{"\r\n            The path to the assembly. Null in the case of in-memory assemblies, where we then use assembly identity.\r\n            ":"\r\n            组装的路径。在内存组件的情况下为null，然后使用汇编身份。\r\n            \r\n","\r\n            Gets the active ":"\r\n            获得活动\r\n","\r\n            The actual editor completion item associated with this ":"\r\n            与此关联的实际编辑器完成项目\r\n","\r\n            Helpers shared by both the text service and the editor service\r\n            ":"\r\n            文本服务和编辑服务共享的帮助者\r\n            \r\n","overloads":"超载\r\n","Both partial method declarations must have identical accessibility modifiers.":"两种部分方法声明都必须具有相同的可访问性修饰符。\r\n","\r\n Performs interface mapping to determine which symbol in this type or a base type\r\n actually implements a particular interface member.\r\n ":"\r\n 执行接口映射以确定此类型或基本类型中的哪个符号\r\n 实际实现了特定的接口成员。\r\n \r\n","\r\n            Navigate to the first source location of a given symbol.\r\n            ":"\r\n            导航到给定符号的第一个源位置。\r\n            \r\n","\r\n The value for the FinallyStatement property.\r\n ":"\r\n 最终统计属性的值。\r\n \r\n","\r\n Given a type parameter declaration, get the corresponding type parameter symbol.\r\n ":"\r\n 给定类型参数声明，获取相应的类型参数符号。\r\n \r\n","\r\n The syntax trees explicitly given to the compilation at creation, in ordinal order.\r\n ":"\r\n 语法树以序数顺序明确地给出了汇编。\r\n \r\n","\r\n Represents an array type, such as \"A() or \"A(,)\", without bounds specified for\r\n the array.\r\n ":"\r\n 表示数组类型，例如“ A（）或“ A（）”，没有指定的界限\r\n 数组。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' is not valid on a member variable declaration..\r\n":"\r\n  在成员变量声明上查找类似于“ {0}”的本地化字符串。\r\n\r\n","\r\n Get method body diagnostics for the entire compilation. This includes diagnostics only from \r\n the bodies of methods and initializers. These diagnostics are NOT cached, so calling this method a second time\r\n repeats significant work.\r\n ":"\r\n 获取整个汇编的方法身体诊断。这仅包括来自\r\n 方法和初始化器的身体。这些诊断没有缓存，因此第二次称此方法\r\n 重复大量工作。\r\n \r\n","The item to get the description for.":"获取描述的项目。\r\n","\r\n The expression denoting the step increment.\r\n ":"\r\n 表示步骤增量的表达式。\r\n \r\n","\r\n The value for the JoinKeyword property.\r\n ":"\r\n JOINKEYWORD属性的值。\r\n \r\n","\r\n Set current result according to a given symbol    \r\n ":"根据给定符号设置当前结果\r\n \r\n","\r\n            The opening brace character to be inserted at the opening position.":"\r\n            开放式支架角色要插入开放位置。\r\n","Add project reference to '{0}'.":"将项目引用添加到“ {0}”中。\r\n","\r\n Returns true if there is any applied RuntimeCompatibilityAttribute assembly attribute for this module.\r\n ":"\r\n 如果有任何适用的runtimeCompatibilityAttribute Assembly属性，则返回true。\r\n \r\n"," with references added.\r\n            ":" 添加了参考。\r\n            \r\n"," is null or contains a null reference.":" 为null或包含零引用。\r\n","\r\n The argument list, if present.\r\n ":"\r\n 参数列表，如果存在。\r\n \r\n","\r\n An optional minus for On Error Goto -1\r\n ":"\r\n 可选的减去错误goto -1\r\n \r\n","\r\n Declare an implicit local variable. The type of the local is determined\r\n by the type character (if any) on the variable.\r\n ":"\r\n 声明隐式局部变量。确定本地的类型\r\n 由变量上的类型字符（如果有）。\r\n \r\n","\r\n Returns a copy of this with the InheritsKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 将其返回此副本，并将其更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            Indicates the reference should be marked as used.\r\n            ":"\r\n            指示该参考应标记为使用。\r\n            \r\n"," with all metadata fields filled.\r\n            ":" 所有元数据田都充满了。\r\n            \r\n","The third condition is not checked for ":"未检查第三个条件\r\n","\r\n  Looks up a localized string similar to Events declared with an 'As' clause must have a delegate type..\r\n":"\r\n  查找类似于声明的事件的本地化字符串，“ AS”子句必须具有委托类型。\r\n\r\n","Updating the underlying type of {0} requires restarting the application.":"更新{0}的基础类型需要重新启动应用程序。\r\n","\r\n The expression on the left-hand-side of the \".\", \".@\" or \"...\" .\r\n ":"\r\n “。”，“。@”或“ ...”的左侧的表达式。\r\n \r\n","\r\n            Try to find all constructors in ":"\r\n            尝试查找所有构造函数 \r\n"," Hash structure fields as we may query them many times ":" 哈希结构字段，因为我们可能会多次查询它们\r\n","\r\n The \"!\" type character.\"\r\n ":"\r\n 这 ”！”类型字符。”\r\n \r\n","\r\n The element type of the array being created.\r\n ":"\r\n 正在创建的数组的元素类型。\r\n \r\n","<element name> :":"<元素名称>：\r\n","\r\n            This set contains the full names of types that have equivalent predefined names in the language.\r\n            ":"\r\n            该集合包含语言中具有等效预定义名称的类型的完整名称。\r\n            \r\n","\r\n  Looks up a localized string similar to '{0}' is not a valid name and cannot be used as the root namespace name..\r\n":"\r\n  查找类似于“ {0}”不是有效名称的本地化字符串，不能用作root namespace名称。\r\n\r\n","\r\n Compares the namespace and type name with the attribute's namespace and type name.  Returns true if they are the same.\r\n ":"\r\n 将命名空间和键入名称与属性的名称空间和键入名称进行比较。如果它们是相同的，则返回真实。\r\n \r\n","\r\n  Looks up a localized string similar to Array initializer has {0} too many elements..\r\n":"\r\n  查找类似于数组初始器的本地化字符串{0}元素太多。\r\n\r\n","\r\n Symbol for the ConstructedFrom type.\r\n      A(Of Integer).B(Of ) for A(Of Integer).B(Of Integer),\r\n      A(Of Integer).B.C(Of ) for A(Of Integer).B.C(Of Integer)\r\n \r\n All types in its containership hierarchy must be either constructed or non-generic, or original definitions.\r\n ":"\r\n 构造类型的符号。\r\n      a（integer）.b（of）f for A（Integer）.b（of Integer），\r\n      a（integer）的（of）a（integer）.b.c（of Integer）（of Integer）\r\n \r\n 其集装箱层次结构中的所有类型都必须构建或非代理或原始定义。\r\n \r\n","'s that delegate to ":"委派\r\n","\r\n Represents a compiler generated field used to implement static locals.\r\n There are two kind of fields: the one, that holds the value, and the one, that holds initialization \"flag\".\r\n ":"\r\n 代表用于实现静态当地人的编译器生成的字段。\r\n 有两种字段：一个具有值的值，一个字段，一个具有初始化“标志”的字段。\r\n \r\n","The navigation target for the text, or ":"文本的导航目标，或\r\n"," must start with a node and alternate between nodes and separator tokens.\r\n ":" 必须从节点和分离器令牌之间的节点和交替开始。\r\n \r\n"," could be used as an Expression in ExpressionStatement\r\n            ":" 可以用作表达阶段的表达\r\n            \r\n","\r\n  Looks up a localized string similar to '{0}' is an assembly and cannot be referenced as a module..\r\n":"\r\n  查找类似于“ {0}”的本地化字符串是一个汇编，不能称为模块。\r\n\r\n","\r\n A Named type is an extensible interface if both the following are true:\r\n (a) It is an interface type and\r\n (b) It is either marked with 'TypeLibTypeAttribute( flags w/o TypeLibTypeFlags.FNonExtensible )' attribute OR\r\n     is marked with 'InterfaceTypeAttribute( flags with ComInterfaceType.InterfaceIsIDispatch )' attribute OR\r\n     inherits from an extensible interface type.\r\n Member resolution for Extensible interfaces is late bound, i.e. members are resolved at run time by looking up the identifier on the actual run-time type of the expression. \r\n ":"\r\n 如果两者都是正确的，则指定类型是可扩展的接口：\r\n （a）它是接口类型，\r\n （b）它要么标记为'typelibtypeattribute（w/o typelibtypeflags.fnonextensible）'属性或\r\n     用“ InterfaceTypeAttribute（带有cominterfacetype.interfaceisidispatch的标志）标记”属性或\r\n     从可扩展的接口类型继承。\r\n 可扩展接口的成员分辨率延迟绑定，即通过查找表达式实际运行时类型的标识符，在运行时间解决成员。\r\n \r\n","\r\n            Used to store the doc comment for some operators/conversions.  This is because some of them will be\r\n            synthesized, so there will be no symbol we can recover after the fact in ":"用于存储一些操作员/转换的DOC评论。这是因为其中一些会\r\n            合成的，因此事实之后我们将没有符号可以恢复\r\n","Cannot use local variable or local function '{0}' declared in a top-level statement in this context.":"在此上下文中，无法使用在顶级语句中声明的本地变量或本地函数'{0}'。\r\n","\r\n The value for the WhileOrUntilClause property.\r\n ":"theroruntilclause属性的值。\r\n \r\n","\r\n            Reported when a file header is missing or does not match the expected string.\r\n            ":"\r\n            报告时缺少文件标头或与预期字符串不匹配时报告。\r\n            \r\n","\r\n            Calculates unmapped active statement spans in the ":"\r\n            计算未映射的活动语句跨越\r\n","\r\n Creates the syntax representation of an exception element within xml documentation comments.\r\n ":"\r\n 在XML文档注释中创建异常元素的语法表示。\r\n \r\n","\r\n Returns a copy of this with the Nullable property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此的副本，而无效的属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Returns result type of the operator or SpecialType.None if operator is not supported.\r\n ":"\r\n 返回运算符或专业类型的结果类型。如果不支持操作员。\r\n \r\n","CallerArgumentExpressionAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'":"无法应用CallerArgumentExpressepresseptressextribute，因为从类型'{0}'type'{1}'类型中没有标准转换\r\n","null pointer constant pattern":"空指针常数模式\r\n","\r\n            Returns true, if the variable could be either passed as a parameter\r\n            to the new local function or the local function can capture the variable.\r\n            ":"\r\n            返回true，如果可以将变量作为参数传递\r\n            对于新的本地函数或本地函数可以捕获变量。\r\n            \r\n"," or\r\n            It will create new ":" 或者\r\n            它将创建新的\r\n","\r\n Gets the method group for a given method name. Returns Nothing if no methods found.\r\n ":"\r\n 获取给定方法名称的方法组。如果找不到方法，则什么都没有返回。\r\n \r\n"," Cache of created anonymous delegates ":" 创建匿名委托的缓存\r\n","\r\n            The rationale is that when user selects e.g. entire local declaration statement [|var a = b;|] it is reasonable\r\n            to provide refactoring for `b` node. Similarly for other types of refactorings.\r\n            ":"\r\n            理由是当用户选择例如整个本地声明语句[| var a = b; |]这是合理的\r\n            为`b`节点提供重构。类似于其他类型的重构。\r\n            \r\n","\r\n Returns a copy of this with the EndKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而EndKeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n A list of array modifiers such as \"()\" or \"(,)\". If no array modifiers were\r\n present, an empty list is returned.\r\n ":"\r\n 诸如“（）”或“（）”等数组修饰符的列表。如果没有阵列修饰符\r\n 现在，返回一个空列表。\r\n \r\n","\r\n            A provider that produces ":"\r\n            生产的提供商\r\n","\r\n Determines whether the given conversion is CLR supported conversion or not.\r\n ":"\r\n 确定给定的转换是否为CLR支持转换。\r\n \r\n"," to be used to resolve source of scripts referenced via #load directive.\r\n            ":" 用于解决通过#load指令引用的脚本源。\r\n            \r\n","The optional key character that caused the commit.":"导致提交的可选关键角色。\r\n","\r\n Represents an Imports statement, which has one or more imports clauses.\r\n ":"\r\n 代表一个Imports语句，该语句具有一个或多个导入条款。\r\n \r\n","\r\n Information decoded from early well-known custom attributes applied on a type.\r\n ":"\r\n 从应用于类型的早期众所周知的自定义属性解码的信息。\r\n \r\n"," instance--internal for TypeScript.\r\n            ":" 实例 - 对于打字稿的内部。\r\n            \r\n","The \"f\" custom format specifier represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value.\r\n            \r\n            If the \"f\" format specifier is used without other format specifiers, it's interpreted as ...":"“ F”自定义格式指定符表示秒数中最重要的数字；也就是说，它代表日期和时间值的十分之一。\r\n            \r\n            如果“ F”格式指定符在没有其他格式指定符的情况下使用，则将其解释为...\r\n"," is selected.\r\n            ":" 选择。\r\n            \r\n","\r\n  Looks up a localized string similar to Delegate class '{0}' has no Invoke method, so an expression of this type cannot be the target of a method call..\r\n":"\r\n  查找类似于委托类'{0}'的本地化字符串没有调用方法，因此这种类型的表达式不能是方法调用的目标。\r\n\r\n","\r\n Return the alias imports for this file. May return Nothing if there are no alias imports.\r\n May contain aliases with error type targets.\r\n ":"\r\n 返回此文件的别名导入。如果没有别名进口，可能不会返回。\r\n 可能包含具有错误类型目标的别名。\r\n \r\n","\r\n Can mutate for a query lambda from ReturnTypePendingDelegate \r\n to the return type of the target delegate.\r\n ":"\r\n 可以从returnTypependingDelegate突变为查询lambda\r\n 到目标委托的返回类型。\r\n \r\n","\r\n Returns a copy of this with the LocalName property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中LocalName属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n             Produces a ":"\r\n             产生a\r\n","\r\n            SearchScope used for searching *only* the source symbols contained within a project/compilation.\r\n            i.e. symbols from metadata will not be searched.\r\n            ":"\r\n            用于搜索 *仅 *项目/汇编中包含的源符号。\r\n            即不会搜索来自元数据的符号。\r\n            \r\n","\r\n The value for the Items property.\r\n ":"\r\n 项目属性的值。\r\n \r\n","\r\n A statement that declares a constructor. This statement will be the Begin of a\r\n BlockStatement with Kind=MethodDeclarationBlock, and the body of the method\r\n will be the Body of that BlockStatement.\r\n ":"\r\n 宣布构造函数的声明。该声明将是一个开始\r\n 带有bink = methoddeclaration block的区块陈述，该方法的主体\r\n 将是该块的主体。\r\n \r\n","\r\n The optional Step clause.\r\n ":"\r\n 可选步骤子句。\r\n \r\n","The set of options in effect.":"一组有效的选项。\r\n","\r\n True if this is a reference to an ":"\r\n 如果这是对\r\n","\r\n            ```\\1```\r\n            ":"\r\n            ````\\ 1''\r\n            \r\n","\r\n            Searches for extension methods exactly called 'Add'.  Returns\r\n            ":"\r\n            搜索完全称为“添加”的扩展方法。返回\r\n            \r\n","\r\n            Represents a syntax tree that only has a weak reference to its \r\n            underlying data.  This way it can be passed around without forcing\r\n            the underlying full tree to stay alive.  Think of it more as a \r\n            key that can be used to identify a tree rather than the tree itself.\r\n            ":"\r\n            表示只有对其的语法树\r\n            基础数据。这样，它可以通过不强迫传递\r\n            基础的全树生存。更多地将其视为\r\n            可用于识别树而不是树本身的钥匙。\r\n            \r\n","\r\n If the passed in type is a System.Linq.Expressions.Expression(Of D) for a delegate type D, return True\r\n ":"\r\n 如果类型中传递的是system.linq.expressions.expressions.exexpression（d）的代表类型D，请返回true\r\n \r\n","Null if the method is a compiler generated method that shouldn't be displayed to the user.":"null如果该方法是编译器生成的方法，则不应向用户显示。\r\n","\r\n  Looks up a localized string similar to \r\n    '{0}' inherits from '{1}'..\r\n":"\r\n  查找类似于\r\n    '{0}'从'{1}'..继承。\r\n\r\n","\r\n A declaration table is a device which keeps track of type and namespace declarations from\r\n parse trees. It is optimized for the case where there is one set of declarations that stays\r\n constant, and a specific root namespace declaration corresponding to the currently edited\r\n file which is being added and removed repeatedly. It maintains a cache of information for\r\n \"merging\" the root declarations into one big summary declaration; this cache is efficiently\r\n re-used provided that the pattern of adds and removes is as we expect.\r\n ":"\r\n 声明表是一种可以跟踪类型和名称空间声明的设备\r\n 解析树。它针对有一组声明的情况进行了优化\r\n 常数，以及与当前编辑相对应的特定根名称空间声明\r\n 正在反复添加和删除的文件。它保留了一系列信息\r\n 将根宣言“合并”成一个大摘要声明；这个缓存有效\r\n 重复使用的是，添加和删除的模式是我们预期的。\r\n \r\n","Warning: Changing namespace may produce invalid code and change code meaning.":"警告：更改名称空间可能会产生无效的代码并更改代码含义。\r\n","To determine the conversion between two types (instead of an expression and a\r\n type), use Compilation.ClassifyConversion.":"确定两种类型之间的转换（而不是表达式和​​一个\r\n 类型），使用Compilation.ClassifyConversion。\r\n","\r\n Create binder for binding statements in speculative code. \r\n ":"\r\n 创建用于投机代码中的绑定语句的活页夹。\r\n \r\n","\r\n            If namespace can be changed, returns a list of documents that linked to the provided document (including itself)\r\n            and the corresponding container nodes in each document, which will later be used for annotation. Otherwise, a \r\n            default ImmutableArray is returned. Currently we only support linked document in multi-targeting project scenario.\r\n            ":"\r\n            如果可以更改命名空间，请返回链接到提供的文档的文档列表（包括本身）\r\n            每个文档中的相应容器节点，后来将用于注释。否则，\r\n            返回默认的ImmutableArray。目前，我们仅支持多目标项目方案中的链接文档。\r\n            \r\n"," are not tested\r\n             by this method.":" 未经测试\r\n             通过这种方法。\r\n","\r\n Can type be accessed through container's inheritance?\r\n ":"\r\n 可以通过容器的继承访问类型吗？\r\n \r\n","\r\n            Version of the diagnostic data.\r\n            ":"\r\n            诊断数据的版本。\r\n            \r\n","\r\n            Additional properties that can be attached to the definition for clients that want to\r\n            keep track of additional data.\r\n            ":"\r\n            可以将要附加到定义的其他属性\r\n            跟踪其他数据。\r\n            \r\n",". When true, we assume any\r\n            variable we don't understand has ":"。如果是真的，我们假设\r\n            我们不了解的变量\r\n","\r\n A list of all the type arguments.\r\n ":"\r\n 所有类型参数的列表。\r\n \r\n","\r\n            Returns a document with frozen partial semantic unless we already have a complete compilation available.\r\n            Getting full semantic could be costly in certains scenarios and would cause significant delay in completion. \r\n            In most cases we'd still end up with complete document, but we'd consider it an acceptable trade-off even when \r\n            we get into this transient state.\r\n            ":"\r\n            除非我们已经有完整的汇编，否则返回带有冷冻部分语义的文档。\r\n            在某些情况下，获得完整的语义可能会很昂贵，并且会大大延迟完成。\r\n            在大多数情况下，我们仍然会得到完整的文件，但是即使\r\n            我们进入了这种瞬态状态。\r\n            \r\n","The AddressOf expression node.":"表达节点的地址。\r\n"," to an equivalent ":" 等效\r\n","\r\n            get type of the range variable symbol\r\n            ":"\r\n            获取范围变量符号的类型\r\n            \r\n","\r\n It is illegal to jump into blocks that reference lifted variable\r\n as that could leave closure frames of the target block uninitialized.\r\n \r\n The fact that closure could be created as high as the declaration level of the variable\r\n and well above goto block (thus making the jump safe) is considered an optional optimization \r\n and ignored. \r\n For the purpose of this analysis just having lifting lambdas already means \r\n that block may require initialization and cannot be jumped into.\r\n \r\n Note that when you are jumping into a block you are essentially jumping into ALL blocks\r\n on the path from LowestCommonAncestor(goto, label) to the actual label block.\r\n ":"\r\n 跳入引用抬起变量的块是非法的\r\n 因为那可能会留下目标块的封闭框架，而是不可初学的。\r\n \r\n 可以创建闭合与变量的声明级别一样高的事实\r\n 远高于goto块（因此使跳跃安全）被认为是可选的优化\r\n 并被忽略。\r\n 出于这种分析的目的\r\n 该块可能需要初始化，不能跳入。\r\n \r\n 请注意，当您跳入一个块时，您实际上是跳入所有块\r\n 从LowestCommonancestor（Goto，标签）到实际标签块的路径上。\r\n \r\n","\r\n Returns the type symbol for a forwarded type based its canonical CLR metadata name.\r\n The name should refer to a non-nested type. If type with this name Is Not forwarded,\r\n null Is returned.\r\n ":"\r\n 返回基于转发类型的类型符号，其规范CLR元数据名称。\r\n 该名称应指无巢类型。如果没有转发此名称的类型，\r\n null返回。\r\n \r\n","\r\n Determines whether the specified object is equal to the current object.\r\n ":"\r\n 确定指定的对象是否等于当前对象。\r\n \r\n"," that sits on top of a \r\n            ":" 那坐在\r\n            \r\n","\r\n            ```\\uFFFF``` escape.\r\n            ":"\r\n            ````\\ uffff''逃脱。\r\n            \r\n"," with the appropriate exit\r\n ":" 有适当的出口\r\n \r\n","\r\n  Looks up a localized string similar to Embedded interop method '{0}' contains a body..\r\n":"\r\n  查找类似于嵌入式Interop方法'{0}'的局部字符串包含一个主体。\r\n\r\n","Convert 'typeof' to 'nameof'":"将“ typeof”转换为“名称”\r\n","\r\n Base class for object, array and anonymous object creation expressions\r\n ":"\r\n 对象，数组和匿名对象创建表达式的基类\r\n \r\n","\r\n Base type as \"declared\".\r\n Declared base type may contain circularities.\r\n \r\n If DeclaredBase must be accessed while other DeclaredBases are being resolved, \r\n the bases that are being resolved must be specified here to prevent potential infinite recursion.\r\n ":"\r\n 基本类型为“声明”。\r\n 声明的基本类型可能包含圆形。\r\n \r\n 如果必须在解决其他声明基键时访问声明基础，则\r\n 必须在此处指定正在解决的基础，以防止潜在的无限递归。\r\n \r\n","Dim a,b As New T":"昏暗的A，B为新T\r\n","\r\n The \"End\" keyword\r\n ":"\r\n “结束”关键字\r\n \r\n","\r\n  Looks up a localized string similar to 'Exit Do' can only appear inside a 'Do' statement..\r\n":"\r\n  查找类似于“退出do”的本地化字符串只能出现在“ do”语句中。\r\n\r\n","non-white-space character":"非白色空间字符\r\n","\r\n            Whether this region should be collapsed by default when a file is opened the first time.\r\n            ":"\r\n            第一次打开文件时，默认情况下应折叠此区域。\r\n            \r\n","Live":"居住\r\n","\r\n  Looks up a localized string similar to Attribute member '{0}' cannot be the target of an assignment because it is not declared 'Public'..\r\n":"\r\n  查找类似于属性成员'{0}'的本地化字符串不能成为分配的目标，因为它没有声明为'public'。\r\n\r\n","\r\n A mapping from every parameter to its replacement parameter. Local variables \r\n are replaced when their types change due to being inside of a lambda.\r\n ":"\r\n 从每个参数到其替换参数的映射。本地变量\r\n 由于在Lambda内部发生变化时，被替换。\r\n \r\n","After an XML axis property qualifier (. or ...).":"XML轴属性预选赛（。或...）之后。\r\n","The \"ddd\" custom format specifier represents the abbreviated name of the day of the week. The localized abbreviated name of the day of the week is retrieved from the DateTimeFormatInfo.AbbreviatedDayNames property of the current or specified culture.":"“ DDD”自定义格式指定符表示一周中的缩写名称。从dateTimeFormatinfo中检索了本周一天的局部缩写名称。当前或指定文化的AbbreviatedDaynames属性。\r\n","while (...);":"尽管 （...）;\r\n","generated code is overlapping with hidden portion of the code":"生成的代码与代码的隐藏部分重叠\r\n","\r\n Full type name, possibly with generic name mangling.\r\n ":"完整的名称，可能带有通用名称。\r\n \r\n","\r\n Returns true if the binder is binding top-level script code.\r\n ":"\r\n 如果粘合剂绑定顶级脚本代码，则返回true。\r\n \r\n","\r\n Rewrites a built-in conversion. Doesn't handle user-defined conversions or Nothing literals.\r\n ":"\r\n 重写内置的转换。无法处理用户定义的转换或没有文字。\r\n \r\n","expression to be used into the last 'select ...' in the query expression":"在查询表达式中使用的表达式要用于最后一个“选择...”\r\n"," was modified.\r\n ":" 被修改了。\r\n \r\n","\r\n Returns a copy of this with the Label property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，标签属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","other, surrogate":"其他，代理\r\n","\r\n The filter expression to be evaluated.\r\n ":"\r\n 要评估的滤波器表达式。\r\n \r\n","GetHashCode":"gethashcode\r\n","The using directive appeared previously as global using":"使用指令以前以全局形式出现\r\n","\r\n A MergedNamespaceSymbol represents a namespace that merges the contents of two or more other\r\n namespaces. Any sub-namespaces with the same names are also merged if they have two or more\r\n instances.\r\n \r\n Merged namespaces are used to merged the symbols from multiple metadata modules and the source \"module\"\r\n into a single symbol tree that represents all the available symbols. The compiler resolves names\r\n against Me merged set of symbols.\r\n \r\n Typically there will not be very many merged namespaces in a Compilation: only the root namespaces and\r\n namespaces that are used in multiple referenced modules. (Microsoft, System, System.Xml,\r\n System.Diagnostics, System.Threading, ...)\r\n ":"\r\n 合并的namespaceSymbol代表一个命名空间，该空间合并了两个或更多其他的内容\r\n 名称空间。如果有两个或更多的子名称，则具有相同名称的任何子名称空间也可以合并\r\n 实例。\r\n \r\n 合并的名称空间用于合并来自多个元数据模块和源“模块”的符号\r\n 进入表示所有可用符号的单个符号树。编译器解决名称\r\n 反对我合并了一组符号。\r\n \r\n 通常，汇编中不会有很多合并的名称空间：只有根名称空间和\r\n 在多个引用模块中使用的名称空间。 （Microsoft，System，System.xml，\r\n System.Diagnostics，System.Threading，...）\r\n \r\n","\r\n Single line subs only have a single statement.  However, when binding it is convenient to have a statement list.  For example,\r\n dim statements are not valid in a single line lambda.  However, it is nice to be able to provide semantic info about the local.\r\n The only way to create locals is to have a statement list. This method is friend because the statement list should not be part\r\n of the public api.\r\n ":"\r\n 单线subs只有一个语句。但是，在绑定时，很容易获得语句列表。例如，\r\n 在单行lambda中，二光语句无效。但是，能够提供有关本地的语义信息真是太好了。\r\n 创建当地人的唯一方法是拥有一个语句列表。此方法是朋友，因为语句列表不应该是一部分\r\n 公共API。\r\n \r\n","\r\n Returns a copy of this with the LessThanSlashToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，而Lessthanslashtoken属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n The keyword describing the block to exit.\r\n ":"\r\n 描述要退出的块的关键字。\r\n \r\n"," being processed.  If not, we don't do the\r\n             actual registration.\r\n             ":" 正在处理。如果没有，我们不做\r\n             实际注册。\r\n             \r\n","\r\n Returns a copy of this with the Body property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，而主体属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n Flag to indicate if this is a shared constructor or an instance constructor.\r\n ":"\r\n 标志以指示这是共享构造函数还是实例构造函数。\r\n \r\n","\r\n            A factory for creating and running C# scripts.\r\n            ":"\r\n            用于创建和运行C＃脚本的工厂。\r\n            \r\n","\r\n This method should be kept consistent with MethodBodySynthesizer.ConstructStringSwitchHashFunctionBody\r\n The control flow in this method mimics lowered \"for\" loop. It is exactly what we want to emit\r\n to ensure that JIT can do range check hoisting.\r\n ":"该方法应与MethodbodySynthesizer.constructStringsWitchHashFunction Body保持一致\r\n 此方法中的控制流模拟降低“为”循环。这正是我们想要发出的\r\n 为了确保JIT可以进行范围检查提升。\r\n \r\n","day of the week (full)":"一周中的一天（满）\r\n","\r\n            Searches for extension methods exactly called 'Select'.  Returns\r\n            ":"\r\n            搜索完全称为“选择”的扩展方法。返回\r\n            \r\n","\r\n Variables that were initialized or written anywhere.\r\n ":"\r\n 在任何地方初始化或编写的变量。\r\n \r\n","\r\n The value for the OnKeyword property.\r\n ":"\r\n OnKeyWord属性的值。\r\n \r\n","\r\n Represents an expression that creates a new array.\r\n ":"\r\n 代表创建新数组的表达式。\r\n \r\n"," represents the updated symbol in both compilations.\r\n            \r\n            We use ":" 表示两个汇编中的更新符号。\r\n            \r\n            我们用\r\n","\r\n Retargeting map from underlying module to the retargeting module.\r\n ":"\r\n 从基础模块重新定位地图到重新定位模块。\r\n \r\n","Assembly":"集会\r\n","\r\n            Common implementation of all ":"\r\n            所有人的共同实施\r\n","\r\n            so that the given ":"\r\n            以便给定\r\n","\r\n            Returns the list of using directives that affect ":"\r\n            返回使用影响的指令列表\r\n","\r\n  Looks up a localized string similar to 'End Event' must be preceded by a matching 'Custom Event'..\r\n":"\r\n  查找类似于“结束事件”的本地化字符串必须在匹配的“自定义事件”之前。\r\n\r\n","The containing type for the synthesized constructor.":"合成构造函数的包含类型。\r\n","\r\n            Returns the text changes necessary to format the document.  If \"textSpan\" is provided,\r\n            only the text changes necessary to format that span are needed.\r\n            ":"\r\n            返回文本更改以格式化文档。如果提供了“ textspan”，\r\n            只有需要更改格式的跨度所需的文本。\r\n            \r\n","\r\n True if implicit variable declaration is available within this binder, and the binder\r\n has already finished binding all possible implicit declarations inside (and is not accepting)\r\n any more.\r\n ":"\r\n 如果有隐式变量声明在此活页夹中可用，则是正确的，并且活页夹\r\n 已经完成了内部所有可能的隐式声明的绑定（并且不接受）\r\n 再加上。\r\n \r\n","The \"t\" custom format specifier represents the first character of the AM/PM designator. The appropriate localized designator is retrieved from the DateTimeFormatInfo.AMDesignator or DateTimeFormatInfo.PMDesignator property of the current or specific cultur ...":"“ T”自定义格式指定符表示AM/PM指定器的第一个字符。从dateTimeFormatinfo.amdesignator或dateTimeFormatinfo.pmdesignator属性中检索适当的本地化指定器...\r\n","\r\n Crumbles currently available node (if available) into its components.\r\n The leftmost child becomes the current node.\r\n If operation is not possible (node has no children, there is no node), then returns false.\r\n ":"\r\n 当前可用的节点（如果可用）到其组件中。\r\n 最左边的孩子成为当前节点。\r\n 如果无法操作（节点没有孩子，没有节点），则返回false。\r\n \r\n","\r\n Scan tokens inside of <!DOCTYPE ... >\r\n ":"\r\n <！Doctype ...>内部的扫描令牌\r\n \r\n","\r\n The \"?\" token that indicates a nullable type.\r\n ":"\r\n 这 ”？”表示无效类型的令牌。\r\n \r\n","\r\n            Code refactoring that converts a regular string containing braces to an interpolated string\r\n            ":"代码重构将包含牙套的常规字符串转换为插值字符串\r\n            \r\n"," returns false since the statement is not a LINQ query\r\n 2. ":" 返回false，因为该语句不是LINQ查询\r\n 2。\r\n","\r\n The \"Ascending\" or \"Descending\" keyword, if present. To determine whether to\r\n sort in ascending or descending order, checking the Kind property is easier.\r\n ":"\r\n 如果存在，则“上升”或“下降”关键字。确定是否\r\n 按上升或下降顺序排序，检查该属性的属性更容易。\r\n \r\n","\r\n Updates access kind. To clear the access kind,\r\n 'newAccessKind' should be Unknown. Otherwise, the current\r\n access kind should be Unknown or equal to 'newAccessKind'.\r\n ":"\r\n 更新访问类型。要清除访问类型，\r\n “ newaccesskind”应该是未知的。否则，电流\r\n 访问类型应未知或等于“ newAccesskind”。\r\n \r\n","\r\n            Moves the trailing trivia from the node's previous token to the end of the node\r\n            ":"将尾随的琐事从节点的前令牌移至节点的末尾\r\n            \r\n"," representing the specific kind of ExitStatementSyntax.\r\n One of ExitDoStatement, ExitForStatement, ExitSubStatement,\r\n ExitFunctionStatement, ExitOperatorStatement, ExitPropertyStatement,\r\n ExitTryStatement, ExitSelectStatement, ExitWhileStatement.\r\n ":" 代表特定类型的exitstatementsyntax。\r\n 出口，出口，出口，退出，\r\n 出口仪，出口术，exitpropertystatement，\r\n 出口，退出statement，出口。\r\n \r\n"," representing the specific kind of\r\n LiteralExpressionSyntax. One of CharacterLiteralExpression,\r\n TrueLiteralExpression, FalseLiteralExpression, NumericLiteralExpression,\r\n DateLiteralExpression, StringLiteralExpression, NothingLiteralExpression.\r\n ":" 代表特定种类\r\n LILUTALEXPRESSIONSYNTAX。角色Literalexpression之一，\r\n trueliteralexpression，falseliteralexpression，numericLiteralexpression，\r\n dateLiteralexpression，StringLiteralexpression，NotherTliterAleaxPression。\r\n \r\n","\r\n  Looks up a localized string similar to Anonymous type member property '{0}' cannot be used to infer the type of another member property because the type of '{0}' is not yet established..\r\n":"\r\n  查找类似于匿名类型成员属性'{0}'的本地化字符串，不能用于推断另一个成员属性的类型，因为尚未确定'{0}'的类型。\r\n\r\n","\r\n The value for the Accessors property.\r\n ":"\r\n 配件属性的值。\r\n \r\n","\r\n            Internal for testing.\r\n            ":"\r\n            内部测试。\r\n            \r\n","\r\n Represents a backing field of WithEvents property. \r\n Attributes applied on the property syntax are applied on the backing field.\r\n ":"\r\n 代表事件属性的背景字段。\r\n 应用于属性语法上的属性在衬板上应用。\r\n \r\n","? . Name (ArgList)":"？ 。名称（arglist）\r\n","\r\n Named (property value) arguments on the attribute. \r\n ":"\r\n 命名（属性值）属性上的参数。\r\n \r\n"," this bucket is associated with.\r\n            ":" 这个水桶与。\r\n            \r\n"," implementation so that it can be discovered by the host.\r\n            ":" 实现，以便主机可以发现它。\r\n            \r\n","\r\n Takes two expressions and makes sequence.\r\n ":"\r\n 接受两个表达式并制作序列。\r\n \r\n","\r\n            Display parts to show after the normal display parts for the parameter.\r\n            ":"显示零件在正常显示零件之后显示参数。\r\n            \r\n","\r\n The \"Catch\" keyword.\r\n ":"\r\n “捕获”关键字。\r\n \r\n","Returns a Conversion object that summarizes whether the conversion was possible, and if so, what\r\n kind of conversion it was. If no conversion was possible, a Conversion object with a false \"Exists \"\r\n property is returned.":"返回一个转换对象，该对象总结了是否可能进行转换，如果是，则\r\n 有点转换。如果无法进行转换，则具有错误“存在”的转换对象\r\n 属性退还。\r\n","\r\n Owning AssemblySymbol. This can be a PEAssemblySymbol or a SourceAssemblySymbol.\r\n ":"\r\n 拥有汇编符号。这可以是peassemblysymbol或源切除术。\r\n \r\n","\r\n Simpler helper for binary expressions.\r\n When operand are boolean, the result type is same as operand's and is never checked \r\n so do not need to pass that in.\r\n ":"\r\n 二进制表达式的更简单的助手。\r\n 当操作数为布尔值时，结果类型与操作数相同，并且从不检查 \r\n 所以不需要传递。\r\n \r\n","The optional as clause":"可选为子句\r\n"," Calculates the flag of being already reported; for structure types\r\n the slot may be reported if ALL the children are reported ":" 计算已经报告的旗帜；对于结构类型\r\n 如果报告所有孩子，可能会报告插槽\r\n","Use {0}":"使用{0}\r\n"," Output the corresponding parameter type of\r\n             \"targetArgument\" if function returns true":" 输出相应的参数类型\r\n             “ targetArgument”如果函数返回true\r\n"," that represents the state after running the script, including all declared variables and return value.":" 这代表运行脚本后的状态，包括所有声明的变量和返回值。\r\n","\r\n The name of the event being declared.\r\n ":"\r\n 事件的名称被声明。\r\n \r\n"," to be used for full solution analysis.\r\n            ":" 用于完整的解决方案分析。\r\n            \r\n","\r\n            Tried to find a public, non-static, int-returning property in the given type with the\r\n            specified ":"\r\n            试图在给定类型中找到公共，非静态的，返回的属性\r\n            指定的\r\n","\r\n            Continues the script with given ":"\r\n            以给定的脚本继续\r\n","\r\n            Reads document checksum.\r\n            ":"\r\n            读取文档校验和。\r\n            \r\n","\r\n Will set only bits used for delegate relaxation level.\r\n ":"\r\n 将仅设置用于委托放松水平的位。\r\n \r\n","\r\n Gets the ":"得到\r\n","\r\n Binds a call expression for a given top level object collection initializer.\r\n ":"绑定给定顶级对象收集初始化器的呼叫表达式。\r\n \r\n","\r\n Symbol commented with the documentation comment handled by this binder. In general,\r\n all name lookup is being performed in context of this symbol's containing symbol.\r\n We still need this symbol, though, to be able to find type parameters or parameters\r\n referenced from 'param', 'paramref', 'typeparam' and 'typeparamref' tags.\r\n ":"\r\n 符号对此活页夹处理的文档评论进行了评论。一般来说，\r\n 所有名称查找都是在此符号包含符号的上下文中执行的。\r\n 但是，我们仍然需要此符号才能找到类型参数或参数\r\n 从“ param”，“ paramref”，“ typeparam”和“ typeparamref”标签引用。\r\n \r\n"," for the most common kinds.\r\n            ":" 对于最常见的种类。\r\n            \r\n"," Indicates whether or not support of constant expressions (boolean and nothing)\r\n is enabled in this analyzer. In general, constant expressions support is enabled in analysis\r\n exposed to public API consumer and disabled when used from command-line compiler. ":" 指示是否支持恒定表达式（布尔和什么都没有）\r\n 在此分析仪中启用。通常，在分析中启用了恒定表达式支持\r\n 暴露于公共API消费者并在命令行编译器中使用时禁用。\r\n","\r\n Parse one token.\r\n ":"\r\n 解析一个令牌。\r\n \r\n","\r\n Returns a copy of this with the ElementType property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中EmenthType属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n",", between it and any of its existing else-if clauses.\r\n            ":"，在它与其任何其他现有条款之间。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Compare' expected..\r\n":"\r\n  查找类似于“比较”预期的本地化字符串。\r\n\r\n","\r\n A list of statements to be executed. Multiple statements must be separated by\r\n colons.\r\n ":"\r\n 要执行的语句列表。多个陈述必须通过\r\n 结肠。\r\n \r\n","\r\n             Refactor:\r\n                 var o = 1 as object;\r\n            \r\n             Into:\r\n                 var o = (object)1;\r\n             ":"\r\n             重构：\r\n                 var o = 1作为对象;\r\n            \r\n             进入：\r\n                 var o =（对象）1;\r\n             \r\n","Generate parameter '{0}'":"生成参数'{0}'\r\n","finally clause":"最后条款\r\n","\r\n Captures information about illegal access exposure.\r\n ":"\r\n 捕获有关非法访问暴露的信息。\r\n \r\n"," that appears selected in the list presented to the user during suggestion mode.\r\n            Suggestion mode disables autoselection of items in the list, giving preference to the text typed by the user unless a specific item is selected manually.\r\n            Specifying a ":" 在建议模式下，在列表中选择了这一点。\r\n            建议模式禁用列表中项目的自动选择，除非手动选择特定的项目，否则优先考虑用户键入的文本。\r\n            指定\r\n","\r\n            The chunks to normalize and wrap.  The first chunk will be normalized,\r\n            but not wrapped.  Successive chunks will be normalized and wrapped \r\n            appropriately depending on if this is wrap-each or wrap-long.\r\n            ":"\r\n            块以正常化和包裹。第一个块将标准化，\r\n            但没有包裹。连续的块将被标准化和包装\r\n            适当地取决于这是包裹的或包裹长的。\r\n            \r\n","\r\n Assuming there is one, the containing member of the binder is the commented symbol if and only if\r\n the commented symbol is a non-delegate named type.  (Otherwise, it is the containing type or namespace of the commented symbol.)\r\n ":"\r\n 假设有一个，只有且仅当\r\n 评论的符号是一个名为类型的非贵族。 （否则，它是注释符号的包含类型或名称空间。）\r\n \r\n","\r\n Represents a \"Try ... Catch ... Finally ... End Try\" block.\r\n ":"\r\n 表示“尝试...捕获...最后...结束尝试”块。\r\n \r\n","The property symbol that was declared.":"声明的属性符号。\r\n"," Version of CheckAssigned for bound field access ":" 用于绑定字段访问的CheckAssign的版本\r\n","\r\n            reporter that doesn't do anything\r\n            ":"\r\n            没有做任何事情的记者\r\n            \r\n","The updated document":"更新的文档\r\n","\r\n Creates an empty list of syntax nodes.\r\n ":"\r\n 创建一个空语节点的空列表。\r\n \r\n","\r\n The kind of namespace: Module, Assembly or Compilation.\r\n Module namespaces contain only members from the containing module that share the same namespace name.\r\n Assembly namespaces contain members for all modules in the containing assembly that share the same namespace name.\r\n Compilation namespaces contain all members, from source or referenced metadata (assemblies and modules) that share the same namespace name.\r\n ":"\r\n 命名空间的种类：模块，汇编或编译。\r\n 模块名称空间仅包含共享同一名称空间名称的包含模块中的成员。\r\n 汇编名称空间包含共享相同名称名称的包含组件中所有模块的成员。\r\n 编译名称空间包含所有成员，从源或引用的元数据（汇编和模块）共享相同的名称名称。\r\n \r\n",". It also handles incomplete selections\r\n            of tokens gracefully. Over-selection containing leading comments is also handled correctly. \r\n            ":"。它还处理不完整的选择\r\n            优雅的代币。还正确处理包含领先评论的过度选择。\r\n            \r\n","Selection not contained inside a type.":"选择不包含在类型中。\r\n","\r\n            This is for conveying cyclic dependencies to the user, not for detecting them.\r\n            ":"\r\n            这是为了将环状依赖性传达给用户，而不是用于检测它们。\r\n            \r\n","\r\n Represents a curried extension method definition - first parameter and fixed \r\n type parameters removed.\r\n ":"\r\n 表示咖喱扩展方法定义 - 第一个参数和固定\r\n 删除类型参数。\r\n \r\n","not pattern":"不是模式\r\n","\r\n The value for the NewKeyword property.\r\n ":"\r\n NewKeyword属性的值。\r\n \r\n","\r\n If this method is a reduced extension method, gets the extension method definition that\r\n this method was reduced from. Otherwise, returns Nothing.\r\n ":"\r\n 如果此方法是减少的扩展方法，请获取扩展方法定义\r\n 此方法从中降低了。否则，什么都没有。\r\n \r\n","\r\n Represent a Await expression.\r\n ":"\r\n 代表一个等待的表达。\r\n \r\n","\r\n The class to represent all types imported from a PE/module.\r\n ":"\r\n 代表从PE/模块导入的所有类型的类。\r\n \r\n","\r\n The value for the InterfaceMembers property.\r\n ":"\r\n Interfacembers属性的值。\r\n \r\n","\r\n            The individual tagged parts of this section.\r\n            ":"\r\n            本节的单个标记部分。\r\n            \r\n","\r\n The opening curly brace '{' token.\r\n ":"\r\n 开口卷发式'{'令牌。\r\n \r\n","\r\n Print Commandline help message (up to 80 English characters per line)\r\n ":"打印命令行帮助消息（每行最多80个英语字符）\r\n \r\n"," Anonymous type field is declared as a 'Key' field ":" 匿名类型字段被声明为“键”字段\r\n","\r\n Returns a copy of this with the QuestionMarkToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中有质理标记的属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Returns: negative value - when namespace lost, 0 - when neither lost, > 0 - when type lost.\r\n ":"\r\n 返回：负值 - 当名称空间丢失时，0-丢失时，当输入丢失时都不会丢失。\r\n \r\n","\r\n This is a top level binder used to bind bodies of query lambdas.\r\n It also contains a bunch of helper methods to bind bodies of a particular kind.\r\n ":"\r\n 这是用于绑定查询兰巴斯物体的顶级粘合剂。\r\n 它还包含一堆辅助方法来结合特定类型的身体。\r\n \r\n","\r\n  Looks up a localized string similar to DeclarationSyntax not within syntax tree.\r\n":"\r\n  查找类似于语法树中不在语法树中的声明类似的本地化字符串。\r\n\r\n","If the current Token is not StringLiteral then returns LiteralNode with missing token.":"如果当前令牌不是字符串文字，则返回具有丢失令牌的文字词。\r\n","\r\n Checks if this symbol is a definition and its containing module is a SourceModuleSymbol.\r\n ":"\r\n 检查此符号是否为定义，其包含的模块是SourceModulesymbol。\r\n \r\n","A culture to use when choosing the best assembly from\r\n            among the set filtered by ":"从中选择最佳组装时使用的文化\r\n            在被过滤的集合中\r\n","Make field readonly":"使字段阅读\r\n","The syntax 'var' for a pattern is not permitted to refer to a type, but '{0}' is in scope here.":"对于模式的语法“ var”不允许参考某种类型，但是“ {0}”在此处。\r\n"," node, or zero, which will trigger inference. Upon return, it will \r\n be adjusted to correspond future result node.\r\n ":" 节点或零，将触发推理。返回后，它将\r\n 调整以相应的未来结果节点。\r\n \r\n","\r\n            Use this helper to register multiple refactorings (":"\r\n            使用此助手注册多个重构（\r\n","\r\n Disallow additional local variable declaration and report delayed shadowing diagnostics.\r\n ":"\r\n 禁止其他本地变量声明，并报告延迟阴影诊断。\r\n \r\n","Changes are not allowed while stopped at exception":"例外停止时不允许更改\r\n","\r\n  Looks up a localized string similar to Chaining speculative semantic model is not supported. You should create a speculative model from the non-speculative ParentModel..\r\n":"\r\n  不支持查找类似于链式投机语义模型的本地化字符串。您应该从非规范源模型中创建一个投机模型。\r\n\r\n","\r\n Placeholder for the bound call to the get_Current method.\r\n ":"\r\n 登录到get_current方法的占位符。\r\n \r\n","\r\n            The caret position when completion was triggered.\r\n            ":"\r\n            触发完成时的角度位置。\r\n            \r\n","\r\n Gets the name And id of the local that are going to be generated into the debug metadata.\r\n ":"\r\n 获取将生成Debug Metadata的本地的名称和ID。\r\n \r\n","\r\n Gets the available named static member symbols in the context of the specified location And optional container.\r\n Only members that are accessible And visible from the given location are returned.\r\n \r\n Non-reduced extension methods are considered, since they are static methods.\r\n ":"\r\n 获取指定位置和可选容器上下文中可用的命名静态成员符号。\r\n 只返回从给定位置可访问和可见的成员。\r\n \r\n 考虑非缩减扩展方法，因为它们是静态方法。\r\n \r\n","\r\n Lowers initializers to fields assignments if not lowered yet and the first statement of the body isn't \r\n a call to another constructor of the containing class. \r\n ":"\r\n 如果还没有降低初始化器的初始化范围分配，并且身体的第一个陈述不是\r\n 呼叫包含类的另一个构造函数。\r\n \r\n","\r\n  Looks up a localized string similar to First operand in a binary 'If' expression must be nullable or a reference type..\r\n":"查找类似于二进制'if'表达式中的第一操作数的局部字符串，必须是无效的或参考类型。\r\n\r\n","&Sort Usings":"＆分类使用\r\n","\r\n            Common interface used by both local Roslyn and LSP to implement\r\n            their specific versions of CodeRefactoringSuggestedAction.\r\n            ":"\r\n            本地罗斯林和LSP都使用的常见界面来实施\r\n            他们的特定版本的CodereFactoringSuggesteDactactact。\r\n            \r\n","s can override this.\r\n            ":"S可以覆盖这一点。\r\n            \r\n","\r\n The value for the Guid property.\r\n ":"\r\n 指南属性的价值。\r\n \r\n","Internal error in the C# compiler.":"C＃编译器中的内部错误。\r\n","\r\n  Looks up a localized string similar to /platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe..\r\n":"\r\n  查找类似于 /平台的局部字符串：Anycpu32bitPrefred仅适用于 /t：exe， /t：winexe和 /t：appContainerexe ..\r\n\r\n","\r\n Indicates why the compiler accepted or rejected the method during overload resolution.\r\n ":"指示为什么编译器在过载分辨率期间接受或拒绝该方法。\r\n \r\n","This is not a general purpose helper.":"这不是通用助手。\r\n","\r\n Returns a copy of this with the Name property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此的副本，名称属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n Returns a copy of this with the ToKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中tokeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n See if any member in [memberList] starting with [memberIndex] conflict with [method],\r\n report appropriate error and return true. \r\n ":"\r\n 查看[MemberList]中的任何成员是否从[MemberIndex]与[方法]冲突开始，\r\n 报告适当的错误并返回true。\r\n \r\n","\r\n Lookup declaration for predefined CorLib type in this Assembly. Only valid if this \r\n assembly is the Cor Library\r\n ":"\r\n 该组件中预定义的Corlib类型的查找声明。只有在此时有效\r\n 集会是Cor库\r\n \r\n","\r\n            Implements workaround for https://github.com/dotnet/project-system/issues/5457.\r\n            \r\n            When debugging is started we capture the current solution snapshot.\r\n            The documents in this snapshot might not match exactly to those that the compiler used to build the module \r\n            that's currently loaded into the debuggee. This is because there is no reliable synchronization between\r\n            the (design-time) build and Roslyn workspace. Although Roslyn uses file-watchers to watch for changes in \r\n            the files on disk, the file-changed events raised by the build might arrive to Roslyn after the debugger\r\n            has attached to the debuggee and EnC service captured the solution.\r\n            \r\n            Ideally, the Project System would notify Roslyn at the end of each build what the content of the source\r\n            files generated by various targets is. Roslyn would then apply these changes to the workspace and \r\n            the EnC service would capture a solution snapshot that includes these changes.\r\n            \r\n            Since this notification is currently not available we check the current content of source files against\r\n            the corresponding checksums stored in the PDB. Documents for which we have not observed source file content \r\n            that maches the PDB checksum are considered ":"\r\n            实施https://github.com/dotnet/project-system/issues/5457的解决方法。\r\n            \r\n            启动调试时，我们捕获了当前的解决方案快照。\r\n            此快照中的文档可能与编译器用于构建模块的文档完全不匹配\r\n            目前已加载到Debuggee中。这是因为之间没有可靠的同步\r\n            （设计时间）构建和罗斯林工作区。尽管罗斯林使用文件观察者观察更改\r\n            磁盘上的文件，构建构建的文件更改的事件可能会在调试器之后到达罗斯林\r\n            已连接到Debuggee和ENC服务捕获了解决方案。\r\n            \r\n            理想情况下，项目系统将在每个构建的末尾通知罗斯林\r\n            由各种目标生成的文件是。然后，罗斯林会将这些更改应用于工作空间，并且\r\n            ENC服务将捕获包含这些更改的解决方案快照。\r\n            \r\n            由于目前尚不可用此通知，我们会检查源文件的当前内容\r\n            存储在PDB中的相应校验和。我们尚未观察到源文件内容的文档\r\n            考虑了PDB校验和\r\n","\r\n Returns the list of custom modifiers, if any, associated with the array.\r\n ":"\r\n 返回与数组关联的自定义修饰符列表。\r\n \r\n","After an open parenthesis (() or before a closing parenthesis ()).":"在开放括号（（）或闭合括号之前（））之后。\r\n","\r\n The expression denoting the call. This could be an Invocation or a MemberAccess\r\n (in the case where no parentheses were supplied.)\r\n ":"\r\n 表示通话的表达式。这可能是调用或会员访问\r\n （如果没有提供括号的情况。）\r\n \r\n","\r\n            Gets data for how to fix a particular ":"\r\n            获取如何修复特定的数据\r\n","\r\n Is this a NoPia local type explicitly declared in source, i.e.\r\n top level type with a TypeIdentifier attribute on it?\r\n ":"\r\n 这是在源中明确声明的NOPIA本地类型，即\r\n 顶级类型带有类型识别符属性？\r\n \r\n",". If\r\n             code has this, and is calling into a method that takes either an ":"。如果\r\n             代码有这个，并且正在调用一种方法\r\n","\r\n The \"Group\" keyword.\r\n ":"\r\n “组”关键字。\r\n \r\n","\r\n This is a cache similar to the one used by MetaImport::GetTypeByName\r\n in native compiler. The difference is that native compiler pre-populates \r\n the cache when it loads types. Here we are populating the cache only\r\n with things we looked for, so that next time we are looking for the same \r\n thing, the lookup is fast. This cache also takes care of TypeForwarders. \r\n Gives about 8% win on subsequent lookups in some scenarios.     \r\n ":"\r\n 这是一个类似于metaimport :: getTypebyname的缓存\r\n 在本地编译器中。区别在于，天然编译器预处理\r\n 加载类型时的缓存。在这里，我们仅填充缓存\r\n 我们寻找的东西，所以下次我们正在寻找相同的东西\r\n 事情，查找很快。此缓存还照顾了typeforwarders。\r\n 在某些情况下，在随后的查找中获得约8％的胜利。\r\n \r\n","\r\n            Checks if this brace completion service should be the service used to provide brace completions at\r\n            the specified position with the specified opening brace.\r\n            \r\n            Only one implementation of ":"\r\n            检查此支架完成服务是否应该是用于提供支架完成的服务\r\n            指定的位置带有指定的打开支架。\r\n            \r\n            只有一个\r\n","Position we are finding the enclosing binder for.":"位置我们正在找到封闭的粘合剂。\r\n","\r\n The options passed to the constructor of the Compilation\r\n ":"\r\n 选项传递给了汇编的构造函数\r\n \r\n","Extension methods":"扩展方法\r\n","\r\n Displays a value in the VisualBasic style.\r\n ":"\r\n 在视觉质量样式中显示一个值。\r\n \r\n","\r\n Returns a copy of this with the EraseKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 将其返回此副本，而EraseKeyWord属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n  Looks up a localized string similar to 'New' is not valid in this context..\r\n":"\r\n  在此上下文中查找类似于“新”的本地化字符串。\r\n\r\n","\r\n  Looks up a localized string similar to Statement cannot appear within an interface body. End of interface assumed..\r\n":"\r\n  查找类似于语句的本地化字符串，无法在接口正文中出现。假定接口的结尾..\r\n\r\n","\r\n  Looks up a localized string similar to '}' expected..\r\n":"\r\n  查找类似于“}”预期的本地化字符串。\r\n\r\n","\r\n A list of all attribute lists on this declaration. If no attributes were\r\n specified, an empty list is returned.\r\n ":"\r\n 此声明中的所有属性列表的列表。如果没有属性\r\n 指定，返回一个空列表。\r\n \r\n","\r\n Does symbol or its containing type have Microsoft.VisualBasic.Embedded() attribute\r\n ":"\r\n 符号或其包含类型具有microsoft.visualbasic.embedded（）属性\r\n \r\n","\r\n Get the preceding trivia nodes of this node. If this node is a token, returns the preceding trivia\r\n associated with this node. If this is a non-terminal, returns the preceding trivia of the first token\r\n of this node. \r\n ":"\r\n 获取此节点的前面琐事节点。如果此节点是令牌，请返回前面的琐事\r\n 与此节点相关联。如果这是非末端，则返回第一个令牌的前面琐事\r\n 这个节点。\r\n \r\n","\r\n Represents the If part or ElseIf part of a If...End If block (or line If). This\r\n statement is always the Begin of a IfPart. The Kind can be examined to\r\n determine if this is an If or an ElseIf statement.\r\n ":"\r\n 表示if a的if零件或elseif部分，如果...结束if块（或行if）。这个\r\n 语句始终是IFPART的开始。可以检查那种\r\n 确定这是IF还是Alseif语句。\r\n \r\n","\r\n Holds information about a member in a compact form. Used for all non-type members for simplicity\r\n ":"\r\n 以紧凑的形式保留有关成员的信息。用于简单的所有非类型成员\r\n \r\n","\r\n Returns the type arguments that have been substituted for the type parameters.\r\n If nothing has been substituted for a given type parameter,\r\n then the type parameter itself is consider the type argument.\r\n ":"\r\n 返回已替换为类型参数的类型参数。\r\n 如果没有什么可以代替给定类型参数，\r\n 然后，类型参数本身为类型参数。\r\n \r\n","Updating '{0}' requires restarting the application.":"更新“ {0}”需要重新启动应用程序。\r\n","Add optional parameter to constructor":"将可选参数添加到构造函数\r\n","The assembly to check accessibility within.":"组件以检查内部的可访问性。\r\n","\r\n  Looks up a localized string similar to Events in a Module cannot be declared '{0}'..\r\n":"\r\n  查找类似于模块中事件的本地化字符串，无法声明“ {0}”。\r\n\r\n","\r\n            Array of analyzer IDs for analyzers that need to be executed for computing diagnostics.\r\n            ":"\r\n            需要执行用于计算诊断的分析仪的一系列分析仪ID。\r\n            \r\n","\r\n The third \".\" in a \"...\" separator.\r\n ":"\r\n 第三 ”。”在“ ...”分离器中。\r\n \r\n","The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerMemberNameAttribute.":"应用于参数'{0}'的CallerArgumentExpresseptresseptresseattribute将无效。它被callermembernameattribute覆盖。\r\n","A string representing the standard Visual Basic source file extension.":"代表标准Visual基本源文件扩展名的字符串。\r\n","\r\n            Contains the parsed file header information for a syntax tree.\r\n            ":"\r\n            包含语法树的解析文件头信息。\r\n            \r\n","Use block body for properties":"使用块主体进行属性\r\n"," for method-like member declarations with block bodies (methods, operators, constructors, destructors, accessors).\r\n            - ":" 用于具有块体的类似方法的成员声明（方法，操作员，构造函数，破坏者，登录器）。\r\n             - \r\n","\r\n            Returns true if type information could be gleaned by simply looking at the given statement.\r\n            This typically means that the type name occurs in right hand side of an assignment.\r\n            ":"\r\n            如果可以通过简单地查看给定的语句来收集类型信息，则返回true。\r\n            这通常意味着类型名称出现在分配的右侧。\r\n            \r\n","\r\n Represents an attribute applied to a Symbol.\r\n ":"\r\n 表示应用于符号的属性。\r\n \r\n","obj is TestFile && ((TestFile)obj).Name == \"Test\"":"OBJ是testfile &&（（（testfile）OBJ）.name ==“ test”\r\n"," ends/starts precisely on current selection.\r\n            - Selection is zero-width and in whitespace that corresponds to a Token whose direct ancestor is of type of type ":" 末端/始于当前选择。\r\n             - 选择为零宽，在空格中，与一个直接祖先类型类型的令牌相对应\r\n","\r\n Converts a sequence of definitions provided by a caller (public API) into map \r\n of definitions used internally.\r\n ":"\r\n 将呼叫者（公共API）提供的定义顺序转换为地图\r\n 内部使用的定义。\r\n \r\n","An assembly identity or null, if ":"如果\r\n","\r\n            The caret position where quick info was requested from.\r\n            ":"\r\n            从请求快速信息的角度位置。\r\n            \r\n","Modifying a try/catch/finally statement when the finally block is active requires restarting the application.":"当最终块处于活动状态时，修改试用/捕获/最终语句需要重新启动应用程序。\r\n"," to an unique editorconfig code style option, if any,\r\n            such that diagnostic's severity can be configured in .editorconfig with an entry such as:\r\n                \"%option_name% = %option_value%:%severity%\r\n            ":" 到唯一的EditorConfig代码样式选项（如果有）\r\n            因此，可以在.editorconfig中配置诊断的严重性，例如：\r\n                “％option_name％=％option_value％：％严重性％\r\n            \r\n","yield return statement":"收益率回报陈述\r\n","\r\n            so that the severity of the given ":"\r\n            这样给定的严重性\r\n","\r\n            This call is equivalent to ":"\r\n            这个电话等同于\r\n","\r\n            Looks for the next sequence of ":"\r\n            寻找下一个序列\r\n","The regular expression construct \\p{ name } matches any character that belongs to a Unicode general category or named block, where name is the category abbreviation or named block name.":"正则表达式构造\\ p {name}匹配属于Unicode常规类别或命名块的任何字符，其中名称是类别缩写或命名块名称。\r\n","try block":"尝试块\r\n","\r\n            used to determine whether static can be used\r\n            ":"\r\n            用于确定是否可以使用静态\r\n            \r\n","Returns a Conversion object that summarizes whether the conversion was\r\n possible, and if so, what kind of conversion it was. If no conversion was possible, a\r\n Conversion object with a false \"Exists \" property is returned.":"返回一个转换对象，该对象总结了转换是否为\r\n 可能，如果是这样，那是什么样的转换。如果无法进行转换，一个\r\n 返回具有错误“存在”属性的转换对象。\r\n","The EnumeratorCancellationAttribute applied to parameter '{0}' will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable":"应用于参数'{0}'的EnumeratorCancellationAttribute将无效。该属性仅对在异步 - 列表方法中返回iAsyncenumerable中的类型concellationToken的参数有效\r\n","\r\n  Looks up a localized string similar to 'Lib' expected..\r\n":"查找类似于“ lib”预期的局部字符串。\r\n\r\n","\r\n Returns a copy of this with the CaseBlocks property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，caseblocks属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            Services related to a specific embedded language.\r\n            ":"\r\n            与特定嵌入式语言有关的服务。\r\n            \r\n","\r\n Returns true if the assembly attribute at the given index is a duplicate assembly attribute that must not be emitted.\r\n Duplicate assembly attributes are attributes that bind to the same constructor and have identical arguments.\r\n ":"\r\n 如果给定索引处的汇编属性是一个重复的汇编属性，则返回true。\r\n 重复的汇编属性是与同一构造函数结合并具有相同参数的属性。\r\n \r\n","\r\n Combined flag to express that a modified identifier appeared in a local or field declaration.\r\n ":"\r\n 合并的标志表明，在本地或字段声明中出现了修改的标识符。\r\n \r\n","\r\n            Determine whether given path is under the shadow-copy directory managed by this shadow-copy provider.\r\n            ":"\r\n            确定给定路径是否位于该影子拷贝提供商管理的影子拷贝目录下。\r\n            \r\n"," type.\r\n            These tags may influence how the item is displayed.\r\n            ":" 类型。\r\n            这些标签可能会影响项目的显示方式。\r\n            \r\n","\r\n            This is the core class a code-style feature needs to derive from.  All logic related to the\r\n            feature will then be contained in this class.  This class will take care of many bit of\r\n            common logic that all code style providers would have to care about and can thus do that\r\n            logic in a consistent fashion without all providers having to do the same.  For example,\r\n            this class will check the current value of the code style option. If it is 'refactoring\r\n            only', it will not bother running any of the DiagnosticAnalyzer codepaths, and will only run\r\n            the CodeRefactoringProvider codepaths.\r\n            ":"\r\n            这是核心类A代码风格的功能需要得出的。所有逻辑与\r\n            然后，功能将包含在此类中。这堂课会照顾好\r\n            所有代码样式提供商都必须关心的常见逻辑，因此可以做到这一点\r\n            以一致的方式逻辑，没有所有提供商都必须这样做。例如，\r\n            此类将检查代码样式选项的当前值。如果是重构\r\n            只有'，它不会打扰运行任何诊断仪编码器，并且只会运行\r\n            CodereFactoringProvider编码器。\r\n            \r\n","\r\n This method is called directly by a Binder when it uses this module level namespace.\r\n ":"\r\n 当粘合剂使用此模块级命名空间时，该方法是直接调用的。\r\n \r\n","\r\n Represents a span of a value between definition and use. Start/end positions are \r\n specified in terms of global node count as visited by StackOptimizer visitors. \r\n (i.e. recursive walk not looking into constants)\r\n ":"\r\n 代表定义和使用之间值的跨度。开始/结束位置是\r\n 根据stackoptimizer访问者访问，根据全球节点计数指定。\r\n （即递归步行不看常见）\r\n \r\n","\r\n            Groups fixes by the diagnostic being addressed by each fix.\r\n            ":"\r\n            组通过每个修复程序解决的诊断来解决。\r\n            \r\n","Compare to '{0}'":"比较'{0}'\r\n","\r\n The purpose of this class is to answer questions about convertibility of one type to another.\r\n It also answers questions about conversions from an expression to a type.\r\n\r\n The code is organized such that each method attempts to implement exactly one section of the\r\n specification.\r\n ":"\r\n 该课程的目的是回答有关一种类型向另一种类型的可转换性的问题。\r\n 它还回答了从表达式转换为类型的问题。\r\n\r\n 该代码的组织使每种方法都试图实现准确的一部分\r\n 规格。\r\n \r\n","\r\n The first expression inside the parentheses.\r\n ":"\r\n 括号内的第一个表达式。\r\n \r\n","\r\n  Looks up a localized string similar to 'Case Else' can only appear inside a 'Select Case' statement..\r\n":"\r\n  查找类似于“其他情况”的本地化字符串只能出现在“选择案例”语句中。\r\n\r\n","\r\n  This method determines if an applied attribute must be emitted. \r\n Some attributes appear in symbol model to reflect the source code, but should not be emitted.\r\n  ":"\r\n  此方法确定是否必须发出应用属性。\r\n 某些属性出现在符号模型中以反映源代码，但不应发射。\r\n  \r\n","\r\n If answer is True, the binder is returned via [binder] parameter.\r\n ":"\r\n 如果答案是正确的，则粘合剂将通过[Binder]参数返回。\r\n \r\n"," that produces wrapping code actions for the  \r\n            node passed in.  Returns ":" 为此产生包装代码操作\r\n            节点传递。返回\r\n","{0} - {1}":"{0}  -  {1}\r\n","Selection can not contain a yield statement.":"选择不能包含收益率语句。\r\n","\r\n Variables that were used anywhere, in the sense required to suppress warnings about unused variables.\r\n ":"\r\n 从任何地方使用的变量，就抑制有关未使用变量的警告所需的意义。\r\n \r\n","\r\n  Looks up a localized string similar to 'WithEvents' variables cannot be typed as arrays..\r\n":"\r\n  查找类似于“ withEvents'变量的局部字符串，不能将其键入为数组。\r\n\r\n"," is a property declaration the tokens of its expression body or initializer.\r\n              \r\n            If ":" 是属性声明其表达主体或初始化器的令牌。\r\n              \r\n            如果\r\n"," doesn't match the corresponding ":" 不匹配相应的\r\n","\r\n Determine what kind of conversion, if any, there is between the types \r\n \"source\" and \"destination\".\r\n ":"\r\n 确定类型之间有哪种转换（如果有）\r\n “源”和“目的地”。\r\n \r\n","Binder for the method body, lambda body, or field initializer. The\r\n returned binder will be nested inside the binder, or be this binder.":"用于方法主体，lambda主体或现场初始化器的粘合剂。这\r\n 返回的粘合剂将嵌套在活页夹中，或者是这种粘合剂。\r\n","\r\n Visit the given type and, in the case of compound types, visit all \"sub type\"\r\n (such as A in A(), or { A(Of T), T, U } in A(Of T).B(Of U)) invoking 'predicate'\r\n with the type and 'arg' at each sub type. If the predicate returns true for any type,\r\n traversal stops and that type is returned from this method. Otherwise if traversal\r\n completes without the predicate returning true for any type, this method returns null.\r\n ":"\r\n 访问给定的类型，对于复合类型，请访问所有“子类型”\r\n （例如A（）或{a（of t），t，u}（t）.b（of u））调用“谓词”\r\n 在每个子类型上使用类型和“ arg”。如果任何类型的谓词返回true，\r\n 遍历停止，该类型是从此方法返回的。否则，如果遍历\r\n 该方法在没有谓词返回的情况下完成，此方法返回null。\r\n \r\n","\r\n            Returns true when the current position is inside user code (e.g. not strings) and the closing token\r\n            matches the expected closing token for this brace completion service.\r\n            Helper method used by ":"\r\n            当当前位置在用户代码内部（例如，不是字符串）和关闭令牌时，返回true\r\n            匹配此支架完成服务的预期关闭令牌。\r\n            辅助方法\r\n","\r\n Splits nullable operand into a hasValueExpression and an expression that represents underlying value (returned).\r\n \r\n Underlying value can be called after calling hasValueExpr without duplicated side-effects.\r\n Note that hasValueExpr is guaranteed to have NO SIDE-EFFECTS, while result value is \r\n expected to be called exactly ONCE. That is the normal pattern in operator lifting.\r\n \r\n All necessary temps and side-effecting initializations are appended to temps and inits\r\n ":"\r\n 将可空操作数拆分为hasValueExpression和表示基础值（返回）的表达式。\r\n \r\n 可以在调用hasValueExpr后调用基础值，而不会产生重复的副作用。\r\n 请注意，hasValueExpr保证没有副作用，而结果值为 \r\n 预计会被调用一次。 这是操作员提升的正常模式。\r\n \r\n 所有必要的临时工作和侧面影响初始化都附加到临时工作和inits中\r\n \r\n","\r\n            Common interface used by both local Roslyn and LSP to implement\r\n            their specific versions of CodeFixSuggestedAction.\r\n            ":"\r\n            本地罗斯林和LSP都使用的常见界面来实施\r\n            他们的特定版本的CodeFixSuggesteDAction。\r\n            \r\n","\r\n            Base type of ```(?inmsx)``` or ```(?inmsx:...)``` nodes.\r\n            ":"\r\n            ``（？inmsx）的基本类型`\r\n            \r\n","\r\n Returns Default property name for the type.\r\n If there is no default property name, then Nothing is returned.\r\n ":"\r\n 返回该类型的默认属性名称。\r\n 如果没有默认属性名称，则不会返回。\r\n \r\n","\r\n The \"End Interface\" statement that ends the block.\r\n ":"\r\n 结束块的“端接口”语句。\r\n \r\n","\r\n Causes lookups to assume that the given set of classes are having their \r\n bases being resolved, so lookups should not check for base classes.\r\n ":"\r\n 引起查找的原因，假设给定的一组类\r\n 基地正在解决，因此查找不应检查基础类。\r\n \r\n","\r\n            Prior to .net6 preview 7, the source generated path was built using a relative path with a preceding \\\r\n            and without only .cs as part of the extension.\r\n            ":"\r\n            在.NET6 Preview 7之前，源生成的路径是使用先前\\的相对路径构建的\r\n            并且仅作为扩展的一部分而没有.cs。\r\n            \r\n","\r\n            Fix groups are returned in priority order determined based on ":"\r\n            修复组按优先顺序返回，根据\r\n","end of string or before ending newline":"字符串的结尾或结束新线之前\r\n","\r\n Returns all errors. The errors are not sorted in any particular order, and the client\r\n should sort the errors as desired.\r\n ":"\r\n 返回所有错误。这些错误均未按任何特定顺序排序，客户\r\n 应该根据需要对错误进行排序。\r\n \r\n","\r\n            Worker is an utility class that can classify a list of tokens or a tree within a\r\n            requested span The implementation is generic and can produce any kind of classification\r\n            artifacts T T is normally either ClassificationSpan or a Tuple (for testing purposes) \r\n            and constructed via provided factory.\r\n            ":"\r\n            工人是一个实用程序类，可以对令牌或树的列表进行分类\r\n            请求的跨度实现是通用的，可以产生任何类型的分类\r\n            工件t t通常是分类池或元组（用于测试目的）\r\n            并通过提供的工厂建造。\r\n            \r\n","\r\n            Gets the span start where async keyword should go.\r\n            ":"\r\n            获取ASYNC关键字应进行的跨度启动。\r\n            \r\n","\r\n Represents a single value in a Case.\r\n ":"\r\n 代表情况中的一个值。\r\n \r\n","LiteralNode":"术语\r\n","The syntax node that declares a method, property, or event.":"声明方法，属性或事件的语法节点。\r\n","s in depth-first order.\r\n ":"s在一阶的深处。\r\n \r\n"," referenced by the underlying module,\r\n value is the corresponding ":" 由基础模块引用，\r\n 值是相应的\r\n","Node for diagnostics":"诊断节点\r\n","#{0} directive":"＃{0}指令\r\n","letter, uppercase":"信，大写\r\n","Optionally returns a binder, OUT parameter!":"可选地返回活页夹，输出参数！\r\n","\r\n  Looks up a localized string similar to Cannot implement interface '{0}' because it could be identical to interface '{1}' from which the implemented interface '{2}' inherits for some type arguments..\r\n":"查找类似于无法实现接口'{0}'的本地化字符串，因为它可能与接口'{1}'相同，从中实现的接口'{2}'继承了某种类型的参数。\r\n\r\n","\r\n Consider all symbols, using normal accessibility rules.\r\n ":"\r\n 使用正常可访问性规则考虑所有符号。\r\n \r\n","\r\n            Indicates which features are enabled for a code cleanup operation.\r\n            ":"\r\n            指示启用哪些功能以进行代码清理操作。\r\n            \r\n","\r\n The value for the IntoKeyword property.\r\n ":"\r\n InterKeyWord属性的值。\r\n \r\n"," \r\n Poolable data set to be used in structure circularity detection.\r\n ":"可用于结构循环检测的可池数据集。\r\n \r\n","Invalid format of the PDB or assembly data.":"PDB或组装数据的无效格式。\r\n","No valid location to insert method call.":"没有有效的位置插入方法调用。\r\n","{0} is not a valid C# conversion expression":"{0}不是有效的C＃转换表达式\r\n","\r\n            Given a syntax token determines a text span delimited by the closest applicable sequence points \r\n            encompassing the token.\r\n            ":"\r\n            给定语法令牌决定了最接近的序列点划定的文本跨度\r\n            包含令牌。\r\n            \r\n","\r\n  Looks up a localized string similar to 'MyClass' must be followed by '.' and an identifier..\r\n":"\r\n  查找类似于“ myclass”的局部字符串必须是“”。和标识符..\r\n\r\n","The bound expression.":"绑定的表达式。\r\n","\r\n Should be in sync with OverloadResolution.MatchArgumentToByValParameter.\r\n ":"\r\n 应该与OrforloadResolution.MatchargumentTobyvalParameter同步。\r\n \r\n","A syntax node that represents a parsed expression. This syntax\r\n node need not and typically does not appear in the source code referred to  SemanticModel\r\n instance.":"表示解析表达式的语法节点。这个语法\r\n 节点无需，通常不会出现在引用Semanticmodel的源代码中\r\n 实例。\r\n","\r\n Returns a copy of this with the AscendingOrDescendingKeyword property changed\r\n to the specified value. Returns this instance if the specified value is the\r\n same as the current value.\r\n ":"\r\n 返回此副本，并更改​​了AspendingOddesCendingKeyWord属性\r\n 指定值。如果指定的值是\r\n 与当前值相同。\r\n \r\n","\r\n If the Using statement is of a form that declares one or more new variables,\r\n this is the list of variable declarations. Otherwise, Nothing is returned.\r\n ":"\r\n 如果使用语句是声明一个或多个新变量的表单，则\r\n 这是可变声明的列表。否则，什么都不会返回。\r\n \r\n","\r\n Represents event container that refers to a WithEvents member's property.\r\n ":"\r\n 代表事件容器，指的是事件成员的属性。\r\n \r\n","Use implicit type":"使用隐式类型\r\n","\r\n            Whether or not this span can be collapsed.\r\n            ":"\r\n            该跨度是否可以折叠。\r\n            \r\n","\r\n Represents a multi-line lambda expression.\r\n ":"\r\n 代表多行lambda表达式。\r\n \r\n","A collection of GlobalImports":"全球群岛的集合\r\n"," represents the inserted symbol in the new compilation.\r\n            If ":" 表示新汇编中的插入符号。\r\n            如果\r\n","\r\n            Alternate regions of the document that help describe the item.\r\n            ":"\r\n            文档的替代区域有助于描述该项目。\r\n            \r\n","\r\n Get symbol for predefined type from Cor Library referenced by this compilation.\r\n ":"\r\n 从本汇编引用的COR库中获取预定义类型的符号。\r\n \r\n","\r\n Checks if the expression is a constant and that constant is False\r\n ":"\r\n 检查表达是否是常数，并且该常数为false\r\n \r\n","\r\n  Looks up a localized string similar to file '{0}' could not be found.\r\n":"\r\n  查找类似于文件'{0}'的本地化字符串。\r\n\r\n","\r\n Spill a list of expressions (e.g. the arguments of a method call).\r\n \r\n The expressions are processed right-to-left. Once an expression has been found that contains an await\r\n expression, all subsequent expressions are spilled.\r\n \r\n Example:\r\n \r\n     (1 + 2, await t1, Foo(), await t2, 3 + 4)\r\n \r\n     becomes:\r\n \r\n     Spill(\r\n         spill1 = 1 + 2,\r\n         spill2 = await t1,\r\n         spill3 = Foo(),\r\n         (spill1, spill2, spill3, await t2, 3 + 4))\r\n \r\n NOTE: Consider nested array initializers:\r\n \r\n     new int[] {\r\n         { 1, await t1 },\r\n         { 3, await t2 }\r\n     }\r\n \r\n If the arguments of the top-level initializer had already been spilled, we would end up trying to spill\r\n something like this:\r\n \r\n     new int[] {\r\n         Spill(\r\n             spill1 = 1,\r\n             { spill1, await t1 }),\r\n         Spill(\r\n             spill2 = 3,\r\n             { spill2, await t2 })\r\n     }\r\n \r\n The normal rewriting would produce:\r\n \r\n     Spill(\r\n         spill1 = 1,\r\n         spill3 = { spill1, await t1 },\r\n         spill2 = 3,\r\n         int[] a = new int[] {\r\n             spill3,\r\n             { spill2, await t2 }))\r\n \r\n Which is invalid, because spill3 does not have a type.\r\n \r\n To solve this problem the expression list spilled descends into nested array initializers.\r\n \r\n ":"\r\n 溢出表达式列表（例如，方法调用的参数）。\r\n \r\n 表达式是左右处理的。一旦发现表达式包含一个等待的\r\n 表达，所有后续表达式都溢出。\r\n \r\n 例子：\r\n \r\n     （1 + 2，等待T1，foo（），等待T2，3 + 4）\r\n \r\n     变成：\r\n \r\n     洒（\r\n         spill1 = 1 + 2，\r\n         Spill2 =等待T1，\r\n         spill3 = foo（），\r\n         （Spill1，Spill2，Spill3，等待T2，3 + 4））\r\n \r\n 注意：考虑嵌套数组初始化器：\r\n \r\n     新的int [] {\r\n         {1，等待T1}，\r\n         {3，等待T2}\r\n     }\r\n \r\n 如果顶级初始化器的论点已经溢出，我们最终会试图溢出\r\n 这样的事情：\r\n \r\n     新的int [] {\r\n         洒（\r\n             spill1 = 1，\r\n             {Spill1，等待T1}），\r\n         洒（\r\n             spill2 = 3，\r\n             {Spill2，等待T2}）\r\n     }\r\n \r\n 正常的重写将产生：\r\n \r\n     洒（\r\n         spill1 = 1，\r\n         spill3 = {spill1，等待t1}，\r\n         spill2 = 3，\r\n         int [] a = new int [] {\r\n             Spill3，\r\n             {Spill2，等待T2}）））\r\n \r\n 这是无效的，因为Spill3没有类型。\r\n \r\n 为了解决此问题，表达式列表溢出到嵌套阵列初始化器中。\r\n \r\n \r\n","Could not extract interface: The selection is not inside a class/interface/struct.":"无法提取接口：选择不在类/接口/结构内。\r\n","conditional expression match":"条件表达式匹配\r\n","\r\n            Returns the text change to add the closing brace given the context.\r\n            ":"\r\n            返回文本更改以添加给定上下文的闭合支架。\r\n            \r\n"," objects\r\n that record the imports are persisted.\r\n ":" 对象\r\n 该记录导入持续存在。\r\n \r\n","Malformed \\p{X} character escape":"畸形\\ p {x}字符逃脱\r\n","\r\n            Helper to create a conditional expression out of two original IOperation values\r\n            corresponding to the whenTrue and whenFalse parts. The helper will add the appropriate\r\n            annotations and casts to ensure that the conditional expression preserves semantics, but\r\n            is also properly simplified and formatted.\r\n            ":"\r\n            助手从两个原始的ioperation值创建条件表达式\r\n            对应于whentrue和何时零件。助手将添加适当的\r\n            注释和铸造以确保条件表达保留语义，但\r\n            也适当简化和格式化。\r\n            \r\n",",\r\n            the removes the ":",\r\n            删除 \r\n","\r\n Represents a simple \"Loop\" statement that end a \"Do ... Loop\" block.\r\n ":"\r\n 代表一个简单的“循环”语句，结束“ do ... loop”块。\r\n \r\n","\r\n Returns true and a string from the first GuidAttribute on the assembly, \r\n the string might be null or an invalid guid representation. False, \r\n if there is no GuidAttribute with string argument.\r\n ":"\r\n 返回true和一个从组件上的第一个指南中的字符串，\r\n 字符串可能为null或无效的GUID表示。错误的，\r\n 如果没有字符串参数的指南。\r\n \r\n","\r\n            Defines the known values for ":"\r\n            定义已知值 \r\n","An out variable cannot be declared as a ref local":"输出变量不能被声明为ref局部\r\n","{0} Keyword":"{0}关键字\r\n","\r\n            Returns the total number of arguments that have been typed in the current document.  This may be \r\n            greater than the ArgumentIndex if there are additional arguments after the provided position.\r\n            ":"\r\n            返回当前文档中已键入的参数总数。这可能是\r\n            如果在提供的位置之后还有其他参数，则大于参数索引。\r\n            \r\n","\r\n This implementation uses a binary search to find the first slot that contains\r\n the given offset.\r\n ":"\r\n 该实现使用二进制搜索来查找包含的第一个插槽\r\n 给定偏移。\r\n \r\n","\r\n Bind a Me.New(...), MyBase.New (...), MyClass.New(...) constructor call. \r\n (NOT a normal constructor call like New Type(...)).\r\n ":"\r\n 绑定me.new（...），mybase.new（...），myClass.new（...）构造函数调用。\r\n （不是像新类型（...）这样的普通构造函数。\r\n \r\n","\r\n Represents the When/Filter clause of a Catch statement\r\n ":"\r\n 表示捕获语句的何时/过滤器子句\r\n \r\n","Rename type to {0}":"重命名类型为{0}\r\n","\r\n The \"End Operator\" statement that ends the block declaration.\r\n ":"\r\n 结束块声明的“结束运算符”语句。\r\n \r\n"," used when there is no description.\r\n            ":" 当没有描述时使用。\r\n            \r\n","\r\n            Returns null indicating a failure.\r\n            ":"\r\n            返回零表示故障。\r\n            \r\n","Edit and Continue":"编辑并继续\r\n","Generate method '{1}.{0}'":"生成方法'{1}。{0}'\r\n","Use 'switch' expression":"使用“开关”表达式\r\n","\r\n            Supports providing argument values for an argument completion session.\r\n            ":"\r\n            支持为参数完成会话提供参数值。\r\n            \r\n","letter, modifier":"字母，修饰符\r\n","\r\n            Gets or creates metadata for specified file path.\r\n            ":"\r\n            获取或为指定的文件路径创建元数据。\r\n            \r\n","\r\n            It's very common to have duplicated diagnostics.  For example, consider \"((\". This will\r\n            have two 'missing )' diagnostics, both at the end.  Reporting both isn't helpful, so we\r\n            filter duplicates out here.\r\n            ":"\r\n            复制诊断非常常见。例如，考虑“（”。\r\n            最后都有两个“缺失）”诊断。报告两者都没有帮助，所以我们\r\n            过滤器在这里重复。\r\n            \r\n","The optional preferred culture information":"可选的首选文化信息\r\n"," for everything and you have ":" 对于一切，你有\r\n","\r\n Gets a chunk of text as a DisabledCode node.\r\n ":"\r\n 将大部分文本作为禁用代码节点。\r\n \r\n","\r\n            Version of the Items\r\n            ":"项目的版本\r\n            \r\n","TODO":"去做\r\n","\r\n            Returns the declaration of \r\n            - a property, indexer or event declaration whose accessor is the specified ":"\r\n            返回声明\r\n             - 属性，索引或事件声明，其访问者是指定的\r\n","\r\n            Raised when solution crawler progress changed\r\n            \r\n            Notifications for this event are serialized to preserve order. \r\n            However, individual event notifications may occur on any thread.\r\n            ":"\r\n            当解决方案爬行者的进度发生变化时抬起\r\n            \r\n            此事件的通知被序列化以保存订单。\r\n            但是，任何线程上都可能发生单个事件通知。\r\n            \r\n","True if a document with given path is listed in the PDB.":"如果在PDB中列出了具有给定路径的文档，则为正确。\r\n","\r\n The \"New\" keyword.\r\n ":"\r\n “新”关键字。\r\n \r\n","\r\n            Optional document text span, if computing diagnostics for a specific span for a document.\r\n            For example, diagnostic computation for light bulb invocation for a specific line in active document.\r\n            ":"\r\n            可选文档文本跨度，如果计算文档特定跨度的诊断。\r\n            例如，用于活动文档中特定行的灯泡调用的诊断计算。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Implements' statements must follow any 'Inherits' statement and precede all declarations in a class..\r\n":"\r\n  查找类似于“实施”语句的本地化字符串必须遵循任何“继承”语句，并在类中的所有声明之前。\r\n\r\n","Adding {0} with the Handles clause requires restarting the application.":"用手柄子句添加{0}需要重新启动应用程序。\r\n","A zero-width positive lookahead assertion, where for a match to be successful, the input string must match the regular expression pattern in 'subexpression'. The matched substring is not included in the match result. A zero-width positive lookahead asserti ...":"零宽的正lookahead断言，要成功匹配，输入字符串必须匹配“子表达”中的正则表达模式。匹配的子字符串不包括在比赛结果中。零宽的积极lookahead susperti ...\r\n","\r\n            The text change to be applied to the document.  This must always be supplied and is useful for hosts that\r\n            can apply a large text change efficiently while only making minimal edits to a file.\r\n            ":"\r\n            文本更改将应用​​于文档。这必须始终提供，对主机很有用\r\n            可以有效地应用大型文本更改，而仅对文件进行最小的编辑。\r\n            \r\n","\r\n Returns if all the rules for a \"Me.New\" or \"MyBase.New\" constructor call are satisfied:\r\n   a) In instance constructor body\r\n   b) First statement of that constructor\r\n   c) \"Me\", \"MyClass\", or \"MyBase\" is the receiver.\r\n ":"\r\n 如果满足“ me.new”或“ mybase.new”的所有规则，请返回。\r\n   a）实例构造函数主体\r\n   b）该构造函数的第一个陈述\r\n   c）“我”，“ myclass”或“ mybase”是接收者。\r\n \r\n","Implement '{0}' explicitly":"明确实现'{0}'\r\n"," must still be provided as well.\r\n            ":" 仍然必须提供。\r\n            \r\n","\r\n            Relational patterns only come in the prefix form so we'll have to\r\n            flip the operator if the constant happens to be on the left-hand-side.\r\n            For instance: `123 > x` would be rewritten as `x is < 123`.\r\n            ":"\r\n            关系模式仅以前缀形式出现，因此我们必须\r\n            如果常数恰好在左侧，则翻转操作员。\r\n            例如：`123> x`将被重写为`x是<123`。\r\n            \r\n","\r\n Returns a copy of this with the ResumeKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 将其返回此副本，而ResumeKeyWord属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Type parameter '{1}' has the 'unmanaged' constraint so '{1}' cannot be used as a constraint for '{0}'":"类型参数'{1}'具有'未管理的'约束so'{1}'不能用作'{0}'的约束\r\n","\r\n Returns a copy of this with the RankSpecifiers property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中rankspecifiers属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","The name of the expression.":"表达的名称。\r\n","\r\n            Given a document and syntax node, returns the number of locations where the located node is referenced.\r\n            ":"\r\n            给定的文档和语法节点，返回引用定位节点的位置数量。\r\n            \r\n","A set of options. If these options are not supplied the\r\n            current set of options from the project's workspace will be used.":"一组选项。如果未提供这些选项\r\n            将使用项目工作区的当前选项集。\r\n","\r\n Returns True if this is a lambda conversion.\r\n ":"\r\n 如果这是lambda的转换，则返回true。\r\n \r\n","\r\n Check that the current token is the expected kind, the current node is consumed and optionally a new line\r\n after the token.\r\n ":"\r\n 检查当前令牌是否是预期的，当前节点被消耗并选择为新行\r\n 令牌之后。\r\n \r\n","The optional partial name.":"可选的部分名称。\r\n","\r\n  Looks up a localized string similar to Interface '{0}' can be implemented only once by this type..\r\n":"\r\n  查找类似于接口'{0}'的本地化字符串，只能通过此类型实现一次。\r\n\r\n","\r\n            An abstraction of a symbol reader that provides a reader of Edit and Continue debug information.\r\n            Owns the underlying PDB reader.\r\n            ":"\r\n            符号读取器的抽象，该符号读取器提供了编辑的读者并继续调试信息。\r\n            拥有基础PDB阅读器。\r\n            \r\n","\r\n Returns a copy of this with the Count property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，其中计数属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n A region analysis walker that computes the set of variables for\r\n which their assigned values flow out of the region.\r\n A variable assigned inside is used outside if an analysis that\r\n treats assignments in the region as un-assigning the variable would\r\n cause \"unassigned\" errors outside the region.\r\n ":"\r\n 一个计算变量集的区域分析步行器\r\n 其分配的值流出该区域。\r\n 如果分析\r\n 将区域中的分配视为未分配变量\r\n 导致该地区以外的“未分配”错误。\r\n \r\n","\r\n Returns False if trivia ends line.\r\n ":"\r\n 如果琐事结束线，则返回false。\r\n \r\n",".\r\n            \r\n            Complements ":"。\r\n            \r\n            补充\r\n","\r\n The \"Module\" keyword.\r\n ":"\r\n “模块”关键字。\r\n \r\n","\r\n Updates property access kind. To clear the access kind,\r\n 'newAccessKind' should be Unknown. Otherwise, the current\r\n access kind should be Unknown or equal to 'newAccessKind'.\r\n ":"\r\n 更新属性访问类型。要清除访问类型，\r\n “ newaccesskind”应该是未知的。否则，电流\r\n 访问类型应未知或等于“ newAccesskind”。\r\n \r\n","\r\n            Distance is a number within [0, 1], the smaller the more similar the tokens are. \r\n            ":"\r\n            距离是[0，1]中的数字，越小，令牌越越相似。\r\n            \r\n","Change '{0}' to '{1}'.":"将'{0}'更改为'{1}'。\r\n","\r\n  Looks up a localized string similar to '{0}' cannot implement '{1}.{2}' because they differ by type parameter constraints..\r\n":"\r\n  查找类似于'{0}'无法实现'{1}的本地化字符串。\r\n\r\n","character-group":"角色组\r\n","\r\n            The syntax map for nodes in the tree for this edit, which will be merged with other maps from other trees for this type.\r\n            Only available when ":"\r\n            该编辑的树节点的语法映射将与其他树的其他地图合并为此类型。\r\n            仅在何时可用\r\n"," for an attribute type.\r\n ":" 对于属性类型。\r\n \r\n","\r\n Produces a pessimistic list of spans that denote the regions of text in this tree that\r\n are changed from the text of the old tree.\r\n ":"\r\n 产生一个悲观的跨度清单，表示这棵树中文本区域\r\n 从旧树的文字改变了。\r\n \r\n","\r\n Returns a copy of this with the AsKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 将其返回此副本，并将ASKeyWord属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n This is a map from TypeDef handle to the target ":"\r\n 这是从Typedef手柄到目标的地图\r\n","\r\n Represents a namespace.\r\n ":"\r\n 代表一个名称空间。\r\n \r\n","\r\n The import name.\r\n ":"\r\n 导入名称。\r\n \r\n","\r\n            Finds a public, non-static overload of ":"\r\n            发现公共的非静态超载\r\n","\r\n             For example:\r\n             class Base { }\r\n             class Derived1 : Base { }\r\n             class Derived2 : Base { }\r\n             class Derived3 : Base { }\r\n             void DoSomething(int i, Derived1 d) { }\r\n             void DoSomething(string s, Derived2 d) { }\r\n             void DoSomething(int i, Derived3 d) { }\r\n             \r\n             Base b;\r\n             DoSomething(1, [||]b);\r\n            \r\n             *void DoSomething(string s, Derived2 d) { }* is not the perfect match candidate function for\r\n             *DoSomething(1, [||]b)* because int and string are not ancestor-descendant relationship. Thus,\r\n             Derived2 is not a potential conversion type.\r\n             \r\n             ":"\r\n             例如：\r\n             班级{}\r\n             类派生1：基础{}\r\n             class dedived2：base {}\r\n             类派生3：基础{}\r\n             void dosomething（int i，derived1 d）{}\r\n             void dosomething（字符串S，derived2 d）{}\r\n             void dosomething（int i，derived3 d）{}\r\n             \r\n             b;\r\n             dosomething（1，[||] b）;\r\n            \r\n             * void dosomething（字符串S，derived2 d）{}*不是完美的匹配候选功能\r\n             * dosomething（1，[||] b）*，因为int和字符串不是祖先 - 居民关系。因此，\r\n             派生2不是潜在的转换类型。\r\n             \r\n             \r\n"," is defined in the script.":" 在脚本中定义。\r\n"," values that have not already been handed out to existing\r\n            numbered capture groups.\r\n            ":" 尚未分发给现有的值\r\n            编号捕获组。\r\n            \r\n","\r\n Given an expression specified for With statement produces:\r\n   1) Expression - an expression to be used instead of expression placeholder\r\n   2) Locals - a set of locals used to capture parts of Expression\r\n   3) Initializers - initializers for Locals\r\n \r\n To be used in With statement only!\r\n ":"\r\n 给定用语句指定的表达式产生：\r\n   1）表达式 - 要使用的表达代替表达占位符\r\n   2）当地人 - 一组用于捕获表达部分的当地人\r\n   3）初始化器 - 当地人的初始化器\r\n \r\n 仅与语句一起使用！\r\n \r\n","\r\n context of expression evaluation. \r\n it will affect inference of stack behavior\r\n it will also affect when expressions can be dup-reused\r\n     Example:\r\n         Foo(x, ref x)     x cannot be duped as it is used in different context  \r\n ":"\r\n 表达评估的背景。\r\n 它将影响堆栈行为的推断\r\n 它也会影响表达式何时被淘汰\r\n     例子：\r\n         foo（x，ref x）x不能被欺骗，因为它在不同的上下文中使用\r\n \r\n","\r\n            Returns a method signature display string. Used to display stack frames.\r\n            ":"\r\n            返回方法签名显示字符串。用于显示堆栈帧。\r\n            \r\n","\r\n  Looks up a localized string similar to '{0}' has multiple definitions with identical signatures..\r\n":"\r\n  查找类似于'{0}'的本地化字符串，具有带有相同签名的多个定义。\r\n\r\n","24 hour clock (2 digits)":"24小时时钟（2位数字）\r\n","\r\n                if ":"\r\n                如果\r\n","A character position used to identify a declaration scope and accessibility. This\r\n character position must be within the FullSpan of the Root syntax node in this SemanticModel and must be\r\n within the FullSpan of a Method body within the Root syntax node.":"用于标识声明范围和可访问性的角色位置。这个\r\n 字符位置必须在此语法模型中的root语法节点的成面内，必须为\r\n 在根语法节点内的方法主体的成面内。\r\n","\r\n The intermediate type to which the output of the ":"\r\n 输出的中间类型\r\n","\r\n Given a error info from this node, create the corresponding syntax error with the right span.\r\n ":"\r\n 给定此节点中的错误信息，在正确的跨度中创建相应的语法错误。\r\n \r\n","\r\n  Looks up a localized string similar to Type argument '{0}' does not satisfy the 'Class' constraint for type parameter '{1}'..\r\n":"\r\n  查找类似于类型参数'{0}'的本地化字符串不满足类型参数'{1}'..的“类”约束。\r\n\r\n","\r\n            Required attribute '{0}' has a partial CSS operator. '{1}' must be followed by an equals.\r\n            ":"\r\n            必需的属性'{0}'具有部分CSS操作员。 '{1}'必须遵循平等。\r\n            \r\n","\r\n Represents the use of \"Group\" as the aggregation function in the in the\r\n aggregation range variable declaration of a Group By or Group Join query\r\n operator.\r\n ":"\r\n 表示使用“组”作为在\r\n 集合范围可变声明按组或组加入查询\r\n 操作员。\r\n \r\n"," (an empty array of spans is returned for such document).\r\n            Returns ":" （该文档返回一个空跨度）。\r\n            返回\r\n","Delegate to get diagnostic info to generate if a required type is missing (Option Strict On/Custom) ":"如果缺少所需类型，则委托获取诊断信息以生成（选项严格/自定义）\r\n","\r\n A list of statements to be executed if an exception is caught by the \"Catch\"\r\n block.\r\n ":"\r\n 如果“捕获”捕获异常，则要执行的陈述列表\r\n 堵塞。\r\n \r\n"," property.\r\n            These tags influence the presentation of items in the list.\r\n            ":" 财产。\r\n            这些标签会影响列表中项目的呈现。\r\n            \r\n"," Anonymous delegate parameters, including one for return type ":"匿名委托参数，其中一个用于返回类型\r\n","\r\n This is used while computing the values of constant symbols.  Since they can depend on each other,\r\n we need to keep track of which ones we are currently computing in order to avoid (and report) cycles.\r\n ":"\r\n 计算常数符号的值时使用的。由于它们可以彼此依赖\r\n 我们需要跟踪目前正在计算的哪些，以避免（报告）周期。\r\n \r\n","\r\n Perform control flow analysis, reporting all necessary diagnostics.  Returns true if the end of\r\n the body might be reachable..\r\n ":"\r\n 执行控制流分析，报告所有必要的诊断。如果结束\r\n 身体可能是可以达到的。\r\n \r\n"," for the given targetType. \r\n ":" 对于给定的目标类型。\r\n \r\n","\r\n Decodes a set of local declaration modifier flags and reports any errors with the flags.\r\n ":"\r\n 解码一组本地声明修饰符标志并报告标志的任何错误。\r\n \r\n","\r\n            Marker interface to indicate whether given diagnostic args are from live analysis.\r\n            ":"\r\n            标记界面指示给定的诊断ARG是否来自实时分析。\r\n            \r\n","\r\n Returns a copy of this with the FollowingMisc property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此的副本，以下设备属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            An additional hint to the matching algorithm that can\r\n            augment or override the existing text-based matching.\r\n            ":"\r\n            对匹配算法的附加提示可以\r\n            增强或覆盖现有的基于文本的匹配。\r\n            \r\n","The method, property or event symbol that was declared.":"声明的方法，属性或事件符号。\r\n","\r\n            Helper code to support both \"UseSystemHashCodeCodeFixProvider\" and\r\n            ":"\r\n            辅助代码都支持“ useystemhashcodecodefixprovider”和\r\n            \r\n","\r\n Represent a \"? expression\" \"Print\" statement in VB Interactive code.\r\n ":"\r\n 在VB交互式代码中表示“？表达式”“打印”语句。\r\n \r\n","\r\n Represents the beginning of a declaration. However, not enough syntax is\r\n detected to classify this as a field, method, property or event. This is node\r\n always represents a syntax error.\r\n ":"\r\n 代表声明的开始。但是，语法不够\r\n 检测到将其归类为字段，方法，属性或事件。这是节点\r\n 始终表示语法错误。\r\n \r\n","\r\n            MVIDs read from the assembly built for given project id.\r\n            ":"\r\n            MVID从为给定的项目ID构建的大会中读取。\r\n            \r\n","\r\n            A rude edit is reported if an active statement is changed and this method returns true.\r\n            ":"\r\n            如果更改了主动语句，并且此方法返回true，则报告粗鲁的编辑。\r\n            \r\n","\r\n            Run the script from the specified state.\r\n            ":"\r\n            从指定状态运行脚本。\r\n            \r\n","A global using directive cannot be used in a namespace declaration.":"使用指令的全局不能在命名空间声明中使用。\r\n","The alias symbol that was declared or Nothing if no alias symbol was declared.":"如果没有宣布别名符号，则宣布或一无所有的别名符号。\r\n","Invalid format string":"无效格式字符串\r\n","\r\n  Looks up a localized string similar to option '{0}' requires '{1}'.\r\n":"\r\n  查找类似于选项'{0}'要求'{1}'的本地化字符串。\r\n\r\n","year (5 digits)":"年（5位数字）\r\n","Simplify conditional expression":"简化条件表达\r\n","\r\n Helper to check whether the token is a keyword\r\n ":"\r\n 助手检查令牌是否是关键字\r\n \r\n","\r\n Following enum is used just to help give more specific error messages.\r\n ":"\r\n 以下枚举仅用于帮助提供更具体的错误消息。\r\n \r\n","\r\n The \"Me\", \"MyClass\" or \"MyBase\" keyword.\r\n ":"\r\n “我”，“ myclass”或“ mybase”关键字。\r\n \r\n","\r\n  Looks up a localized string similar to Variable '{0}' is already declared as a parameter of this or an enclosing lambda expression..\r\n":"\r\n  查找类似于变量'{0}'的本地化字符串已被声明为此或封闭的lambda表达式的参数。\r\n\r\n","\r\n Removes substitution currently used by the rewriter for a placeholder node.\r\n Asserts if there isn't already a substitution.\r\n ":"\r\n 删除重写者目前使用的替代者为占位符节点。\r\n 断言是否还没有替代。\r\n \r\n","\r\n The value for the ContinueKeyword property.\r\n ":"\r\n 继续关键字属性的值。\r\n \r\n","\r\n Creates a binder for a project level namespace declaration \r\n This includes the following binders:\r\n    BackstopBinder\r\n    SourceModuleBinder\r\n    TypesOfImportedNamespacesMembersBinder (for modules of project-level imported namespaces)\r\n    ImportedTypesAndNamespacesMembersBinder (for project-level imported namespaces and types)\r\n    SourceFileBinder\r\n    TypesOfImportedNamespacesMembersBinder (for modules of file-level imported namespaces)\r\n    ImportedTypesAndNamespacesMembersBinder (for file-level imported namespaces and types)\r\n    ImportAliasesBinder (for file-level import aliases)\r\n    NamespaceBinder... (for each namespace, starting at the global namespace)\r\n ":"\r\n 为项目级别名称空间声明创建活页夹\r\n 这包括以下粘合剂：\r\n    后脚手\r\n    Sourcemodulebinder\r\n    typesofimportednamespacespacesmembersbinder（用于项目级导入名称空间的模块）\r\n    importedtypesandnamespacessmembersbinder（用于项目级导入的名称空间和类型）\r\n    SourceFileBinder\r\n    typesofimportednamespacespacesmembersbinder（用于文件级导入名称空间的模块）\r\n    importedtypesandnamespacesmembersbinder（用于文件级导入的名称空间和类型）\r\n    Exufertaliasesbinder（用于文件级导入别名）\r\n    名称空间Binder ...（对于每个名称空间，从全局名称空间开始）\r\n \r\n","\r\n            True if the active statement is covered by any of the exception region spans.\r\n            ":"如果有任何异常区域跨度涵盖了主动语句，则为正确。\r\n            \r\n","\r\n The \"Operator\" keyword that introduces this operator declaration.\r\n ":"\r\n 介绍该操作员声明的“操作员”关键字。\r\n \r\n","\r\n            Analyzes the document inside the texstpan to determine if imports can be added.\r\n            ":"\r\n            分析TexSTPAN内部的文档，以确定是否可以添加导入。\r\n            \r\n","\r\n The value for the SyncLockStatement property.\r\n ":"\r\n SynclockStatement属性的值。\r\n \r\n","\r\n The closing curly brace '}' token of the embedded expression.\r\n ":"\r\n 嵌入式表达式的闭合卷发'}'令牌。\r\n \r\n","\r\n Given result of binding preceding query operators, the source, bind the following Aggregate operator.\r\n \r\n     {Preceding query operators} Aggregate {collection range variables} [{other operators}] Into {aggregation range variables}\r\n \r\n Depending on how many items we have in the INTO clause,\r\n we will interpret Aggregate operator as follows:\r\n\r\n FROM a in AA              FROM a in AA\r\n AGGREGATE b in a.BB  =>   LET count = (FROM b IN a.BB).Count()\r\n INTO Count()\r\n\r\n FROM a in AA              FROM a in AA\r\n AGGREGATE b in a.BB  =>   LET Group = (FROM b IN a.BB)\r\n INTO Count(),             Select a, Count=Group.Count(), Sum=Group.Sum(b=>b)\r\n      Sum(b)\r\n\r\n ":"\r\n 给定绑定前面的查询操作员的结果，源，绑定以下骨料操作员。\r\n \r\n     {前面的查询运算符}汇总{Collection range变量} [{other Operator}] {聚合范围变量}\r\n \r\n 取决于我们在该条款中有多少个项目，\r\n 我们将解释总操作员如下：\r\n\r\n 来自A a a a a a a a a a a a a a a a a a in\r\n a.bb => let count =（来自a.bb中的b）.count（）的骨料b\r\n 进入count（）\r\n\r\n 来自A a a a a a a a a a a a a a a a a a in\r\n a.bb => let group =（来自a.bb中的b）中的B骨料B\r\n incount（），选择a，count = group.count（），sum = group.sum（b => b）\r\n      sum（b）\r\n\r\n \r\n","Partial method declarations must have matching ref return values.":"部分方法声明必须具有匹配的REF返回值。\r\n","\r\n            Returns the name of specified argument at the current position in the document.  \r\n            This only applies to languages that allow the user to provide named arguments.\r\n            If no named argument exists at the current position, then null should be returned. \r\n            \r\n            This value is used to determine which documentation comment should be provided for the current\r\n            parameter.  Normally this is determined simply by determining the parameter by index.\r\n            ":"\r\n            返回文档当前位置的指定参数的名称。\r\n            这仅适用于允许用户提供命名参数的语言。\r\n            如果在当前位置不存在命名参数，则应返回nul。\r\n            \r\n            该值用于确定应为当前提供哪些文档注释\r\n            范围。通常，这是通过通过索引来确定参数来确定的。\r\n            \r\n"," where the caret should be positioned after replacement\r\n            ":" 更换后应将其放置在哪里\r\n            \r\n","\r\n  Looks up a localized string similar to No accessible 'Main' method with an appropriate signature was found in '{0}'..\r\n":"\r\n  在“ {0}'..\r\n\r\n","\r\n The value for the DoubleQuoteToken property.\r\n ":"\r\n Doublequotetken属性的价值。\r\n \r\n","\r\n The value for the FromKeyword property.\r\n ":"\r\n fromKeyWord属性的值。\r\n \r\n","\r\n Gets the current interactive command line parser.\r\n ":"\r\n 获取当前的交互式命令行解析器。\r\n \r\n","\r\n The \"Interface\" keyword.\r\n ":"\r\n “接口”关键字。\r\n \r\n","\r\n This is a helper method shared between NamedTypeSymbol and NamespaceSymbol.\r\n \r\n Its purpose is to add names of probable extension methods found in membersByName parameter\r\n to nameSet parameter. Method's viability check is delegated to overridable method\r\n AddExtensionMethodLookupSymbolsInfoViabilityCheck, which is overridden by RetargetingNamedtypeSymbol\r\n and RetargetingNamespaceSymbol in order to perform the check on corresponding RetargetingMethodSymbol.\r\n \r\n Returns true if there were extension methods among the members, \r\n regardless whether their names were added into the set. \r\n ":"\r\n 这是命名typesymbol和namespaceSymbol之间共享的辅助方法。\r\n \r\n 其目的是添加MembersByName参数中可能的扩展方法的名称\r\n 到姓名参数。方法的生存能力检查被委派给了过多的方法\r\n AddExtensionMethodlookupSymbolsInfoviableCheck，它被retargetingNeveMedTypesymbol覆盖\r\n 并retargetingNamespaceSymbol为了对相应的retargetingMethodSymbol进行检查。\r\n \r\n 如果成员之间有扩展方法，则返回true，\r\n 不管他们的名字是否被添加到集合中。\r\n \r\n","\r\n The \"Select\" keyword.\r\n ":"\r\n “选择”关键字。\r\n \r\n","Language for the given language-specific ":"给定语言特定语言的语言\r\n","\r\n Optimizer performs optimization of the bound tree performed before passing it to a codegen. Generally it may\r\n include several phases like stack scheduling of local variables, etc...\r\n ":"\r\n 优化器在将其传递给代码根之前执行的绑定树进行优化。通常可以\r\n 包括几个阶段，例如本地变量的堆栈计划等...\r\n \r\n","\r\n The body of the lambda. Depending on the kind of lambda, this is either a\r\n StatementBody (multi-line lambda), Statement (single-line Sub lambda) or\r\n Expression (single-line Function). This might be an empty list.\r\n ":"\r\n Lambda的身体。取决于那种lambda，这是\r\n Spatecondoby（多行lambda），语句（单线sub lambda）或\r\n 表达式（单线功能）。这可能是一个空列表。\r\n \r\n","The navigation hint for the text, or ":"文本的导航提示，或\r\n","\r\n            If the parameter is optional and the invocation does not specify the parameter, then\r\n            a named argument needs to be introduced.\r\n            ":"\r\n            如果参数是可选的，并且调用未指定参数，则\r\n            需要引入一个指定的论点。\r\n            \r\n","\r\n Binder used for speculatively binding.\r\n ":"\r\n 粘合剂用于投机结合。\r\n \r\n","\r\n The \"End Module\" statement that ends the block.\r\n ":"\r\n 结束块的“端模块”语句。\r\n \r\n","\r\n            Returns an array of parameter symbols that correspond to selected member symbols.\r\n            If a selected member symbol has an empty base identifier name, the parameter symbol will not be added.\r\n            ":"\r\n            返回与所选成员符号相对应的参数符号数组。\r\n            如果所选的成员符号具有空的基本标识符名称，则不会添加参数符号。\r\n            \r\n","\r\n  Looks up a localized string similar to Statement cannot appear outside of a method body..\r\n":"\r\n  查找类似于语句的本地化字符串，无法出现在方法主体之外。\r\n\r\n","short time":"短时间\r\n","\r\n            An MVID and an error message to report, in case an IO exception occurred while reading the binary.\r\n            The MVID is default if either project not built, or an it can't be read from the module binary.\r\n            ":"\r\n            如果在阅读二进制文件时发生IO例外，则会报告MVID和错误消息。\r\n            如果未构建项目或无法从模块二进制读取它，则MVID默认值。\r\n            \r\n","\r\n Returns the TypeSyntax of the given NewExpressionSyntax if specified.\r\n ":"\r\n 如果指定了给定的newexpressyntax的型号。\r\n \r\n","\r\n The \"$\" type character.\"\r\n ":"\r\n “ $”类型字符。\r\n \r\n","A module initializer must be an ordinary member method":"模块初始化器必须是普通的成员方法\r\n","Global variables passed to a script without a global type":"全局变量传递给没有全局类型的脚本\r\n","\r\n This binder keeps track of the set of constant fields that are currently being evaluated\r\n so that the set can be passed into the next call to SourceFieldSymbol.ConstantValue (and\r\n its callers).\r\n ":"\r\n 此活页夹跟踪当前正在评估的恒定字段集\r\n 因此，该集合可以传递到sourcefieldsymbol.constantvalue的下一个呼叫中（和\r\n 它的呼叫者）。\r\n \r\n","\r\n  Looks up a localized string similar to 'Inherits' statement must precede all declarations in a class..\r\n":"\r\n  查找类似于“继承”语句的本地化字符串必须先于类中的所有声明。\r\n\r\n","\r\n We're going to ignore SourceMemberFlags.MethodIsSub and override IsSub explicitly.  We do this because\r\n the flags have to be set at construction time, but IsSub depends on IsWindowsRuntimeEvent, which depends\r\n on interface implementations, which we don't want to bind until the member list is complete.  (It's probably \r\n okay now (2012/12/17), but it would be very fragile to take a dependency on the exact mechanism by which\r\n  interface members are looked up.)\r\n ":"\r\n 我们将忽略Sourcememblags.methodissub，并明确覆盖ISSUB。我们这样做是因为\r\n 标志必须在施工时设置，但ISSUB取决于IswindowsruntimeEvent，这取决于\r\n 在接口实现上，直到成员列表完成之前，我们不想绑定。 （可能是\r\n 好的，现在（2012/12/17），但是要依赖于确切机制，这将是非常脆弱的\r\n  接口成员被查找。）\r\n \r\n","\r\n  Looks up a localized string similar to 'End Select' must be preceded by a matching 'Select Case'..\r\n":"\r\n  查找类似于“ End Select”的本地化字符串必须先于匹配的“选择案例”。\r\n\r\n","\r\n This class represents a simple customizable hash method to hash the string constants\r\n corresponding to the case clause string constants.\r\n If we have at least one string type select case statement in a module that needs a\r\n hash table based jump table, we generate a single public string hash synthesized\r\n method (SynthesizedStringSwitchHashMethod) that is shared across the module.\r\n We must emit this function into the compiler generated PrivateImplementationDetails class.\r\n ":"\r\n 该类代表一个简单的可自定义哈希方法来哈希字符串常数\r\n 对应于案例子句字符串常数。\r\n 如果我们在一个需要一个的模块中至少有一个字符串类型的案例语句\r\n 基于哈希表的跳台，我们生成单个公共字符串哈希合成\r\n 在整个模块上共享的方法（综合stringswitchhashmethod）。\r\n 我们必须将此函数发射到编译器生成的私有ImimpletationDetails类中。\r\n \r\n","\r\n Creates an InitializerSemanticModel that allows asking semantic questions about an initializer node.\r\n ":"\r\n 创建一个initializersemanticmodel，允许询问有关初始器节点的语义问题。\r\n \r\n","\r\n The value for the ImplementsClause property.\r\n ":"\r\n strumentementClause属性的值。\r\n \r\n","\r\n            The identity of update group. \r\n            ":"\r\n            更新组的身份。\r\n            \r\n","\r\n            state that is responsible to hold onto local diagnostics data regarding active/opened files (depends on host)\r\n            in memory.\r\n            ":"\r\n            声明负责保留有关活动/打开文件的本地诊断数据（取决于主机）\r\n            在记忆中。\r\n            \r\n","Type of the interface members (Method, Property, Event)":"接口成员的类型（方法，属性，事件）\r\n"," Field or property declaration statement syntax node ":" 字段或属性声明语句语法节点\r\n","\r\n  Looks up a localized string similar to 'Implements' is not valid on operator declarations..\r\n":"\r\n  查找类似于“工具”的本地化字符串在运营商声明中无效。\r\n\r\n","\r\n            Wraps the given statements within a block statement.\r\n            Note this method is invoked when replacing a statement that is parented by a non-block statement syntax.\r\n            ":"\r\n            将给定语句包装在块语句中。\r\n            请注意，在替换由非块语句语法归属的语句时，请调用此方法。\r\n            \r\n","true if yes was clicked, false otherwise.":"如果是是，则为the，否则为false。\r\n","\r\n            Facade used to call remote ":"\r\n            外墙用来调用遥控器\r\n","\r\n            Flags.\r\n            ":"\r\n            标志。\r\n            \r\n","\r\n  Looks up a localized string similar to 'IsNot' operand of type '{0}' can be compared only to 'Nothing' because '{0}' is a nullable type..\r\n":"\r\n  查找类似于类型'{0}'操作数类似的本地化字符串，只能与'Nothing'进行比较，因为'{0}'是一个无效的类型。\r\n\r\n","\r\n \"?\" token.\r\n ":"\r\n “？”令牌。\r\n \r\n","The \\A anchor specifies that a match must occur at the beginning of the input string. It is identical to the ^ anchor, except that \\A ignores the RegexOptions.Multiline option. Therefore, it can only match the start of the first line in a multiline input s ...":"\\ a锚指定必须在输入字符串的开头发生匹配。它与 ^锚相同，只是\\ a忽略了regexoptions.multiline选项。因此，它只能匹配多行输入S ...中第一行的开始\r\n","\r\n The \"End Get\", \"End Set\", \"End AddHandler\", \"End RemoveHandler\", or \"End\r\n RaiseEvent\" statement that ends the accessor block.\r\n ":"\r\n “ end get”，“ end Set”，“ End Addhandler”，“ End remove Handler”或“ End\r\n RAISEEVENT“结束登录块的语句。\r\n \r\n","\r\n             Returns method's fully quilified name without parameters\r\n            ":"\r\n             返回方法的完全quil缝名称没有参数\r\n            \r\n","Insufficient hexadecimal digits":"十六进制数字不足\r\n","\r\n Returns a copy of this with the TypeParameterConstraintClause property changed\r\n to the specified value. Returns this instance if the specified value is the\r\n same as the current value.\r\n ":"\r\n 返回此副本，并更改​​了TypeparameterContraintClause属性\r\n 指定值。如果指定的值是\r\n 与当前值相同。\r\n \r\n","\r\n Compute the type of a local symbol using the type character, as clause and equals value expression.\r\n 1. Try to compute the type based on the identifier/modified identifier and as clause.  If there is a type then we're done.\r\n 2. If OptionInfer is on then evaluate the expression and use that to infer the type.\r\n \r\n ComputeVariableType will only bind the value if the symbol does not have an explicit type.\r\n ":"\r\n 使用类型字符作为子句计算本地符号的类型，并等于值表达式。\r\n 1.尝试根据标识符/修改后标识符和作为子句计算类型。如果有类型，那么我们就完成了。\r\n 2.如果OptionInfer打开，请评估表达式并使用它来推断类型。\r\n \r\n ComputeVariaBletype仅在符号没有显式类型的情况下才能绑定该值。\r\n \r\n","\r\n            Implements core of Edit and Continue orchestration: management of edit sessions and connecting EnC related services.\r\n            ":"\r\n            实施编辑和继续编排的核心：编辑会议的管理和连接eND相关服务。\r\n            \r\n","True if the statement terminator was consumed":"如果消耗了声明终结者\r\n","\r\n  Looks up a localized string similar to Conversion operators cannot convert from Object..\r\n":"\r\n  查找类似于转换操作员的本地化字符串无法从对象转换。\r\n\r\n","\r\n The value for the WhileKeyword property.\r\n ":"\r\n thekeyword属性的值。\r\n \r\n","\r\n The value for the Target property.\r\n ":"\r\n 目标属性的值。\r\n \r\n","Bound type after the As or a type from the initializing value expression. Can be nothing if no type was supplied.":"在初始化值表达式中的AS或类型之后的绑定类型。如果没有提供类型，则无能为力。\r\n","\r\n Abstract class that represent structured trivia.\r\n ":"\r\n 代表结构化琐事的抽象类。\r\n \r\n","Ignore 'throughType' in accessibility checking. \r\n Used in checking accessibility of symbols accessed via 'MyBase' or 'base'.":"在辅助功能检查中忽略'throttype'。 \r\n 用于检查通过\"MyBase\"或\"base\"访问的符号的可访问性。\r\n","\r\n            operation has succeeded with a span that is different than original span\r\n            ":"\r\n            操作成功的跨度与原始跨度不同\r\n            \r\n","\r\n            ```(?inmsx:expr)``` node.  Changes options for the parsing of 'expr'.\r\n            ":"\r\n            ``（？inmsx：expr）````node''。更改“ Expr”解析的选项。\r\n            \r\n","Token that marks the end of submission.":"标志着提交结束的令牌。\r\n","\r\n Represents the Else part of an If statement, consisting of a Else statement,\r\n followed by a body of statement controlled by that Else.\r\n ":"\r\n 代表IF语句的其他部分，由其他语句组成，\r\n 其次是由其他陈述控制的机构。\r\n \r\n","'s AnalyzerReferences.\r\n            This will never create new ":"的分析仪。\r\n            这永远不会创造新的\r\n","\r\n True if \"symbol is accessible, false otherwise.":"\r\n true如果“可以访问符号，则为false否则。\r\n","\r\n Calculate MethodConversionKind based on required return type conversion.\r\n \r\n TODO: It looks like Dev10 MethodConversionKinds for return are badly named because\r\n       they appear to give classification in the direction opposite to the data\r\n       flow. This is very confusing. However, I am not going to rename them just yet.\r\n       Will do this when all parts are ported and working together, otherwise it will \r\n       be very hard to port the rest of the feature.\r\n \r\n We are trying to classify conversion between methods\r\n ConvertFrom(...) As returnTypeOfConvertFromMethod -> ConvertTo(...) As returnTypeOfConvertToMethod\r\n \r\n The relaxation stub would look like:\r\n Stub(...) As returnTypeOfConvertToMethod\r\n     Return ConvertFrom(...)\r\n End ... \r\n ":"\r\n 根据所需的返回类型转换计算MethodConversionKind。\r\n \r\n TODO：看起来Dev10 MethodConversionKinds返回的命名不佳，因为\r\n       它们似乎给出与数据相反的方向的分类\r\n       流动。这很令人困惑。但是，我还不会重命名它们。\r\n       当所有零件都移植并一起工作时，将执行此操作，否则将\r\n       非常难以移植其余功能。\r\n \r\n 我们正在尝试对方法之间的转换进行分类\r\n convertfrom（...）作为returnTypeofConvertFrommethod-> convertto（...）作为returnTypeofConvertTomethod\r\n \r\n 放松存根看起来像：\r\n 存根（...）作为returnTypeofConvertTomethod\r\n     返回转换（...）\r\n 结尾 ...\r\n \r\n","\r\n            Display structure of the object on a single line.\r\n            ":"\r\n            在单行上显示对象的结构。\r\n            \r\n","\r\n Rewrites method.\r\n ":"\r\n 重写方法。\r\n \r\n","\r\n The value for the QuestionToken property.\r\n ":"\r\n 询问属性的价值。\r\n \r\n","\r\n Get the \"root\" or default namespace that all source types are declared inside. This may be the \r\n global namespace or may be another namespace. \r\n ":"\r\n 获取所有源类型在内部声明的“根”或默认名称空间。这可能是\r\n 全局名称空间或可能是另一个名称空间。\r\n \r\n","The syntax node that declares a type parameter.":"声明类型参数的语法节点。\r\n","\r\n The value for the ErrorCodes property.\r\n ":"\r\n 错误代码属性的值。\r\n \r\n"," Returns all templates owned by this type manager ":" 返回此类型管理器拥有的所有模板\r\n","\r\n The value for the Keys property.\r\n ":"\r\n 钥匙属性的值。\r\n \r\n","\r\n WORKAROUND:\r\n We're taking a dependency on the location and structure of a framework assembly resource.  This is not a robust solution.\r\n \r\n Possible alternatives:\r\n 1) Polish our XML parser until it matches MSXML.  We don't want to reinvent the wheel.\r\n 2) Build a map that lets us go from XML string positions back to source positions.  \r\n This is what the native compiler did, and it was a lot of work.  We'd also still need to modify the message.\r\n 3) Do not report a diagnostic.  This is very unhelpful.\r\n 4) Report a vague diagnostic (i.e. there's a problem somewhere in this doc comment).  This is relatively unhelpful.\r\n 5) Always report the message in English, so that we can pull it apart without needing to mess with resource files.\r\n This engenders a lot of ill will.\r\n 6) Report the exception message without modification and (optionally) include the text with respect to which the\r\n position is specified.  This looks amateurish.            \r\n ":"\r\n 解决方法：\r\n 我们正在依赖框架组装资源的位置和结构。这不是强大的解决方案。\r\n \r\n 可能的替代方案：\r\n 1）抛光我们的XML解析器，直到与MSXML匹配。我们不想重新发明轮子。\r\n 2）构建一个地图，使我们可以从XML字符串位置回到源位置。\r\n 这就是本地编译器所做的，这是很多工作。我们还需要修改消息。\r\n 3）不要报告诊断。这是非常无益的。\r\n 4）报告模糊的诊断（即，此文档评论中的某个地方存在问题）。这是相对无助的。\r\n 5）始终用英语报告该消息，以便我们可以将其分开而无需弄乱资源文件。\r\n 这导致了很多病。\r\n 6）报告没有修改的异常消息，并且（（可选））包括\r\n 指定位置。这看起来业余。\r\n \r\n"," if the operation is cancelled.":" 如果操作被取消。\r\n","\r\n Union bit arrays taking into account 'all bits set' flag\r\n ":"\r\n 联合位阵列考虑了“所有位集”标志\r\n \r\n","\r\n            Code action to edit/remove/add the pragma directives for removing diagnostic suppression.\r\n            ":"\r\n            代码操作以编辑/删除/添加PRAGMA指令，以消除诊断抑制。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Exit AddHandler', 'Exit RemoveHandler' and 'Exit RaiseEvent' are not valid. Use 'Return' to exit from event members..\r\n":"\r\n  查找类似于“退出Addhandler”，“ Exit removeHandler”和“ Exit raiseevent”的本​​地化字符串是无效的。使用“返回”到活动成员退出。\r\n\r\n","\r\n            Whether or not the items in this group can be inlined in the topmost lightbulb.\r\n            ":"\r\n            该组中的项目是否可以将其绑在最上方的灯泡中。\r\n            \r\n","\r\n  Looks up a localized string similar to 'AddressOf' expressions are not valid in the first expression of a 'Select Case' statement..\r\n":"\r\n  在“选择案例”语句的第一个表达式中查找类似于“地址”表达式类似的本地化字符串。\r\n\r\n","\r\n Returns a copy of this with the Initializer property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，初始化属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n  Looks up a localized string similar to Error in project-level import '{0}' at '{1}' : {2}.\r\n":"\r\n  查找类似于项目级导入'{0}'at'{1}''的局部字符串：{2}。\r\n\r\n","The \"U\" standard format specifier represents a custom date and time format string that is defined by a specified culture's DateTimeFormatInfo.FullDateTimePattern property. The pattern is the same as the \"F\" pattern. However, the DateTime value is automatic ...":"“ U”标准格式指定符表示由指定文化的dateTimeFormatinfo.fulldateTimePattern属性定义的自定义日期和时间格式字符串。该模式与“ F”模式相同。但是，DateTime值是自动的...\r\n","\r\n Check constraints of generic types referenced in constraint types. For instance,\r\n with \"Interface I(Of T As I(Of T))\", check T satisfies constraints on I(Of T). Those\r\n constraints are not checked when binding ConstraintTypes since ConstraintTypes\r\n has not been set on I(Of T) at that point.\r\n ":"\r\n 检查约束类型中引用的通用类型的约束。例如，\r\n 使用“接口i（t）i（t）”，检查t满足对i（t）的限制。那些\r\n 绑定约束类型时未检查约束因素\r\n 当时尚未在i（t）上设置。\r\n \r\n","\r\n Bind the ObjectInitializer.\r\n During the binding we basically bind the member access for each initializer, as well as the value that will be assigned.\r\n The main information stored in the bound node is a list of assignment operators (that may contain placeholders), as\r\n well as the information whether expression creates a temporary or not.\r\n ":"\r\n 绑定对objectInitializer。\r\n 在绑定期间，我们基本上将每个初始化器的成员访问以及将要分配的值绑定。\r\n 绑定节点中存储的主要信息是分配运算符（可能包含占位符）的列表，如\r\n 以及表达是否创建临时性的信息。\r\n \r\n","Remove document '{0}'":"删除文档'{0}'\r\n","\r\n  True if this symbol has a special name (metadata flag SpecialName is set).\r\n ":"\r\n  是的，如果此符号具有特殊名称（设置了元数据标志SpecialName）。\r\n \r\n","\r\n             Indicates this ":"\r\n             表示这个\r\n","any character":"任何角色\r\n"," which are fast operations.\r\n            It should not be used for syntactic or semantic operations.\r\n            ":" 是快速操作。\r\n            它不应用于句法或语义操作。\r\n            \r\n","s typically specify this.\r\n            ":"S通常指定此。\r\n            \r\n","Absolute path expected":"预期的绝对路径\r\n"," are contained in ":" 载于 \r\n","\r\n            Determine if the given ":"\r\n            确定是否给定\r\n","\r\n            Data holder for all diagnostics for a project for an analyzer\r\n            ":"\r\n            分析仪项目的所有诊断数据持有人\r\n            \r\n","match at least 'n' times":"至少匹配“ n”时间\r\n","\r\n            Rules that declare how this item should behave.\r\n            ":"\r\n            声明该项目应如何行为的规则。\r\n            \r\n","Interfaces":"接口\r\n","\r\n            Looks for code of the form:\r\n            \r\n                if (expr is Type)\r\n                {\r\n                    var v = (Type)expr;\r\n                }\r\n                \r\n            and converts it to:\r\n            \r\n                if (expr is Type v)\r\n                {\r\n                }\r\n            ":"\r\n            寻找表格的代码：\r\n            \r\n                if（expr是类型）\r\n                {\r\n                    var v =（type）expr;\r\n                }\r\n                \r\n            并将其转换为：\r\n            \r\n                if（expr是类型V）\r\n                {\r\n                }\r\n            \r\n","\r\n Returns a flag indicating whether this symbol is ComImport.\r\n ":"\r\n 返回一个标志，指示此符号是否为comimport。\r\n \r\n","updating usages in containing type":"更新包含类型的用法\r\n","\r\n Returns a copy of this with the StructureStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，结构属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n",". \r\n            This happens when an active statement associated with the member is outside of its body\r\n            (e.g. C# constructor, or VB ":"。\r\n            当与成员相关联的主动语句在其身体外面时，就会发生这种情况\r\n            （例如C＃构造函数或VB\r\n","\r\n Count of all initializers.\r\n ":"\r\n 所有初始化器的计数。\r\n \r\n","\r\n            Unique prefix for generated assemblies.\r\n            ":"\r\n            生成的组件的唯一前缀。\r\n            \r\n","Comparison of function pointers might yield an unexpected result, since pointers to the same function may be distinct.":"功能指针的比较可能会产生意外的结果，因为对同一功能的指针可能是不同的。\r\n","\r\n            trivia factory.\r\n            \r\n            it will cache some commonly used trivia to reduce memory footprint and heap allocation\r\n            ":"\r\n            琐事工厂。\r\n            \r\n            它将缓存一些常用的琐事，以减少内存足迹和堆分配\r\n            \r\n","Parameter '{0}' can be removed if it is not part of a shipped public API; its initial value is never used":"如果参数'{0}'不是发货公共API的一部分，则可以删除。它的初始值永远不会使用\r\n","Remove unnecessary suppression":"去除不必要的抑制\r\n","\r\n            Returns 'true' if a multi-line conditional was created, and thus should be\r\n            formatted specially.\r\n            ":"\r\n            如果创建了多行条件，则返回“ true”，因此应该是\r\n            专门格式化。\r\n            \r\n","\r\n Check that the property and its getter exist and collect any use-site errors.\r\n ":"\r\n 检查该属性及其Getter是否存在并收集任何用途错误。\r\n \r\n","\r\n The name of the enum being declared.\r\n ":"\r\n 被宣布的枚举名称。\r\n \r\n","Builder to place inexactly-matched overridden member candidates in. ":"建造者将不恰当的压倒会员候选人放入。\r\n","\r\n Given a set of explicit interface implementations that are undergoing substitution, return the substituted versions.\r\n ":"\r\n 给定一组正在替换的显式接口实现，请返回替换版本。\r\n \r\n","Make containing scope async (return Task)":"制作包含范围异步（返回任务）\r\n","Error reading debug information.":"错误阅读调试信息。\r\n","\r\n NOTE: the method should write OR push children, but never do both\r\n ":"\r\n 注意：该方法应该写或推孩子，但不要同时做\r\n \r\n","\r\n  Looks up a localized string similar to Array modifiers cannot be specified on lambda expression parameter name. They must be specified on its type..\r\n":"\r\n  在lambda表达参数名称上查找类似于数组修饰符的本地化字符串。它们必须在其类型上指定。\r\n\r\n","\r\n Represents a range variable symbol.\r\n ":"\r\n 代表范围变量符号。\r\n \r\n","\r\n Return true if nothing can inherit or implement this type.\r\n ":"\r\n 如果没有什么可以继承或实施此类型的返回True。\r\n \r\n","Record member '{0}' must be a readable instance property or field of type '{1}' to match positional parameter '{2}'.":"记录成员'{0}'必须是可读的实例属性或类型'{1}'的字段才能匹配位置参数'{2}'。\r\n","\r\n Represents an #ExternalChecksum pre-processing directive appearing in source.\r\n ":"\r\n 代表#ExternalChecksum预处理指令出现在源中。\r\n \r\n","\r\n            All the members involved in this pull up operation,\r\n            and the other changes (in adddition to pull up) needed so that this pull up operation won't cause error.\r\n            ":"\r\n            所有参与此拉的操作的成员，\r\n            还有其他更改（另外要拉起），以使此上拉操作不会导致错误。\r\n            \r\n","\r\n Represents an accessor block member declaration: A declaration that has a\r\n beginning declaration, a body of executable statements and an end statement.\r\n Examples include property accessors and custom event accessors.\r\n ":"\r\n 代表登录块成员声明：具有\r\n 开始声明，可执行语句的主体和结束声明。\r\n 示例包括物业访问者和自定义活动访问者。\r\n \r\n","\r\n  Looks up a localized string similar to Nested function does not have the same signature as delegate '{0}'..\r\n":"\r\n  查找类似于嵌套函数的本地化字符串与委托'{0}'..的签名相同\r\n\r\n","\r\n Represents a module within an assembly. Every assembly contains one or more modules.\r\n ":"\r\n 代表组件中的模块。每个组件都包含一个或多个模块。\r\n \r\n","\r\n Returns information about methods associated with AggregateClauseSyntax.\r\n ":"\r\n 返回有关与聚集的方法相关的信息。\r\n \r\n","\r\n            We keep operators sorted in a specific order.  We don't want to sort them alphabetically, but instead want\r\n            to keep things like ":"\r\n            我们将操作员按特定顺序进行分类。我们不想按字母顺序排序，而是想要\r\n            保留像\r\n","\r\n  Looks up a localized string similar to Array initializer has too many dimensions..\r\n":"\r\n  查找类似于数组初始化器的本地化字符串的尺寸太多。\r\n\r\n","\r\n            Constructor for a code style analyzer with a multiple diagnostic descriptors such that all the descriptors have no unique code style option to configure the descriptors.\r\n            ":"\r\n            具有多个诊断描述符的代码样式分析仪的构造函数，因此所有描述符都没有配置描述符的唯一代码样式选项。\r\n            \r\n","\r\n Returns the \"End Sub\" or \"End Function\" statement if this is a multi-line\r\n lambda.\r\n ":"\r\n 如果这是多行\r\n 兰姆达。\r\n \r\n","\r\n            Checks if this ":"\r\n            检查是否\r\n","\r\n            Calculates the distance between two sequences of syntax tokens, disregarding trivia. \r\n            ":"\r\n            计算两个语法令牌序列之间的距离，无视琐事。\r\n            \r\n","\r\n            True if this document is less important than other documents in the project it is \r\n            contained in, and should have work scheduled for it happen after all other documents\r\n            in the project.\r\n            ":"\r\n            是的，如果本文档不如项目中的其他文档重要\r\n            包含在所有其他文档后，应安排工作的工作\r\n            在项目中。\r\n            \r\n","\r\n Return the index within the trivia of what would be considered trailing\r\n single-line trivia by the Scanner. This behavior must match ScanSingleLineTrivia.\r\n In short, search walks backwards and stops at the second terminator\r\n (colon or EOL) from the end, ignoring EOLs preceded by line continuations.\r\n ":"\r\n 返回被认为落后的琐事中的索引\r\n 扫描仪的单线琐事。这种行为必须与ScansingLelinetrivia相匹配。\r\n 简而言之，搜索向后走，停在第二终结者\r\n （结肠或EOL）从末端，忽略EOL之前是线的连续性。\r\n \r\n","\r\n            Features like add-using want to be able to quickly search symbol indices for projects and\r\n            metadata.  However, creating those indices can be expensive.  As such, we don't want to\r\n            construct them during the add-using process itself.  Instead, we expose this type as an \r\n            Incremental-Analyzer to walk our projects/metadata in the background to keep the indices\r\n            up to date.\r\n            \r\n            We also then export this type as a service that can give back the index for a project or\r\n            metadata dll on request.  If the index has been produced then it will be returned and \r\n            can be used by add-using.  Otherwise, nothing is returned and no results will be found.\r\n            \r\n            This means that as the project is being indexed, partial results may be returned.  However\r\n            once it is fully indexed, then total results will be returned.\r\n            ":"\r\n            诸如添加的功能希望能够快速搜索项目和\r\n            元数据。但是，创建这些指数可能很昂贵。因此，我们不想\r\n            在添加过程本身中构建它们。相反，我们将这种类型公开为\r\n            增量分析仪将我们的项目/元数据漫步在背景中以保留指数\r\n            最新。\r\n            \r\n            然后，我们还将这种类型导出为可以退还项目或\r\n            元数据DLL应要求。如果产生了索引，则将返回并\r\n            可以通过添加使用。否则，什么也不会返回，也找不到结果。\r\n            \r\n            这意味着，随着项目的索引，可以返回部分结果。然而\r\n            一旦完全索引，将返回总结果。\r\n            \r\n","\r\n For a given goto, the nearest enclosing block that captures variables\r\n ":"对于给定的goto，捕获变量的最近的封闭块\r\n \r\n","\r\n            True if this signature help item can have an unbounded number of arguments passed to it.\r\n            If it is variadic then the last parameter will be considered selected, even if the\r\n            selected parameter index strictly goes past the number of defined parameters for this\r\n            item.\r\n            ":"\r\n            是的，如果此签名帮助项目可能会传递无限的参数。\r\n            如果是variadic，则将选择最后一个参数，即使\r\n            精选的参数索引严格超过了此的定义参数数量\r\n            物品。\r\n            \r\n","\r\n Creates a singleton list of syntax nodes.\r\n ":"\r\n 创建一个语法节点的单例列表。\r\n \r\n","Literal value.":"字面价值。\r\n","\r\n            Wrapper function of [GetInheritanceDistance], also consider the class with explicit conversion operator\r\n            has the highest priority.\r\n            ":"\r\n            [getInherrancistance]的包装器功能，也考虑具有显式转换操作员的课程\r\n            具有最高优先级。\r\n            \r\n","\r\n The value for the AliasName property.\r\n ":"\r\n AliasName属性的值。\r\n \r\n","named matched subexpression":"命名为匹配的子表达\r\n","\r\n This method checks to see if the given symbol is Obsolete or if any symbol in the parent hierarchy is Obsolete.\r\n ":"\r\n 此方法检查给定符号是否已过时，或者父层中的任何符号是否已过时。\r\n \r\n"," of a body of ":" 尸体\r\n","\r\n If specified called for every child syntax node (not token) that is visited during the comparison. \r\n It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\r\n ":"\r\n 如果指定了在比较期间访问的每个儿童语法节点（非令牌）的要求。\r\n 它归还了孩子的归还访问，否则孩子及其子树被忽略了。\r\n \r\n","\r\n  Looks up a localized string similar to Expected closing '%>' for embedded expression..\r\n":"\r\n  在嵌入式表达式中查找类似于预期关闭的“％>”的局部字符串。\r\n\r\n","\r\n Returns True if the type is marked by 'Microsoft.VisualBasic.Embedded' attribute. \r\n ":"\r\n 如果类型由'microsoft.visualbasic.embedded'属性标记，则返回true。\r\n \r\n","\r\n            A class that represents a script that you can run.\r\n            \r\n            Create a script using a language specific script class such as CSharpScript or VisualBasicScript.\r\n            ":"\r\n            代表您可以运行的脚本的类。\r\n            \r\n            使用语言特定脚本类（例如CSHARPSCRIPT或VisualBasicscript）创建脚本。\r\n            \r\n","\r\n            Adds a parameter to a method.\r\n            ":"\r\n            将参数添加到方法中。\r\n            \r\n","\r\n The value for the EndModuleStatement property.\r\n ":"\r\n EndModuleStatement属性的值。\r\n \r\n","\r\n Returns a copy of this with the Options property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而“选项属性”更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Abstract node class that represents the textual description of a type, possibly\r\n include generic type arguments, qualified names, array specifiers, nullable\r\n specifier and the like.\r\n ":"\r\n 代表类型的文本描述的抽象节点类，可能\r\n 包括通用类型参数，合格的名称，数组指定，可无效\r\n 指定词等。\r\n \r\n","The \\z anchor specifies that a match must occur at the end of the input string. Like the $ language element, \\z ignores the RegexOptions.Multiline option. Unlike the \\Z language element, \\z does not match a \\n character at the end of a string. Therefore, i ...":"\\ z锚指定必须在输入字符串末端进行匹配。像$ Lakans元素一样，\\ z忽略了Regexoptions.multiline选项。与\\ z语言元素不同，\\ z在字符串末端不匹配a \\ n字符。因此，我...\r\n","\r\n Get all reserved keywords\r\n ":"\r\n 获取所有保留的关键字\r\n \r\n","\r\n The sequence of groups of TypeDef row ids for types contained within the namespace, \r\n recursively including those from nested namespaces. The row ids must be grouped by the \r\n fully-qualified namespace name in case-sensitive manner. There could be multiple groups \r\n for each fully-qualified namespace name. The groups must be sorted by their key in \r\n case-insensitive manner. Empty string must be used as namespace name for types \r\n immediately contained within Global namespace. Therefore, all types in THIS namespace, \r\n if any, must be in several first IGroupings.\r\n ":"\r\n 命名空间中包含的类型类型的Typedef行ID组序列，\r\n 递归包括来自嵌套名称空间的。行ID必须由\r\n 以情况敏感的方式完全合格的名称名称。可能有多个组\r\n 对于每个符合条件的名称空间名称。这些小组必须按其钥匙进行排序\r\n 案例不敏感的方式。空字符串必须用作类型的名称名称\r\n 立即包含在全球名称空间中。因此，此名称空间中的所有类型，\r\n 如果有的话，必须在几个第一个Igroupings中。\r\n \r\n","\r\n Returns a copy of this with the UnderlyingType property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其基础属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            Signature Help was triggered through typing a closing brace.\r\n            ":"\r\n            签名帮助是通过输入闭合支架触发的。\r\n            \r\n","subexpression":"子表达\r\n","\r\n  Looks up a localized string similar to Since this is an async method, the return expression must be of type '{0}' rather than 'Task(Of {0})'..\r\n":"\r\n  查找与类似的本地化字符串，因为这是一个异步方法，返回表达式必须是类型为'{0}'而不是'task（of {0}）'..\r\n\r\n","\r\n Get all errors in the compilation, up through the given compilation stage. Note that this may\r\n require significant work by the compiler, as all source code must be compiled to the given\r\n level in order to get the errors. Errors on Options should be inspected by the user prior to constructing the compilation.\r\n ":"\r\n 通过给定的汇编阶段获取编译中的所有错误。请注意，这可能\r\n 需要编译器的重大工作，因为必须将所有源代码汇编为给定\r\n 级别以获取错误。选项上的错误应由用户在构造汇编之前检查。\r\n \r\n","\r\n The value for the IdentifierName property.\r\n ":"\r\n 标识名称属性的值。\r\n \r\n","\r\n            Generates an implementation of ":"\r\n            生成实施\r\n","root node of a tree":"树的根节点\r\n","type pattern":"类型模式\r\n"," that represents\r\n an assembly that couldn't be found.\r\n ":" 代表\r\n 找不到的组装。\r\n \r\n","\r\n An array of cached Cor types defined in this assembly.\r\n Lazily filled by GetSpecialType method.\r\n ":"\r\n 该组件中定义的一组缓存的COR类型。\r\n 用getspecialtype方法懒洋洋地填充。\r\n \r\n","\r\n This is equivalent to ":"\r\n 这等同于\r\n","\r\n Determines if a submission is complete.\r\n Returns false if the syntax is valid but incomplete.\r\n Returns true if the syntax is invalid or complete.\r\n Throws ":"\r\n 确定提交是否完成。\r\n 如果语法有效但不完整，则返回false。\r\n 如果语法无效或完成，则返回true。\r\n 扔\r\n","\r\n  Looks up a localized string similar to Enum '{0}' must contain at least one member..\r\n":"\r\n  查找类似于枚举'{0}'的本地化字符串必须至少包含一个成员。\r\n\r\n","TODO: override finalizer only if '{0}' has code to free unmanaged resources":"todo：仅当'{0}'具有免费资源的代码时，才覆盖最终确定器\r\n","\r\n            Add a trailing newline if we don't already have one if that's what the user's \r\n            preference is.\r\n            ":"\r\n            如果我们还没有一个，则添加尾随的新线，如果是用户的\r\n            偏好是。\r\n            \r\n","\r\n Returns true if this symbols can overload another of the same kind.\r\n ":"\r\n 如果此符号可以超载另一种相同类型，则返回true。\r\n \r\n","-returning property called ":" - 返回的属性\r\n","\r\n The value for the Events property.\r\n ":"\r\n 事件属性的值。\r\n \r\n","\r\n Creates an MethodBodySemanticModel that allows asking semantic questions about an attribute node.\r\n ":"\r\n 创建一个Methodbodysemanticmodel，允许询问有关属性节点的语义问题。\r\n \r\n","\r\n Returns a copy of this with the EventContainer property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中EventContainer属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            create VariableInfo type\r\n            ":"\r\n            创建变量类型\r\n            \r\n","\r\n            Gets, filters, and orders code fixes.\r\n            ":"\r\n            获取，过滤器和订单代码修复。\r\n            \r\n","\r\n  Looks up a localized string similar to The pathmap option was incorrectly formatted..\r\n":"\r\n  查找类似于Pathmap选项的本地化字符串的格式不正确。\r\n\r\n","[x-y] range in reverse order":"[x-y]范围为反向顺序\r\n","\r\n Create a missing keyword.\r\n ":"\r\n 创建一个缺少的关键字。\r\n \r\n","\r\n            for the first invocation.\r\n            ":"\r\n            第一个调用。\r\n            \r\n","Edit and Continue disallowed by module":"编辑并继续被模块禁止\r\n","True to get overridden getters, False to get overridden setters":"真实地被覆盖的人，错误地覆盖了固定器\r\n","\r\n This is for perf, not for correctness.\r\n ":"\r\n 这是为了perf，而不是正确的。\r\n \r\n","\r\n The value for the StepKeyword property.\r\n ":"\r\n Stepkeyword属性的值。\r\n \r\n","\r\n The first of the two optional Select methods associated with ":"\r\n 两个可选的选择方法中的第一种与\r\n","\r\n We look at all pending branches and attempt to resolve the branches with labels if the nesting of the \r\n block is the nearest common parent to the branch and the label. Because the code is evaluated recursively \r\n outward we only need to check if the current nesting is a prefix of both the branch and the label nesting.\r\n ":"\r\n 我们查看所有等待的分支，并尝试用标签解析分支\r\n 块是与分支和标签的最接近的父母。因为代码是递归评估的\r\n 向外，我们只需要检查当前嵌套是否是分支和标签嵌套的前缀。\r\n \r\n","\r\n Extract type under assumption that there should be no custom modifiers.\r\n The method asserts otherwise.\r\n ":"\r\n 假设不应该有自定义修饰符的提取类型。\r\n 该方法否则断言。\r\n \r\n","\r\n Set after all diagnostics have been reported for this symbol.\r\n ":"\r\n 在所有诊断术后已报告此符号的所有诊断。\r\n \r\n","Assembly '{0}' has already been loaded from '{1}'. A different assembly with the same name can't be loaded unless it's signed: '{2}'.":"汇编'{0}'已经从'{1}'加载。除非签名：'{2}'，否则将无法加载具有相同名称的不同组件。\r\n"," back by a given ":" 回到给定\r\n","\r\n             Method full name is expected to be in the .NET full name type convention. That is,\r\n             namespace/type is delimited by '.' and nested type is delimited by '+'\r\n            ":"\r\n             方法全名有望在.NET全名类型约定中。那是，\r\n             名称空间/类型由'。嵌套类型由'+'界定\r\n            \r\n","\r\n Determines if possibleLambda is a lambda expression and position is in the interior.\r\n ":"\r\n 确定Possiblelambda是否是lambda的表达，并且位置在内部。\r\n \r\n","\r\n Represents a \"While ...\" clause of a \"Do\" or \"Loop\" statement.\r\n ":"\r\n 表示“ do”或“ loop”语句的“ while ...”条款。\r\n \r\n","\r\n Given a localSymbol and a syntaxNode where the symbol is used, safely return the symbol's type.\r\n ":"\r\n 给定使用符号的localsymbol和语法句，安全地返回符号的类型。\r\n \r\n"," parameter.\r\n ":" 范围。\r\n \r\n","\r\n            referenced from.\r\n            ":"\r\n            引用。\r\n            \r\n","\r\n This method groups equally applicable (§11.8.1.1 Applicability) candidates into buckets. \r\n \r\n Returns an ArrayBuilder of buckets. Each bucket is represented by an ArrayBuilder(Of Integer), \r\n which contains indexes of equally applicable candidates from input parameter 'candidates'.\r\n ":"\r\n 此方法将同样适用的（第11.8.1.1节适用性）候选为存储桶。\r\n \r\n 返回一个存储桶阵列。每个存储桶由（整数）的阵列布置器表示，\r\n 其中包含来自输​​入参数“候选人”的同样适用候选人的索引。\r\n \r\n","'UnmanagedCallersOnly' method '{0}' cannot implement interface member '{1}' in type '{2}'":"'UnmanagedCallersonly'方法'{0}'无法在类型'{2}'中实现接口成员'{1}'\r\n","\r\n Simple check of whether or not we should step into the type 'typeToTest' during \r\n type graph traversal inside 'DetectStructureCircularity' or 'GetDependenceChain'.\r\n \r\n The following rules are in place: \r\n   (a) we order all symbols according their first source location \r\n       comparison rules: first, source file names are compared, \r\n       then SourceSpan.Start is used for symbols inside the same file;\r\n   (b) given this order we enter the loop if only 'typeToTest' is 'less' than \r\n       'structBeingAnalyzed';\r\n   (c) we also always enter types from other modules\r\n \r\n !!! To be ONLY used in 'CheckStructureCircularity'.\r\n ":"\r\n 简单地检查我们是否应该进入类型的“ TypeTotest”类型\r\n 类型的图形遍历“检测缩写状态”或“ getDepentenceChain”。\r\n \r\n 以下规则已就位：\r\n   （a）我们根据其第一个源位置订购所有符号\r\n       比较规则：首先比较源文件名，\r\n       然后，sourcespan.start用于同一文件中的符号。\r\n   （b）鉴于此订单，我们输入循环，如果仅“ typeTotest”是“少”\r\n       “结构分析”；\r\n   （c）我们也总是从其他模块中输入类型\r\n \r\n !!!仅在“ checkstrasturecircularity”中使用。\r\n \r\n","No best type was found for the switch expression.":"没有找到开关表达式的最佳类型。\r\n","\r\n Validate and apply appropriate conversion for the target argument of Is/IsNot expression.\r\n ":"\r\n 验证并对IS/ISNOT表达的目标参数应用适当的转换。\r\n \r\n",".  It must only\r\n            have a single parameter, with the provided ":"。它必须只有\r\n            有一个参数，提供\r\n","Remove unused member":"删除未使用的成员\r\n"," of the unmapped document containing the active statement (i.e. the document that has the #line directive mapping the statement to one of the specified ":" 包含活动语句的未藏品文档（即具有#line指令将语句映射到指定的文档的文档\r\n","\r\n The conversion of the enumerator to the target type on which Dispose is called \r\n (contains a placeholder).\r\n ":"\r\n 将枚举者转换为被称为处置的目标类型\r\n （包含一个占位符）。\r\n \r\n","\r\n Do additional verification of interfaces after acyclic interfaces are found. This is\r\n the chance to generate diagnostics that may need to walk interfaces and as such\r\n can be performed only after the interfaces have been determined and cycles broken.\r\n (For instance, checking constraints on Class C(Of T) Implements I(Of C(Of T)).)\r\n ":"\r\n 在发现无环接口后对接口进行额外验证。这是\r\n 产生可能需要走接口的诊断的机会等等\r\n 只有在确定接口并损坏界面后才能执行。\r\n （例如，检查对C（t）类上的约束，实现I（t（of t）的c（of t））。\r\n \r\n","'RefKind.Out' is not a valid ref kind for a return type.":"“ Refkind.out”不是返回类型的有效REF类型。\r\n","The syntax node that declares an event.":"声明事件的语法节点。\r\n"," as we resolve TypeRefs from the module.\r\n ":" 当我们从模块解析键入时。\r\n \r\n","\r\n            Adding a static field to an existing type.\r\n            ":"\r\n            将静态字段添加到现有类型中。\r\n            \r\n","Where to put errors":"在哪里放错误\r\n","Indent all parameters":"缩进所有参数\r\n","\r\n            Get the user-specified naming rules, with the added ":"\r\n            获取用户指定的命名规则，并添加\r\n"," Creates a token with kind StringLiteralToken from a string value. ":" 从字符串值创建具有属性的字符串LiteralToken的令牌。\r\n","\r\n The value for the OfKeyword property.\r\n ":"\r\n OFKEYWORD属性的值。\r\n \r\n","\r\n Returns a copy of this with the SecondExpression property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，第二个表达属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            Gets the description of the item.\r\n            ":"\r\n            获取项目的描述。\r\n            \r\n","\r\n Interfaces that are implemented or inherited (if current type is interface itself).\r\n ":"\r\n 实现或继承的接口（如果当前类型是接口本身）。\r\n \r\n","\r\n Supported Visual Basic language versions.\r\n ":"\r\n 支持的视觉基本语言版本。\r\n \r\n","start of string or line":"字符串或行的开始\r\n","\r\n Gets the return type of the event (typically System.Void). \r\n ":"\r\n 获取事件的返回类型（通常是System.Void）。\r\n \r\n","\r\n The value for the ClassKeyword property.\r\n ":"\r\n classKeyword属性的值。\r\n \r\n"," Queue element structure ":" 队列元素结构\r\n","\r\n The value for the AliasKeyword property.\r\n ":"\r\n AliasKeyWord属性的值。\r\n \r\n","\r\n If overload resolution successfully selected a single best method, returns information\r\n about that method. Otherwise returns Nothing.\r\n ":"\r\n 如果超载分辨率成功选择了单个最佳方法，请返回信息\r\n 关于该方法。否则什么都不会返回。\r\n \r\n"," True if 'Overrides' is explicitly specified in method's declaration ":" 是的，如果在方法的声明中明确指定了“覆盖”\r\n","\r\n            Finds a QueryExpressionSyntax node for the span.\r\n            ":"\r\n            为跨度找到一个QueryExpressionsyntax节点。\r\n            \r\n","\r\n Determine if member is the definition of the type, or \r\n is contained (directly or indirectly) in the definition of the type.\r\n ":"\r\n 确定成员是类型的定义，还是\r\n 在类型的定义中（直接或间接）包含（直接或间接）。\r\n \r\n","This is the suggested ":"这是建议的\r\n","\r\n  Looks up a localized string similar to 'Sub' or 'Function' expected..\r\n":"\r\n  查找类似于“ sub”或“函数”预期的本地化字符串。\r\n\r\n"," of the node.\r\n ":" 节点。\r\n \r\n","\r\n The value for the Standalone property.\r\n ":"\r\n 独立属性的值。\r\n \r\n","\r\n The \"(\" token if present.\r\n ":"\r\n “”（如果存在）。\r\n \r\n","Generator failed to generate source.":"发电机无法生成源。\r\n","\r\n Returns true if this type is known to be a value type. It is never the case\r\n that IsReferenceType and IsValueType both return true. However, for an unconstrained\r\n type parameter, IsReferenceType and IsValueType will both return false.\r\n ":"\r\n 如果已知该类型是值类型，则返回true。从来没有\r\n IsReferenceType和ISVALUETYPE都返回true。但是，对于不受限制的\r\n 类型参数，IsReferenceType和ISVALUETYPE都将返回false。\r\n \r\n","Merge with nested '{0}' statement":"与嵌套'{0}'语句合并\r\n","\r\n The value for the Invocation property.\r\n ":"\r\n 调用属性的值。\r\n \r\n","Add 'await'":"添加“等待”\r\n","Selection can not contain a pattern expression.":"选择不能包含模式表达式。\r\n","\r\n            Gets the set of naming rules the user has set for this document.  Will include a set of default naming rules\r\n            that match if the user hasn't specified any for a particular symbol type.  The are added at the end so they\r\n            will only be used if the user hasn't specified a preference.\r\n            ":"\r\n            获取用户为此文档设置的命名规则集。将包括一组默认命名规则\r\n            如果用户未针对特定符号类型指定任何内容，则匹配。最后添加了\r\n            仅当用户未指定偏好时才使用。\r\n            \r\n","\r\n  Looks up a localized string similar to Enum in an interface cannot be declared '{0}'..\r\n":"\r\n  查找与接口中类似枚举类似的本地化字符串，无法声明“ {0}”。\r\n\r\n","Metadata kind (assembly or module).":"元数据（组件或模块）。\r\n","Cannot ref-assign '{1}' to '{0}' because '{1}' has a narrower escape scope than '{0}'.":"无法ref-ref-sapeign'{1}'to'{0}'，因为'{1}'具有比'{0}'的较窄的逃生范围。\r\n","\r\n            Return all diagnostics for the given document stored in this state including non local diagnostics for this document\r\n            ":"\r\n            返回存储在此状态中的给定文档的所有诊断，包括本文档的非本地诊断。\r\n            \r\n","\r\n A namespace binder provides the context for a namespace symbol; e.g., looking up names\r\n inside the namespace.\r\n ":"\r\n 名称空间粘合剂为命名空间符号提供了上下文；例如，查找名称\r\n 在名称空间内。\r\n \r\n",".\r\n An IVT attribute without a public key setting is represented by an entry that is empty in the returned list\r\n ":"。\r\n 没有公共密钥设置的IVT属性由返回列表中空的条目表示\r\n \r\n","\r\n            Text changes to make to the document.  Usually just the import to add.  May also\r\n            include a change to the name node the feature was invoked on to fix the casing of it.\r\n            May be empty for fixes that don't need to add an import and only do something like\r\n            add a project/metadata reference.\r\n            ":"\r\n            文本更改以对文档进行。通常只是导入。也可能\r\n            包括更改名称节点该功能已调用以修复其外壳的功能。\r\n            对于不需要添加导入而只做类似的事情的修复程序可能是空的\r\n            添加项目/元数据参考。\r\n            \r\n","\r\n The value for the WithKeyword property.\r\n ":"\r\n withkeyword属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to 'RemoveHandler' declaration must end with a matching 'End RemoveHandler'..\r\n":"\r\n  查找类似于“ Remove Handler”声明的本地化字符串必须以匹配的“ End remove Handler”结束。\r\n\r\n","\r\n Returns whether this method is using VARARG calling convention.\r\n ":"\r\n 返回此方法是否使用vararg呼叫约定。\r\n \r\n","can't not construct final tree":"不能构造最后一棵树\r\n","\r\n  Looks up a localized string similar to 'System.Runtime.InteropServices.DispIdAttribute' cannot be applied to '{0}' because 'Microsoft.VisualBasic.ComClassAttribute' reserves values less than zero..\r\n":"\r\n  查找类似于'system.runtime.interopservices.dispidattribute'的本地化字符串，不能应用于'{0}'，因为'microsoft.visualbasic.classic.classic.classattribute'储存小于零..的值。\r\n\r\n","The expected node kind.":"预期的节点种类。\r\n","\r\n            Try use the existing syntax node and generate a new syntax node for the given ":"\r\n            尝试使用现有语法节点并为给定的新语法节点生成新的语法节点\r\n","\r\n Returns a copy of this with the UpperBound property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，上行属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n The value for the Aggregation property.\r\n ":"\r\n 聚合属性的值。\r\n \r\n","\r\n If this returns True, exactly one of ":"\r\n 如果这是真的，那恰恰是\r\n","\r\n            Architecture filter used when resolving assembly references.\r\n            ":"\r\n            解决汇编引用时使用的架构过滤器。\r\n            \r\n","\r\n Represents the \"expression Equals expression\" condition in a Join.\r\n ":"\r\n 表示“表达式等于表达式”条件。\r\n \r\n","in Source":"在来源\r\n","\r\n Displays a symbol in the VisualBasic style.\r\n ":"\r\n 以视觉质量样式显示符号。\r\n \r\n","\r\n Returns false if the field wasn't declared as \"const\", or constant value was omitted or erroneous.\r\n True otherwise.\r\n ":"\r\n 如果该字段未声明为“ const”，则返回false，或省略或错误的恒定值。\r\n 否则否则。\r\n \r\n","\r\n Implements shadowing based on\r\n §11.8.1 Overloaded Method Resolution.\r\n 7.9.\tIf M did not use any optional parameter defaults in place of explicit \r\n         arguments, but N did, then eliminate N from the set.\r\n \r\n !!!WARNING!!! The index (7.9) is based on \"VB11 spec [draft 3]\" version of documentation rather \r\n than Dev10 documentation.\r\n TODO: Update indexes of other overload method resolution rules \r\n ":"\r\n 基于\r\n §11.8.1超载方法分辨率。\r\n 7.9。如果m不使用任何可选参数默认来代替显式\r\n         争论，但n确实从集合中消除了n。\r\n \r\n ！！！警告！！！索引（7.9）基于“ VB11规格[草稿3]”文档版本而不是\r\n 比Dev10文档。\r\n TODO：更新其他过载方法的索引分辨率规则\r\n \r\n",". Prior to the use of this enum, the serialized value\r\n             was the ":". 在使用此枚举之前，序列化值\r\n             是 \r\n","Separate thousands":"分开数千\r\n","True to treat includes as semantically meaningful \r\n (pull in contents from other files and bind crefs, etc).":"真正的治疗包括语义上有意义的\r\n （从其他文件中汲取内容并绑定Crefs等）。\r\n","\r\n Gets the BaseType of this type. If the base type could not be determined, then \r\n an instance of ErrorType is returned. If this kind of type does not have a base type\r\n (for example, interfaces), Nothing is returned. Also the special class System.Object\r\n always has a BaseType of Nothing.\r\n ":"\r\n 获取这种类型的底套。如果无法确定基本类型，则\r\n 返回错误类型的实例。如果这种类型没有基本类型\r\n （例如，接口），什么都没有返回。还有特殊类系统。\r\n 总是没有一无所有的基准。\r\n \r\n"," where argument completion is requested.\r\n            ":" 请求参数完成的地方。\r\n            \r\n","GetType":"getType\r\n","\r\n Gets the parameters of this property. If this property has no parameters, returns\r\n an empty list.\r\n ":"\r\n 获取此属性的参数。如果此属性没有参数，请返回\r\n 一个空列表。\r\n \r\n","Partial method '{0}' must have accessibility modifiers because it has a 'virtual', 'override', 'sealed', 'new', or 'extern' modifier.":"部分方法'{0}'必须具有可访问性修饰符，因为它具有“虚拟”，“覆盖”，“密封”，“新”或“ Extern”修饰符。\r\n","Structures":"结构\r\n","\r\n If this is a type parameter of a reduced extension method, gets the type parameter definition that\r\n this type parameter was reduced from. Otherwise, returns Nothing.\r\n ":"\r\n 如果这是简化扩展方法的类型参数，请获取类型参数定义\r\n 此类参数从中降低。否则，什么都没有。\r\n \r\n","\r\n            If the symbol is a local or anonymous function (lambda or delegate), adds the variables captured\r\n            by that local or anonymous function to the \"Captures\" group.\r\n            ":"\r\n            如果符号是本地或匿名函数（lambda或委托），则添加捕获的变量\r\n            通过“捕获”组的本地或匿名函数。\r\n            \r\n"," that works by comparing the\r\n            provided ":" 通过比较\r\n            假如\r\n","-indexer.  In order to convert between methods, the type\r\n             must have identical overloads except that one takes an ":"-Indexer。为了在方法之间转换，该类型\r\n             必须具有相同的超载\r\n","\r\n            The rule replaces the existing set of characters.\r\n            ":"\r\n            该规则替换了现有的字符集。\r\n            \r\n","\r\n Return true if there Is a source declaration symbol name that meets given predicate.\r\n ":"\r\n 如果有一个符合给定谓词的源声明符号名称，则返回true。\r\n \r\n"," under one of these nodes are checked.\r\n            ":" 在这些节点之一下被检查。\r\n            \r\n","\r\n            Get project diagnostics (diagnostics with no source location) of the given diagnostic ids from the given solution. all diagnostics returned should be up-to-date with respect to the given solution.\r\n            Note that this method doesn't return any document diagnostics. Use ":"\r\n            从给定解决方案获取给定诊断ID的项目诊断（无源位置的诊断）。返回的所有诊断均应相对于给定的解决方案进行最新。\r\n            请注意，此方法不会返回任何文档诊断。利用\r\n","\r\n Compute the nesting depth of a given block.\r\n Topmost block (where method locals and parameters are defined) are at the depth 0.\r\n ":"\r\n 计算给定块的嵌套深度。\r\n 最上方的块（定义了当地的方法和参数）在深度0。\r\n \r\n","Indent wrapped arguments":"缩进包裹的论点\r\n","\r\n The \":\" token, if an attribute modifier is present. If no attribute modifier is\r\n present, Nothing is returned.\r\n ":"\r\n 如果存在属性修饰符，则“：”令牌。如果没有属性修饰符是\r\n 目前，什么都没有归还。\r\n \r\n","\r\n Second part of BindSimpleName.\r\n It is a separate function so that it could be called directly \r\n when we have already looked up for the name.\r\n ":"\r\n bindsimplename的第二部分。\r\n 这是一个单独的函数，因此可以直接调用\r\n 当我们已经仰望这个名字时。\r\n \r\n","\r\n  Looks up a localized string similar to Error reading ruleset file {0} - {1}.\r\n":"\r\n  查找类似于错误阅读规则集文件{0}  -  {1}的本地化字符串。\r\n\r\n","\r\n            Only return this service as valid when we're typing curly braces inside an interpolated string.\r\n            Otherwise curly braces should be completed using the ":"\r\n            仅当我们在插值字符串中输入卷曲括号时，仅将此服务返回。\r\n            否则，应使用\r\n","\r\n The type binder class handles binding of type names.\r\n ":"\r\n 类型粘合剂类处理类型名称的绑定。\r\n \r\n"," \r\n Property declaration syntax node. \r\n It is either PropertyStatement for normal properties or FieldDeclarationSyntax for WithEvents ones.\r\n ":" \r\n 属性声明语法节点。\r\n 它要么是正常属性的属性定义，要么是事件的fieldDeclarationsyntax。\r\n \r\n","\r\n            Remove Spacing\r\n        ":"\r\n            卸下间距\r\n        \r\n","\r\n The value for the LessThanToken property.\r\n ":"\r\n LifeThantoken财产的价值。\r\n \r\n","Modifying source with experimental language features enabled requires restarting the application.":"使用启用实验语言功能修改源需要重新启动应用程序。\r\n","s[^n]":"s [^n]\r\n","\r\n  Looks up a localized string similar to Invalid debug information format: {0}.\r\n":"\r\n  查找类似于无效调试信息格式的本地化字符串：{0}。\r\n\r\n","If true then allow the keyword \"key\" to prefix the field initializer":"如果为true，则允许关键字“键”前缀字段初始化器\r\n","\r\n Scan trivia on one LOGICAL line\r\n Will check for whitespace, comment, EoL, implicit line break\r\n EoL may be consumed as whitespace only as a part of line continuation ( _ )\r\n ":"\r\n 在一条逻辑线上扫描琐事\r\n 将检查空格，评论，EOL，隐式线路休息\r\n EOL只能作为线条延续的一部分（_）才能被消耗为Whitespace\r\n \r\n","The name of the method or property to look for.":"要寻找的方法或属性的名称。\r\n","The arguments of the method call.":"方法调用的参数。\r\n","\r\n            A completion provider for offering ":"\r\n            提供商的完整提供商\r\n","\r\n            Rules for how the individual items are handled.\r\n            ":"\r\n            关于如何处理单个项目的规则。\r\n            \r\n","\r\n Represents the end of interpolated string when parsing.\r\n ":"\r\n 解析时代表插值字符串的末端。\r\n \r\n","The collection of the for each statement.":"每个语句的集合。\r\n","Filter expression is a constant 'false', consider removing the try-catch block":"滤波器表达式是常数的“ false”，请考虑删除try-catch块\r\n","\r\n If this method overrides another method (because it both had the Overrides modifier\r\n and there correctly was a method to override), returns the overridden method.\r\n ":"\r\n 如果此方法覆盖了另一种方法（因为它两者都具有覆盖器修饰符\r\n 并且正确地是一种覆盖方法），返回覆盖方法。\r\n \r\n","\r\n Represents a group of attributes within \"<\" and \">\" brackets.\r\n ":"\r\n 代表“ <”和“>”括号内的一组属性。\r\n \r\n","\r\n Represents the list of Imports statements at the beginning of a source file.\r\n ":"\r\n 表示源文件开头的导入语句列表。\r\n \r\n","\r\n Class to represent a synthesized attribute\r\n ":"\r\n 代表合成属性的类\r\n \r\n","Invalid or missing target for 'SuppressMessageAttribute'":"无效或缺少“抑制”目标的目标\r\n","\r\n The underlying AssemblySymbol, it leaks symbols that should be retargeted.\r\n This cannot be an instance of RetargetingAssemblySymbol.\r\n ":"\r\n 它的基础组合符号，它泄漏了应重新定位的符号。\r\n 这不能是retargetingAssemblysymbol的一个实例。\r\n \r\n","\r\n Makes it look like Option Strict is Off, all other operations\r\n are delegated up the chain.\r\n ":"\r\n 使看起来很严格的选项不在了，所有其他操作\r\n 被委派成链。\r\n \r\n","\r\n            Not a range bound.\r\n            ":"\r\n            没有范围。\r\n            \r\n","\r\n            Display parts for this parameter that should be presented to the user when this\r\n            parameter is selected.\r\n            ":"\r\n            显示此参数的零件，应在此时向用户呈现\r\n            选择参数。\r\n            \r\n","\r\n Creates the syntax representation of an xml text that contains a newline token with a documentation comment \r\n exterior trivia at the end (continued documentation comment).\r\n ":"\r\n 创建XML文本的语法表示，该文本包含带有文档注释的newline令牌\r\n 最后的琐事（持续文档评论）。\r\n \r\n","\r\n  Looks up a localized string similar to 'Await' may only be used in a query expression within the first collection expression of the initial 'From' clause or within the collection expression of a 'Join' clause..\r\n":"\r\n  查找类似于“等待”的本地化字符串只能在“初始”子句的第一个集合表达式中的查询表达式中使用，或者在“ join”子句的集合表达式中使用。\r\n\r\n","o switch { int _ => ... }":"o开关{int _ => ...}\r\n","\r\n Gets the name of a symbol as it appears in metadata. Most of the time, this\r\n is the same as the Name property, with the following exceptions:\r\n 1) The metadata name of generic types includes the \"`1\", \"`2\" etc. suffix that\r\n indicates the number of type parameters (it does not include, however, names of\r\n containing types or namespaces).\r\n 2) The metadata name of methods that overload or override methods with the same\r\n case-insensitive name but different case-sensitive names are adjusted so that\r\n the overrides and overloads always have the same name in a case-sensitive way.\r\n \r\n It should be noted that Visual Basic merges namespace declaration from source\r\n and/or metadata with different casing into a single namespace symbol. Thus, for\r\n namespace symbols this property may return incorrect information if multiple declarations\r\n with different casing were found.\r\n ":"\r\n 获取出现在元数据中的符号的名称。大多数时候，这个\r\n 与名称属性相同，但有以下例外：\r\n 1）通用类型的元数据名称包括“ 1”，'2“等。后缀\r\n 指示类型参数的数量（不包括\r\n 包含类型或名称空间）。\r\n 2）超载或覆盖方法的元数据名称与相同的方法\r\n 对案例不敏感的名称，但对情况敏感的名称进行了调整，以便\r\n 覆盖和过载总是以案例敏感的方式具有相同的名称。\r\n \r\n 应该注意的是，Visual Basic合并了来自源的名称空间声明\r\n 和/或带有不同外壳的元数据成一个单个名称空间符号。因此，是\r\n 命名空间符号如果多个声明，此属性可能会返回错误的信息\r\n 发现不同的外壳。\r\n \r\n"," (the destination to navigate to when clicked) and a ":" （点击时要导航到的目的地）和\r\n","\r\n Returns true if this type was declared as requiring a derived class;\r\n i.e., declared with the \"MustInherit\" modifier. Always true for interfaces.\r\n ":"\r\n 如果将这种类型声明为要求派生类，则返回为true；\r\n 即，用“必须透明”修饰符声明。对于接口总是正确的。\r\n \r\n","\r\n The value for the CustomKeyword property.\r\n ":"\r\n CustomKeyWord属性的值。\r\n \r\n","\r\n Return a BoundXmlMemberAccess node with\r\n updated MemberAccess property.\r\n ":"\r\n 返回一个带有boundxmlmemberaccess节点\r\n 更新的MemberAccess属性。\r\n \r\n","\r\n            All line changes made in changed documents.\r\n            ":"\r\n            更改文档中的所有行更改。\r\n            \r\n"," statements, only the last statement requires braces.":" 语句，只有最后一个语句需要大括号。\r\n","\r\n Get the lowest bound node in the tree associated with a particular syntax node. Lowest is defined as last\r\n in a pre-order traversal of the bound tree.\r\n ":"\r\n 获取与特定语法节点关联的树中的最低结合节点。最低定义为最后\r\n 在绑定树的预订遍历中。\r\n \r\n","A string representing the text in a half width Unicode form.":"以半宽Unicode形式表示文本的字符串。\r\n","\r\n The value for the EventExpression property.\r\n ":"\r\n 事件表达属性的值。\r\n \r\n","\r\n Gets a value indicating whether this argument is an omitted argument.\r\n ":"\r\n 获取一个指示此参数是否为省略的参数的值。\r\n \r\n","\r\n            Base type for class or struct. Shown as O↑\r\n            ":"类或结构的基本类型。显示为o↑\r\n            \r\n","\r\n Subclasses may override LeaveRegion to perform any action at the end of the region.\r\n ":"\r\n 子类可能覆盖莱维利奥以在该地区尽头执行任何动作。\r\n \r\n","A collection of reported diagnostics during parsing of symbolList, can be empty IEnumerable.":"在解析符合者期间，报告的诊断集合可以是空的。\r\n"," that can be used to prioritize\r\n            work.\r\n            ":" 可以用来优先级\r\n            工作。\r\n            \r\n","\r\n  Looks up a localized string similar to Either the parameter type or the return type of this conversion operator must be of the containing type '{0}'..\r\n":"\r\n  查找类似于参数类型的本地化字符串或此转换操作员的返回类型必须为“ {0}”。\r\n\r\n","\r\n            The set of well known kinds used for the ":"\r\n            一套众所周知的类型\r\n","\r\n            Gets a value indicating whether the file header is missing.\r\n            ":"\r\n            获取一个值，该值指示文件头是否丢失。\r\n            \r\n","\r\n Gets a value indicating whether this instance is metadata constant. A field is considered to be \r\n metadata constant if the field value is a valid default value for a field.\r\n ":"\r\n 获取一个指示此实例是否为元数据常数的值。一个字段被认为是\r\n 元数据常数如果字段值是字段的有效默认值。\r\n \r\n","\r\n Represents a string of XML characters embedded as the content of an XML\r\n element.\r\n ":"\r\n 表示嵌入为XML的内容的XML字符串\r\n 元素。\r\n \r\n","\r\n Reports the overloads error for this type.\r\n ":"\r\n 报告此类型的过载错误。\r\n \r\n","Generate constructor in '{0}' (with properties)":"在“ {0}”中生成构造函数（带有属性）\r\n","User Diagnostic Analyzer Failure.":"用户诊断分析仪失败。\r\n","\r\n  Looks up a localized string similar to Interface '{0}' cannot inherit from itself: {1}.\r\n":"\r\n  查找类似于接口'{0}'的本地化字符串不能从自身继承：{1}。\r\n\r\n",".\r\n  \r\n  The assembly references listed in the metadata AssemblyRef table are matched to the resolved references \r\n  stored on this ":"。\r\n  \r\n  元数据汇编表中列出的汇编参考表与已解决的参考\r\n  存储在此上\r\n","\r\n Returns a copy of this with the NameEquals property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中nameequals属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Replace '{0}' and '{1}' with property":"用属性替换'{0}'和'{1}'\r\n","\r\n  Looks up a localized string similar to Methods of 'System.Nullable(Of T)' cannot be used as operands of the 'AddressOf' operator..\r\n":"\r\n  查找类似于“ system.nullable（t）”方法的局部字符串，不能用作“地址”操作员的操作数。\r\n\r\n","\r\n Returns a copy of this with the Target property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，目标属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n Construct a new type from this type, substituting the given type arguments for the \r\n type parameters. This method should only be called if this named type does not have\r\n any substitutions applied for its own type arguments with exception of alpha-rename\r\n substitution (although it's container might have substitutions applied).\r\n ":"\r\n 从这种类型构建一种新类型，将给定类型的参数替换为\r\n 类型参数。仅当此命名类型没有\r\n 除alpha-rename以外\r\n 替换（尽管它的容器可能具有替换）。\r\n \r\n","\r\n The list of contained ModuleSymbol objects. First item in the list\r\n is RetargetingModuleSymbol that wraps corresponding SourceModuleSymbol \r\n from m_UnderlyingAssembly.Modules list, the rest are PEModuleSymbols for \r\n added modules.\r\n ":"\r\n 包含的模块符号对象的列表。列表中的第一项\r\n 是retargetingModulesymbol，包裹相应的SourceModulesymbol\r\n 从m_underlyingAssembly.modules列表中，其余的是pemodulesymbols\r\n 添加了模块。\r\n \r\n","\r\n            The transformed document that was produced as a result of the extract method operation.\r\n            ":"\r\n            由于提取方法操作而产生的转换文档。\r\n            \r\n","\r\n Method to early decode applied well-known attribute which can be queried by the binder.\r\n This method is called during attribute binding after we have bound the attribute types for all attributes,\r\n but haven't yet bound the attribute arguments/attribute constructor.\r\n Early decoding certain well-known attributes enables the binder to use this decoded information on this symbol\r\n when binding the attribute arguments/attribute constructor without causing attribute binding cycle.\r\n ":"\r\n 早期解码的方法应用了众所周知的属性，该属性可以由粘合剂查询。\r\n 在我们绑定所有属性的属性类型之后，在属性绑定期间调用此方法\r\n 但是尚未绑定属性参数/属性构造函数。\r\n 早期解码某些众所周知的属性使粘合剂能够在此符号上使用此解码信息\r\n 当绑定属性参数/属性构造函数时，而不会引起属性结合周期。\r\n \r\n","\r\n            If specified, any exception thrown by the script top-level code is passed to ":"\r\n            如果指定，则脚本顶级代码抛出的任何例外将传递给\r\n","\r\n Generates the name of a field where initial thread ID is stored\r\n ":"\r\n 生成存储初始线程ID的字段的名称\r\n \r\n"," Anonymous type/delegate location ":" 匿名类型/委托位置\r\n","\r\n            Returns true if the passed in node contains an interleaved pp directive.\r\n            \r\n            i.e. The following returns false:\r\n            \r\n              void Goo() {\r\n            #if true\r\n            #endif\r\n              }\r\n            \r\n            #if true\r\n              void Goo() {\r\n              }\r\n            #endif\r\n            \r\n            but these return true:\r\n            \r\n            #if true\r\n              void Goo() {\r\n            #endif\r\n              }\r\n            \r\n              void Goo() {\r\n            #if true\r\n              }\r\n            #endif\r\n            \r\n            #if true\r\n              void Goo() {\r\n            #else\r\n              }\r\n            #endif\r\n            \r\n            i.e. the method returns true if it contains a PP directive that belongs to a grouping\r\n            constructs (like #if/#endif or #region/#endregion), but the grouping construct isn't\r\n            entirely contained within the span of the node.\r\n            ":"\r\n            如果节点中的传递包含交错的PP指令，则返回true。\r\n            \r\n            即以下返回错误：\r\n            \r\n              void goo（）{\r\n            ＃如果真实\r\n            ＃万一\r\n              }\r\n            \r\n            ＃如果真实\r\n              void goo（）{\r\n              }\r\n            ＃万一\r\n            \r\n            但是这些返回真实：\r\n            \r\n            ＃如果真实\r\n              void goo（）{\r\n            ＃万一\r\n              }\r\n            \r\n              void goo（）{\r\n            ＃如果真实\r\n              }\r\n            ＃万一\r\n            \r\n            ＃如果真实\r\n              void goo（）{\r\n            ＃别的\r\n              }\r\n            ＃万一\r\n            \r\n            即，如果该方法包含属于分组的PP指令，则该方法将返回true\r\n            构造（例如＃if/＃endif或＃区域/＃end Region），但是分组构造不是\r\n            完全包含在节点的跨度内。\r\n            \r\n","\r\n Containing assembly.\r\n ":"\r\n 包含组件。\r\n \r\n","\r\n            Executes analyzers on a document for computing local syntax/semantic/additional file diagnostics for a specific ":"\r\n            在用于计算本地语法/语义/附加文件诊断的文档上执行分析仪\r\n","Remove unused variable":"删除未使用的变量\r\n","\r\n The Do statement that begins the block.\r\n ":"\r\n 开始块的DO语句。\r\n \r\n","\r\n Only false in debugger scenarios (where calls should never be omitted).\r\n ":"\r\n 仅在调试器方案中仅为false（永远不要省略呼叫）。\r\n \r\n","symbol, modifier":"符号，修饰符\r\n","The new token":"新的令牌\r\n","\r\n  Looks up a localized string similar to At least one parameter of this binary operator must be of the containing type '{0}'..\r\n":"\r\n  查找类似于此二进制运算符的至少一个参数的本地化字符串必须是包含类型的“ {0}” ..\r\n\r\n","\r\n Given a string which may contain newline sequences, get the index of the first newline\r\n sequence beginning at the given starting index.\r\n ":"\r\n 给定一个可能包含newline序列的字符串，获取第一个newline的索引\r\n 序列从给定的启动索引开始。\r\n \r\n","GetBaseNamesForDiagnostic(typeSyntax) (basically dot-delimited list of names).  Shortened as different prefixes are checked.":"getBasenamesfordiagnostic（typeyntax）（基本上是点数的名称列表）。检查不同的前缀时缩短。\r\n","\r\n Force a variable to have a slot.\r\n ":"\r\n 强制变量具有插槽。\r\n \r\n"," if the text does not have a navigation\r\n            target.\r\n            ":" 如果文本没有导航\r\n            目标。\r\n            \r\n","The parameterless struct constructor must be 'public'.":"无参数结构构造函数必须是“公共”。\r\n","\r\n Base class for all parameters that are emitted.\r\n ":"\r\n 所有发射参数的基类。\r\n \r\n","\r\n The new kind.\r\n ":"\r\n 新型。\r\n \r\n","\r\n Compares content of two nodes ignoring lambda bodies and trivia.\r\n ":"\r\n 比较两个节点的含量忽略了lambda身体和琐事。\r\n \r\n","The source trivia.":"来源琐事。\r\n","\r\n Get the label that a Exit XXX statement should branch to, or Nothing if we are\r\n not inside a context that would be exited by that kind of statement. The passed in kind\r\n is the SyntaxKind for the exit statement that would target the label (e.g. SyntaxKind.ExitDoStatement).\r\n ":"\r\n 获取出口XXX语句应分支到的标签，或者如果我们是什么都没有\r\n 不在这种陈述将退出的上下文中。通过了实物\r\n 是针对标签的退出语句的语法Kind（例如Syntaxkind.exitDostatement）。\r\n \r\n","\r\n Represents the \"Group By\" query operator.\r\n ":"\r\n 代表“ By”查询操作员。\r\n \r\n","\r\n The \".\" token.\r\n ":"\r\n 这 ”。”令牌。\r\n \r\n","\r\n Return true if the type parameters specified on the nested type (Me),\r\n that represent the corresponding type parameters on the containing\r\n types, in fact match the actual type parameters on the containing types.\r\n ":"\r\n 如果在嵌套类型（ME）上指定的类型参数，则返回true\r\n 代表包含的相应类型参数\r\n 类型，实际上匹配包含类型上的实际类型参数。\r\n \r\n","\r\n An elastic trivia with kind WhitespaceTrivia containing a single space character. Elastic trivia are used to\r\n denote trivia that was Not produced by parsing source text, And are usually Not preserved during formatting.\r\n ":"\r\n 具有单个空间特征的弹性琐事。弹性琐事习惯\r\n 表示未通过解析源文本产生的琐事，通常在格式期间没有保留。\r\n \r\n","\r\n A ProjectImportsBinder provides the equivalent of a SourceFileBinder, but for the project-level\r\n imports, which don't live in any file.\r\n It primarily provides the services of getting locations of nodes, since it holds onto a SyntaxTree, although\r\n that tree isn't technically a source tree.\r\n ":"\r\n ProjectImportsBinder提供了相当于SourceFileBinder的功能，但对于项目级别\r\n 导入，不在任何文件中。\r\n 它主要提供获取节点位置的服务，因为它保留在语法中，尽管\r\n 从技术上讲，那棵树不是源树。\r\n \r\n","\r\n            Get diagnostics for given span either by using cache or calculating it on the spot.\r\n            ":"\r\n            通过使用缓存或当场对给定跨度进行诊断。\r\n            \r\n","\r\n Returns the value of the Option Strict declaration if there was one, otherwise Null.\r\n ":"\r\n 如果有一个，则返回期权严格声明的值，否则为null。\r\n \r\n","Selection can not contain throw statement.":"选择不能包含投掷语句。\r\n"," \r\n Describes anonymous type field in terms of its name, type and other attributes.\r\n Or describes anonymous delegate parameter, including \"return\" parameter, in terms \r\n of its name, type and other attributes.\r\n ":" \r\n 用名称，类型和其他属性来描述匿名类型字段。\r\n 或描述匿名委托参数，包括“返回”参数\r\n 其名称，类型和其他属性。\r\n \r\n","positional fields in records":"记录中的位置字段\r\n","\r\n The \"In\" keyword.\r\n ":"\r\n “ in”关键字。\r\n \r\n","\r\n Returns a copy of this with the FromKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此的副本，而从keyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Binds all the common part for ForTo and ForEach loops except the loop body and the next variables.\r\n ":"\r\n 绑定除循环主体和下一个变量以外的forto和foreach循环的所有常见部分。\r\n \r\n"," was created.\r\n            Individual ":" 被创建了。\r\n            个人\r\n","\r\n  Looks up a localized string similar to 'AddressOf' expression cannot be converted to '{0}' because '{0}' is not a delegate type..\r\n":"\r\n  查找类似于“地址”表达式类似的本地化字符串不能转换为“ {0}”，因为'{0}'不是委托类型。\r\n\r\n","\r\n The value for the FormatStringToken property.\r\n ":"\r\n 格式属性属性的价值。\r\n \r\n",", which is not the first\r\n ":"，这不是第一个\r\n \r\n"," graph and\r\n may replace or remove visited SyntaxNodes in depth-first order.\r\n ":" 图和\r\n 可以在深度优先替换或删除访问的语法。\r\n \r\n","\r\n  Looks up a localized string similar to Invalid signature public key specified in AssemblySignatureKeyAttribute..\r\n":"\r\n  查找类似于InvelySignature Keytribute中指定的无效签名公共密钥的本地化字符串。\r\n\r\n","\r\n A helper method for ReferenceManager to set assembly identities for assemblies \r\n referenced by this module and corresponding AssemblySymbols.\r\n ":"\r\n 引用meanager的辅助方法，以设置汇编的汇编身份\r\n 由该模块和相应的汇编符号引用。\r\n \r\n","static anonymous function":"静态匿名函数\r\n","\r\n Merges two lookup results while eliminating symbols that are shadowed.\r\n Note that the final result may contain unrelated and possibly conflicting symbols as\r\n this helper is not intended to catch ambiguities.\r\n ":"\r\n 合并两个查找结果，同时消除被阴影的符号。\r\n 请注意，最终结果可能包含无关且可能相互冲突的符号\r\n 这个帮手并不是要抓住歧义。\r\n \r\n","\r\n            Similar to ISuggestedAction, but in a location that can be used by both local Roslyn and LSP.\r\n            ":"\r\n            类似于IsuggesteDaction，但在本地Roslyn和LSP可以使用的位置。\r\n            \r\n","Remove Unnecessary Cast":"删除不必要的演员\r\n","\r\n            One of \\b \\B \\A \\G \\z \\Z\r\n            ":"\r\n            \\ b \\ b \\ a \\ g \\ z \\ z之一\r\n            \r\n","\r\n Return the slot for a variable, or SlotKind.NotTracked if it is not tracked (because, for example, it is an empty struct).\r\n ":"\r\n 返回插槽以获取变量，或slotkind.nottrack.如果没有跟踪（例如，因为它是一个空的struct）。\r\n \r\n","\r\n             Determines if any of the state sets in ":"\r\n             确定是否有任何状态设置\r\n","\r\n The container of the event. This can be one of the special keywords: \"Me\",\r\n \"MyBase\" or \"MyClass\".\r\n ":"\r\n 事件的容器。这可能是特殊关键字之一：“我”，\r\n “ mybase”或“ myclass”。\r\n \r\n","\r\n The value for the Token2 property.\r\n ":"\r\n Token2属性的值。\r\n \r\n","\r\n Represents a type parameter in a generic type or generic method.\r\n ":"\r\n 代表通用类型或通用方法中的类型参数。\r\n \r\n","If all required methods have been successfully looked up and bound, true is being returned; otherwise false.\r\n ":"如果所有必需的方法都已成功查找并绑定，则将返回真实；否则错误。\r\n \r\n","Syntax node to attach diagnostics to in case the argument list is nothing.":"如果参数列表一无所有，则将诊断的语法节点连接到诊断。\r\n","\r\n If this method has MethodKind of MethodKind.PropertyGet or MethodKind.PropertySet,\r\n returns the property that this method is the getter or setter for.\r\n If this method has MethodKind of MethodKind.EventAdd or MethodKind.EventRemove,\r\n returns the event that this method is the adder or remover for.\r\n Note, the set of possible associated symbols might be expanded in the future to \r\n reflect changes in the languages.\r\n ":"\r\n 如果此方法具有MethodKind.propertyget或MethodKind.propertyset的MethodKind，则\r\n 返回此方法是Getter或setter的属性。\r\n 如果此方法具有MethodKind.eventadd或MethodKind.eventremove的MethodKind，则\r\n 返回此方法是加法器或去除剂的事件。\r\n 注意，将来可能会扩展一组可能的相关符号\r\n 反映语言的变化。\r\n \r\n","\r\n Parses a specified string to create a GlobalImport instance with diagnostics info.\r\n ":"\r\n 解析指定的字符串，以创建具有诊断信息的GlobalImport实例。\r\n \r\n","\r\n  Looks up a localized string similar to Auto-implemented Properties contained in Structures cannot have initializers unless they are marked 'Shared'..\r\n":"\r\n  查找类似于结构中包含的自动实现属性的本地化字符串，除非将其标记为“共享”。\r\n\r\n","\r\n The Using statement that begins a Using block. This statement always occurs as\r\n the Begin of a UsingBlock, and the body of the Using is the Body of that\r\n UsingBlock.\r\n ":"\r\n 开始使用块的使用语句。这个陈述总是发生\r\n 使用block的开始，而使用的主体是它的主体\r\n 使用block。\r\n \r\n"," format\r\n            strings in a document efficiently.\r\n            ":" 格式\r\n            文档中的字符串有效。\r\n            \r\n","\r\n A custom equality comparer for ":"\r\n 一个自定义平等比较\r\n","\r\n Binds a parameter's default value syntax\r\n ":"\r\n 绑定参数的默认值语法\r\n \r\n","The \"h\" custom format specifier represents the hour as a number from 1 through 12; that is, the hour is represented by a 12-hour clock that counts the whole hours since midnight or noon. A particular hour after midnight is indistinguishable from the same h ...":"“ H”自定义格式指定符表示小时为1到12的数字；也就是说，小时以12小时的时钟为代表，该时钟算在午夜或中午以来的整个小时。午夜后的特定小时与同一H ...\r\n","\r\n Create a BoundExpression representing an array creation initialized with the given items.\r\n If there are zero items, the result is a BoundLiteral Nothing, otherwise, a BoundArrayCreation.\r\n ":"\r\n 创建代表用给定项目初始化的数组创建的界表达。\r\n 如果有零项目，则结果是一个界限，否则是边界造成的。\r\n \r\n","Parameter is unread. Did you forget to use it to initialize the property with that name?":"参数未读。您是否忘记使用它用该名称初始化该属性？\r\n","The generic containing type.":"通用类型。\r\n","\r\n            The span this session applies to.\r\n            \r\n            Navigation outside this span will cause signature help to be dismissed.\r\n            ":"\r\n            该会话适用的跨度。\r\n            \r\n            在此跨度之外的导航将导致签名帮助被解雇。\r\n            \r\n","\r\n The closing '\"', '”', or '“' token.\r\n ":"\r\n 关闭的'“'，''”或“”令牌。\r\n \r\n","\r\n Represents event container specified through special keywords \"Me\", \"MyBase\" or\r\n \"MyClass\"..\r\n ":"\r\n 代表通过特殊关键字“ me”，“ mybase”或\r\n “我的课”..\r\n \r\n","\r\n            Optional document ID, if computing diagnostics for a specific document.\r\n            For example, diagnostic computation for open file analysis.\r\n            ":"\r\n            可选文档ID，如果计算特定文档的诊断。\r\n            例如，用于开放文件分析的诊断计算。\r\n            \r\n","\r\n  Looks up a localized string similar to Option Strict On does not allow narrowing in implicit type conversions between extension method '{0}' defined in '{2}' and delegate '{1}'..\r\n":"\r\n  查找类似于“严格的选项”的本地化字符串，不允许在“ {2}'and demegate”中定义的扩展方法'{0}'之间的隐式类型转换中缩小缩小。\r\n\r\n","\r\n  Looks up a localized string similar to '{0}' cannot be named as a parameter in an attribute specifier because it is not a field or property..\r\n":"\r\n  查找类似于'{0}'的本地化字符串在属性指示符中不能命名为参数，因为它不是字段或属性。\r\n\r\n","Implement Interface":"实施接口\r\n","month (abbreviated)":"月（缩写）\r\n","\r\n            The implementation has to decide what kinds of nodes in top-level match relationship represent a declaration.\r\n            Every member declaration must be represented by exactly one node, but not all nodes have to represent a declaration.\r\n            \r\n            If a member doesn't have a body (null is returned) it can't have associated active statements.\r\n            \r\n            Body does not need to cover all active statements that may be associated with the member. \r\n            E.g. Body of a C# constructor is the method body block. Active statements may be placed on the base constructor call.\r\n                 Body of a VB field declaration with shared AsNew initializer is the New expression. Active statements might be placed on the field variables.\r\n            ":"\r\n            实施必须决定顶级匹配关系中哪些节点代表声明。\r\n            每个成员声明必须完全由一个节点表示，但并非所有节点都必须代表声明。\r\n            \r\n            如果成员没有车身（返回null），则无法具有关联的活动语句。\r\n            \r\n            身体不需要涵盖可能与成员关联的所有活动陈述。\r\n            例如。 c＃构造变量的主体是方法主体块。主动语句可以放在基本构造函数上。\r\n                 带有共享ASNEW初始化器的VB字段声明的主体是新表达式。活动语句可能放在字段变量上。\r\n            \r\n","\r\n When constructing this ErrorTypeSymbol, there may have been symbols that seemed to\r\n be what the user intended, but were unsuitable. For example, a type might have been\r\n inaccessible, or ambiguous. This property returns the possible symbols that the user\r\n might have intended. It will return no symbols if no possible symbols were found.\r\n See the CandidateReason property to understand why the symbols were unsuitable.\r\n ":"\r\n 在构建此errortypeSymbol时，似乎有符号\r\n 是用户想要的，但不合适。例如，一种类型可能是\r\n 无法访问或模棱两可。此属性返回用户的可能符号\r\n 可能打算了。如果找不到可能的符号，它将不会返回符号。\r\n 请参阅候选季节的财产，以了解为什么这些符号不合适。\r\n \r\n","\r\n The identifier being introduced.\r\n ":"\r\n 引入标识符。\r\n \r\n","\r\n  Looks up a localized string similar to Command-line syntax error: Missing Guid for option '{1}'.\r\n":"\r\n  查找类似于命令行语法错误的本地化字符串：选项'{1}'丢失GUID。\r\n\r\n","\r\n Returns the ranks of this array rank specifier.\r\n ":"\r\n 返回此数组排名规范符的排名。\r\n \r\n","\r\n Gets the nearest enclosing namespace for this namespace or type. For a nested type,\r\n returns the namespace that contains its container.\r\n ":"\r\n 获取此名称空间或类型的最近的封闭名称空间。对于嵌套类型\r\n 返回包含其容器的名称空间。\r\n \r\n","\r\n            Provides a conversion to query.Method() like query.ToList(), query.Count().\r\n            ":"\r\n            提供转换为query.method（），例如query.tolist（），query.count（）。\r\n            \r\n","Extract interface...":"提取接口...\r\n","\r\n            Give numbers to all named captures.  They will get successive ":"\r\n            给所有命名捕获的数字。他们将连续\r\n","\r\n Gets symbol information about an expression syntax node. This is the worker\r\n function that is overridden in various derived kinds of Semantic Models. It can assume that \r\n CheckSyntaxNode has already been called.\r\n ":"\r\n 获取有关表达语法节点的符号信息。这是工人\r\n 在各种派生的语义模型中被覆盖的函数。它可以假设\r\n checksyntaxnode已被调用。\r\n \r\n","\r\n            Exceptions are only caught and stored here if the API returning the ":"\r\n            如果API返回\r\n","\r\n  Looks up a localized string similar to An embedded expression cannot be used here..\r\n":"\r\n  在此处查找类似于嵌入式表达式的局部字符串。\r\n\r\n"," to speed up type reference resolution\r\n for metadata coming from this module. The map is lazily populated\r\n as we load types from the module.\r\n ":" 加快类型参考分辨率\r\n 对于来自该模块的元数据。该地图懒洋洋\r\n 当我们从模块加载类型时。\r\n \r\n","Use null propagation":"使用零繁殖\r\n","\r\n            Decide if we can change the namespace for provided ":"\r\n            决定是否可以更改提供的名称空间\r\n","\r\n Get all the errors within the syntax tree associated with this object. Includes errors involving compiling\r\n method bodies or initializers, in addition to the errors returned by GetDeclarationDiagnostics.\r\n ":"\r\n 在与此对象关联的语法树中获取所有错误。包括涉及编译的错误\r\n 除了getDeclarationDiagnostics返回的错误外，方法主体或初始化器。\r\n \r\n","The \"yyy\" custom format specifier represents the year with a minimum of three digits. If the year has more than three significant digits, they are included in the result string. If the year has fewer than three digits, the number is padded with leading zer ...":"“ YYY”自定义格式指定符代表至少三位数的年份。如果这一年有三个以上的重要数字，则将其包含在结果字符串中。如果这一年的数字少于三位数，那么这个数字就会带有领先的Zer ...\r\n","\r\n The value for the LoopKeyword property.\r\n ":"\r\n loopkeyword属性的值。\r\n \r\n","\r\n Emits address of a temp.\r\n Used in cases where taking address directly is not possible \r\n (typically because expression does not have a home)\r\n \r\n Will introduce a temp which it will return.\r\n ":"\r\n 发出温度的地址。\r\n 在不可能直接进行地址的情况下使用\r\n （通常是因为表达没有家）\r\n \r\n 将引入一个将返回的温度。\r\n \r\n"," with the specific ":" 与特定\r\n","\r\n            Unwraps first item.  Subsequent items, if wrapped, will be aligned with that first item:\r\n                 MethodName(int a, int b, int c, int d, int e,\r\n                            int f, int g, int h, int i, int j)\r\n            ":"\r\n            拆开第一项。随后的项目（如果包装）将与第一个项目对齐：\r\n                 methotName（int a，int b，int c，int d，int e，\r\n                            int f，int g，int h，int i，int j）\r\n            \r\n","\r\n            ```\\'name'``` or ```\\<name>``` escape.\r\n            ":"\r\n            ``\\'名称''或````\\ <name>''\r\n            \r\n","The globals of type '{0}' is not assignable to '{1}'":"类型'{0}'的全球不能分配给'{1}'\r\n","\r\n  Looks up a localized string similar to Modules cannot be declared '{0}'..\r\n":"\r\n  查找类似于模块的本地化字符串，无法声明“ {0}”。\r\n\r\n","Convert to file-scoped namespace":"转换为文件划分的名称空间\r\n","12 hour clock (1-2 digits)":"12小时时钟（1-2位数字）\r\n","\r\n An analysis that computes the set of variables that may be used\r\n before being assigned anywhere within a method.\r\n ":"\r\n 计算可能使用的变量集的分析\r\n 在方法中的任何地方分配之前。\r\n \r\n","\r\n Synthesizes a custom attribute. \r\n Returns null if the ":"\r\n 合成自定义属性。\r\n 如果是\r\n","\r\n            The enter key is always passed through to the editor after it has been used to commit the completion item.\r\n            ":"\r\n            Enter密钥用于提交完成项目后，始终将其传递给编辑器。\r\n            \r\n","\r\n            together contain a superset of the symbols in ":"\r\n            一起包含一个符号的超集\r\n","\r\n Returns a copy of this with the GetXmlNamespaceKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中getxmlnamespacekeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n The \"From\" keyword.\r\n ":"\r\n “来自”关键字。\r\n \r\n","\r\n If this is a partial method with a body, returns the corresponding\r\n definition part (without a body).  Otherwise null.\r\n ":"\r\n 如果这是带有身体的部分方法，请返回相应的\r\n 定义零件（没有身体）。否则为空。\r\n \r\n","\r\n Returns a copy of this with the EndSelectStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中EndSelectStatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n  Looks up a localized string similar to 'For Each' on type '{0}' is ambiguous because the type implements multiple instantiations of 'System.Collections.Generic.IEnumerable(Of T)'..\r\n":"\r\n  查找类似于“每个”类型'{0}'的局部字符串是模棱两可的，因为该类型实现了'system.collections.generic.generic.enumoser（t）的多个实例化'..\r\n\r\n","all letter characters":"所有字母字符\r\n","Indent all arguments":"缩进所有论点\r\n","\r\n Replaces local declaration with its initializer\r\n Also marks resulting statement with seq point that matches original declaration.\r\n ":"\r\n 将本地声明替换为其初始值设定项\r\n 还使用与原始声明匹配的seq点标记结果语句。\r\n \r\n","\r\n The name of the parameter, including any \"?\" or \"()\" modifiers.\r\n ":"\r\n 参数的名称，包括任何“？”或“（）”修饰符。\r\n \r\n","{0} is not a valid C# compound assignment operation":"{0}不是有效的C＃复合分配操作\r\n","\r\n Represents the Finally part of an Try...Catch...Finally...End Try statement,\r\n consisting of a Finally statement, followed by a body of statements controlled\r\n by the Finally.\r\n ":"\r\n 代表尝试的最后一部分...捕获...最后...结束尝试语句，\r\n 由最终的陈述组成，然后是一系列控制的陈述\r\n 最后。\r\n \r\n","\r\n If function returns false, it requests an instance of ArrayBuilder from the pool and populates\r\n it with information about illegal exposure. The caller is responsible for returning the ArrayBuilder\r\n to the pool.\r\n ":"\r\n 如果函数返回false，它将从池中请求阵列建筑器的实例并填充\r\n 它具有有关非法曝光的信息。呼叫者负责返回阵列构造器\r\n 到游泳池。\r\n \r\n","\r\n The Next statement that ends a For-Next or For Each-Next block. This statement\r\n always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),\r\n and the body of the For-Next is the Body of that ForBlock. The Begin of that\r\n ForBlock has the corresponding For or For Each statement.\r\n ":"\r\n 下一个语句结束一个邻接或每个邻近块。这个说法\r\n 总是作为forblock的末端（带有Kind = forblock或foreachBlock）的末端，\r\n 邻接的身体是那个for骨的主体。开始的开始\r\n ForBlock具有每个语句的相应或对应。\r\n \r\n","\r\n Returns true if this property is a default property. \r\n ":"\r\n 如果此属性是默认属性，则返回true。\r\n \r\n","\r\n Returns error info for an error, if any, that should be reported at the use site of the symbol.\r\n ":"\r\n 返回错误信息，以获取错误的错误信息（如果有），应在符号的使用站点上报告。\r\n \r\n","\r\n Method that is called from the CachingLookup to lookup the children of a given name. Looks\r\n in all the constituent namespaces.\r\n ":"从缓存lookup调用的方法来查找给定名称的孩子。看起来\r\n 在所有组成命名空间中。\r\n \r\n","\r\n Represent a named field initializer in a With {...} initializer, such as \".x =\r\n expr\".\r\n ":"\r\n 代表{...} initializer，例如“ .x =”中的命名字段初始器\r\n Expr”。\r\n \r\n","Pull '{0}' up":"拉'{0}'向上\r\n","indexing movable fixed buffers":"索引可移动的固定缓冲区\r\n","\r\n            Indicates whether the extracted method should have a 'readonly' modifier.\r\n            ":"\r\n            指示提取的方法是否应具有“读取”修饰符。\r\n            \r\n","\r\n Gets a value indicating whether the condition of this do loop is \"until\" or not. In syntax error cases\r\n where both conditions are used, priority is given to the first one.\r\n It's recommended to consistently use this property instead of checking TopConditionIsUntil and BottomConditionIsUntil\r\n directly.\r\n ":"\r\n 获取一个值，指示该循环的条件是否为“直到”。在语法错误案例中\r\n 在使用两个条件的情况下，将优先级给予第一个条件。\r\n 建议始终使用此属性，而不是检查TopConcontionIsuntil和BottonConconcontionIsuntil\r\n 直接地。\r\n \r\n","12 hour clock (2 digits)":"12小时时钟（2位数字）\r\n","\r\n Returns Nothing if items were omitted.\r\n ":"\r\n 如果省略物品，则什么都没有。\r\n \r\n","\r\n            checks if type name matches its parent document name, per style rules.\r\n            ":"\r\n            根据样式规则，检查类型名称是否匹配其父文档名称。\r\n            \r\n","\r\n  Looks up a localized string similar to Error signing assembly '{0}': {1}.\r\n":"\r\n  查找类似于错误签名汇编'{0}'的本地化字符串：{1}。\r\n\r\n",".\r\n            Returns empty Span with original ":"。\r\n            原始返回空跨度\r\n","\r\n The \"Enum\" keyword.\r\n ":"\r\n “枚举”关键字。\r\n \r\n","\r\n Binder used to bind using blocks. \r\n It hosts the variables declared in the resource list (if they are declared).\r\n ":"\r\n 粘合剂用于使用块绑定。\r\n 它托管了资源列表中声明的变量（如果已声明）。\r\n \r\n","\r\n            Return list of ":"\r\n            返回列表\r\n","\r\n Associate the method with a particular event. Returns\r\n false if the method is already associated with a property or event.\r\n ":"\r\n 将方法与特定事件相关联。返回\r\n false如果该方法已经与属性或事件关联。\r\n \r\n","\r\n Represents a namespace of a RetargetingModuleSymbol. Essentially this is a wrapper around \r\n another NamespaceSymbol that is responsible for retargeting symbols from one assembly to another. \r\n It can retarget symbols for multiple assemblies at the same time.\r\n ":"\r\n 代表retargetingModulesymbol的名称空间。本质上，这是周围的包装纸\r\n 另一个命名paceSymbol是负责从一个组件重新定位符号到另一个组件的。\r\n 它可以同时重新定位多个组件。\r\n \r\n"," but will return ones already created.\r\n            ":" 但是将返回已经创建的。\r\n            \r\n","Module initializer method '{0}' must be static, must have no parameters, and must return 'void'":"模块初始化器方法'{0}'必须是静态的，必须没有参数，并且必须返回'void'\r\n"," is that \r\n            this will only return ":" 就是它\r\n            这只会返回\r\n","es supplied by a given fix provider\r\n            (such as ":"由给定的修复提供者提供的ES\r\n            （如\r\n","existing parameters of the symbol":"符号的现有参数\r\n","\r\n Returns a copy of this with the ParameterList property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"返回此副本，其中参数列表属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Gets the location in terms of path, line and column after applying source line mapping directives (":"\r\n 应用源线映射指令后，请在路径，线路和列中获取位置（\r\n",".  This type takes care of a lot of common logic for\r\n            all of them, including:\r\n            \r\n            1. Keeping track of code action invocations, allowing code actions to then be prioritized on\r\n               subsequent invocations.\r\n               \r\n            2. Checking nodes and tokens to make sure they are safe to be wrapped.\r\n            \r\n            Individual subclasses may be targeted at specific syntactic forms.  For example, wrapping\r\n            lists, or wrapping logical expressions.\r\n            ":"。这种类型照顾了很多常见的逻辑\r\n            所有这些，包括：\r\n            \r\n            1.跟踪代码操作调用，允许代码操作优先考虑\r\n               随后的调用。\r\n               \r\n            2.检查节点和令牌以确保它们安全地包装。\r\n            \r\n            单个子类可以针对特定的句法形式。例如，包装\r\n            列表或包装逻辑表达式。\r\n            \r\n","\r\n            Data about a navigate to match.  Only intended for use by C# and VB.  Carries enough rich information to\r\n            rehydrate everything needed quickly on either the host or remote side.\r\n            ":"\r\n            有关导航匹配的数据。仅旨在由C＃和VB使用。提供足够丰富的信息来\r\n            在主机或远程方面快速补充所有需要的东西。\r\n            \r\n","\r\n  Looks up a localized string similar to Instance of restricted type '{0}' cannot be used in a lambda expression..\r\n":"\r\n  查找类似于限制类型的实例“ {0}”的本地化字符串。\r\n\r\n","Other result.":"其他结果。\r\n"," isn't applied on the containing module or it doesn't apply on this symbol.\r\n ":" 不应用于包含的模块，也不应用于此符号上。\r\n \r\n","\r\n Scan a single quoted string RIGHT_SINGLE_QUOTATION_MARK\r\n ":"\r\n 扫描单个引号right_single_quotation_mark\r\n \r\n"," , \r\n when they must share attribute data.\r\n ":" ，，，，\r\n 当他们必须共享属性数据时。\r\n \r\n","If specified then it is the syntax for the as clause and the type is the bound type from this syntax.":"如果指定，则是AS子句的语法，类型是该语法的界类型。\r\n"," exported.  We don't want the workspace\r\n            to automatically load this.  Instead, VS waits until it is ready\r\n            and then calls into the service to tell it to start analyzing the solution.  At that point we'll get\r\n            created and added to the solution crawler.\r\n            ":" 出口。我们不想要工作空间\r\n            自动加载此。相反，VS等到准备就绪\r\n            然后打电话给服务，告诉它开始分析解决方案。那时我们会得到\r\n            创建并添加到解决方案爬网中。\r\n            \r\n","\r\n Represents a parameter of a RetargetingMethodSymbol. Essentially this is a wrapper around \r\n another ParameterSymbol that is responsible for retargeting symbols from one assembly to another. \r\n It can retarget symbols for multiple assemblies at the same time.\r\n ":"\r\n 表示RetargetingMethodSymbol的参数。 从本质上讲，这是一个包装 \r\n 另一个ParameterSymbol，负责将符号从一个程序集重新定位到另一个程序集。 \r\n 它可以在同一时间为多个程序集重新定位符号。\r\n \r\n","Remove redundant equality":"删除冗余平等\r\n","\r\n  Looks up a localized string similar to {0}.\r\n":"\r\n  查找类似于{0}的局部字符串。\r\n\r\n","\r\n Given a modified identifier and a type syntax, return the actual type to use. Applies the type character\r\n and type modifiers to the given type.\r\n ":"\r\n 给定修改后的标识符和类型语法，返回实际使用的类型。应用类型字符\r\n 并将修饰符键入给定类型。\r\n \r\n","\r\n  Looks up a localized string similar to Range variable '{0}' hides a variable in an enclosing block, a previously defined range variable, or an implicitly declared variable in a query expression..\r\n":"\r\n  查找类似于范围变量'{0}'的局部字符串将变量隐藏在一个封闭块中，先前定义的范围变量或隐式声明中的Query表达式中的变量。\r\n\r\n","The project containing the document and text":"包含文档和文本的项目\r\n","\r\n            Description of a TODO comment type to find in a user's comments.\r\n            ":"\r\n            用户评论中查找的待办事评论类型的描述。\r\n            \r\n","\r\n Create a substitution. If the substitution is the identity substitution, Nothing is returned.\r\n ":"\r\n 创建替代。如果替换是身份替代，则什么都不会返回。\r\n \r\n","\r\n Creates a speculative MethodBodySemanticModel that allows asking semantic questions about an attribute node that did not appear in the original source code.\r\n ":"\r\n 创建一个投机方法Bodysemanticmodel，允许询问有关未出现在原始源代码中的属性节点的语义问题。\r\n \r\n","A descriptive tag from ":"来自\r\n","If the collection meets all criteria, currentType contains the type of the element from \r\n the collection that get's returned by the current property.":"如果该集合符合所有条件，则CurrentType包含来自\r\n 当前属性返回的集合。\r\n","\r\n Determine if the kind represents a contextual keyword\r\n ":"\r\n 确定类型是否代表上下文关键字\r\n \r\n"," \r\n            is treated more as a caret location.\r\n            ":" \r\n            被视为商店的位置。\r\n            \r\n","\r\n            Custom fix all provider for namespace sync. Does fix all on per document level. Since\r\n            multiple documents may be updated when changing a single namespace, it happens \r\n            on a sequential level instead of batch fixing and merging the changes. This prevents\r\n            collissions that the batch fixer won't handle correctly but is slower.\r\n            ":"\r\n            自定义命名空间同步的所有提供商。确实在每个文档级别上修复了全部。自从\r\n            更改单个名称空间时可能会更新多个文档\r\n            在连续级别而不是批处理修复和合并更改。这可以防止\r\n            批处理固定器无法正确处理但较慢的碰撞。\r\n            \r\n","\r\n            syntax trivia related services\r\n            ":"语法琐事相关服务\r\n            \r\n","\r\n            The top item of the stack indicates the hyperlink to apply to text rendered at the current location. It\r\n            consists of a navigation ":"\r\n            堆栈的最高项目指示超链接适用于当前位置呈现的文本。它\r\n            由导航组成\r\n","\r\n  Looks up a localized string similar to \r\n    Base type of '{0}' needs '{1}' to be resolved..\r\n":"\r\n  查找类似于\r\n    要解决的基本类型'{0}'需求'{1}'。\r\n\r\n","\r\n Verifies that the collection is either a string, and array or matches the design pattern criteria and reports \r\n diagnostics appropriately.\r\n ":"\r\n 验证该集合是否是字符串，并且数组或匹配设计模式标准并报告\r\n 适当的诊断。\r\n \r\n","Syntax node.":"语法节点。\r\n"," using this operation.\r\n            ":" 使用此操作。\r\n            \r\n","\r\n            ```(?(group)result)```\r\n            ":"\r\n            ``（？（组）结果）````````\r\n            \r\n","\r\n Represents the end of the source file. This token may have trivia (whitespace,\r\n comments, ...) attached to it.\r\n ":"\r\n 表示源文件的末尾。这个令牌可能有琐事（Whitespace，\r\n 评论，...）附在上面。\r\n \r\n","The variable declarator.":"变量声明器。\r\n","\r\n The \"Declare\" keyword.\r\n ":"\r\n “声明”关键字。\r\n \r\n","\r\n            Returns true if the character might trigger completion, \r\n            e.g. '(' and ',' for method invocations \r\n            ":"\r\n            如果角色可能触发完成，则返回true，\r\n            例如'（'和'，'用于方法调用\r\n            \r\n","round-trip date/time":"往返日期/时间\r\n","\r\n Gets the locations where this symbol was originally defined, either in source\r\n or metadata. Some symbols (for example, partial classes) may be defined in more\r\n than one location.\r\n ":"\r\n 获取最初定义此符号的位置，要么在源中\r\n 或元数据。某些符号（例如，部分类）可以在更多中定义\r\n 比一个位置。\r\n \r\n","'{0}' does not contain a constructor that takes that many arguments.":"'{0}'不包含采用许多参数的构造函数。\r\n",".\r\n ":"。\r\n \r\n","\r\n The value for the Modifiers property.\r\n ":"\r\n 修饰符属性的值。\r\n \r\n","An ImmutableArray containing all the members of this symbol. If this symbol has no members,\r\n returns an empty ImmutableArray. Never returns Nothing.":"一个包含此符号的所有成员的不可分付款。如果此符号没有成员，\r\n 返回一个空的Immutablearray。永远不会返回。\r\n","\r\n This is a map from TypeRef row id to the target ":"\r\n 这是从Typeref行ID到目标的地图\r\n","\r\n Assembly is /l-ed by compilation that is using it as a reference.\r\n ":"\r\n 组件是通过使用它作为参考的编译 /L-ED。\r\n \r\n","\r\n            Updates (one for each changed project) and Rude Edit diagnostics. Does not include syntax or semantic diagnostics.\r\n            ":"\r\n            更新（每个更改项目的一个）和粗鲁的编辑诊断。不包括语法或语义诊断。\r\n            \r\n","\r\n  Looks up a localized string similar to Option Strict Custom can only be used as an option to the command-line compiler (vbc.exe)..\r\n":"\r\n  查找类似于选项的本地化字符串，只能用作命令行编译器（vbc.exe）的选项。\r\n\r\n","\r\n A bound access to the Current property.\r\n ":"\r\n 对当前属性的约束访问。\r\n \r\n","\r\n            used to determine whether \"return\" statement needs to be inserted\r\n            ":"\r\n            用于确定是否需要插入“返回”语句\r\n            \r\n","\r\n Locals are given slots when their declarations are encountered.  We only need give slots to local variables, and \r\n the \"Me\" variable of a structure constructs. Other variables are not given slots, and are therefore not tracked \r\n by the analysis.  This returns SlotKind.NotTracked for a variable that is not tracked, for fields of structs \r\n that have the same assigned status as the container, and for structs that (recursively) contain no data members.\r\n We do not need to track references to variables that occur before the variable is declared, as those are reported \r\n in an earlier phase as \"use before declaration\". That allows us to avoid giving slots to local variables before\r\n processing their declarations.\r\n ":"\r\n 当遇到声明时，当地人将获得插槽。我们只需要给本地变量插槽，\r\n 结构构造的“我”变量。其他变量未给出插槽，因此未经跟踪\r\n 通过分析。这将返回slotkind.nottracked for未经跟踪的变量，用于结构的字段\r\n 具有与容器相同的分配状态，以及（递归）不包含数据成员的结构。\r\n 我们不需要跟踪在声明变量之前发生的变量的引用，因为报告了这些变量\r\n 在较早的阶段为“声明之前使用”。这使我们能够避免在本地变量之前给予插槽\r\n 处理他们的声明。\r\n \r\n"," for the reported diagnostic\r\n                2. \"isUnusedLocalAssignment\": Flag indicating if the flagged local variable has no reads/uses.\r\n                3. \"isRemovableAssignment\": Flag indicating if the assigned value is from an expression that has no side effects\r\n                        and hence can be removed completely. For example, if the assigned value is a constant or a reference\r\n                        to a local/parameter, then it has no side effects, but if it is method invocation, it may have side effects.\r\n            ":" 报告的诊断\r\n                2.“ IsunusedLocalAssignment”：标记为标记的本地变量是否没有读取/用途。\r\n                3.“ IsremovableSignment”：标志指示分配的值是否来自没有副作用的表达式\r\n                        因此可以完全删除。例如，如果分配的值是常数或参考\r\n                        对于局部/参数，它没有副作用，但是如果是方法调用，则可能具有副作用。\r\n            \r\n","The discard pattern is not permitted as a case label in a switch statement. Use 'case var _:' for a discard pattern, or 'case @_:' for a constant named '_'.":"开关语句中不允许将丢弃模式作为案例标签。使用'case var _：'用于丢弃模式，或“ case @_：'对于命名为'_'的常数。\r\n","global statement":"全球声明\r\n","\r\n                 . name1 (arglist1) remainder1 . name2 (arglist2) remainder2\r\n             ":"\r\n                 。 name1（arglist1）剩余1。 name2（arglist2）剩余2\r\n             \r\n","Remove 'new' modifier":"删除“新”修饰符\r\n","\r\n Represents a \"GoTo\" statement.\r\n ":"\r\n 代表“ goto”陈述。\r\n \r\n","\r\n Represents an entire source file of VB code.\r\n ":"\r\n 表示VB代码的整个源文件。\r\n \r\n","zero-width negative lookahead assertion":"零宽的负lookahead断言\r\n","\r\n Scan interpolated string format string text content (no newlines).\r\n ":"\r\n 扫描插值字符串字符串文本内容（无纽线）。\r\n \r\n","\r\n The value for the Attributes property.\r\n ":"\r\n 属性属性的值。\r\n \r\n","Asynchronous method cannot have ref/out parameters : [{0}]":"异步方法不能具有参数/输出参数：[{0}]\r\n","\r\n Given a catch statement syntax get the corresponding local symbol.\r\n ":"\r\n 给定一个捕获语句语法获取相应的本地符号。\r\n \r\n","\r\n            We always unilaterally add \"global::\" to all named types/namespaces.  This\r\n            will then be trimmed off if possible by calls to \r\n            ":"\r\n            我们总是单方面将“全局::”添加到所有命名类型/名称空间中。这个\r\n            然后，如果可能的话，将通过电话修剪\r\n            \r\n","\r\n Returns a copy of this with the EndTryStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，而Endrytrystatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Creates a method symbol for Declare Sub or Function.\r\n ":"\r\n 为声明sub或函数创建方法符号。\r\n \r\n","\r\n Resolves a symbol that represents script container (Script class). \r\n Uses the full name of the container class stored in ":"\r\n 解析代表脚本容器（脚本类）的符号。\r\n 使用存储在中的容器类的全名\r\n",".\r\n            This is needed to prevent the code fix/FixAll from generating code with\r\n            multiple local variables named '_', which is a compiler error.\r\n            ":"。\r\n            这是防止代码/fixall与使用代码生成代码的\r\n            多个局部变量名为“ _”，这是编译器错误。\r\n            \r\n","\r\n  Looks up a localized string similar to Type parameter not allowed in 'Implements' clause..\r\n":"\r\n  查找类似于类型参数的本地化字符串，在“实施”子句中不允许。\r\n\r\n"," can't be resolved.":" 无法解决。\r\n"," instance is returned if:\r\n            - Selection is zero-width and inside/touching a Token with direct parent of type ":" 如果：\r\n             - 选择为零宽，内部/触摸一个直接父母的令牌\r\n","property accessor":"物业登录器\r\n","\r\n  Looks up a localized string similar to 'Custom' modifier is not valid on events declared in interfaces..\r\n":"\r\n  在接口中声明的事件上查找类似于“自定义”修饰符类似的本地化字符串。\r\n\r\n","\r\n Rewrites property.\r\n ":"\r\n 重写属性。\r\n \r\n","\r\n Verify TypeSubstitution to make sure it doesn't map any \r\n type parameter to an alpha-renamed type parameter.\r\n ":"\r\n 验证tymenubstitution以确保其不会绘制任何\r\n 类型参数到α命名的类型参数。\r\n \r\n","\r\n Given a type declaration, get the corresponding type symbol.\r\n ":"\r\n 给定类型声明，获取相应的类型符号。\r\n \r\n","The type parameter symbol that was declared.":"声明的类型参数符号。\r\n","Code is null.":"代码为空。\r\n"," is a binary subtraction operator. If so, it\r\n            will be returned through ":" 是二进制减法操作员。如果是这样，\r\n            将通过\r\n","\r\n            The project only changed in comments, whitespaces, etc. that don't require compilation.\r\n            ":"\r\n            该项目仅在不需要汇编的评论，空间等中更改。\r\n            \r\n","Simplify all occurrences":"简化所有发生\r\n","\r\n  Looks up a localized string similar to '{0}' is not valid on a Declare..\r\n":"\r\n  在声明上查找类似于“ {0}”的本地化字符串。\r\n\r\n","\r\n Should be kept in sync with OverloadResolution.MatchArguments. Anything that \r\n OverloadResolution.MatchArguments flags as an error should be detected by \r\n this function as well. \r\n ":"\r\n 应与OrforloadResolution.matcharguments保持同步。一切\r\n unerloadresolution.matcharguments flags作为错误应检测到\r\n 此功能也是如此。\r\n \r\n","all diacritic marks":"所有变音符号\r\n","Title for the diagnostic descriptor":"诊断描述符的标题\r\n","\r\n Returns a copy of this with the ImportsKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中importskeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Report an unimplemented language construct.\r\n ":"\r\n 报告未完成的语言结构。\r\n \r\n","The delegate parameter type.":"委托参数类型。\r\n","\r\n            True if the assembly was loaded by the assembly loader, false if has been loaded before.\r\n            ":"\r\n            如果是由组件装载机加载组件，则为false，如果已加载之前。\r\n            \r\n"," End of the region being analyzed, or Nothing if it is not a region based analysis ":" 分析区域的结束，或者如果不是基于区域的分析，则什么都没有\r\n","\r\n            Make a State instance representing the Deconstruct method we want to generate.\r\n            The method will be called \"Deconstruct\". It will be a member of `typeToGenerateIn`.\r\n            Its arguments will be based on `targetVariables`.\r\n            ":"\r\n            制作一个代表我们要生成的解构方法的状态实例。\r\n            该方法将称为“解构”。它将是`typetogenatein in'的成员。\r\n            它的论点将基于“ targetVariables”。\r\n            \r\n","use 'var' instead of explicit type":"使用“ var”而不是显式类型\r\n","\r\n Overriding methods should consider ":"\r\n 覆盖方法应考虑\r\n","Remove 'async' modifier":"删除“异步”修饰符\r\n","\r\n This instance is intended to reflect the definition of signature equality used by the runtime (ECMA 335 Section 8.6.1.6).\r\n It considers type, name, parameters, and custom modifiers.\r\n ":"\r\n 此实例旨在反映运行时使用的签名平等的定义（ECMA 335第8.6.1.6节）。\r\n 它考虑类型，名称，参数和自定义修饰符。\r\n \r\n","\r\n            Determines whether it is possible to navigate to the given position in the specified document.\r\n            ":"\r\n            确定是否可以导航到指定文档中的给定位置。\r\n            \r\n","\r\n             Test if all argument types can be converted to corresponding parameter types.\r\n             ":"\r\n             测试是否可以将所有参数类型转换为相应的参数类型。\r\n             \r\n","\r\n The \"Implements\" keyword.\r\n ":"\r\n “实现”关键字。\r\n \r\n","\r\n            Tag to let us know we need to rehydrate the conversion from the parameter and return type.\r\n            ":"\r\n            标签让我们知道我们需要从参数和返回类型中补充转换。\r\n            \r\n","The AsyncMethodBuilder attribute is disallowed on anonymous methods without an explicit return type.":"在没有明确返回类型的情况下，在匿名方法上不允许使用异步构成属性。\r\n","Remove extra blank lines":"删除额外的空白线\r\n","Updating the kind of a type requires restarting the application.":"更新类型的类型需要重新启动应用程序。\r\n","\r\n NOTE: Dev11 does some pretty weird things here.  First, it ignores arity,\r\n which seems like a good way to disambiguate symbols (in particular,\r\n CLS Rule 43 says that the name includes backtick-arity).  Second, it\r\n does not consider two members with identical names (i.e. not differing\r\n in case) to collide.\r\n ":"\r\n 注意：Dev11在这里做一些很奇怪的事情。首先，它忽略了Arity，\r\n 这似乎是消除符号的好方法（尤其是\r\n CLS规则43说该名称包括Backtick-Arity）。第二，它\r\n 不考虑两个具有相同名称的成员（即没有不同\r\n 如果）碰撞。\r\n \r\n","\r\n  Looks up a localized string similar to Expected '/' for XML end tag..\r\n":"\r\n  查找类似于XML End标签的预期'/'的本地化字符串。\r\n\r\n","\r\n Collect all overloads in \"container\" of the given name and kind.\r\n Also determine if any have \"Overloads\" or \"Overrides\" specifiers.\r\n ":"\r\n 收集给定名称和类型的“容器”中的所有过载。\r\n 还要确定任何人是否具有“超载”或“覆盖”指数。\r\n \r\n","intervalTree":"Intervaltree\r\n","Renaming {0} requires restarting the application because it is not supported by the runtime.":"重命名{0}需要重新启动应用程序，因为运行时不支持它。\r\n","lambda return type":"lambda返回类型\r\n","\r\n Deserialize a syntax node from a byte stream.\r\n ":"\r\n 从字节流进行典当化语法节点。\r\n \r\n","Full name of type that failed lookup.  Shortened as different prefixes are checked.":"查找失败的类型的全名。检查不同的前缀时缩短。\r\n","\r\n The name of the aggregation function.\r\n ":"\r\n 聚合函数的名称。\r\n \r\n","\r\n Alpha-renamed type parameters, i.e. type parameters with constraints substituted according\r\n to containing type's TypeSubstitution.\r\n For example:\r\n     Class A (Of T)\r\n         Sub B(Of S As T)()\r\n         End Sub\r\n     End Class\r\n  \r\n Given a method A(Of IComparable).B(Of ), alpha-renamed type parameter S will have type constraint IComparable.\r\n ":"\r\n alpha命名的类型参数，即用约束替换的类型参数\r\n 包含类型的类型物质。\r\n 例如：\r\n     A类（T）\r\n         s子（s as t）（）\r\n         结束子\r\n     最终课程\r\n  \r\n 给定一个方法A（iComable）.b（Of），alpha命名的类型参数S将具有型号的键入图形。\r\n \r\n","All numbers. This includes the Nd, Nl, and No categories.":"所有数字。这包括ND，NL和NO类别。\r\n"," if the syntax node represents an expression syntax, but it's not \r\n an expression from the VB language point of view; otherwise ":" 如果语法节点代表表达语法，但不是\r\n 从VB语言角度来看的表达；否则\r\n","\r\n Lookup all names that are available from a single binder, without delegating\r\n to containing binder. The original binder passed in is used for accessibility checking\r\n and so forth.\r\n Names that are available are inserted into \"nameSet\". This is a hashSet that accumulates\r\n names, and should be created with the VB identifierComparer.\r\n ":"\r\n 查找单个粘合剂可用的所有名称，而无需委派\r\n 含有粘合剂。传递的原始粘合剂用于可访问性检查\r\n 等等。\r\n 可用的名称被插入“姓名表”。这是一个积累的主题集\r\n 名称，应使用VB标识符comparer创建。\r\n \r\n","\r\n            Detects the context of this occurrence of predefined type and determines if we should report it.\r\n            ":"\r\n            检测预定类型的这种情况的上下文，并确定我们是否应该报告。\r\n            \r\n","Adding a MustOverride {0} or overriding an inherited {0} requires restarting the application.":"添加Mustoverride {0}或覆盖继承的{0}需要重新启动应用程序。\r\n","\r\n  Looks up a localized string similar to 'Structure' statement must end with a matching 'End Structure'..\r\n":"\r\n  查找类似于“结构”语句的本地化字符串必须以匹配的“终端结构”结尾。\r\n\r\n","\r\n            Reference's character based on the document content\r\n            ":"\r\n            基于文档内容的参考角色\r\n            \r\n","\r\n            Abstract implementation of the C# and VB embedded language providers.\r\n            ":"\r\n            C＃和VB嵌入式语言提供商的抽象实现。\r\n            \r\n","\r\n            Helper class to analyze the semantic effects of a speculated syntax node replacement on the parenting nodes.\r\n            Given an expression node from a syntax tree and a new expression from a different syntax tree,\r\n            it replaces the expression with the new expression to create a speculated syntax tree.\r\n            It uses the original tree's semantic model to create a speculative semantic model and verifies that\r\n            the syntax replacement doesn't break the semantics of any parenting nodes of the original expression.\r\n            ":"\r\n            辅助类别分析了推测的语法节点替换对育儿节点的语义效应。\r\n            从语法树和来自不同语法树的新表达式给定一个表达式节点，\r\n            它用新表达式替换表达式以创建推测的语法树。\r\n            它使用原始树的语义模型来创建投机性语义模型并验证\r\n            语法替代不会打破原始表达式的任何育儿节点的语义。\r\n            \r\n","\r\n             Invariants we try to maintain (and should consider a bug if we do not): l 1. If the .NET\r\n             regex parser does not report an error for a given pattern, we should not either. it would be\r\n             very bad if we told the user there was something wrong with there pattern when there really\r\n             wasn't.\r\n            \r\n             2. If the .NET regex parser does report an error for a given pattern, we should either not\r\n             report an error (not recommended) or report the same error at an appropriate location in the\r\n             pattern.  Not reporting the error can be confusing as the user will think their pattern is\r\n             ok, when it really is not.  However, it can be acceptable to do this as it's not telling\r\n             them that something is actually wrong, and it may be too difficult to find and report the\r\n             same error.  Note: there is only one time we do this in this parser (see the deviation\r\n             documented in ":"\r\n             不变性我们试图维护（如果不这样做，应该考虑一个错误）：l 1.如果.net\r\n             Regex解析器不会报告给定模式的错误，我们也不应该。这将是\r\n             如果我们告诉用户时，真的很糟糕\r\n             不是。\r\n            \r\n             2.如果.NET REGEX解析器确实报告了给定模式的错误，我们要么不应该\r\n             报告错误（不建议）或在适当位置报告相同的错误\r\n             图案。不报告错误可能会混淆，因为用户会认为他们的模式是\r\n             好的，真的不是。但是，这样做可以接受，因为它没有说明\r\n             他们实际上是错误的，可能很难找到和报告\r\n             相同的错误。注意：我们只有一次在这个解析器中这样做（请参阅偏差\r\n             记录在\r\n","deconstruction":"解构\r\n","\r\n            Continues the script with given code snippet.\r\n            ":"\r\n            使用给定代码段继续脚本。\r\n            \r\n","\r\n            ```a{5}```\r\n            ":"\r\n            ````{5}``````\r\n            \r\n","\r\n Returns a copy of this with the NamespaceKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，并将其命名空间键属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Matches symbols from an assembly in one compilation to\r\n the corresponding assembly in another. Assumes that only\r\n one assembly has changed between the two compilations.\r\n ":"\r\n 匹配一个汇编中的组件的符号\r\n 另一个相应的组件。假设只有\r\n 两次汇编之间发生了一个组件。\r\n \r\n","\r\n This method is called by the binder when it is finished binding a set of attributes on the symbol so that\r\n the symbol can extract data from the attribute arguments and potentially perform validation specific to\r\n some well known attributes.\r\n ":"\r\n 当粘合剂完成绑定符号上的一组属性时，该方法是调用的\r\n 该符号可以从属性参数中提取数据，并可能执行特定于\r\n 一些众所周知的属性。\r\n \r\n","\r\n Represents a type name consisting of a single identifier (which might include\r\n brackets or a type character).\r\n ":"\r\n 表示由单个标识符组成的类型名称（可能包括\r\n 支架或类型字符）。\r\n \r\n","\r\n The accessor blocks contained in the custom event declaration, between the\r\n Event statement and the End Event statement.\r\n ":"\r\n 自定义事件声明中包含的登录块，\r\n 事件声明和结束事件语句。\r\n \r\n","\r\n            Should match the Include or Name attribute used in the project file.\r\n            ":"\r\n            应匹配项目文件中使用的include或名称属性。\r\n            \r\n","\r\n  Looks up a localized string similar to Friend assembly reference '{0}' is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations..\r\n":"查找类似于朋友汇编引用'{0}'的本地化字符串无效。坚固的签名组件必须在其InternalSvisibleto声明中指定公共密钥。\r\n\r\n"," operates on (the new tree, since the map is mapping from new nodes to old nodes).\r\n            Only available when ":" 操作（新树，因为地图从新节点到旧节点映射）。\r\n            仅在何时可用\r\n","\\D matches any non-digit character. It is equivalent to the \\P{Nd} regular expression pattern.\r\n            \r\n            If ECMAScript-compliant behavior is specified, \\D is equivalent to [^0-9]":"\\ d匹配任何非数字字符。它等效于\\ p {nd}正则表达模式。\r\n            \r\n            如果指定了符合eCMAScript的行为，\\ d等于[^0-9]\r\n","Autoselect disabled due to potential range variable declaration.":"由于潜在的范围可变声明，自动选择禁用。\r\n","\r\n The value for the OperatorToken property.\r\n ":"\r\n Operatortoken属性的价值。\r\n \r\n","utc hour and minute offset":"UTC小时和分钟偏移\r\n","\r\n Member that does not have Overloads, is considered Shadows (hidebyname)\r\n ":"\r\n 没有超载的成员被视为阴影（hidebyname）\r\n \r\n","\r\n Returns the constant value associated with the symbol, if any.\r\n ":"\r\n 返回与符号相关的常数值（如果有）。\r\n \r\n","Add member name":"添加成员名称\r\n","\r\n            Return 1 if it is desirable to report two edits (delete and insert) rather than a move edit\r\n            when the node changes its parent.\r\n            ":"\r\n            返回1如果需要报告两个编辑（删除和插入）而不是移动编辑\r\n            当节点更改其父时。\r\n            \r\n","The operation may overflow at runtime (use 'unchecked' syntax to override)":"操作可能在运行时溢出（使用“未选中”语法覆盖）\r\n","False if node of candidates wins":"假设候选人的节点获胜\r\n","\r\n Interface1 and Interface2 have variable ambiguity. Report the warning in the correct location.\r\n ":"\r\n 接口1和接口2具有可变的歧义。在正确的位置报告警告。\r\n \r\n","\r\n Do not consider symbols that are shared members.\r\n ":"\r\n 不要考虑共享成员的符号。\r\n \r\n","\r\n Narrow a quadword result to a specific integral type, setting Overflow true\r\n if the result value cannot be represented in the result type.\r\n ":"\r\n 将四词结果缩小到特定的积分类型，设置溢出true\r\n 如果结果值无法在结果类型中表示。\r\n \r\n","\r\n once this goes to true we are no longer interested in this variable.\r\n ":"\r\n 一旦实现了，我们将不再对此变量感兴趣。\r\n \r\n","\r\n            Destination of where members should be pulled up to.\r\n            ":"\r\n            应将成员拉到的目的地。\r\n            \r\n","\r\n            In .net6 p7 the source generator changed to passing in the relative doc path without a leading \\ to GetIdentifierFromPath\r\n            which caused the source generated file name to no longer be prefixed by an _.  Additionally, the file extension was changed to .g.cs\r\n            ":"\r\n            在.net6 p7中，源发电机更改为传递相对DOC路径，而无需引导\\ getIdentifierFrompath\r\n            导致源生成的文件名不再由_ _前缀。此外，将文件扩展名更改为.g.cs\r\n            \r\n","\r\n Consumers must provide implementation for ":"\r\n 消费者必须提供实施\r\n","\r\n            Virtual so that extenders can support other radices.\r\n            ":"\r\n            虚拟，以便扩展器可以支持其他辐射。\r\n            \r\n","Convert to record struct":"转换为记录结构\r\n","\r\n  Looks up a localized string similar to Attribute '{0}' cannot be applied to an assembly..\r\n":"\r\n  查找类似于属性'{0}'的本地化字符串不能应用于汇编。\r\n\r\n","\r\n Represents the \"Finally\" statement that begins a \"Finally\" block.\r\n ":"\r\n 表示开始“最后”块的“最后”陈述。\r\n \r\n","\r\n            Represents an and-pattern, constructed from two other patterns.\r\n            ":"\r\n            代表一个由另外两个模式构建的模式。\r\n            \r\n","\r\n Returns a copy of this with the ToValue property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，Tovalue属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n",". Name (ArgList)":"。名称（arglist）\r\n","\r\n  Looks up a localized string similar to '{0}' is not valid on a local constant declaration..\r\n":"在本地常数声明中查找类似于“ {0}”的本地化字符串。\r\n\r\n","\r\n            Get the unique state name for the given analyzer.\r\n            Note that this name is used by the underlying persistence stream of the corresponding ":"\r\n            获取给定分析仪的唯一状态名称。\r\n            请注意，该名称由相应的基础持久流使用\r\n","the enclosing scope's access has to be lesser than":"封闭范围的访问必须比\r\n"," which was introduced in .Net 4.5\r\n ":" 在.NET 4.5中引入\r\n \r\n","\r\n Embedded kind of the tree. \r\n ":"\r\n 嵌入的树。\r\n \r\n","\r\n            Progress reporter\r\n            \r\n            this progress reporter is a best effort implementation. it doesn't stop world to find out accurate data\r\n            \r\n            what this reporter care is we show start/stop background work and show things are moving or paused\r\n            without too much cost.\r\n            \r\n            due to how solution cralwer calls Start/Stop (see caller of those 2), those 2 can't have a race\r\n            and that is all we care for this reporter\r\n            ":"\r\n            进度记者\r\n            \r\n            该进度记者是最好的努力实施。它不会阻止世界找出准确的数据\r\n            \r\n            这个记者的护理是我们展示开始/停止背景工作，并显示事情正在移动或暂停\r\n            没有太多成本。\r\n            \r\n            由于解决方案如何呼叫启动/停止（请参阅这2的呼叫者），这2个不能参加比赛\r\n            这就是我们关心的记者\r\n            \r\n","'{0}' cannot be used as a modifier on a function pointer parameter.":"'{0}'不能用作函数指针参数的修饰符。\r\n","\r\n            One or more ":"\r\n            一个或多个\r\n","There is no target type for the default literal.":"默认文字没有目标类型。\r\n","\r\n            Text above the line with the reference\r\n            ":"\r\n            线上上方的文字带有参考\r\n            \r\n","\r\n Rewrites a for each over an one dimensional array or a string.\r\n \r\n As an optimization, if c is an array type of rank 1, the form becomes:\r\n\r\n     Dim collectionCopy As C = c\r\n     Dim collectionIndex As Integer = 0\r\n     Do While collectionIndex < len(collectionCopy)    ' len(a) represents the LDLEN opcode\r\n         dim controlVariable = DirectCast(collectionCopy(collectionIndex), typeOfControlVariable)\r\n         <loop body>\r\n     continue:\r\n         collectionIndex += 1\r\n     postIncrement:\r\n     Loop\r\n\r\n An iteration over a string becomes\r\n     Dim collectionCopy As String = c\r\n     Dim collectionIndex As Integer = 0\r\n     Dim limit as Integer = s.Length\r\n     Do While collectionIndex < limit\r\n         dim controlVariable = DirectCast(collectionCopy.Chars(collectionIndex), typeOfControlVariable)\r\n         <loop body>\r\n     continue:\r\n         collectionIndex += 1\r\n     postIncrement:\r\n     Loop\r\n ":"\r\n 在一维数组或字符串上重写每个数组的a。\r\n \r\n 作为优化，如果c是秩1的数组类型，则形式变为:\r\n\r\n     Dim collectionCopy为C=c\r\n     Dim collectionIndex为Integer=0\r\n     Do While collectionIndex<len(collectionCopy)'len(a)表示LDLEN操作码\r\n         dim controlVariable=DirectCast（collectionCopy（collectionIndex），typeOfControlVariable）\r\n         <循环体>\r\n     继续:\r\n         collectionIndex+=1\r\n     后整理,后整理:\r\n     循环\r\n\r\n 对字符串的迭代变成\r\n     Dim collectionCopy作为String=c\r\n     Dim collectionIndex为Integer=0\r\n     Dim限制为整数=s.长度\r\n     在collectionIndex<limit时执行\r\n         dim controlVariable=DirectCast(collectionCopy.Chars（collectionIndex），typeOfControlVariable）\r\n         <循环体>\r\n     继续:\r\n         collectionIndex+=1\r\n     后整理,后整理:\r\n     循环\r\n \r\n","\r\n Summarizes the results of an overload resolution analysis. Describes whether overload resolution \r\n succeeded, and which method was selected if overload resolution succeeded.\r\n ":"\r\n 总结过载分析分析的结果。描述是否分辨率\r\n 成功，如果超载分辨率成功，则选择了哪种方法。\r\n \r\n","C#":"C#\r\n","\r\n Gets a read-only list of all the modules in this assembly. (There must be at least one.) The first one is the main module\r\n that holds the assembly manifest.\r\n ":"\r\n 获取此组件中所有模块的仅读取列表。 （必须至少有一个。）第一个是主模块\r\n 这持有组装的清单。\r\n \r\n","\r\n The value for the Keyword property.\r\n ":"\r\n 关键字属性的值。\r\n \r\n","\r\n            Where the location originally came from (for example, the containing assembly or\r\n            project name).  May be used in the presentation of a definition.\r\n            ":"\r\n            位置最初来自的位置（例如，包含组件或\r\n            项目名称）。可以用于定义的介绍。\r\n            \r\n","\r\n            Flag indicating if analyzer performance info, such as analyzer execution times,\r\n            should be logged as performance telemetry.\r\n            ":"\r\n            标志指示分析仪性能信息（例如分析仪执行时间）是否\r\n            应记录为性能遥测。\r\n            \r\n","\r\n  Looks up a localized string similar to Branching out of a 'Finally' is not valid..\r\n":"\r\n  查找类似于“最后”分支类似的本地化字符串是无效的。\r\n\r\n","\r\n Returns a copy of this with the Keyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，关键字属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n  Looks up a localized string similar to '#Else' must be preceded by a matching '#If' or '#ElseIf'..\r\n":"\r\n  查找类似于“ #else”的本地化字符串必须先于匹配的“ #if”或“ #elseif” ..\r\n\r\n","\r\n The sequence of groups of TypeDef row ids for types contained within the namespace, \r\n recursively including those from nested namespaces. The row ids are grouped by the \r\n fully-qualified namespace name in case-sensitive manner. There could be multiple groups \r\n for each fully-qualified namespace name. The groups are sorted by their key  \r\n in case-insensitive manner. Empty string is used as namespace name for types \r\n immediately contained within Global namespace. Therefore, all types in this namespace, if any, \r\n will be in several first IGroupings.\r\n ":"\r\n 命名空间中包含的类型类型的Typedef行ID组序列，\r\n 递归包括来自嵌套名称空间的。行ID由\r\n 以情况敏感的方式完全合格的名称名称。可能有多个组\r\n 对于每个符合条件的名称空间名称。小组用他们的钥匙排序\r\n 以情况不敏感的方式。空字符串用作类型的名称名称\r\n 立即包含在全球名称空间中。因此，此名称空间中的所有类型（如果有）\r\n 将在几个第一个Igroupings中。\r\n \r\n"," that contains path, line and column information.\r\n\r\n If the location path is not mapped the resulting path is ":" 其中包含路径，行和列信息。\r\n\r\n 如果未映射位置路径，则结果路径为\r\n","\r\n An InstanceTypeSymbol is a NamedTypeSymbol that is a pure instance type, where the class\r\n (and any containing classes) have no type substitutions applied.\r\n This class provide shared implementation for types whose definition is (possibly lazily)\r\n constructed from source or metadata. It provides the shared implementation between these two, primarily\r\n the implementation of Construct and InternalSubstituteTypeParameters.\r\n ":"\r\n instancetypesymbol是一个名为tytypesymbol，是纯实例类型，该类别\r\n （以及任何包含类）没有应用类型的替代。\r\n 此类为定义的类型提供共享的实现（可能懒惰）\r\n 由源或元数据构建。它提供了这两者之间的共同实现，主要是\r\n 实施构建体和内部提交型型电子计。\r\n \r\n","\r\n            We handle only certain operation tree shapes in flow analysis\r\n            when delegate creations are involved (lambdas/local functions).\r\n            We track assignments of lambdas/local functions to parameters/locals,\r\n            assignments of parameters/locals to other parameters/locals of delegate types,\r\n            and then delegate invocations through parameter/locals.\r\n            For the remaining unknown ones, we conservatively mark the operation as leading to\r\n            delegate escape, and corresponding bail out from flow analysis in ":"\r\n            我们只处理流量分析中的某些操作树形状\r\n            当涉及委托创建时（Lambdas/local功能）。\r\n            我们跟踪lambdas/local功能的分配到参数/当地人，\r\n            参数/本地人分配给其他参数/​​当地人，\r\n            然后通过参数/当地人委派起诉。\r\n            对于其余未知的人，我们保守地将操作标记为\r\n            委派逃脱，并从流量分析中进行对应的保释\r\n","\r\n Abstract node class that represents a name, possibly include generic arguments.\r\n ":"\r\n 代表名称的抽象节点类，可能包括通用参数。\r\n \r\n","\r\n            Placed at the same indent as the current context\r\n        ":"\r\n            与当前上下文相同的缩进\r\n        \r\n","\r\n Returns a copy of this with the InterfaceKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 将其返回此副本，而InterfaceKeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Binds the field initializer. A bound field initializer contains the bound field access and bound init value.\r\n ":"\r\n 绑定字段初始化器。绑定字段初始化器包含绑定的字段访问和绑定的初始值。\r\n \r\n","\r\n  Looks up a localized string similar to 'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to instance method..\r\n":"\r\n  查找类似于'system.runtime.interopservices.dllimportattribute'的本地化字符串，不能应用于实例方法。\r\n\r\n",") for a variable\r\n            which needs to be removed, we will annotate it as a conflict, since we don't have\r\n            a better refactoring.\r\n            ":"）对于变量\r\n            需要删除哪些，我们将把它作为冲突，因为我们没有\r\n            更好的重构。\r\n            \r\n","\r\n Determines if the property can be accessed with empty parameter list.\r\n ":"\r\n 确定是否可以使用空参数列表访问该属性。\r\n \r\n","\r\n The value for the AwaitKeyword property.\r\n ":"\r\n 等待关键字属性的值。\r\n \r\n","\r\n Walk up the type hierarchy from ContainingType and list members that this\r\n method overrides (accessible methods/properties with the same signature, if this\r\n method is declared \"override\").\r\n \r\n Methods in the overridden list may not be virtual or may have different\r\n accessibilities, types, accessors, etc.  They are really candidates to be\r\n overridden.\r\n \r\n All found accessible candidates of overridden members are collected in two \r\n builders, those with 'exactly' matching signatures and those with 'generally'\r\n or 'inexactly' matching signatures. 'Exact' signature match is a 'general' \r\n signature match which also does not have mismatches in total number of parameters\r\n and/or types of optional parameters. See also comments on correspondent \r\n OverriddenMembersResult(Of TSymbol) properties.\r\n \r\n 'Inexactly' matching candidates are only collected for reporting Dev10/Dev11\r\n errors like BC30697 and others. We collect 'inexact' matching candidates until \r\n we find any 'exact' match.\r\n \r\n Also remembers inaccessible members that are found, but these do not prevent\r\n continuing to search for accessible members.\r\n \r\n ":"\r\n 从包含类型的类型层次结构上沿着列表成员列出这一类型层次结构。\r\n 方法覆盖（如果此，则具有相同签名的可访问方法/属性\r\n 方法被声明为“覆盖”）。\r\n \r\n 覆盖列表中的方法可能不是虚拟的，或者可能具有不同的方法\r\n 访问性，类型，访问者等。它们确实是候选人\r\n 覆盖。\r\n \r\n 所有发现的被压倒成员的可访问的候选人都被收集\r\n 建筑商，具有“恰好”匹配签名的人和具有“一般”的签名\r\n 或“不确定”匹配签名。 “确切”签名匹配是“一般”\r\n 签名匹配也没有参数总数不匹配\r\n 和/或可选参数的类型。另请参见关于通讯员的评论\r\n 覆盖物（TSYMBOL）性质的覆盖物。\r\n \r\n “不可取”的匹配候选人仅用于报告DEV10/DEV11\r\n BC30697等错误。我们收集“不精确”的匹配候选人，直到\r\n 我们发现任何“确切”匹配。\r\n \r\n 还记得发现的不可接受的成员，但这些成员并不能阻止\r\n 继续寻找可访问的成员。\r\n \r\n \r\n","\r\n            Indentation amount for any items that have been wrapped to a new line.  Valid if we're\r\n            not aligning with the first item. i.e.\r\n            \r\n                void Goobar(\r\n                    ^\r\n                    |\r\n            ":"\r\n            任何已包装到新线路的项目的压痕额。如果我们有效\r\n            与第一项不符。 IE。\r\n            \r\n                void guobar（\r\n                    ^\r\n                    |\r\n            \r\n","\r\n             Refactor:\r\n                 var o = (object)1;\r\n            \r\n             Into:\r\n                 var o = 1 as object;\r\n            \r\n             Or vice versa.\r\n             ":"\r\n             重构：\r\n                 var o =（对象）1;\r\n            \r\n             进入：\r\n                 var o = 1作为对象;\r\n            \r\n             或相反亦然。\r\n             \r\n","\r\n            Constructor for a code style analyzer with a multiple diagnostic descriptors with language-specific options that can be used to configure each descriptor.\r\n            ":"\r\n            代码样式分析仪的构造函数，带有多个诊断描述符，具有特定于语言的选项，可用于配置每个描述符。\r\n            \r\n","\r\n May be user-defined.\r\n ":"\r\n 可能是用户定义的。\r\n \r\n","Name can be simplified":"名称可以简化\r\n","The loop body.":"循环主体。\r\n","it provides a custom way of creating trivia list between two tokens":"它提供了一种在两个令牌之间创建琐事列表的自定义方法\r\n","Introduce local for all occurrences of '{0}'":"介绍所有出现“ {0}”的本地\r\n","\r\n Applies a text change to this syntax tree, returning a new syntax tree with the changes applied to it.\r\n ":"\r\n 将文本更改应用于此语法树，并返回一个新的语法树，并将其应用于它。\r\n \r\n","Upgrade this project to C# language version '{0}'":"将该项目升级到C＃语言版本'{0}'\r\n","\r\n Calculate declared accessibility of most accessible type within this namespace or within a containing namespace recursively.\r\n Expected to be called at most once per namespace symbol, unless there is a race condition.\r\n \r\n Valid return values:\r\n     Friend,\r\n     Public,\r\n     NotApplicable - if there are no types.\r\n ":"\r\n 计算此命名空间中最容易访问类型的声明的可访问性，或递归中包含的名称空间内。\r\n 除非有种族条件，否则预计每个名称空间符号最多都会被调用一次。\r\n \r\n 有效返回值：\r\n     朋友，\r\n     上市，\r\n     非适当的 - 如果没有类型。\r\n \r\n","Generate variable '{0}'":"生成变量'{0}'\r\n","\r\n Returns a copy of this with the StopOrEndKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，并更改​​为StoporendKeyword属性\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Represents a Join query operator.\r\n ":"\r\n 代表加入查询操作员。\r\n \r\n","\r\n  Looks up a localized string similar to Cannot implement interface '{0}' because the interface '{1}' from which it inherits could be identical to implemented interface '{2}' for some type arguments..\r\n":"\r\n  查找类似于无法实现接口'{0}'的本地化字符串，因为它继承的接口'{1}'可以与某种类型的参数相同，与实现的接口'{2}'相同。\r\n\r\n","\r\n The value for the EndKeyword property.\r\n ":"\r\n EndKeyWord属性的值。\r\n \r\n"," to understand the need for this annotation.\r\n            ":" 了解对该注释的需求。\r\n            \r\n","\r\n The common language version among the trees of the compilation.\r\n ":"\r\n 汇编树木中的共同语言版本。\r\n \r\n","\r\n Scan remaining text inside of <? ... ?>\r\n ":"\r\n 扫描剩余的文字<？ ...？>\r\n \r\n","\r\n The expression denoting the collection to iterate over.\r\n ":"\r\n 表示收藏的表达方式。\r\n \r\n","\r\n Register COR types declared in this namespace, if any, in the COR types cache.\r\n ":"\r\n 在此名称空间中声明的注册COR类型（如果有）在COR类型缓存中。\r\n \r\n","\r\n The value for the SecondCommaToken property.\r\n ":"\r\n 第二通用属性的价值。\r\n \r\n"," statement that starts the\r\n            sequence.":" 启动的声明\r\n            序列。\r\n","Records may only inherit from object or another record":"记录只能从对象或其他记录继承\r\n","\r\n            Text below the line with the reference\r\n            ":"\r\n            参考文献下方的文字\r\n            \r\n","\r\n Represents the \"Try\" statement that begins a \"Try\" block.\r\n ":"\r\n 表示开始“尝试”块的“尝试”语句。\r\n \r\n","\r\n The class to represent all properties imported from a PE/module.\r\n ":"\r\n 代表从PE/模块导入的所有属性的类。\r\n \r\n"," \r\n Anonymous type descriptor Key \r\n \r\n The key is being used to separate anonymous type templates, for example in an anonymous type \r\n symbol cache. The type descriptors with the same keys are supposed to map to 'the same' anonymous\r\n type template in terms of the same generic type being used for their implementation.\r\n ":" \r\n 匿名类型描述符键\r\n \r\n 关键被用于分离匿名类型模板，例如在匿名类型中\r\n 符号缓存。具有相同键的类型描述符应该映射到“同一”匿名\r\n 类型模板根据用于实现的相同的通用类型。\r\n \r\n","\r\n Type used by State Machine rewriter to represent symbol proxy. Lambda rewriter as \r\n well as iterator rewriter use simplified form of proxy as they only capture \r\n locals as r-values in fields, async rewriter uses a different structure as a proxy\r\n because it has to capture l-values on stack as well\r\n ":"\r\n 状态计算机使用的类型代表符号代理。 Lambda重写AS\r\n 以及迭代器重写器使用简化的代理形式，因为它们仅捕获\r\n 当地人作为字段中的R值，异步重写器使用不同的结构作为代理\r\n 因为它也必须在堆栈上捕获L值\r\n \r\n","catch clause":"捕获子句\r\n","\r\n  Looks up a localized string similar to '{0}' values cannot be converted to 'Char'. Use 'Microsoft.VisualBasic.ChrW' to interpret a numeric value as a Unicode character or first convert it to 'String' to produce a digit..\r\n":"\r\n  查找类似于“ {0}”值类似的本地化字符串无法转换为“ char”。使用'Microsoft.visualbasic.chrw'将数字值解释为Unicode字符或首先将其转换为“字符串”以产生数字。\r\n\r\n","\r\n            Is this a possible position for an await statement (`await using` or `await foreach`)?\r\n            ":"\r\n            这是等待陈述的可能位置（等待使用“或等待``foreach''）？\r\n            \r\n","Unwrap and indent all arguments":"解开和缩进所有参数\r\n","The text representing the original identifier.  This can be in full width or half width Unicode form.  ":"代表原始标识符的文本。这可以是宽度或半宽Unicode形式的。\r\n","\r\n Bind key selectors for a Join/Group Join operator.\r\n ":"\r\n 绑定加入/组加入操作员的密钥选择器。\r\n \r\n","\r\n            Given a list of symbols, determine which are not recommended at the same position in linked documents.\r\n            ":"\r\n            给定符号列表，确定在链接文档中同一位置不建议使用哪些符号。\r\n            \r\n","The {n} quantifier matches the preceding element exactly n times, where n is any integer. {n} is a greedy quantifier whose lazy equivalent is {n}?":"{n}量词匹配前面的元素恰好n次，其中n是任何整数。 {n}是贪婪的量词，其懒惰的等效物是{n}？\r\n","\r\n Returns number of types in the list of {input type, output type} that refer to a generic type parameter.\r\n ":"\r\n 返回{输入类型，输出类型}列表中的类型数量，该列表是指通用类型参数。\r\n \r\n","Array to search":"数组要搜索\r\n","\r\n            Simple data holder for local diagnostics for an analyzer\r\n            ":"\r\n            用于分析仪本地诊断的简单数据持有人\r\n            \r\n","Generate Equals(object)":"生成平等（对象）\r\n","\r\n The type of the expression represented by the syntax node. For expressions that do not\r\n have a type, null is returned. If the type could not be determined due to an error, than\r\n an object derived from ErrorTypeSymbol is returned.\r\n ":"\r\n 语法节点表示的表达式类型。对于不表达的表达\r\n 有类型，返回null。如果由于错误而无法确定类型，则\r\n 返回源自errortypesymbol的对象。\r\n \r\n","\r\n            returns AlignTokensOperations under a node either by itself or by filtering/replacing operations returned by NextOperation\r\n            ":"\r\n            返回节点下的AlignTokenSoperations本身或通过过滤/替换由NextOperation返回的操作\r\n            \r\n","\r\n The value for the ElseClause property.\r\n ":"\r\n ElSeclause属性的值。\r\n \r\n","\r\n             Try to return up to date diagnostics for the given span for the document.\r\n            \r\n             It will return true if it was able to return all up-to-date diagnostics.\r\n              otherwise, false indicating there are some missing diagnostics in the diagnostic list\r\n             ":"\r\n             尝试为文档的给定跨度返回最新的诊断。\r\n            \r\n             如果能够返回所有最新诊断，它将返回True。\r\n              否则，false表示诊断列表中存在一些诊断\r\n             \r\n","\r\n Return True if the builder is a (possibly empty) list of\r\n WhitespaceTrivia followed by an EndOfLineTrivia.\r\n ":"\r\n 如果建设者是（可能为空的）列表，则返回true\r\n Whitespactrivia之后是内膜尿。\r\n \r\n","Record equality contract property '{0}' must have a get accessor.":"记录平等合同属性'{0}'必须具有GET登录器。\r\n","'{0}' does not implement static interface member '{1}'. '{2}' cannot implement the interface member because it is not static.":"'{0}'不会实现静态接口成员'{1}'。 '{2}'无法实现接口成员，因为它不是静态的。\r\n","\r\n Get assembly level declaration errors.\r\n ":"\r\n 获取组装级声明错误。\r\n \r\n"," Unassign a slot for a regular variable ":" 定期变量统一插槽\r\n","\r\n Should only be called during construction.\r\n ":"\r\n 只能在施工期间调用。\r\n \r\n","Generate {0} '{1}'":"生成{0}'{1}'\r\n","\r\n The value for the WhenTrue property.\r\n ":"\r\n Whentrue属性的值。\r\n \r\n",", this class performs a quick \r\n traversal of the symbol table and performs processing of synthesized symbols if necessary.\r\n ":"，这堂课很快\r\n 符号表的遍历，并在必要时执行合成符号的处理。\r\n \r\n","\r\n Returns a copy of this with the CaseKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，casekeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            Provides a conversion to query.Count().\r\n            ":"\r\n            提供转换为query.count（）。\r\n            \r\n","Unseal class '{0}'":"Unseal类'{0}'\r\n","\r\n Represents event container that refers to a WithEvents member.\r\n ":"\r\n 代表事件容器，指的是事件成员。\r\n \r\n","\r\n Returns the value of the Option Explicit declaration if there was one, otherwise Null.\r\n ":"\r\n 如果有一个，则返回期权明确声明的值，否则为null。\r\n \r\n","\r\n Do not consider locals or parameters during lookup.\r\n ":"\r\n 在查找过程中不要考虑当地人或参数。\r\n \r\n","CollectionInitializerSyntax":"CollectionInitializerSyntax\r\n","The Id of diagonostic":"对决的ID\r\n","\r\n Given the full text of a single-line style documentation comment, for each line, strip off\r\n the comment punctuation (''') and flatten the text.\r\n ":"\r\n 鉴于单行样式文档注释的全文，每行，脱掉\r\n 评论标点符号（''）并弄平了文本。\r\n \r\n","\r\n Target base class type.\r\n ":"\r\n 目标基类类型。\r\n \r\n","\r\n Returns a copy of this with the DoStatement property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，并更改​​为指定的属性\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n"," class to create a new syntax tree rooted at the given root node.\r\n This method does not create a clone of the given root, but instead preserves its reference identity.\r\n ":" 类创建扎根于给定的根节点的新语法树。\r\n 此方法不会创建给定根的克隆，而是保留其参考身份。\r\n \r\n","Add braces to '{0}' statement.":"将牙套添加到'{0}'语句中。\r\n","\r\n Returns a copy of this with the WithKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中withkeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            Returns the fully loaded state for both the project system and the remote host.\r\n            ":"\r\n            返回项目系统和远程主机的满载状态。\r\n            \r\n","'{0}' does not override expected method from 'object'.":"'{0}'不会从“对象”中覆盖预期的方法。\r\n","\r\n The only public entry point is the Infer method.\r\n ":"\r\n 唯一的公共入口点是推断方法。\r\n \r\n","\r\n Represents a reference to an instantiation of a generic type nested in an instantiation of another generic type.\r\n e.g. \r\n A{int}.B{string}\r\n A.B{int}.C.D{string}\r\n ":"\r\n 表示嵌套在另一种通用类型的实例化中的通用类型的实例化。\r\n 例如\r\n a {int} .b {string}\r\n a.b {int} .c.d {string}\r\n \r\n","A bound placeholder value for the collection local if GetEnumerator \r\n was bound successful":"如果GetEnumerator\r\n 被束缚了\r\n","You can use the vertical bar (|) character to match any one of a series of patterns, where the | character separates each pattern.":"您可以使用垂直条（|）字符匹配一系列图案中的任何一个，其中|角色分开每个模式。\r\n","\r\n            Snippets are included if the user types: id?<tab>\r\n            ":"\r\n            如果用户类型：ID？<tab>包括摘要\r\n            \r\n","\r\n Does substitution target either genericDefinition or \r\n one of its containers?\r\n ":"\r\n 是替代目标是通用定义还是\r\n 它的容器之一？\r\n \r\n","\r\n Returns a copy of this with the Content property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，内容属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n here we have a case of indirect assignment:  *t1 = expr;\r\n normally we would need to push t1 and that will cause spilling of t2\r\n \r\n TODO: an interesting case arises in unused x[i]++  and ++x[i] :\r\n       we have trees that look like:\r\n\r\n    t1 = &(x[0])\r\n    t2 = *t1\r\n   *t1 = t2 + 1\r\n\r\n    t1 = &(x[0])\r\n    t2 = *t1 + 1\r\n   *t1 = t2\r\n\r\n  in these cases, we could keep t2 on stack (dev10 does).\r\n  we are dealing with exactly 2 locals and access them in strict order \r\n  t1, t2, t1, t2  and we are not using t2 after that.\r\n  We may consider detecting exactly these cases and pretend that we do not need \r\n  to push either t1 or t2 in this case.\r\n ":"\r\n 在这里，我们有一个间接分配的情况： *t1 = expr;\r\n 通常我们需要推动T1，这将导致T2的溢出\r\n \r\n TODO：在未使用的X [I] ++和++ X [I]中出现了一个有趣的情况：\r\n       我们的树看起来像：\r\n\r\n    t1 =＆（x [0]）\r\n    T2 = *T1\r\n   *T1 = T2 + 1\r\n\r\n    t1 =＆（x [0]）\r\n    T2 = *T1 + 1\r\n   *T1 = T2\r\n\r\n  在这些情况下，我们可以将T2保留在堆栈上（Dev10确实）。\r\n  我们正与2个当地人打交道，并以严格的顺序访问\r\n  T1，T2，T1，T2，此后我们没有使用T2。\r\n  我们可能会考虑确切检测这些案件，并假装我们不需要\r\n  在这种情况下推动T1或T2。\r\n \r\n","The \"fff\" custom format specifier represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value.":"“ FFF”自定义格式指示符表示秒数的三个最重要的数字；也就是说，它代表日期和时间值中的毫秒。\r\n","\r\n            Creates a delegate that will run this script from the beginning when invoked.\r\n            ":"\r\n            创建一个代表，该代表将从开始时从一开始就运行此脚本。\r\n            \r\n","Wrap and align long call chain":"包裹和对齐长呼叫链\r\n","\r\n            Updates the map to the given project snapshot.\r\n            ":"将地图更新为给定的项目快照。\r\n            \r\n","\r\n Bind the given attribute speculatively at the given position, and return back\r\n the resulting bound node. May return null in some error cases.\r\n ":"\r\n 在给定位置绑定给定属性，然后返回\r\n 结果结合节点。在某些错误情况下可能会返回null。\r\n \r\n","The rules used to control behavior of the completion list shown to the user during typing.":"在打字过程中，用于控制用户显示的完成列表的行为的规则。\r\n"," is selected. In that case the ":" 选择。在这种情况下\r\n","\r\n Returns a copy of this with the PropertyStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，属性属性属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Represents a field or property initializer. Holds the symbol and the syntax for the initialization.\r\n ":"\r\n 代表字段或属性初始化器。持有初始化的符号和语法。\r\n \r\n","\r\n Represents a type other than an array, a type parameter.\r\n ":"\r\n 代表除阵列以外的类型，类型参数。\r\n \r\n","Cannot create constructed generic type from non-generic type.":"无法从非生成类型创建构造的通用类型。\r\n","\r\n Represents a method symbol for a lambda method.\r\n ":"\r\n 代表lambda方法的方法符号。\r\n \r\n","\r\n We need to handle case when an old node that represents a lambda body with multiple nodes \r\n of the same kind is mapped to a new node that belongs to the lambda body but is \r\n different from the one that represents the new body.\r\n \r\n In that case ":"\r\n 当代表具有多个节点的lambda主体的旧节点时，我们需要处理案例\r\n 相同类型的映射到属于lambda身体的新节点，但\r\n 与代表新身体的那个不同。\r\n \r\n 在这种情况下\r\n","\r\n Optional. The alignment clause ',alignment' of the embedded expression.\r\n ":"\r\n 可选的。嵌入式表达式的对齐条款“对齐”。\r\n \r\n","\r\n The \"Aggregate\" keyword.\r\n ":"\r\n “汇总”关键字。\r\n \r\n","\r\n            Matches old active statement to new active statement without constructing full method body match.\r\n            This is needed for active statements that are outside of method body, like constructor initializer.\r\n            ":"\r\n            将旧的活动语句与新的活动语句匹配，而无需构造完整的方法主体匹配。\r\n            这对于在方法主体之外的主动语句（例如构造函数initializer）所需。\r\n            \r\n","\r\n Get all the members of this symbol that are modules that have a particular name\r\n ":"\r\n 获取具有特定名称的模块的所有成员\r\n \r\n","\r\n Verifies that given symbol does not have loops in its inheritance chain\r\n and reports appropriate diagnostics.\r\n ":"\r\n 验证给定的符号在其继承链中没有循环\r\n 并报告适当的诊断。\r\n \r\n","\r\n Entry point to directive processing for Scanner.\r\n ":"\r\n 扫描仪指令处理的切入点。\r\n \r\n","\r\n            ```(?'name1-name2'expr)``` or ```(?<name1-name2>expr)``` node.\r\n            ":"\r\n            ``（？'name1-name2'expr）``或``（？<name1-name2> expr）``node n node。\r\n            \r\n","Wrap every argument":"包裹每个论点\r\n","'{0}' is already listed in the interface list on type '{1}' with different nullability of reference types.":"'{0}'已经在类型'{1}'上的接口列表中列出，参考类型的无效性。\r\n","\r\n True if implicit variable declaration is allow by the language here. Differs from OptionExplicit\r\n in that it is only try if this binder is associated with a region that allows implicit variable\r\n declaration (field initializers and attributes don't, for example).\r\n ":"\r\n 如果语言允许使用隐式变量声明，则是正确的。与选项解释不同\r\n 仅当此粘合剂与允许隐式变量的区域相关联时才尝试\r\n 声明（例如，字段初始化器和属性不是）。\r\n \r\n","\r\n            Returns if the token is a valid opening token kind for this brace completion service.\r\n            ":"\r\n            如果令牌是此支架完成服务的有效开口令牌，则返回。\r\n            \r\n","Updating async or iterator modifier around an active statement requires restarting the application.":"在活动语句围绕Active语句更新异步或迭代器修饰符需要重新启动应用程序。\r\n"," when analyzing a particular\r\n            compilation model.  This saves the time from having to recreate this for every string literal that features\r\n            examine for a particular compilation.\r\n            ":" 分析特定\r\n            汇编模型。这节省了时间，从必须为每个字符串的字符串重新创建它\r\n            检查特定的汇编。\r\n            \r\n","\r\n Creates a returns element within an xml documentation comment.\r\n ":"\r\n 在XML文档注释中创建返回元素。\r\n \r\n","\r\n The value for the LessThanSlashToken property.\r\n ":"\r\n Lesslashtoken属性的价值。\r\n \r\n","\r\n Binder used for interiors of documentation comment for binding 'cref' attribute value\r\n ":"用于绑定“ cref”属性值的文档注释内部的粘合剂\r\n \r\n","\r\n            Method invoked in ":"\r\n            调用方法\r\n","\r\n If this is a generic type instantiation or a nested type of a generic type instantiation,\r\n return TypeSubstitution for this construction. Nothing otherwise.\r\n Returned TypeSubstitution should target OriginalDefinition of the symbol.\r\n ":"\r\n 如果这是通用类型的实例化或嵌套类型的通用类型实例化，则\r\n 返回该建筑的返回类型。否则什么也没有。\r\n 返回的型替代物应针对符号的原始定义。\r\n \r\n","\r\n Should return Nothing if there are none.\r\n ":"\r\n 如果没有，应该什么也不会返回。\r\n \r\n","\r\n Returns true if there is no illegal access exposure, false otherwise.\r\n ":"\r\n 如果没有非法访问曝光，则返回true，否则为false。\r\n \r\n","\r\n The value for the ByKeyword property.\r\n ":"\r\n BYKEYWORD属性的值。\r\n \r\n","\r\n            Aggregated across all threads.\r\n            ":"\r\n            在所有线程中汇总。\r\n            \r\n","an updated solution with the original document fixed up as appropriate.":"带有原始文档的更新解决方案，请及时修复。\r\n","\r\n Checks if the type of the collection matches the for each collection design pattern.\r\n ":"\r\n 检查集合的类型是否匹配每个集合设计模式。\r\n \r\n","Microsoft (R) Visual C# Interactive Compiler version {0}":"Microsoft（R）Visual C＃Interactive编译器版本{0}\r\n","\r\n This is actually calculating the reverse CRC\r\n computing the reverse CRC of 0 gives the table entry above\r\n ":"\r\n 这实际上是在计算反向CRC\r\n 计算0的反向CRC给出了上面的表条目\r\n \r\n","\r\n            Inline content for the callee method.\r\n            ":"\r\n            Callee方法的内联内容。\r\n            \r\n","\r\n Represents a pre-processing directive (such as #If, #Const or #Region)\r\n appearing in source.\r\n ":"\r\n 代表预处理指令（例如#if，#const或#region）\r\n 出现在源中。\r\n \r\n"," this update is associated with, or ":" 此更新与\r\n","\r\n Is there any code to execute in the given statement that could have side-effects,\r\n such as throwing an exception? This implementation is conservative, in the sense\r\n that it may return true when the statement actually may have no side effects.\r\n ":"\r\n 在给定语句中是否有任何代码可以执行，可能具有副作用，\r\n 例如抛出例外？从意义上讲，这种实施是保守的\r\n 当该语句实际上没有副作用时，它可能会返回。\r\n \r\n","\r\n Ensure that attributes are bound and the ObsoleteState of this symbol is known.\r\n ":"\r\n 确保属性是绑定的，并且已知该符号的过遗嘱。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' does not implement '{1}'..\r\n":"\r\n  查找类似于'{0}'的本地化字符串，不实现'{1}'..\r\n\r\n"," for the conversion \r\n of the AddressOf operand to the target type\r\n ":" 用于转换\r\n 目标类型操作数的地址\r\n \r\n","\r\n A set of all the names of the members in this type.\r\n ":"\r\n 此类型中成员的所有名称的一组。\r\n \r\n","\r\n            if you want to fetch only project diagnostics without source locations.\r\n            ":"\r\n            如果您只想在没有源位置的情况下获取项目诊断。\r\n            \r\n","\r\n            Returns true if over typing should be allowed given the caret location and completed pair of braces.\r\n            For example some providers allow over typing in non-user code and others do not.\r\n            ":"\r\n            如果允许访问键入的位置和完成的括号，则返回返回。\r\n            例如，某些提供商允许在非用户代码中输入，而其他提供商则不键入。\r\n            \r\n","\r\n If this is an extension method that can be applied to an instance of the given type,\r\n returns the curried method symbol thus formed. Otherwise, returns Nothing.\r\n ":"\r\n 如果这是一种扩展方法，可以应用于给定类型的实例，\r\n 返回因此形成的咖喱方法符号。否则，什么都没有。\r\n \r\n","The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'notnull' constraint.":"该类型不能用作通用类型或方法中的类型参数。类型参数的无效性不匹配“ notnull”约束。\r\n","\r\n            Gets the span of text to squiggle underline.\r\n            If the expression is contained within a single line, the entire expression span is returned.\r\n            Otherwise it will return the span from the expression start to the end of the same line.\r\n            ":"\r\n            获取文本的跨度以刺伤下划线。\r\n            如果表达式包含在单行中，则返回整个表达式跨度。\r\n            否则，它将从表达式启动到同一行的末端返回跨度。\r\n            \r\n","\r\n The value for the LoopStatement property.\r\n ":"\r\n 循环属性的值。\r\n \r\n","Pick members to be used as constructor parameters":"选择将成员用作构造函数参数\r\n","tuple":"元组\r\n"," if type is valid for a const field; otherwise, ":" 如果类型对const字段有效；否则，\r\n","\r\n Represents a parameter symbol defined in source.\r\n ":"\r\n 表示源中定义的参数符号。\r\n \r\n","A property subpattern requires a reference to the property or field to be matched, e.g. '{{ Name: {0} }}'":"属性子图案需要对要匹配的属性或字段的引用，例如'{{name：{0}}}}'\r\n","\r\n The statement that begins the NamespaceBlock.\r\n ":"\r\n 开始命名空间块的语句。\r\n \r\n","\r\n Gets but does not fully validate a symbol's attributes. Returns binding errors but not attribute usage and attribute specific errors.\r\n ":"\r\n 获取但不能完全验证符号的属性。返回绑定错误，而不是属性用法和属性特定错误。\r\n \r\n","range operator":"范围操作员\r\n"," if the token is of the specified kind; otherwise, ":" 如果令牌是指定类型的；否则，\r\n","Where to put the errors":"在哪里放错误\r\n","int i = 0":"int i = 0\r\n","\r\n             Looks for code like:\r\n            \r\n                 ```c#\r\n                 using (var a = b)\r\n                 using (var c = d)\r\n                 using (var e = f)\r\n                 {\r\n                 }\r\n                 ```\r\n             \r\n             And offers to convert it to:\r\n            \r\n                 ```c#\r\n                 using var a = b;\r\n                 using var c = d;\r\n                 using var e = f;\r\n                 ```\r\n            \r\n             (this of course works in the case where there is only one using).\r\n             \r\n             A few design decisions:\r\n                 \r\n             1. We only offer this if the entire group of usings in a nested stack can be\r\n                converted.  We don't want to take a nice uniform group and break it into\r\n                a combination of using-statements and using-declarations.  That may feel \r\n                less pleasant to the user than just staying uniform.\r\n             \r\n             2. We're conservative about converting.  Because `using`s may be critical for\r\n                program correctness, we only convert when we're absolutely *certain* that\r\n                semantics will not change.\r\n             ":"\r\n             寻找代码，例如：\r\n            \r\n                 ````c＃c＃\r\n                 使用（var a = b）\r\n                 使用（var c = d）\r\n                 使用（var e = f）\r\n                 {\r\n                 }\r\n                 ````````\r\n             \r\n             并提出将其转换为：\r\n            \r\n                 ````c＃c＃\r\n                 使用var a = b;\r\n                 使用var c = d;\r\n                 使用var e = f;\r\n                 ````````\r\n            \r\n             （当然，在只有一个使用的情况下）。\r\n             \r\n             一些设计决策：\r\n                 \r\n             1.我们只有在嵌套堆栈中的整个使用情况下才能提供此功能\r\n                转换。我们不想参加一个漂亮的统一小组并将其分解为\r\n                使用使用和使用陈述的组合。可能会感觉到\r\n                对用户的愉悦不仅仅是保持统一。\r\n             \r\n             2.我们对转换保守。因为“使用”可能对\r\n                程序正确，我们只有在绝对 *确定 *的情况下进行转换\r\n                语义不会改变。\r\n             \r\n","\r\n Returns a copy of this with the Tokens property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，代币属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n Gets a value indicating whether this instance is not overridable.\r\n ":"\r\n 获取一个值，指示此实例是否不填充。\r\n \r\n","\r\n            Reads MVID of the output assembly. Overridable for test mocking.\r\n            Returns ":"\r\n            读取输出组件的MVID。对于测试嘲笑而言，太多了。\r\n            返回\r\n","\r\n Abstract node class that represents a name, possibly include generic arguments\r\n and qualified names.\r\n ":"\r\n 代表名称的抽象节点类，可能包括通用参数\r\n 和合格的名称。\r\n \r\n"," representing the specific kind of\r\n ReDimStatementSyntax. One of ReDimStatement, ReDimPreserveStatement.\r\n ":" 代表特定种类\r\n redimstatementsyntax。 Redimstatement之一，Redimpreservestatement。\r\n \r\n","\r\n If the given node is within a preprocessing directive, gets the preprocessing symbol info for it.\r\n ":"\r\n 如果给定的节点在预处理指令中，则获取预处理符号信息。\r\n \r\n","\r\n            Helps match patterns of the form: language=regex,option1,option2,option3\r\n            \r\n            All matching is case insensitive, with spaces allowed between the punctuation.\r\n            'regex' or 'regexp' are both allowed.  Option values will be or'ed together\r\n            to produce final options value.  If an unknown option is encountered, processing\r\n            will stop with whatever value has accumulated so far.\r\n            \r\n            Option names are the values from the ":"\r\n            有助于匹配表格的模式：语言= REGEX，option1，option2，option3\r\n            \r\n            所有匹配都是案例不敏感的，标点符号之间允许空间。\r\n            允许'Regex'或“ Regexp”。选项值将在一起\r\n            产生最终选项值。如果遇到未知选项，请处理\r\n            到目前为止，将停止任何价值。\r\n            \r\n            选项名称是来自\r\n","The member is defined in metadata.":"该成员在元数据中定义。\r\n","The name '_' refers to the constant, not the discard pattern. Use 'var _' to discard the value, or '@_' to refer to a constant by that name.":"名称“ _”是指常数，而不是丢弃模式。使用'var _'丢弃值，或“ @_”来指代常数。\r\n","\r\n            For some Foo(int x, params int[] p), this helps convert the \"1, 2, 3\" in Foo(0, 1, 2, 3)\r\n            to \"new int[] { 1, 2, 3 }\" in Foo(0, new int[] { 1, 2, 3 });\r\n            ":"\r\n            对于某些foo（int x，params int [] p），这有助于转换foo中的“ 1、2、3”（0、1、2、3）\r\n            在foo（0，new Int [] {1，2，3}）中;\r\n            \r\n","\r\n Given a property block syntax get the corresponding property symbol.\r\n ":"\r\n 给定的属性块语法获取相应的属性符号。\r\n \r\n","\r\n  Looks up a localized string similar to 'Shared' cannot be combined with '{0}' on a property declaration..\r\n":"\r\n  在属性声明上查找类似于“共享”的本地化字符串。\r\n\r\n","\r\n Gets the name of this symbol.\r\n ":"\r\n 获取此符号的名称。\r\n \r\n"," may not correspond to any document in the given ":"可能与给定的任何文件不符\r\n","Convert to regular string":"转换为常规字符串\r\n","\r\n            Introduces a new parameter and refactors all the call sites based on the selected code action.\r\n            ":"\r\n            根据所选代码操作引入一个新参数和重构所有调用站点。\r\n            \r\n"," for await foreach statements,\r\n            ":" 等待着语句，\r\n            \r\n","\r\n This method is called on every variable reference.\r\n It checks for cases where variable is declared outside of the lambda in which it is being accessed\r\n If capture is detected, than it marks variable as capturED and all lambdas involved as capturING\r\n ":"\r\n 每个变量参考都调用此方法。\r\n 它检查是否在访问它的lambda之外声明变量的案例\r\n 如果检测到捕获，则比捕获的变量标记为捕获，所有lambdas涉及捕获\r\n \r\n","\r\n The value for the Default property.\r\n ":"\r\n 默认属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to '(' unexpected. Arrays of uninstantiated generic types are not allowed..\r\n":"\r\n  查找类似于'的本地化字符串（“意外。不可能的通用类型的阵列）。\r\n\r\n","\r\n Returns a copy of this with the EndQuoteToken property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中EndQuotetkoken属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n The \"On\" keyword.\r\n ":"\r\n “ on”关键字。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' is ambiguous..\r\n":"查找类似于'{0}'的本地化字符串是模棱两可的。\r\n\r\n","non-word character":"非词字符\r\n","\r\n            This is the part of the declared namespace that is contained in default namespace.\r\n            We will use this to construct target folder to move the file to.\r\n            For example, if default namespace is `A` and declared namespace is `A.B.C`, \r\n            this would be `B.C`.\r\n            ":"\r\n            这是默认名称空间中包含的已声明名称空间的一部分。\r\n            我们将使用它来构建目标文件夹以将文件移至。\r\n            例如，如果默认命名空间为``a```\r\n            这将是``B.C'。\r\n            \r\n"," if not an argument list character, otherwise whether the trigger is in an argument list.":" 如果不是参数列表字符，否则触发器是否在参数列表中。\r\n","\r\n            Pairs of (node, statement part), or (node, -1) indicating there is no logical following statement.\r\n            The enumeration continues until the root is reached.\r\n            ":"\r\n            对（节点，语句零件）或（节点，-1）的对表示没有逻辑以下语句。\r\n            枚举一直持续到达根为止。\r\n            \r\n","\r\n Helper method for wrapping a string and offset in an SourceText.\r\n ":"\r\n 辅助方法，用于包裹字符串和偏移源。\r\n \r\n","\r\n The default charset used for type marshalling. \r\n Can be changed via ":"\r\n 用于类型编组的默认字符集。\r\n 可以通过\r\n","The offset within the file at which the header started, or was expected to start.":"标头开始或预期开始的文件内的偏移量。\r\n","To cancel symbol resolution":"取消符号分辨率\r\n","\r\n            Values for these parameters can be provided (during testing) for mocking purposes.\r\n            ":"\r\n            这些参数的值可以提供（在测试期间）用于模拟目的。\r\n            \r\n","\r\n            Returns all symbols associated with an edit and an actual edit kind, which may be different then the specified one.\r\n            Returns an empty set if the edit is not associated with any symbols.\r\n            ":"\r\n            返回与编辑和实际编辑类型关联的所有符号，这可能与指定的符号不同。\r\n            如果编辑与任何符号没有关联，则返回空集。\r\n            \r\n","The syntax node that declares a constructor.":"声明构造函数的语法节点。\r\n","\r\n  Looks up a localized string similar to Inherits clause of {0} '{1}' causes cyclic dependency: {2}.\r\n":"\r\n  查找类似于{0}'{1}'的继承子句的本地化字符串导致环状依赖性：{2}。\r\n\r\n",".\r\n The ":"。\r\n 这\r\n","\r\n If the Kind is ExtendKind.Assembly, returns the assembly symbol that this namespace\r\n encompasses. Otherwise throws InvalidOperationException.\r\n ":"\r\n 如果类型是ExtendKind.sembly，请返回此名称空间的汇编符号\r\n 包含。否则会引发无效的exception。\r\n \r\n","\r\n            and no breakpoint spans that do not belong to the ":"\r\n            并且没有断点跨越不属于\r\n","\r\n  Looks up a localized string similar to 'Try' must end with a matching 'End Try'..\r\n":"\r\n  查找类似于“尝试”的本地化字符串必须以匹配的“结束尝试”结尾。\r\n\r\n","\r\n Keys are GenericNameSyntax nodes representing unbound generic types.\r\n Values are false if the node should result in an error and true otherwise.\r\n ":"\r\n 键是代表无限通用类型的genericNamesyntax节点。\r\n 值如果节点应导致错误，则值为false。\r\n \r\n","\r\n Process an alias clause and any imported mappings from it.\r\n E.g., If you have an alias Ex=Blah.Extension, add any mapping for Extension to those for Ex.\r\n Note that although, in VB, an alias cannot reference another alias, this code doesn't not attempt\r\n to distinguish between aliases and regular names, as that would add complexity to the data structure\r\n and would be unlikely to matter. This entire class is probabilistic anyone and is only used for quick\r\n checks.\r\n ":"\r\n 处理一个别名条款和任何导入的映射。\r\n 例如，如果您有一个别名ex = blah.extension。\r\n 请注意，尽管在VB中，别名不能引用另一个别名，但此代码不会没有尝试\r\n 区分别名和常规名称，因为这会增加数据结构的复杂性\r\n 并且不太可能很重要。整个班级都是任何人，只用于快速\r\n 检查。\r\n \r\n","\r\n Perform any validation of import statements that must occur\r\n after the import statements have been added to the SourceFile.\r\n Specifically, constraints are checked for generic type references.\r\n ":"\r\n 执行任何必须发生的导入语句的验证\r\n 在将导入语句添加到SourceFile之后。\r\n 具体而言，检查了一般类型参考的约束。\r\n \r\n","\r\n The value for the StartTag property.\r\n ":"\r\n StartTag属性的值。\r\n \r\n","Explicitly implemented methods of records must have parameter names that match the compiler generated equivalent '{0}'":"明确实现的记录方法必须具有匹配编译器生成的等效'{0}'的参数名称\r\n","\r\n  Looks up a localized string similar to Array exceeds the limit of 32 dimensions..\r\n":"\r\n  查找类似于数组的局部字符串超过32维的限制。\r\n\r\n","\r\n Returns true if the compiler accepted this method as the sole correct result of overload resolution.\r\n ":"\r\n 如果编译器接受此方法作为过载分辨率的唯一正确结果，则返回true。\r\n \r\n","\r\n            Set of type and namespace names that have an alias associated with them.  i.e. if the\r\n            user has ":"\r\n            类型和名称名称，它们具有与之关联的别名。即\r\n            用户有\r\n","\r\n Rewrite lambda that are being converted to LINQ expression trees (Expression(Of T))\r\n ":"\r\n 重写正在转换为linq表达树的lambda（表达式（t）表达）\r\n \r\n","\r\n Represents a ReDim statement clause.\r\n ":"\r\n 代表一个redim语句条款。\r\n \r\n","\r\n            A metadata name used by telemetry to distinguish between the different kinds of this code action.\r\n            This code action will perform 2 different actions depending on if missing parameters can be optional.\r\n            \r\n            In this case we don't want to use the title as it depends on the class name for the ctor.\r\n            ":"\r\n            遥测用于区分此代码操作的不同类型的元数据名称。\r\n            此代码操作将执行2个不同的操作，具体取决于是否可以选择缺少参数。\r\n            \r\n            在这种情况下，我们不希望使用标题，因为它取决于ctor的类名。\r\n            \r\n","\r\n True if 'Handles' is specified in method's declaration\r\n ":"\r\n 如果在方法的声明中指定了“句柄”，则为true\r\n \r\n","\r\n            List of active debugging sessions (small number of simoultaneously active sessions is expected).\r\n            ":"\r\n            主动调试会话列表（预计会有少量的类似活动会话）。\r\n            \r\n","\r\n Bind a type name using the given binder. Returns a type symbol if the binding bound\r\n to something, or an error symbol if the binding failed. In either case, errors may\r\n be reported via the context. For example, if an inaccessible type or type with the\r\n wrong arity was found, the best possible type is returned, but an error is also\r\n generated.\r\n ":"\r\n 使用给定的粘合剂绑定类型名称。如果绑定绑定，则返回类型符号\r\n 如果绑定失败，则可以或错误符号。无论哪种情况，错误都可能\r\n 可以通过上下文报告。例如，如果是无法访问的类型或类型\r\n 发现了错误的Arity，返回了最好的类型，但错误也是\r\n 生成。\r\n \r\n","\r\n Sequence of names for nested child namespaces.\r\n ":"\r\n 嵌套子名称空间的名称序列。\r\n \r\n","\r\n Special slot for tracking the implicit local for the function return value\r\n ":"\r\n 用于跟踪函数返回值隐式本地的特殊插槽\r\n \r\n","\r\n            Tries to build either a specific or a default converter.\r\n            ":"\r\n            试图构建特定或默认转换器。\r\n            \r\n","\r\n Returns true and a ":"\r\n 返回真实和\r\n","var preferences":"VAR首选项\r\n","\r\n Gets the standard Visual Basic source file extension\r\n ":"\r\n 获取标准的视觉基本源文件扩展名\r\n \r\n","\r\n            The span in the original text that should be replaced with the documentation comment.\r\n            ":"\r\n            原始文本中应替换为文档注释的跨度。\r\n            \r\n","An ImmutableArray containing all the namespaces that are members of this symbol. If this symbol has no namespace members,\r\n returns an empty ImmutableArray. Never returns Nothing.":"一个不含该符号成员的名称空间的immutablearray。如果此符号没有名称空间成员，\r\n 返回一个空的Immutablearray。永远不会返回。\r\n","\r\n            Symbol usage info associated with the reference.\r\n            This entry indicates that the reference has additional usage information, such as\r\n            it is a read/write reference for 'a++'.\r\n            ":"\r\n            符号使用信息与参考相关的信息。\r\n            该条目表明该参考具有其他用法信息，例如\r\n            这是“ A ++”的读/写参考。\r\n            \r\n","Introduce local constant for '{0}'":"介绍'{0}'的局部常数\r\n","\r\n            This is used instead of ":"\r\n            这是使用而不是\r\n","fixed statement":"固定语句\r\n","excluded-group":"排除组\r\n","\r\n digs into known concat operators and unwraps their arguments\r\n otherwise returns the expression as-is\r\n \r\n Generally we only need to recognize same node patterns that we create as a result of concatenation rewrite.\r\n We could recognize some other nodes and unwrap to arguments \r\n ":"\r\n 挖掘已知的Concat操作员并解开其论点\r\n 否则返回表达式\r\n \r\n 通常，我们只需要识别串联重写而创建的相同节点模式。\r\n 我们可以识别其他一些节点并解开参数\r\n \r\n","\r\n             Exception regions -- spans of catch and finally handlers that surround the active statements.\r\n             \r\n             Null if the document has syntax errors, rude edits or has not changed.\r\n             ":"\r\n             异常区域 - 围绕活跃陈述的捕获和最后一个处理程序。\r\n             \r\n             null如果文档有语法错误，粗鲁的编辑或尚未更改。\r\n             \r\n","\r\n  Looks up a localized string similar to Comma expected..\r\n":"\r\n  查找类似于预期逗号的局部字符串。\r\n\r\n","\r\n            True if the provider produces items show be shown in expanded list only.\r\n            ":"\r\n            如果提供者生产的项目显示，则仅在扩展列表中显示。\r\n            \r\n","Specified code has errors.":"指定的代码有错误。\r\n","If specified, and the reference is qualified with namespace, the namespace part of original reference \r\n            will be replaced with given namespace in the new node.":"如果指定，并且参考条件有命名空间的资格，则是原始参考的名称空间一部分\r\n            将在新节点中的给定名称空间替换。\r\n","\r\n The name of the method being declared.\r\n ":"\r\n 该方法的名称正在声明。\r\n \r\n"," that represents the state after running ":" 这代表运行后的状态\r\n","\r\n Creates a string representing the formatted LocalizableErrorArgument instance.\r\n ":"\r\n 创建一个代表格式化的本地化术语实例的字符串。\r\n \r\n"," for given project.\r\n            ":" 给定项目。\r\n            \r\n","\r\n In some scenarios, it is safe to leave compound variable in nested form when there is an\r\n operator down the road that does its own projection (Select, Group By, ...). \r\n All following operators have to take an Anonymous Type in both cases and, since there is no way to\r\n restrict the shape of the Anonymous Type in method's declaration, the operators should be\r\n insensitive to the shape of the Anonymous Type.\r\n ":"\r\n 在某些情况下，当有一个时，以嵌套形式离开复合变量是安全的\r\n 操作员在做自己的投影的道路上（Select，组成，...）。\r\n 所有以下操作员在两种情况下都必须采用匿名类型，因为没有办法\r\n 限制方法声明中匿名类型的形状，操作员应为\r\n 对匿名类型的形状不敏感。\r\n \r\n","\r\n The \"Step\" keyword.\r\n ":"\r\n “步骤”关键字。\r\n \r\n","!<Stack overflow while evaluating object>":"！<堆栈溢出在评估对象>\r\n","Target runtime doesn't support 'protected', 'protected internal', or 'private protected' accessibility for a member of an interface.":"目标运行时不支持接口成员的“受保护”，“受保护的内部”或“私人保护”可访问性。\r\n","\r\n  Looks up a localized string similar to 'RaiseEvent' is already declared..\r\n":"\r\n  查找类似于“ raiseevent”的局部字符串已被声明。\r\n\r\n","\r\n Ignore duplicate types from the cor library.\r\n ":"\r\n 忽略COR库中的重复类型。\r\n \r\n","\r\n Return symbol text name the way Dev11 does it\r\n ":"\r\n 返回符号文本名称Dev11的方式\r\n \r\n","\r\n            The cancellation token that aggregates the original cancellation token + this progress\r\n            ":"\r\n            汇总原始取消令牌 +此进度的取消令牌\r\n            \r\n","Prefer explicitly provided tuple element name":"喜欢明确提供的元组元素名称\r\n"," bucket of code style diagnostics to enforce on build.":" 代码样式诊断的存储桶将在构建上执行。\r\n","\r\n Ensures that there are no stack locals. It is done by accessing \r\n virtual \"empty\" local that is at the bottom of all stack locals.\r\n ":"\r\n 确保没有堆栈当地人。它是通过访问来完成的\r\n 虚拟“空”本地，位于所有堆栈当地人的底部。\r\n \r\n","\r\n Represents a method declared in source. \r\n ":"\r\n 代表在源中声明的方法。\r\n \r\n","\r\n The object to compare with the current object. \r\n ":"\r\n 与当前对象进行比较的对象。\r\n \r\n"," by a newer baseline.\r\n            ":" 通过较新的基线。\r\n            \r\n","Use block body for methods":"使用块主体进行方法\r\n","Namespace does not match folder structure":"名称空间不匹配文件夹结构\r\n"," instances for refactoring given specified selection in document.\r\n            ":" 在文档中指定选择的重构实例。\r\n            \r\n","The syntax node that references the symbol":"引用符号的语法节点\r\n"," matches and should be renamed.\r\n            If this sorted set is null, it indicates that sub-spans to rename within the token span\r\n            are not available, and a regex match should be performed to rename\r\n            all ":" 比赛，应重命名。\r\n            如果此排序集为NULL，则表明在令牌跨度内重命名的子跨度\r\n            不可用，应进行正则匹配以重命名\r\n            全部\r\n","\r\n            return default organizers\r\n            ":"\r\n            返回默认组织者\r\n            \r\n","year month":"年份\r\n","\r\n Represents the primary module of an assembly being built by compiler.\r\n ":"\r\n 代表由编译器构建的组件的主要模块。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' cannot expose the underlying delegate type '{1}' of the event it is implementing to {2} '{3}' through {4} '{5}'..\r\n":"\r\n  查找类似于'{0}'的本地化字符串，无法公开其实现的事件的基础委托类型'{1}'通过{4}'{5}'{5}'..\r\n\r\n","Options used to customize formatting of a literal value.":"用于自定义字面价值格式的选项。\r\n","\r\n            A per language service for constructing context dependent list of completions that \r\n            can be presented to a user during typing in an editor.\r\n            ":"\r\n            用于构建上下文依赖的完成列表的每个语言服务\r\n            可以在编辑器中键入编辑器时向用户展示。\r\n            \r\n","\r\n Gets the binder that encloses the position. See comment on LookupSymbols for how\r\n positions are interpreted.\r\n ":"\r\n 获取包含位置的活页夹。请参阅有关如何查看查找的评论\r\n 位置被解释。\r\n \r\n","Partial method '{0}' must have accessibility modifiers because it has 'out' parameters.":"部分方法'{0}'必须具有可访问性修饰符，因为它具有'out'参数。\r\n","\r\n Convert source expression to queryable type by inferring control variable type \r\n and applying AsQueryable/AsEnumerable or Cast(Of Object) calls.   \r\n \r\n In case of success, returns possibly \"converted\" source and non-Nothing controlVariableType.\r\n In case of failure, returns passed in source and Nothing as controlVariableType.\r\n ":"\r\n 通过推断控制变量类型将源表达式转换为可查询类型\r\n 并应用令人震惊的/可触觉的或（对象）调用。\r\n \r\n 在成功的情况下，返回可能是“转换”的源和非缺乏控制Variabletype。\r\n 在失败的情况下，返回通过源传递，没有任何作为ControlVariaBletype。\r\n \r\n","\r\n  Looks up a localized string similar to 'Optional' and 'ParamArray' cannot be combined..\r\n":"\r\n  查找类似于“可选”和“ paramarray”的局部字符串。\r\n\r\n","An alternating list of nodes and tokens.":"节点和令牌的交替列表。\r\n","\r\n Describes a single variable of the form \"[x [As Type] =] aggregation-function\"\r\n for use in the Into clause of Aggregate or Group By or Group Join query\r\n operators.\r\n ":"\r\n 描述“ [x [as type] =]聚合功能”的形式的一个变量\r\n 用于在汇总或组的子句中使用或组加入查询\r\n 操作员。\r\n \r\n","\r\n The flow analysis state at each label, computed by merging the state from branches to\r\n that label with the state when we fall into the label.  Entries are created when the\r\n label is encountered.  One case deserves special attention: when the destination of the\r\n branch is a label earlier in the code, it is possible (though rarely occurs in practice)\r\n that we are changing the state at a label that we've already analyzed. In that case we\r\n run another pass of the analysis to allow those changes to propagate. This repeats until\r\n no further changes to the state of these labels occurs.  This can result in quadratic\r\n performance in unlikely but possible code such as this: \"int x; if (cond) goto l1; x =\r\n 3; l5: print x; l4: goto l5; l3: goto l4; l2: goto l3; l1: goto l2;\"\r\n ":"\r\n 每个标签处的流量分析状态，通过将状态从分支合并到\r\n 当我们跌入标签时，该标签与状态。当\r\n 遇到标签。一个案子值得特别注意：当目的地的目的地\r\n 分支是代码早期的标签，这是可能的（尽管在实践中很少发生）\r\n 我们正在通过已经分析的标签更改状态。在这种情况下，我们\r\n 运行另一个分析的通过，以允许这些更改传播。这重复直到为止\r\n 这些标签的状态没有进一步的变化。这可能导致二次\r\n 以下不太可能但可能的代码性能：“ int x; if（cond）goto l1; x =\r\n 3; L5：打印x； L4：goto l5; L3：goto l4; L2：goto l3; L1：goto l2;”\r\n \r\n","Unwrap call chain":"解开呼叫链\r\n","\r\n            Returns null if the type is not considered primitive in the target language.\r\n            ":"\r\n            返回null如果类型不被视为目标语言中的原始类型。\r\n            \r\n","A character position used to identify a declaration scope and accessibility. This\r\n character position must be within the FullSpan of the Root syntax node in this SemanticModel.\r\n ":"用于标识声明范围和可访问性的角色位置。这个\r\n 字符位置必须在此semanticmodel中的root语法节点的成面内。\r\n \r\n","match exactly 'n' times (lazy)":"完全匹配“ n”时间（懒惰）\r\n","\r\n The values are not affected by line mapping directives (":"\r\n 这些值不受行映射指令的影响（\r\n","', but outside any \r\n type. Protected members are deemed inaccessible.\r\n ":"'，但是在任何地方\r\n 类型。受保护的成员被认为无法访问。\r\n \r\n"," but\r\n            with a predetermined analysis of the input instead of recalculating it\r\n            ":" 但\r\n            通过对输入的预定分析而不是重新计算\r\n            \r\n","\r\n            Helper class for \"Fix all occurrences\" code fix providers.\r\n            ":"\r\n            用于“修复所有事件”代码修复提供商的“修复所有事件”的帮助类。\r\n            \r\n","\r\n Returns symbol for the event interface or Nothing when event interface is not synthesized.\r\n ":"\r\n 事件接口的返回符号或当事件接口未合成时什么都没有。\r\n \r\n","\r\n Get the \"this\" parameter for this field.  This is only valid for source fields.\r\n ":"\r\n 获取此字段的“此”参数。这仅适用于源字段。\r\n \r\n","\r\n            Copy of the specified file, or null if the file doesn't need a copy (":"\r\n            指定文件的副本或null如果文件不需要复制（\r\n","The input always matches the provided pattern.":"输入始终与提供的模式匹配。\r\n","\r\n The value for the CommaTokens property.\r\n ":"通讯属性的价值。\r\n \r\n","Index into ":"索引\r\n","\r\n Should return full emitted namespace name for a top level type if the name \r\n might be different in case from containing namespace symbol full name, Nothing otherwise.\r\n \r\n Although namespaces unify based on case-insensitive name, VB uses the casing the namespace\r\n declaration surround the class definition for the name emitted to metadata. \r\n \r\n Namespace FOO\r\n    Class X\r\n    End Class\r\n ENd Namespace\r\n Namespace foo\r\n    Class Y\r\n    End Class\r\n ENd Namespace\r\n \r\n In metadata, these are classes \"FOO.X\" and \"foo.Y\" (and thus appear in different namespaces\r\n when imported into C#.) This function determines the casing of the namespace part of a class, if needed\r\n to override the namespace name.\r\n ":"\r\n 如果名称\r\n 如果没有包含名称空间符号的全名，则可能不同。\r\n \r\n 尽管命名空间基于对案例不敏感的名称统一，但VB使用壳体名称空间\r\n 声明围绕着发出元数据的名称的班级定义。\r\n \r\n 名称空间foo\r\n    X类\r\n    最终课程\r\n 终点空间\r\n 名称空间foo\r\n    Y级\r\n    最终课程\r\n 终点空间\r\n \r\n 在元数据中，这些是“ foo.x”和“ foo.y”类（因此出现在不同的名称空间中\r\n 当导入到C＃。）此功能确定类的命名空间部分的外壳，如果需要\r\n 覆盖名称名称。\r\n \r\n","\r\n Helper methods that exist to share code between properties and events.\r\n ":"\r\n 在属性和事件之间共享代码的帮助方法。\r\n \r\n","\r\n            The optional id for a ":"\r\n            可选ID\r\n","\r\n            Note that this is initially unset until we find a non-constant expression.\r\n            ":"\r\n            请注意，这最初是不设置的，直到我们找到非恒定表达式为止。\r\n            \r\n","Custom  assembly loader.":"自定义装配装载机。\r\n","Order modifiers":"订购修饰符\r\n","\r\n Returns a copy of this with the LessThanToken property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而Lessthantken属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Returns the location (span) of the accessor begin block.\r\n (Used for consistency with the native compiler that\r\n highlights the entire begin block for certain diagnostics.)\r\n ":"\r\n 返回登录器开始块的位置（跨度）。\r\n （用于与本地编译器一致的\r\n 突出显示某些诊断的整个开始块。）\r\n \r\n","\r\n The \"Case\" keyword, if present.\r\n ":"\r\n “案例”关键字，如果存在。\r\n \r\n","\r\n Attempts to fold conversion of a constant expression.\r\n \r\n Returns Nothing if conversion cannot be folded, i.e. unexpected source and destination types. \r\n Returns Bad value (Discriminator = ConstantValueTypeDiscriminator.Bad) if conversion failed due to non-integer overflow. \r\n \r\n If integer overflow occurs, integerOverflow is set to True and the overflowed result is returned. \r\n ":"\r\n 尝试折叠恒定表达式的转换。\r\n \r\n 如果无法折叠转换，即意外的源和目标类型，则返回一无所获。\r\n 返回不良值（Indiciminator = ConstantValuetypediscriminator.bad）如果由于非整数溢出而失败。\r\n \r\n 如果发生整数溢出，则将InteGerOverFlow设置为TRUE，并返回溢出结果。\r\n \r\n","\r\n Is this an accessor parameter that came from the associated property? If so, \r\n return it, else return Nothing.\r\n ":"\r\n 这是来自关联属性的登录参数吗？如果是这样，\r\n 返回它，否则什么也没返回。\r\n \r\n","\r\n Check each member of container for constraints against the base type. For methods and properties and events,\r\n checking overriding and hiding constraints. For other members, just check for hiding issues.\r\n ":"\r\n 检查容器的每个成员是否针对基本类型的约束。对于方法，属性和事件，\r\n 检查覆盖和隐藏约束。对于其他成员，只需检查隐藏问题即可。\r\n \r\n","\r\n Given a operator statement syntax get the corresponding method symbol.\r\n ":"\r\n 给定一个操作员语句语法获取相应的方法符号。\r\n \r\n","\r\n Indicates that this PE file makes Win32 calls. See CorPEKind.pe32BitRequired for more information (http://msdn.microsoft.com/en-us/library/ms230275.aspx).\r\n ":"\r\n 指示此PE文件进行Win32调用。有关更多信息，请参见Corpekind.pe32bitrequired（http://msdn.microsoft.com/en-us/library/ms230275.aspx）。\r\n \r\n","\r\n The value for the GreaterThanToken property.\r\n ":"\r\n GreaterThantoken财产的价值。\r\n \r\n","\r\n This instance is used to compare potential WinRT fake members in type projection.\r\n \r\n FIXME(angocke): This is almost certainly wrong. The semantics of WinRT conflict \r\n comparison should probably match overload resolution (i.e., we should not add a member\r\n  to lookup that would result in ambiguity), but this is closer to what Dev12 does.\r\n \r\n The real fix here is to establish a spec for how WinRT conflict comparison should be\r\n performed. Once this is done we should remove these comments.\r\n ":"\r\n 此实例用于比较类型投影中潜在的WinRT假成员。\r\n \r\n FixMe（Angocke）：这几乎可以肯定是错误的。 Winrt冲突的语义\r\n 比较可能应匹配超载分辨率（即，我们不应添加成员\r\n  查找会导致歧义），但这更接近Dev12的作用。\r\n \r\n 这里的真正解决方案是建立一个规范Winrt冲突应该如何比较\r\n 执行。完成此操作后，我们应该删除这些评论。\r\n \r\n","\r\n Checks all symbol locations against the syntax provided and return symbol if any of the locations is \r\n inside the syntax span. Returns Nothing otherwise.\r\n ":"\r\n 检查所有符号位置针对所提供的语法，并返回符号，如果有任何位置\r\n 在语法跨度内。否则什么也没返回。\r\n \r\n","\r\n            Gets the concatenated value text for the token list.\r\n            ":"\r\n            获取令牌列表的串联值文本。\r\n            \r\n","\r\n Helper to check whether the token is a predefined type OR Variant keyword\r\n ":"\r\n 助手检查令牌是预定义的类型还是变体关键字\r\n \r\n","A static abstract interface member can be accessed only on a type parameter.":"静态抽象接口成员只能在类型参数上访问。\r\n","To cancel project and document operations":"取消项目和文件操作\r\n","\r\n The value for the ForKeyword property.\r\n ":"\r\n forkeyword属性的值。\r\n \r\n"," so that suppression fixes\r\n            always show up last after all other fixes (and refactorings) for the selected line of code.\r\n            ":" 这样的抑制作用\r\n            始终在所有其他修复程序（和重构）的代码行后最后出现。\r\n            \r\n","\r\n            Represents if the count is capped by a certain maximum.\r\n            ":"\r\n            表示计数是否由某个最大值限制。\r\n            \r\n","\r\n Use the receiver of the ObjectCreationExpression to as the omitted left of a dictionary access.\r\n ":"\r\n 将ObjectCreationexpression的接收器作为字典访问的左侧省略。\r\n \r\n","\r\n            Determines if the expression is something that should have code actions displayed for it.\r\n            Depends upon the identifiers in the expression mapping back to parameters.\r\n            Does not handle params parameters.\r\n            ":"\r\n            确定表达式是否应该显示为其显示的代码操作。\r\n            取决于表达式映射回到参数中的标识符。\r\n            不处理参数。\r\n            \r\n","\r\n Creates the syntax representation of a placeholder element within xml documentation comments.\r\n ":"\r\n 在XML文档注释中创建占位符元素的语法表示。\r\n \r\n"," implies ":" 暗示\r\n","\r\n            Contains helpers used by several simplifier subclasses.\r\n            ":"\r\n            包含几个简化子类使用的帮助者。\r\n            \r\n","The \"ffff\" custom format specifier represents the four most significant digits of the seconds fraction; that is, it represents the ten thousandths of a second in a date and time value.\r\n            \r\n            Although it's possible to display the ten thousandths of a second comp ...":"“ FFFF”自定义格式指示符表示秒数的四个最重要的数字；也就是说，它代表了日期和时间值中的一千分之一。\r\n            \r\n            虽然可以显示第二个comp的十分之一...\r\n","\r\n  Looks up a localized string similar to '{0}' cannot be indexed because it has no default property..\r\n":"\r\n  查找类似于'{0}'的本地化字符串，因为它没有默认属性。\r\n\r\n","\r\n Given a delegate statement syntax get the corresponding named type symbol.\r\n ":"\r\n 给定的委托语句语法获取相应的命名类型符号。\r\n \r\n","\r\n            Called when a new set of (possibly empty) diagnostics have been produced.  This\r\n            happens through normal editing and processing of files as diagnostic analyzers\r\n            produce new diagnostics for documents and projects.\r\n            ":"\r\n            当产生了一组新的（可能为空的）诊断时，请致电。这个\r\n            通过正常编辑和处理文件作为诊断分析仪发生\r\n            为文档和项目生产新的诊断。\r\n            \r\n","\r\n Implementation for an operator\r\n ":"\r\n 操作员的实施\r\n \r\n","\r\n            Base type of all ```(?...)``` groupings.\r\n            ":"\r\n            所有的基本类型``（？...）``分组。\r\n            \r\n","\r\n Returns a copy of this with the FinallyBlock property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此的副本，最后一个block属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Represents a method of a generic type instantiation.\r\n e.g. \r\n A{int}.M()\r\n A.B{int}.C.M()\r\n ":"\r\n 代表一种通用类型实例化的方法。\r\n 例如\r\n {int} .m（）\r\n a.b {int} .c.m（）\r\n \r\n"," if this instance is shared; otherwise, ":" 如果共享此实例；否则，\r\n","Array of capabilities retrieved from the runtime to dictate supported rude edits.":"从运行时检索到一系列功能，以决定支持的粗鲁编辑。\r\n","\r\n Type substitution for this symbol, it targets OriginalDefinition of the symbol.\r\n ":"\r\n 替换此符号，它针对符号的原始定义。\r\n \r\n","The \"u\" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.UniversalSortableDateTimePattern property. The pattern reflects a defined standard, and the property is read-only. Therefore, it is  ...":"“ U”标准格式指定符表示由DateTimeFormatInfo.universalsalbabledateTimePattern属性定义的自定义日期和时间格式字符串。该模式反映了定义的标准，并且该属性仅读取。因此它是  ...\r\n","\r\n A NamespaceExtent represents whether a namespace contains types and sub-namespaces from a particular module,\r\n assembly, or merged across all modules (source and metadata) in a particular compilation.\r\n ":"\r\n namespaceextent表示名称空间是否包含来自特定模块的类型和子名称空间，\r\n 组装，或在特定汇编中跨所有模块（源和元数据）合并。\r\n \r\n","Set to true if there are conversion errors (e.g. Asc(\"\")). Otherwise it's not written to.":"如果有转换错误（例如ASC（“”）），则设置为true。否则就不会写信。\r\n","\r\n  Looks up a localized string similar to '{0}' cannot be used as an attribute because it is not a class..\r\n":"\r\n  查找类似于'{0}'的本地化字符串不能用作属性，因为它不是类。\r\n\r\n","\r\n            Displays a message box with a yes/no question to the user.\r\n            ":"\r\n            显示一个消息框，对用户有肯定的问题。\r\n            \r\n","\r\n Lookup a top level type within the assembly or one of the assemblies referenced by the primary module, \r\n names are compared case-sensitively. In case of ambiguity, type from this assembly wins,\r\n otherwise Nothing is returned.\r\n ":"\r\n 查找组件中的顶级类型或主模块引用的一个组件之一，\r\n 名称是敏感的。如果有歧义，请从这个大会上赢得胜利，\r\n 否则什么都不会返回。\r\n \r\n","The symbol which is the target of the attribute.":"符号是属性的目标。\r\n","\r\n This method is called directly by a Binder when it uses this type.\r\n ":"\r\n 当粘合剂使用此类型时，该方法是直接调用的。\r\n \r\n","\r\n The text changes combined into a single region.\r\n ":"\r\n 文本更改合并为单个区域。\r\n \r\n","An ImmutableArray containing all the members of this symbol. If this symbol has no members,\r\n returns an empty ImmutableArray. Never returns null.":"一个包含此符号的所有成员的不可分付款。如果此符号没有成员，\r\n 返回一个空的Immutablearray。永远不会返回零。\r\n","\r\n The Imports binder handles binding of Imports statements in files, and also the project-level imports.\r\n ":"\r\n 导入粘合剂处理文件中的导入语句的绑定以及项目级导入。\r\n \r\n",".\r\n            The trimmed version is then used to determine relevant ":"。\r\n            然后使用修剪版本来确定相关的版本\r\n","\r\n  Looks up a localized string similar to Reference to class '{0}' is not allowed when its assembly is configured to embed interop types..\r\n":"\r\n  查找类似于类“ {0}”的引用的本地化字符串，当将其组装配置为嵌入Interop类型时，不允许使用。\r\n\r\n","\r\n Containing type or method.\r\n The field is not read-only because it is initialized after construction through\r\n SetContainingSymbol() method.\r\n ":"\r\n 包含类型或方法。\r\n 该字段不仅读取，因为它是在施工后初始化的\r\n setContainingsymbol（）方法。\r\n \r\n","\r\n The part of the name that appears to the left of the dot. This can itself be\r\n any name.\r\n ":"\r\n DOT左侧出现的名称的一部分。这本身就是\r\n 任何名字。\r\n \r\n","\r\n A list of all the query operators in this query expression. This list always\r\n contains at least one operator.\r\n ":"\r\n 此查询表达式中所有查询运算符的列表。总是这个列表\r\n 至少包含一个操作员。\r\n \r\n","\r\n            Align all the wrapped parts of the expression with the token after 'return'.\r\n            That way we get:\r\n            \r\n            return a == obj.a &&\r\n                   b == obj.b &&\r\n                   ...\r\n            ":"\r\n            “返回”后，将表达式的所有包裹部分与令牌对齐。\r\n            这样我们得到：\r\n            \r\n            返回a == obj.a && &&\r\n                   b == obj.b &&\r\n                   ...\r\n            \r\n"," in the containing type.\r\n            The overload must have the same return type as ":" 在包含类型中。\r\n            过载必须具有与\r\n","\r\n            this help finding a range of tokens to format based on given ending token\r\n            ":"\r\n            这有助于根据给定的结尾令牌找到一系列令牌以格式化\r\n            \r\n","\r\n Returns a hash code for the current object.\r\n ":"\r\n 返回当前对象的哈希代码。\r\n \r\n","Unknown property '{0}'":"未知属性'{0}'\r\n","\r\n The \"Each\" keyword.\r\n ":"\r\n “每个”关键字。\r\n \r\n","\r\n  Looks up a localized string similar to Attribute '{0}' cannot be applied to a module..\r\n":"\r\n  查找类似于属性'{0}'的本地化字符串无法应用于模块。\r\n\r\n","\r\n            Recursive function that decomposes ":"\r\n            分解的递归功能\r\n","\r\n Parses a specified string to create a GlobalImport instance.\r\n ":"\r\n 解析指定的字符串以创建一个GlobalImport实例。\r\n \r\n","The text used to determine the order that the item appears in the list.":"用于确定项目出现在列表中的顺序的文本。\r\n","Invalid selection.":"无效的选择。\r\n","Cannot apply changes -- unexpected error: '{0}'":"无法应用更改 - 意外错误：'{0}'\r\n","other, not assigned":"其他，未分配\r\n","\r\n            Groups active statements by document path as listed in the PDB.\r\n            Within each group the statements are ordered by their start position.\r\n            ":"\r\n            按PDB中列出的文档路径进行活动语句。\r\n            在每个组中，语句按其起始位置排序。\r\n            \r\n","\r\n The value for the EndPropertyStatement property.\r\n ":"\r\n EndPropertyStatement属性的值。\r\n \r\n","\r\n Represents a method parameter that has undergone type substitution.\r\n ":"\r\n 代表具有经历类型替代的方法参数。\r\n \r\n","Take both":"两者兼而有之\r\n","\r\n            We create a mutex so other processes can see if our directory is still alive. We destroy the mutex when\r\n            we purge our generated files.\r\n            ":"\r\n            我们创建一个互斥X，以便其他过程可以查看我们的目录是否还活着。我们摧毁了穆特克斯\r\n            我们清除生成的文件。\r\n            \r\n","\r\n RaiseEvent situation is very special: \r\n 1) Unlike other syntaxes that take named arguments, RaiseEvent is a statement. \r\n 2) RaiseEvent is essentially a wrapper around underlying call to the event rising method.\r\n    Note that while event itself may have named parameters in its syntax, their names could be irrelevant\r\n    For the purpose of fetching named parameters, it is the target of the call that we are interested in.\r\n    \r\n    === Example:\r\n \r\n Interface I1\r\n    Event E(qwer As Integer)  \r\n End Interface\r\n \r\n Class cls1 : Implements I1\r\n    Event E3(bar As Integer) Implements I1.E   '  \"bar\" means nothing here. Only type matters.\r\n\r\n    Sub moo()\r\n        RaiseEvent E3(qwer:=123)  ' qwer binds to parameter on I1.EEventhandler.invoke(foo)\r\n    End Sub\r\nEnd Class\r\n \r\n \r\n ":"\r\n Raiseevent情况非常特别：\r\n 1）与其他命名参数的语法不同，raiseevent是一个陈述。\r\n 2）Raiseevent本质上是围绕事件上升方法的基础呼叫的包装。\r\n    请注意，虽然事件本身可能在其语法中命名了参数，但它们的名称可能无关紧要\r\n    为了获取命名参数，它是我们感兴趣的呼叫的目标。\r\n    \r\n    ===示例：\r\n \r\n 接口I1\r\n    事件E（QWER作为整数）\r\n 结束接口\r\n \r\n CLS1类：实现I1\r\n    事件E3（bar作为整数）实现I1.E'“ bar”在这里什么都不意味着。仅类型很重要。\r\n\r\n    sub moo（）\r\n        raiseevent e3（qwer：= 123）'qwer bit bit in i1.eeventhandler.invoke（foo）上的参数\r\n    结束子\r\n最终课程\r\n \r\n \r\n \r\n","\r\n Atomically store value into variable, and store the diagnostics away for later retrieval.\r\n When this routine returns, variable is non-null. If this routine stored value into variable,\r\n then the diagnostic bag is saved away before the variable is stored and it returns True.\r\n Otherwise it returns False.\r\n ":"\r\n 将原子存储在变量中，然后将诊断存储在以后的检索中。\r\n 当此例程返回时，变量为非null。如果此例程将值存储到变量中，\r\n 然后在存储变量之前将诊断袋保存下来，并返回真实。\r\n 否则它将返回false。\r\n \r\n","\r\n            it will never change.\r\n            ":"\r\n            它永远不会改变。\r\n            \r\n","\r\n For implicitly declared delegate types returns the EventSymbol that caused this\r\n delegate type to be generated.\r\n For all other types returns null.\r\n Note, the set of possible associated symbols might be expanded in the future to \r\n reflect changes in the languages.\r\n ":"\r\n 对于隐式宣布的委托类型，返回造成此的事件符号\r\n 要生成的委托类型。\r\n 对于所有其他类型，返回null。\r\n 注意，将来可能会扩展一组可能的相关符号\r\n 反映语言的变化。\r\n \r\n","\r\n Returns true if this parameter was declared as Optional. \r\n ":"\r\n 如果该参数被声明为可选，则返回true。\r\n \r\n","\r\n            The completion items to present to the user.\r\n            ":"\r\n            要介绍给用户的完成项目。\r\n            \r\n","The binder to bind within. This binder is used for looking up\r\n unqualified names, accessibility checking, reporting errors, and probably other\r\n stuff too.":"粘合剂在内部结合。此活页夹用于查找\r\n 不合格的名称，可访问性检查，报告错误以及可能其他\r\n 也有东西。\r\n","\r\n The value for the StopOrEndKeyword property.\r\n ":"\r\n StoporendKeyword属性的值。\r\n \r\n","\r\n Creates a seealso element within an xml documentation comment.\r\n ":"\r\n 在XML文档注释中创建SEEALSO元素。\r\n \r\n","\r\n 'Safe' version of GetDeclaredBase takes into account bases being resolved to make sure \r\n we avoid infinite loops in some scenarios. Note that the cycle is being broken not when\r\n we detect it, but when we detect it on the 'smallest' type of the cycle, this brings stability \r\n in multithreaded scenarios while still ensures that we don't loop more than twice.\r\n ":"\r\n getDeclaredBase的“安全”版本已解决了解决方案以确保\r\n 在某些情况下，我们避免了无限循环。请注意，周期不是在何时破坏\r\n 我们检测到它，但是当我们在“最小”类型的周期上检测到它，这会带来稳定性\r\n 在多线程的情况下，虽然仍然可以确保我们的循环不超过两次。\r\n \r\n","\r\n            Updates the root of the document with the document update.\r\n            ":"\r\n            使用文档更新更新文档的根。\r\n            \r\n",".GetType() is used if not specified.":"如果未指定，则使用.getType（）。\r\n","indexer setter":"索引器设置器\r\n","\r\n            Implements shadow-copying metadata file cache.\r\n            ":"\r\n            实现影子复制元数据文件缓存。\r\n            \r\n","<interface name>":"<接口名称>\r\n",".Create\r\n            overloads.\r\n            \r\n            Subclassing is also supported for scenarios that fall outside the bounds of\r\n            these common cases.\r\n            ":"。创造\r\n            超载。\r\n            \r\n            还支持子类的场景。\r\n            这些常见案例。\r\n            \r\n","\r\n An empty token because all non terminals must have a token.\r\n ":"\r\n 一个空的令牌，因为所有非终端都必须具有令牌。\r\n \r\n","\r\n            Returns a node that represents a body of a lambda containing specified ":"\r\n            返回一个表示包含指定的lambda主体的节点\r\n","\r\n A list of the contained Case blocks.\r\n ":"\r\n 包含的案例块的列表。\r\n \r\n","The field.":"场。\r\n","\r\n The value for the ClassStatement property.\r\n ":"\r\n classstatement属性的值。\r\n \r\n","\r\n Analyze data-flow within a statement.\r\n ":"\r\n 在声明中分析数据流。\r\n \r\n","\r\n Bind to the global namespace.\r\n ":"\r\n 绑定到全局名称空间。\r\n \r\n","\r\n Gets a value indicating whether this instance is const, but not metadata constant. A field is considered to be \r\n const but not metadata constant if the const field's type is either Date or Decimal.\r\n ":"\r\n 获取一个指示此实例是否为const但不是元数据常数的值。一个字段被认为是\r\n 如果const字段的类型为日期或小数，则const但不是元数据常数。\r\n \r\n","\r\n Represents a GetXmlNamespace expression.\r\n ":"\r\n 代表getXMlNamespace表达式。\r\n \r\n","\r\n            The context presented to a ":"\r\n            呈现给\r\n","\r\n            Since ":"\r\n            自从\r\n"," as we need to show a confirmation\r\n            dialog to the user before applying the change.\r\n            ":" 因为我们需要显示确认\r\n            在应用更改之前，请与用户对话。\r\n            \r\n","\r\n  Looks up a localized string similar to Cannot find the interop type that matches the embedded type '{0}'. Are you missing an assembly reference?.\r\n":"\r\n  查找类似于类似的本地化字符串，找不到与嵌入式类型“ {0”}'匹配的Interop类型。您是否错过了组装参考？\r\n\r\n","\r\n True if we are in a place that allows implicit variable declaration. This binder\r\n implies that.\r\n ":"\r\n 如果我们在一个允许隐式变量声明的地方，则是真的。这个活页夹\r\n 暗示。\r\n \r\n","\r\n             x = a ?? throw SomeException();\r\n             ":"\r\n             x = a ??抛出一些exception（）;\r\n             \r\n","\r\n  Looks up a localized string similar to Anonymous type member name cannot be inferred from an XML identifier that is not a valid Visual Basic identifier..\r\n":"\r\n  从不是有效的Visual Basic标识符的XML标识符中推断出类似于匿名类型成员名称的本地化字符串。\r\n\r\n","\r\n Create substitution for targetGenericDefinition based on its type \r\n arguments (matched to type parameters by position) and TypeSubstitution\r\n for direct or indirect container.\r\n ":"\r\n 根据其类型创建替换为目标属性定义\r\n 参数（与位置键入类型参数匹配）和类型验证\r\n 用于直接或间接容器。\r\n \r\n","\r\n  True if this type is considered serializable (metadata flag Serializable is set).\r\n ":"\r\n  如果认为该类型可序列化（设置元数据标志可序列化）。\r\n \r\n","\r\n  Looks up a localized string similar to 'Microsoft.VisualBasic.ComClassAttribute' cannot be applied to '{0}' because it is not declared 'Public'..\r\n":"\r\n  查找类似于'Microsoft.visualbasic.comclassattribute“不能应用于'{0}'的本地化字符串，因为它没有声明为'public'。\r\n\r\n","\r\n SelectMany method for ":"\r\n 选择的方法\r\n","\r\n  Looks up a localized string similar to 'Await' cannot be used inside a 'Catch' statement, a 'Finally' statement, or a 'SyncLock' statement..\r\n":"\r\n  查找类似于“等待”的本地化字符串，无法在“ catch”语句，“最后”语句或“ synclock”语句中使用。\r\n\r\n","\r\n Returns a copy of this with the SubOrFunctionStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回其中的副本，并将其转换为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Returns a copy of this with the EndSyncLockStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中EndSynClockStatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","'init' accessors cannot be marked 'readonly'. Mark '{0}' readonly instead.":"“ init”登录器不能标记为“ ReadOnly”。标记'{0}'readonly。\r\n","\r\n Base class for symbols representing non-generic or open generic methods contained within constructed generic type.\r\n For example: A(Of Integer).B, A(Of Integer).B.C or A(Of Integer).B.C(Of ).\r\n ":"\r\n 代表构造的通用类型中包含的非生成或开放通用方法的符号的基类。\r\n 例如：a（integer）.b，a（integer）.b.c或a（integer）.b.c（of）。\r\n \r\n","\r\n Does this type implement all the members of the given interface. Does not include members\r\n of interfaces that iface inherits, only direct members.\r\n ":"\r\n 这种类型是否实现给定接口的所有成员。不包括成员\r\n IFACE继承的接口，仅指导成员。\r\n \r\n","\r\n            Generate a dictionary which key is the symbol in Callee (include local variable and parameter), value\r\n            is the replacement syntax node for all its occurence.\r\n            ":"\r\n            生成一个字典，该字典是键是callee中的符号（包括局部变量和参数），值\r\n            是其所有事件的替换语法节点。\r\n            \r\n","\r\n Represents a generic method of a generic type instantiation, closed over type parameters.\r\n e.g. \r\n A{T}.M{S}()\r\n A.B{T}.C.M{S}()\r\n ":"代表通用类型实例化的通用方法，封闭了类型参数。\r\n 例如\r\n a {t} .m {s}（）\r\n a.b {t} .c.m {s}（）（）\r\n \r\n","The switch expression does not handle some null inputs.":"开关表达式无法处理某些空输入。\r\n"," to produce the value for\r\n            ":" 产生价值\r\n            \r\n","\r\n The value for the UsingStatement property.\r\n ":"使用statement属性的值。\r\n \r\n","Unnecessary assignment of a value":"不必要的价值分配\r\n","\r\n Checks if it is allowed to take a writable reference to expression according to VB rules.\r\n ":"\r\n 检查是否允许根据VB规则对表达进行可写的参考。\r\n \r\n","Method symbol for the rewritten lambda body.":"重写Lambda主体的方法符号。\r\n","\r\n An elastic trivia with kind EndOfLineTrivia containing a single carriage return character. Elastic trivia\r\n are used to denote trivia that was Not produced by parsing source text, And are usually Not preserved during\r\n formatting.\r\n ":"\r\n 带有单个马车返回特征的弹性琐事。弹性琐事\r\n 用于表示未通过解析源文本产生的琐事，通常在\r\n 格式化。\r\n \r\n"," is a constructor with an initializer, \r\n            tokens of the initializer concatenated with tokens of the constructor body.\r\n            \r\n            If ":" 是具有初始化器的构造函数，\r\n            初始化器的代币与构造体主体的令牌连接在一起。\r\n            \r\n            如果\r\n","\r\n            Gets the style(s) to apply to the text.\r\n            ":"\r\n            获取样式应用于文本。\r\n            \r\n","\r\n            Creates a linq invocation expression.\r\n            ":"\r\n            创建LINQ调用表达式。\r\n            \r\n","\r\n  Looks up a localized string similar to '{0}' and '{1}' cannot be combined..\r\n":"\r\n  查找类似于'{0}'和'{1}'的本地化字符串。\r\n\r\n","\r\n            The resulting reader does not take ownership of the ":"\r\n            由此产生的读者不占有\r\n"," True, if the comment was written ":" 是的，如果写了评论\r\n","s for the ":"s\r\n","\r\n Returns a copy of this with the ClassKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，classKeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n"," with unsafe code regions allowed.\r\n            ":" 允许使用不安全的代码区域。\r\n            \r\n","\r\n  Looks up a localized string similar to Type arguments could not be inferred from the delegate..\r\n":"\r\n  查找类似于类型参数的本地化字符串无法从代表中推断出。\r\n\r\n","The qualifier (or left-hand-side) of the name expression. This may be null if there is no qualifier.":"名称表达式的预选赛（或左侧）。如果没有预选赛，这可能是无效的。\r\n","new-line character":"新线角色\r\n","\r\n Returns a copy of this with the SubOrFunctionKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中subfunctionkeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","The \"FFF\" custom format specifier represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value. However, trailing zeros or three zero digits aren't displayed.":"“ FFF”自定义格式指示符表示秒数的三个最重要的数字；也就是说，它代表日期和时间值中的毫秒。但是，未显示尾随的零或三个零数字。\r\n"," The invocation node that is the parent of \"argumentList\"":" 调用节点是“参数列表”的父母\r\n","\r\n The event being handled. This must be a simple identifier.\r\n ":"\r\n 活动正在处理。这必须是一个简单的标识符。\r\n \r\n"," applied on this symbol, or null if there are none.\r\n ":" 应用于此符号，如果没有，则应用于null。\r\n \r\n","\r\n Get the original definition of this symbol. If this symbol is derived from another\r\n symbol by (say) type substitution, this gets the original symbol, as it was defined\r\n in source or metadata.\r\n ":"\r\n 获取此符号的原始定义。如果此符号来自另一个符号\r\n 符号（例如）类型替代，这将获得原始符号，因为它被定义\r\n 在源或元数据中。\r\n \r\n","The local symbol":"本地符号\r\n","\r\n            Param tag with no matching parameter\r\n            ":"\r\n            没有匹配参数的参数标签\r\n            \r\n","Unwrap all arguments":"解开所有参数\r\n","\r\n            Provide a way to see whether solution crawler is started or not\r\n            ":"\r\n            提供一种方法来查看解决方案是否启动\r\n            \r\n","Remove redundant assignment":"删除冗余分配\r\n","\r\n Represents a declaration of an Enum, its contents and the End Enum statement\r\n that ends it.\r\n ":"\r\n 代表枚举的声明，其内容和最终枚举陈述\r\n 结束了。\r\n \r\n","Remove unnecessary discard":"删除不必要的丢弃\r\n","\r\n This structure holds the relevant bound node information relating to a particular syntax\r\n node, used temporarily for GetSemanticInfo and similar APIs. \r\n ":"\r\n 该结构拥有与特定语法有关的相关界点信息\r\n 节点，临时用于getemanticinfo和类似的API。\r\n \r\n"," is called an implementation\r\n            of ":" 称为实现\r\n            的\r\n","\r\n  Looks up a localized string similar to Compilation (Visual Basic): .\r\n":"\r\n  查找类似于汇编（Visual Basic）的局部字符串：。\r\n\r\n","Remove this value when another is added.":"添加另一个值时删除此值。\r\n","\r\n  Looks up a localized string similar to '{0}' cannot inherit from {1} '{2}' because it expands the access of the base {1} outside the assembly..\r\n":"\r\n  查找类似于'{0}'的本地化字符串，无法从{1}'{2}'继承，因为它扩展了汇编外基础{1}的访问。\r\n\r\n","Changes to expression trees may result in behavior changes at runtime":"表达树的变化可能会导致运行时行为变化\r\n","\r\n The variables in the Next statement, if present\r\n ":"\r\n 下一个语句中的变量，如果存在\r\n \r\n","With DateTime values, the \"z\" custom format specifier represents the signed offset of the local operating system's time zone from Coordinated Universal Time (UTC), measured in hours. It doesn't reflect the value of an instance's DateTime.Kind property. For ...":"使用DateTime值，“ Z”自定义格式指定符表示本地操作系统时区的签名偏移，该时区与协调的通用时间（UTC）（以小时为单位测量）。它不会反映实例dateTime.kind属性的值。为了 ...\r\n","\r\n The \"Yield\" keyword.\r\n ":"\r\n “产量”关键字。\r\n \r\n","10,000ths of a second (non-zero)":"10,000秒（非零）\r\n","\r\n A \"When\" clause to filter exceptions before catching.\r\n ":"\r\n 捕获之前要过滤异常的“ n时”子句。\r\n \r\n","\r\n Implementation for a property.\r\n ":"\r\n 财产的实施。\r\n \r\n","\r\n  Looks up a localized string similar to Reference to '{0}' netmodule missing..\r\n":"\r\n  查找类似于“ {0}” NetModule缺失的引用的本地化字符串。\r\n\r\n","\r\n            Last set of data we broadcasted to outer world, or ":"\r\n            我们广播到外世界的最后一组数据，或\r\n","\r\n Gets the semantic information of a for each statement.\r\n ":"\r\n 获取每个语句的语义信息。\r\n \r\n","\r\n The value for the BlockKeyword property.\r\n ":"\r\n BlockKeyWord属性的值。\r\n \r\n","\r\n Returns a copy of this with the ArrayBounds property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而Arraybounds属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n This class handles binding of members of namespaces and types.\r\n The key member is Lookup, which handles looking up a name\r\n in a namespace or type, by name and arity, and produces a \r\n lookup result. \r\n ":"\r\n 此类处理名称空间和类型成员的绑定。\r\n 关键成员是查找，它处理一个名称\r\n 用名称和arity在名称空间或类型中，并产生一个\r\n 查找结果。\r\n \r\n","Nested quantifier {0}":"嵌套量词{0}\r\n","\r\n            The changed solution for this intent result.\r\n            ":"\r\n            此意图结果的改变解决方案。\r\n            \r\n","\r\n  Looks up a localized string similar to 'GoTo {0}' is not valid because '{0}' is inside a 'Try', 'Catch' or 'Finally' statement that does not contain this statement..\r\n":"\r\n  查找类似于'goto {0}'的本地化字符串是无效的，因为'{0}'在“ try”，“ catch”或“最后”语句中，不包含此语句。\r\n\r\n","Regex issue: {0}":"正则发行：{0}\r\n","\r\n  Looks up a localized string similar to 'While' must end with a matching 'End While'..\r\n":"\r\n  查找类似于“ while”必须以匹配的“结尾”结尾的本地化字符串。\r\n\r\n","\r\n Returns a copy of this with the AwaitKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而等待关键字属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","The given expression always matches the provided constant.":"给定的表达式始终匹配提供的常数。\r\n","\r\n Gets a SyntaxReference for this syntax node. SyntaxReferences can be used to regain access to a\r\n syntax node without keeping the entire tree and source text in memory.\r\n ":"\r\n 获取此语法节点的语法rreference。语法重新提取可用于重新获得对\r\n 语法节点无需保留整个树和源文本存储器。\r\n \r\n","Syntax nodes of attributes in order they are specified in source.":"属性的语法节点按顺序为顺序指定。\r\n","The attribute [EnumeratorCancellation] cannot be used on multiple parameters":"属性[enumeratorCancellation]不能在多个参数上使用\r\n","orderby clause":"Orderby子句\r\n","\r\n The value for the ElseStatement property.\r\n ":"\r\n ElStatement属性的值。\r\n \r\n","\r\n            Returns true if the character recently inserted or deleted in the text should trigger completion.\r\n            ":"\r\n            如果字符最近在文本中插入或删除应触发完成，则返回为true。\r\n            \r\n","\r\n Returns a copy of this with the EndOperatorStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回其中的副本，并使用EndoperatorStatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            Sometimes signature changes can cascade from a declaration with m parameters to one with n > m parameters, such as\r\n            delegate Invoke methods (m) and delegate BeginInvoke methods (n = m + 2). This method adds on those extra parameters\r\n            to the base ":"\r\n            有时，签名更改可能会从具有M参数的声明到具有N> M参数的声明，例如\r\n            委托调用方法（M）和委托开始voke方法（n = m + 2）。此方法添加了这些额外的参数\r\n            到基地\r\n","Enables or disables specific pattern matching options for the remainder of a regular expression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:\r\n            \r\n                i\tUse case-insensit ...":"启用或禁用对正则表达式的其余部分的特定模式匹配选项。在问号之后指定了启用的选项，以及在减号之后禁用的选项。允许的选项是：\r\n            \r\n                我用案例暗示...\r\n","\r\n Get a SemanticModel object that is associated with an initializer that did not appear in\r\n this source code. This can be used to get detailed semantic information about sub-parts\r\n of a field initializer, property initializer or default parameter value that did not appear in source code.\r\n ":"\r\n 获取与未出现在\r\n 此源代码。这可以用来获取有关子部分的详细语义信息\r\n 未显示在源代码中的字段初始化器，属性初始器或默认参数值。\r\n \r\n","\r\n Returns a copy of this with the RegionKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而regionKeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","An ImmutableArray containing all the types that are members of this symbol with the given name and arity.\r\n If this symbol has no type members with this name and arity,\r\n returns an empty ImmutableArray. Never returns Nothing.":"一个不可或缺的名称和arity的符号成员的immutablearray。\r\n 如果此符号没有此名称和arity的类型成员，\r\n 返回一个空的Immutablearray。永远不会返回。\r\n","\r\n Forces binding and decoding of attributes.\r\n TODO: We should replace methods GetSourceDecodedWellKnownAttributeData and GetNetModuleDecodedWellKnownAttributeData with\r\n a single method GetDecodedWellKnownAttributeData, which merges DecodedWellKnownAttributeData from source and netmodule attributes.\r\n ":"\r\n 属性结合和解码的力。\r\n TODO：我们应该替换方法getercedecodedwellnonningattribedata和getNetModuledecodedeDwellnoningattribitedata\r\n 单个方法getDecodedwellnoningattribedata，该方法从源和NetModule属性合并了解码器noningattribedata。\r\n \r\n","\r\n Returns a copy of this with the SubNewStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，并将子新闻属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n This class implements the region data flow analysis operations.  Region data flow analysis provides information\r\n how data flows into and out of a region.  The analysis is done lazily. When created, it performs no analysis, but\r\n simply caches the arguments. Then, the first time one of the analysis results is used it computes that one\r\n result and caches it. Each result is computed using a custom algorithm.\r\n ":"\r\n 该类实现区域数据流分析操作。区域数据流分析提供信息\r\n 数据如何流入和退出一个区域。分析懒惰地进行。创建时，它不会执行任何分析，但是\r\n 只是缓存论点。然后，第一次使用分析结果，它计算出一个\r\n 结果并缓存。使用自定义算法计算每个结果。\r\n \r\n","\r\n Given a set of 'Select' methods, infer control variable type. \r\n \r\n Returns inferred type or Nothing.\r\n ":"\r\n 给定一组“选择”方法，推断控制变量类型。\r\n \r\n 返回推断的类型或什么都不是。\r\n \r\n","Assign 'out' parameters (at start)":"分配“ out”参数（在开始时）\r\n","\r\n Returns a copy of this with the ColonEqualsToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中包括Colonequalstoken财产更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","An instance of SemanticModel caches local symbols and semantic information. Thus, it\r\n is much more efficient to use a single instance of SemanticModel when asking multiple\r\n questions about a syntax tree, because information from the first question may be reused.\r\n This also means that holding onto an instance of SemanticModel for a long time may keep a\r\n significant amount of memory from being garbage collected.\r\n ":"语义模型的实例缓存了本地符号和语义信息。因此，它\r\n 在询问多个时，使用smanticmodel的单个实例要高得多\r\n 关于语法树的问题，因为第一个问题的信息可能会重复使用。\r\n 这也意味着长时间持续使用smanticmodel实例\r\n 收集垃圾的大量记忆。\r\n \r\n"," Creates a token with kind IntegerLiteralToken from the text and corresponding 4-byte signed integer value. ":" 从文本和相应的4个字节签名的整数值中创建一个具有诸如integerliteraltoken的令牌。\r\n","init-only setters":"仅初始设置器\r\n","\r\n Conditional symbols map, where each key-value pair indicates:\r\n   Key: Conditional symbol name.\r\n   Value: Stack of all active conditional symbol definitions, i.e. #Const directives, in the source file corresponding to a parsed syntax tree.\r\n          All the defining #Const directives for a conditional symbol are pushed onto this stack in source code order.\r\n          Each stack entry is a tuple {InternalSyntax.CConst, Integer} where:\r\n            InternalSyntax.CConst: Constant value of the symbol.\r\n            Integer: Source position of the defining #Const directive.\r\n ":"\r\n 条件符号映射，其中每个键值对表示：\r\n   钥匙：条件符号名称。\r\n   值：所有活动条件符号定义的堆栈，即#Const指令，在与解析的语法树相对应的源文件中。\r\n          有条件符号的所有定义#CONST指令都按照源代码顺序推入此堆栈。\r\n          每个堆栈条目都是元组{internalSyntax.cconst，integer}其中：\r\n            internalsyntax.cconst：符号的恒定值。\r\n            整数：定义#Const指令的源位置。\r\n \r\n","\r\n Gets already declared and initialized local.\r\n ":"\r\n 已被声明并初始化本地化。\r\n \r\n","punctuation, final quote":"标点符号，最终报价\r\n","\r\n            Returns true if this token is something that looks like a C# keyword. This includes \r\n            actual keywords, contextual keywords, and even 'var' and 'dynamic'\r\n            ":"\r\n            如果这个令牌看起来像c＃关键字，则返回true。这包括\r\n            实际关键字，上下文关键字，甚至“ var”和“动态”\r\n            \r\n","\r\n Parses a FieldInitializer\r\n \r\n FieldInitializer -> (\"key\"? \".\" IdentifierOrKeyword \"=\")? Expression\r\n ":"\r\n 解析野战机构\r\n \r\n fieldInitializer  - >（“键”？“。” dissineFierRekeyword“ =”）？表达\r\n \r\n","\r\n This method is called when this namespace is part of a merged namespace and we are trying to build\r\n a map of extension methods for the whole merged namespace.\r\n ":"\r\n 当此命名空间是合并名称空间的一部分时，我们正在尝试构建此方法\r\n 整个合并名称空间的扩展方法图。\r\n \r\n","Assign 'out' parameters":"分配“输出”参数\r\n"," \r\n If any of the \"Handles\" in the list have synthetic WithEvent override\r\n as a container, then this method will (if not done already) inject \r\n property/accessors symbol into the emit module and assign bodies to the accessors.\r\n ":" \r\n 如果列表中的任何“手柄”具有合成的事件覆盖\r\n 作为容器，此方法将（如果尚未完成）注入\r\n 属性/登录器符号进入EMIT模块，并将物体分配给登录器。\r\n \r\n","\r\n Returns a copy of this with the ClassStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，classStatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","The \"FFFFFF\" custom format specifier represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value. However, trailing zeros or six zero digits aren't displayed.\r\n            \r\n            Although it's ...":"“ FFFFFF”自定义格式指定符表示秒数的六个最重要的数字；也就是说，它代表了日期和时间价值中的百万分之一。但是，未显示尾随的零或六个零数字。\r\n            \r\n            虽然是...\r\n","inline options":"内联选项\r\n","Solution snapshot.":"解决方案快照。\r\n","\r\n An array of assemblies referenced by this assembly, which are linked (/l-ed) by \r\n each compilation that is using this AssemblySymbol as a reference. \r\n If this AssemblySymbol is linked too, it will be in this array too.\r\n The array and its content is provided by ReferenceManager and must not be modified.\r\n ":"\r\n 该组件引用的一系列组件，由（/l-ed）链接\r\n 每次使用此组合符号作为参考的汇编。\r\n 如果此汇编符号也链接在一起，则它也将在此数组中。\r\n 数组及其内容由ReferenceManager提供，不得修改。\r\n \r\n","The syntax node that declares the custom event.":"声明自定义事件的语法节点。\r\n","\r\n The \"Structure\" keyword.\r\n ":"\r\n “结构”关键字。\r\n \r\n","\r\n A map of the PE assembly symbol identities to the identities of the original metadata AssemblyRefs.\r\n This map will be used in emit when serializing AssemblyRef table of the delta. For the delta to be compatible with\r\n the original metadata we need to map the identities of the PE assembly symbols back to the original AssemblyRefs (if different).\r\n In other words, we pretend that the versions of the dependencies haven't changed.\r\n ":"\r\n PE组装符号标识的地图，符合原始元数据汇编的身份。\r\n 当序列化三角洲的汇编表时，该地图将用于发射。为了使三角洲兼容\r\n 原始元数据我们需要将PE组件符号的身份映射回原始的汇编Refs（如果不同）。\r\n 换句话说，我们假装依赖项的版本没有改变。\r\n \r\n","\r\n See comments for BindFromClause method, this method actually does all the work.\r\n ":"\r\n 请参阅bindfromclause方法的注释，此方法实际上完成了所有工作。\r\n \r\n","\r\n            Displays a simple description of the object followed by list of members. Each member is\r\n            displayed on a separate line.\r\n            ":"\r\n            显示对象的简单描述，然后显示成员列表。每个成员都是\r\n            显示在单独的线上。\r\n            \r\n","constant":"持续的\r\n","\r\n Consider methods of any arity (but still consider arity for other types of symbols).\r\n ":"\r\n 考虑任何ARITY的方法（但仍考虑其他类型的符号）。\r\n \r\n","\r\n            Breaks down complex ":"\r\n            分解复合物\r\n"," node, if cursor in the name and it's the \r\n            only namespace declaration in the document.\r\n            (2) a node of type ":" 节点，如果名称中的光标，则是\r\n            文档中只有名称空间声明。\r\n            （2）类型节点\r\n","The syntax node that declares an operator.":"声明运算符的语法节点。\r\n","The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerMemberNameAttribute":"CallerArgumentExpresseprysattribute将无效；它被callermembernameattribute覆盖\r\n","The text that completion is occurring within.":"完成的文本正在内部。\r\n","Change signature...":"更改签名...\r\n","Note that default conversions are considered widening conversions.":"请注意，默认转换被认为正在扩大转化率。\r\n","\r\n The value for the StructureStatement property.\r\n ":"\r\n 结构属性的值。\r\n \r\n","\r\n A region analysis walker that computes whether or not the region completes normally.  It does this by determining \r\n if the point at which the region ends is reachable.\r\n ":"\r\n 一个区域分析步行器计算该区域是否正常完成。它通过确定\r\n 如果该区域结束的点是可以达到的。\r\n \r\n","\r\n The value for the Base property.\r\n ":"\r\n 基本属性的值。\r\n \r\n","\r\n It Is Not suitable to call this method on a ":"\r\n 在A上调用此方法是不合适的\r\n","\r\n Certain syntax node kinds should not be crumbled since\r\n re-using individual child nodes may complicate parsing.\r\n ":"\r\n 某些语法节点种类不应崩溃，因为\r\n 重复使用单个儿童节点可能会使解析复杂。\r\n \r\n","\r\n Returns true and a string from the first GuidAttribute on the type, \r\n the string might be null or an invalid guid representation. False, \r\n if there is no GuidAttribute with string argument.\r\n ":"\r\n 从类型上的第一个指南返回true和一个字符串，\r\n 字符串可能为null或无效的GUID表示。错误的，\r\n 如果没有字符串参数的指南。\r\n \r\n","After the With keyword in a member initializer.":"在会员初始化器中使用关键字之后。\r\n","\r\n The \")\" token.\r\n ":"\r\n “）”令牌。\r\n \r\n","\r\n WARNING: Only use this if the token is obtainable without allocating it (even if cached later). E.g., only\r\n if the node is stored in the constructor of the symbol. In particular, do not call this on the result of a GetSyntax()\r\n call on a SyntaxReference.\r\n ":"\r\n 警告：仅当可以在不分配的情况下获得令牌时使用此功能（即使以后缓存）。例如，仅\r\n 如果节点存储在符号的构造函数中。特别是，请勿根据getsyntax（）的结果称呼此事\r\n 调用语法。\r\n \r\n","\r\n A type name that represents a nullable type, such as \"Integer?\".\r\n ":"\r\n 代表无效类型的类型名称，例如“整数？”。\r\n \r\n","\r\n The value for the Token property.\r\n ":"\r\n 令牌属性的值。\r\n \r\n","\r\n The label. The value of this depends on the Kind. If Kind=Resume, returns\r\n Nothing. If Kind=ResumeNext, wraps the keyword \"Next\", If Kind=ResumeLabel,\r\n wraps an Identifier or IntegerLiteralToken with the label or line number.\r\n ":"\r\n 标签。它的价值取决于这种价值。如果属于=简历，请返回\r\n 没有什么。如果bink = resumenext，请包装关键字“ next”，if bink = resumelabel，\r\n 用标签或行号包装标识符或IntegerLiteralToken。\r\n \r\n","constant interpolated strings":"恒定的插值字符串\r\n","\r\n The value for the Arguments property.\r\n ":"\r\n 参数属性的值。\r\n \r\n","\r\n Returns a copy of this with the TryKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 将其返回此副本，而TryKeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n"," Locals initialization expressions ":" 当地人初始化表达式\r\n","\r\n  Looks up a localized string similar to Method '{0}' must be declared 'Private' in order to implement partial method '{1}'..\r\n":"\r\n  查找类似于方法'{0}'的本地化字符串，必须声明“私有”才能实现部分方法'{1}'..\r\n\r\n","\r\n            True if given project has any diagnostics\r\n            ":"\r\n            如果给定的项目有任何诊断，则为真实\r\n            \r\n","\r\n            Errors to be reported when a project is updated but the corresponding module does not support EnC.\r\n            ":"\r\n            更新项目时要报告的错误，但相应的模块不支持ENC。\r\n            \r\n","Conversion of a stackalloc expression of type '{0}' to type '{1}' is not possible.":"类型为“ {0}”的stackalloc表达式转换为type'{1}'是不可能的。\r\n","\r\n Returns a copy of this with the GroupKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中GroupKeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Owning ":"\r\n 拥有\r\n","\r\n             Tracks the analysis state of syntax trees in a compilation. Each syntax tree has the properties:\r\n             ":"\r\n             在编译中跟踪语法树的分析状态。每个语法树都有属性：\r\n             \r\n","\r\n Returns a copy of this with the AliasKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而Aliaskeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","P1":"P1\r\n"," \r\n Helper for implementing DeclaringSyntaxNodes for derived classes that store SyntaxReferences. \r\n ":" \r\n 用于实现存储语法references类的派生类的声明词法。\r\n \r\n","\r\n The format string.\r\n ":"\r\n 格式字符串。\r\n \r\n","Variable is read-only or a constant.":"变量是仅读取或常数的。\r\n","\r\n            sequence are considered sibling statements, even though they don't appear as immediate siblings in the\r\n            syntax tree. This method walks up the syntax tree to find the ":"\r\n            序列被认为是兄弟姐妹的陈述，即使它们在\r\n            语法树。此方法走上语法树以找到\r\n","\r\n The first available slot for variables\r\n ":"\r\n 变量的第一个可用插槽\r\n \r\n","\r\n  Looks up a localized string similar to Type '{0}' cannot be used as an implementing class..\r\n":"\r\n  查找类似于“ {0}”类型的本地化字符串不能用作实现类。\r\n\r\n"," if type can be assigned to a IEnumerable(Of ":" 如果可以将类型分配给IEnumerable（\r\n","Cancellation token to allow cancelling the operation.":"取消令牌以取消操作。\r\n","All diacritic marks. This includes the Mn, Mc, and Me categories.":"所有变音符号。这包括MN，MC和ME类别。\r\n","Root syntax node":"根语法节点\r\n","\r\n            Returns the set of PEReferences in the solution that are not currently being referenced\r\n            by this project.  The set returned will be tuples containing the PEReference, and the project-id\r\n            for the project we found the pe-reference in.\r\n            ":"\r\n            返回解决方案中当前未被引用的PEReferences集\r\n            通过这个项目。  返回的集合将是包含PEReference和project-id的元组\r\n            对于这个项目,我们找到了pe参考.\r\n            \r\n","\r\n            Root of all quantifier nodes: ```?```, ```*``` etc.\r\n            ":"\r\n            所有量词节点的根源：``````````````*``\r\n            \r\n","Generic definition the result should target.":"通用定义结果应为目标。\r\n","\r\n            Set of documents that we have reported an non-empty set of todo comments for.  Used so that we don't bother\r\n            notifying the host about documents with empty-todo lists (the common case). Note: no locking is needed for\r\n            this set as the incremental analyzer is guaranteed to make all calls sequentially to us.\r\n            ":"\r\n            我们已经报告了一套非空的待办事项评论的文档。使用以使我们不打扰\r\n            通知主机有关使用空-Todo列表的文档（常见情况）。注意：不需要锁定\r\n            该集合作为增量分析仪可以保证将所有调用依次向我们进行。\r\n            \r\n","\r\n  Looks up a localized string similar to Bracketed identifier is missing closing ']'..\r\n":"\r\n  查找类似于包围的标识符类似的本地化字符串正在丢失关闭']。\r\n\r\n","\r\n Parse tokens in the input.\r\n ":"\r\n 在输入中解析令牌。\r\n \r\n","Use explicit type instead of 'var'":"使用显式类型而不是“ var”\r\n","\r\n                 stringList.\r\n                 await Test2();\r\n            ":"\r\n                 stringList。\r\n                 等待test2（）;\r\n            \r\n","updating usages in containing member":"更新包含会员的用法\r\n","True if it is statement terminator":"如果是语句终结者，则为true\r\n","month (1-2 digits)":"月（1-2位数字）\r\n","\r\n Builds a constructor body. \r\n ":"\r\n 建造一个构造函数。\r\n \r\n"," Free resources ":" 免费资源\r\n","Generator '{0}' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'":"生成器'{0}'无法生成源。它不会导致输出，因此可能会出现汇编错误。异常是类型为'{1}'带有消息'{2}'\r\n","\r\n  Looks up a localized string similar to 'Yield' can only be used in a method marked with the 'Iterator' modifier..\r\n":"\r\n  查找类似于“屈服”的本地化字符串只能在标记为“迭代器”修饰符的方法中使用。\r\n\r\n","The individual tagged parts of the description.":"描述的单个标记部分。\r\n","It runs out-of-proc if it's enabled":"如果已启用，它将运行到期\r\n","\r\n When compiling in metadata-only mode, ":"\r\n 在以元数据模式进行编译时，\r\n","\r\n The value for the EndSubOrFunctionStatement property.\r\n ":"\r\n EnduborFunctionStatement属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to Attribute '{0}' cannot be applied to a method with optional parameters..\r\n":"\r\n  查找类似于属性'{0}'的本地化字符串不能应用于具有可选参数的方法。\r\n\r\n","\r\n Returns a copy of this with the Mid property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，其中MID属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n Get all syntax errors associated with this node, or any child nodes, grand-child nodes, etc. The errors\r\n are not in order.\r\n ":"\r\n 获取与此节点或任何子节点，孙子节点等相关的所有语法错误。错误\r\n 没有秩序。\r\n \r\n","\r\n            Base class to represents a case clause (pattern) constructed from various checks\r\n            ":"\r\n            基础类代表根据各种检查构建的案例子句（模式）\r\n            \r\n","\r\n Represents an identifier name followed by a \":=\" token in a named argument.\r\n ":"\r\n 代表标识符名称，后跟一个命名参数中的“：=”令牌。\r\n \r\n","\r\n            A service that is used to determine the appropriate quick info for a position in a document.\r\n            ":"\r\n            用于确定文档中位置的适当快速信息的服务。\r\n            \r\n","\r\n            Analyzer options with workspace.\r\n            These are used to fetch the workspace options by our internal analyzers (e.g. simplification analyzer).\r\n            ":"\r\n            使用工作区的分析仪选项。\r\n            这些用于通过我们的内部分析仪（例如简化分析仪）获取工作空间选项。\r\n            \r\n","\r\n Represents the type parameter list in a declaration.\r\n ":"\r\n 表示声明中的类型参数列表。\r\n \r\n","\r\n Check if it is a regular collection of expressions or there are nested initializers.\r\n ":"\r\n 检查它是定期的表达式集合还是有嵌套的初始化器。\r\n \r\n","\r\n            The rule adds new characters onto the existing set of characters.\r\n            ":"\r\n            该规则将新字符添加到现有字符集中。\r\n            \r\n"," \r\n Map an anonymous type or delegate's method symbol to an implementation method symbol to be used in emit\r\n ":" \r\n 将匿名类型或代表的方法符号映射到要在EMIT中使用的实现方法符号\r\n \r\n","\r\n If this property returns false, it is certain that there are no extension\r\n methods (from language perspective) inside this module. If this property returns true, \r\n it is highly likely (but not certain) that this type contains extension methods. \r\n This property allows the search for extension methods to be narrowed much more quickly.\r\n \r\n !!! Note that this property can mutate during lifetime of the symbol !!!\r\n !!! from True to False, as we learn more about the module.           !!! \r\n ":"\r\n 如果此属性返回false，则可以肯定没有扩展\r\n 该模块内的方法（从语言角度来看）。如果此属性返回true，\r\n 这种类型包含扩展方法很可能（但不确定）。\r\n 此属性允许搜索扩展方法更快地缩小。\r\n \r\n !!!请注意，此属性可以在符号的生命周期中突变！！！\r\n !!!从真实到错误，随着我们了解有关模块的更多信息。 !!!\r\n \r\n","\r\n The optional name and type of the expression range variable. If omitted, the\r\n name of the expression range variable is inferred from the expression.\r\n ":"\r\n 表达范围变量的可选名称和类型。如果省略了\r\n 表达范围变量的名称是从表达式推断出的。\r\n \r\n","\r\n            Helper type to cache information about types while analyzing the compilation.\r\n            ":"\r\n            在分析汇编时，助手类型到缓存有关类型的信息。\r\n            \r\n","\r\n Check type parameters for the containing type or method symbol.\r\n The type parameters are assumed to be the original definitions of type\r\n parameters from the containing type or method, and the TypeSubstitution\r\n instance is used for substituting type parameters within the constraints\r\n of those type parameters, so the substitution should map from type\r\n parameters to type arguments.\r\n ":"\r\n 检查包含类型或方法符号的类型参数。\r\n 假定类型参数是类型的原始定义\r\n 来自包含类型或方法的参数以及类型验证\r\n 实例用于在约束中替换类型参数\r\n 这些类型的参数，因此替换应从类型中映射\r\n 键入参数的参数。\r\n \r\n","Misplaced using directive":"使用指令放错了位置\r\n","\r\n  Looks up a localized string similar to Late bound overload resolution cannot be applied to '{0}' because the accessing instance is an interface type..\r\n":"\r\n  查找类似于后期绑定过载分辨率的本地化字符串不能应用于“ {0}”，因为访问实例是接口类型。\r\n\r\n","\r\n            The name of the variable.\r\n            ":"\r\n            变量的名称。\r\n            \r\n","\r\n The \"Await\" keyword.\r\n ":"\r\n “等待”关键字。\r\n \r\n","\r\n Bind an invocation expression representing an array access,\r\n delegate invocation, or default member.\r\n ":"\r\n 绑定代表数组访问的调用表达式，\r\n 委托调用或默认成员。\r\n \r\n","Braces may be omitted in the cases described for ":"在描述的情况下，大括号可以省略。 \r\n","The address of a variable is used inside the selected code.":"变量的地址在所选代码中使用。\r\n","The symbol does not have an icon.":"该符号没有图标。\r\n","\r\n This instance is used to search for methods that have identical signatures in every regard.\r\n ":"\r\n 此实例用于搜索在各个方面具有相同签名的方法。\r\n \r\n","\r\n The statement that begins the block declaration.\r\n ":"\r\n 开始块声明的声明。\r\n \r\n"," Creates a token with kind IntegerLiteralToken from an 8-byte unsigned integer value. ":" 从8个字节的无符号整数值中创建具有元素的令牌。\r\n","\r\n Given result of binding preceding query operators, the source, bind the following Skip While operator.\r\n \r\n     {Preceding query operators} Skip While {expression}\r\n \r\n Ex: From a In AA Skip While a > 0 ==> AA.SkipWhile(Function(a) a > b)\r\n \r\n ":"\r\n 给定绑定前面的查询操作员的结果，源，在操作员时绑定以下跳过。\r\n \r\n     {先前的查询操作员}跳过{expression}\r\n \r\n 例如：从A中的A跳过A> 0 ==> aa.skipwhile（function（a）a> b）\r\n \r\n \r\n","\r\n Returns a copy of this with the CharsetKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中charsetKeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n If present, an \"= initial-value\" clause describing the initial value of the\r\n variable or the value of the constant.\r\n ":"\r\n 如果存在，则描述了一个“ =初始值”子句\r\n 变量或常数的值。\r\n \r\n","\r\n Returns the default value of this parameter as a ConstantValue.\r\n Return nothing if there isn't a default value.\r\n ":"\r\n 将此参数的默认值返回为constantValue。\r\n 如果没有默认值，则一无所获。\r\n \r\n","\r\n WARN: Retrieves the symbol but does not check its viability (accessibility, etc).\r\n ":"\r\n 警告：检索符号，但没有检查其生存能力（可访问性等）。\r\n \r\n","\r\n            Look for methods like \"SomeType MyType.Get(int)\".  Also matches against the 'getter'\r\n            of an indexer like 'SomeType MyType.this[int]`\r\n            ":"\r\n            查找诸如“ worde opper mytype.get（int）”之类的方法。也与“ Getter”匹配\r\n            像'wory oped mytype一样的索引器。\r\n            \r\n","\r\n  Looks up a localized string similar to '{0}' cannot expose the underlying delegate type '{1}' of the event it is implementing outside the project through {2} '{3}'..\r\n":"\r\n  查找类似于“ {0}”的本地化字符串无法公开事件的基础委托类型'{1}'，它正在通过{2}'{3}'..在项目外实现。\r\n\r\n","1,000ths of a second":"十分之一一秒钟\r\n","\r\n Determine if the token instance represents 'Me', 'MyBase' or 'MyClass' keywords\r\n ":"\r\n 确定令牌实例是否代表“我”，“ mybase”或“ myclass”关键字\r\n \r\n","\r\n Returns the method that defines the user defined conversion, if any. Otherwise returns Nothing.\r\n ":"\r\n 返回定义用户定义转换的方法（如果有）。否则什么都不会返回。\r\n \r\n","An expression tree may not contain a from-end index ('^') expression.":"表达树可能不包含从末端索引（'^'）表达式。\r\n","\r\n  Looks up a localized string similar to Expanded Properties cannot be initialized..\r\n":"\r\n  查找类似于扩展属性的本地化字符串无法初始化。\r\n\r\n","\r\n  Looks up a localized string similar to Cannot copy the value of 'ByRef' parameter '{0}' back to the matching argument because type '{1}' cannot be converted to type '{2}'..\r\n":"\r\n  查找类似于类似的本地化字符串，无法将byref'parameter'{0}'的值复制回匹配参数，因为类型'{1}'不能转换为type'{2}'..\r\n\r\n","\r\n Causes lookups to ignore base classes. Used for binding\r\n Imports statements.\r\n ":"\r\n 导致查找可以忽略基本类。用于绑定\r\n 导入语句。\r\n \r\n","\r\n  Looks up a localized string similar to Label '{0}' is already defined in the current method..\r\n":"\r\n  在当前方法中已经定义了类似于标签'{0}'的局部字符串。\r\n\r\n","The value for platform.":"平台的值。\r\n","Unrecognized grouping construct":"无法识别的分组结构\r\n","The switch expression does not handle all possible values of its input type (it is not exhaustive). For example, the pattern '{0}' is not covered.":"开关表达式无法处理其输入类型的所有可能值（并不详尽）。例如，未涵盖模式'{0}'。\r\n","\r\n  Looks up a localized string similar to 'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to a method that is generic or contained in a generic type..\r\n":"\r\n  查找类似于'system.runtime.interopservices.dllimportattribute'的本地化字符串，不能应用于通用类型中的通用方法或包含的方法。\r\n\r\n","\r\n In VB, if the output file name isn't specified explicitly, then it is derived from the name of the\r\n first input file.\r\n ":"\r\n 在VB中，如果未明确指定输出文件名，则将其从\r\n 第一个输入文件。\r\n \r\n","\r\n String such as 'class', 'interface' etc that can be used in error messages.\r\n ":"\r\n 可以在错误消息中使用的字符串，例如“类”，“接口”等。\r\n \r\n","A conditional expression cannot be used directly in a string interpolation because the ':' ends the interpolation. Parenthesize the conditional expression.":"条件表达式不能直接在字符串插值中使用，因为“：”结束了插值。括号化条件表达式。\r\n","\r\n  Looks up a localized string similar to Variable cannot be initialized with non-array type '{0}'..\r\n":"\r\n  查找类似于变量的本地化字符串无法使用非阵列类型“ {0}”初始化。\r\n\r\n"," isn't assignable to the type of the variable.":" 不能分配给变量的类型。\r\n","symbol, math":"符号，数学\r\n","\r\n            Indicates this ":"\r\n            表示这个\r\n","\r\n         Class Clazz\r\n             ...\r\n     ":"\r\n         班级\r\n             ...\r\n     \r\n"," in case ":" 如果\r\n","\r\n  Looks up a localized string similar to 'Case' cannot follow a 'Case Else' in the same 'Select' statement..\r\n":"\r\n  查找类似于“ case”的本地化字符串在同一'select'语句中都无法遵循“ else否”。\r\n\r\n","\r\n Get the compilation.\r\n ":"\r\n 获取汇编。\r\n \r\n","\r\n This instance is used to check whether one event overrides another, according to the VB definition.\r\n ":"\r\n 根据VB定义，该实例用于检查一个事件是否覆盖另一个事件。\r\n \r\n","\r\n  Looks up a localized string similar to 'End Structure' must be preceded by a matching 'Structure'..\r\n":"\r\n  查找类似于“最终结构”的局部字符串必须在匹配的“结构”之前。\r\n\r\n","\r\n A helper method for ReferenceManager to set AssemblySymbols for assemblies \r\n referenced by this module.\r\n ":"\r\n 引用meanager的辅助方法，以设置组件的汇编符号\r\n 该模块引用。\r\n \r\n","Interpolated string handler method '{0}' has inconsistent return type. Expected to return '{1}'.":"插值字符串处理程序方法'{0}'的返回类型不一致。期望返回'{1}'。\r\n","\r\n Get a ModuleSymbol that refers to the module being created by compiling all of the code. By\r\n getting the GlobalNamespace property of that module, all of the namespace and types defined in source code \r\n can be obtained.\r\n ":"\r\n 获取一个模块符号，该模块是指通过编译所有代码创建的模块。经过\r\n 获取该模块的globalNamespace属性，源代码中定义的所有名称空间和类型\r\n 可以获得。\r\n \r\n","\r\n Get symbol for a Nullable type of particular type, reuse symbols for operand types to avoid type \r\n lookups and construction of new instances of symbols.\r\n ":"\r\n 获取可无效类型的特定类型的符号，用于操作数类型的重复使用符号以避免类型\r\n 查找和构造新符号实例。\r\n \r\n","\r\n Parses the warning option.\r\n ":"\r\n 解析警告选项。\r\n \r\n","Optional parameter list syntax":"可选参数列表语法\r\n","\r\n  Looks up a localized string similar to 'AddressOf' operand must be the name of a method (without parentheses)..\r\n":"\r\n  查找类似于“地址”操作数的本地化字符串必须是方法的名称（无括号）。\r\n\r\n","\r\n Returns a copy of this with the EndModuleStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中endModuleStatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Represents a preprocessing conditional compilation symbol.\r\n ":"\r\n 表示预处理条件汇编符号。\r\n \r\n"," Diagnostics produced while binding the expression ":" 绑定表达时产生的诊断\r\n","\r\n            All semantic changes made in changed documents.\r\n            ":"\r\n            更改文档中的所有语义更改。\r\n            \r\n","\r\n            Gets the semantic model where argument completion is requested.\r\n            ":"\r\n            获取要求完成参数完成的语义模型。\r\n            \r\n",".\r\n            We provide following code fixes:\r\n                1. If the unused value assigned to a local/parameter has no side-effects,\r\n                   we recommend removing the assignment. We consider an expression value to have no side effects\r\n                   if one of the following is true:\r\n                    1. Value is a compile time constant.\r\n                    2. Value is a local or parameter reference.\r\n                    3. Value is a field reference with no or implicit this instance.\r\n                2. Otherwise, if user preference is set to DiscardVariable, and project's\r\n                   language version supports discard variable, we recommend assigning the value to discard.\r\n                3. Otherwise, we recommend assigning the value to a new unused local variable which has no reads.\r\n            ":"。\r\n            我们提供以下代码修复：\r\n                1.如果分配给本地/参数的未使用值没有副作用，\r\n                   我们建议删除作业。我们认为表达值没有副作用\r\n                   如果以下一个是正确的：\r\n                    1.值是编译时间常数。\r\n                    2.值是局部或参数参考。\r\n                    3.值是无或隐含此实例的字段参考。\r\n                2.其他\r\n                   语言版本支持丢弃变量，我们建议将值分配给丢弃。\r\n                3.否则，我们建议将值分配给没有读取的新的未使用的本地变量。\r\n            \r\n","\r\n Populate the map with all extension methods declared within this namespace, so that methods from\r\n the same type are grouped together within each bucket. \r\n ":"\r\n 用在此命名空间中声明的所有扩展方法填充地图，以便从\r\n 相同类型在每个桶中分组在一起。\r\n \r\n","Update suppression format":"更新抑制格式\r\n","\r\n An Assembly object providing metadata for the assembly.\r\n ":"\r\n 为组件提供元数据的组件对象。\r\n \r\n","\r\n            Creates a new version of this script with the specified options.\r\n            ":"\r\n            使用指定选项创建此脚本的新版本。\r\n            \r\n","\r\n The value for the LineStart property.\r\n ":"\r\n Linestart属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to 'Imports' statements must precede any declarations..\r\n":"\r\n  查找类似于“导入”语句的本地化字符串必须先于任何声明。\r\n\r\n","The control variable syntax.":"控制变量语法。\r\n","load":"加载\r\n"," will be the argument and invocatoin the string literal was passed as.\r\n            ":" 将是论点，而Invocatoin字符串字面的传递。\r\n            \r\n","Autoselect disabled due to type declaration.":"由于类型声明而导致禁用自动选择。\r\n","\r\n            CS1624: The body of 'x' cannot be an iterator block because 'y' is not an iterator interface type\r\n            ":"\r\n            CS1624：“ X”的主体不能是迭代器块，因为“ Y”不是迭代器接口类型\r\n            \r\n","\r\n            All the definitions to show.  Note: not all definitions may have references.\r\n            ":"\r\n            所有要显示的定义。注意：并非所有定义都可能具有参考。\r\n            \r\n","\r\n The keyword that was used in the cast operation.\r\n ":"\r\n 铸件操作中使用的关键字。\r\n \r\n","\r\n            The service to locate the positions in which the adornments should appear\r\n            as well as associate the adornments back to the parameter name\r\n            ":"\r\n            定位应该出现装饰的位置的服务\r\n            以及将装饰与参数名称相关联\r\n            \r\n","\r\n  Looks up a localized string similar to 'RaiseEvent' definition missing for event '{0}'..\r\n":"\r\n  查找类似于事件的“ raiseevent”定义类似的本地化字符串'{0}'..\r\n\r\n","\r\n            The title associated with this intent result.\r\n            ":"\r\n            与此意图结果相关的标题。\r\n            \r\n","The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerFilePathAttribute":"CallerArgumentExpresseprysattribute将无效；它被callerfilepathattribute覆盖\r\n","\r\n Given user defined conversion node replace the operand with the coalesce lambda parameter. \r\n \r\n The input bound conversion node must have the following form:\r\n     --> BoundConversion [UserDefined]\r\n         --> [optional] BoundConversion (OutConversion)\r\n             --> BoundCall [shared method, no receiver, one argument]\r\n \r\n The OUTPUT bound conversion node will have the following form:\r\n     --> BoundConversion *updated*\r\n         --> [optional] BoundConversion *updated*\r\n             --> BoundCall [shared method, no receiver, * updated argument *]\r\n                 --> [optional] BoundConversion (parameter from nullable to value)\r\n                     --> *parameter*\r\n \r\n ":"\r\n 给定用户定义的转换节点用coceSce lambda参数替换操作数。\r\n \r\n 输入绑定的转换节点必须具有以下形式：\r\n      - > boundConversion [用户定义]\r\n          - > [可选] boundConversion（张开）\r\n              - > boundcall [共享方法，无接收器，一个参数]\r\n \r\n 输出绑定转换节点将具有以下形式：\r\n      - > boundConversion *更新 *\r\n          - > [可选] boundConversion *更新 *\r\n              - > boundcall [共享方法，无接收器， *更新的参数 *]\r\n                  - > [可选] boundConversion（从无效到值的参数）\r\n                      - > *参数 *\r\n \r\n \r\n","\r\n Checks if there is a name match with any type parameter.\r\n ":"\r\n 检查是否有任何类型参数的名称匹配。\r\n \r\n","\r\n The statement that begins the type or module.\r\n ":"\r\n 开始类型或模块的语句。\r\n \r\n","\r\n            Operations performed by CodeAction.\r\n            ":"\r\n            通过编码执行的操作。\r\n            \r\n"," based on the criteria listed for \r\n            ":" 根据列出的标准\r\n            \r\n","\r\n            Asynchronous foreach statement cannot operate on variables of type 'X' because 'X' does not contain a suitable public instance or extension definition for 'GetAsyncEnumerator'\r\n            ":"\r\n            异步语句无法在类型的“ x”类型上操作，因为'x'不包含适合“ getAsyncenumerator”的合适的公共实例或扩展定义\r\n            \r\n","+ additional {0} errors":"+附加{0}错误\r\n"," if all extended nodes have been processed.\r\n            ":" 如果所有扩展的节点都已处理。\r\n            \r\n","\r\n A collection of return, exit sub, exit function, exit operator and exit property statements found within the region that return to the enclosing method.\r\n ":"\r\n 返回，退出子，退出功能，退出操作员和退出属性语句的集合，在返回封闭方法的区域内发现。\r\n \r\n","\r\n Decode a parameter list into a list of parameter symbols.\r\n ":"\r\n 将参数列表解码为参数符号列表。\r\n \r\n","\r\n Given an event statement syntax get the corresponding event symbol.\r\n ":"\r\n 给定事件语句语法获取相应的事件符号。\r\n \r\n","\r\n Checks if ":"\r\n 检查是否\r\n","The \"Y\" or \"y\" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.YearMonthPattern property of a specified culture. For example, the custom format string for the invariant culture is \"yyyy MM ...":"“ y”或“ y”标准格式指定符表示由dateTimeFormatinfo.yearmonthpattern属性定义的自定义日期和时间格式字符串。例如，不变文化的自定义格式字符串是“ yyyy mm ...\r\n","\r\n            checks if there is a single top level type declaration in a document\r\n            ":"\r\n            检查文档中是否有单个顶级类型声明\r\n            \r\n","Unwrap argument list":"UNABRAP参数列表\r\n","\r\n The Compilation object is an immutable representation of a single invocation of the\r\n compiler. Although immutable, a Compilation is also on-demand, in that a compilation can be\r\n created quickly, but will that compiler parts or all of the code in order to respond to\r\n method or properties. Also, a compilation can produce a new compilation with a small change\r\n from the current compilation. This is, in many cases, more efficient than creating a new\r\n compilation from scratch, as the new compilation can share information from the old\r\n compilation.\r\n ":"\r\n 汇编对象是单个调用的不变表示\r\n 编译器。尽管不可变，但也是按需进行的，但可以进行汇编\r\n 很快就创建了，但是该编译器零件或所有代码都会响应\r\n 方法或属性。此外，汇编可以产生一个新的汇编，并进行较小的更改\r\n 从当前汇编。在许多情况下，这比创建新的更有效\r\n 从头开始汇编，因为新汇编可以共享旧的信息\r\n 汇编。\r\n \r\n","\r\n Return true if the class type has a public parameterless constructor.\r\n ":"\r\n 如果类类型具有公共参数构造函数，则返回true。\r\n \r\n","\r\n This is an entry point for the Binder. Its purpose is to add names of viable extension methods declared \r\n in this (compilation merged or module level) namespace to nameSet parameter.\r\n ":"\r\n 这是粘合剂的入口点。其目的是添加声明的可行扩展方法的名称\r\n 在此（汇编合并或模块级别）命名空间到名称参数。\r\n \r\n","\r\n Look for a type forwarder for the given type in the containing assembly and any referenced assemblies.\r\n If one is found, search again in the target assembly.  Return the last assembly in the chain.\r\n ":"\r\n 在包含的组件和任何引用的组件中寻找给定类型的类型转发器。\r\n 如果找到一个，请在目标组件中再次搜索。返回链中的最后一个组件。\r\n \r\n","\r\n            Invalid tag helper bound property '{1}' on tag helper '{0}'. '{2}.{3}' must not be null if property has no public setter and its type implements '{4}'.\r\n            ":"\r\n            标签助手'{0}'上的无效标记助手绑定属性'{1}'。 '{2}。{3}'如果属性没有公共设置且其类型实现'{4}'，则不得为null。\r\n            \r\n","All initializers.":"所有初始化器。\r\n","\r\n  Looks up a localized string similar to Arrays cannot be declared with 'New'..\r\n":"\r\n  查找类似于数组的本地化字符串，无法用“新”声明。\r\n\r\n","The primary constructor conflicts with the synthesized copy constructor.":"主要的构造函数与合成的复制构造函数冲突。\r\n","\r\n current page we are reading.\r\n ":"\r\n 当前页面我们正在阅读。\r\n \r\n","\r\n When VB Dev10 detects circularity it reports the error only once for each cycle. Thus, if the cycle \r\n is {S1 --> S2 --> S3 --> S1}, only one error will be reported, which one of S1/S2/S3 will have error\r\n is non-deterministic (depends on the order of symbols in a hash table).\r\n \r\n Moreover, Dev10 analyzes the type graph and reports only one error in case S1 --> S2 --> S1 even if \r\n there are two fields referencing S2 from S1.\r\n \r\n Example:\r\n    Structure S2\r\n      Dim s1 As S1\r\n    End Structure\r\n \r\n    Structure S3\r\n      Dim s1 As S1\r\n    End Structure\r\n \r\n    Structure S1\r\n      Dim s2 As S2  ' ERROR\r\n      Dim s2_ As S2 ' NO ERROR \r\n      Dim s3 As S3  ' ERROR\r\n    End Structure\r\n \r\n Dev10 also reports only one error for all the cycles starting with the same field, which one is reported \r\n depends on the declaration order. Current implementation reports all of the cycles for consistency. \r\n See testcases MultiplyCyclesInStructure03 and MultiplyCyclesInStructure04 (report different errors in Dev10).\r\n ":"\r\n 当VB Dev10检测到圆形时，它仅报告每个周期一次误差。因此，如果周期\r\n IS {S1-> S2-> S3-> S1}，仅报告一个错误，S1/S2/S3中的一个将有错误\r\n 是非确定性的（取决于哈希表中符号的顺序）。\r\n \r\n 此外，dev10分析类型图，并仅报告一个错误\r\n 有两个字段引用S1。\r\n \r\n 例子：\r\n    结构S2\r\n      DIM S1 AS S1\r\n    末端结构\r\n \r\n    结构S3\r\n      DIM S1 AS S1\r\n    末端结构\r\n \r\n    结构S1\r\n      DIM S2作为S2'错误\r\n      DIM S2_ AS S2'无错误\r\n      DIM S3作为S3'错误\r\n    末端结构\r\n \r\n DEV10还仅报告一个从同一字段开始的所有周期的错误\r\n 取决于声明令。当前的实施报告所有循环以保持一致性。\r\n 请参阅Testcases MultiplyCyclesinstructure03和MultiplyCyclesinstructure04（报告DEV10中的不同错误）。\r\n \r\n","\r\n ExpressionSyntax node representing the access expression to be executed when\r\n the object is not null.\"\r\n ":"\r\n 表达式nntax节点表示要执行的访问表达式\r\n 该对象不是零。”\r\n \r\n","\r\n            Analyzer that finds code of the form:\r\n            ":"\r\n            查找表格代码的分析仪：\r\n            \r\n","\r\n An empty read-only array.\r\n ":"\r\n 一个空的只读数组。\r\n \r\n","\r\n  Looks up a localized string similar to 'Shared' cannot be combined with '{0}' on a method declaration..\r\n":"\r\n  在方法声明上查找类似于“共享”的本地化字符串与“ {0}”不能结合。\r\n\r\n","\r\n Checks if the expression is a constant and that constant is True\r\n ":"\r\n 检查表达是否是常数，并且该常数为真\r\n \r\n","\r\n The list of OrderExpression's to sort by.\r\n ":"\r\n 要排序的Orderexpression列表。\r\n \r\n","\r\n indirect assignment is assignment to a value referenced indirectly\r\n it may only happen if lhs is a reference (must be a parameter or a local)\r\n       1) lhs is a reference (must be a parameter or a local)\r\n       2) it is not a ref/out assignment where the reference itself would be assigned\r\n ":"\r\n 间接分配分配给间接引用的值\r\n 它只有在LHS为参考时才发生（必须是参数或本地）\r\n       1）LHS是参考（必须是参数或本地）\r\n       2）这不是参考本身分配的参考/输出分配\r\n \r\n","\r\n The \"Call\" keyword.\r\n ":"\r\n “呼叫”关键字。\r\n \r\n","\r\n For extension methods, the type of the fist parameter in method's definition (i.e. before type parameters are substituted).\r\n Otherwise, same as the ReceiverType.\r\n ":"\r\n 对于扩展方法，方法定义中的拳头参数的类型（即替换类型参数之前）。\r\n 否则，与收到类型相同。\r\n \r\n","\r\n The value for the InheritsKeyword property.\r\n ":"\r\n sharthitskeyword属性的值。\r\n \r\n","\r\n An array of cached Cor types defined in this assembly.\r\n Lazily filled by GetDeclaredSpecialType method.\r\n ":"\r\n 该组件中定义的一组缓存的COR类型。\r\n 用getDeclaredSpecialType方法懒洋洋地填充。\r\n \r\n",",\r\n            if ":"，，，，\r\n            如果\r\n","is pattern":"是模式\r\n","\r\n The \"S\" literal suffix denoting \"Short\"\r\n ":"\r\n “ s”字面后缀表示“ short”\r\n \r\n"," for the underlying \r\n metadata as soon as the are needed. \r\n \r\n The New compilation uses whatever metadata is currently being provided by the ":" 对于基础\r\n 元数据一旦需要。\r\n \r\n 新汇编使用当前正在提供的任何元数据\r\n","\r\n If analysis is being performed in a context of a method returns method's parameters, \r\n otherwise returns an empty array\r\n ":"\r\n 如果在方法返回方法的参数的上下文中进行分析，\r\n 否则返回一个空数组\r\n \r\n","\r\n  Looks up a localized string similar to Implementing class '{0}' for interface '{1}' cannot be found..\r\n":"\r\n  查找类似于实现class'{0}'interface'{1}'的本地化字符串。\r\n\r\n","\r\n  Looks up a localized string similar to Parameter specifier is duplicated..\r\n":"\r\n  查找类似于参数规范的本地化字符串已重复。\r\n\r\n","\r\n Optimization: in many cases, the parameter count (fast) is sufficient and we\r\n don't need the actual parameter symbols (slow).\r\n ":"优化：在许多情况下，参数计数（快速）就足够了，我们\r\n 不需要实际的参数符号（慢）。\r\n \r\n","Take bottom":"底部\r\n","\r\n            Renames the target type\r\n            ":"\r\n            重命名目标类型\r\n            \r\n","\r\n Groups the information computed by MakeOverriddenMembers.\r\n ":"\r\n 将MachoverRiddenMembers计算的信息分组。\r\n \r\n","\r\n Returns a copy of this with the Equals property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 将其返回其副本，而Equals属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n The statements contained in the case block. This might be an empty list.\r\n ":"\r\n 案例块中包含的陈述。这可能是一个空列表。\r\n \r\n","\r\n The ":"\r\n 这\r\n","Build enforcement recommendation for this analyzer":"为此分析仪建立执法建议\r\n"," to show nothing.\r\n            ":" 什么都没有。\r\n            \r\n","\r\n            For metadata symbols we encode information in the ":"\r\n            对于元数据符号，我们在\r\n","\r\n Represents an Date literal token.\r\n ":"\r\n 代表日期文字令牌。\r\n \r\n","\r\n  Looks up a localized string similar to Method '{0}' cannot handle event '{1}' because they do not have a compatible signature..\r\n":"\r\n  查找类似于方法'{0}'无法处理事件'{1}'的本地化字符串，因为它们没有兼容的签名。\r\n\r\n","The bound collection expression.":"绑定的集合表达式。\r\n","After an open embedded expression (<%=) or before the close of an embedded expression (%>) within an XML literal.":"在XML文字中嵌入的表达式（％>）结束之前，在开放的嵌入式表达式（<％=）之后。\r\n","\r\n            Represents a type-pattern, constructed from is-expression\r\n            ":"\r\n            代表由IS-Expression构建的类型模式\r\n            \r\n","\r\n Returns true if this is the original definition of this symbol.\r\n ":"如果这是此符号的原始定义，则返回true。\r\n \r\n",".  Then if we hit any members that explicitly have *oblivious* types, but no annotated or\r\n            non-annotated types, then we switch to ":"。然后，如果我们击中任何明确具有 *忽略 *类型的成员，但没有注释或\r\n            非注销类型，然后我们切换到\r\n","\r\n This function must return a BoundConversion node in case of non-identity conversion.\r\n ":"\r\n 在非身份转换的情况下，此功能必须返回boundconversion节点。\r\n \r\n","base-group":"基团\r\n","\r\n Adds a sequence point with the specified span before stepping on the statement.\r\n ":"\r\n 在踏上语句之前，在指定的跨度上添加一个序列点。\r\n \r\n"," from untagged text.\r\n            ":" 来自未标记的文字。\r\n            \r\n","\r\n Always prefer IsFromCompilation.\r\n ":"\r\n 始终更喜欢ISFROMCOMPILATION。\r\n \r\n","\r\n An elastic trivia with kind EndOfLineTrivia containing both the carriage return And line feed characters.\r\n Elastic trivia are used to denote trivia that was Not produced by parsing source text, And are usually Not\r\n preserved during formatting.\r\n ":"\r\n 带有载体的弹性琐事，既包含托架返回和线饲料字符。\r\n 弹性琐事用于表示不是通过解析源文本产生的琐事，通常不是\r\n 在格式期间保存。\r\n \r\n","\r\n            Handles information about updating the document with the refactoring.\r\n            ":"\r\n            处理有关使用重构更新文档的信息。\r\n            \r\n"," is currently\r\n            enabled, then '#...' comments are allowed.  Otherwise, only '(?#...)' comments\r\n            are allowed.":" 目前\r\n            启用，然后允许“＃...”注释。否则，只有'（？＃...）'评论\r\n            被允许。\r\n","The parameter of a unary operator must be the containing type, or its type parameter constrained to it.":"单一操作员的参数必须是包含类型，或者其类型的参数约束。\r\n","\r\n Metadata types need to compute their base types in order to know their TypeKinds, And that can lead\r\n to cycles if base types are already being computed.\r\n ":"\r\n 元数据类型需要计算其基本类型才能知道他们的类型，这可以领导\r\n 如果已经计算了基本类型，请循环。\r\n \r\n","The index of the current item in the list.":"列表中当前项目的索引。\r\n"," is true for this tree prior to invoking this method.\r\n ":" 在调用此方法之前，该树是正确的。\r\n \r\n","\r\n            A delegate that will run a script when invoked.\r\n            ":"\r\n            调用时将运行脚本的委托。\r\n            \r\n","\r\n Find the slot that contains the given offset.\r\n ":"\r\n 找到包含给定偏移的插槽。\r\n \r\n","\r\n Identifies the special instance \"MyBase\"\r\n ":"\r\n 标识特殊实例“ mybase”\r\n \r\n","\r\n Returns the marshalling type of this field, or 0 if marshalling information isn't available.\r\n ":"\r\n 返回此字段的编组类型，或者如果没有编组信息，则返回0。\r\n \r\n","\r\n The \".\" token that separates the names.\r\n ":"\r\n 这 ”。”将名称分开的令牌。\r\n \r\n","\r\n The underlying TypeParameterSymbol, cannot be another RetargetingTypeParameterSymbol.\r\n ":"\r\n 基础的TypeParameterSymbol不能是另一个RetargetingTypeParameterSymbol。\r\n \r\n","The \"D\" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.LongDatePattern property. For example, the custom format string for the invariant culture is \"dddd, dd MMMM yyyy\".":"“ D”标准格式指定符表示由当前DateTimeFormatinfo.longdatePattern属性定义的自定义日期和时间格式字符串。例如，不变文化的自定义格式字符串是“ DDDD，DD MMMM Yyyy”。\r\n","Non-invoked method cannot be replaced with property.":"无法用属性代替非掠夺的方法。\r\n","\r\n            Annotation to mark the namespace encapsulating the type that has been moved\r\n            ":"\r\n            注释以标记封装已移动类型的名称空间\r\n            \r\n"," are sorted by their start position.\r\n            ":" 通过他们的开始位置进行排序。\r\n            \r\n","\r\n In case the passed initializers require a shared constructor, this method returns a new MethodSymbol instance for the \r\n shared constructor if there is not already an explicit shared constructor\r\n ":"\r\n 如果传递的初始化器需要共享构造函数，则此方法将返回一个新的方法符号实例\r\n 共享构造函数，如果尚未有明确的共享构造函数\r\n \r\n"," if we were able to add the cached diagnostics and we do not need to compute them fresh.\r\n            ":" 如果我们能够添加缓存的诊断，并且不需要对它们进行新鲜的计算。\r\n            \r\n","\r\n Returns a copy of this with the VarianceKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，而VrianceKeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","minute (2 digits)":"分钟（2位数字）\r\n","Cannot convert &method group '{0}' to delegate type '{0}'.":"无法将＆方法组'{0}'转换为委托类型'{0}'。\r\n","\r\n If parameter (or variable in the EE) is lifted, initialize its proxy.\r\n ":"\r\n 如果抬起参数（或EE中的变量），请初始化其代理。\r\n \r\n","\r\n            Analyzes the containing ":"\r\n            分析包含\r\n"," that appears selected in the list presented to the user during suggestion mode.":" 在建议模式下，在列表中选择了这一点。\r\n","A boolean value set to True if name is valid identifier.":"如果名称为有效标识符，则将布尔值设置为true。\r\n","\r\n            An optional prefix to be displayed prepended to ":"\r\n            可选的前缀要显示为\r\n","\r\n Returns a copy of this with the Signature property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此的副本，签名属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n The value for the CharsetKeyword property.\r\n ":"\r\n CharSetKeyword属性的值。\r\n \r\n","number, other":"数字，其他\r\n","\r\n            Indicates if the given expression statement operation has an explicit \"Call\" statement syntax indicating explicit discard.\r\n            For example, VB \"Call\" statement.\r\n            ":"\r\n            指示给定的表达式语句操作是否具有明确的“呼叫”语句语法，指示明确丢弃。\r\n            例如，VB“呼叫”语句。\r\n            \r\n","Null check can be simplified":"无效检查可以简化\r\n","\r\n            Represents a relational-pattern constructed from comparison operators\r\n            ":"\r\n            代表由比较操作员构建的关系模式\r\n            \r\n","\r\n Determines if position is within the span of a node, or in the trailing trivia of a node \r\n up to, but not including, a newline or colon trivia (which mark the end of a statement.)\r\n ":"\r\n 确定位置是在节点的跨度内还是在节点的尾随琐事中\r\n 到但不包括新线或结肠琐事（标志着陈述的结尾。）\r\n \r\n","\r\n            whose declared local is no longer used removed.\r\n            ":"\r\n            其声明为本地的不再使用。\r\n            \r\n","\r\n Parse TypeOf ... Is ... or TypeOf ... IsNot ...\r\n TypeOfExpression -> \"TypeOf\" Expression \"Is|IsNot\" LineTerminator? TypeName\r\n ":"\r\n parse typeof ...是...或类型...不...\r\n typeofexpression->“ typeof“ expression”是| isnot“ lineterminator？打字\r\n \r\n"," is accessible from within type ":" 可以从类型中访问\r\n"," the enumerator is or inherits from or implements IDisposable.":" 枚举者是或从idisposable中继承或实现。\r\n","The syntax node for report errors.":"报告错误的语法节点。\r\n","\r\n            Gets all the diagnostics for this event, regardless if this is for pull or push diagnostics.  Most clients\r\n            should not use this.  The only clients that should are ones that are aggregating the values transparently\r\n            and then forwarding on later on to other clients that will make this decision.\r\n            ":"\r\n            无论是用于拉动还是推诊断，都可以获取此事件的所有诊断。大多数客户\r\n            不应该使用此。唯一应该是透明值汇总值的客户\r\n            然后稍后转发给其他将做出此决定的客户。\r\n            \r\n","\r\n            Returns all of the trivia to the left of this token up to the previous token (concatenates\r\n            the previous token's trailing trivia and this token's leading trivia).\r\n            ":"\r\n            将所有琐事返回到这个令牌的左侧，直到前面的令牌（连接\r\n            前代币的尾随琐事和这个代币的领先琐事）。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Finally' can only appear once in a 'Try' statement..\r\n":"\r\n  查找类似于“最后”的本地化字符串只能出现在“尝试”语句中。\r\n\r\n","Generator failed to initialize.":"发电机无法初始化。\r\n","\r\n  Looks up a localized string similar to Single-line lambdas cannot have the 'Iterator' modifier. Use a multiline lambda instead..\r\n":"\r\n  查找类似于单线兰巴斯的本地化字符串，不能具有“迭代器”修饰符。改用多行lambda。\r\n\r\n"," has been added to the queue.\r\n ":" 已添加到队列中。\r\n \r\n","\r\n A map of types immediately contained within this type \r\n grouped by their name (case-insensitively).\r\n ":"\r\n 此类型中立即包含的类型地图\r\n 按其名称分组（casemonsitationally）。\r\n \r\n","\r\n Target architecture of the machine.\r\n ":"\r\n 机器的目标架构。\r\n \r\n","\r\n The expression whose value is being output.\r\n ":"\r\n 其价值正在输出的表达式。\r\n \r\n","\r\n This class walks all the statements in some syntax, in order, except those statements that are contained\r\n inside expressions (a statement can occur inside an expression if it is inside\r\n a lambda.)\r\n \r\n This is used when collecting the declarations and declaration spaces of a method body.\r\n \r\n Typically the client overrides this class and overrides various Visit methods, being sure to always\r\n delegate back to the base.\r\n ":"\r\n 此课程以某种语法的顺序走动所有语句，除了包含的那些语句\r\n 内部表达式（如果在表达式内部，则可能发生语句\r\n 兰伯达。）\r\n \r\n 当收集方法主体的声明和声明空间时，使用此方法。\r\n \r\n 通常，客户覆盖此类并覆盖各种访问方法，请务必始终\r\n 委派回到基地。\r\n \r\n","\r\n The CommandLineArguments class provides members to Set and Get Visual Basic compilation and parse options.\r\n ":"\r\n CommandLinearguments类提供成员来设置和获取视觉基本汇编和解析选项。\r\n \r\n","\r\n Gets the System.Type type symbol from targetSymbol's containing assembly.\r\n ":"\r\n 获取系统。从targetSymbol的包含程序集键入类型符号。\r\n \r\n","\r\n The first statement to be included in the analysis.\r\n ":"\r\n 分析中包含的第一个陈述。\r\n \r\n","\r\n Given a variable declaration, get the corresponding  symbol.\r\n ":"\r\n 给定可变声明，获取相应的符号。\r\n \r\n","Method '{0}' specifies a 'class' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a reference type.":"方法'{0}'指定类型参数'{1}'的'类'约束，但是相应的类型参数'{2}'被覆盖或显式实现的方法'{3}不是参考类型。\r\n","\r\n Represents the beginning statement of an Enum declaration. This node always\r\n appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.\r\n ":"\r\n 代表枚举声明的起点。这个节点总是\r\n 以kint = enumdeclarationBlock的枚举开始。\r\n \r\n","into extracted method to invoke at call sites":"进入提取的方法以在呼叫站点调用\r\n","Use recursive patterns":"使用递归图案\r\n","The whitespace to indent with":"空间缩进\r\n","\r\n Returns True if the embedded symbol is known to be referenced in the current compilation.\r\n ":"\r\n 如果已知在当前汇编中引用嵌入式符号，则返回为true。\r\n \r\n","Indexing can be simplified":"可以简化索引\r\n","\r\n The value for the ExternalSource property.\r\n ":"\r\n 外部属性的价值。\r\n \r\n","\r\n  Looks up a localized string similar to Each linked resource and module must have a unique filename. Filename '{0}' is specified more than once in this assembly..\r\n":"\r\n  查找类似于每个链接资源的本地化字符串，模块必须具有唯一的文件名。在此汇编中，多次指定了一次文件名'{0}'。\r\n\r\n","\r\n  Looks up a localized string similar to Lambda expression cannot be converted to '{0}' because '{0}' is not a delegate type..\r\n":"\r\n  查找类似于lambda表达式的本地化字符串不能转换为'{0}'，因为'{0}'不是委托类型。\r\n\r\n","Apply 'this.' qualification preferences":"应用“这个”。资格偏好\r\n","\r\n Represents a qualified type name, for example X.Y or X(Of Z).Y.\r\n ":"\r\n 代表合格的类型名称，例如X.Y或X（Z的X）。\r\n \r\n","1,000,000ths of a second":"1,000,000秒\r\n","\r\n Create a NamespaceExtent that represents a given Compilation.\r\n ":"\r\n 创建一个代表给定汇编的命名续文。\r\n \r\n","The enclosing binder within \"memberBinder\" for the given position.":"给定位置的“成员迎合器”中的封闭粘合剂。\r\n","\r\n  Looks up a localized string similar to 'Optional' cannot be applied to the first parameter of an extension method. The first parameter specifies which type to extend..\r\n":"\r\n  查找类似于“可选”的本地化字符串不能应用于扩展方法的第一个参数。第一个参数指定要扩展的类型。\r\n\r\n","\r\n The set of local variables and parameters that were hoisted and need a proxy.\r\n ":"\r\n 悬挂并需要代理的局部变量和参数集。\r\n \r\n"," Holds information needed by With block to properly bind \r\n references to With block expression, placeholder, etc... ":"持有块所需的信息以正确绑定\r\n 用块表达，占位符等提及...\r\n","\r\n Is this zero-based one-dimensional array, i.e. SZArray in CLR terms.\r\n ":"\r\n 这是基于零的一维数组，即用CLR术语进行szarray。\r\n \r\n","\r\n Returns True if this conversion is a widening numeric conversion or a narrowing numeric conversion, as defined in\r\n section 8.3.\r\n ":"\r\n 如果此转换是扩大的数字转换或变窄的数字转换，则返回true\r\n 第8.3节。\r\n \r\n","\r\n            Note: This is the new version of the language service and superceded the same named type\r\n            in the EditorFeatures layer.\r\n            ":"\r\n            注意：这是语言服务的新版本，并将相同的命名类型取代\r\n            在编辑层中。\r\n            \r\n","name1":"name1\r\n","\r\n Get a SemanticModel object that is associated with an executable statement that did not appear in\r\n this source code. This can be used to get detailed semantic information about sub-parts\r\n of a statement that did not appear in source code. \r\n ":"\r\n 获取与未出现在\r\n 此源代码。这可以用来获取有关子部分的详细语义信息\r\n 源代码中未出现的语句。\r\n \r\n","\r\n Represents a \"With\" statement. This statement always occurs as the\r\n BeginStatement of a WithBlock, and the body of the With is the Body of that\r\n WithBlock.\r\n ":"\r\n 代表一个“带”语句。这个陈述始终是\r\n block的开始，带有的身体是那个的身体\r\n 用block。\r\n \r\n","\r\n            Creating a new type definition.\r\n            ":"\r\n            创建一个新的类型定义。\r\n            \r\n","\r\n The value for the ImportsClauses property.\r\n ":"\r\n ImportSClauses属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to The 'Main' method cannot be marked 'Async'..\r\n":"\r\n  查找类似于“主”方法的局部字符串，无法标记为“异步”。\r\n\r\n","\r\n Get this accessibility that was declared on this symbol. For symbols that do\r\n not have accessibility declared on them, returns NotApplicable.\r\n ":"\r\n 获取此符号上声明的可访问性。对于符号\r\n 没有访问权限，而是返回无关紧要的。\r\n \r\n","unicode category":"Unicode类别\r\n"," representing the specific kind of\r\n WhileOrUntilClauseSyntax. One of WhileClause, UntilClause.\r\n ":" 代表特定种类\r\n wheroruntilclausesyntax。其中之一是，直到序列为止。\r\n \r\n","Using directives must be placed inside of a namespace declaration":"使用指令必须放置在命名空间声明的内部\r\n","Generate constructor in '{0}'":"在'{0}'中生成构造函数\r\n",".\r\n            Any resolution errors are reported at that point through ":"。\r\n            当时有任何分辨率错误\r\n","\r\n VB lambda bodies may be non-contiguous sequences of nodes whose ancestor (parent or grandparent) is a lambda node.\r\n Whenever we need to check whether a node is a lambda body node we should use this method.\r\n ":"\r\n VB lambda主体可能是节点的不连续序列，其祖先（父母或祖父母）是lambda节点。\r\n 每当我们需要检查节点是lambda身体节点时，我们都应该使用此方法。\r\n \r\n","\r\n            Provides an argument provider that always appears before any built-in argument provider. This argument\r\n            provider does not provide any argument values.\r\n            ":"\r\n            提供了一个参数提供商，总是出现在任何内置参数提供商面前。这个论点\r\n            提供者不提供任何参数值。\r\n            \r\n","Add to '{0}'":"添加到'{0}'\r\n","\r\n Variable slots are allocated to local variables sequentially and never reused.  This is\r\n the index of the next slot number to use.\r\n ":"\r\n 可变插槽依次分配给局部变量，并且永远不会重复使用。这是\r\n 要使用的下一个插槽号的索引。\r\n \r\n","\r\n State tracked for the root XmlElement while binding nodes within the\r\n tree. This state is mutable since it includes the set of namespaces from\r\n Imports referenced within the tree. Ideally, this state would be part of the\r\n XmlRootElementBinder, but since this state is mutable, there would be\r\n issues caching and reusing the Binder. Instead, the state is passed\r\n explicitly as an argument to each binding method.\r\n ":"\r\n 在绑定在bong xmlelement的状态下绑定节点的状态\r\n 树。该状态是可变的，因为它包括来自\r\n 树内引用的导入。理想情况下，这种状态将是\r\n xmlrootelementbinder，但由于这种状态是可变的，所以会有\r\n 问题缓存和重复使用活页夹。相反，国家通过\r\n 明确作为每个绑定方法的参数。\r\n \r\n","period/era":"时期/时代\r\n","\r\n            String describing the PDB to be used in user facing error messages (e.g. file path).\r\n            ":"\r\n            字符串描述用于面向错误消息的用户（例如文件路径）的PDB。\r\n            \r\n","\r\n Returns true when field is a backing field for a captured frame pointer (typically \"Me\").\r\n ":"\r\n 当字段是捕获的帧指针（通常是“我”）的后备字段时，返回true。\r\n \r\n","\r\n            among variables that will be used as parameters at the extracted method, check whether one of the parameter can be used as return\r\n            ":"\r\n            在将用作提取方法的参数的变量中，检查是否可以用作返回的参数\r\n            \r\n","\r\n            Given a document and a type contained in it, moves the type\r\n            out to its own document. The new document's name typically\r\n            is the type name, or is at least based on the type name.\r\n            ":"\r\n            给定一个文档和其中包含的类型，移动类型\r\n            到自己的文件。新文档的名称通常\r\n            是类型名称，或至少基于类型名称。\r\n            \r\n"," but may be different in certain circumstances.\r\n            ":" 但是在某些情况下可能有所不同。\r\n            \r\n"," Intersect and unsplit state ":" 相交和未平面状态\r\n","\r\n An abstract node class that is the parent of classes that describe type\r\n parameter constraints.\r\n ":"\r\n 一个抽象节点类，是描述类型的类的父母\r\n 参数约束。\r\n \r\n","universal sortable date/time":"通用分类日期/时间\r\n","record structs":"记录结构\r\n","\r\n The range from which we cannot reuse nodes.\r\n ":"\r\n 我们无法重复使用节点的范围。\r\n \r\n","\r\n Indicate which attributes might be present. Could be extended to other attributes \r\n if desired.\r\n ":"\r\n 指示可能存在哪些属性。可以扩展到其他属性\r\n 如果需要。\r\n \r\n"," objects corresponding to assemblies directly referenced by this module.\r\n ":" 对应于该模块直接引用的组件的对象。\r\n \r\n","Updating the size of a {0} requires restarting the application.":"更新{0}的大小需要重新启动应用程序。\r\n","The static initializers.":"静态初始化器。\r\n","\r\n The value for the ReturnKeyword property.\r\n ":"\r\n returnkeyword属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to Cannot infer an element type, and Option Strict On does not allow 'Object' to be assumed. Specifying the type of the array might correct this error..\r\n":"\r\n  查找类似于不能推断元素类型的本地化字符串，并且对选项严格不允许假设“对象”。指定数组的类型可能会纠正此错误。\r\n\r\n","code":"代码\r\n","\r\n The caller is expected to handle constraint checking and any caching of results.\r\n ":"\r\n 预计呼叫者将处理约束检查和结果的任何缓存。\r\n \r\n","\r\n Represents nested missing type.\r\n ":"\r\n 表示嵌套缺失类型。\r\n \r\n","\r\n            ```\\xFF``` escape.\r\n            ":"\r\n            ````\\ xff''逃脱。\r\n            \r\n"," because it goes against the user's preferences.\r\n            ":" 因为这违背了用户的喜好。\r\n            \r\n","\r\n Provides context for binding statements in speculative code.\r\n ":"\r\n 提供投机代码中绑定语句的上下文。\r\n \r\n","\r\n Given a type syntax, strip out ?, (), (of xxx) stuff and return a string of the form\r\n x.y.z, for use in an error message.\r\n ":"\r\n 给定类型的语法，剥离？，（），（xxx）东西并返回表单\r\n X.Y.Z，用于在错误消息中使用。\r\n \r\n","\r\n In emit phase every time a created anonymous type is referenced we try to adjust name of \r\n template's fields as well as store the lowest location of the template. The last one will \r\n be used for ordering templates and assigning emitted type names.\r\n ":"\r\n 每次引用创建的匿名类型时，在发射阶段中，我们都尝试调整名称\r\n 模板的字段以及存储模板的最低位置。最后一个\r\n 用于订购模板和分配发射的类型名称。\r\n \r\n","Passing '{0}' is not valid unless '{1}' is 'SignatureCallingConvention.Unmanaged'.":"除非'{1}'是'signatureCallingConvention.unmanaged'，否则传递'{0}'是无效的。\r\n","The * quantifier matches the preceding element zero or more times. It is equivalent to the {0,} quantifier. * is a greedy quantifier whose lazy equivalent is *?.":"*量词匹配前面的元素零或更多次。它等效于{0，}量词。 *贪婪的量词是懒惰的等效物 *吗？\r\n","\r\n The value for the KeyKeyword property.\r\n ":"\r\n KeyKeyword属性的值。\r\n \r\n","\r\n            Indicates if the operation block has an ":"\r\n            指示操作块是否具有\r\n","\r\n The identifier after the \".\" or \"!\" token.\r\n ":"\r\n “”。或者 ”！”令牌。\r\n \r\n","Organize Usings":"组织使用\r\n","\r\n            Base class for ":"\r\n            基础课\r\n","\r\n A draft version of placeholder substitute which will be used in this With statement. \r\n \r\n Note, the placeholder substitute returned by this property is 'draft' because it is\r\n generated based on initial bound tree, the real substitute will be generated in lowering \r\n based on lowered expression form.\r\n ":"\r\n 占位符替代品的草稿，将在此用语句中使用。\r\n \r\n 注意，该物业返回的占位符替代人是“草稿”，因为它是\r\n 基于初始绑定树生成，将在降低时生成真正的替代品\r\n 基于降低的表达形式。\r\n \r\n","\r\n Returns a copy of this with the QuestionToken property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，询问属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","); otherwise ":"）；否则\r\n","\r\n            Because items from each entity are cached as a separate array, we simply return them as is instead of an \r\n            aggregated array to avoid unnecessary allocations.\r\n            ":"\r\n            因为每个实体的项目都被缓存为一个单独的数组，所以我们只是按原样返回它们，而不是\r\n            汇总阵列以避免不必要的分配。\r\n            \r\n","\r\n This method should be kept consistent with ComputeStringHash\r\n ":"\r\n 该方法应与Computestringhash保持一致\r\n \r\n","\r\n Can return Nothing in case of failure.\r\n ":"\r\n 在失败的情况下，什么都不能返回。\r\n \r\n","\r\n This override is essential - it's a base case of the recursive definition.\r\n ":"\r\n 该覆盖是必不可少的 - 它是递归定义的基本案例。\r\n \r\n","\r\n  Looks up a localized string similar to Cannot implement interface '{0}' because its implementation could conflict with the implementation of another implemented interface '{1}' for some type arguments..\r\n":"\r\n  查找类似于实现接口'{0}'的本地化字符串，因为其实现可能与某种类型参数的另一个实现接口'{1}'的实现相抵触。\r\n\r\n","The optional initializing expression":"可选初始化表达式\r\n","\r\n If the identifier has a type character, report an error on it.\r\n ":"\r\n 如果标识符具有类型字符，请在其上报告错误。\r\n \r\n","\r\n Gets the available named label symbols in the context of the specified location And optional container.\r\n Only members that are accessible And visible from the given location are returned.\r\n ":"\r\n 获取指定位置和可选容器上下文中的可用命名标签符号。\r\n 只返回从给定位置可访问和可见的成员。\r\n \r\n","\r\n If present, a type parameter list with generic type parameters for this method.\r\n If no generic type parameters were present, Nothing is returned.\r\n ":"\r\n 如果存在，则该方法具有通用类型参数的类型参数列表。\r\n 如果没有通用类型参数，则不会返回。\r\n \r\n","Modifying {0} which contains the stackalloc operator requires restarting the application.":"包含stackalloc运算符的修改{0}需要重新启动应用程序。\r\n","\r\n            The span of the syntax element associated with this item.\r\n            \r\n            The span identifies the text in the document that is used to filter the initial list presented to the user,\r\n            and typically represents the region of the document that will be changed if this item is committed.\r\n            ":"\r\n            与此项目关联的语法元素的跨度。\r\n            \r\n            跨度标识文档中用于过滤给用户的初始列表的文本，\r\n            并且通常表示如果该项目提交该项目，则将更改的文档区域。\r\n            \r\n","\r\n Represents an identifier with optional \"?\" or \"()\" or \"(,,,)\" modifiers, as\r\n used in parameter declarations and variable declarations.\r\n ":"\r\n 代表具有可选“？”的标识符。或“（）”或“（,,,）”修饰符，为\r\n 用于参数声明和可变声明中。\r\n \r\n","\r\n The accessor blocks contained in the property, between the Property and the End\r\n Property statements.\r\n ":"\r\n 属性中包含的登录块，属性和末端之间\r\n 属性语句。\r\n \r\n","Calling convention of '{0}' is not compatible with '{1}'.":"调用'{0}'的约定与'{1}'不兼容。\r\n","\r\n  Looks up a localized string similar to \r\n    Extension method '{0}' defined in '{1}': {2}.\r\n":"\r\n  查找类似于\r\n    扩展方法'{0}'在'{1}'：{2}中定义。\r\n\r\n","\r\n Field initializers need to be rewritten multiple times in case of an AsNew declaration with multiple field names because the \r\n initializer may contain references to the current field like in the following example:\r\n Class C1\r\n     Public x, y As New RefType() With {.Field1 = .Field2}\r\n End Class \r\n \r\n in this example .Field2 references the temp that is created for x and y.\r\n \r\n We moved the final rewriting for field initializers to the local \r\n rewriters because here we already have the infrastructure to replace placeholders. \r\n ":"\r\n 如果AsNew声明具有多个字段名称，则需要多次重写字段初始值设定项，因为 \r\n 初始化器可能包含对当前字段的引用，如下例所示:\r\n C1类\r\n     Public x,y As New RefType()With{.字段1=。字段2}\r\n 结束类 \r\n \r\n 在这个例子中。Field2引用为x和y创建的temp。\r\n \r\n 我们将字段初始化器的最终重写移动到本地 \r\n 重写器，因为在这里我们已经有了替换占位符的基础设施。 \r\n \r\n","\r\n Generates the name of a state machine's parameter name\r\n ":"\r\n 生成状态机的参数名称的名称\r\n \r\n","\r\n Represents an \"As {type-name}\" clause that does not have an initializer or\r\n \"New\". The type has optional attributes associated with it, although attributes\r\n are not permitted in all possible places where this node occurs.\r\n ":"\r\n 表示没有初始化器或\r\n “新的”。该类型具有与之关联的可选属性，尽管属性\r\n 在此节点发生的所有可能的地方不允许使用。\r\n \r\n","overload":"超载\r\n","\r\n            Notifies the assembly loader about an in-memory dependency that should be available within the resolution context.\r\n            ":"\r\n            通知汇编装载机有关在分辨率上下文中应可用的内存依赖性。\r\n            \r\n","\r\n  Looks up a localized string similar to Method '{0}' does not have a signature compatible with delegate '{1}'..\r\n":"\r\n  查找类似于方法'{0}'的本地化字符串与签名'{1}'..没有签名。\r\n\r\n"," this service corresponds to.\r\n            ":"此服务对应于。\r\n            \r\n","\r\n            Base type for [...] and [^...] character classes.\r\n            ":"\r\n            [...]和[^...]字符类的基本类型。\r\n            \r\n","extra leading tokens to be added to the select clause":"要添加到“选择子句”\r\n","\r\n A region analysis walker that records reads and writes of all variables, both inside and outside the region.\r\n ":"\r\n 记录的区域分析步行者读取和写入该地区内部和外部的所有变量。\r\n \r\n","\r\n            We set the ":"\r\n            我们设置了\r\n","\r\n  Looks up a localized string similar to The specified version string does not conform to the required format - major[.minor[.build|*[.revision|*]]].\r\n":"\r\n  查找类似于指定版本字符串的本地化字符串不符合所需的格式-Maine [.minor [.build |*[。修订|*]]]。\r\n\r\n","\r\n A Declaration summarizes the declaration structure of a source file. Each entity declaration\r\n in the program that is a container (specifically namespaces, classes, interfaces, structs,\r\n and delegate declarations) is represented by a node in this tree.  At the top level, the\r\n compilation unit is treated as a declaration of the unnamed namespace.\r\n\r\n Special treatment is required for namespace declarations, because a single namespace\r\n declaration can declare more than one namespace.  For example, in the declaration\r\n\r\nnamespace A.B.C {}\r\n\r\nwe see that namespaces A and B and C are declared.  This declaration is represented as three\r\n declarations. All three of these ContainerDeclaration objects contain a reference to the\r\n syntax tree for the declaration.\r\n\r\n A \"single\" declaration represents a specific namespace or type declaration at a point in\r\n source code. A \"root\" declaration is a special single declaration which summarizes the\r\n contents of an entire file's types and namespaces.  Each source file is represented as a tree\r\n of single declarations.\r\n\r\n A \"merged\" declaration merges together one or more declarations for the same symbol.  For\r\n example, the root namespace has multiple single declarations (one in each source file) but\r\n there is a single merged declaration for them all.  Similarly partial classes may have\r\n multiple declarations, grouped together under the umbrella of a merged declaration.  In the\r\n common trivial case, a merged declaration for a single declaration contains only that single\r\n declaration.  The whole program, consisting of the set of all declarations in all of the\r\n source files, is represented by a tree of merged declarations.'''\r\n":"\r\n 声明总结了源文件的声明结构。每个实体声明\r\n 在程序中是一个容器（特别是名称空间，类，接口，结构，\r\n 和委托声明）由该树中的节点表示。在最高级别\r\n 汇编单元被视为未命名名称空间的声明。\r\n\r\n 命名空间声明需要特殊处理，因为一个名称空间\r\n 声明可以声明多个名称空间。例如，在声明中\r\n\r\n名称空间A.B.C {}\r\n\r\n我们看到名称空间A和B和C被声明。该声明表示为三\r\n 声明。这三个这些容器持续对象都包含对\r\n 声明的语法树。\r\n\r\n “单个”声明代表特定的名称空间或类型声明\r\n 源代码。 “根”声明是一个特殊的单一声明，总结了\r\n 整个文件类型和名称空间的内容。每个源文件表示为树\r\n 单声明。\r\n\r\n “合并”声明将一个或多个声明合并为同一符号。为了\r\n 例如，根名称空间具有多个单一声明（每个源文件中一个），但是\r\n 所有人都有一个合并的声明。类似的部分类可能有\r\n 多个声明将合并宣言的保护下组合在一起。在里面\r\n 常见的琐事，单个声明的合并声明仅包含该单一声明\r\n 宣言。整个程序，包括所有声明的集合\r\n 源文件，由合并的声明树表示。'''\r\n\r\n","A variable may not be declared within a 'not' or 'or' pattern.":"在“非”或“或”模式中不得声明变量。\r\n","Suppress {0}":"抑制{0}\r\n","project {0}":"项目{0}\r\n","Replace return with yield return":"用收益率替换回报率\r\n","\r\n            Use this attribute to declare a ":"\r\n            使用此属性声明\r\n","\r\n The \"position\" is used to determine what variables are visible and accessible.\r\n \r\n Non-reduced extension methods are considered, but reduced extension methods are not.\r\n ":"\r\n \"位置\"用于确定哪些变量是可见的和可访问的。\r\n \r\n 考虑非缩减扩展方法，但缩减扩展方法不是。\r\n \r\n","\r\n Returns the type parameters that this type has. If this is a non-generic type,\r\n returns an empty ImmutableArray.  \r\n ":"\r\n 返回此类型具有的类型参数。如果这是一种非传播类型，\r\n 返回一个空的Immutablearray。\r\n \r\n","\r\n Returns a copy of this with the CloseBraceToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，封闭式属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Returns true if this type is known to be a reference type. It is never the case\r\n that ":"\r\n 如果已知该类型是参考类型，则返回true。从来没有\r\n 那\r\n","\r\n The \"Using\" keyword.\r\n ":"\r\n “使用”关键字。\r\n \r\n","The symbol that was declared, or Nothing if no such symbol exists or \r\n if the field initializer was not part of an anonymous type creation.":"声明的符号，或者如果不存在这样的符号或\r\n 如果字段初始化器不是匿名类型创建的一部分。\r\n","The diagnostics collection.":"诊断收集。\r\n","\r\n Returns a copy of this with the JoinKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，并更改​​为“ Joinkeyword属性”\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n NamedTypeSymbol calls derived implementations of this method when acyclic base type\r\n is needed for the first time.\r\n This method typically calls GetDeclaredBase, filters for \r\n illegal cycles and other conditions before returning result as acyclic.\r\n ":"\r\n 当无环碱类型时，该方法的命名typeymbol调用派生的实现\r\n 第一次需要。\r\n 此方法通常调用getDeclaredBase，过滤器\r\n 在返回结果之前，非法周期和其他条件为无环。\r\n \r\n","\r\n            The applicable container node based on cursor location,\r\n            which will be used to change namespace.\r\n            ":"\r\n            基于光标位置的适用容器节点，\r\n            将用于更改名称空间。\r\n            \r\n","\r\n Get the state of Option Compare for the code covered by this semantic model.\r\n This takes into effect both file-level \"Option Compare\" statements and the project-level\r\n defaults.\r\n ":"\r\n 获取该语义模型涵盖的代码的选项状态。\r\n 这可以生效文件级“选项比较”语句和项目级别\r\n 默认。\r\n \r\n","\r\n            Project contains rude edits.\r\n            ":"\r\n            项目包含粗鲁的编辑。\r\n            \r\n","The type '{0}' may not be used for a field of a record.":"类型'{0}'不得用于记录字段。\r\n","\r\n The value for the WarningKeyword property.\r\n ":"\r\n 警告关键字属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to '.' expected..\r\n":"\r\n  查找类似于“”的本地化字符串。预期的..\r\n\r\n","\r\n Supports visitor pattern. \r\n ":"\r\n 支持访客模式。\r\n \r\n","\r\n  Looks up a localized string similar to Nullable types are not allowed in conditional compilation expressions..\r\n":"\r\n  在条件汇编表达式中不允许查找类似于无效类型的本地化字符串。\r\n\r\n","\r\n            Do not use.  Use ":"\r\n            不使用。利用\r\n","\r\n  Looks up a localized string similar to Statements and labels are not valid between 'Select Case' and first 'Case'..\r\n":"\r\n  查找类似于语句的本地化字符串，标签在“选择案例”和第一个“案例”之间无效。\r\n\r\n"," Used to create a region analysis context \r\n with failed flag set to be used in 'failed' scenarios ":" 用于创建区域分析上下文\r\n 在“失败”方案中使用故障标志设置\r\n","\r\n Get a SemanticModel object that is associated with a type syntax that did not appear in\r\n this source code. This can be used to get detailed semantic information about sub-parts\r\n of a type syntax that did not appear in source code. \r\n ":"\r\n 获取与未出现在\r\n 此源代码。这可以用来获取有关子部分的详细语义信息\r\n 未出现在源代码中的类型语法。\r\n \r\n","\r\n The value for the Clauses property.\r\n ":"\r\n 条款属性的值。\r\n \r\n","Tuple types used as operands of an == or != operator must have matching cardinalities. But this operator has tuple types of cardinality {0} on the left and {1} on the right.":"用作AN ==或！=操作员的操作数的元组类型必须具有匹配的基础性。但是该操作员在左侧具有元组类型的基数{0}，右侧有{1}。\r\n","\r\n Allows asking semantic questions about any node in a SyntaxTree within a Compilation.\r\n ":"\r\n 允许在编译中询问有关语法中任何节点的语义问题。\r\n \r\n","named backreference":"名为BackReference\r\n","The initializers itself. For each partial type declaration there is an array of \r\n field initializers":"初始化器本身。对于每种部分类型声明，都有一个数组\r\n 现场初始化器\r\n","\r\n            Return CompilationWithAnalyzer for given project with given stateSets\r\n            ":"\r\n            给定项目的给定项目的返回汇编Withanalyzer\r\n            \r\n","Alternation conditions cannot be comments":"交替条件不能评论\r\n","Autoselect disabled due to member declaration":"由于成员声明而导致禁用自动选择\r\n",") to account for\r\n            source suppressions.":"）来说明\r\n            源抑制。\r\n","Use of new() is not valid in this context":"在这种情况下，新（）的使用无效\r\n","\r\n The value for the AsClause property.\r\n ":"\r\n Asclause属性的值。\r\n \r\n","\r\n For a receiver to match an instance, more or less, the type of that instance has to be convertible\r\n to the type of the receiver with the same bit-representation (i.e. identity on value-types\r\n and reference-convertibility on reference types).\r\n Actually, we don't include the reference-convertibilities that seem nonsensical, e.g. enum() to underlyingtype()\r\n We do include inheritance, implements and variance conversions amongst others.\r\n ":"要使接收器匹配实例，或多或少，该实例的类型必须是可转换的\r\n 对于具有相同比特代理的接收器的类型（即值类型的身份\r\n 和参考类型的参考转换性）。\r\n 实际上，我们不包括看起来荒谬的参考转换性，例如enum（）to UndeslyingType（）\r\n 我们确实包括继承，工具和方差转换。\r\n \r\n","\r\n A list of all attribute lists on the type. If no attributes were specified, an\r\n empty list is returned.\r\n ":"\r\n 类型上所有属性列表的列表。如果未指定属性，则\r\n 返回空列表。\r\n \r\n"," \r\n If we believe we know which symbol the user intended, then we should retain that information\r\n in the corresponding error symbol - it can be useful for deciding how to handle the error.\r\n ":" \r\n 如果我们相信我们知道用户预期的符号，那么我们应该保留该信息\r\n 在相应的错误符号中 - 它对于确定如何处理错误可能很有用。\r\n \r\n","The text that is displayed to the user.":"向用户显示的文本。\r\n","\r\n Represents a compiler \"MyGroupCollection\" property.\r\n ":"\r\n 代表编译器“ myGroupCollection”属性。\r\n \r\n","\r\n            optimized for perf, uses Skip(1).Any() instead of Count() > 1\r\n            ":"\r\n            对perf进行了优化，使用skip（1）.any（）而不是count（）> 1\r\n            \r\n","\r\n            Statements that should be inserted to before the invocation location of callee.\r\n            ":"\r\n            在Callee的调用位置之前应插入的语句。\r\n            \r\n","\r\n Is this Out parameter (metadata flag In is set).\r\n ":"\r\n 这是out参数（设置的元数据标志）。\r\n \r\n","s.\r\n ":"s。\r\n \r\n","\r\n            The document that quick info was requested within.\r\n            ":"\r\n            内部请求快速信息的文档。\r\n            \r\n","The string arrays to be parsed.":"字符串阵列要解析。\r\n","\r\n Returns child node or token that contains given position.\r\n ":"\r\n 返回包含给定位置的子节点或令牌。\r\n \r\n",". The one exception is the refactoring, which is explicitly there to still let people\r\n            convert things quickly, even if it's going against their stated style.":"。一个例外是重构，这显然是在那里让人们\r\n            即使与他们陈述的风格有关，也很快转换了事物。\r\n","'GetHashCode' implementation can be simplified":"可以简化“ gethashcode”实现\r\n","\r\n            Breaks up the list of provided nodes, based on how they are interspersed with pp\r\n            directives, into groups.  Within these groups nodes can be moved around safely, without\r\n            breaking any pp constructs.\r\n            ":"\r\n            根据如何与PP散布的方式分解提供的节点的列表\r\n            指令，分组。在这些组中，节点可以安全地移动，而无需\r\n            打破任何PP构造。\r\n            \r\n","\r\n  Looks up a localized string similar to Option Strict On does not allow narrowing in implicit type conversions between method '{0}' and delegate '{1}'..\r\n":"\r\n  查找类似于Option Option的本地化字符串，不允许在方法'{0}'和委托'{1}'..之间的隐式类型转换中缩小缩小。\r\n\r\n","Use index operator":"使用索引操作员\r\n"," method.\r\n ":" 方法。\r\n \r\n","\r\n Implements shadowing based on\r\n §11.8.1 Overloaded Method Resolution.\r\n 7.7.  If M and N both required type inference to produce type arguments, and M did not \r\n       require determining the dominant type for any of its type arguments (i.e. each the \r\n       type arguments inferred to a single type), but N did, eliminate N from the set.\r\n ":"\r\n 基于\r\n §11.8.1超载方法分辨率。\r\n 7.7。如果M和N都需要类型的推理才能产生类型的参数，而M则没有\r\n       需要确定其任何类型参数的主要类型（即\r\n       推断为单一类型的类型参数），但是n确实从集合中消除了n。\r\n \r\n","\r\n Collect extension methods with the given name that are in scope in this binder.\r\n The passed in ArrayBuilder must be empty. Extension methods from the same containing type\r\n must be grouped together. \r\n ":"\r\n 收集具有此粘合剂范围中给定名称的扩展方法。\r\n 阵列构造器中传递的人必须为空。来自同一包含类型的扩展方法\r\n 必须分组在一起。\r\n \r\n","\r\n The value for the UnderlyingType property.\r\n ":"\r\n 基础类型属性的值。\r\n \r\n","\r\n            The value of the variable after running the script.\r\n            ":"\r\n            运行脚本后变量的值。\r\n            \r\n","The \"y\" custom format specifier represents the year as a one-digit or two-digit number. If the year has more than two digits, only the two low-order digits appear in the result. If the first digit of a two-digit year begins with a zero (for example, 2008), ...":"“ Y”自定义格式指定符表示年度为一位数或两位数的数字。如果一年有两个以上的数字，则结果仅出现两个低阶数字。如果两位数的第一位数以零开始（例如，2008年），...\r\n","\r\n  Looks up a localized string similar to White space cannot appear here..\r\n":"\r\n  查找类似于白空间的本地化弦。\r\n\r\n","\r\n Represents a New expression that creates a new non-array object, possibly with\r\n a \"With\" or \"From\" clause.\r\n ":"\r\n 代表一个新的表达式，可以创建一个新的非阵列对象\r\n a“ with”或“来自”子句。\r\n \r\n","\r\n The expression.\r\n ":"\r\n 表达方式。\r\n \r\n","Unknown error occurred":"发生未知错误\r\n","Error while reading assembly data.":"读取组装数据时错误。\r\n","\r\n The optional array bounds, such as \"(4)\" or \"(0 to 5, 0 To 6)\".\r\n ":"\r\n 可选阵列边界，例如“（4）”或“（0至5，0至6）”。\r\n \r\n","\r\n The value for the FollowingMisc property.\r\n ":"\r\n 后续限制属性的值。\r\n \r\n","1, for the length of ":"1、对于长度 \r\n","The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect because it's self-referential.":"应用于参数'{0}'的callerargumentExpresseptribute将没有效果，因为它是自称的。\r\n","An expression tree may not contain a pattern System.Index or System.Range indexer access":"表达树可能不包含模式系统.index或System.Range索引器访问\r\n","\r\n Data for Binder.BindImportClause that exposes dictionaries of\r\n the members and aliases that have been bound during the\r\n execution of BindImportClause. It is the responsibility of derived\r\n classes to update the dictionaries in AddMember and AddAlias.\r\n ":"\r\n 粘合剂的数据。\r\n 在\r\n 执行Bindimportclause。这是派生的责任\r\n 在AddMember和Addalias中更新字典的类。\r\n \r\n","\r\n This property should not be confused with general property overloading in Visual Basic, and is not directly related. \r\n This property will only return true if this method hides a base property by name and signature (Overloads keyword).\r\n ":"\r\n 该属性不应与Visual Basic中的一般属性过载相混淆，也不应直接相关。\r\n 此属性仅在此方法按名称和签名（Overloads关键字）隐藏基本属性时才能返回True。\r\n \r\n","\r\n CONSIDER: it probably isn't truly necessary to cache this.  If space gets tight, consider\r\n alternative approaches (recompute every time, cache on the side, only store on some types,\r\n etc).\r\n ":"\r\n 考虑：缓存可能并不是真正必要的。如果空间很紧，请考虑\r\n 替代方法（每次重新计算，在侧面缓存，仅存储在某些类型上，\r\n ETC）。\r\n \r\n"," directive.\r\n            Null if unknown (not determined yet).\r\n            ":" 指示。\r\n            如果未知（尚未确定），则为空。\r\n            \r\n"," snapshot that may keep around a lot of memory in a host.\r\n            ":" 快照可能会在主机中保留大量内存。\r\n            \r\n","100,000ths of a second":"100,000秒\r\n","\r\n Is this a member of a interface that requires implementation?\r\n ":"\r\n 这是需要实施的接口的成员吗？\r\n \r\n","\r\n Creates a new command line parser.\r\n ":"\r\n 创建一个新的命令行解析器。\r\n \r\n","\r\n  Looks up a localized string similar to 'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to 'AddHandler', 'RemoveHandler' or 'RaiseEvent' method..\r\n":"\r\n  查找类似于“ system.runtime.interopservices.dllimportattribute”的本地化字符串，不能应用于“ Addhandler”，“ removeHandler”或“ raiseeevent”方法。\r\n\r\n","\r\n  Looks up a localized string similar to Variable '{0}' hides a variable in an enclosing block..\r\n":"\r\n  查找类似于变量'{0}'的局部字符串将变量隐藏在一个封闭块中。\r\n\r\n","\r\n The value for the EventStatement property.\r\n ":"\r\n 事件statement属性的值。\r\n \r\n","Syntax tree.":"语法树。\r\n","\r\n ExpressionSyntax node representing the object conditionally accessed.\r\n ":"\r\n 表示有条件访问的对象的extressionsyntax节点。\r\n \r\n","\r\n Create a bracketed identifier.\r\n ":"\r\n 创建一个包围的标识符。\r\n \r\n","\r\n Must be a non-null interface property, method, or event.\r\n ":"\r\n 必须是非NULL接口属性，方法或事件。\r\n \r\n","A negative character group specifies a list of characters that must not appear in an input string for a match to occur. The list of characters are specified individually.\r\n            \r\n            Two or more character ranges can be concatenated. For example, to specify the range  ...":"负角色组指定一个不得出现在输入字符串中以进行匹配的字符列表。字符列表单独指定。\r\n            \r\n            可以连接两个或多个角色范围。例如，指定范围...\r\n","\r\n            The length of the prefix indicating the start of a comment. For example:\r\n            ":"\r\n            指示注释开始的前缀的长度。 例如:\r\n            \r\n","\r\n Returns a copy of this with the LoopKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中Loopkeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            check if its the form: `expr.Length - value`.  If so, update rangeOperation to then\r\n            point to 'value' so that we can generate '^value'.\r\n            ":"\r\n            检查其是否形式：`expr.length -value`。如果是这样，请更新揽胜\r\n            指向“值”，以便我们可以生成'^value'。\r\n            \r\n","\r\n Creates a list of tokens.\r\n ":"\r\n 创建一个令牌列表。\r\n \r\n"," Expression to be used instead of With statement expression placeholder ":" 表达式而不是语句表达占位符\r\n","Inline variable declaration":"内联变量声明\r\n","\r\n            Annotation used to mark imports that we move over, so that we can remove these imports if they are unnecessary\r\n            (and so we don't remove any other unnecessary imports)\r\n            ":"\r\n            注释用于标记我们转移的导入，以便如果不必要，我们可以删除它们\r\n            （因此，我们不会删除其他任何不必要的进口）\r\n            \r\n","Apply object/collection initialization preferences":"应用对象/收集初始化首选项\r\n","The condition whether to call dispose or not.":"是否呼叫处置的条件。\r\n","\r\n Represents an invocation of an Aggregation function in the aggregation range\r\n variable declaration of a Group By, Group Join or Aggregate query operator.\r\n ":"\r\n 表示聚合范围内聚合函数的调用\r\n 小组的可变声明，组加入或汇总查询操作员。\r\n \r\n","\r\n Given an AnonymousObjectCreationExpressionSyntax, get the corresponding symbol of anonymous type.\r\n ":"\r\n 给定一个匿名creationexpressyntax，获取匿名类型的相应符号。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' is already declared as a parameter of this method..\r\n":"\r\n  查找类似于“ {0}”的本地化字符串已被声明为此方法的参数。\r\n\r\n"," has a corresponding slot in ":" 在相应的插槽中\r\n"," Creates a token with kind IntegerLiteralToken from the text and corresponding 4-byte unsigned integer value. ":" 从文本和相应的4个字节无符号整数值中创建一个具有元素integerliteraltoken的令牌。\r\n",") each of which addresses / fixes the same supplied ":"）每个都解决 /修复了相同的提供的\r\n","\r\n Lookup member declaration in well known type used by this Compilation.\r\n ":"\r\n 查找成员声明以本汇编使用的众所周知的类型。\r\n \r\n","\r\n            Gets the text prefix indicating a single-line comment.\r\n            ":"\r\n            获取文本前缀指示单线注释。\r\n            \r\n","\r\n            Represents a not-pattern, constructed from inequality check or a logical-not expression.\r\n            ":"\r\n            代表由不等式检查或逻辑表达式构建的非模式。\r\n            \r\n","\r\n Option Strict is Off. No Option Strict checks are in effect.\r\n ":"\r\n 选项严格已关闭。没有选项严格的检查有效。\r\n \r\n","discard":"丢弃\r\n","\r\n Returns a copy of this with the GoToKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中Gotokeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","A bound call to GetEnumerator on the collection if found.":"如果发现了收藏集中的getEnumerer的绑定呼叫。\r\n","Optional options that override the default options.":"覆盖默认选项的可选选项。\r\n","\r\n            The current source span.\r\n            ":"\r\n            当前的源跨度。\r\n            \r\n"," when displaying this item.\r\n            ":" 显示此项目时。\r\n            \r\n","\r\n            \r\n            Then we would be unable to handle that.  However, this is highly unlikely to happen, and so we accept the\r\n            inaccuracy for the purpose of simplicity and for handling the much more common cases of either the entire\r\n            file being annotated, or the user individually disabling annotations at the member level.\r\n            ":"\r\n            \r\n            那么我们将无法处理。但是，这不太可能发生，因此我们接受\r\n            出于简单性和处理整个案例的更常见案例的不准确性\r\n            文件被注释，或用户单独禁用会员级别的注释。\r\n            \r\n","\r\n Return True if type constraints should be checked when binding.\r\n ":"\r\n 如果在绑定时应检查类型约束，则返回true。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' is ambiguous in the namespace '{1}'..\r\n":"\r\n  在名称空间'{1}'..中查找类似于“ {0}”的本地化字符串。\r\n\r\n","), as caching is known to\r\n            reduce latency in designer scenarios using the VS workspace.  For other Workspace kinds, the cost of the\r\n            cache is likely to outweigh the benefit (for example, in Misc File Workspace cases, we can end up holding\r\n            onto a lot of memory even after a file is closed).  We can opt in other kinds of Workspaces as needed.\r\n            ":"），因为缓存是已知的\r\n            使用VS工作区减少设计人员方案的延迟。对于其他工作空间，\r\n            缓存可能会超过利益（例如，在MISC文件工作空间案例中，我们最终可以持有\r\n            即使关闭文件后，也可以在许多内存上）。我们可以根据需要选择其他类型的工作区。\r\n            \r\n","\r\n Mark all deferred types as referenced\r\n ":"\r\n 标记所有递延类型\r\n \r\n","The file header is missing or not located at the top of the file":"文件标头丢失或不位于文件顶部\r\n","Trivia is not associated with token":"琐事与令牌无关\r\n","\r\n All symbols that should never be captured with a copy constructor of a closure.\r\n ":"\r\n 绝不应该用闭合的复制构造函数捕获的所有符号。\r\n \r\n","The node to be replaced. This might be an ancestor of original reference.":"要替换的节点。这可能是原始参考的祖先。\r\n","\r\n            ```\\cX``` escape\r\n            ":"\r\n            ````\\ cx''逃脱\r\n            \r\n","\r\n            Defines global members that common command line script hosts expose to the hosted scripts.\r\n            ":"定义全局成员，通用命令行脚本托管暴露于托管脚本。\r\n            \r\n","The declarationSyntax that declares a variable.":"声明宣布变量的声明类别。\r\n","\r\n The \"To\" keyword.\r\n ":"\r\n “到”关键字。\r\n \r\n","The \"ss\" custom format specifier (plus any number of additional \"s\" specifiers) represents the seconds as a number from 00 through 59. The result represents whole seconds that have passed since the last minute. A single-digit second is formatted with a lea ...":"“ SS”自定义格式指定符（加上任何数量的附加“ S”指示符）表示秒为00至59的数字。结果表示自上分钟以来已通过的整个秒数。单位一秒钟的格式是用lea ...\r\n","\r\n Symbol for the event handled in current Handles item.\r\n ":"\r\n 当前手柄项目处理的事件的符号。\r\n \r\n","\r\n These are the flags that are found in the syntax.  They must correspond to the modifiers list.\r\n ":"\r\n 这些是语法中发现的标志。它们必须对应于修饰符列表。\r\n \r\n","\r\n The \"&\" type character.\"\r\n ":"“＆”类型字符。\r\n \r\n","\r\n            Walks the portion of the tree we're adding imports to looking to see if those imports could likely cause\r\n            conflicts with existing code.  Note: this is a best-effort basis, and the goal is to catch reasonable\r\n            conflicts effectively.  There may be cases that do slip through that we can adjust for in the future.  Those\r\n            cases should be assessed to see how reasonable/likely they are.  I.e. if it's just a hypothetical case with\r\n            no users being hit, then that's far less important than if we have a reasonable coding pattern that would be\r\n            impacted by adding an import to a normal namespace.\r\n            ":"\r\n            走动树的一部分，我们正在添加导入，以查看这些导入是否可能导致\r\n            与现有代码发生冲突。注意：这是最佳胜地，目标是抓住合理\r\n            有效冲突。可能有些情况下会经历我们将来可以调整的情况。那些\r\n            应评估案例以查看它们的合理/可能。 IE。如果这只是一个假设的情况\r\n            没有用户受到打击，那么这与我们有合理的编码模式相比，重要的是\r\n            受到将导入添加到普通名称空间的影响。\r\n            \r\n","\r\n The value for the LabelToken property.\r\n ":"\r\n Labeltoken属性的价值。\r\n \r\n","Nothing if no bases being resolved, otherwise the set of bases being resolved.":"如果没有解决基地，则什么都没有解决，否则可以解决一组基础。\r\n","\r\n            Holds the expression determined to be used as the target expression of the switch\r\n            ":"\r\n            保留确定用作开关的目标表达的表达式\r\n            \r\n","default interface implementation":"默认接口实现\r\n","\r\n If we are inside a lambda in a constructor and are passing ByRef a non-LValue field, which \r\n would be an LValue field, if it were referred to in the constructor outside of a lambda, \r\n we need to report an error because the operation will result in a simulated pass by\r\n ref (through a temp, without a copy back), which might be not the intent.\r\n ":"\r\n 如果我们在构造函数中的lambda内\r\n 如果在lambda之外的构造函数中提到了一个LVALUE字段，\r\n 我们需要报告错误，因为该操作将导致模拟通过\r\n 参考（通过温度，无需复制），这可能不是意图。\r\n \r\n","\r\n Returns true if the type is a Script class. \r\n It might be an interactive submission class or a Script class in a csx file.\r\n ":"\r\n 如果类型是脚本类，则返回true。\r\n 它可能是CSX文件中的交互式提交类或脚本类。\r\n \r\n","\r\n Represents the \"Handles ...\" clause on a method declaration that describes\r\n which events this method handles.\r\n ":"\r\n 表示描述的方法声明上的“句柄...”条款\r\n 该方法处理的哪些事件。\r\n \r\n","\r\n            Calculates the distance between two sequences of syntax nodes, disregarding trivia. \r\n            ":"\r\n            计算两个语法节点的两个序列之间的距离，无视琐事。\r\n            \r\n"," if the label (a bullet or number) for the current list item has already been rendered; otherwise ":" 如果当前列表项目的标签（子弹或号码）已经呈现；否则\r\n","\r\n When doing speculative binding, we don't have any context information about expressions or the\r\n context that is expected. We try to interpret as a value, but\r\n only if it doesn't cause additional errors (indicating that it wasn't value to interpret it\r\n that way). This should get us the most \"liberal\" interpretation\r\n for semantic information.\r\n ":"\r\n 进行投机绑定时，我们没有任何有关表达式或表达式的上下文信息\r\n 预期的上下文。我们试图解释为一个价值，但是\r\n 仅当它不会引起其他错误（表明解释它不是值得的\r\n 那样）。这应该使我们成为最“自由”的解释\r\n 有关语义信息。\r\n \r\n","The {n,}? quantifier matches the preceding element at least n times, where n is any integer, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,}":"然后，}？量词至少匹配前面的元素，其中n是任何整数，但尽可能少的次。这是贪婪量词{n，}的懒惰对应物\r\n","\r\n  Looks up a localized string similar to Project '{0}' makes an indirect reference to assembly '{1}', which contains '{2}'. Add a file reference to '{3}' to your project..\r\n":"\r\n  查找类似于项目'{0}'的本地化字符串，使汇编'{1}'间接引用，其中包含'{2}'。将文件引用添加到“ {3}”到您的项目。\r\n\r\n","\r\n            Reports on whether the specified member is suitable for qualification. Some member\r\n            access expressions cannot be qualified; for instance if they begin with ":"\r\n            关于指定成员是否适合资格的报告。 一些成员\r\n            访问表达式不能限定；例如，如果它们以 \r\n","\r\n            If we're adding a metadata-reference, then we always offer to do the add,\r\n            even if there's an existing source-import in the file.\r\n            ":"\r\n            如果我们要添加元数据参考，那么我们始终提出要进行添加，\r\n            即使文件中有现有的源信息。\r\n            \r\n","\r\n Returns a copy of this with the Items property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，其中项目属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","The Invoke method to \"implement\".":"调用方法“实现”。\r\n","\r\n            Descriptive tags from the ":"\r\n            来自\r\n","\r\n            Searches for extension methods exactly called 'GetAsyncEnumerator'.  Returns\r\n            ":"\r\n            搜索精确称为“ getAsyncenumerator”的扩展方法。返回\r\n            \r\n","\r\n            Indicates the end of a text container. See ":"\r\n            指示文本容器的末尾。看\r\n","Error creating instance of CodeFixProvider":"错误创建CodeFixProvider的实例\r\n","\r\n Represents a net-module imported from a PE. Can be a primary module of an assembly. \r\n ":"\r\n 表示从PE导入的净模块。可以是组件的主要模块。\r\n \r\n","Introduce constant for all occurrences of '{0}'":"引入所有出现“ {0}”的常数\r\n","\r\n The argument list, if present. If no argument list was supplied, Nothing is\r\n returned.\r\n ":"\r\n 参数列表，如果存在。如果没有提供参数列表，则什么都没有\r\n 回来。\r\n \r\n","\r\n The system assembly, which provides primitive types like Object, String, etc., e.g. mscorlib.dll. \r\n The value is provided by ReferenceManager and must not be modified. For SourceAssemblySymbol, non-missing \r\n coreLibrary must match one of the referenced assemblies returned by GetReferencedAssemblySymbols() method of \r\n the main module. If there is no existing assembly that can be used as a source for the primitive types, \r\n the value is a Compilation.MissingCorLibrary. \r\n ":"\r\n 系统组件，提供原始类型，例如对象，字符串等，例如mscorlib.dll。\r\n 该值由ReferenceManager提供，不得修改。对于源切除术，无误\r\n 冠状动脉必须匹配由GetReferendedAssemblysymbols返回的参考组件之一（）方法\r\n 主模块。如果没有现有的组件可以用作原始类型的来源，\r\n 该值是汇编。\r\n \r\n","\r\n This function tries to bind the given controlVariableSyntax. \r\n If it was an identifier of a valid target, the bound node is written to controlVariable and true is returned.\r\n If something else was bound, that is not legal as a control variable (e.g. a property), a BoundBadNode is written \r\n to controlVariable and false is returned.\r\n If nothing declared was found, false is returned and controlVariable is set to nothing. In this case it's safe to\r\n create a new local for the loop node.\r\n ":"\r\n 该函数试图结合给定的控制变量元素。\r\n 如果它是有效目标的标识符，则将边界节点写入ControlVaria -Control Variable，并返回TRUE。\r\n 如果其他有限的东西是不合法的，则作为控制变量（例如属性），则编写boundbadnode\r\n 返回控制变量和false。\r\n 如果没有发现任何声明，则返回错误，并且可控制变量设置为“一无所有”。在这种情况下，可以安全\r\n 为循环节点创建一个新的本地。\r\n \r\n","\r\n Represents an alignment clause ',alignment' of an interpolated string embedded\r\n expression.\r\n ":"\r\n 表示嵌入的插值字符串的对齐子句'，对齐\r\n 表达。\r\n \r\n","\r\n Source assembly that triggered creation of this module symbol.\r\n For debug purposes only, this assembly symbol should not be persisted within\r\n this module symbol because the module can be shared across multiple source\r\n assemblies. This method will only be called for the first one.\r\n ":"\r\n 源组件触发了此模块符号的创建。\r\n 仅出于调试目的，此组装符号不应在其中持续\r\n 此模块符号，因为可以通过多个源共享模块\r\n 集会。只有第一种方法将被调用。\r\n \r\n","\r\n            Finds a public, non-static indexer in the given type.  The indexer has to accept the\r\n            provided ":"在给定类型中找到公共，非静态索引器。索引者必须接受\r\n            假如\r\n","\r\n Returns a copy of this with the NameKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中namekeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Do not compare function pointer values":"不要比较功能指针值\r\n","Referenced symbols, less type parameters.":"引用的符号，较少的类型参数。\r\n","Add 'string.IsNullOrWhiteSpace' check":"添加“ string.isnullorwhitespace”检查\r\n","\r\n  Looks up a localized string similar to '{0}' cannot inherit from {1} '{2}' because it expands the access of the base {1} to {3} '{4}'..\r\n":"\r\n  查找类似于'{0}'的本地化字符串不能从{1}'{2}'继承，因为它将基础{1}的访问扩展到{3}'{4}'..\r\n\r\n","enum generic type constraints":"枚举通用类型约束\r\n","Conversion from the local type to IDisposable":"从本地类型到IDisposable的转换\r\n","utc hour offset (2 digits)":"UTC小时偏移（2位数字）\r\n","Add braces":"添加牙套\r\n","\r\n Merge two results, returning the best. If there are\r\n multiple viable results, either produce a result with both symbols if they \r\n can overload each other, or use the current.\r\n ":"\r\n 合并两个结果，返回最好的结果。如果有\r\n 多个可行的结果，要么产生两个符号的结果\r\n 可以互相超载，或使用电流。\r\n \r\n","\r\n            Cannot await void.\r\n            ":"\r\n            无法等待无效。\r\n            \r\n","\r\n Gets the kind of this symbol.\r\n ":"\r\n 得到这种符号。\r\n \r\n","\r\n A SyntaxTree and the associated RootSingleNamespaceDeclaration for an embedded\r\n syntax tree in the Compilation. Unlike the entries in m_rootNamespaces, the\r\n SyntaxTree here is lazy since the tree cannot be evaluated until the references\r\n have been resolved (as part of binding the source module), and at that point, the\r\n SyntaxTree may be Nothing if the embedded tree is not needed for the Compilation.\r\n ":"\r\n 语法和相关的RootsingLenamespacedEclaration，用于嵌入式\r\n 汇编中的语法树。与m_rootnamespaces中的条目不同，\r\n 语法是懒惰的，因为在参考文献之前无法评估树\r\n 已解决（作为绑定源模块的一部分），此时\r\n 如果不需要嵌入的树来进行编译，则语法可能一无所有。\r\n \r\n","\r\n If this symbol represents a metadata assembly returns the underlying ":"\r\n 如果此符号代表元数据组件返回基础\r\n","The instance initializers.":"实例初始化器。\r\n","\r\n Determine whether field access should be treated as LValue. \r\n ":"\r\n 确定是否应将现场访问视为LVALUE。\r\n \r\n","Implement interface abstractly":"抽象实现接口\r\n","\r\n Represents a block property declaration: A declaration that has a beginning\r\n declaration, some get or set accessor blocks and an end statement.\r\n ":"\r\n 代表块属性声明：具有开始的声明\r\n 声明，有些获取或设置访问器块和一个末端语句。\r\n \r\n","Pass true to look up fullName case-insensitively.  WARNING: more expensive.":"通过True以示意性案例。警告：更昂贵。\r\n"," for await expressions,\r\n            ":" 等待表达，\r\n            \r\n","Switching between a lambda and a local function requires restarting the application.":"在lambda和本地功能之间切换需要重新启动应用程序。\r\n","\r\n  Looks up a localized string similar to 'Exit Function' is not valid in a Sub or Property..\r\n":"\r\n  在子或属性中查找类似于“退出功能”的本地化字符串。\r\n\r\n","\r\n Represents a type of a RetargetingModuleSymbol. Essentially this is a wrapper around \r\n another NamedTypeSymbol that is responsible for retargeting referenced symbols from one assembly to another. \r\n It can retarget symbols for multiple assemblies at the same time.\r\n ":"\r\n 代表一种retargetingModulesymbol。本质上，这是周围的包装纸\r\n 另一个命名为typesymbol，负责将引用的符号从一个组件重新定位为另一个组件。\r\n 它可以同时重新定位多个组件。\r\n \r\n","\r\n The value for the ExternalSourceKeyword property.\r\n ":"externalsourcekeyword属性的值。\r\n \r\n","\r\n Returns true if the node is the object of an invocation expression\r\n ":"\r\n 如果节点是调用表达式的对象，则返回true\r\n \r\n","Remove unused function":"删除未使用的功能\r\n","\r\n Can we access MyBase in this location. If False is returned, \r\n also returns the error id associated with that.\r\n ":"\r\n 我们可以在此位置访问mybase吗？如果返回错误，\r\n 还返回与之关联的错误ID。\r\n \r\n","\r\n Used by structured trivia which has no parent node, so need to know syntax tree explicitly\r\n ":"\r\n 由没有父节点的结构化琐事使用，因此需要明确了解语法树\r\n \r\n","\r\n Represents an #Else pre-processing directive appearing in source.\r\n ":"\r\n 代表#else预处理指令出现在源中。\r\n \r\n","\r\n True if the syntax tree is an embedded syntax tree\r\n ":"\r\n 如果语法树是嵌入式语法树\r\n \r\n"," Set conditional state ":" 设定条件状态\r\n","\r\n Implements shadowing based on\r\n §11.8.1 Overloaded Method Resolution.\r\n    7.3.\tIf M and N are extension methods and the target type of M has fewer type \r\n         parameters than the target type of N, eliminate N from the set. \r\n         !!! Note that spec talks about \"fewer type parameters\", but it is not really about count. \r\n         !!! It is about one refers to a type parameter and the other one doesn't.\r\n ":"\r\n 基于\r\n §11.8.1超载方法分辨率。\r\n    7.3。如果M和N是扩展方法，并且M的目标类型的类型较少\r\n         参数比n的目标类型，从集合中消除n。\r\n         !!!请注意，规格谈论“较少的类型参数”，但这并不是真正的计数。\r\n         !!!它大约是指类型参数，另一个参数没有。\r\n \r\n","\r\n Returns a copy of this with the Modifiers property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中修饰符属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","The for each syntax node.":"每个语法节点。\r\n","Remove unnecessary suppression operator":"删除不必要的抑制操作员\r\n","NS1.NS2.T1.T2.Method(...dynamic...)":"NS1.NS2.T1.T2.Method（...动态...）\r\n","Introduce 'using' statement":"引入“使用”语句\r\n","True to leave ":"真实离开\r\n","'{0}' may be null here.":"'{0}'在这里可能无效。\r\n","\r\n If set to true, a documentation comment exterior token will be added to the trailing trivia\r\n of the new token.":"\r\n 如果设置为true，则文档评论外观令牌将添加到the the Trivia\r\n 新令牌。\r\n","\r\n  Looks up a localized string similar to Nullable modifier '?' and array modifiers '(' and ')' cannot be specified on both a variable and its type..\r\n":"\r\n  查找类似于无效修饰符'？'的本地化字符串和数组修饰符'（'and'）'在变量及其类型上都不能指定。\r\n\r\n"," the user is currently working in. May be null if\r\n            there is no active document or the active document is not in this ":" 用户目前正在工作。如果\r\n            没有主动文档，也没有主动文档在此中\r\n","\r\n The value for the EnableKeyword property.\r\n ":"\r\n 启用键属性的值。\r\n \r\n","\r\n If a method had an virtual inaccessible override, then an explicit override in metadata is needed\r\n to make it really override what it intends to override, and \"skip\" the inaccessible virtual\r\n method.\r\n ":"\r\n 如果一种方法具有虚拟的无法访问的替代，则需要在元数据中进行显式覆盖\r\n 为了使它真正覆盖其打算覆盖的意图，然后“跳过”无法访问的虚拟\r\n 方法。\r\n \r\n","\r\n The value for the Label property.\r\n ":"\r\n 标签属性的值。\r\n \r\n","\r\n If this property returns false, it is certain that there are no extension\r\n methods (from language perspective) inside this assembly. If this property returns true, \r\n it is highly likely (but not certain) that this type contains extension methods. \r\n This property allows the search for extension methods to be narrowed much more quickly.\r\n \r\n !!! Note that this property can mutate during lifetime of the symbol !!!\r\n !!! from True to False, as we learn more about the assembly.         !!! \r\n ":"\r\n 如果此属性返回false，则可以肯定没有扩展\r\n 该组件内的方法（从语言角度来看）。如果此属性返回true，\r\n 这种类型包含扩展方法很可能（但不确定）。\r\n 此属性允许搜索扩展方法更快地缩小。\r\n \r\n !!!请注意，此属性可以在符号的生命周期中突变！！！\r\n !!!从真实到错误，随着我们更多地了解集会。 !!!\r\n \r\n","\r\n True is the enumerator needs or may need (in case of IEnumerator) to be disposed.\r\n ":"\r\n 正确的是枚举者的需求或可能需要（如果是Ienumerator）。\r\n \r\n","Unwrap all parameters":"解开所有参数\r\n","\r\n A list of the Implements declarations for the type.\r\n ":"\r\n 该类型的工具声明列表。\r\n \r\n","\r\n Bind query expression that starts with From keyword, as opposed to the one that starts with Aggregate.\r\n \r\n     From {collection range variables} [{other operators}]\r\n ":"\r\n 绑定的查询表达式从关键字开始，而不是从聚合开始的表达式。\r\n \r\n     来自{收集范围变量} [{其他操作员}]\r\n \r\n","\r\n Type context for resolving generic type arguments.\r\n ":"\r\n 解决通用类型参数的类型上下文。\r\n \r\n","The \"hh\" custom format specifier (plus any number of additional \"h\" specifiers) represents the hour as a number from 01 through 12; that is, the hour is represented by a 12-hour clock that counts the whole hours since midnight or noon. A particular hour af ...":"“ HH”自定义格式指定符（加上任何数量的其他“ H”指定符）表示该小时为01至12的数字；也就是说，小时以12小时的时钟为代表，该时钟算在午夜或中午以来的整个小时。特定的小时AF ...\r\n","\r\n            Return true if the declaration is a field/property declaration with an initializer. \r\n            Shall return false for enum members.\r\n            ":"\r\n            如果声明是带有初始化器的字段/属性声明，则返回true。\r\n            应退还枚举成员的假。\r\n            \r\n","\r\n Make sure GetObjectValue calls are injected.\r\n ":"\r\n 确保注入GetObjectValue调用。\r\n \r\n","\r\n The name of the property being declared.\r\n ":"该财产的名称被声明。\r\n \r\n","\r\n Having this binder, which is created for each field initializer within AnonymousObjectCreationExpressionSyntax\r\n gives us the following advantages:\r\n   - We no longer rely on transient state of AnonymousTypeField objects to detect out of order field references\r\n     within initializers. This way we can be sure that result of binding performed by SemanticModel is consistent\r\n     with result of initial binding of the entire node.\r\n   - AnonymousTypeCreationBinder overrides CreateAnonymousObjectCreationExpression in such a way that it mutates\r\n     its state. That overridden method shouldn't be called while we are binding each initializer (by queries, for example), \r\n     it should be called only by AnonymousTypeCreationBinder itself after all initializers are bound and we are producing \r\n     the resulting node. So having an extra binder in between takes care of that.\r\n ":"具有此粘合剂，该粘合剂是为anonymousObjectCreationexpressyntax中每个字段初始化器创建的\r\n 给我们以下优势：\r\n    - 我们不再依赖匿名对象的瞬态状态来检测订单字段参考\r\n     在初始化器中。这样，我们可以确定semanticmodel执行绑定的结果是一致的\r\n     由于整个节点的初始结合。\r\n    - 匿名typecreationbinder以突变的方式覆盖了createAnonyMobjectCreationExpression\r\n     它的状态。当我们绑定每个初始化器时，不应调用覆盖方法（例如，查询），\r\n     在所有初始化器绑定后，我们才应由匿名typecreationbinder本身来调用，我们正在生产\r\n     结果节点。因此，在两者之间有一个额外的活页夹。\r\n \r\n","\r\n NamedTypeSymbol calls derived implementations of this method when declared base type\r\n is needed for the first time.\r\n \r\n basesBeingResolved are passed if there are any types already have their bases resolved\r\n so that the derived implementation could avoid infinite recursion\r\n ":"\r\n 当声明为基本类型时\r\n 第一次需要。\r\n \r\n 如果有任何类型已经解决了基地，则通过基地存在\r\n 因此，派生的实施可以避免无限递归\r\n \r\n","Keywords":"关键字\r\n","\r\n Perform overload resolution on the given method group, with the given arguments and names.\r\n The names can be null if no names were supplied to any arguments.\r\n ":"\r\n 用给定的参数和名称对给定方法组执行过载分辨率。\r\n 如果未向任何参数提供名称，则名称可以为null。\r\n \r\n","A zero-width negative lookahead assertion, where for the match to be successful, the input string must not match the regular expression pattern in subexpression. The matched string is not included in the match result.\r\n            \r\n            A zero-width negative lookahead asser ...":"零宽度的负lookahead断言，要成功匹配，输入字符串不得匹配子表达中的正则表达模式。匹配的字符串不包括在比赛结果中。\r\n            \r\n            零宽的负面lookahead asser ...\r\n","\r\n Returns a copy of this with the Variables property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此的副本，变量属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n The value for the NextStatement property.\r\n ":"\r\n NextStatement属性的值。\r\n \r\n","\r\n Because this method must semantically all method bodies and initializers to check for diagnostics, it may\r\n take a significant amount of time. Unlike GetDeclarationDiagnostics, diagnostics for method bodies and\r\n initializers are not cached, the any semantic information used to obtain the diagnostics is discarded.\r\n ":"\r\n 因为此方法必须从语义上所有方法主体和初始化器检查诊断，所以它可能\r\n 花大量时间。与getDeclarationDiagnostics不同，方法身体的诊断和\r\n 初始化器没有缓存，用于丢弃用于获得诊断的任何语义信息。\r\n \r\n","\r\n Generates the name of a state machine 'builder' field \r\n ":"\r\n 生成状态机的名称“构建器”字段\r\n \r\n","\r\n Rewrites the tree to account for destructive nature of stack local reads.\r\n \r\n Typically, last read stays as-is and local is destroyed by the read.\r\n Intermediate reads are rewritten as Dups -\r\n \r\n       NotLastUse(X_stackLocal) ===> NotLastUse(Dup)\r\n       LastUse(X_stackLocal) ===> LastUse(X_stackLocal)\r\n \r\n ":"\r\n 重写树以说明堆栈本地读取的破坏性性质。\r\n \r\n 通常，上次读取的原样和本地被读取而被摧毁。\r\n 中间读取被重写为dups-\r\n \r\n       notlastuse（x_stacklocal）===> notlastuse（dup）\r\n       lastuse（x_stacklocal）===> lastuse（x_stacklocal）\r\n \r\n \r\n","\r\n            Get diagnostics stored in the source.\r\n            ":"\r\n            获取存储在源中的诊断。\r\n            \r\n","Add accessibility modifiers":"添加可访问性修饰符\r\n","s[s.Length - n]":"s [s.length -n]\r\n","\r\n Returns the assembly containing this symbol. If this symbol is shared\r\n across multiple assemblies, or doesn't belong to an assembly, returns Nothing.\r\n ":"\r\n 返回包含此符号的组件。如果共享此符号\r\n 在多个组件中，或不属于装配物，什么都没有返回。\r\n \r\n","\r\n            Helper class that allows us to share lots of logic between the diagnostic analyzer and the\r\n            code refactoring provider.  Those can't share a common base class due to their own inheritance\r\n            requirements with ":"\r\n            帮助我们在诊断分析仪和\r\n            代码重构提供商。这些由于自己的继承而无法共享普通基类\r\n            要求\r\n","An object that supplies culture-specific format information about format.":"提供有关格式的特定格式信息的对象。\r\n"," Currently set to 32 because of COM+ array type limits ":"当前由于COM+数组类型限制而设置为32\r\n","'{0}' is not a valid calling convention specifier for a function pointer.":"'{0}'不是函数指针的有效调用惯例指定符。\r\n","\r\n Returns True if this conversion a widening value type conversion or a narrowing value type conversion as defined in\r\n section 8.6.\r\n ":"\r\n 如果此转换的延伸值类型转换或定义的缩小值类型转换，则返回true\r\n 第8.6节。\r\n \r\n","\r\n The \"UL\" literal suffix denoting \"ULong\"\r\n ":"\r\n 表示“ ulong”的“ ul”字面后缀\r\n \r\n","expression to be used in the last 'Select' invocation":"在最后的“选择”调用中使用的表达式\r\n","\r\n            Snippet triggering follows the default rules of the language.\r\n            ":"\r\n            摘要触发遵循语言的默认规则。\r\n            \r\n"," passing in ":" 传递\r\n","\r\n of the parser.  If it is not available a diagnostic will be added to the returned value.\r\n ":"\r\n 解析器。如果不可用，则将诊断添加到返回的值中。\r\n \r\n","The initializer syntax for the property.":"属性的初始化语法。\r\n","\r\n  Looks up a localized string similar to Multiline lambda expression is missing 'End Function'..\r\n":"\r\n  查找类似于Multiline Lambda表达式类似的局部字符串，缺少“ END函数”。\r\n\r\n","\r\n By default, the work associated with this method will be executed immediately on the current thread.\r\n Implementations that wish to schedule this work differently should override ":"\r\n 默认情况下，与此方法关联的工作将立即在当前线程上执行。\r\n 希望以不同方式安排这项工作的实施应覆盖\r\n","\r\n The \"Resume\" keyword.\r\n ":"\r\n “简历”关键字。\r\n \r\n","The index where the non-whitespace starts, or -1 if there is no non-whitespace trivia.":"非空白开始的索引，如果没有非空白琐事，则为-1。\r\n"," \r\n If an assembly referenced by this module isn't exactly matching any reference given to compilation \r\n the Assembly Manager might decide to use another reference if it matches except for version \r\n (it unifies the version with the existing reference).  \r\n ":" \r\n 如果该模块引用的组件不完全匹配任何对汇编的引用\r\n 汇编经理可能会决定使用另一个参考，如果匹配版本除外\r\n （它将版本与现有引用统一）。\r\n \r\n","Add argument name '{0}'":"添加参数名称'{0}'\r\n","\r\n                Optionally, the service supports capping the reference count to a value specified by ":"\r\n                可选地，该服务支持将参考计数限制为指定的值\r\n","\r\n A not-null collection of synthesized methods generated for the current source type.\r\n ":"\r\n 为当前源类型生成的合成方法的非核算集合。\r\n \r\n"," \r\n Method binds member access in case when we got hold \r\n of a bound node representing the left expression \r\n ":" \r\n 方法在我们握住时绑定会员访问\r\n 代表左表达式的结合节点\r\n \r\n","\r\n  Looks up a localized string similar to 'GoTo {0}' is not valid because '{0}' is inside a 'With' statement that does not contain this statement..\r\n":"\r\n  查找类似于'goto {0}'的本地化字符串是无效的，因为'{0}'在A内部'带有“不包含此语句的语句”的语句。\r\n\r\n","\r\n A structure used to lexically order symbols. For performance, it's important that this be \r\n a STRUCTURE, and be able to be returned from a symbol without doing any additional allocations (even\r\n if nothing is cached yet.)\r\n ":"用于词汇订购符号的结构。为了表现，重要的是\r\n 结构，并且能够从符号中返回而无需进行任何其他分配（甚至\r\n 如果什么都没有缓存。）\r\n \r\n","\r\n            Raise this when new diagnostics are found\r\n            ":"\r\n            当发现新诊断时提出这一点\r\n            \r\n","Full path name of the resolved assembly":"已解决的组装的完整路径名\r\n","\r\n True if the parameter flows data out of the method.\r\n ":"\r\n 如果参数从该方法中流出数据，则为true。\r\n \r\n","\r\n Represents tokens that were skipped by the parser as part of error recovery,\r\n and thus are not part of any syntactic structure.\r\n ":"\r\n 代表被解析器跳过的代币作为错误恢复的一部分，\r\n 因此，不是任何句法结构的一部分。\r\n \r\n","\r\n Indicates whether the compiler accepted or rejected the method during overload resolution.\r\n ":"\r\n 指示编译器在过载分辨率期间是否接受或拒绝该方法。\r\n \r\n","\r\n Returns true if this method has no return type; i.e., is a Sub instead of a Function.\r\n ":"\r\n 如果此方法没有返回类型，则返回true；即，是子而不是函数。\r\n \r\n","\r\n            A ```.``` expression.\r\n            ":"\r\n            ````````''表达。\r\n            \r\n","\r\n Return the overridden symbol for either a method or property.\r\n ":"\r\n 返回方法或属性的覆盖符号。\r\n \r\n","long date":"长约日期\r\n","\r\n Given an CollectionRangeVariableSyntax, get the corresponding symbol.\r\n ":"\r\n 给定一个CollectionRangeVariablesyntax，获取相应的符号。\r\n \r\n","\r\n True iff the method contains user code.\r\n ":"\r\n 正确，如果方法包含用户代码。\r\n \r\n","'default' expression can be simplified":"可以简化“默认”表达式\r\n","\\W matches any non-word character. It matches any character except for those in the following Unicode categories:\r\n            \r\n                Ll\tLetter, Lowercase\r\n                Lu\tLetter, Uppercase\r\n                Lt\tLetter, Titlecase\r\n                Lo\tLetter, Other\r\n                Lm\tLetter, Modifier\r\n                Mn\tMark, Nonspaci ...":"\\ w匹配任何非单词字符。除了以下Unicode类别中的那些字符外，它匹配任何字符：\r\n            \r\n                LL字母，小写\r\n                lu信，大写\r\n                上字母，滴定酶\r\n                LO信，其他\r\n                LM字母，修饰符\r\n                Mn Mark，Nonspaci ...\r\n","\r\n Parse an expression.\r\n ":"\r\n 解析表达。\r\n \r\n","\r\n The value for the MinusMinusGreaterThanToken property.\r\n ":"\r\n MINUSMINUSGREATERTHANTOKEN财产的价值。\r\n \r\n","\r\n Frees an optional temp.\r\n ":"\r\n 释放一个可选的温度。\r\n \r\n","\r\n            ```expr*```\r\n            ":"\r\n            ````expr*''\r\n            \r\n","\r\n            The text of the section without tags.\r\n            ":"\r\n            没有标签的部分文本。\r\n            \r\n","Remove unused parameter":"删除未使用的参数\r\n","\r\n The value for the ElseKeyword property.\r\n ":"\r\n ElseKeyword属性的值。\r\n \r\n","\r\n Returns a copy of this with the WhileOrUntilKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中wheoruntilkeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Represents an interpolation of an expression in an interpolated string\r\n expression e.g. '{expression[,alignment][:formatString]}'.\r\n ":"\r\n 表示在插值字符串中表达式的插值\r\n 表达，例如'{expression [，对齐] [：formatstring]}'。\r\n \r\n","\r\n            \r\n            i.e. both branches will be on a newline, indented once from the parent indentation.\r\n            ":"\r\n            \r\n            即，两个分支都将在一个新线上，一次从父母的缩进中缩进。\r\n            \r\n","The ROA of members that are being implemented":"正在实施的成员的ROA\r\n"," are used\r\n to indicate that the lazy values have been computed and, if ":" 被使用\r\n 表明已经计算了懒惰的值，如果\r\n","\r\n            Code action for actually wrapping items.  Provided as a special subclass because it will\r\n            also update the wrapping most-recently-used list when the code action is actually\r\n            invoked.\r\n            ":"\r\n            实际包装项目的代码操作。作为特殊子类提供\r\n            还要在代码操作实际上更新包装列表\r\n            调用。\r\n            \r\n","\r\n Gets the special type member.\r\n ":"\r\n 获取特殊类型的成员。\r\n \r\n","'{0}' is not a valid parameter name from '{1}'.":"'{0}'不是来自'{1}'的有效参数名称。\r\n","\r\n Represents a reference to a generic type instantiation that is not nested.\r\n e.g. MyNamespace.A{int}\r\n ":"\r\n 表示对未嵌套的通用类型实例化的引用。\r\n 例如mynamespace.a {int}\r\n \r\n","\r\n  Looks up a localized string similar to Type of '{0}' cannot be inferred from an expression containing '{0}'..\r\n":"\r\n  查找类似于“ {0}”类型类型的本地化字符串，无法从包含'{0}'..\r\n\r\n","Asynchronously waits for the task to finish.":"异步等待任务完成。\r\n","Lambda body rewritten as a body of the given method symbol.":"Lambda身体重写为给定方法符号的主体。\r\n","\r\n Generates the name of a state machine field name for captured me reference\r\n ":"\r\n 生成状态机字段名称的名称供捕获我参考\r\n \r\n","\r\n            If all the ":"\r\n            如果所有的 \r\n","\r\n Returns a copy of this with the InKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中inkeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n if(x, y) becomes\r\n   push x\r\n   dup x\r\n   if pop isnot null goto LEFT_NOT_NULL\r\n     pop \r\n     push y\r\n   LEFT_NOT_NULL:\r\n ":"\r\n 如果（x，y）变为\r\n   推x\r\n   dup x\r\n   如果pop ison null goto left_not_null\r\n     流行音乐\r\n     推y\r\n   left_not_null：\r\n \r\n","\r\n  Looks up a localized string similar to 'End Interface' must be preceded by a matching 'Interface'..\r\n":"\r\n  查找类似于“ End接口”的本地化字符串必须先于匹配的“接口”。\r\n\r\n"," is specified.\r\n \r\n The default value can be obtained with the ":" 指定。\r\n \r\n 默认值可以通过\r\n","\r\n Returns the value of the Option Infer declaration if there was one, otherwise Null.\r\n ":"\r\n 如果有一个，则返回选项的值推断声明的值，否则为null。\r\n \r\n","\r\n The For Each statement that begins the block.\r\n ":"\r\n 对于开始块的每个语句。\r\n \r\n","\r\n The label name (identifier), line number (integer literal), or next keyword\r\n token.\r\n ":"\r\n 标签名称（标识符），行号（整数字面）或下一个关键字\r\n 令牌。\r\n \r\n","A collection of GlobalImports.":"全球IMPORTS的集合。\r\n","\r\n Symbol representing open generic type directly or indirectly contained within constructed\r\n generic type.\r\n For example: A(Of Integer).B(Of ) or A(Of Integer).B.C(Of , )\r\n ":"\r\n 符号代表直接或间接包含的开放通用类型\r\n 通用类型。\r\n 例如：a（integer）.b（of）或a（integer）.b.c（of，）\r\n \r\n","\r\n The value for the EndTag property.\r\n ":"\r\n EndTag属性的值。\r\n \r\n","Matches a vertical-tab character, \\u000B":"匹配垂直标签字符\\ u000b\r\n","\r\n  Looks up a localized string similar to 'Only the 'Async' or 'Iterator' modifier is valid on a lambda..\r\n":"\r\n  查找类似于“ async”或“迭代器”修饰符在lambda上有效的局部字符串。\r\n\r\n","\r\n Returns the type arguments that have been substituted for the type parameters. \r\n If nothing has been substituted for a give type parameters,\r\n then the type parameter itself is consider the type argument.\r\n ":"\r\n 返回已替换为类型参数的类型参数。\r\n 如果什么都没有代替给出类型参数，\r\n 然后，类型参数本身为类型参数。\r\n \r\n","\r\n  Looks up a localized string similar to Statement cannot appear within an Enum body..\r\n":"\r\n  查找类似于语句的本地化字符串，无法出现在枚举主体中。\r\n\r\n","\r\n  Looks up a localized string similar to Class in an interface cannot be declared '{0}'..\r\n":"\r\n  查找与接口类似的局部字符串，无法声明“ {0}”。\r\n\r\n","\r\n            Gets inline hints for type locations.  This is an internal service only for C# and VB.  Use ":"\r\n            获取类型位置的内联提示。这仅是C＃和VB的内部服务。利用\r\n","match at least 'n' times (lazy)":"匹配至少“ n”时间（懒惰）\r\n","\r\n Global namespace. \r\n ":"\r\n 全局名称空间。\r\n \r\n"," for indexer expression bodies.\r\n            ":" 用于索引表达体。\r\n            \r\n","\r\n Lookup a member name in a submission chain.\r\n ":"\r\n 在提交链中查找成员名称。\r\n \r\n","\r\n The expression that is the operand of the With statement.\r\n ":"\r\n 表达式是用语句的操作数。\r\n \r\n","\r\n            For testing only. Changing the default value in actual product might cause perf issues.\r\n            ":"\r\n            仅用于测试。更改实际产品中的默认值可能会导致PERT问题。\r\n            \r\n","\r\n If the control variable was bound to a non bad expression, this function checks if the \r\n bound expression is a variable and reports diagnostics appropriately.\r\n It reports the errors from 10.9.3 2.2\r\n ":"\r\n 如果控制变量与非坏表达式绑定，则此函数检查是否\r\n 绑定表达是一个变量，并适当地报告诊断。\r\n 它报告了10.9.3 2.2的错误\r\n \r\n","The offset within the file at which the header ended.":"标头结束的文件内的偏移量。\r\n","The currently set core compilation options.":"当前设置的核心汇编选项。\r\n","\r\n Bind a Query Expression.\r\n This is the entry point.\r\n ":"\r\n 绑定查询表达式。\r\n 这是入口点。\r\n \r\n","\r\n Returns a copy of this with the ForEachStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中foreachstatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n  Looks up a localized string similar to 'End Function' expected..\r\n":"\r\n  查找类似于预期的“最终功能”的本地化字符串。\r\n\r\n","\r\n if (b, x, y) becomes\r\n     push b\r\n     if pop then goto CONSEQUENCE\r\n     push y\r\n     goto DONE\r\n   CONSEQUENCE:\r\n     push x\r\n   DONE:\r\n ":"\r\n 如果（b，x，y）变为\r\n     推b\r\n     如果流行随后得到结果\r\n     推y\r\n     完成了\r\n   结果：\r\n     推x\r\n   完毕：\r\n \r\n","\r\n If this method can be applied to an object, returns the type of object it is applied to.\r\n ":"\r\n 如果可以将此方法应用于对象，请返回其应用于对象的类型。\r\n \r\n","\r\n A map from Operator name to number of parameters and kind.\r\n ":"\r\n 从操作员名称到参数和类型的地图。\r\n \r\n","\r\n The event being accessed.\r\n ":"\r\n 活动正在访问。\r\n \r\n","\r\n Gets the filename of the first declaration that matches the given namespace name case sensitively.\r\n ":"\r\n 获取第一个声明的文件名，该声明敏感地匹配给定名称空间案例。\r\n \r\n","\r\n            Should also return given node. \r\n            ":"\r\n            还应返回给定的节点。\r\n            \r\n","\r\n  Looks up a localized string similar to Instance members and 'Me' cannot be used within a lambda expression in structures..\r\n":"\r\n  查找类似于实例成员的本地化字符串，并且在结构中的lambda表达式中无法使用“ me”。\r\n\r\n","\r\n The name of the pre-processing constant being defined.\r\n ":"\r\n 定义预处理常数的名称。\r\n \r\n","\r\n This is an entry point for the Binder to collect extension methods with the given name \r\n declared within this (compilation merged or module level) namespace, so that methods \r\n from the same type are grouped together. \r\n ":"\r\n 这是粘合剂收集带有名称的扩展方法的切入点\r\n 在此（汇编合并或模块级别）名称空间中声明，以便方法\r\n 从同一类型分组在一起。\r\n \r\n","100ths of a second (non-zero)":"100秒（非零）\r\n","\r\n Bind body of a lambda representing Select operator selector in context of this binder.\r\n ":"\r\n 在此粘合剂的上下文中，绑定代表选择操作符选择器的lambda的主体。\r\n \r\n","\r\n The value for the UpperBound property.\r\n ":"\r\n 上行属性的值。\r\n \r\n","The resolved method if any.":"解决方法（如果有）。\r\n","This is related to the code in ":"这与代码有关\r\n","\r\n Returns interface properties explicitly implemented by this property.\r\n ":"\r\n 返回该属性明确实现的接口属性。\r\n \r\n","\r\n            We could consider adding more information here (for example the min/max number of args that this can be\r\n            called with).  That could then be used to check if there could be a conflict. However, that's likely\r\n            more complexity than we need currently.  But it is always something we can do in the future.\r\n            ":"\r\n            我们可以考虑在此处添加更多信息（例如，最小/最大arg数字可以说这可以是\r\n            打电话给）。然后可以用来检查是否有冲突。但是，这很可能\r\n            比目前需要的更复杂。但这总是我们将来可以做的。\r\n            \r\n","\r\n            Indicate whether it would cause error if we directly pull all members in MemberAnalysisResults up to destination.\r\n            ":"\r\n            指示如果我们将所有成员分析中的所有成员直接提升到目的地，是否会导致错误。\r\n            \r\n","\r\n Returns a copy of this with the ErrorCodes property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中错误代码属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Parse NameOf, \r\n NameOfExpression -> NameOf OpenParenthesis Name CloseParenthesis \r\n ":"\r\n parse namef，\r\n namefexpression-> name of open脱骨名称近距离人物\r\n \r\n"," for field initializers.\r\n            ":" 用于现场初始化器。\r\n            \r\n","\r\n            Captures the content of a file that is about to be overwritten by saving an open document,\r\n            if the document is currently out-of-sync and the content of the file matches the PDB.\r\n            If we didn't capture the content before the save we might never be able to find a document\r\n            snapshot that matches the PDB.\r\n            ":"\r\n            捕获即将通过保存打开文档来覆盖的文件的内容，\r\n            如果该文档当前不同步，并且文件的内容与PDB匹配。\r\n            如果我们没有在保存之前捕获内容，我们可能永远无法找到文档\r\n            与PDB匹配的快照。\r\n            \r\n","\r\n            Ordinal of the active statement within the set of all active statements.\r\n            ":"\r\n            所有活动语句集合中的活动语句的序数。\r\n            \r\n"," may be filtered out entirely\r\n (by returning null).\r\n ":" 可以完全过滤掉\r\n （通过返回null）。\r\n \r\n","\r\n  Looks up a localized string similar to Cannot emit debug information for a source text without encoding..\r\n":"\r\n  在不编码的情况下查找类似于源文本的本地化字符串无法发出调试信息。\r\n\r\n","\r\n Bind an initializer for an implicitly allocated array field (for example: Private F(2) As Object).\r\n ":"\r\n 绑定一个隐式分配的数组字段的初始器（例如：私有f（2）作为对象）。\r\n \r\n","\r\n            Gets the dot-like token we're after, and also the start of the expression we'd want to place any text before.\r\n            ":"\r\n            获取我们所追求的类似点的令牌，也是我们要放置任何文本的表达式的开始。\r\n            \r\n","\r\n Push any nodes that have errors in the given collection onto a stack\r\n ":"\r\n 将任何在给定集合中有错误的节点推到堆栈上\r\n \r\n","The source node or token.":"源节点或令牌。\r\n","\r\n Returns a copy of this with the NameColonEquals property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中Namecolonequals属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","Modifying {0} which contains a static variable requires restarting the application.":"包含静态变量的修改{0}需要重新启动应用程序。\r\n","\r\n            Implementing class, struct and interface for interface. Shown as I↓\r\n            ":"\r\n            实现界面的类，结构和接口。显示在我↓\r\n            \r\n","\r\n The value for the DisableKeyword property.\r\n ":"\r\n disableyword属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to '=' expected (object initializer)..\r\n":"\r\n  查找类似于'='预期的本地化字符串（对象初始化器）。\r\n\r\n","\r\n A param or type param symbol referenced by a name attribute (e.g. in a\r\n <param> or <typeparam> documentation comment tag). For example, the\r\n M in <param name=\"M\" />.\r\n ":"\r\n 名称属性引用的参数或类型param符号（例如\r\n <param>或<typeparam>文档注释标签）。例如，\r\n m in <param name =“ m” />。\r\n \r\n","\r\n Gets the type of the property. \r\n ":"\r\n 获取属性的类型。\r\n \r\n","The bound AddressOf expression itself.":"表达式本身的绑定地址。\r\n","local variable declaration":"本地变量声明\r\n","Create and assign remaining as properties":"创建并分配剩余作为属性\r\n","Application entry points cannot be attributed with 'UnmanagedCallersOnly'.":"应用程序入口点不能用“无管理的核心”归因于。\r\n","\r\n The value for the Tokens property.\r\n ":"\r\n 令牌属性的值。\r\n \r\n","selection whose trivia around its edges will be saved":"选择其边缘周围的琐事\r\n"," is null, where it's an in-memory assembly.\r\n            ":" 是零，它是内存组件。\r\n            \r\n","\r\n The value for the ForEachStatement property.\r\n ":"\r\n foreachstatement属性的价值。\r\n \r\n","awaitable":"等待\r\n","The semantic model for the document.":"文档的语义模型。\r\n","Allow unsafe code in this project":"在此项目中允许不安全的代码\r\n","\r\n            The matching algorithm should give this item no special treatment.\r\n            \r\n            Ordinary ":"\r\n            匹配算法应不给予此特殊处理。\r\n            \r\n            普通的\r\n"," \r\n Returns a bound node for left part of member access node with omitted left syntax. \r\n In particular it handles member access inside With statement.\r\n \r\n By default the method delegates the work to it's containing binder or returns Nothing.\r\n ":"返回具有省略左语法的成员访问节点左侧的界点。\r\n 特别是它可以处理内部的成员访问。\r\n \r\n 默认情况下，该方法将工作委托给包含粘合剂或什么都没有返回。\r\n \r\n","\r\n This class provides an easy way to combine a MethodSignatureComparer and a PropertySignatureComparer\r\n to create a unified MemberSignatureComparer (e.g. for use in a HashSet).\r\n ":"\r\n 该课程提供了一种简单的方法来组合MethodsignatureComparer和propertySignatureComparer\r\n 创建一个统一的成员dignaturecomparer（例如用于标签）。\r\n \r\n"," for property initializers and expression bodies.\r\n            ":" 用于属性初始化器和表达体。\r\n            \r\n","Adding an extern {0} requires restarting the application.":"添加外部{0}需要重新启动应用程序。\r\n","The position of the caret after the triggering action.":"触发动作后的嘉年华的位置。\r\n","\r\n Optional Select method to handle AsClause.\r\n ":"\r\n 可选的选择方法来处理Asclause。\r\n \r\n","\r\n            If we're adding ":"\r\n            如果我们要添加\r\n","\r\n            Creates new code actions for each introduce parameter possibility.\r\n            Does not create actions for overloads/trampoline if there are optional parameters or if the methodSymbol\r\n            is a constructor.\r\n            ":"\r\n            为每个引入参数可能创建新的代码操作。\r\n            如果有可选参数，则不会为超载/蹦床创建动作\r\n            是一个构造函数。\r\n            \r\n","\r\n Code if the #If False out is code ported from C# that isn't currently used, and\r\n hence has no code coverage. It may or may not work correctly, but should be a useful\r\n starting point.\r\n ":"\r\n 代码如果#if false是从当前未使用的C＃移植的代码，并且\r\n 因此，没有代码覆盖范围。它可能正常工作，也可能无法正常工作，但应该是有用的\r\n 初始点。\r\n \r\n","\r\n Possibly create the array version of type, given the element type and the array modifier syntax.\r\n ":"\r\n 给定元素类型和数组修饰符语法，可能创建类型的数组版本。\r\n \r\n","\r\n For delegate types, gets the delegate's invoke method.  Returns null on\r\n all other kinds of types.  Note that it is possible to have an ill-formed \r\n delegate type imported from metadata which does not have an Invoke method.\r\n Such a type will be classified as a delegate but its DelegateInvokeMethod\r\n would be null.\r\n ":"\r\n 对于委托类型，获取代表的调用方法。返回null\r\n 所有其他类型。请注意，可能有一个不良的\r\n 从元数据中导入的委托类型，该类型没有调用方法。\r\n 这种类型将被归类为代表，但其委托\r\n 将是无效的。\r\n \r\n","The period character (.) matches any character except \\n (the newline character, \\u000A).  If a regular expression pattern is modified by the RegexOptions.Singleline option, or if the portion of the pattern that contains the . character class is modified b ...":"周期字符（。）匹配除\\ n（newline字符，\\ u000a）之外的任何字符。如果正则表达式模式通过Regexoptions.Singleline选项修改，或者包​​含的模式的部分。字符类已修改B ...\r\n","\r\n A try block might have no state (transitions) within it, in which case it does not need\r\n to have a state to represent finalization.  This flag tells us whether the current try\r\n block that we are within has a finalizer state.  Initially true as we have the (trivial)\r\n finalizer state of -1 at the top level.\r\n ":"\r\n 尝试块可能没有状态（过渡），在这种情况下，它不需要\r\n 具有代表最终确定的状态。这个标志告诉我们当前是否尝试\r\n 我们所在的块具有最终确定性状态。最初是正确的，因为我们有（琐碎）\r\n 最终确定性为-1处于最高级别。\r\n \r\n"," has been obtained\r\n             for use in a ":" 已获得\r\n             用于使用\r\n","\r\n            This will update documents in the specified projects so that their namespace matches the RootNamespace\r\n            and their relative folder path.\r\n            ":"\r\n            这将在指定项目中更新文档，以便其名称空间与rootnamespace匹配\r\n            及其相对文件夹路径。\r\n            \r\n","\r\n This method must be invoked only after all the assembly attributes have been bound.\r\n ":"\r\n 只有在所有汇编属性绑定后才调用此方法。\r\n \r\n","\r\n The list of tokens that were skipped by the parser.\r\n ":"\r\n 被解析器跳过的令牌列表。\r\n \r\n","\r\n            Inserts the given declaration statement at the start of the given switch case block.\r\n            ":"\r\n            在给定开关案例块的开头插入给定的声明语句。\r\n            \r\n","A string to use for formatting.":"用于格式化的字符串。\r\n","\r\n            Check if ":"\r\n            检查是否\r\n",".  For example if inserting `\\p{Number}` into a normal C#\r\n            string token, the `\\` would have to be escaped into `\\\\`.  However in a verbatim-string\r\n            literal (i.e. `@\"...\"`) it would not have to be escaped.\r\n            ":"。例如，如果将`\\ p {number}插入普通C＃中\r\n            字符串令牌，``\\'必须逃脱到``\\\\''中。但是在逐字弦上\r\n            字面意思（即`@@@“ ...”`）不必逃脱。\r\n            \r\n","\r\n            The indentation string necessary to indent an item in a list such that the start of\r\n            that item will exact start at the end of the open-token for the containing list. i.e.\r\n            \r\n                void Goobar(\r\n                            ^\r\n                            |\r\n            \r\n            This is the indentation we want when we're aligning wrapped items with the first item \r\n            in the list.\r\n            ":"\r\n            缩进列表中的项目所需的缩进字符串，使得\r\n            该项目将在包含列表的“开放式”末端精确启动。 IE。\r\n            \r\n                void guobar（\r\n                            ^\r\n                            |\r\n            \r\n            当我们将包装物品与第一项对齐时，这是我们想要的凹痕\r\n            在列表中。\r\n            \r\n","root node to the annotated tree":"根节点到注释树\r\n","\r\n            Supports simplifying cast expressions like ":"\r\n            支持简化的铸造表达\r\n","all separator characters":"所有分离器字符\r\n","\r\n note that state is applied only to the token #1\r\n ":"\r\n 请注意，状态仅适用于令牌＃1\r\n \r\n","\r\n Look up the given metadata type, if it Is forwarded.\r\n ":"\r\n 如果转发，请查找给定的元数据类型。\r\n \r\n","\r\n The method's parameter list including the parentheses. If no parameter list was\r\n present, Nothing is returned.\r\n ":"\r\n 该方法的参数列表包括括号。如果没有参数列表\r\n 目前，什么都没有归还。\r\n \r\n","\r\n Checks for errors in the constant initialization of a field, and only returns a BoundFieldOrPropertyInitializer for\r\n decimals and dates because they aren't compile time constant in CLR. Other data type end up directly in metadata and \r\n do not cause a BoundFieldOrPropertyInitializer node.\r\n ":"\r\n 检查字段恒定初始化中的错误，并且仅返回boundfieldorproperpyinitializer\r\n 小数和日期是因为它们不是CLR中的编译时间常数。其他数据类型直接进入元数据，并\r\n 请勿引起界面properperyinitializer节点。\r\n \r\n","\r\n Const fields do not (always) have to be declared with a given type. To get the inferred type determined from\r\n the initialization this method should be called instead of \"Type\". For non const field this method returns the\r\n declared type.\r\n ":"\r\n const字段不得（总是）用给定类型声明。从\r\n 初始化此方法应称为“类型”。对于非const字段，此方法返回\r\n 声明类型。\r\n \r\n","\r\n If the expression underwent an implicit conversion, return information about that\r\n conversion. Otherwise, returns an identity conversion.\r\n ":"\r\n 如果表达式进行了隐式转换，请返回有关该的信息\r\n 转换。否则，返回身份转换。\r\n \r\n","The control variable.":"控制变量。\r\n","\r\n            Returns null if a breakpoint can't be placed at the specified position.\r\n            ":"\r\n            如果无法将断点放置在指定位置，则返回null。\r\n            \r\n","The type to use as a context for the check.":"用作检查上下文的类型。\r\n","\r\n Gets the static initializers.\r\n ":"\r\n 获取静态初始化器。\r\n \r\n","The selection contains an error or unknown type.":"选择包含错误或未知类型。\r\n"," representing the specific kind of LabelSyntax. One of\r\n IdentifierLabel, NumericLabel, NextLabel.\r\n ":" 代表特定类型的标记字符。之一\r\n 识别标签，NumericLabel，NextLabel。\r\n \r\n","\r\n Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.\r\n This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.\r\n ":"\r\n 如果没有过时的属性，则返回从过时属性或null解码的数据。\r\n 该属性返回OmpoleTeatTribedata.Nitialized如果属性参数尚未解码。\r\n \r\n","\r\n Symbol to copy bound attributes from, or null if the attributes are not shared among multiple source method symbols.\r\n ":"\r\n 符号以从多个源方法符号之间共享属性，以复制绑定属性或null。\r\n \r\n","\r\n            This is in charge of anything related to ":"\r\n            这是负责与\r\n","\r\n Returns a copy of this with the FinallyStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，最后施说属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n"," if this instance is sub; otherwise, ":" 如果此实例为sub；否则，\r\n","An expression tree may not contain a null coalescing assignment":"表达树可能不包含无效的合并作业\r\n","\r\n            ```(?>expr)``` node.\r\n            ":"\r\n            ``（？> expr）````node''。\r\n            \r\n","\r\n Create a new ArrayTypeSymbol.\r\n ":"\r\n 创建一个新的arraytypesymbol。\r\n \r\n","\r\n            if (cond)\r\n            {\r\n            }\r\n            NextStatement();\r\n            ":"\r\n            if（cond）\r\n            {\r\n            }\r\n            NextStatement（）;\r\n            \r\n"," to provide a reasonable alternative.\r\n            ":" 提供合理的选择。\r\n            \r\n","\r\n Represents the members of the default namespace for this source file: all the\r\n top-level type and namespace declarations in the file. May also contain\r\n Statements that are not valid\r\n ":"\r\n 代表此源文件的默认名称空间的成员：所有\r\n 文件中的顶级类型和名称空间声明。也可能包含\r\n 无效的陈述\r\n \r\n","\r\n A BinderBuilder builds a linked list of Binder objects for various typical binders.\r\n \r\n Typically the binder chain looks something like this:\r\n    BackstopBinder\r\n    SourceModuleBinder\r\n    TypesOfImportedNamespacesMembersBinder (for modules of project-level imported namespaces)\r\n    ImportedTypesAndNamespacesMembersBinder (for project-level imported namespaces and types)\r\n    ImportAliasesBinder (for project-level import aliases)\r\n    SourceFileBinder\r\n    TypesOfImportedNamespacesMembersBinder (for modules of file-level imported namespaces)\r\n    ImportedTypesAndNamespacesMembersBinder (for file-level imported namespaces and types)\r\n    ImportAliasesBinder (for file-level import aliases)\r\n    NamespaceBinder... (for each namespace, starting at the global namespace)\r\n    TypeBinder... (for each type, and nested type)\r\n  (maybe more)\r\n    DiagnosticBagBinder \r\n \r\n  Note: Binders are also built by the BinderCache class. Changes to how namespace and type Binders\r\n  are built may need changes there also.\r\n ":"\r\n BinderBuilder构建了各种典型粘合剂的粘合剂对象列表。\r\n \r\n 通常，粘合剂链看起来像这样：\r\n    后脚手\r\n    Sourcemodulebinder\r\n    typesofimportednamespacespacesmembersbinder（用于项目级导入名称空间的模块）\r\n    importedtypesandnamespacessmembersbinder（用于项目级导入的名称空间和类型）\r\n    ExtimaliasesBinder（用于项目级的进口别名）\r\n    SourceFileBinder\r\n    typesofimportednamespacespacesmembersbinder（用于文件级导入名称空间的模块）\r\n    importedtypesandnamespacesmembersbinder（用于文件级导入的名称空间和类型）\r\n    Exufertaliasesbinder（用于文件级导入别名）\r\n    名称空间Binder ...（对于每个名称空间，从全局名称空间开始）\r\n    typebinder ...（每种类型和嵌套类型）\r\n  （也许更多）\r\n    DiagnosticBagbinder\r\n \r\n  注意：Binders也由BinderCache类构建。更改名称空间和键入粘合剂的方式\r\n  建造可能还需要更改。\r\n \r\n","\r\n A list of all the modifier tokens that were present on this declaration. If no\r\n modifiers were specified, an empty list is returned. A bitfield version of all\r\n the modifiers ORed together, which is in many cases easier to use, can be\r\n obtained with the Modifiers property.\r\n ":"\r\n 该声明中存在的所有修饰符令牌的列表。如果不\r\n 指定了修饰符，返回一个空列表。所有的Bitfield版本\r\n 在许多情况下，可以更易于使用的修饰符，可以是\r\n 使用修饰符属性获得。\r\n \r\n","The modifier '{0}' is not valid for this item in C# {1}. Please use language version '{2}' or greater.":"修饰符'{0}'在C {1}中对此项目无效。请使用语言版本'{2}'或更大。\r\n","\r\n            True if the changes include the typed character that caused the ":"\r\n            如果更改包含引起的键入字符，则为真实\r\n","asynchronous using":"异步使用\r\n","\r\n            Constructor for a code style analyzer with a single diagnostic descriptor and\r\n            unique ":"\r\n            带有单个诊断描述符的代码样式分析仪的构造函数和\r\n            独特的\r\n","\r\n Returns a copy of this with the EndInterfaceStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回其中的副本，其中EndinterFacestatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","other, format":"其他，格式\r\n"," and the document whence the corresponding ":" 以及对应的文档\r\n","\r\n            Wrap the large && expression after every && token.\r\n            ":"\r\n            在每个&& token之后包装大&&表达式。\r\n            \r\n","\r\n Decode the modifiers on a user-defined operator, reporting errors where applicable. \r\n ":"\r\n 在用户定义的操作员上解码修饰符，在适用的情况下报告错误。\r\n \r\n","Encapsulate fields (but still use field)":"封装字段（但仍使用字段）\r\n","Inline and keep '{0}'":"内联并保持'{0}'\r\n","Conditional expression can be simplified":"有条件的表达可以简化\r\n","\r\n  Looks up a localized string similar to 'Equals' expected..\r\n":"\r\n  查找类似于预期的“平等”的局部字符串。\r\n\r\n"," trees, looking for particular\r\n            ":" 树木，寻找特定的树木\r\n            \r\n","True if the two items are Equal.":"如果这两个项目相等，则为是真的。\r\n","\r\n Returns the containing type or namespace, if this symbol is immediately contained by it.\r\n Otherwise returns Nothing.\r\n ":"\r\n 如果此符号立即包含，则返回包含类型或名称空间。\r\n 否则什么都不会返回。\r\n \r\n","\r\n The value for the Initializer property.\r\n ":"初始化器属性的值。\r\n \r\n","\r\n            Looks for types that have static methods that return the same type as the container.\r\n            e.g: int.Parse, XElement.Load, Tuple.Create etc.\r\n            ":"\r\n            寻找具有静态方法的类型，这些方法返回与容器相同的类型。\r\n            例如：int.parse，xlement.load，tuple.create等。\r\n            \r\n","Introduce local constant for all occurrences of '{0}'":"介绍所有出现“ {0}”的局部常数\r\n","The document whence the symbol came":"该符号来自该文件\r\n","\r\n  Looks up a localized string similar to Syntax error in conditional compilation expression..\r\n":"在条件汇编表达式中查找类似于语法错误的局部字符串。\r\n\r\n","\r\n            Indicates which, if any, Organize Usings features are enabled for code cleanup.\r\n            ":"\r\n            指示启用哪个组织使用功能以进行代码清理。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Select Case' must end with a matching 'End Select'..\r\n":"\r\n  查找类似于“选择案例”的本地化字符串必须以匹配的“结束选择”结尾。\r\n\r\n",") that represents the containing lambda body.\r\n ":"）代表包含的lambda身体。\r\n \r\n","\r\n Returns False if the search should be cancelled.\r\n ":"\r\n 如果应取消搜索，则返回false。\r\n \r\n"," passed to that method.\r\n            ":" 传递给该方法。\r\n            \r\n","\r\n Represents a For or For Each statement.\r\n ":"\r\n 代表每个语句或为每个语句。\r\n \r\n","\r\n Represents a single line lambda expression.\r\n ":"\r\n 代表单行lambda表达式。\r\n \r\n"," when providing quick info.\r\n            ":" 提供快速信息时。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Catch' cannot catch type '{0}' because it is not 'System.Exception' or a class that inherits from 'System.Exception'..\r\n":"\r\n  查找类似于“ catch”的本地化字符串无法捕获type'{0}'，因为它不是'System.exception'或从“ System.exception”中继承的类。\r\n\r\n"," does not apply this format to collections elements - \r\n            they are shown regardless.\r\n            ":"不将此格式应用于收藏要素 - \r\n            无论如何显示它们。\r\n            \r\n"," clauses because they are only considered multiline\r\n            when their embedded statement is multiline.":" 条款是因为它们仅被视为多行\r\n            当他们的嵌入式陈述是多行的。\r\n","\r\n Returns a copy of this with the ModuleKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中Modulekeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            Indicates the reference should be removed from the project.\r\n            ":"\r\n            指示该参考应从项目中删除。\r\n            \r\n","\r\n The name of the label. If the label is a line number, 0 or -1, wraps an\r\n IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.\r\n ":"\r\n 标签的名称。如果标签是行号，则为0或-1，请包装\r\n integerliteraltoken是行号，否则会包含标识符。\r\n \r\n","\r\n Scan text between markup\r\n ":"\r\n 标记之间的扫描文本\r\n \r\n","\r\n The value for the Signature property.\r\n ":"\r\n 签名属性的值。\r\n \r\n","\r\n            returns AdjustNewLinesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation\r\n            ":"\r\n            返回两个令牌之间的调整新线索，或者通过过滤/替换下方返回的操作\r\n            \r\n","\r\n The value for the Identifier property.\r\n ":"\r\n 标识符属性的值。\r\n \r\n","s that have same language as ":"具有与语言相同的语言\r\n","A bit-flag of the allowable modifiers. If a bit isn't set, an error occurs.":"允许修饰符的一点列。如果未设置一点，则会发生错误。\r\n","Warning: Moving using directives may change code meaning.":"警告：使用指令移动可能会更改代码含义。\r\n","\r\n            Notifies the assembly loader about a dependency that might be loaded in future.\r\n            ":"\r\n            通知装配装加载程序有关将来可能会加载的依赖项。\r\n            \r\n","\r\n            Input:\r\n            foreach(...)\r\n            {\r\n                ...\r\n                ...\r\n                list.Add(item);\r\n             }\r\n             \r\n             Output:\r\n             list.AddRange(queryGenerated);\r\n        ":"\r\n            输入：\r\n            foreach（...）\r\n            {\r\n                ...\r\n                ...\r\n                list.add（item）;\r\n             }\r\n             \r\n             输出：\r\n             list.Addrange（queryGenerated）;\r\n        \r\n","\r\n            Extractor function that checks and retrieves all nodes current location is in a header.\r\n            ":"\r\n            检查和检索所有节点当前位置的提取器函数都位于标题中。\r\n            \r\n","\r\n Generates the name of a static lambda display class instance cache\r\n ":"\r\n 生成静态lambda显示类实例缓存的名称\r\n \r\n","\r\n  Looks up a localized string similar to Multiple initializations of '{0}'.  Fields and properties can be initialized only once in an object initializer expression..\r\n":"\r\n  查找类似于“ {0}'的多个初始化的本地化”字符串。字段和属性只能在对象初始化器表达式中初始初始化一次。\r\n\r\n","\r\n The type character suffix, if present. Returns TypeCharacter.None if no type\r\n character was present. The only allowed values are None, Integer, Long,\r\n Decimal, Single, Double, and String.\r\n ":"\r\n 类型字符后缀（如果存在）。返回typecharacter.none如果没有类型\r\n 角色存在。唯一允许的值无，整数，长，\r\n 小数，单，双和字符串。\r\n \r\n","\r\n            The instruction of the active statement that is being executed.\r\n            The executing version of the method might be several generations old.\r\n            E.g. when the thread is executing an exception handling region and hasn't been remapped yet.\r\n            ":"\r\n            正在执行的主动语句的指令。\r\n            该方法的执行版本可能是几代旧的。\r\n            例如。当线程执行异常处理区域时，尚未重新拍摄。\r\n            \r\n","\r\n The value for the EndInterfaceStatement property.\r\n ":"\r\n EndInterFaCestatement属性的值。\r\n \r\n","A boolean value set to True if character represents XML whitespace.":"如果字符表示XML空格，则设置为true的布尔值。\r\n","\r\n            Sections are used to make up a ":"\r\n            部分用于组成\r\n"," patterns and extracting out the field and property\r\n            symbols use to compute the hash.\r\n            ":" 模式并提取田地和属性\r\n            符号用于计算哈希。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Module' statements can occur only at file or namespace level..\r\n":"\r\n  查找类似于“模块”语句的本地化字符串只能在文件或名称空间级别上发生。\r\n\r\n","\r\n            The final value produced by running the script.\r\n            ":"\r\n            运行脚本产生的最终值。\r\n            \r\n","\r\n Returns a copy of this with the EndNamespaceStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中endNamespaCestatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Returns a copy of this with the LibKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中libkeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Returns a copy of this with the OnKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而OnKeyWord属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n"," until disposed.\r\n            ":" 直到处置。\r\n            \r\n","'{0}' is attributed with 'UnmanagedCallersOnly' and cannot be called directly. Obtain a function pointer to this method.":"'{0}'归因于'UnmanagedCallersonly'，无法直接调用。获取该方法的功能指针。\r\n","\r\n Expand the span in the tree to encompass the\r\n nearest statements that the span overlaps.\r\n ":"\r\n 扩展树中的跨度以包含\r\n 跨度重叠的最近的语句。\r\n \r\n","\r\n  Looks up a localized string similar to Cannot infer a common type..\r\n":"\r\n  查找类似于无法推断公共类型的本地化字符串。\r\n\r\n"," }, respectively.\r\n            \r\n            May return multiple declarations if the specified ":" }， 分别。\r\n            \r\n            如果指定的话，可能会返回多个声明\r\n"," if this instance is vararg; otherwise, ":" 如果此实例为vararg;否则，\r\n","\r\n            Formats only the members in the provided document that were generated by this interface.\r\n            ":"\r\n            格式仅此接口生成的文档中的成员。\r\n            \r\n","Adding {0} into an interface method requires restarting the application.":"将{0}添加到接口方法中需要重新启动应用程序。\r\n"," and converts it to\r\n            ":" 并将其转换为\r\n            \r\n","\r\n The value for the ElementType property.\r\n ":"\r\n ElementType属性的值。\r\n \r\n","\r\n The value for the PreserveKeyword property.\r\n ":"\r\n PreserveKeyword属性的值。\r\n \r\n","\r\n The missing identifier token for this incomplete member. Should only be used to\r\n have a location for error reporting.\r\n ":"\r\n 此不完整成员的缺失标识符令牌。只能习惯\r\n 有一个错误报告的位置。\r\n \r\n","\r\n Represents the list of Option statements at the beginning of a source file.\r\n ":"\r\n 表示源文件开头的选项语句列表。\r\n \r\n","The named type that was declared.":"被声明的命名类型。\r\n","\r\n            For ChangeSignature, FAR on a delegate invoke method must cascade to BeginInvoke, \r\n            cascade through method group conversions, and discover implicit invocations that do not\r\n            mention the string \"Invoke\" or the delegate type itself. This implementation finds these\r\n            symbols by binding most identifiers and invocation expressions in the solution. \r\n            ":"\r\n            对于更改，在委托召唤方法上，必须级联开始效力，\r\n            通过方法组转换级联，并发现不可能的隐式调用\r\n            提及字符串“调用”或委托类型本身。这个实现找到了这些\r\n            通过在解决方案中绑定大多数标识符和调用表达式来通过符号。\r\n            \r\n"," that represents\r\n a namespace that couldn't be found.\r\n ":" 代表\r\n 一个找不到的名称空间。\r\n \r\n","\r\n            State for diagnostics that belong to a project at given time.\r\n            ":"\r\n            在给定时间属于项目的诊断状态。\r\n            \r\n"," appropriately so it can be inserted into \r\n            ":" 适当地将其插入\r\n            \r\n","\r\n            Base type for Parameter information, whether the parameter\r\n            is preexisting or new.\r\n            ":"\r\n            参数信息的基本类型，是否参数\r\n            是先前或新的。\r\n            \r\n","Implementing a record positional parameter '{0}' as read only requires restarting the application,":"实现记录位置参数'{0}'，因为读取仅需要重新启动应用程序，\r\n","\r\n            status code for extract method operations\r\n            ":"\r\n            提取方法操作的状态代码\r\n            \r\n","Multiple analyzer config files cannot be in the same directory ('{0}').":"多个分析仪配置文件不能在同一目录（'{0}'）中。\r\n","\r\n Assignment expressions in lowered form should always have suppressObjectClone = True\r\n ":"\r\n 以降低形式的分配表达式应始终具有抑制clone = true\r\n \r\n","\r\n Represents the list of AttributeStatements at the beginning of a source file\r\n that contain the Assembly and Module attributes.\r\n ":"\r\n 表示源文件开头的属性列表\r\n 包含组件和模块属性。\r\n \r\n","\r\n The \"Sub\" or \"Function\" keyword.\r\n ":"\r\n “ sub”或“函数”关键字。\r\n \r\n","\r\n The body of the lambda. Depending on the kind of lambda, this is either a\r\n Statement (single-line Sub lambda) or Expression (single-line Function).\r\n ":"\r\n Lambda的身体。取决于那种lambda，这是\r\n 语句（单线子lambda）或表达式（单线函数）。\r\n \r\n","Modifying a generic method requires restarting the application.":"修改通用方法需要重新启动应用程序。\r\n","\r\n An optional From or With clause to initialize the new object.\r\n ":"\r\n 来自或使用子句的可选来初始化新对象。\r\n \r\n","The source node.":"源节点。\r\n","\r\n Backstop that forms the end of the binder chain. Does nothing, and should never actually get hit. Provides\r\n asserts that methods never get called.\r\n ":"\r\n 构成粘合剂链末端的后备。什么也不做，绝对不应该被打击。提供\r\n 断言方法永远不会被调用。\r\n \r\n","\r\n Apply GetObjectValue call if needed.\r\n ":"\r\n 如果需要，应用GetObjectValue调用。\r\n \r\n","\r\n  Looks up a localized string similar to Variable of restricted type '{0}' cannot be declared in an Async or Iterator method..\r\n":"\r\n  查找类似于限制类型的变量'{0}'的局部字符串，无法在异步或迭代方法中声明。\r\n\r\n","This field may only be accessed while ":"该字段只能访问\r\n","The statements.":"声明。\r\n","local constant":"局部常数\r\n","^expr2":"^expr2\r\n","A zero-width negative lookbehind assertion, where for a match to be successful, 'subexpression' must not occur at the input string to the left of the current position. Any substring that does not match 'subexpression' is not included in the match result.\r\n            \r\n             ...":"零宽度的负相位断言，要成功的匹配，“子表达”不得在当前位置左侧的输入字符串处出现。比赛结果中不包含任何不匹配“子表达”的子字符串。\r\n            \r\n             ...\r\n","\r\n Returns a copy of this with the NextKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而NextKeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Returns True if any embedded symbols are referenced.\r\n \r\n WARNING: the referenced symbols collection may not be sealed yet!!!\r\n ":"\r\n 如果引用了任何嵌入式符号，则返回true。\r\n \r\n 警告：引用的符号集合可能尚未密封！！！\r\n \r\n"," in case the tree is null.\r\n Throws ":" 如果树为空。\r\n 扔\r\n","\r\n The name of the variable being defined.\r\n ":"\r\n 定义的变量的名称。\r\n \r\n","The code to be executed.":"要执行的代码。\r\n","\r\n Generates the name of a state machine's type.\r\n ":"\r\n 生成状态计算机类型的名称。\r\n \r\n","<namespace name>":"<名称空间名称>\r\n"," Region itself ":" 地区本身\r\n","\r\n If true then the trees are equivalent if the contained nodes and tokens declaring metadata visible symbolic information are equivalent,\r\n ignoring any differences of nodes inside method bodies or initializer expressions, otherwise all nodes and tokens must be equivalent.\r\n ":"\r\n 如果为true，则树是等效的，如果包含的节点和代币声明元数据可见的符号信息是等效的，则\r\n 忽略方法物体或初始化器表达式内部节点的任何差异，否则所有节点和令牌都必须等效。\r\n \r\n","\r\n Creates a speculative InitializerSemanticModel that allows asking semantic questions about an initializer node that did not appear in the original source code.\r\n ":"\r\n 创建一个投机性初始化词法模型，允许询问有关原始源代码中未出现的初始化器节点的语义问题。\r\n \r\n","\r\n  Looks up a localized string similar to 'Exit Property' is not valid in a Function or Sub..\r\n":"\r\n  查找类似于“退出属性”的本地化字符串在函数或sub中无效。\r\n\r\n","\r\n  Looks up a localized string similar to Cannot remove compiler special tree.\r\n":"查找类似于无法删除编译器特殊树的本地化字符串。\r\n\r\n"," are rendered in a rectangular block which is positioned\r\n            as an inline element relative to surrounding elements. The text of the ":" 在位置的矩形块中渲染\r\n            作为与周围元素的内联元素。文字\r\n","\r\n Gets the constructor used in this application of the attribute.\r\n ":"\r\n 获取在属性的此应用中使用的构造函数。\r\n \r\n","Newlines are not allowed inside a non-verbatim interpolated string":"在非verbatim插值字符串中不允许新线\r\n"," \r\n Holds information needed by With block to properly bind \r\n references to With block expression placeholder\r\n ":" \r\n 持有块所需的信息以正确绑定\r\n 用块表达占位符参考\r\n \r\n","date separator":"日期分离器\r\n","Generate explicit conversion operator in '{0}'":"在'{0}'中生成显式转换操作员\r\n","Add/remove braces for single-line control statements":"为单线控制语句添加/卸下括号\r\n","\r\n            removing escaped left brackets and replacing with space characters so they won't\r\n            impede the extraction of placeholders, yet the locations of the placeholders are\r\n            the same as in the original string.\r\n            ":"\r\n            删除逃脱的左支架并用太空字符替换，这样他们就不会\r\n            阻碍了占位符的提取，但占位符的位置是\r\n            与原始字符串相同。\r\n            \r\n","\r\n Rewrites nodes in ":"\r\n 重写节点\r\n","\r\n The value for the WhileOrUntilKeyword property.\r\n ":"\r\n theorRuntilKeyWord属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to Element names cannot use the 'xmlns' prefix..\r\n":"\r\n  查找类似于元素名称的本地化字符串无法使用“ XMLN”前缀。\r\n\r\n","\r\n Base class of a compile time constant.\r\n ":"\r\n 编译时间常数的基类。\r\n \r\n","\r\n Represents the \"ElseIf ... Then\" statement that begins an \"ElseIf\" block.\r\n ":"\r\n 代表开始一个“ elseif”块的“ elseif ...则”语句。\r\n \r\n"," is not an absolute path.":" 不是绝对路径。\r\n","\r\n The value for the DotToken property.\r\n ":"\r\n Dottoken物业的价值。\r\n \r\n","Remove tag":"删除标签\r\n","Cannot use '{0}' as a calling convention modifier.":"不能将'{0}'用作调用约定修饰符。\r\n","\r\n Gets a list of all the diagnostics associated with the trivia.\r\n ":"\r\n 获取与琐事相关的所有诊断列表。\r\n \r\n","Convert to struct":"转换为结构\r\n","\r\n The value for the Encoding property.\r\n ":"\r\n 编码属性的值。\r\n \r\n","\r\n Represents an \"Erase\" statement.\r\n ":"\r\n 代表“擦除”陈述。\r\n \r\n","\r\n Represents a For block, including the introducing statement, the body and the\r\n \"Next\" (which can be omitted if a containing For has a Next with multiple\r\n variables).\r\n ":"\r\n 代表一个用于障碍的，包括介绍陈述，身体和\r\n “下一步”（如果包含的下一个，则可以省略\r\n 变量）。\r\n \r\n","\r\n Takes a list of pairs of well-known members and constants. The constants\r\n will be passed to the field/property referenced by the well-known member.\r\n If the well-known member does Not exist in the compilation then no attribute\r\n will be synthesized.\r\n ":"\r\n 列出一对知名成员和常数。常数\r\n 将传递给著名成员引用的现场/财产。\r\n 如果汇编中不存在知名成员，则不存在属性\r\n 将合成。\r\n \r\n","indexer getter":"索引器getter\r\n"," of the active document. May be null if there is no active document\r\n            or the active document is not in the workspace.\r\n            ":" 活跃文档。如果没有活动文档，则可能是零的\r\n            或活动文档不在工作空间中。\r\n            \r\n","\r\n            Options for creating and running scripts.\r\n            ":"\r\n            创建和运行脚本的选项。\r\n            \r\n","\r\n  Looks up a localized string similar to Error creating Win32 resources: {0}.\r\n":"\r\n  查找类似于错误创建Win32资源的局部字符串：{0}。\r\n\r\n","\r\n Determines if the unicode character is a colon character.\r\n ":"\r\n 确定Unicode字符是否为结肠特征。\r\n \r\n","\r\n Represents a base type for compiler generated backing fields.\r\n ":"\r\n 代表编译器生成的备份字段的基本类型。\r\n \r\n","\r\n The value for the Types property.\r\n ":"\r\n 类型属性的值。\r\n \r\n","The \"name\" of the generic identifier, last token before\r\n            the \"&\"":"通用标识符的“名称”，最后一个令牌\r\n            这 ”＆”\r\n","\r\n            Tracks incremental progress of a find references search, we use this to\r\n            count the number of references up until a certain cap is reached and cancel the search\r\n            or until the search completes, if such a cap is not reached.\r\n            ":"\r\n            跟踪查找参考搜索的增量进度，我们将其用于\r\n            计算引用的数量，直到达到特定限额并取消搜索\r\n            或直到搜索完成为止，如果未达到这样的帽子。\r\n            \r\n","A syntax node that represents a parsed attribute. This attribute should not be\r\n present in the syntax tree associated with this object.":"表示解析属性的语法节点。这个属性不应该是\r\n 存在与此对象关联的语法树中。\r\n","The place to report errors for each generic type argument.":"报告每个通用类型参数错误的地方。\r\n"," or null, if no variable of the specified ":"或null，如果没有指定的变量\r\n"," was created against.":" 是针对的。\r\n"," if provided.\r\n            ":" 如果提供。\r\n            \r\n","\r\n  Looks up a localized string similar to '{0}.{1}' cannot be implemented more than once..\r\n":"\r\n  查找类似于'{0}的本地化字符串。{1}'不能多次实现。\r\n\r\n","\r\n            Yields potential active statements around the specified active statement\r\n            starting with siblings following the statement, then preceding the statement, follows with its parent, its following siblings, etc.\r\n            ":"\r\n            在指定的活动语句周围产生潜在的活动性语句\r\n            从声明之后的兄弟姐妹开始，然后在该语句之前，随后与其父，其以下兄弟姐妹等。\r\n            \r\n","\r\n Create a vector of n dummy type parameters.  Always reuses the same type parameter symbol\r\n for the same position.\r\n ":"\r\n 创建n个虚拟类型参数的向量。始终重复使用相同类型的参数符号\r\n 对于相同的位置。\r\n \r\n","\r\n Reclassify lambdas, array literals, etc. \r\n ":"重新分类lambdas，阵列文字等。\r\n \r\n","\r\n            Gets the top-most ":"\r\n            获得最高的\r\n","Usage: csi [option] ... [script-file.csx] [script-argument] ...\r\n            \r\n            Executes script-file.csx if specified, otherwise launches an interactive REPL (Read Eval Print Loop).\r\n            \r\n            Options:\r\n              /help                          Display this usage message (alternative form:  ...":"用法：CSI [option] ... [script-file.csx] [script-argument] ...\r\n            \r\n            执行脚本 -  file.csx如果指定，否则启动交互式repl（阅读评估打印循环）。\r\n            \r\n            选项：\r\n              /帮助显示此用法消息（替代表格：...\r\n","InterpolatedStringHandlerArgumentAttribute arguments cannot refer to the parameter the attribute is used on.":"InterpolatedStringHandlerArgumentAttribute参数无法参考属性所使用的参数。\r\n","\r\n            The algorithm for this, is as follows:\r\n            1. Fork the original document that contains the type to be moved.\r\n            2. Keep the type, required namespace containers and using statements.\r\n               remove everything else from the forked document.\r\n            3. Add this forked document to the solution.\r\n            4. Finally, update the original document and remove the type from it.\r\n            ":"\r\n            为此的算法如下：\r\n            1.分叉原始文档包含要移动的类型。\r\n            2.保持类型，所需的名称空间容器和使用语句。\r\n               从分叉文档中删除其他所有内容。\r\n            3.将此叉文档添加到解决方案中。\r\n            4.最后，更新原始文档并从中删除类型。\r\n            \r\n","\r\n  Looks up a localized string similar to '#End Region' must be preceded by a matching '#Region'..\r\n":"\r\n  查找类似于“ #end region”的本地化字符串必须先于匹配的“ #region”。\r\n\r\n","\r\n Can we access MyClass in this location. If False is returned, \r\n also returns the error id associated with that.\r\n ":"\r\n 我们可以在此位置访问myclass吗？如果返回错误，\r\n 还返回与之关联的错误ID。\r\n \r\n","Updating a reloadable type (marked by {0}) or its member requires restarting the application because is not supported by the runtime.":"更新可重新加载类型（由{0}标记）或其成员需要重新启动应用程序，因为运行时不支持。\r\n","The method or property group.":"方法或属性组。\r\n","\r\n Returns a bag of netmodule assembly attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.\r\n ":"\r\n 返回一袋NetModule组装属性和从知名属性解码的数据。返回null如果符号上没有属性。\r\n \r\n","\r\n Gets the ordinal order of this parameter. The first type parameter has ordinal zero.\r\n ":"\r\n 获取此参数的顺序顺序。第一个类型参数具有序数零。\r\n \r\n","\r\n We override GetBinder so that the BindStatement override is still\r\n in effect on nested binders.\r\n ":"\r\n 我们覆盖getBinder，以使绑定替代仍然是\r\n 实际上是嵌套的粘合剂。\r\n \r\n","Selection does not contain a valid node":"选择不包含有效节点\r\n","The BoundCollectionInitializerExpression that should be rewritten.":"应重写的BoundCollectionInitializerExpression。\r\n","\r\n Represents a block If...Then...Else...EndIf Statement. The Kind property can be\r\n used to determine if it is a block or line If.\r\n ":"\r\n 表示一个块，如果...然后... else ... endif语句。善的属性可以是\r\n 用于确定它是块还是行。\r\n \r\n","\r\n            The reason that completion was started.\r\n            ":"\r\n            开始完成的原因。\r\n            \r\n","Generate property '{1}.{0}'":"生成属性'{1}。{0}'\r\n","\r\n Make sure we retarget methods when underlying type checks their viability.\r\n ":"\r\n 确保我们重新定位方法在基本类型时检查其生存能力。\r\n \r\n","In general, most features should only convert the type if ":"通常，大多数功能只能在\r\n","\r\n Returns a copy of this with the StructureKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中constructekeword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","Prefer 'null' check over type check":"优于“ null”检查类型检查\r\n","Matching the tuple type '{0}' requires '{1}' subpatterns, but '{2}' subpatterns are present.":"匹配元组类型'{0}'需要'{1}'子图案，但是存在'{2}'子图案。\r\n","\r\n            Return nodes that represent exception handlers encompassing the given active statement node.\r\n            ":"\r\n            代表包括给定的活动语句节点的异常处理程序的返回节点。\r\n            \r\n"," Locals being used ":" 当地人正在使用\r\n","list of syntax nodes, to be removed from the forked copy.":"语法节点列表，将从分叉副本中删除。\r\n","\r\n            Analyzes the assignment expression and rejects a given declaration if it is unsuitable for implicit typing.\r\n            ":"\r\n            如果不适合隐式键入，则分析分配表达式并拒绝给定声明。\r\n            \r\n","Change to global namespace":"更改为全局名称空间\r\n","\r\n The value for the AggregateKeyword property.\r\n ":"\r\n 汇总键属性的值。\r\n \r\n","\r\n Returns a copy of this with the File property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，文件属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n Analyze data-flow within an expression. \r\n ":"\r\n 在表达式中分析数据流。\r\n \r\n","\r\n Class to represent custom attributes attached to symbols.\r\n ":"\r\n 类代表附加到符号的自定义属性。\r\n \r\n","\r\n            Gets the reference to be updated.\r\n            ":"\r\n            获取引用进行更新。\r\n            \r\n","updating usages in dependent projects":"更新依赖项目中的用法\r\n","\r\n Tells whether the method conversion is considered to be narrowing or not.\r\n ":"\r\n 告诉方法转换是否被认为是缩小的。\r\n \r\n"," representing the specific kind of\r\n PartitionWhileClauseSyntax. One of SkipWhileClause, TakeWhileClause.\r\n ":" 代表特定种类\r\n partitionwhileclausesyntax。 skipwhileclause，takewhileclause。\r\n \r\n","\r\n Overloaded Operator for Inequality ith GlobalImport Objects.\r\n ":"\r\n 不平等的超载运算符ITH GlobalImport对象。\r\n \r\n","\r\n A pending branch.  There are created for a return, break, continue, or goto statement.  The\r\n idea is that we don't know if the branch will eventually reach its destination because of an\r\n intervening finally block that cannot complete normally.  So we store them up and handle them\r\n as we complete processing each construct.  At the end of a block, if there are any pending\r\n branches to a label in that block we process the branch.  Otherwise we relay it up to the\r\n enclosing construct as a pending branch of the enclosing construct.\r\n ":"\r\n 一个待处理的分支。创建了用于返回，中断，继续或Goto语句。这\r\n 想法是，我们不知道该分支是否最终会因为\r\n 介入最终无法正常完成。所以我们将它们存放并处理它们\r\n 当我们完成处理每个构造时。在街区结束时，如果有任何待处理\r\n 分支到该块中的标签，我们处理分支。否则我们将其传达给\r\n 将构造作为封闭构造的待处理分支。\r\n \r\n","\r\n Symbol types should override this if they want to handle a specific well-known attribute.\r\n If the attribute is of a type that the symbol does not wish to handle, it should delegate back to\r\n this (base) method.\r\n ":"\r\n 如果符号类型要处理特定众所周知的属性，则应覆盖这一点。\r\n 如果属性是符号不希望处理的类型，则应将其委派给\r\n 这个（基础）方法。\r\n \r\n","The collection initializer syntax":"集合初始化器语法\r\n","\r\n The upper bound of the range.\r\n ":"\r\n 范围的上限。\r\n \r\n","\r\n  Looks up a localized string similar to 'Handles' in modules must specify a 'WithEvents' variable qualified with a single identifier..\r\n":"\r\n  查找模块中类似于“句柄”的本地化字符串必须指定具有单个标识符的“ withEvents”变量。\r\n\r\n","\r\n            Formats a new document that is being added to a project from the Add New Item dialog.\r\n            ":"\r\n            格式化一个新文档，该文档正在从“添加新项目”对话框中添加到项目中。\r\n            \r\n","\r\n Get a SemanticModel object that is associated with a range argument syntax that did not appear in\r\n this source code. This can be used to get detailed semantic information about sub-parts\r\n of this node that did not appear in source code. \r\n ":"\r\n 获取与未出现在\r\n 此源代码。这可以用来获取有关子部分的详细语义信息\r\n 该节点未出现在源代码中。\r\n \r\n","Introduce local for '{0}'":"向'{0}'介绍本地\r\n","\r\n  Looks up a localized string similar to 'ByVal' and 'ByRef' cannot be combined..\r\n":"\r\n  查找类似于“ byval”和“ byref”的本地化字符串。\r\n\r\n","\r\n  Structure containing all semantic information about an Await expression.\r\n ":"\r\n  结构包含有关等待表达的所有语义信息。\r\n \r\n"," object by parsing given display name.\r\n            ":" 通过解析给定的显示名称。\r\n            \r\n","\r\n  Looks up a localized string similar to Duplicate XML attribute '{0}'..\r\n":"\r\n  查找类似于重复X​​ML属性'{0}'..的本地化字符串。\r\n\r\n","\r\n Returns a copy of this with the WhenKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 将其返回此副本，其中wheskeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","static constructor":"静态构造函数\r\n","\r\n            Adds user defined operators to the unnamed recommendation set.\r\n            ":"\r\n            将用户定义的运算符添加到未命名的建议集中。\r\n            \r\n","\r\n Analyze control-flow within a part of a method body.\r\n ":"\r\n 在方法主体的一部分内分析控制流。\r\n \r\n","\r\n Concatenates messages for a set of DiagnosticInfo.\r\n ":"\r\n 加入一组诊断的消息。\r\n \r\n","\r\n Check whether token is end of text\r\n ":"\r\n 检查令牌是否是文本的终结\r\n \r\n","\r\n This visitor walks over a type expression looking for open types.\r\n Open types are allowed if an only if:\r\n   1) There is no constructed generic type elsewhere in the visited syntax; and\r\n   2) The open type is not used as a type argument or array/nullable\r\n        element type.\r\n ":"\r\n 该访问者浏览类型的表达式寻找开放类型。\r\n 仅当以下情况下才允许开放类型\r\n   1）在访问的语法中其他地方没有构造的通用类型；和\r\n   2）开放类型不被用作类型参数或数组/无效\r\n        元素类型。\r\n \r\n","full short date/time":"完整的短期/时间\r\n","\r\n Returns True if resolution of user defined conversions is complete, i.e. there was an operator\r\n that converts from the most specific source type to the most specific target type. \r\n This, however, doesn't mean that resolution is successful.\r\n ":"\r\n 如果完成用户定义的转换的分辨率完成，则返回true，即有一个操作员\r\n 从最特定的源类型转换为最特定的目标类型。\r\n 但是，这并不意味着解决方案是成功的。\r\n \r\n","\r\n The \"Join\" keyword.\r\n ":"\r\n “加入”关键字。\r\n \r\n","\r\n  Looks up a localized string similar to Label '{0}' is not defined..\r\n":"\r\n  查找类似于标签'{0}'的本地化字符串。\r\n\r\n","\r\n A NoPiaIllegalGenericInstantiationSymbol is a special kind of ErrorSymbol that represents\r\n a generic type instantiation that cannot cross assembly boundaries according to NoPia rules.\r\n ":"\r\n nopiaillgalgenericinstantiationsymbol是一种特殊的错误符号，代表\r\n 无法根据NOPIA规则跨组装边界的通用类型实例化。\r\n \r\n","\r\n            Use this helper to register multiple fixes (":"\r\n            使用此帮手注册多个修复程序（\r\n","\\s matches any white-space character. It is equivalent to the following escape sequences and Unicode categories:\r\n            \r\n                \\f\tThe form feed character, \\u000C\r\n                \\n\tThe newline character, \\u000A\r\n                \\r\tThe carriage return character, \\u000D\r\n                \\t\tThe tab charac ...":"\\ s匹配任何白色空间字符。它等同于以下逃生序列和Unicode类别：\r\n            \r\n                \\ f形式feed字符\\ u000c\r\n                \\ n newline字符\\ u000a\r\n                \\ r马车返回字符，\\ u000d\r\n                \\ t标签字符...\r\n","\r\n The value for the Minus property.\r\n ":"\r\n 减去属性的值。\r\n \r\n"," for symbols that matches\r\n            ":" 对于匹配的符号\r\n            \r\n","\r\n  Looks up a localized string similar to First statement of a method body cannot be on the same line as the method declaration..\r\n":"\r\n  查找类似于方法主体的第一个语句的本地化字符串不能与方法声明相同。\r\n\r\n","Feature '{0}' is not available in C# 9.0. Please use language version {1} or greater.":"C＃9.0中不可用功能'{0}'。请使用语言版本{1}或更大。\r\n"," A list of xml node syntax that will be used as the link text for the referenced item.":" XML节点语法列表，将用作引用项目的链接文本。\r\n","Naming rule violation: {0}":"命名规则违规：{0}\r\n","Rude edit":"粗鲁的编辑\r\n","\r\n            Uniquely identifies the reference.\r\n            ":"\r\n            独特地识别参考。\r\n            \r\n","\r\n Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this \r\n assembly is the Cor Library\r\n ":"\r\n 查找成员在此组件中以预定义的Corlib类型声明。只有在此时有效\r\n 集会是Cor库\r\n \r\n","\r\n  Looks up a localized string similar to Specifiers valid only at the beginning of a declaration..\r\n":"\r\n  查找类似于指定符的本地化字符串，仅在声明的开头。\r\n\r\n","\r\n  A trivia with kind WhitespaceTrivia containing a single space character.\r\n ":"\r\n  具有单个空间特征的善良的琐事。\r\n \r\n","punctuation, connector":"标点符号，连接器\r\n","\r\n Holds infrequently accessed fields. See ":"\r\n 持有很少访问的字段。看\r\n","\r\n            This class proxies requests for option values first to the ":"\r\n            此类代理首先请求选项值\r\n","Scan using rules for the start of a statement":"使用规则开始扫描声明开始\r\n","Object or collection initializer implicitly dereferences possibly null member.":"对象或收集初始化器隐式递增可能为null成员。\r\n","Returns the actual casing of the matching name.":"返回匹配名称的实际外壳。\r\n"," snapshot.\r\n            ":" 快照。\r\n            \r\n","\r\n The list of expression range variable being defined by the Let operator.\r\n ":"\r\n LET运算符定义的表达范围变量列表。\r\n \r\n","The \"M\" or \"m\" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.MonthDayPattern property. For example, the custom format string for the invariant culture is \"MMMM dd\".":"“ M”或“ M”标准格式指定符表示由当前DateTimeFormatinfo.monthdayPattern属性定义的自定义日期和时间格式字符串。例如，不变文化的自定义格式字符串是“ mmmm dd”。\r\n","\r\n  Looks up a localized string similar to the value '{1}' is invalid for option '{0}'.\r\n":"\r\n  查找类似于值'{1}'的局部字符串对于选项'{0}'是无效的。\r\n\r\n","\r\n Parse the input for trailing trivia.\r\n ":"\r\n 解析traging琐事的输入。\r\n \r\n","The syntax node that declares an enum.":"声明枚举的语法节点。\r\n","\r\n            'A' is not an attribute class\r\n            ":"\r\n            'a'不是属性类\r\n            \r\n","in {0} (project {1})":"在{0}（project {1}）中\r\n","\r\n  Parses a CollectionInitializer \r\n         CollectionInitializer -> \"{\" CollectionInitializerList \"}\"\r\n         CollectionInitializerList ->  CollectionElement {\",\" CollectionElement}*\r\n         CollectionElement -> Expression | CollectionInitializer\r\n ":"\r\n  解析收集器\r\n         CollectionInitializer->“ {” CollectionInitializerList“}”\r\n         CollectionInitializerList-> CollectionElement {“，” CollectionElement}*\r\n         Collectionlement->表达式| CollectionInitializer\r\n \r\n","Error ID to report if a bad modifier is found.":"错误ID报告是否找到了不良修饰符。\r\n","Place diagnostics here.":"将诊断放在这里。\r\n"," Represents variable symbol combined with the containing variable slot ":"代表可变符号与包含的变量插槽结合\r\n","\r\n Do not look for extension methods.\r\n ":"\r\n 不要寻找扩展方法。\r\n \r\n","The containing type.":"包含类型。\r\n","obj is TestFile file && file.Name == \"Test\"":"OBJ是testfile文件&& file.name ==“测试”\r\n","\r\n  Looks up a localized string similar to The type of the 'AddHandler' method's parameter must be the same as the type of the event..\r\n":"\r\n  查找类似于“ Addhandler”方法的参数类型的本地化字符串必须与事件类型相同。\r\n\r\n","\r\n            If current context is in active region, returns available symbols. Otherwise, returns null.\r\n            ":"\r\n            如果当前上下文在活动区域​​中，则返回可用的符号。否则，返回null。\r\n            \r\n","\r\n If this method has MethodKind of MethodKind.PropertyGet or MethodKind.PropertySet,\r\n returns the property that this method is the getter or setter for.\r\n If this method has MethodKind of MethodKind.EventAdd or MethodKind.EventRemove,\r\n returns the event that this method is the adder or remover for.\r\n ":"\r\n 如果此方法具有MethodKind.propertyget或MethodKind.propertyset的MethodKind，则\r\n 返回此方法是Getter或setter的属性。\r\n 如果此方法具有MethodKind.eventadd或MethodKind.eventremove的MethodKind，则\r\n 返回此方法是加法器或去除剂的事件。\r\n \r\n","\r\n  Looks up a localized string similar to For loop control variable '{0}' already in use by an enclosing For loop..\r\n":"\r\n  查找类似于循环控制变量'{0}'的本地化字符串，已通过封闭式循环使用。\r\n\r\n","Use expression body for lambda expressions":"将表达式用于lambda表达式\r\n","\r\n            Test purpose only.\r\n            ":"仅测试目的。\r\n            \r\n","\r\n  Looks up a localized string similar to 'ReadOnly' and 'WriteOnly' cannot be combined..\r\n":"\r\n  查找类似于“ ReadOnly”和“ Wrighonly”的本地化字符串。\r\n\r\n"," Append a default argument (i.e. the default argument of an optional parameter). \r\n Assumed to be non-null. \r\n ":" 附加默认参数（即可选参数的默认参数）。\r\n 假定为非效果。\r\n \r\n","Culture of documentation comments to copy. If not specified no doc comment files are going to be copied.":"文档文化评论要复制。如果未指定，则不会复制任何文档评论文件。\r\n","Assembly location.":"组装位置。\r\n","\r\n  Looks up a localized string similar to 'Get' statement must end with a matching 'End Get'..\r\n":"\r\n  查找类似于“ GET”语句的本地化字符串必须以匹配的“ end Get”结尾。\r\n\r\n","The type, either from the type character or the as clause. Uses Object as default if needed.":"类型，来自类型字符或AS子句。如果需要，将对象用作默认值。\r\n","The flags of this parameter.":"此参数的标志。\r\n"," Examines the members collection and builds a set of partial methods if any, otherwise returns nothing ":" 检查成员的收集并构建一组部分方法（如果有），否则什么都没有返回\r\n","match exactly 'n' times":"恰好匹配“ n”时间\r\n","Use auto property":"使用自动属性\r\n","The location representing the start of the file header.":"表示文件头开始的位置。\r\n","malformed":"畸形\r\n","The symbol to navigate to":"导航到\r\n","\r\n            True if the specified declaration node is an async method, anonymous function, lambda, local function.\r\n            ":"\r\n            正确，如果指定的声明节点是异步方法，匿名函数，lambda，local函数。\r\n            \r\n","\r\n The underlying AssemblySymbol.\r\n This cannot be an instance of RetargetingAssemblySymbol.\r\n ":"\r\n 基础组合符号。\r\n 这不能是retargetingAssemblysymbol的一个实例。\r\n \r\n","Replace '{0}' with methods":"用方法替换'{0}'\r\n","\r\n Returns a copy of this with the Checksum property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，校验和属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Represents a New expression that create an object of anonymous type.\r\n ":"\r\n 代表创建匿名类型对象的新表达式。\r\n \r\n","\r\n            Used for C#/VB sig help providers so they can build up information using SymbolDisplayParts.\r\n            These parts will then by used to properly replace anonymous type information in the parts.\r\n            Once that it done, this will be converted to normal SignatureHelpParameters which only \r\n            point to TaggedText parts.\r\n            ":"\r\n            用于C＃/VB SIG帮助提供商，以便他们可以使用SymboldisPlayParts构建信息。\r\n            然后，这些零件将通过正确替换零件中的匿名类型信息。\r\n            完成此操作后，它将转换为正常的signature Helpparameters\r\n            指向标记的零件。\r\n            \r\n","\r\n The three possible number bases that a literal can be written in.\r\n ":"\r\n 可以写入字面的三个可能的基础。\r\n \r\n","\r\n Gets an initial preprocessor state and applies all directives from a given node.\r\n Entry point for blender\r\n ":"\r\n 获取初始的预处理器状态，并从给定的节点应用所有指令。\r\n 搅拌机的切入点\r\n \r\n"," is Nothing.":" 没什么。\r\n","\r\n            The text of the description without tags.\r\n            ":"\r\n            没有标签的描述文字。\r\n            \r\n"," except that the span to check\r\n            for interleaved directives can be specified separately to the node passed in.\r\n            ":" 除了检查的跨度\r\n            对于交织的指令，可以单独指定为传递的节点。\r\n            \r\n","\r\n Represents a \"Finally ...\" block of a \"Try\" block.\r\n ":"\r\n 表示“尝试”块的“最后...”块。\r\n \r\n","\r\n Returns UnaryOperatorKind.Error in case of error, otherwise adjusted operator kind.\r\n ":"\r\n 返回Unaryoperatorkind.Error如果发生错误，则否则调整了操作员。\r\n \r\n","\r\n            Even though we have child actions, we mark ourselves as explicitly non-inlinable.\r\n            We want to the experience of having the top level item the user has to see and\r\n            navigate through, and we don't want our child items confusingly being added to the\r\n            top level light-bulb where it's not clear what effect they would have if invoked.\r\n            ":"\r\n            即使我们有孩子的行为，我们也将自己标记为明确的不可限制。\r\n            我们想获得用户必须看到的顶级项目的经验，并且\r\n            浏览，我们不希望我们的孩子物品混乱地被添加到\r\n            最高灯泡尚不清楚如果调用会产生什么影响。\r\n            \r\n","\r\n When branching into constructs that don't support jumps into/out of (i.e. lambdas), \r\n we save the pending branches when visiting more nested constructs.\r\n ":"\r\n 当分支成不支持的构造时，跳入/外（即lambdas）时，\r\n 访问更多嵌套构造时，我们保存待处理的分支。\r\n \r\n","\r\n Returns information about methods associated with CollectionRangeVariableSyntax.\r\n ":"\r\n 返回有关与CollectionRangeVariablesyntax关联的方法的信息。\r\n \r\n","\r\n            The text used to determine the order that the item appears in the list.\r\n            This is often the same as the ":"\r\n            用于确定项目出现在列表中的顺序的文本。\r\n            这通常与\r\n","\r\n Create a local symbol with substituted type.\r\n ":"\r\n 用替换类型创建本地符号。\r\n \r\n","Attribute '{0}' is missing. Updating an async method or an iterator requires restarting the application.":"属性'{0}'丢失。更新异步方法或迭代器需要重新启动应用程序。\r\n","\r\n  Looks up a localized string similar to 'End Module' must be preceded by a matching 'Module'..\r\n":"\r\n  查找类似于“ End Module”的本地化字符串必须先于匹配的“模块”。\r\n\r\n","Adding {0} into a class with explicit or sequential layout requires restarting the application.":"将{0}添加到具有显式或顺序布局的类中，需要重新启动应用程序。\r\n","\r\n            Exclude the following kind of symbols:\r\n             1. Implicitly declared symbols (such as implicit fields backing properties)\r\n             2. Symbols that can't be referenced by name (such as property getters and setters).\r\n             3. Metadata only symbols, i.e. symbols with no location in source.\r\n            ":"\r\n            排除以下类型的符号：\r\n             1.隐式声明为符号（例如隐式字段备份属性）\r\n             2.无法用名称引用的符号（例如属性Geters和Setter）。\r\n             3.元数据仅符号，即源中没有位置的符号。\r\n            \r\n",". \r\n            Each entry in the group applies the delta of ":"。\r\n            该组中的每个条目都适用\r\n","\r\n Represents a \"From {...} clause used to initialize a new collection object's\r\n elements.\r\n ":"\r\n 表示一个“来自{...}子句，用于初始化新集合对象的\r\n 元素。\r\n \r\n"," class finds the correct Binder to use for a node in a syntax\r\n tree, down to method level. Within a method, the ":" 类找到正确的粘合剂，用于语法中的节点\r\n 树，到方法级别。在方法中，\r\n","\r\n A collection of statements inside the region that jump to locations outside the region.\r\n ":"\r\n 在区域内的陈述集合，这些语句跳到该地区以外的位置。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' cannot inherit from {1} '{2}' because it expands the access of type '{3}' to {4} '{5}'..\r\n":"\r\n  查找类似于'{0}'的本地化字符串不能从{1}'{2}'继承，因为它将类型'{3}'的访问扩展到{4}'{5}'..\r\n\r\n","\r\n            This definitely needs to be fixed at the compiler layer.  However, until that happens, this is \r\n            only alternative at our disposal.\r\n            ":"\r\n            这肯定需要在编译器层上修复。但是，直到发生这种情况，这是\r\n            只有我们可以使用的替代方案。\r\n            \r\n","end of string only":"仅字符串的结尾\r\n","minute (1-2 digits)":"分钟（1-2位数字）\r\n"," referenced by this module, and corresponding\r\n retargeting map for symbols.\r\n ":" 由此模块引用，对应\r\n 符号的重新定位地图。\r\n \r\n","\r\n Implementation of IEqualityComparer for EventSymbol, with options for various aspects\r\n to compare.\r\n ":"\r\n 实施iEqualityComparer for Eventymbol，具有各个方面的选项\r\n 比较。\r\n \r\n"," \r\n Return the arity of a member. \r\n ":" \r\n 返回会员的贫苦。\r\n \r\n","However, you must include a line-continuation character (_) following a member qualifier character when you are using the With statement or \r\n supplying values in the initialization list for a type.":"但是，在使用with with语句或\r\n 在类型的初始化列表中提供值。\r\n","Parameters' type or return type cannot be an anonymous type : [{0}]":"参数类型或返回类型不能是匿名类型：[{0}]\r\n","\r\n Returns a copy of this with the ImplementsClause property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 将其返回此副本，并使用instrumentement clause属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Gets a value indicating whether this instance is overrides.\r\n ":"\r\n 获取一个指示此实例是否覆盖的值。\r\n \r\n","\r\n Performs an initial pass through the group of candidates and does\r\n the following in the process.\r\n 1) Eliminates candidates based on the number of supplied arguments and number of supplied generic type arguments.\r\n 2) Adds additional entries for expanded ParamArray forms when applicable.\r\n 3) Infers method's generic type arguments if needed.\r\n 4) Substitutes method's generic type arguments.\r\n 5) Eliminates candidates based on shadowing by signature.\r\n    This partially takes care of §11.8.1 Overloaded Method Resolution, section 7.1.\t\r\n      If M is defined in a more derived type than N, eliminate N from the set. \r\n 6) Eliminates candidates with identical virtual signatures by applying various shadowing and\r\n    tie-breaking rules from §11.8.1 Overloaded Method Resolution, section 7.0 \r\n     • If M has fewer parameters from an expanded paramarray than N, eliminate N from the set. \r\n 7) Takes care of unsupported overloading within the same type for instance methods/properties.\r\n \r\n Assumptions:\r\n 1) Shadowing by name has been already applied.\r\n 2) group can include extension methods.\r\n 3) group contains original definitions, i.e. method type arguments have not been substituted yet. \r\n    Exception are extension methods with type parameters substituted based on receiver type rather \r\n    than based on type arguments supplied at the call site.    \r\n 4) group contains only accessible candidates.\r\n 5) group doesn't contain members involved into unsupported overloading, i.e. differ by casing or custom modifiers only.\r\n 6) group does not contain duplicates.\r\n 7) All elements of arguments array are Not Nothing, omitted arguments are represented by OmittedArgumentExpression node.\r\n ":"\r\n 执行初次通过的候选人组，并执行\r\n 在此过程中的以下内容。\r\n 1）根据提供的参数数量和提供的通用类型参数数量来消除候选人。\r\n 2）在适用时添加了扩展的Paramarray表单的其他条目。\r\n 3）如果需要，Infers方法的通用类型参数。\r\n 4）替代方法的通用类型参数。\r\n 5）根据签名来消除基于阴影的候选人。\r\n    这部分照顾了第11.8.1节超载方法分辨率，第7.1节。\r\n      如果M以比N更衍生的类型定义，则从集合中消除N。\r\n 6）通过应用各种阴影和\r\n    §11.8.1超载方法分辨率的第7.0节的第7.0条规则，第7.0节\r\n     •如果M从扩展的Paramarray中具有较少的参数，则从集合中消除N。\r\n 7）考虑到同一类型中的无支撑超载，例如方法/属性。\r\n \r\n 假设：\r\n 1）已经应用了名称的阴影。\r\n 2）组可以包括扩展方法。\r\n 3）组包含原始定义，即尚未替换方法类型参数。\r\n    异常是基于接收器类型替换的类型参数的扩展方法而不是\r\n    比基于呼叫网站提供的类型参数。\r\n 4）小组仅包含可访问的候选人。\r\n 5）组不包含涉及不支持的过载的成员，即仅通过外壳或自定义修饰符而有所不同。\r\n 6）组不包含重复项。\r\n 7）参数数组的所有元素都不是一无所有，省略的参数均由省略argumentExpression节点表示。\r\n \r\n","\r\n Moving to the next node on the stack.\r\n returns false if we are out of nodes.\r\n ":"\r\n 移至堆栈上的下一个节点。\r\n 如果我们不在节点之外，则返回false。\r\n \r\n","\r\n Parse a CustomEventMemberDeclaration\r\n ":"\r\n 解析CustomeventMemberDeclaration\r\n \r\n","Move type to {0}":"将类型移至{0}\r\n","\r\n Represents the name and optional type of an expression range variable.\r\n ":"\r\n 表示表达范围变量的名称和可选类型。\r\n \r\n","Introduce parameter for all occurrences of '{0}'":"引入所有出现“ {0}”的参数\r\n","\r\n  Looks up a localized string similar to Generic methods cannot use 'Handles' clause..\r\n":"\r\n  查找类似于通用方法的本地化字符串无法使用“句柄”子句。\r\n\r\n","\r\n Methods, Properties, and Events all have implements clauses and need to handle interface\r\n implementation. This module has helper methods and extensions for sharing by multiple\r\n symbol types.\r\n ":"\r\n 方法，属性和事件都具有实施条款，并且需要处理接口\r\n 执行。该模块具有辅助方法和扩展，可通过多个共享\r\n 符号类型。\r\n \r\n","The current parameter token.":"当前参数令牌。\r\n","\r\n The value for the Prefix property.\r\n ":"\r\n 前缀属性的值。\r\n \r\n","\r\n Returns a copy of this with the CommaToken property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而致命属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","name-or-number":"名称或编号\r\n","\r\n Implementation for a lifted operator.\r\n ":"\r\n 抬起操作员的实施。\r\n \r\n","\r\n            Diagnostic update source for reporting workspace host specific diagnostics,\r\n            which may not be related to any given project/document in the solution.\r\n            For example, these include diagnostics generated for exceptions from third party analyzers.\r\n            ":"\r\n            报告工作空间主机特定诊断的诊断更新来源，\r\n            可能与解决方案中的任何给定的项目/文档无关。\r\n            例如，其中包括针对第三方分析仪例外生成的诊断。\r\n            \r\n","\r\n            restore saved trivia to given tree\r\n            ":"\r\n            还原保存的琐事到给定的树\r\n            \r\n","\r\n Visit a node.\r\n ":"\r\n 访问节点。\r\n \r\n","\r\n            How this item should be selected when the completion list first appears and\r\n            before the user has typed any characters.\r\n            ":"\r\n            首先出现完成列表时，应如何选择此项目\r\n            在用户输入任何字符之前。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Exit Select' can only appear inside a 'Select' statement..\r\n":"\r\n  查找类似于“退出选择”的本地化字符串只能出现在“选择”语句中。\r\n\r\n","The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'notnull' constraint.":"类型'{2}'在通用类型或方法'{0}'中不能用作类型参数'{1}'。类型参数'{2}'的无效性不匹配'notnull'约束。\r\n","\r\n            Returns true if this item's text edit requires complex resolution that\r\n            may impact performance. For example, an edit may be complex if it needs\r\n            to format or type check the resulting code, or make complex non-local\r\n            changes to other parts of the file.\r\n            Complex resolution is used so we only do the minimum amount of work\r\n            needed to display completion items. It is performed only for the\r\n            committed item just prior to commit. Thus, it is ideal for any expensive\r\n            completion work that does not affect the display of the item in the\r\n            completion list, but is necessary for committing the item.\r\n            An example of an item type requiring complex resolution is C#/VB\r\n            override completion.\r\n            ":"\r\n            如果本项目的文本编辑需要复杂的解决方案，则返回true\r\n            可能会影响性能。例如，如果需要，编辑可能很复杂\r\n            要格式化或键入检查结果代码，或进行复杂的非本地代码\r\n            更改文件的其他部分。\r\n            使用复杂的分辨率，因此我们只做最小的工作量\r\n            需要显示完成项目。它仅针对\r\n            提交之前提交的项目。因此，它是任何昂贵的理想选择\r\n            完成不影响项目显示的完成工作\r\n            完成列表，但对于投入项目是必不可少的。\r\n            需要复杂分辨率的项目类型的示例是C＃/VB\r\n            覆盖完成。\r\n            \r\n","The InterpolatedStringHandlerArgumentAttribute applied to parameter '{0}' is malformed and cannot be interpreted. Construct an instance of '{1}' manually.":"应用于参数'{0}'的InterpolatedStringHandlerArgumentAttribute已畸形，无法解释。手动构造“ {1}”的实例。\r\n",". Essentially this is a wrapper around \r\n another ":"。本质上，这是周围的包装纸\r\n 其他\r\n"," is responsible for allowing a user to pick a \r\n            set of members from a class or struct, and then generate a constructor for that takes in\r\n            matching parameters and assigns them to those members.  The members can be picked using \r\n            a actual selection in the editor, or they can be picked using a picker control that will\r\n            then display all the viable members and allow the user to pick which ones they want to\r\n            use.\r\n            \r\n            Importantly, this type is not responsible for generating constructors when the user types\r\n            something like \"new MyType(x, y, z)\", nor is it responsible for generating constructors\r\n            in a derived type that delegate to a base type. Both of those are handled by other services.\r\n            ":" 负责允许用户选择\r\n            集体或结构中的成员集，然后生成一个构造函数\r\n            匹配参数并将其分配给那些成员。可以使用成员选择\r\n            编辑器中的实际选择，或者可以使用Picker控件进行选择\r\n            然后显示所有可行的成员，并允许用户选择他们想要的哪些成员\r\n            利用。\r\n            \r\n            重要的是，当用户类型时，这种类型不负责生成构造函数\r\n            诸如“新mytype（x，y，z）”之类的东西，也不负责生成构造函数\r\n            在派生类型中，将其委派给基本类型。两者都由其他服务处理。\r\n            \r\n","\r\n Gets the kind of this type.\r\n ":"\r\n 得到这种类型的类型。\r\n \r\n","\r\n Represents a method in a RetargetingModuleSymbol. Essentially this is a wrapper around \r\n another MethodSymbol that is responsible for retargeting symbols from one assembly to another. \r\n It can retarget symbols for multiple assemblies at the same time.\r\n ":"\r\n 代表retargetingModulesymbol中的一种方法。本质上，这是周围的包装纸\r\n 负责从一个组件重新定位符号到另一个组件的另一个方法符号。\r\n 它可以同时重新定位多个组件。\r\n \r\n","\r\n  Looks up a localized string similar to 'Inherits' can appear only once within a 'Class' statement and can only specify one class..\r\n":"\r\n  查找类似于“继承”的本地化字符串只能在“类”语句中出现一次，并且只能指定一个类。\r\n\r\n","\r\n            Additional priority associated with all configuration and suppression code actions.\r\n            This allows special code actions such as Bulk configuration to to be at the end of\r\n            all suppression and configuration actions by having a lower additional priority.\r\n            ":"\r\n            与所有配置和抑制代码操作相关联的其他优先级。\r\n            这允许特殊的代码操作，例如散装配置\r\n            通过具有较低的额外优先级，所有抑制和配置操作。\r\n            \r\n","\r\n Symbol for the most nested namespace, if found. Nothing \r\n if namespace or any part of it can not be found.\r\n ":"\r\n 如果找到了最嵌套的名称空间的符号。没有什么\r\n 如果找不到名称空间或任何部分。\r\n \r\n","\r\n The value for the FunctionName property.\r\n ":"\r\n 功能名属性的值。\r\n \r\n","\r\n An elastic trivia with kind WhitespaceTrivia containing a single tab character. Elastic trivia are used to\r\n denote trivia that was Not produced by parsing source text, And are usually Not preserved during formatting.\r\n ":"\r\n 具有单个标签字符的弹性琐事。弹性琐事习惯\r\n 表示未通过解析源文本产生的琐事，通常在格式期间没有保留。\r\n \r\n","\r\n An abstract node class that represents a \"With\" or \"From\" clause used to\r\n initializer an new object.\r\n ":"\r\n 一个代表“或“从”子句的“ with”或“\r\n 初始化器一个新对象。\r\n \r\n","Syntax node that position is in.":"语法节点该位置在。\r\n"," Owning compilationSource module ":"拥有Compilationsource模块\r\n","\r\n Represents type parameter of a curried extension method definition.\r\n ":"\r\n 表示咖喱扩展方法定义的类型参数。\r\n \r\n","\r\n Specifies the syntax that a user defined variable comes from.\r\n ":"\r\n 指定用户定义变量来自的语法。\r\n \r\n","\r\n Creates the syntax representation of an xml newline token for xml documentation comments.\r\n ":"\r\n 为XML文档注释创建XML Newline令牌的语法表示。\r\n \r\n","\r\n Returns a copy of this with the ForKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中forkeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n"," is important for serialization compatibility in\r\n            ":" 对于序列化兼容性很重要\r\n            \r\n","\r\n The value for the WhenFalse property.\r\n ":"\r\n 何时属性属性的值。\r\n \r\n","\r\n If this is a speculative semantic model, then returns its parent semantic model.\r\n Otherwise, returns null.\r\n ":"\r\n 如果这是一个投机性语义模型，则返回其父语义模型。\r\n 否则，返回null。\r\n \r\n","\r\n Base type. \r\n Could be Nothing for Interfaces or Object.\r\n ":"\r\n 基本类型。\r\n 对于接口或对象而言，可能没有任何东西。\r\n \r\n","Add missing param nodes":"添加缺少的参数节点\r\n","\r\n True iff this type or some containing type has type parameters.\r\n ":"\r\n 正确的IFF此类型或某些包含类型的类型参数。\r\n \r\n","An optional parameter indicating whether to create a interactive command line parser.":"可选参数，指示是否创建交互式命令行解析器。\r\n"," API otherwise, return\r\n            ":" 否则API，返回\r\n            \r\n","\r\n This is a layer on top of the Compilation version that generates a diagnostic if the well-known\r\n type isn't found.\r\n ":"\r\n 这是汇编版本顶部的一层，如果众所周知\r\n 找不到类型。\r\n \r\n","s that contain\r\n            the static classes that those extension methods are contained in.\r\n            ":"s包含\r\n            这些扩展方法包含的静态类。\r\n            \r\n","\r\n The value for the ModuleStatement property.\r\n ":"\r\n ModuleStatement属性的值。\r\n \r\n","\r\n Do not consider symbols that are instance members.\r\n ":"\r\n 不要考虑是实例成员的符号。\r\n \r\n","\r\n The value for the ElseIfBlocks property.\r\n ":"\r\n Elseifblocks属性的值。\r\n \r\n","\r\n Infer the type of a variable declared with an initializing expression.\r\n ":"\r\n 推断以初始化表达式声明的变量的类型。\r\n \r\n","\r\n The text token.\r\n ":"\r\n 文字令牌。\r\n \r\n","\r\n A simple \"As\" clause specifying the type of exception to catch.\r\n ":"\r\n 一个简单的“ AS”子句，指定要捕获的异常类型。\r\n \r\n","\r\n Using aliases in VB are always at the top\r\n level within a compilation unit, within the [Global] namespace declaration.  We\r\n return that as the \"containing\" symbol, even though the alias isn't a member of the\r\n namespace as such.\r\n ":"\r\n 在VB中使用别名总是在顶部\r\n 在[全局]名称空间声明中的汇编单元中的级别。我们\r\n 将其作为“包含”符号的归还，即使别名不是成员\r\n 名称空间。\r\n \r\n","\r\n What is the argument to the (first) CLSCompliantAttribute on this symbol, if there is one?\r\n Consider attributes inherited from base types.\r\n ":"\r\n 如果有的话，（第一个）ClsCompliantAtibute的论点是什么？\r\n 考虑从基本类型继承的属性。\r\n \r\n","\r\n            Lists compiler attributes that we want to remove.\r\n            The TupleElementNames attribute is compiler generated (it is used for naming tuple element names).\r\n            We never want to place it in source code.\r\n            Same thing for the Dynamic attribute.\r\n            ":"\r\n            列表我们要删除的编译器属性。\r\n            TupleelementNames属性是编译器生成的（用于命名元组元素名称）。\r\n            我们永远不想将其放在源代码中。\r\n            动态属性相同。\r\n            \r\n","The parameter symbol that was declared.":"声明的参数符号。\r\n","\r\n Return False if ComVisibleAttribute(False) is applied to the symbol, True otherwise.\r\n ":"\r\n 如果将comvisibleattribute（false）应用于符号，则返回false，否则否则。\r\n \r\n","s is set to\r\n            ":"S设置为\r\n            \r\n","The \"s\" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.SortableDateTimePattern property. The pattern reflects a defined standard (ISO 8601), and the property is read-only. Therefore, it i ...":"“ S”标准格式指定符表示由DateTimeFormatInfo.SortabledateTimePattern属性定义的自定义日期和时间格式字符串。该模式反映了定义的标准（ISO 8601），并且该属性仅读取。因此，我...\r\n","The method, property, or event symbol that was declared.":"声明的方法，属性或事件符号。\r\n","\r\n Determine the relaxation level of a given conversion. This will be used by\r\n overload resolution in case of conflict. This is to prevent applications that compiled in VB8\r\n to fail in VB9 because there are more matches. And the same for flipping strict On to Off.\r\n \r\n Will set only bits used for delegate relaxation level.\r\n ":"\r\n 确定给定转换的放松水平。这将由\r\n 在发生冲突的情况下，超负荷分辨率。这是为了防止在VB8中编译的应用程序\r\n 在VB9中失败，因为还有更多匹配项。严格翻转的情况也是如此。\r\n \r\n 将仅设置用于委托放松水平的位。\r\n \r\n","\r\n Create a possibly merged namespace symbol. If only a single namespace is passed it, it is just returned directly.\r\n If two or more namespaces are passed in, then a new merged namespace is created with the given extent and container.\r\n ":"\r\n 创建可能合并的名称空间符号。如果仅通过一个名称空间，则直接返回。\r\n 如果传递了两个或多个命名空间，则使用给定范围和容器创建一个新的合并名称空间。\r\n \r\n"," \r\n Given anonymous type descriptor provided construct an anonymous type symbol\r\n ":" \r\n 给定的匿名类型描述符提供了构造匿名类型符号\r\n \r\n"," is possibly a string literal token that could contain a date or time\r\n            format string passed into an method call.  If so, ":" 可能是一个字符串文字令牌，可能包含一个日期或时间\r\n            格式字符串传递到方法调用中。如果是这样，\r\n","\r\n  Looks up a localized string similar to Expression expected..\r\n":"\r\n  查找类似于预期表达式的局部字符串。\r\n\r\n","\r\n  Looks up a localized string similar to 'End If' must be preceded by a matching 'If'..\r\n":"\r\n  查找类似于“ end”的本地化字符串，必须先于匹配“如果”。\r\n\r\n","\r\n  Looks up a localized string similar to Cannot await Nothing. Consider awaiting 'Task.Yield()' instead..\r\n":"\r\n  查找类似于不能等待的本地化字符串。考虑等待“ task.yield（）”。\r\n\r\n","\r\n Enumeration with all Visual Basic syntax node kinds.\r\n ":"\r\n 枚举所有可视化基本语法节点类型。\r\n \r\n","\r\n The name used to identify the named argument.\r\n ":"\r\n 用于识别命名参数的名称。\r\n \r\n","\r\n Creates binders for top-level executable statements.\r\n ":"\r\n 为顶级可执行语句创建粘合剂。\r\n \r\n","\r\n Returns True if the binder, or any containing binder, has xmlns Imports.\r\n ":"\r\n 如果粘合剂或任何包含粘合剂的活页夹有XMLNS导入，则返回true。\r\n \r\n","\r\n  Looks up a localized string similar to 'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to an Async or Iterator method..\r\n":"\r\n  查找类似于'system.runtime.interopservices.dllimportattribute'的本地化字符串，不能应用于异步或迭代方法。\r\n\r\n","The switch expression does not handle some null inputs (it is not exhaustive). For example, the pattern '{0}' is not covered.":"开关表达式无法处理某些空输入（并不详尽）。例如，未涵盖模式'{0}'。\r\n","\r\n            True if all child nodes of the ":"\r\n            如果所有孩子的节点\r\n","\r\n Given the type of operator's argument, return corresponding type to\r\n look for operator in. Can return Nothing.\r\n ":"\r\n 给定操作员的参数类型，将相应类型返回到\r\n 寻找操作员。什么都不能返回。\r\n \r\n","\r\n Returns a copy of this with the SlashGreaterThanToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回其中的副本，其中Slashgreatthantken物业更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n The value for the ThrowKeyword property.\r\n ":"\r\n ThrowKeyWord属性的值。\r\n \r\n","\r\n Checks if 'symbol' is accessible from within type 'within', with\r\n an optional qualifier of type \"throughTypeOpt\".\r\n ":"\r\n 检查是否可以从类型“内部”中访问“符号”，\r\n 类型“ Printypeopt”的可选资格赛。\r\n \r\n","\r\n The operator being defined.\r\n ":"\r\n 定义操作员。\r\n \r\n","\r\n Gets constant value information about an expression syntax node. This is the worker\r\n function that is overridden in various derived kinds of Semantic Models. It can assume that \r\n CheckSyntaxNode has already been called.\r\n ":"\r\n 获取有关表达语法节点的常数价值信息。这是工人\r\n 在各种派生的语义模型中被覆盖的函数。它可以假设\r\n checksyntaxnode已被调用。\r\n \r\n","\r\n Represents an entire Try...Catch...Finally...End Try statement.\r\n ":"\r\n 代表整个尝试...捕获...最后...结束尝试语句。\r\n \r\n","\r\n Based on CompilationPass::CLSReduceSignature.\r\n ":"\r\n 基于CompilationPass :: ClsreduceSignature。\r\n \r\n","\r\n Returns a copy of this with the WithStatement property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，升级属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n The underlying EventSymbol, cannot be another RetargetingEventSymbol.\r\n ":"\r\n 基础事件符号不能是另一个retargetingeventsymbol。\r\n \r\n","\r\n The statement that declares a Sub or Function. If this method has a body, this\r\n statement will be the Begin of a BlockStatement with\r\n Kind=MethodDeclarationBlock, and the body of the method will be the Body of\r\n that BlockStatement.\r\n ":"\r\n 声明子或函数的语句。如果此方法具有身体，那么\r\n 语句将是一个封锁的开始\r\n kint = methoddeclaration block，该方法的主体将是\r\n 那个块。\r\n \r\n","The implementing member or Nothing, if there isn't one.":"实施成员或什么都没有，如果没有。\r\n","Private property '{0}' can be converted to a method as its get accessor is never invoked.":"私有属性'{0}'可以转换为方法，因为从未调用其GET登录器。\r\n","\r\n Placeholder for the bound enumerator local. \r\n ":"\r\n 本地枚举者的占位符。\r\n \r\n","'{0}': Target runtime doesn't support covariant return types in overrides. Return type must be '{2}' to match overridden member '{1}'":"'{0}'：目标运行时不支持覆盖中的协变量返回类型。返回类型必须为'{2}'才能匹配覆盖成员'{1}'\r\n","\r\n  Looks up a localized string similar to Local variable '{0}' is already declared in the current block..\r\n":"\r\n  查找类似于本地变量'{0}'的本地化字符串已在当前块中声明。\r\n\r\n","\r\n Implementation for an extension method, i.e. it is used as an extension method.\r\n ":"\r\n 扩展方法的实现，即将其用作扩展方法。\r\n \r\n","\r\n            Tracks the given file path of a non-existent file and whenever a new file with this file path is created,\r\n            it adds it as a solution item.\r\n            NOTE: ":"\r\n            跟踪不存在的文件的给定文件路径，并且每当创建带有此文件路径的新文件时，\r\n            它将其添加为解决方案项目。\r\n            笔记：\r\n","\r\n Returns True if this conversion a widening type parameter or a narrowing type parameter conversion, as defined in\r\n section 8.10.\r\n ":"\r\n 如果此转换为扩展类型参数或变窄类型的参数转换，则返回true\r\n 第8.10节。\r\n \r\n","The modified identifier.":"修改后的标识符。\r\n","Use 'throw' expression":"使用“投掷”表达式\r\n","Returns the symbol's type or an ErrorTypeSymbol if the local is referenced before its definition or if the symbol is still being bound.":"如果在其定义之前引用本地元素或符号仍在绑定之前，则返回符号的类型或errortypesymbol。\r\n","\r\n            Determine among the provided items the best match w.r.t. the given filter text, \r\n            those returned would be considered equally good candidates for selection by controller.\r\n            ":"\r\n            在提供的项目中确定最佳匹配W.R.T.给定的过滤文本，\r\n            返回的这些将被认为是由控制者选择的好候选人。\r\n            \r\n","\r\n            A string defined from ":"\r\n            定义的字符串\r\n","\r\n Synthesizes attribute data for given constructor symbol.\r\n If the constructor has UseSiteErrors and the attribute is optional returns Nothing.\r\n ":"\r\n 合成给定构造函数符号的属性数据。\r\n 如果构造函数具有useIteErrors，并且属性是可选的返回。\r\n \r\n","\r\n Binds the AddressOf expression.\r\n ":"\r\n 结合表达式的地址。\r\n \r\n","\r\n Creates a new compilation with the specified references.\r\n ":"使用指定的引用创建新的汇编。\r\n \r\n","\r\n Creates a binder for a binding project-level imports. This includes the following binders:\r\n    BackstopBinder\r\n    SourceModuleBinder\r\n    ProjectImportsBinder\r\n    NamespaceBinder (for the global namespace)\r\n    IgnoreBaseClassesBinder (so that base classes are ignore during binding)\r\n ":"\r\n 为绑定的项目级进口创建活页夹。这包括以下粘合剂：\r\n    后脚手\r\n    Sourcemodulebinder\r\n    ProjectImportsBinder\r\n    名称空间Binder（用于全局名称空间）\r\n    忽略baseclassesbinder（以便在绑定期间忽略基类）\r\n \r\n","The symbol to check accessibility.":"检查可访问性的符号。\r\n","Changing constraints of {0} requires restarting the application.":"更改{0}的约束需要重新启动应用程序。\r\n","\r\n Creates a binder for binding a source parameter's default value.\r\n ":"\r\n 创建用于绑定源参数的默认值的粘合剂。\r\n \r\n","\r\n Return MethodKind corresponding to the method the code being interpreted is going to end up in.\r\n ":"\r\n 返回methodKind对应于与所解释的代码最终进入的方法相对应的。\r\n \r\n","The position of the caret within the text.":"嘉年华在文本中的位置。\r\n","\r\n §11.8.1 Overloaded Method Resolution\r\n     2.\tNext, eliminate all members from the set that are inaccessible or not applicable to the argument list.\r\n \r\n Note, similar to Dev10 compiler this process will eliminate candidates requiring narrowing conversions\r\n if strict semantics is used, exception are candidates that require narrowing only from numeric constants.\r\n \r\n Returns amount of applicable candidates left.\r\n ":"\r\n §11.8.1超载方法分辨率\r\n     2.接下来，消除无法访问或不适用于参数列表的所有成员。\r\n \r\n 注意，与DEV10编译器相似，此过程将消除需要缩小转换的候选人\r\n 如果使用严格的语义，则需要仅从数字常数缩小的候选人。\r\n \r\n 退货剩余的适用候选人金额。\r\n \r\n","\r\n Returns true if this symbol was declared as requiring an override; i.e., declared\r\n with the \"MustOverride\" modifier. Never returns true for types. \r\n ":"\r\n 如果该符号被宣布为替代，则返回为真；即，宣布\r\n 带有“ Mustoverride”修饰符。类型永远不会返回。\r\n \r\n","\r\n            The enter is key only passed through to the editor if the completion item has been fully typed out.\r\n            ":"\r\n            ENTER是仅通过完全键入完成项目的键才传递给编辑器的密钥。\r\n            \r\n","\r\n Returns a copy of this with the Guid property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，指南属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n Resets numbering in anonymous type names and compiles the\r\n anonymous type methods. Also seals the collection of templates.\r\n ":"\r\n 以匿名类型名称重置编号并编译\r\n 匿名类型方法。还密封模板的集合。\r\n \r\n","The keyword kind for a given special type, or SyntaxKind.None if the type name is not a predefined type.":"给定特殊类型的关键字类型，或语法。\r\n","\r\n Given a custom event block syntax get the corresponding event symbol.\r\n ":"\r\n 给定一个自定义事件块语法获取相应的事件符号。\r\n \r\n","The flags for this method.":"此方法的标志。\r\n","\r\n Create a local variable symbol. Note: this does not insert it automatically into a\r\n local binder so that it can be found by lookup.\r\n ":"\r\n 创建局部变量符号。注意：这不会自动插入\r\n 局部活页夹，以便可以通过查找找到它。\r\n \r\n","\r\n            Analyzers supplied by the host (IDE). These are built-in to the IDE, the compiler, or from an installed IDE extension (VSIX). \r\n            Maps language name to the analyzers and their state.\r\n            ":"\r\n            主机提供的分析仪（IDE）。这些是内置于IDE，编译器或已安装的IDE扩展（VSIX）内置的。\r\n            将语言名称映射到分析仪及其状态。\r\n            \r\n","\r\n Check whether the token is a statement terminator\r\n ":"\r\n 检查令牌是否是语句终结者\r\n \r\n","\r\n  Looks up a localized string similar to Friend access was granted by '{0}', but the strong name signing state of the output assembly does not match that of the granting assembly..\r\n":"\r\n  查找类似于朋友访问的本地化字符串由“ {0}”授予，但是输出组件的强名称签名状态与授予程序集的签名不匹配。\r\n\r\n","\r\n            Can be null, if we are dealing with one-argument call to a slice-like method.\r\n            ":"\r\n            如果我们要处理一个类似片的方法的单词呼叫，则可以是无效的。\r\n            \r\n"," is instructed to do so. \r\n            By default they are propagated to the caller of the API.\r\n            ":" 被指示这样做。\r\n            默认情况下，它们将传播给API的呼叫者。\r\n            \r\n","Location to use for various synthetic nodes and symbols.":"用于各种合成节点和符号的位置。\r\n","\r\n Returns true if namespace contains types accessible from the target assembly.\r\n ":"\r\n 如果名称空间包含可从目标组件访问的类型，则返回true。\r\n \r\n","\r\n A MissingMetadataSymbol is a special kind of ErrorSymbol that represents\r\n a type symbol that was attempted to be read from metadata, but couldn't be\r\n found, because:\r\n   a) The metadata file it lives in wasn't referenced\r\n   b) The metadata file was referenced, but didn't contain the type\r\n   c) The metadata file was referenced, contained the correct outer type, but\r\n      didn't contains a nested type in that outer type.\r\n ":"\r\n 缺失的甲核杆是一种特殊的错误符号，代表\r\n 试图从元数据读取的类型符号，但不能\r\n 发现，因为：\r\n   a）未参考它居住的元数据文件\r\n   b）引用了元数据文件，但不包含类型\r\n   c）引用了元数据文件，包含正确的外部类型，但\r\n      没有包含该外部类型中的嵌套类型。\r\n \r\n","24 hour clock (1-2 digits)":"24小时时钟（1-2位数字）\r\n","T1.T2":"T1.T2\r\n","\r\n  Looks up a localized string similar to could not find library '{0}'.\r\n":"\r\n  查找类似于找不到库'{0}'的本地化字符串。\r\n\r\n","\r\n This class represents a query expression. A query expression is composed of one\r\n or more query operators in a row. The first query operator must be a From or\r\n Aggregate.\r\n ":"\r\n 该类代表查询表达式。查询表达式由一个\r\n 或连续查询操作员。第一个查询操作员必须是来自或\r\n 总计的。\r\n \r\n"," \r\n Following C# implementation we keep up to 32 data sets so that we do not need to allocate \r\n them over and over. In this implementation though, circularity detection in one type can trigger\r\n circularity detection in other types while it traverses the types tree. The traversal is being \r\n performed breadth-first, so the number of data sets used by one thread is not longer than the \r\n length of the longest structure-in-structure nesting chain.\r\n ":" \r\n 在C＃实施之后，我们最多保持32个数据集，因此我们不需要分配\r\n 他们一遍又一遍地。但是，在此实现中，一种类型的圆形检测可以触发\r\n 当它穿越类型树时，其他类型的圆形检测。遍历正在\r\n 执行广度优先，因此一个线程使用的数据集数不得\r\n 最长结构内结构嵌套链的长度。\r\n \r\n","\r\n Assembly's identity.\r\n ":"\r\n 集会的身份。\r\n \r\n","\r\n Returns: negative value - when first lost, 0 - when neither lost, > 0 - when second lost.\r\n ":"\r\n 返回：负值 - 第一次丢失时，0-当第二次丢失时都不会丢失，> 0。\r\n \r\n","\r\n            This API uses SourceText instead of Document so implementations can only be based on text, not syntax or semantics.\r\n            ":"\r\n            该API使用SourceText代替文档，因此实现只能基于文本，而不是语法或语义。\r\n            \r\n","\r\n Returns true if this property can overload another.\r\n ":"\r\n 如果此属性可以超载另一个，则返回true。\r\n \r\n","\r\n If search within assembly fails, lookup in assemblies referenced by the primary module.\r\n For source assembly, this is equivalent to all assembly references given to compilation.\r\n ":"\r\n 如果在组件中搜索失败，则在主模块引用的汇编中查找。\r\n 对于源组件，这等同于所有汇编的所有组件参考。\r\n \r\n","Add missing usings":"添加缺失的使用\r\n","\r\n Returns full string representation of this node including its leading and trailing trivia.\r\n ":"\r\n 返回该节点的完整字符串表示形式，包括其领先和尾随的琐事。\r\n \r\n"," have special implementation of GetBinder functions,\r\n the rest just delegate to containing binder.\r\n ":"具有特殊实施GetBinder功能，\r\n 其余的只是将包含粘合剂委托。\r\n \r\n","\r\n            Used for clients that are finding usages to push information about how far along they\r\n            are in their search.\r\n            ":"\r\n            用于寻找用法的客户，以推动有关他们走多远的信息\r\n            在他们的搜索中。\r\n            \r\n","\r\n Represents part of an If statement, consisting of a beginning statement (If or\r\n ElseIf), followed by a body of statement controlled by that beginning\r\n statement. The Kind property returns if this is an If or ElseIf.\r\n ":"\r\n 代表IF语句的一部分，由开始语句组成（如果或\r\n Elseif），然后是由该开始控制的一系列陈述\r\n 陈述。如果是IF或ERESIF，则属性属性将返回。\r\n \r\n","\r\n Given a constructor statement syntax get the corresponding method symbol.\r\n ":"\r\n 给定的构造函数语句语法获取相应的方法符号。\r\n \r\n","\r\n Gets the \"IsCompleted\" property.\r\n ":"\r\n 获取“完整的”属性。\r\n \r\n","\r\n This is a binder for use when early decoding of well known attributes. The binder will only bind expressions that can appear in an attribute.\r\n Its purpose is to allow a symbol to safely decode any attribute without the possibility of any attribute related infinite recursion during binding.\r\n If an attribute and its arguments are valid then this binder returns a BoundAttributeExpression otherwise it returns a BadExpression.\r\n ":"\r\n 当早期解码众所周知的属性时，这是一种粘合剂。粘合剂只能绑定可以在属性中出现的表达式。\r\n 它的目的是允许符号安全地解码任何属性，而无需在绑定过程中任何属性相关的无限递归。\r\n 如果属性及其参数有效，则此活页夹将返回一个boundattributeexpression，否则它将返回badexpression。\r\n \r\n","The syntax node to get type information for.":"语法节点获取类型信息。\r\n","\r\n            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic\r\n            can convey more detailed information to the fixer.\r\n            ":"\r\n            一组可选的名称值对，通过其创建诊断的分析仪\r\n            可以将更详细的信息传达给修复程序。\r\n            \r\n","No common root node for extraction.":"没有通用的根节点用于提取。\r\n",".\r\n            If it returns true the exception is caught and stored on the resulting ":"。\r\n            如果返回正确，则将异常捕获并存储在结果上\r\n","Object or collection initializer implicitly dereferences possibly null member '{0}'.":"对象或收集初始化器隐式删除可能为null成员'{0}'。\r\n","struct field initializers":"结构字段初始化器\r\n","\r\n Generate the body for MoveNext()\r\n ":"\r\n 生成Movenext（）的身体\r\n \r\n","An empty diagnostic bag to capture diagnostics that have to be reported if the\r\n collection matches the design pattern and that can be used instead of the generic error message in case non of the\r\n for each collection criteria match.":"一个空的诊断袋来捕获诊断，如果\r\n 收集与设计模式匹配，并且可以使用，而不是通用错误消息，以防万一\r\n 对于每个收集条件匹配。\r\n","\r\n            This class contains all the operations needs to be done on members and destination to complete the pull up operation.\r\n            If user clicked the cancel button, it will be null.\r\n            ":"\r\n            此类包含所有需要在成员和目的地上完成的操作，以完成上拉操作。\r\n            如果用户单击“取消”按钮，则将为null。\r\n            \r\n","Generate GetHashCode()":"生成gethashcode（）\r\n","\r\n Returns a copy of this with the EnumStatement property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，枚举属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","expression to be used into the last Select in the query expression or linq invocation.":"在查询表达式或LINQ调用中的最后一个选择中使用的表达式。\r\n","\r\n Returns a copy of this with the LoopStatement property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回其中的副本，loopstatement属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Returns true if this property is an auto-created WithEvents property that \r\n takes place of a field member when the field is marked as WithEvents.\r\n ":"\r\n 如果此属性是自动创建的事件属性，则返回true\r\n 当字段被标记为事件时，发生现场成员。\r\n \r\n","Auto-implemented instance properties in readonly structs must be readonly.":"必须阅读自动实例实例属性。\r\n","\r\n            Reports rude edits for a symbol that's been deleted in one location and inserted in another and the edit was not classified as\r\n            ":"\r\n            报告粗鲁的编辑，该符号已在一个位置删除并插入另一个位置，并且编辑未分类为\r\n            \r\n"," tree\r\n visiting each SyntaxNode and its child ":" 树\r\n 访问每个语法及其孩子\r\n","\r\n The value for the SkipOrTakeKeyword property.\r\n ":"\r\n Skiportakekeyword属性的值。\r\n \r\n","\r\n The \"GoTo\" keyword.\r\n ":"\r\n “ goto”关键字。\r\n \r\n","\r\n VB allows two weak assembly references of the same simple name be passed to a compilation \r\n as long as their versions are different. It ignores culture.\r\n ":"\r\n VB允许将同一简单名称的两个弱汇编引用传递给汇编\r\n 只要它们的版本不同。它忽略了文化。\r\n \r\n","Solution":"解决方案\r\n","Script initializer or Nothing if not binding top-level statements.":"脚本初始化器或没有绑定顶级语句的任何内容。\r\n","\r\n The exitLabel is used to label the final method body return at the end of the async state-machine \r\n method. Is used in rewriting of return statements from Await expressions and a couple of other \r\n places where the return is not accompanied by return of the value.\r\n ":"\r\n 排放标签用于标记最终方法主体在异步状态计的末端返回\r\n 方法。用于重写等待表达式的返回语句和其他几个\r\n 退货不伴随该值返回的地方。\r\n \r\n","\r\n            Gets the copyright text, as parsed from the header.\r\n            ":"\r\n            获取从标题解析的版权文本。\r\n            \r\n","\r\n Consider only namespaces and types.\r\n ":"\r\n 仅考虑名称空间和类型。\r\n \r\n","\r\n Represents a sequence of characters appearing in source with no possible\r\n meaning in the Visual Basic language (e.g. the semicolon ';'). This token\r\n should only appear in SkippedTokenTrivia as an artifact of parsing error\r\n recovery.\r\n ":"\r\n 代表一系列字符出现在源中，无需\r\n 在视觉基本语言中的含义（例如，分号';'）。这个令牌\r\n 应该只出现在跳过的tokentrivia中作为解析错误的工件\r\n 恢复。\r\n \r\n","A constructor declared in a record with parameter list must have 'this' constructor initializer.":"在带有参数列表的记录中声明的构造函数必须具有“此”构造函数初始化器。\r\n","native-sized integers":"本地大小的整数\r\n","\r\n            The automation text to use when narrating the completion item. If set to\r\n            null, narration will use the ":"\r\n            叙述完成项目时要使用的自动化文本。如果设置为\r\n            null，叙述将使用\r\n"," Method's information ":" 方法的信息\r\n","Unrecognized escape sequence \\{0}":"无法识别的逃脱序列\\ {0}\r\n","'{0}' is not an instance method, the receiver cannot be an interpolated string handler argument.":"'{0}'不是实例方法，接收器不能是插值字符串处理程序参数。\r\n","\r\n  Looks up a localized string similar to Embedding the interop type '{0}' from assembly '{1}' causes a name clash in the current assembly. Consider disabling the embedding of interop types..\r\n":"\r\n  查找类似于嵌入Interop类型的'{0}'的本地化字符串，从汇编'{1}'导致当前汇编中的名称冲突。考虑禁用Interop类型的嵌入。\r\n\r\n","\r\n The value for the DollarSignDoubleQuoteToken property.\r\n ":"\r\n DollarSignDoublequotoken属性的价值。\r\n \r\n","\r\n Suppresses RValue validation when constructing the node. \r\n Must be used _only_ when performing lambda inference where RValue inconsistency on this node is intentionally allowed.\r\n If such node makes into a regular bound tree it will be eventually rewritten (all Yields are rewritten at some point)\r\n and that will trigger validation.\r\n ":"\r\n 构造节点时抑制RVALUE验证。\r\n 必须在执行lambda推理时使用_对_，在该节点上有意允许rvalue不一致。\r\n 如果这种节点变成常规树，最终将重写（在某个时候重写所有收益）\r\n 这将触发验证。\r\n \r\n","\r\n  Looks up a localized string similar to Value of type '{0}' cannot be converted to '{1}' because '{2}' is not derived from '{3}'..\r\n":"\r\n  查找类似于类型'{0}'的值的本地化字符串，不能转换为'{1}'，因为'{2}'不是从'{3}'..派生的。\r\n\r\n","\r\n The value for the NextKeyword property.\r\n ":"\r\n NextKeyWord属性的值。\r\n \r\n","\r\n It works by maintaining a dictionary of all possible simple names that might map to a particular\r\n attribute.\r\n ":"\r\n 它通过维护所有可能映射到特定的简单名称的字典来起作用\r\n 属性。\r\n \r\n"," has a single entry in it.  If there\r\n            are multiple entries, ":" 其中有一个条目。如果有\r\n            是多个条目，\r\n","\r\n Binder used for interiors of documentation comment for binding 'name' attribute \r\n value of 'typeparam' documentation comment tag\r\n ":"\r\n 用于绑定“名称”属性的文档注释内部的活页夹\r\n “ Typeparam”文档评论标签的价值\r\n \r\n","\r\n            Timeout value used for time-boxing completion of unimported extension methods.\r\n            Value less than 0 means no timebox; value == 0 means immediate timeout (for testing purpose)\r\n            ":"\r\n            超时值用于未安装扩展方法的时间盒完成。\r\n            值小于0表示无时间箱；值== 0表示立即超时（用于测试目的）\r\n            \r\n","\r\n Get contextual keywords\r\n ":"\r\n 获取上下文关键字\r\n \r\n","\r\n Replace the symbol replaced with a new one, but the kind\r\n and diagnostics retained from the current result. Typically used when constructing\r\n a type from a symbols and type arguments.\r\n ":"\r\n 替换符号替换为新符号，但是\r\n 并从当前结果中保留了诊断。通常在构造时使用\r\n 来自符号和类型参数的类型。\r\n \r\n","\r\n  Looks up a localized string similar to Type argument '{0}' does not satisfy the 'Structure' constraint for type parameter '{1}'..\r\n":"\r\n  查找类似于类型参数'{0}'的本地化字符串不满足类型参数'{1}'..的“结构”约束。\r\n\r\n","The binder to bind within. This binder is used for looking up\r\n unqualified names, accessibility checking, reporting errors, and probably other stuff too.":"粘合剂在内部结合。此活页夹用于查找\r\n 不合格的名称，可访问性检查，报告错误以及可能的其他内容。\r\n","\r\n NOTE: This method should always be kept as a NotOverridable method.\r\n If you want to override attribute binding logic for a sub-class, then override ":"\r\n 注意：该方法应始终保存为一种可忽略的方法。\r\n 如果要覆盖子类属性绑定逻辑，则覆盖\r\n","\r\n Add a mapping from name to some attributes.\r\n ":"\r\n 将映射从名称添加到某些属性。\r\n \r\n","\r\n Create binder for binding the body of a method. \r\n ":"创建粘合剂以结合方法的身体。\r\n \r\n","\r\n            Defines the ":"\r\n            定义\r\n","An ImmutableArray containing all the members of this symbol with the given name. If there are\r\n no members with this name, returns an empty ImmutableArray. Never returns Nothing.":"一个immutablearray包含带有给定名称的所有符号成员。如果有\r\n 没有这个名字的成员返回一个空的Immutablearray。永远不会返回。\r\n","\r\n Create a possibly merged namespace symbol representing global namespace on an assembly level.\r\n ":"\r\n 创建一个可能合并的名称空间符号，代表汇编级别的全局名称空间。\r\n \r\n","\r\n            Host provides no guarantee when will this be called (i.e. pre or post document change), nor the text \r\n            change will actually happen at all (e.g. the commit operation might be cancelled due to cancellation/exception/etc.)\r\n            ":"\r\n            主机不提供任何保证，何时会调用（即文件前或后更改），也不保证文本\r\n            更改实际上将完全发生（例如，由于取消/异常/等，可能会取消提交操作。）\r\n            \r\n","The Dispose method.":"处理方法。\r\n","\r\n            expandItemsAvailable is true when expanded items are returned or can be provided upon request.\r\n            ":"\r\n            当返回扩展项目或可以根据要求提供扩展项目时，ExpandItemsavailable是正确的。\r\n            \r\n","\r\n            Create filter for extension methods from metadata\r\n            The filter is a map from fully qualified type name to info of extension methods it contains.\r\n            ":"\r\n            从元数据创建用于扩展方法的过滤器\r\n            该过滤器是从完全合格的类型名称到其包含的扩展方法的信息的地图。\r\n            \r\n","\r\n            Encapsulates access to the last committed solution.\r\n            We don't want to expose the solution directly since access to documents must be gated by out-of-sync checks.\r\n            ":"\r\n            封装访问最后一个授予的解决方案。\r\n            我们不想直接暴露解决方案，因为必须通过离同步支票将对文档的访问访问。\r\n            \r\n"," if this loop is a DoTopLoop; otherwise, ":" 如果此循环是螺旋桨；否则，\r\n","Alpha-renamed type parameters.":"α-命名的类型参数。\r\n","\r\n If a receiver is included in cases where the receiver will not be\r\n evaluated (an instance for a shared method for instance), we\r\n still want to visit the receiver but treat it as unreachable code.\r\n ":"\r\n 如果在接收器不会是的情况下包括接收器\r\n 评估（例如共享方法的实例），我们\r\n 仍然想访问接收器，但将其视为无法到达的代码。\r\n \r\n","\r\n             \r\n             So, if there are two or more of these like:\r\n             \r\n             ":"\r\n             \r\n             因此，如果有两个或多个类似：\r\n             \r\n             \r\n"," is null, then\r\n the \"empty\" value should be inferred.\r\n ":" 是无效的\r\n 应推断“空”值。\r\n \r\n","\r\n Represents a Lambda parameter for a LambdaSymbol.\r\n ":"\r\n 代表lambdasymbol的lambda参数。\r\n \r\n","A bound call to the GetEnumerator method.":"对GetEnumerator方法的界定调用。\r\n"," is not absolute.":" 不是绝对的。\r\n","all control characters":"所有控制字符\r\n","Make containing scope async":"制作包含范围异步\r\n","The part of the statement preceding the embedded statement":"嵌入式语句之前的声明的一部分\r\n","Illegal \\ at end of pattern":"非法\\在模式结束时\r\n","\r\n            [...] node.\r\n            ":"\r\n            [...]节点。\r\n            \r\n","\r\n Produces a clone of a ":"\r\n 产生一个克隆\r\n","\r\n Identifies the special instance \"MyClass\"\r\n ":"\r\n 标识特殊实例“ myclass”\r\n \r\n"," with ref-specific exclusions for C# script\r\n            ":" 带有C＃脚本的特定于Ref的排除\r\n            \r\n","\r\n            The document that completion was invoked within.\r\n            ":"\r\n            在其中调用了完成的文件。\r\n            \r\n","\r\n            Gets the DisplayName for the given node.\r\n            ":"\r\n            获取给定节点的显示名。\r\n            \r\n","The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.":"无效的参考类型的注释仅应在“ #nullable”注释上下文中的代码中使用。自动生成的代码需要在源中明确的“ #nullable”指令。\r\n","\r\n Register declaration of predefined CorLib type in this Assembly.\r\n ":"\r\n 在此组件中注册预定义的Corlib类型的声明。\r\n \r\n","\r\n Creates a local and assigns it the given bound expression.\r\n ":"\r\n 创建本地并为其分配给定的绑定表达式。\r\n \r\n","\r\n  Looks up a localized string similar to Statement cannot end a block outside of a line 'If' statement..\r\n":"\r\n  查找类似于语句的本地化字符串无法结束“ if”语句之外的块。\r\n\r\n","\r\n A Declare statement that declares an external DLL method.\r\n ":"\r\n 声明声明，该声明声明外部DLL方法。\r\n \r\n","\r\n Creates the syntax representation of a see element within xml documentation comments,\r\n that points to a language keyword.\r\n ":"\r\n 创建XML文档注释中的See元素的语法表示，\r\n 这指向语言关键字。\r\n \r\n","\r\n The set of captured variables seen in the method body.\r\n ":"\r\n 在方法主体中看到的一组捕获变量。\r\n \r\n","\r\n §11.8.1 Overloaded Method Resolution\r\n      6.\tNext, if, given any two members of the set, M and N, M is more applicable than N \r\n         to the argument list, eliminate N from the set. If more than one member remains \r\n         in the set and the remaining members are not equally applicable to the argument \r\n         list, a compile-time error results.\r\n      7.\tOtherwise, given any two members of the set, M and N, apply the following tie-breaking rules, in order.\r\n \r\n Returns amount of applicable candidates left.\r\n \r\n Note that less applicable candidates are going to be eliminated if and only if there are most applicable\r\n candidates.\r\n ":"\r\n §11.8.1超载方法分辨率\r\n      6.接下来，如果给定设置的任何两个成员，M和N，M比N更适用\r\n         到参数列表，从集合中消除n。如果有多个成员\r\n         在集合和其余成员中，不同样适用于参数\r\n         列表，一个编译时错误结果。\r\n      7.否则，鉴于集合M和N的任何两个成员，请按顺序应用以下抢七规则。\r\n \r\n 退货剩余的适用候选人金额。\r\n \r\n 请注意，仅当最适用的情况下，且仅在\r\n 候选人。\r\n \r\n","Type '{0}' cannot be embedded because it has a non-abstract member. Consider setting the 'Embed Interop Types' property to false.":"键入'{0}'不能嵌入，因为它具有非吸收成员。考虑将“嵌入Interop类型”属性设置为false。\r\n","The syntax node for the using block":"使用块的语法节点\r\n","\r\n A collection of statements outside the region that jump into the region.\r\n ":"\r\n 该地区跳入该地区的陈述集合。\r\n \r\n","\r\n            Indicates if the completion is trigger by toggle the expander.\r\n            ":"\r\n            指示是否通过切换扩展器来触发完成。\r\n            \r\n","\r\n Gets the retargeted System.Type type symbol.\r\n ":"\r\n 获取retargeted system.type类型符号。\r\n \r\n","\r\n Returns true if the first set of constraint types\r\n is a subset of the second set.\r\n ":"\r\n 如果第一组约束类型，则返回true\r\n 是第二组的子集。\r\n \r\n","Generate abstract property '{1}.{0}'":"生成抽象属性'{1}。{0}'\r\n","\r\n            Used by the documentation comment rewriters to identify top-level ":"\r\n            文档评论重写者使用的识别顶级\r\n","\r\n            Provides and caches analyzer information.\r\n            ":"\r\n            提供和缓存分析仪信息。\r\n            \r\n","\r\n Implements shadowing based on\r\n §11.8.1 Overloaded Method Resolution.\r\n    7.10.\tIf the overload resolution is being done to resolve the target of a \r\n             delegate-creation expression from an AddressOf expression and M is a \r\n             function, while N is a subroutine, eliminate N from the set.\r\n ":"\r\n 基于\r\n §11.8.1超载方法分辨率。\r\n    7.10。如果完成了超负荷解决方案以解决一个目标\r\n             来自地址表达式的委托创造表达和m是一个\r\n             功能，而n是子例程，从集合中消除n。\r\n \r\n"," if a stub needed for conversion; otherwise, ":" 如果需要转换存根；否则，\r\n","\r\n            ```a{5,10}```\r\n            ":"\r\n            ````{5,10}````''\r\n            \r\n","\r\n            The default rule that determines if the enter key is passed through to the editor after the selected item has been committed.\r\n            Individual ":"\r\n            确定所选项目后，确定Enter密钥是否传递给编辑器的默认规则。\r\n            个人\r\n"," since\r\n            it's only used for a conservative approximation (shorter is more conservative when trying\r\n            to determine the minimum number of members that will fill the output).\r\n            ":" 自从\r\n            它仅用于保守近似（尝试时较短\r\n            确定将填充输出的最小成员数量）。\r\n            \r\n","Apply file header preferences":"应用文件标头首选项\r\n","\r\n Combined flag to express that a modified identifier appeared in a parameter of a lambda.\r\n ":"\r\n 组合标志表明修改后的标识符出现在lambda的参数中。\r\n \r\n","\r\n            Updates or adds an .editorconfig ":"\r\n            更新或添加.EditorConfig\r\n","\r\n  Looks up a localized string similar to '{0}' cannot expose type '{1}' in {2} '{3}' through {4} '{5}'..\r\n":"\r\n  查找类似于“ {0}'的本地化字符串，无法公开{2}'{3}'in {4}'{5}'..中的类型'{1}'..\r\n\r\n","Make method synchronous":"使方法同步\r\n","\r\n Is the node the name of a named argument of an invocation or object creation expression, \r\n but not an attribute.\r\n ":"\r\n 是节点是调用或对象创建表达式的命名参数的名称吗？\r\n 但不是属性。\r\n \r\n","\r\n This property may be called while containing type is still being constructed.\r\n Therefore it can take membersInProgress context to ensure that returned symbol\r\n is relevant to the current type construction.\r\n (there could be several optimistically concurrent sessions)\r\n ":"\r\n 该属性仍在构造时可以调用。\r\n 因此，可以采用会员的上下文来确保返回的符号\r\n 与当前类型的结构有关。\r\n （可能有几个乐观的并发会议）\r\n \r\n","foreach statement":"foreach声明\r\n","\r\n Since this method is intended to be used for error reporting, it stops as soon as it finds\r\n any type forwarder - it does not check other assemblies for consistency or better results.\r\n \r\n NOTE: unlike in C#, this method searches for type forwarders case-insensitively.\r\n ":"\r\n 由于此方法旨在用于错误报告，因此一旦找到它就会停止\r\n 任何类型的转发器 - 它不会检查其他组件是否有一致性或更好的结果。\r\n \r\n 注意：与C＃不同，此方法在casemensitation中搜索类型的转发器。\r\n \r\n","receiver will be changed as a result":"结果将更改接收器\r\n","\r\n Verify the default value matches the default value from any earlier attribute\r\n (DefaultParameterValueAttribute, DateTimeConstantAttribute or DecimalConstantAttribute).\r\n If not, report ERR_ParamDefaultValueDiffersFromAttribute.\r\n ":"\r\n 验证默认值从任何早期属性中匹配默认值\r\n （DefaultParameTervAlueatTribute，dateTimeConstantAttribute或DecimalConstantAttribute）。\r\n 如果不是，请报告ERR_PARAMDEFAULTVALUEDIFFERSFROMPTRIBUTE。\r\n \r\n","\r\n Represents line breaks that are syntactically insignificant.\r\n ":"\r\n 表示句法无关紧要的线断裂。\r\n \r\n","\r\n            Creates a default converter where foreach is joined with some children statements but other children statements are kept unmodified.\r\n            Example:\r\n            foreach(...)\r\n            {\r\n                if (condition)\r\n                {\r\n                   doSomething();\r\n                }\r\n            }\r\n            is converted to\r\n            foreach(... where condition)\r\n            {\r\n                   doSomething(); \r\n            }\r\n            ":"\r\n            创建一个默认的转换器，其中foreach与一些儿童陈述相连，但其他儿童陈述却没有修改。\r\n            例子：\r\n            foreach（...）\r\n            {\r\n                如果（条件）\r\n                {\r\n                   做一点事（）;\r\n                }\r\n            }\r\n            被转换为\r\n            foreach（...状况）\r\n            {\r\n                   做一点事（）;\r\n            }\r\n            \r\n","Generate field '{1}.{0}'":"生成字段'{1}。{0}'\r\n","\r\n  Looks up a localized string similar to Cannot infer an element type. Specifying the type of the array might correct this error..\r\n":"\r\n  查找类似于不能推断元素类型的本地化字符串。指定数组的类型可能会纠正此错误。\r\n\r\n","\r\n            Formats object members to a list.\r\n            \r\n            Inline == false:\r\n            ":"\r\n            格式化对象成员列表。\r\n            \r\n            inline == false：\r\n            \r\n","\r\n            Get diagnostics of the given diagnostic ids from the given solution. all diagnostics returned should be up-to-date with respect to the given solution.\r\n            Note that for project case, this method returns diagnostics from all project documents as well. Use ":"\r\n            从给定解决方案中获取给定诊断ID的诊断。返回的所有诊断均应相对于给定的解决方案进行最新。\r\n            请注意，对于项目案例，此方法也从所有项目文档中返回诊断。利用\r\n","\r\n The \"Else\" statement that begins the \"Else\" block.\r\n ":"\r\n 开始“ else”块的“ else”语句。\r\n \r\n","\r\n Full type name with generic name mangling.\r\n ":"\r\n 带有通用名称的完整名称。\r\n \r\n"," \r\n A bound node rewriter that rewrites types properly (which in some cases the automatically-generated). \r\n This is used in the lambda rewriter, the iterator rewriter, and the async rewriter.\r\n ":" \r\n 正确重写类型的绑定节点重写器（在某些情况下是自动生成的）。\r\n 这用于Lambda重写器，迭代器重写器和异步重写器中。\r\n \r\n","\r\n            Can't be null.  Even if we weren't able to read in metadata, we'll still create an empty\r\n            index.\r\n            ":"\r\n            不能无效。即使我们无法阅读元数据，我们仍然会创建一个空的\r\n            指数。\r\n            \r\n","The \"yyyy\" custom format specifier represents the year with a minimum of four digits. If the year has more than four significant digits, they are included in the result string. If the year has fewer than four digits, the number is padded with leading zeros ...":"“ YYYY”自定义格式指定符代表至少四位数的年份。如果这一年有四个以上的重要数字，则将其包含在结果字符串中。如果这一年的数字少于四位数，那么这个数字将带有领先的零...\r\n","The name of the symbol to find. If null Is specified then symbols\r\n with any names are returned.":"要查找的符号的名称。 如果指定null，则符号\r\n 与任何名称返回。\r\n","\r\n            The project contains valid changes that require application of a delta.\r\n            ":"\r\n            该项目包含需要应用三角洲的有效更改。\r\n            \r\n","\r\n Get a source location key for sorting. For performance, it's important that this\r\n be able to be returned from a symbol without doing any additional allocations (even\r\n if nothing is cached yet.)\r\n ":"\r\n 获取用于分类的源位置密钥。为了表现，重要的是\r\n 能够从符号中返回而无需进行任何其他分配（甚至\r\n 如果什么都没有缓存。）\r\n \r\n"," and\r\n             offers to update to ":" 和\r\n             优惠以更新为\r\n","\r\n Represents a \"Catch ...\" block.\r\n ":"\r\n 代表一个“捕获...”块。\r\n \r\n","Do not use '_' for a case constant.":"请勿将“ _”用于情况常数。\r\n","\r\n            ```-[f-m]``` in a pattern like ```[a-z-[f-m]]```.  A subtraction must come last in a \r\n            character class, and removes some range of chars from the character class built up\r\n            so far.\r\n            ":"\r\n            ```` -  [f-m]````在类似``[a-z- [f-m]]````````减法必须持续到\r\n            角色类别，并删除了构建角色类的一些字符\r\n            至今。\r\n            \r\n","\r\n            Returns the latest token the lexer has produced, and then asks the lexer to \r\n            produce the next token after that.\r\n            ":"\r\n            返回Lexer生产的最新代币，然后要求Lexer\r\n            在那之后产生下一个令牌。\r\n            \r\n",", which owns the opened metadata and must be disposed once the caller is done reading the data, \r\n            or null if the assembly is not available.\r\n            ":"，拥有打开的元数据，必须在呼叫者阅读数据后处置，\r\n            或null如果没有可用。\r\n            \r\n"," node, not the ":" 节点，不是\r\n","The formatting options to apply.  If Nothing is passed, ":"要应用的格式选项。如果什么都没有通过，\r\n","\r\n The value for the XmlKeyword property.\r\n ":"\r\n XMLKeyWord属性的值。\r\n \r\n","\r\n            Gets the top most enclosing statement or CrefSyntax as target to call MakeExplicit on.\r\n            It's either the enclosing statement, or if this statement is inside of a lambda expression, the enclosing\r\n            statement of this lambda.\r\n            ":"获取最封闭式的语句或Crefsyntax作为目标，以呼吁MakeSexplicit。\r\n            它要么是封闭语句，要么是此语句在lambda表达式内部\r\n            这个lambda的声明。\r\n            \r\n","\r\n            Subclasses should implement this to support fixing all given diagnostics efficiently.\r\n            ":"\r\n            子类应实施此功能，以支持修复所有给定的诊断。\r\n            \r\n","\r\n  Looks up a localized string similar to Executables cannot be satellite assemblies; culture should always be empty.\r\n":"查找类似于可执行文件的本地化字符串不能是卫星组件；文化应该永远是空的。\r\n\r\n"," in several \r\n            cases, including:\r\n            \r\n                1. No edits.\r\n                2. Edits would change more than whitespace.\r\n                3. A previous code action was created that already had the same effect.\r\n            ":" 在几个\r\n            案件，包括：\r\n            \r\n                1.没有编辑。\r\n                2.编辑将比空格变化更多。\r\n                3.创建了先前的代码操作，该操作已经具有相同的效果。\r\n            \r\n","The bounds":"边界\r\n","\r\n            Gets the span of the syntax element at the caret position.\r\n            This is the most common value used for ":"\r\n            获取在Caret位置的语法元素的跨度。\r\n            这是最常用的值\r\n","\r\n            Given an expression node, tries to generate an appropriate name that can be used for\r\n            that expression. \r\n            ":"\r\n            给定表达节点，试图生成一个可用于用于的适当名称\r\n            那个表达。\r\n            \r\n","A bound access to the Current property.":"对当前属性的约束访问。\r\n","\r\n Given result of binding preceding query operators, the source, bind the following Where operator.\r\n \r\n     {Preceding query operators} Where {expression}\r\n \r\n Ex: From a In AA Where a > 0 ==> AA.Where(Function(a) a > b)\r\n \r\n ":"\r\n 给定绑定前面的查询操作员的结果，源，将以下位置绑定在操作员的位置。\r\n \r\n     {先前的查询操作员}其中{expression}\r\n \r\n 例如：从aa中的一个> 0 ==> aa.where（function（a）a> b）\r\n \r\n \r\n","\r\n Represents a constructor block declaration: A declaration that has a beginning\r\n declaration, a body of executable statements and an end statement.\r\n ":"\r\n 代表构造函数块声明：具有开始的声明\r\n 声明，可执行语句的主体和结束陈述。\r\n \r\n","\r\n  Looks up a localized string similar to 'If', 'ElseIf', 'Else', 'Const', 'Region', 'ExternalSource', 'ExternalChecksum', 'Enable', 'Disable', 'End' or 'R' expected..\r\n":"\r\n  查找类似于“ if”，“ elseif”，“ else”，“ const”，“ region”，“ externalsource'，'externalCheckSum'，'enable'，'enable'，“ disable”，“ disable”，“ end”，“ end”或“ r”）的局部字符串预期的..\r\n\r\n","\r\n Returns True if error or warning was reported.\r\n \r\n This function is invoked on the occasion of a Narrowing or NoConversion.\r\n It looks at the conversion. If the conversion could have been helped by variance in\r\n some way, it reports an error/warning message to that effect and returns true. This\r\n message is a substitute for whatever other conversion-failed message might have been displayed.\r\n\r\n Note: these variance-related messages will NOT show auto-correct suggestion of using CType. That's\r\n because, in these cases, it's more likely than not that CType will fail, so it would be a bad suggestion\r\n ":"\r\n 如果报告错误或警告，则返回为真。\r\n \r\n 在变窄或非转换之际调用此功能。\r\n 它查看转换。如果转换可以通过差异来帮助\r\n 某种程度上，它将错误/警告消息报告给该效果并返回true。这个\r\n 消息是替代可能显示的任何其他转换消息。\r\n\r\n 注意：这些与方差相关的消息不会显示使用CTYPE的自动校正建议。那是\r\n 因为在这些情况下，CTYPE更有可能失败，所以这将是一个不好的建议\r\n \r\n","yield break statement":"屈服陈述\r\n","\r\n  Looks up a localized string similar to Initializer expected..\r\n":"\r\n  查找类似于初始化器的本地化字符串。\r\n\r\n","The return type for ++ or -- operator must either match the parameter type, or be derived from the parameter type, or be the containing type's type parameter constrained to it unless the parameter type is a different type parameter.":"++或 - 运算符的返回类型必须匹配参数类型，或者是从参数类型派生的，或者是包含类型的类型参数，除非参数类型是不同的类型参数。\r\n","\r\n If this module forwards the given type to another assembly, return that assembly;\r\n otherwise, return Nothing.\r\n ":"\r\n 如果此模块将给定类型转发到另一个组件上，请返回该组件；\r\n 否则，什么也没返回。\r\n \r\n","\r\n The name of the delegate being declared.\r\n ":"\r\n 宣布代表的名字。\r\n \r\n","\r\n Returns a copy of this with the MinusMinusGreaterThanToken property changed to\r\n the specified value. Returns this instance if the specified value is the same\r\n as the current value.\r\n ":"\r\n 返回其中的副本，其中Minusminusgreathantoken财产更改为\r\n 指定值。如果指定的值相同，则返回此实例\r\n 作为当前值。\r\n \r\n","\r\n            True if this quick info came from hovering over an 'await' keyword, which we show the return\r\n            type of with special text.\r\n            ":"\r\n            是的，如果此快速信息来自悬停在“等待”关键字的情况下，我们显示了返回\r\n            特殊文本的类型。\r\n            \r\n","\r\n The \"@\" type character.\"\r\n ":"\r\n “@”类型字符。\r\n \r\n","\r\n Specifies whether existing, \"unused\" locals (corresponding to proxies) are preserved during lambda rewriting.\r\n ":"\r\n 指定在Lambda重写期间保留现有的“未使用”当地人（对应代理）。\r\n \r\n","\r\n  Looks up a localized string similar to 'Assembly' or 'Module' expected..\r\n":"\r\n  查找类似于“汇编”或“模块”的局部字符串。\r\n\r\n","\r\n            The span of text to display in the hint on mouse hover.\r\n            ":"\r\n            要在鼠标悬停的提示中显示的文本跨度。\r\n            \r\n","into clause":"进入子句\r\n","\r\n Verifies that given symbol does not have loops in its inheritance hierarchy\r\n and reports appropriate diagnostics.\r\n ":"\r\n 验证给定符号在其继承层次结构中没有循环\r\n 并报告适当的诊断。\r\n \r\n","\r\n  Looks up a localized string similar to 'Inherits' statements must precede all declarations in an interface..\r\n":"\r\n  查找类似于“继承”语句的本地化字符串必须先于接口中的所有声明。\r\n\r\n","\r\n Gets type information about an attribute syntax node. This is the worker\r\n function that is overridden in various derived kinds of Semantic Models. It can assume that \r\n CheckSyntaxNode has already been called.\r\n ":"\r\n 获取有关属性语法节点的类型信息。这是工人\r\n 在各种派生的语义模型中被覆盖的函数。它可以假设\r\n checksyntaxnode已被调用。\r\n \r\n","\r\n            The cancellation token to use for this operation.\r\n            ":"\r\n            用于此操作的取消令牌。\r\n            \r\n","\r\n Returns a copy of this with the ReDimKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中redimkeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n  Create a local symbol from a local variable declaration.\r\n ":"\r\n  从局部变量声明创建本地符号。\r\n \r\n","\r\n  Looks up a localized string similar to Type '{0}' exported from module '{1}' conflicts with type declared in primary module of this assembly..\r\n":"\r\n  查找类似于从模块'{1}'导出的类型“ {0}”类型的本地化字符串与此汇编主模块中声明的类型冲突。\r\n\r\n","\r\n A collection of the local variables that have been referenced in anonymous functions\r\n and therefore must be moved to a field of a frame class.\r\n ":"\r\n 匿名函数中已引用的本地变量集合\r\n 因此，必须移至框架类的字段。\r\n \r\n","\r\n            Provide a way to control solution crawler.\r\n            ":"\r\n            提供一种控制解决方案爬网的方法。\r\n            \r\n","Cannot create a function pointer for '{0}' because it is not a static method":"无法为“ {0}”创建功能指针，因为它不是静态方法\r\n","\r\n Returns true if the binder is performing early decoding of a\r\n (well-known) attribute.\r\n ":"\r\n 如果粘合剂正在执行早期解码\r\n （众所周知）属性。\r\n \r\n","\r\n The value for the NameOfKeyword property.\r\n ":"\r\n NameFkeyword属性的值。\r\n \r\n","\r\n The value for the ResumeKeyword property.\r\n ":"\r\n 简历属性属性的值。\r\n \r\n","\r\n Represent a parameter to a method, property, constructor, etc.\r\n ":"\r\n 代表方法，属性，构造函数等的参数。\r\n \r\n",", which Is a snapshot of nodes from the original document.\r\n We're mutating the tree as we rewrite, so it's important to grab a snapshot of the\r\n nodes that we're going to reparent before we enumerate them.\r\n ":"，这是原始文档中节点的快照。\r\n 当我们重写时，我们正在突变这棵树，因此抓住一张快照很重要\r\n 在列举它们之前，我们将要进行修复的节点。\r\n \r\n","\r\n            Determines whether it is possible to navigate to the given line/offset in the specified document.\r\n            ":"确定是否可以导航到指定文档中的给定行/偏移。\r\n            \r\n","Private member '{0}' is unused":"私人成员'{0}'未使用\r\n","\r\n Implementation-specific name for labels to mark state machine resume points.\r\n ":"\r\n 标签的实现名称，以标记状态机简历点。\r\n \r\n","\r\n Each statement and the begin will be displayed on a separate line. No empty lines.\r\n ":"每个语句和开始都将显示在单独的行上。没有空线。\r\n \r\n","\r\n Gets the AssemblySymbol that represents the assembly being created.\r\n ":"\r\n 获取代表正在创建的组件的汇编符号。\r\n \r\n","\r\n  Looks up a localized string similar to Interface can inherit only from another interface..\r\n":"\r\n  查找类似于接口的本地化字符串只能从另一个接口继承。\r\n\r\n","Too many | in (?()|)":"太多|在（？（）|）中\r\n","\r\n Gets the syntax tree.\r\n ":"\r\n 获取语​​法树。\r\n \r\n"," we started the add-import analysis in.\r\n            ":" 我们开始了附加信息分析。\r\n            \r\n","\r\n            Show the confirmation message, if available, before attempting to apply the changes.\r\n            ":"\r\n            在尝试应用更改之前，请显示确认消息（如果有）。\r\n            \r\n","\r\n            The namespaces, static classes and aliases imported by the script.\r\n            ":"\r\n            脚本导入的名称空间，静态类和别名。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Catch' cannot appear after 'Finally' within a 'Try' statement..\r\n":"\r\n  查找类似于“捕获”的本地化字符串，在“ try”语句中“最后”之后无法出现。\r\n\r\n","\r\n Binder used for interiors of documentation comment for binding 'name' attribute \r\n value of 'typeparamref' documentation comment tag\r\n ":"\r\n 用于绑定“名称”属性的文档注释内部的活页夹\r\n “ typeparamref”文档评论标签的值\r\n \r\n","\r\n Returns data decoded from source assembly attributes or null if there are none.\r\n ":"\r\n 返回从源组件属性解码的数据或null如果没有的数据。\r\n \r\n","All letter characters. This includes the Lu, Ll, Lt, Lm, and Lo characters.":"所有字母字符。这包括LU，LL，LT，LM和LO字符。\r\n","\r\n Resolve constraints, binding and checking for conflicts as necessary. This is an\r\n internal method for resolving dependent sets of constraints and handling cycles.\r\n It will be called indirectly for core implementations (SourceTypeParameterSymbol and\r\n PETypeParameterSymbol) as a result of accessing constraint properties on this class.\r\n ":"\r\n 解决必要的约束，约束和检查是否需要冲突。这是个\r\n 解决依赖的约束和处理周期的内部方法。\r\n 它将间接称为核心实现（sourcetypeparametersymbol和\r\n petypeparametersymbol）由于在此类上访问了约束属性。\r\n \r\n","\r\n            Descriptive text to place after ":"\r\n            描述性文本以后放置\r\n","renderedItem":"渲染\r\n","\r\n The \"Exit\" keyword.\r\n ":"\r\n “退出”关键字。\r\n \r\n"," All the constructors in the cycle will be reported ":" 周期中的所有构造函数将报告\r\n","\r\n            This method iterates through the variables in the expression and maps the variables back to the parameter\r\n            it is associated with. It then maps the parameter back to the argument at the invocation site and gets the\r\n            index to retrieve the updated arguments at the invocation.\r\n            ":"\r\n            此方法通过表达式中的变量迭代，并将变量映射回参数\r\n            它与之相关。然后，它将参数映射回调用站点上的参数，并获取\r\n            索引在调用中检索更新的参数。\r\n            \r\n","\r\n            Clone the current collector into a new one with\r\n            the same parent but a separate progress collector.\r\n            This allows collection of items given the same state\r\n            as this collector while also keeping them \"grouped\" separately.\r\n            ":"\r\n            克隆当前的收藏家\r\n            同一父母，但是一个单独的进度收藏家。\r\n            这允许收集给定状态的项目\r\n            作为该收藏家，同时还将它们分开“分组”。\r\n            \r\n",".\r\n E.g. if the current compilation references a metadata file that has changed since the creation of the compilation\r\n the New compilation is going to use the updated version, while the current compilation will be using the previous (it doesn't change).\r\n ":"。\r\n 例如。如果当前汇编引用自汇编创建以来已更改的元数据文件\r\n 新的汇编将使用更新版本，而当前汇编将使用以前的版本（不更改）。\r\n \r\n","Flags for the modifiers.":"修饰符的标志。\r\n","Remove unused parameter '{0}' if it is not part of a shipped public API":"删除未使用的参数'{0}'如果它不是发货公共API的一部分\r\n","o switch { int => ... }":"o开关{int => ...}\r\n","\r\n            Evaluate a format string with possible member references enclosed in braces. \r\n            E.g. \"goo = {GetGooString(),nq}, bar = {Bar}\".\r\n            ":"\r\n            评估格式字符串，其中包含在牙套中的可能成员参考。\r\n            例如。 “ goo = {getGooString（），nq}，bar = {bar}”。\r\n            \r\n","Adding an imported method requires restarting the application.":"添加导入的方法需要重新启动应用程序。\r\n","Introduce field":"介绍场\r\n","Merge with outer '{0}' statement":"与外部'{0}'语句合并\r\n","\r\n should be used instead.\r\n ":"\r\n 应该使用。\r\n \r\n","\r\n  Looks up a localized string similar to Statement is not valid inside '{0}' block..\r\n":"\r\n  查找类似于语句的本地化字符串在'{0}'块中无效。\r\n\r\n","\r\n  Looks up a localized string similar to ')' expected..\r\n":"\r\n  查找类似于'）的本地化字符串。\r\n\r\n","Inline '{0}'":"内联'{0}'\r\n","\r\n A list of \"Catch\" blocks which may be executed if an exception is thrown while\r\n executing the statements in the \"Try\" block.\r\n ":"\r\n 如果抛出异常，则可以执行的“捕获”块的列表\r\n 在“尝试”块中执行语句。\r\n \r\n","\r\n            Gets the navigation target for the text, or ":"\r\n            获取文本的导航目标，或\r\n","\r\n            Create the Edit representing the deletion of all trivia between left and right.\r\n            ":"\r\n            创建表示左右之间所有琐事的删除的编辑。\r\n            \r\n","Changing {0} from asynchronous to synchronous requires restarting the application.":"将{0}从异步更改为同步需要重新启动应用程序。\r\n","\r\n The value for the DelegateExpression property.\r\n ":"\r\n 委托表达属性的值。\r\n \r\n","\r\n Returns True if this conversion a narrowing conversion, and not a widening conversion. \r\n ":"\r\n 如果转换变窄，而不是扩大转换，则返回真实。\r\n \r\n","\r\n Also, the following are affected if container=Nothing (and, for the latter, when container=Nothing or arity=0):\r\n ":"\r\n 另外，如果容器= nothing（对于后者，当容器= Nothing或Arity = 0）时，会影响以下影响：\r\n \r\n","Parameter '{0}' is unread. Did you forget to use it to initialize the property with that name?":"参数'{​​0}'是未读的。您是否忘记使用它用该名称初始化该属性？\r\n","\r\n Represents a Select Case statement. This statement always occurs as the Begin\r\n of a SelectBlock.\r\n ":"\r\n 代表选择案例语句。此陈述总是在开始时发生\r\n selectblock。\r\n \r\n","Interpolation can be simplified":"可以简化插值\r\n","\r\n            Similar to FixAllSuggestedAction, but in a location that can be used by\r\n            both local Roslyn and LSP.\r\n            ":"类似于fixallsuggesteDaction，但在可以使用的位置\r\n            当地的罗斯林和LSP。\r\n            \r\n","Events":"事件\r\n","\r\n            Implemented member for member in class or structure. Shown as I↑\r\n            ":"\r\n            在课堂或结构中实施成员。显示为↑\r\n            \r\n","\r\n Returns True if the conversion exists, either as a widening or narrowing conversion.\r\n ":"如果存在转换，则返回为true，既可以作为扩大或变窄的转换。\r\n \r\n","\r\n The list of arguments. This may be empty. Omitted argument are represented by\r\n an OmittedArgumentSyntax node.\r\n ":"\r\n 参数列表。这可能是空的。省略的论点由\r\n 省略argumentsyntax节点。\r\n \r\n","\r\n            Operator precedence classes from section 7.3.1 of the C# language specification.\r\n            ":"\r\n            C＃语言规范第7.3.1节的操作员优先类。\r\n            \r\n","\r\n            Implements a code fix for file header diagnostics.\r\n            ":"\r\n            实施文件标头诊断的代码修复。\r\n            \r\n","\r\n Returns a copy of this with the Version property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中版本属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Returns a NamespaceSymbol representing the global (root) namespace, with\r\n module extent, that can be used to browse all of the symbols defined in this module.\r\n ":"\r\n 返回代表全局（root）名称空间的名称pacesembol，带有\r\n 模块范围，可用于浏览本模块中定义的所有符号。\r\n \r\n","Unexpected interface member kind: {0}":"意外接口成员类型：{0}\r\n","\r\n                 . name1 (arglist1) remainder1\r\n                 . name2 (arglist2) remainder2\r\n             ":"\r\n                 。 name1（arglist1）剩余1\r\n                 。 name2（arglist2）剩余2\r\n             \r\n","\r\n The value for the EndTryStatement property.\r\n ":"\r\n Endrystatement属性的价值。\r\n \r\n","\r\n Given a property statement syntax get the corresponding property symbol.\r\n ":"\r\n 给定的属性语句语法获取相应的属性符号。\r\n \r\n","\r\n  Looks up a localized string similar to Operators cannot be declared '{0}'..\r\n":"\r\n  查找类似于运算符的本地化字符串，无法声明“ {0}”。\r\n\r\n","\r\n  Looks up a localized string similar to Constructor must not have the 'Async' modifier..\r\n":"\r\n  查找类似于构造函数的本地化字符串，不得具有“ async”修饰符。\r\n\r\n","\r\n  Looks up a localized string similar to 'RemoveHandler' definition missing for event '{0}'..\r\n":"\r\n  查找类似于事件'{0}'的“ removehandler”定义类似的本地化字符串。\r\n\r\n","\r\n            The list of items to present to the user.\r\n            ":"\r\n            要介绍给用户的项目列表。\r\n            \r\n","\r\n Base class for symbols representing non-generic or open generic types contained within constructed generic type.\r\n For example: A(Of Integer).B, A(Of Integer).B.C or A(Of Integer).B.C(Of ).\r\n ":"\r\n 代表构造的通用类型中包含的非传播或开放式通用类型的符号的基类。\r\n 例如：a（integer）.b，a（integer）.b.c或a（integer）.b.c（of）。\r\n \r\n","\r\n ParseCast parses CType, DirectCast, TryCast.\r\n CCCastExpression ->   DirectCast ( CCExpression , TypeName ) \r\n                     | TryCast ( CCExpression , TypeName ) \r\n                     | CType ( CCExpression , TypeName ) \r\n                     { | CastTarget ( CCExpression ) }\r\n ":"\r\n parsecast解析CTYPE，Directcast，trycast。\r\n CCCASTExpression-> Directcast（CCEXPRESSION，TYPENAME）\r\n                     | trycast（ccexpression，键入）\r\n                     | ctype（ccexpression，键入）\r\n                     {| casttarget（ccexpression）}\r\n \r\n"," names in use.\r\n            Names are used for ordering providers with the ":" 使用中的名称。\r\n            名称用于订购提供商\r\n","\r\n This is the FULL namespace name (e.g., \"System.Collections.Generic\")\r\n of the type that couldn't be found.\r\n ":"\r\n 这是完整的名称名称（例如，“ system.collections.generic”）\r\n 找不到的类型。\r\n \r\n","\r\n            This is useful for cases such as tracking arguments, where each\r\n            argument may be an expression or something else. We want to track each\r\n            argument expression in the correct order, but a single argument may produce\r\n            multiple items. By cloning we can track the items for each argument and then\r\n            gather them all at the end to report in the correct order.\r\n            ":"\r\n            这对于诸如跟踪参数之类的案例很有用\r\n            参数可能是表达方式或其他内容。我们想跟踪每个\r\n            以正确顺序的论点表达式，但是单个参数可能会产生\r\n            多个项目。通过克隆，我们可以跟踪每个参数的项目，然后\r\n            最后收集所有内容以正确的顺序报告。\r\n            \r\n","\r\n            Use an explicit value to populate call sites, and convert \r\n            arguments to named arguments even if not required. Often\r\n            useful for literal callsite values like \"true\" or \"null\".\r\n            ":"\r\n            使用明确的值来填充呼叫站点，然后转换\r\n            即使不需要的论点也要指定参数。经常\r\n            对于“ true”或“ null”之类的文字呼叫值有用。\r\n            \r\n","name shadowing in nested functions":"嵌套功能中的名称阴影\r\n","The document to insert the brace at the position.":"将支架插入该位置的文档。\r\n","\r\n Creates a binder for a source attribute block from the containing type or containing namespace.\r\n This binder is used by the normal compilation code path for source attributes. In this case, no\r\n containing binder exists.\r\n ":"\r\n 从包含类型或包含名称空间的源属性块中创建粘合剂。\r\n 源属性的普通汇编代码路径使用此粘合剂。在这种情况下，不\r\n 存在包含粘合剂。\r\n \r\n","Rename file to {0}":"将文件重命名为{0}\r\n","The next variables.":"下一个变量。\r\n","\r\n            Optional paired overload that takes a ":"\r\n            可选的配对过载\r\n","\r\n The value for the WhenClause property.\r\n ":"\r\n 当clale属性的值。\r\n \r\n","Configure severity for all analyzers":"为所有分析仪配置严重性\r\n",".\r\n            This function checks the operation tree shape in context of\r\n            an ":"。\r\n            此功能在以下情况下检查操作树的形状\r\n            一个\r\n","\r\n Returns a copy of this with the SyncLockKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中SynclockKeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            Indicates that the code style diagnostic can be enforced on build when explicitly enabled in a configuration file,\r\n            but is not part of the ":"\r\n            表示在配置文件中明确启用时，可以在构建中执行代码样式诊断，\r\n            但不是\r\n","\r\n A comma separated list of attribute declarations in this attribute list.\r\n ":"\r\n 此属性列表中的逗号分隔属性声明列表。\r\n \r\n"," property on the type.  Must be public, non-static, no-parameter,\r\n            ":" 类型上的属性。必须是公共，非静态的，无参数，\r\n            \r\n","\r\n  Looks up a localized string similar to code page '{0}' is invalid or not installed.\r\n":"\r\n  查找类似于代码页'{0}'的本地化字符串是无效或未安装的。\r\n\r\n","\r\n If IsConst returns true, then returns the value of the constant or Enum member.\r\n If IsConst return false, then returns Nothing.\r\n ":"\r\n 如果ISCONST返回true，则返回常数或枚举成员的值。\r\n 如果isConst返回false，则什么都不返回。\r\n \r\n","Return type of the property named \"Current\" if found.":"如果找到了名为“当前”的属性的返回类型。\r\n","\r\n  Looks up a localized string similar to can't open '{0}' for writing: {1}.\r\n":"\r\n  查找类似于无法打开'{0}'的本地化字符串进行写作：{1}。\r\n\r\n","True unless the project outputs can't be read.":"除非项目输出无法读取，否则是正确的。\r\n","\r\n  Looks up a localized string similar to 'Await' can only be used within an Async method. Consider marking this method with the 'Async' modifier and changing its return type to 'Task'..\r\n":"\r\n  查找类似于“等待”的本地化字符串只能在异步方法中使用。考虑使用“ async”修饰符标记此方法，然后将其返回类型更改为“任务”。\r\n\r\n","An ImmutableArray containing all the types that are members of this symbol with the given name. \r\n If this symbol has no type members with this name,\r\n returns an empty ImmutableArray. Never returns Nothing.":"一个immutableArray包含具有给定名称的所有类型。\r\n 如果此符号没有此名称的类型成员，\r\n 返回一个空的Immutablearray。永远不会返回。\r\n","Invert conditional":"有条件的反转\r\n","\r\n This instance is used to compare custom modifiers, parameter and return types, including byref.\r\n ":"\r\n 此实例用于比较自定义修饰符，参数和返回类型，包括BYREF。\r\n \r\n"," is in the right place in the syntax tree.\r\n ":" 位于语法树中的正确位置。\r\n \r\n","\r\n The expression whose value is being yielded.\r\n ":"\r\n 其价值的表达式。\r\n \r\n","\r\n Flags to specify where the decoding of the modified identifier's type happens.\r\n ":"\r\n 标志以指定修改后标识符类型的解码发生的位置。\r\n \r\n","\r\n returns type arguments or Nothing if group does not have type arguments.\r\n ":"\r\n 返回类型参数或没有类型参数，什么也没有。\r\n \r\n","The placeholder for the bound enumerator local.":"本地枚举者的占位符。\r\n","\r\n Return the source location of the error, if any. If there error was\r\n from a constraint, and that constraint was from source, its location\r\n is returned. Otherwise if the type parameter was from source, its\r\n location is returned. If neither is from source, Nothing is returned.\r\n ":"\r\n 返回错误的源位置（如果有）。如果有错误\r\n 来自约束，该约束来自源头，其位置\r\n 退回。否则，如果类型参数来自源，则\r\n 返回位置。如果两者都不来自源，则什么都不会返回。\r\n \r\n","\r\n             Produces tokens from the sequence of ":"\r\n             从序列中产生令牌\r\n","\r\n Represents an Inherits statement in a Class, Structure or Interface.\r\n ":"\r\n 代表类，结构或接口中的继承语句。\r\n \r\n","Convert to 'switch' expression":"转换为“开关”表达式\r\n","\r\n            Name of the symbol. Needed here for the Preview Changes dialog.\r\n            ":"\r\n            符号的名称。这里需要进行预览更改对话框。\r\n            \r\n","\r\n Is this type System.Linq.Expressions.Expression(Of T) for some delegate type T. If so, return the type\r\n argument, else return nothing.\r\n The passed-in compilation is used to find the well-known-type System.Linq.Expressions.Expression(Of T).\r\n ":"\r\n 是该类型System.linq.expressions.expressions（t）的某些委托类型T。如果是，请返回类型\r\n 论点，否则什么也没返回。\r\n 传递的汇编用于查找众所周知的型系统.linq.expressions.expression（t）。\r\n \r\n","\r\n            Returns true if the PDB contains a document record for given ":"\r\n            如果PDB包含给定的文档记录，则返回true\r\n","\r\n The value for the FormatClause property.\r\n ":"\r\n formatclause属性的值。\r\n \r\n","\r\n Check presence of [On Error]/[Resume] statements and report diagnostics based on presence of other\r\n \"incompatible\" statements.\r\n Report Async/Await diagnostics, which depends on surrounding context.\r\n ":"\r\n 检查[on错误]/[简历]语句的存在，并根据其他的存在报告诊断\r\n “不兼容”陈述。\r\n 报告异步/等待诊断，这取决于周围环境。\r\n \r\n","Use expression body for operators":"将表达式用于操作员\r\n","\r\n            Analyzes the assignment expression and rejects a given declaration if it is unsuitable for explicit typing.\r\n            ":"\r\n            分析分配表达式并拒绝给定声明，如果不适合明确键入。\r\n            \r\n"," is a variable declarator of a field with an initializer,\r\n            subset of the tokens of the field declaration depending on which variable declarator it is.\r\n            \r\n            Null reference otherwise.\r\n            ":" 是带有初始化器的字段的变量声明器，\r\n            字段声明的令牌子集取决于它是哪个变量声明器。\r\n            \r\n            否则为null引用。\r\n            \r\n","\r\n Lookup a type defined in referenced assembly.\r\n ":"\r\n 查找引用组件中定义的类型。\r\n \r\n"," and should show up after fixes but before\r\n            suppression fixes in the light bulb menu.\r\n            ":" 并应在修复后出现\r\n            在灯泡菜单中进行抑制修复。\r\n            \r\n","\r\n            CodeFixProvider factory. if an analyzer reference implements this, we call this to get CodeFixProviders\r\n            ":"\r\n            CodeFixProvider工厂。如果分析仪引用了这一点，我们称此为获取CodeFixProviders\r\n            \r\n","\r\n Accept a CR/LF pair or either in isolation as a newline.\r\n Make it a statement separator\r\n ":"\r\n 接受CR/LF对，或孤立地接受新线。\r\n 使其成为陈述分离器\r\n \r\n","\r\n Gets a list of all the diagnostics in the sub tree that has this node as its root.\r\n This method does not filter diagnostics based on compiler options like nowarn, warnaserror etc.\r\n ":"\r\n 获取具有该节点作为根部的子树中所有诊断的列表。\r\n 此方法不会根据nowarn，warnaserror等的编译器选项过滤诊断。\r\n \r\n","\r\n  Looks up a localized string similar to 'RemoveHandler' is already declared..\r\n":"\r\n  查找类似于“ RemoveHandler”的本地化字符串已被声明。\r\n\r\n","Add document '{0}'":"添加文档'{0}'\r\n","\r\n            If the position is on a control flow keyword (continue, break, yield, return , etc), returns the relevant position in the corresponding control flow statement.\r\n            Otherwise, returns null.\r\n            ":"\r\n            如果该位置在控制流关键字上（继续，中断，收益，返回等），则返回相应的控制流语句中的相关位置。\r\n            否则，返回null。\r\n            \r\n","Whether the source file already exists on disk and should be included. If\r\n            this is a false, a document is still created, but it's not backed by the file system and thus we won't\r\n            try to load it.":"源文件是否已经存在于磁盘上，应包括在内。如果\r\n            这是一个错误，仍然创建文档，但它不受文件系统的支持，因此我们不会\r\n            尝试加载它。\r\n","\r\n            Cached compile time solution corresponding to the ":"缓存的编译时间解决方案对应于\r\n"," group for build enforcement.\r\n            ":" 构建执法小组。\r\n            \r\n","\r\n             Null if there are any rude edit diagnostics.\r\n             \r\n             Otherwise, each active statement in ":"\r\n             null如果有任何粗鲁的编辑诊断。\r\n             \r\n             否则，每个活动语句\r\n","\r\n Binds a list of statements and puts in a scope.\r\n ":"\r\n 绑定语句列表并放入范围。\r\n \r\n"," and dispose them at the end of the debugging session.\r\n            ":" 并在调试会议结束时处置它们。\r\n            \r\n","\r\n A bound call to the GetEnumerator method.\r\n ":"\r\n 对GetEnumerator方法的界定调用。\r\n \r\n","\r\n This value will override m_SourceModule.MetadataName.\r\n ":"\r\n 该值将覆盖m_sourcemodule.metadataname。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' is not valid on a Delegate declaration..\r\n":"\r\n  查找类似于“ {0}”的本地化字符串在委托声明上无效。\r\n\r\n","\r\n            Perform language specific checks if the conversion is supported.\r\n            C#: Currently nothing blocking a conversion\r\n            VB: Nested foreach loops sharing a single Next statement, Next statements with multiple variables and next statements\r\n            not using the loop variable are not supported.\r\n            ":"\r\n            如果支持转换，请执行语言特定检查。\r\n            C＃：目前没有任何阻止转换\r\n            VB：嵌套foreach循环共享一个下一步语句，带有多个变量的下一个语句和下一个语句\r\n            不支持不使用循环变量。\r\n            \r\n","\r\n 'Me' parameter, relevant for methods, fields, properties, otherwise Nothing\r\n ":"\r\n “我”参数，与方法，字段，属性相关，否则什么都没有\r\n \r\n","\r\n If present, the \"As type-name\" clause describing the type of the parameter. If\r\n no As clause is present, Nothing is returned.\r\n ":"\r\n 如果存在，则描述参数类型的“ as type-name”子句。如果\r\n 没有作为条款，什么也不会返回。\r\n \r\n"," for the kind of synthesized variable.\r\n ":" 对于合成变量的种类。\r\n \r\n","at {0} : {1}":"在{0}：{1}\r\n"," code style option.\r\n            ":" 代码样式选项。\r\n            \r\n","\r\n Returns true if this is a read-only property; i.e., has no set accessor.\r\n ":"\r\n 如果这是只读的属性，则返回true；即，没有设置登录器。\r\n \r\n","\r\n Parse and return a TypeName.  Assumes the CurrentToken is on the name.\r\n ":"\r\n 解析并返回打字名称。假设CurrentToken在名称上。\r\n \r\n","\r\n  Looks up a localized string similar to Initializers on structure members are valid only for 'Shared' members and constants..\r\n":"\r\n  查找与结构成员上的初始化器类似的本地化字符串仅适用于“共享”成员和常数。\r\n\r\n","groupby clause":"Groupby子句\r\n","\r\n            True if the related completion item should be initially selected.\r\n            ":"\r\n            如果应该选择相关的完成项，则为正确。\r\n            \r\n","\r\n Get a SemanticModel object that is associated with an attribute that did not appear in\r\n this source code. This can be used to get detailed semantic information about sub-parts\r\n of an attribute that did not appear in source code. \r\n ":"\r\n 获取与未出现在\r\n 此源代码。这可以用来获取有关子部分的详细语义信息\r\n 未出现在源代码中的属性。\r\n \r\n","\r\n Retrieves Get method for this property or 'most derived' Get method from closest \r\n overridden property if such property exists.\r\n \r\n NOTE: It is not possible in VB, but possible in other languages (for example in C#) to\r\n       override read-write property an provide override only for setter, thus inheriting \r\n       getter's implementation. This method will find the Get method from the most-derived\r\n       overridden property in this case\r\n ":"\r\n 检索此属性的获取方法或从最近的“最派生”获取方法\r\n 如果存在此类财产，则覆盖财产。\r\n \r\n 注意：在VB中不可能，但其他语言（例如C＃中的其他语言）不可能\r\n       覆盖读取属性仅为setter提供替代，从而继承\r\n       Getter的实现。此方法将从最衍生的\r\n       在这种情况下覆盖财产\r\n \r\n","\r\n            Extractor function that retrieves all nodes that should be considered for extraction of given current node. \r\n            ":"\r\n            提取器函数检索应考虑提取给定电流节点的所有节点。\r\n            \r\n","Wrapping preferences":"包装首选项\r\n","\r\n            Determines whether performing the syntax replacement in one of the sibling nodes of the given lambda expressions will change the lambda binding semantics.\r\n            This is done by first determining the lambda parameters whose type differs in the replaced lambda node.\r\n            For each of these parameters, we find the descendant identifier name nodes in the lambda body and check if semantics of any of the parenting nodes of these\r\n            identifier nodes have changed in the replaced lambda.\r\n            ":"\r\n            确定在给定lambda表达式的一个同胞节点中执行语法替换是否会改变lambda结合语义。\r\n            这是通过首先确定lambda参数在替换的lambda节点中不同的lambda参数来完成的。\r\n            对于每个参数，我们在lambda主体中找到后代标识符名称节点，并检查这些育儿节点的语义是否\r\n            标识符节点在替换的lambda中发生了变化。\r\n            \r\n","The Current property.":"当前属性。\r\n","match zero or one time (lazy)":"匹配零或一次（懒惰）\r\n"," from a sequence of nodes and tokens.\r\n ":" 来自一系列节点和令牌。\r\n \r\n","\r\n The \"Let\" keyword.\r\n ":"\r\n “ LET”关键字。\r\n \r\n","\r\n            The current baseline for given project id.\r\n            The baseline is updated when changes are committed at the end of edit session.\r\n            The backing module readers of initial baselines need to be kept alive -- store them in\r\n            ":"\r\n            当前的给定项目ID的基线。\r\n            在编辑会话结束时进行更改时，将更新基线。\r\n            初始基线的背景模块读取器需要保持活力 - 将它们存储在\r\n            \r\n","Reference to undefined group name {0}":"引用未定义的组名称{0}\r\n","\r\n Returns true if this method is not implemented in IL of the assembly it is defined in.\r\n ":"\r\n 返回true如果在汇编的IL中未实现此方法，则返回。\r\n \r\n","\r\n  Looks up a localized string similar to '#ElseIf' cannot follow '#Else' as part of a '#If' block..\r\n":"\r\n  查找类似于“ #elseif”的本地化字符串，无法关注#else'作为“ #if”块的一部分。\r\n\r\n","\r\n The Option Strict checks generate warnings. (Note that other\r\n compile options may hide these warnings, or turn them into errors.)\r\n ":"\r\n 选项严格检查会生成警告。 （请注意其他\r\n 编译选项可能会隐藏这些警告，或者将它们变成错误。）\r\n \r\n","Exceptions:":"例外：\r\n"," id within the specified Document.\r\n            Similar to ":" 指定文档中的ID。\r\n            如同\r\n","Configure {0} code style":"配置{0}代码样式\r\n","sealed ToString in record":"记录的密封to\r\n","The \\G anchor specifies that a match must occur at the point where the previous match ended. When you use this anchor with the Regex.Matches or Match.NextMatch method, it ensures that all matches are contiguous.":"\\ g锚指定必须在上一场比赛结束的点上进行匹配。当您将此锚与Regex..matches.nextMatch方法一起使用时，它确保所有匹配都是连续的。\r\n","A string representing the standard Visual Basic script file extension.":"代表标准Visual Basic脚本文件扩展名的字符串。\r\n","\r\n The value for the ThenKeyword property.\r\n ":"\r\n thekeyword属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to XML namespace prefix '{0}' is already declared..\r\n":"\r\n  查找类似于XML名称空间前缀'{0}'的本地化字符串。\r\n\r\n","\r\n Bind query expression that starts with Aggregate keyword, as opposed to the one that starts with From.\r\n \r\n     Aggregate {collection range variables} [{other operators}] Into {aggregation range variables}\r\n \r\n If Into clause has one item, a single value is produced. If it has multiple items, values are\r\n combined into an instance of an Anonymous Type.\r\n ":"\r\n 绑定的查询表达式以汇总关键字开头，而不是从汇总表达式开始。\r\n \r\n     聚集{集合范围变量} [{other Operator}]中{聚合范围变量}\r\n \r\n 如果“进入子句”有一个项目，则会产生一个值。如果它有多个项目，则值为\r\n 合并成匿名类型的实例。\r\n \r\n","<lambda expression>":"<lambda表达式>\r\n","\r\n  Looks up a localized string similar to Specifier is duplicated..\r\n":"\r\n  查找类似于指定符的本地化字符串已重复。\r\n\r\n","\r\n The value for the ElseIfKeyword property.\r\n ":"\r\n ElseifKeyword属性的值。\r\n \r\n","\r\n Return the containing module if the output kind is module and the containing assembly otherwise.\r\n ":"\r\n 如果输出类型为模块，则返回包含的模块，否则包含装配体。\r\n \r\n","The name of this method.":"此方法的名称。\r\n","\r\n Returns a copy of this with the OrderKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，订购键属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n The \"By\" keyword.\r\n ":"\r\n “ by”关键字。\r\n \r\n","\r\n The Select Case statement that begins the block.\r\n ":"\r\n 开始块的选择案例语句。\r\n \r\n"," to queryable\r\n collection.\r\n ":" 可查询\r\n 收藏。\r\n \r\n","\r\n            We don't use PE cache from the service, so just pass in type `object` for PE entries.\r\n            ":"\r\n            我们不使用服务中的PE CACHE，因此只需输入PE条目的“对象”类型。\r\n            \r\n","\r\n The value for the EndQuoteToken property.\r\n ":"\r\n EndQuoteToken属性的价值。\r\n \r\n","\r\n One of the special type parameter constraints: New, Class or Structure. Which\r\n kind of special constraint it is can be obtained from the Kind property and is\r\n one of: NewConstraint, ReferenceConstraint or ValueConstraint.\r\n ":"\r\n 特殊类型的参数约束之一：新，类或结构。哪个\r\n 一种特殊的约束，可以从该物业中获得，并且是\r\n 之一：newconstraint，referenceConstraint或valueconstraint。\r\n \r\n","\r\n The conversion from the type of the ":"\r\n 从类型的转换\r\n","\r\n Represents an alias identifier followed by an \"=\" token in an Imports clause.\r\n ":"\r\n 代表一个别名标识符，后面是导入子句中的“ =”令牌。\r\n \r\n","\r\n Represents literal character data in interpolated string expression.\r\n ":"\r\n 表示插值字符串表达式中的字面字符数据。\r\n \r\n","Invert if":"if\r\n","\r\n Represents a primary module of a ":"\r\n 代表一个主要模块\r\n","\r\n Handle a case of being able to refer to System.Int32 through System.Integer.\r\n Same for other intrinsic types with intrinsic name different from emitted name.\r\n ":"\r\n 处理能够引用system.int32的案例。通过system.integer。\r\n 对于其他固有类型的固有名称与发射名称不同的类型相同。\r\n \r\n","\r\n            No action needs to be performed.\r\n            ":"\r\n            不需要采取行动。\r\n            \r\n","Enums":"枚举\r\n"," Checks for validity of type arguments passed to Construct(...) method ":" 检查传递给构造方法的类型参数的有效性（...）方法\r\n","Too many )'s":"太多）\r\n","\r\n Alpha-renamed type parameters, i.e. type parameters with constraints substituted according\r\n to containing type's TypeSubstitution.\r\n For example:\r\n     Class A (Of T)\r\n         Class B(Of S As T)\r\n             Dim x As A(Of Integer).B(Of S) 'error BC32044: Type argument 'S' does not inherit from or implement the constraint type 'Integer'.\r\n         End Class\r\n     End Class\r\n  \r\n Given a type A(Of IComparable).B(Of ), alpha-renamed type parameter S will have type constraint IComparable.\r\n ":"\r\n alpha命名的类型参数，即用约束替换的类型参数\r\n 包含类型的类型物质。\r\n 例如：\r\n     A类（T）\r\n         B级（S为T）\r\n             dim x作为（integer）.b（s）'错误bc32044：类型参数's'不会继承或实现约束类型'integer'。\r\n         最终课程\r\n     最终课程\r\n  \r\n 给定一个类型A（iComable）.b（OF），alpha命名的类型参数S将具有型号的键入。\r\n \r\n",".  In order to convert to the\r\n             indexer, the type being called on needs a slice-like method that takes two ints, and returns\r\n             an instance of the same type. It also needs a ":"。为了转换为\r\n             索引器，被调用的类型需要一种类似切片的方法，该方法需要两个int，然后返回\r\n             同一类型的实例。它也需要一个\r\n","\r\n Lookup a member name in a namespace or type, returning a LookupResult that\r\n summarizes the results of the lookup. See LookupResult structure for a detailed\r\n discussing of the meaning of the results. The supplied binder is used for accessibility\r\n checked and base class suppression.\r\n ":"\r\n 查找命名空间或类型中的成员名称，返回查找\r\n 总结查找的结果。有关详细信息，请参见查找结构\r\n 讨论结果的含义。提供的粘合剂用于可访问性\r\n 检查和基类抑制。\r\n \r\n","The $ anchor specifies that the preceding pattern must occur at the end of the input string, or before \\n at the end of the input string. If you use $ with the RegexOptions.Multiline option, the match can also occur at the end of a line.\r\n            \r\n            The $ anchor matc ...":"$锚指定前面的模式必须发生在输入字符串的末尾，或者在输入字符串末尾\\ n之前。如果您在Regexoptions.multiline选项中使用$，则该匹配也可以在行末尾发生。\r\n            \r\n            $锚矩阵...\r\n","\r\n One needs to call ":"\r\n 一个人需要打电话\r\n","\r\n The parsed representation of a Visual Basic source document.\r\n ":"\r\n 视觉基本源文档的解析表示。\r\n \r\n","\r\n Determines whether the given type is valid for a const field.\r\n VB Spec 9.5: The type of a constant may only be a primitive type or Object\r\n ":"\r\n 确定给定类型是否对const字段有效。\r\n VB规格9.5：常数的类型只能是原始类型或对象\r\n \r\n","\r\n            Test purpose only\r\n            ":"\r\n            仅测试目的\r\n            \r\n","\r\n            Gets the completions available at the caret position, with additional info indicates \r\n            whether expander items are available.\r\n            ":"\r\n            在Caret位置获得可用的完成，并提供其他信息。\r\n            是否有扩展物品可用。\r\n            \r\n","True if it is a binary operator":"如果是二进制操作员\r\n","\r\n All user-defined and long-lived synthesized variables must return a reference to a node that is \r\n tracked by the EnC diffing algorithm. For example, for ":"\r\n 所有用户定义和长期综合变量的所有用户定义的变量都必须返回对一个节点的引用\r\n 由ENC扩散算法跟踪。例如，对于\r\n","\r\n            applicableToSpan should represent a logical section within the original document that the action is \r\n            applicable to. It doesn't have to precisely represent the exact ":"\r\n            ApplipableTospan应代表原始文档中的逻辑部分，该操作是\r\n            适用于。它不必精确代表确切的\r\n","\r\n  Looks up a localized string similar to 'Enum' must end with a matching 'End Enum'..\r\n":"\r\n  查找类似于“枚举”的本地化字符串必须以匹配的“末端枚举”结尾。\r\n\r\n","\r\n A method that wraps the call to a method through MyBase/MyClass receiver.\r\n ":"\r\n 通过mybase/myclass接收器将调用调用的方法。\r\n \r\n","\r\n Evaluates expr and calls HasValue on it.\r\n ":"\r\n 计算expr并对其调用HasValue。\r\n \r\n","\r\n If present, a type parameter list with generic type parameters for this\r\n delegate. If no generic type parameters were present, Nothing is returned.\r\n ":"\r\n 如果存在，则具有通用类型参数的类型参数列表为此\r\n 代表。如果没有通用类型参数，则不会返回。\r\n \r\n","\r\n Binds the expression in the context of the specified location and gets type information.\r\n This method is used to get type information about an expression that did not actually\r\n appear in the source code.\r\n ":"\r\n 在指定位置的上下文中绑定表达式并获取类型信息。\r\n 此方法用于获取有关表达式的类型信息\r\n 出现在源代码中。\r\n \r\n","\r\n  Looks up a localized string similar to 'Sub Main' is declared more than once in '{0}': {1}.\r\n":"\r\n  在“ {0}'：{1}中，查找类似于“ Sub Main”的本地化字符串被多次声明。\r\n\r\n","\r\n  Looks up a localized string similar to '{0}' is ambiguous across the inherited interfaces '{1}' and '{2}'..\r\n":"\r\n  在继承的接口'{1}'和'{2}'..上查找类似于“ {0}”类似的本地化字符串。\r\n\r\n","\r\n            The source code of the script.\r\n            ":"\r\n            脚本的源代码。\r\n            \r\n","\r\n Returns a copy of this with the PreserveKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，并将其preserveKeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Calling convention of the signature.\r\n ":"\r\n 召集签名惯例。\r\n \r\n","\r\n Check all generic constraints on the given type and any containing types\r\n (such as A(Of T) in A(Of T).B(Of U)). This includes checking constraints\r\n on generic types within the type (such as B(Of T) in A(Of B(Of T)())).\r\n ":"\r\n 检查给定类型和任何包含类型的所有通用约束\r\n （例如（t）.b（u）的A（t）中的A（t）。这包括检查约束\r\n 在类型中的通用类型上（例如b（of t）（t）（））中的b（t））。\r\n \r\n","\r\n  Looks up a localized string similar to Attribute constructor has a 'ByRef' parameter of type '{0}'; cannot use constructors with byref parameters to apply the attribute..\r\n":"\r\n  查找类似于属性构造函数的本地化字符串具有'{0}'type'byref'参数;无法将构造函数与BYREF参数一起应用属性。\r\n\r\n","\r\n  Looks up a localized string similar to 'Next' statement names more variables than there are matching 'For' statements..\r\n":"\r\n  查找类似于“ Next”语句的本地化字符串名称的变量要比与“匹配”更大的变量。\r\n\r\n","\r\n            Cache so that we can reuse the same ":"\r\n            缓存，以便我们可以重复使用相同的\r\n","\r\n An error type symbol with name and diagnostic. More info can be added in the future.\r\n ":"\r\n 带有名称和诊断的错误类型符号。将来可以添加更多信息。\r\n \r\n","The syntax node that declares a type block.":"声明一个类型块的语法节点。\r\n","\r\n  Looks up a localized string similar to 'As' expected..\r\n":"\r\n  查找类似于“预期”的局部字符串。\r\n\r\n","\r\n Returns a copy of this with the Token2 property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，Token2属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n A reference to \r\n ":"\r\n 引用\r\n \r\n","\r\n Returns what kind of extent: Module, Assembly, or Compilation.\r\n ":"\r\n 返回多大程度：模块，组装或编译。\r\n \r\n","\r\n Specifies if the analysis should process compiler generated locals. \r\n \r\n Note that data flow API should never report compiler generated variables \r\n as well as those should not generate any diagnostics (like being unassigned, etc...).\r\n \r\n But when the analysis is used for iterators or async captures it should process \r\n compiler generated locals as well...\r\n ":"\r\n 指定分析是否应处理编译器生成的当地人。\r\n \r\n 请注意，数据流API绝不应报告编译器生成的变量\r\n 以及这些不应产生任何诊断（例如未分配等等）。\r\n \r\n 但是，当分析用于迭代器或异步捕获时，应处理\r\n 编译器也生成了当地人...\r\n \r\n","\r\n A MetadataDocumentationProvider providing XML documentation for this assembly.\r\n ":"\r\n 元数据库库提供了此组件的XML文档。\r\n \r\n","\r\n The possible reasons a symbol may be inaccessible\r\n ":"\r\n 符号可能无法访问的可能原因\r\n \r\n","\r\n            Checks if there are indications that there might be more than one declarations that need to be fixed.\r\n            The check does not look-up if there are other declarations (this is done later in the CodeAction).\r\n            ":"\r\n            检查是否有迹象表明可能需要修复多个声明。\r\n            检查是否还有其他声明（以后在编码中进行）。\r\n            \r\n"," representing the specific kind of LambdaHeaderSyntax.\r\n One of SubLambdaHeader, FunctionLambdaHeader.\r\n ":" 代表特定的lambdaheadersyntax。\r\n Sublambdaheader之一，功能lambdaheader。\r\n \r\n","\r\n Given a type block, get the corresponding type symbol.\r\n ":"\r\n 给定一个类型块，获取相应的类型符号。\r\n \r\n","s.Slice(start..end)":"S.Slice（start..end）\r\n","\r\n Bind CollectionRangeVariableSyntax, applying AsQueryable/AsEnumerable/Cast(Of Object) calls and \r\n Select with implicit type conversion as appropriate.\r\n ":"\r\n bind collectionRangeVariablesyntax，应用Asqueryable/AseNumerable/cast（对象）调用和\r\n 与隐式类型转换一起选择。\r\n \r\n","\r\n Contains the main method of this assembly, if there is one.\r\n ":"\r\n 如果有一个，则包含此组件的主要方法。\r\n \r\n","Interface member '{0}' does not have a most specific implementation. Neither '{1}', nor '{2}' are most specific.":"接口成员'{0}'没有最具体的实现。 '{1}'，也不是'{2}'最具体的。\r\n","\r\n            update the original document and remove the type that was moved.\r\n            perform other fix ups as necessary.\r\n            ":"\r\n            更新原始文档并删除已移动的类型。\r\n            必要时执行其他修复程序。\r\n            \r\n","\r\n Bind Join/Let like and mixed selector in context of this binder.\r\n \r\n Join like selector: Function(a, b) New With {a, b}\r\n \r\n Let like selector: Function(a) New With {a, letExpressionRangeVariable}\r\n \r\n Mixed selector: Function(a, b) New With {a, b, letExpressionRangeVariable}\r\n ":"\r\n 在此粘合剂的上下文中，绑定加入/让喜欢和混合选择器。\r\n \r\n 像选择器一样加入：函数（a，b）新的，{a，b}\r\n \r\n 让Like Selector：函数（a）with {a，letexpressionrangevariable} new}\r\n \r\n 混合选择器：函数（a，b）新的，{a，b，letexpressionrangevariable}\r\n \r\n","\r\n Find enclosing WithStatement if it exists.\r\n ":"\r\n 如果存在，请找到封闭的效力。\r\n \r\n","\r\n For each lambda in the code, the set of variables that it captures.\r\n ":"\r\n 对于代码中的每个lambda，它捕获的变量集。\r\n \r\n","\r\n Returns a copy of this with the EachKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，每个键属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n A Compilation the assembly is created for.\r\n ":"\r\n 为组件创建的汇编。\r\n \r\n","\r\n The value for the Parameters property.\r\n ":"\r\n 参数属性的值。\r\n \r\n","\r\n Provides context for binding body of a Lambda.\r\n ":"\r\n 提供了lambda结合体的背景。\r\n \r\n","A syntax node that represents a parsed initializer. This initializer should not be\r\n present in the syntax tree associated with this object.":"代表解析初始化器的语法节点。此初始化器不应是\r\n 存在与此对象关联的语法树中。\r\n"," if this instance has declared type; otherwise, ":" 如果此实例已声明类型；否则，\r\n","\r\n Construct an object for region-aware analysis\r\n ":"\r\n 构建一个以区域感知分析的对象\r\n \r\n","\r\n Classifies the address of conversion. \r\n ":"\r\n 分类转换的地址。\r\n \r\n","\r\n  Looks up a localized string similar to Generic type '{0}' cannot be imported more than once..\r\n":"\r\n  查找类似于通用类型'{0}'的本地化字符串，不能多次导入。\r\n\r\n","Source file can not contain both file-scoped and normal namespace declarations.":"源文件不能同时包含文件划分和正常名称空间声明。\r\n","\r\n Get all constraints, with optional source location for each. This method\r\n is provided for constraint checking only, and should only be invoked\r\n for SourceTypeParameterSymbol or ErrorTypeParameterSymbol directly.\r\n There is currently no need to invoke this method for PETypeParameterSymbol.\r\n ":"\r\n 获取所有约束，每个约束都有可选的源位置。这个方法\r\n 提供仅用于约束检查，仅应调用\r\n 直接用于Soupcetyparametersymbol或errortyparametersymbol。\r\n 目前无需为petyparametersymbol调用这种方法。\r\n \r\n","Change namespace to match folder structure":"更改名称空间以匹配文件夹结构\r\n","The copyright string, as parsed from the header.":"从标题解析的版权字符串。\r\n","ObjectCollectionInitializer":"ObjectCollectionInitializer\r\n","After the From keyword in a collection initializer.":"在集合初始化器中的关键字之后。\r\n"," with string argument.\r\n ":" 使用字符串参数。\r\n \r\n","Actions can not be empty.":"动作不能为空。\r\n","100ths of a second":"100秒\r\n","Method '{0}' specifies a 'struct' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a non-nullable value type.":"方法'{0}'指定类型参数'{1}'的'struct'约束，但是相应的类型参数'{2}'被覆盖或显式实现的方法'{3}'不是不可公开的值类型。\r\n","10,000,000ths of a second (non-zero)":"10,000,000秒（非零）\r\n","\r\n The conditional compilation string. This takes the form of a comma delimited list\r\n of NAME=Value pairs, where Value may be a quoted string or integer.\r\n ":"\r\n 条件汇编字符串。这采用逗号分隔列表的形式\r\n 名称=值对，其中值可能是引用的字符串或整数。\r\n \r\n","\r\n Returns a copy of this with the Constraints property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中约束属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Introduce field for '{0}'":"介绍“ {0}'的字段\r\n","\r\n The \"{\" token.\r\n ":"\r\n “ {”令牌。\r\n \r\n","The original parent of the node rewritten by ":"节点的原始父母由\r\n","\r\n A LookupResult summarizes the result of a name lookup, and allows combining name lookups\r\n from different scopes in an easy way.\r\n \r\n A LookupResult can be ONE OF:\r\n    empty - nothing found.\r\n    a non-accessible result - this kind of result means that search continues into further scopes of lower priority for\r\n                      a viable result. An error is attached with the inaccessibility errors. Non-accessible results take priority over\r\n                      non-viable results.\r\n    a non-viable result - a result that means that the search continues into further scopes of lower priority for\r\n                          a viable or non-accessible result. An error is attached with the error that indicates\r\n                          why the result is non-viable.\r\n    a bad symbol that stops further lookup -  this kind of result prevents lookup into further scopes of lower priority.\r\n                      a diagnostic is attached explaining why the symbol is bad.\r\n    ambiguous symbols.- In this case, an AmbiguousSymbolDiagnostic diagnostic has the other symbols. \r\n    a good symbol, or set of good overloaded symbols - no diagnostic is attached in this case\r\n \r\n Occasionally, good or ambiguous results are referred to as \"viable\" results.\r\n \r\n Multiple symbols can be represented in a single LookupResult. Multiple symbols are ONLY USED for overloadable\r\n entities, such an methods or properties, and represent all the symbols that overload resolution needs to consider.\r\n When ambiguous symbols are encountered, a single representative symbols is returned, with an attached AmbiguousSymbolDiagnostic\r\n from which all the ambiguous symbols can be retrieved. This implies that Lookup operations that are restricted to namespaces\r\n and/or types always create a LookupResult with 0 or 1 symbol.\r\n \r\n Note that the class is poolable so its instances can be obtained from a pool via GetInstance.\r\n Also it is a good idea to call Free on instances after they no longer needed.\r\n \r\n The typical pattern is \"caller allocates / caller frees\" -\r\n    \r\n    Dim result = LookupResult.GetInstance()\r\n  \r\n    scope.Lookup(result, \"foo\")\r\n    ... use result ...\r\n         \r\n    result.Clear()\r\n    anotherScope.Lookup(result, \"moo\")\r\n    ... use result ...\r\n \r\n    result.Free()   'result and its content is invalid after this\r\n ":"\r\n 查找总结了名称查找的结果，并允许组合名称查找\r\n 以一种简单的方式来自不同的范围。\r\n \r\n 查找可以是：\r\n    空 - 找不到。\r\n    一个不可访问的结果 - 这种结果意味着搜索将继续进入较低优先级的进一步范围\r\n                      可行的结果。错误的错误错误附加了错误。不可访问的结果优先\r\n                      不可行的结果。\r\n    一个不可行的结果 - 结果意味着搜索将继续进入较低优先级的进一步范围\r\n                          可行或不可访问的结果。带有指示的错误附加了错误\r\n                          为什么结果是不可行的。\r\n    一个不良符号会停止进一步查找 - 这种结果可防止查找较低优先级的进一步范围。\r\n                      附有诊断，解释了为什么符号不好。\r\n    模棱两可的符号。-在这种情况下，模棱两可的诊断诊断具有其他符号。\r\n    一个好的符号或一组良好的超载符号 - 在这种情况下没有附加诊断\r\n \r\n 有时，良好或模棱两可的结果被称为“可行”结果。\r\n \r\n 可以在单个查找中表示多个符号。多个符号仅用于超载\r\n 实体，这样的方法或属性，并表示过载分辨率需要考虑的所有符号。\r\n 当遇到模棱两可的符号时，将返回一个代表性符号，并带有模棱两可的诊断\r\n 可以从中检索所有模棱两可的符号。这意味着仅限于名称空间的查找操作\r\n 和/或类型始终创建具有0或1个符号的LookupResult。\r\n \r\n 请注意，该类是可池的，因此可以通过getInstance从池中获得其实例。\r\n 同样，最好在不再需要的情况下在实例上免费致电。\r\n \r\n 典型的模式是“呼叫者分配 /呼叫者释放”  - \r\n    \r\n    dim结果= LookupResult.getInstance（）\r\n  \r\n    scope.lookup（结果，“ foo”）\r\n    ...使用结果...\r\n         \r\n    result.clear（）\r\n    anotherscope.lookup（结果，“ moo”）\r\n    ...使用结果...\r\n \r\n    result.free（）'结果及其内容之后无效\r\n \r\n"," with a property added to the ":" 将属性添加到\r\n"," is provided, the name \r\n            in the new node might be qualified with this new namespace instead.\r\n            ":" 提供，名称\r\n            在新节点中，可以使用此新名称空间资格。\r\n            \r\n","\r\n Returns a copy of this with the GlobalKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中globalkeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Represents an XML attribute in an XML literal expression.\r\n ":"\r\n 代表XML文字表达式中的XML属性。\r\n \r\n","A single-element deconstruct pattern requires some other syntax for disambiguation. It is recommended to add a discard designator '_' after the close paren ')'.":"单元素解构模式需要一些其他语法才能消除歧义。建议在关闭Paren之后添加丢弃的指定器“ _”）。\r\n","\r\n  Looks up a localized string similar to 'RaiseEvent' declaration must end with a matching 'End RaiseEvent'..\r\n":"\r\n  查找类似于“ raiseevent”声明的本地化字符串必须以匹配的“ end raiseevent”结尾。\r\n\r\n","Remove Unnecessary Usings":"删除不必要的使用\r\n","\r\n Returns a copy of this with the AccessorKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 将其返回此副本，其中登录键属性将其更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Returns a copy of this with the EndEnumStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中具有EndenumStatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Gets the root node of the syntax tree asynchronously.\r\n ":"\r\n 异步获取语法树的根节点。\r\n \r\n","\r\n            The set of completions to present to the user.\r\n            ":"\r\n            向用户展示的完整组合。\r\n            \r\n","\r\n  Looks up a localized string similar to '{0}' cannot be used as a type constraint..\r\n":"\r\n  查找类似于'{0}'的局部字符串不能用作类型约束。\r\n\r\n","\r\n The SourceAssemblySymbol for this compilation. Do not access directly, use Assembly\r\n property instead. This field is lazily initialized by ReferenceManager,\r\n ReferenceManager.CacheLockObject must be locked while ReferenceManager \"calculates\" the\r\n value and assigns it, several threads must not perform duplicate \"calculation\"\r\n simultaneously.\r\n ":"\r\n 该汇编的源切除术。请勿直接访问，使用组件\r\n 属性。该字段是由ReferenceManager懒惰的，\r\n referencemanager.cachelockobject必须锁定，而引用memanager“计算”\r\n 值并分配它，几个线程不得执行重复的“计算”\r\n 同时。\r\n \r\n","carriage-return character":"马车回归人物\r\n","\r\n Creates the syntax representation of a para element within xml documentation comments.\r\n ":"\r\n 在XML文档注释中创建PARA元素的语法表示。\r\n \r\n","\r\n Interface1 and Interface2 conflict for some type arguments. Report the correct error in the correct location.\r\n ":"interface1和interface2冲突某些类型参数。在正确的位置报告正确的错误。\r\n \r\n","Naming Styles":"命名风格\r\n","Autoselect disabled due to namespace declaration.":"由于名称空间声明，自动选择禁用。\r\n","\r\n A map of members immediately contained within this type \r\n grouped by their name (case-insensitively).\r\n ":"\r\n 此类型中立即包含的成员地图\r\n 按其名称分组（casemonsitationally）。\r\n \r\n","\r\n This should probably be an extra constructor parameter, but we don't need more constructor overloads.\r\n ":"\r\n 这可能应该是一个额外的构造函数参数，但是我们不需要更多的构造函数过载。\r\n \r\n","\r\n Gets type information about an expression syntax node. This is the worker\r\n function that is overridden in various derived kinds of Semantic Models. It can assume that \r\n CheckSyntaxNode has already been called.\r\n ":"\r\n 获取有关表达语法节点的类型信息。这是工人\r\n 在各种派生的语义模型中被覆盖的函数。它可以假设\r\n checksyntaxnode已被调用。\r\n \r\n","\r\n If this symbol represents a metadata module returns the underlying ":"\r\n 如果此符号代表元数据模块返回基础\r\n","+ additional {0} error":"+附加{0}错误\r\n","\r\n Represents a type or module declared in source. \r\n Could be a class, structure, interface, delegate, enum, or module.\r\n ":"\r\n 表示源中声明的类型或模块。\r\n 可以是类，结构，接口，委托，枚举或模块。\r\n \r\n","\r\n Gets the root of the syntax tree statically typed as ":"\r\n 获取语​​法树的根部静态键入为\r\n","\r\n Get the Location associated with a given TextSpan.\r\n ":"\r\n 获取与给定的文本范围关联的位置。\r\n \r\n"," for await using declarators.\r\n            ":" 要等待使用声明器。\r\n            \r\n","\r\n Given a possibly constructed/specialized generic type, create a symbol\r\n to represent an unbound generic type for its definition.\r\n ":"\r\n 给定可能构造/专业的通用类型，创建一个符号\r\n 代表其定义的无限通用类型。\r\n \r\n","local function":"本地功能\r\n","\r\n This function classifies all intrinsic language conversions and user-defined conversions.\r\n ":"\r\n 此函数将分类所有内在的语言转换和用户定义的转换。\r\n \r\n","\r\n            An optional set of additional locations indicating unnecessary code related to the diagnostic.\r\n            These locations are joined with ":"\r\n            一组可选的其他位置，指示与诊断相关的不必要代码。\r\n            这些位置与\r\n","\r\n            If the span exists it is possible to place a breakpoint at the given position.\r\n            ":"\r\n            如果跨度存在，则可以在给定位置放置断点。\r\n            \r\n","\r\n            Message for the diagnostic descriptor.\r\n            ":"\r\n            诊断描述符的消息。\r\n            \r\n"," is added whenever EnC analyzer reports \r\n            rude edits or module diagnostics. At the end of the session we ask the diagnostic analyzer to reanalyze \r\n            the documents to clean up the diagnostics.\r\n            ":" 每当ENC分析仪报告时添加\r\n            粗鲁的编辑或模块诊断。在会议结束时，我们要求诊断分析仪重新分析\r\n            清理诊断的文档。\r\n            \r\n","This method safely returns a local symbol's type by checking for circular references or references before declaration.":"此方法通过在声明之前检查循环引用或参考，可以安全地返回本地符号的类型。\r\n","\r\n stack at variable declaration, may be > 0 in sequences.\r\n ":"\r\n 在变量声明处的堆栈可能为序列> 0。\r\n \r\n","100,000ths of a second (non-zero)":"100,000秒（非零）\r\n","\r\n Returns a copy of this with the Statements property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此的副本，语句属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Implement interface with Dispose pattern":"用处置模式实现接口\r\n"," is not null.\r\n            ":" 不是零。\r\n            \r\n","\r\n Handles ":"\r\n 手柄\r\n","The selection contains syntactic errors":"选择包含句法错误\r\n"," type.  Needed so that we only fixup code if we see the type\r\n            we're using has an indexer that takes an ":" 类型。需要，以便我们仅在看到类型时修复代码\r\n            我们使用的是一个索引器\r\n"," if 'Select All' was chosen.  ":" 如果选择了“选择”。\r\n","\r\n            Try to change the namespace declaration in the document (specified by ":"\r\n            尝试更改文档中的名称空间声明（由\r\n","\r\n            internal interface used to use language specific service from common service layer\r\n            ":"\r\n            内部界面用于使用公共服务层的语言特定服务\r\n            \r\n","\r\n Returns true if the type is a submission class. \r\n ":"\r\n 如果类型是提交类，则返回true。\r\n \r\n","\r\n  Looks up a localized string similar to 'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to interface methods..\r\n":"\r\n  查找类似于'system.runtime.interopservices.dllimportattribute'的本地化字符串，不能应用于接口方法。\r\n\r\n","\r\n Creates a trivia with kind EndOfLineTrivia containing the specified text. \r\n ":"\r\n 用包含指定文本的善良内传式创建一个琐事。\r\n \r\n","\r\n A region analysis walker that records declared variables.\r\n ":"\r\n 记录变量的区域分析步行者。\r\n \r\n","True to get implemented getters, False to get implemented setters":"真实地实现getters，false获得实现的设置器\r\n"," Automatically embedded symbols (types, methods and fields) used in the current compilation ":" 当前汇编中使用的自动嵌入符号（类型，方法和字段）\r\n","\r\n This class implements the region control flow analysis operations.  Region control flow analysis provides\r\n information about statements which enter and leave a region. The analysis done lazily. When created, it performs\r\n no analysis, but simply caches the arguments. Then, the first time one of the analysis results is used it\r\n computes that one result and caches it. Each result is computed using a custom algorithm.\r\n ":"\r\n 该类实现区域控制流分析操作。区域控制流分析提供\r\n 有关输入和离开区域的陈述的信息。分析懒洋洋地进行了。创建时，它会执行\r\n 没有分析，而只是缓存了论点。然后，第一次使用分析结果\r\n 计算一个结果并缓存。使用自定义算法计算每个结果。\r\n \r\n","Add [Obsolete]":"添加[过时]\r\n","\r\n A trivia with kind EndOfLineTrivia containing a single carriage return character.\r\n ":"\r\n 带有单个马车返回特征的善良内翼曲线的琐事。\r\n \r\n","\r\n            when users type, we chain all those changes as incremental parsing requests \r\n            but doesn't actually realize those changes. it is saved as a pending request. \r\n            so if nobody asks for final parse tree, those chain can keep grow. \r\n            we do this since Roslyn is lazy at the core (don't do work if nobody asks for it)\r\n            \r\n            but certain host such as VS, we have this (BackgroundParser) which preemptively \r\n            trying to realize such trees for open/active files expecting users will use them soonish.\r\n            ":"\r\n            当用户键入时，我们将所有这些更改链接为增量解析请求\r\n            但实际上并没有意识到这些变化。它被保存为待处理的请求。\r\n            因此，如果没有人要求最终的解析树，那些链条可以保持生长。\r\n            我们这样做是因为罗斯林在核心方面很懒惰（如果没人要求，请不要工作）\r\n            \r\n            但是某些主机（例如Vs），我们有这个（背景parlserser）\r\n            试图实现此类树的开放/活动文件，期望用户很快使用它们。\r\n            \r\n","\r\n Determines if the type is a valid type for a custom attribute argument\r\n ":"\r\n 确定该类型是否是自定义属性参数的有效类型\r\n \r\n","The syntax node that declares one or more fields.":"声明一个或多个字段的语法节点。\r\n","\r\n Collect extension methods with the given name that are in scope in this binder.\r\n The passed in ArrayBuilder must be empty. Extension methods from the same containing type\r\n must be grouped together.\r\n ":"\r\n 收集具有此粘合剂范围中给定名称的扩展方法。\r\n 阵列构造器中传递的人必须为空。来自同一包含类型的扩展方法\r\n 必须分组在一起。\r\n \r\n","Replace '{0}' with method":"用方法替换'{0}'\r\n"," for metadata reference directive, ":" 对于元数据参考指令，\r\n","\r\n            Starts the watcher.\r\n            ":"\r\n            开始观察者。\r\n            \r\n","\r\n Implements shadowing based on\r\n §11.8.1 Overloaded Method Resolution.\r\n 7.8.\tIf one or more arguments are AddressOf or lambda expressions, and all of the corresponding \r\n         delegate types in M match exactly, but not all do in N, eliminate N from the set.\r\n 7.9.\tIf one or more arguments are AddressOf or lambda expressions, and all of the corresponding \r\n         delegate types in M are widening conversions, but not all are in N, eliminate N from the set.\r\n ":"\r\n 基于\r\n §11.8.1超载方法分辨率。\r\n 7.8。如果一个或多个参数是地址或lambda表达式，以及所有相应的\r\n         M中的委托类型完全匹配，但并非全部匹配N，从集合中消除N。\r\n 7.9。如果一个或多个参数是地址或lambda表达式，以及所有相应的\r\n         M中的委托类型正在扩大转化率，但并非全部在n中，从集合中消除了n。\r\n \r\n","\r\n The value for the ConstKeyword property.\r\n ":"\r\n Constkeyword属性的值。\r\n \r\n","\r\n The value for the StructureKeyword property.\r\n ":"\r\n 结构关键属性的值。\r\n \r\n","The anonymous object creation field initializer syntax.":"匿名对象创建字段初始化器语法。\r\n","\r\n Returns true if this parameter was declared as a ParamArray. \r\n ":"\r\n 如果此参数被声明为paramarray，则返回true。\r\n \r\n","\r\n The \"ElseIf ... Then\" statement the begins the \"ElseIf\" block.\r\n ":"\r\n “ Elseif ...然后”语句开始开始“ Elsif”块。\r\n \r\n","\r\n The \"Option\" keyword.\r\n ":"\r\n “选项”关键字。\r\n \r\n","\r\n Optimize the case where we create an instance of a delegate and invoke it right away.\r\n Skip the delegate creation and invoke the method directly. Specifically, we are targeting \r\n lambda relaxation scenario that requires a stub, which invokes original lambda by instantiating\r\n an Anonymous Delegate and calling its Invoke method. That is why this optimization should be done\r\n after lambdas are rewritten.\r\n CONSIDER: Should we expand this optimization to all delegate types and all explicitly written code?\r\n           If we decide to do this, we should be careful with extension methods because they have\r\n           special treatment of 'this' parameter. \r\n ":"\r\n 优化我们创建代表实例并立即调用的情况。\r\n 跳过代表创建并直接调用该方法。具体来说，我们是针对的\r\n Lambda放松方案需要一个存根，该存根通过实例化调用原始lambda\r\n 匿名代表并调用其调用方法。这就是为什么应该进行此优化的原因\r\n 在重写Lambdas之后。\r\n 考虑：我们应该将此优化扩展到所有委托类型和所有明确书面代码吗？\r\n           如果我们决定这样做，我们应该谨慎使用扩展方法，因为它们有\r\n           “此”参数的特殊处理。\r\n \r\n"," has to account for such cases.\r\n            ":" 必须考虑此类案件。\r\n            \r\n","The field, property or parameter symbol with an initializer or default value.":"带有初始器或默认值的字段，属性或参数符号。\r\n","\r\n Get all the members of this symbol.\r\n ":"\r\n 获取此符号的所有成员。\r\n \r\n","Generate operators":"生成操作员\r\n"," code style options for the given language.\r\n            ":" 给定语言的代码样式选项。\r\n            \r\n","Compiler":"编译器\r\n","\r\n            True to prefetch all metadata from the assembly and close the underlying stream on return,\r\n            otherwise keeps the underlying stream open until the returned ":"\r\n            忠实于将所有元数据从组件中预取，并在返回时关闭基础流，\r\n            否则将基础流保持开放直到返回\r\n","\r\n Helper method that replaces less-than and greater-than characters with brackets. \r\n ":"\r\n 辅助方法可以用括号替代比人字符少。\r\n \r\n","\r\n if there is a dependency chain from \"current\" to the \"root\"\r\n Returning Nothing, means that there is no dependency\r\n Returning Empty, means that root and current are the same and we have a 0-length dependency\r\n Otherwise a dependence chain is formed.\r\n ":"\r\n 如果存在从\"当前\"到\"根\"的依赖链\r\n 返回Nothing，表示没有依赖关系\r\n 返回空，意味着根和当前是相同的，我们有一个0长度的依赖关系\r\n 否则形成依赖链。\r\n \r\n","\r\n The value for the WhenKeyword property.\r\n ":"\r\n wherkeyword属性的值。\r\n \r\n","\r\n The \"R\" literal suffix denoting \"Double\"\r\n ":"\r\n “ r”字面后缀表示“ double”\r\n \r\n","\r\n Checks if the embedded symbol provided is in the collection and adds it \r\n into collection if not.\r\n \r\n See description of AddReferencedSymbolWithDependents for more details of how \r\n it actually works.\r\n ":"\r\n 检查收集中提供的嵌入式符号是否存在并添加\r\n 如果不是，则进入集合。\r\n \r\n 有关更多详细信息\r\n 它实际上有效。\r\n \r\n","\r\n Call the correct VisitXXX method in this class based on the particular type of symbol that is passed in.\r\n ":"\r\n 基于传递的特定类型的符号类型，在此类中调用正确的visitxxx方法。\r\n \r\n","\r\n            Similar to SuggestedAction, but in a location that can be used by\r\n            both local Roslyn and LSP.\r\n            ":"\r\n            类似于建议的操作，但是在可以使用的位置\r\n            当地的罗斯林和LSP。\r\n            \r\n","\r\n Represents a Catch part of an Try...Catch...Finally...End Try statement,\r\n consisting of a Catch statement, followed by a body of statements controlled by\r\n that Catch statement. The Kind property returns which kind of part this is.\r\n ":"\r\n 代表尝试的捕获部分...捕获...最后...结束尝试语句，\r\n 由捕捞陈述组成，然后是由\r\n 那个捕获的声明。同类属性返回哪种部分。\r\n \r\n","\r\n            The original solution that modifications made to annotate the symbol declarations\r\n            ":"\r\n            对符号声明进行注释的修改的原始解决方案\r\n            \r\n","\r\n  Looks up a localized string similar to Required attribute 'version' missing from XML declaration..\r\n":"\r\n  查找类似于XML声明中缺少所需属性的“版本”的本地化字符串。\r\n\r\n","\r\n If the specified node represents a lambda returns a node (or nodes) that represent its body (bodies).\r\n ":"\r\n 如果指定的节点代表lambda返回代表其身体（身体）的节点（或节点）。\r\n \r\n","Convert to tuple":"转换为元组\r\n","\r\n If With statement expression is being used from nested lambda there are some restrictions\r\n to the usage of Me reference in this expression. As these restrictions are only to be checked \r\n in few scenarios, this flag is being calculated lazily.\r\n ":"\r\n 如果使用嵌套lambda使用语句表达式，则有一些限制\r\n 在此表达中使用我参考。因为这些限制只需要检查\r\n 在少数情况下，该标志懒洋洋地计算出来。\r\n \r\n","\r\n            The rule determining how snippets work.\r\n            ":"\r\n            确定摘要如何工作的规则。\r\n            \r\n","The selection contains a local function call without its declaration.":"选择包含一个本地函数调用，而无需声明。\r\n","Warning: Method overrides symbol from metadata":"警告：方法覆盖元数据的符号\r\n","\r\n            It is recommended for hosts to expose the members defined by this class and implement \r\n            the same semantics, so that they can run scripts written against standard hosts. \r\n            \r\n            Specialized hosts that target niche scenarios might choose to not provide this functionality.\r\n            ":"\r\n            建议主持人公开该类别定义的成员并实施\r\n            相同的语义，以便他们可以使用标准主机编写的脚本。\r\n            \r\n            针对利基方案的专业主机可能会选择不提供此功能。\r\n            \r\n","\r\n default zero-init constructor symbol is added to a struct when it does not define \r\n its own parameterless public constructor.\r\n We do not emit this constructor and do not call it \r\n ":"\r\n 默认的零输入构造函数符号将在未定义时添加到结构\r\n 它自己的无参数公共构造函数。\r\n 我们不发出这个构造函数，也不称为\r\n \r\n"," from a Portable PDB metadata reader provider.\r\n            ":" 来自便携式PDB元数据读取器提供商。\r\n            \r\n","Directories to exclude from shadow-copying.":"目录将排除在影子复印之外。\r\n","\r\n Get the source module.\r\n ":"\r\n 获取源模块。\r\n \r\n","\r\n            Helper methods for pragma based suppression code actions.\r\n            ":"\r\n            基于PRAGMA的抑制代码操作的帮助方法。\r\n            \r\n","\r\n            Represents a range-pattern constructed from a couple of comparison operators\r\n            ":"\r\n            代表由几个比较操作员构建的范围图案\r\n            \r\n","\r\n            ```(?!expr)``` node.\r\n            ":"\r\n            ``（？！expr）``节点。\r\n            \r\n","Install version '{0}'":"安装版本'{0}'\r\n","\r\n Determine if two methods have the same signature according to section 4.1.1 of the VB language spec.\r\n The name, number of type parameters, and number and types of the method's non-optional parameters are\r\n considered. ByRef/Byval, parameter names, returns type, constraints, or optional parameters are not considered.\r\n ":"\r\n 根据VB语言规范的第4.1.1节确定两种方法是否具有相同的签名。\r\n 该方法的非选项参数的名称，类型参数的数量以及数字和类型是\r\n 经过考虑的。不考虑BYREF/BYVAL，参数名称，返回类型，约束或可选参数。\r\n \r\n","\r\n  Looks up a localized string similar to Reference to object under construction is not valid when calling another constructor..\r\n":"\r\n  在调用另一个构造函数时，查找类似于对构造对象的引用类似的本地化字符串。\r\n\r\n","\r\n            Creates a semantic analyzer for speculative syntax replacement.\r\n            ":"\r\n            为投机性语法替换创建语义分析仪。\r\n            \r\n","\r\n Binds a sync lock block.\r\n A SyncLock come in the following form:\r\n \r\n SyncLock <expression>\r\n     <body>\r\n End SyncLock\r\n ":"\r\n 绑定一个同步锁定块。\r\n Synclock采用以下形式：\r\n \r\n Synclock <表达>\r\n     <身体>\r\n 结束同步\r\n \r\n","-returning.\r\n            ":" - 返回。\r\n            \r\n","Fix return type":"修复返回类型\r\n","\r\n The comma tokens in the array type. There is one less comma than the rank.\r\n ":"\r\n 数组类型中的逗号令牌。逗号少于等级。\r\n \r\n","Refer to \"Statements in Visual Basic\", 2010 version, http://msdn.microsoft.com/en-us/library/865x40k4(v=vs.100).aspx \r\n for examples.":"请参阅“ Visual Basic中的语句”，2010年版，http：//msdn.microsoft.com/en-us/library/865x40k4(V=VS.100).aspx\r\n 举些例子。\r\n","\r\n Represents a reference to another Visual Basic compilation. \r\n ":"\r\n 代表对另一个视觉基本汇编的引用。\r\n \r\n","\r\n            Snippets are never included in the completion list\r\n            ":"\r\n            摘要从未包含在完成列表中\r\n            \r\n","\r\n The value for the NameEquals property.\r\n ":"\r\n nameequals属性的值。\r\n \r\n","\r\n Base class for symbols representing constructed generic types.\r\n For example: A(Of Integer), A.B(Of Integer), A(Of Integer).B.C(Of Integer).\r\n ":"代表构造的通用类型的符号的基类。\r\n 例如：A（整数），A.B（整数），A（Integer）.b.c（整数）。\r\n \r\n","\r\n            Generates an override of ":"\r\n            产生一个替代\r\n","mark, nonspacing":"马克，非公共\r\n","\r\n  Looks up a localized string similar to 'If' operands cannot be named arguments..\r\n":"\r\n  查找类似于“如果”操作数类似的本地化字符串。\r\n\r\n","\r\n The value for the Equals property.\r\n ":"\r\n 等价属性的值。\r\n \r\n","\r\n A statement that declares a delegate type.\r\n ":"\r\n 声明宣布委托类型的声明。\r\n \r\n","\r\n  Looks up a localized string similar to Derived classes cannot raise base class events..\r\n":"\r\n  查找类似于派生类的本地化字符串无法引起基类事件。\r\n\r\n","\r\n            Class responsible for actually computing the entire set of code actions to offer the user.\r\n            ":"\r\n            班级负责实际计算整个代码操作以提供用户。\r\n            \r\n","\r\n Perform validation of an import statement that must occur\r\n after the statement has been added to the module. Specifically,\r\n constraints are checked for generic type references.\r\n ":"执行必须发生的导入语句的验证\r\n 在将语句添加到模块之后。具体来说，\r\n 检查通用类型引用的约束。\r\n \r\n","Feature '{0}' is not available in C# 10.0. Please use language version {1} or greater.":"C＃10.0中不可用功能'{0}'。请使用语言版本{1}或更大。\r\n","\r\n Add an empty line after the begin, except the first member is a nested namespace.\r\n Separate each member of a namespace with an empty line. \r\n ":"\r\n 开始后添加一个空行，除了第一个成员是嵌套名称空间。\r\n 将名称空间的每个成员与空行分开。\r\n \r\n","\r\n     Public Function LookupNames(position As Integer, Optional container As NamespaceOrTypeSymbol = Nothing, Optional options As LookupOptions = LookupOptions.Default, Optional results As List(Of String) = Nothing) As IList(Of String)\r\n     Public Function LookupSymbols(position As Integer,\r\n                                  Optional container As NamespaceOrTypeSymbol = Nothing,\r\n                                  Optional name As String = Nothing,\r\n                                  Optional arity As Integer? = Nothing,\r\n                                  Optional options As LookupOptions = LookupOptions.Default,\r\n                                  Optional results As List(Of Symbol) = Nothing) As IList(Of Symbol)\r\n ":"\r\n     public Function LookupNames（位置为整数，可选容器为namespaceOrtypesymbol = nothing，可选选项为LookupOptions = lookupoptions.default.default，可选结果为list（of String）= nothing）作为ILIST（of String）\r\n     公共功能查找符号（作为整数的位置，\r\n                                  可选容器作为namespaceOrtyPesymbol = Nothing，\r\n                                  可选名称为字符串= Nothing，\r\n                                  可选的Arity作为整数？ =没有，\r\n                                  可选选项AS LookupTions = LookupOptions.default，\r\n                                  可选结果作为列表（符号）= nothing）作为iList（符号的）\r\n \r\n","\\d matches any decimal digit. It is equivalent to the \\p{Nd} regular expression pattern, which includes the standard decimal digits 0-9 as well as the decimal digits of a number of other character sets.\r\n            \r\n            If ECMAScript-compliant behavior is specified, \\d is ...":"\\ d匹配任何十进制数字。它等同于\\ p {nd}正则表达模式，其中包括标准的小数位数0-9以及许多其他字符集的十进制数字。\r\n            \r\n            如果指定了符合eCMAScript的行为，\\ d是...\r\n","\r\n Returns a copy of this with the PrecedingMisc property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 将其返回此副本，而先前的属性将其更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n"," variable\r\n the declarator is the ":" 多变的\r\n 声明者是\r\n","Fully qualify '{0}'":"完全资格'{0}'\r\n"," to be applicable container, it must be a namespace \r\n             declaration or a compilation unit, contain no partial declarations and meet the following additional\r\n             requirements:\r\n             \r\n             - If a namespace declaration:\r\n                1. It doesn't contain or is nested in other namespace declarations\r\n                2. The name of the namespace is valid (i.e. no errors)\r\n            \r\n             - If a compilation unit (i.e. ":" 要成为适用的容器，必须是一个名称空间\r\n             声明或汇编单元，不包含部分声明，并满足以下额外\r\n             要求：\r\n             \r\n              - 如果名称空间声明：\r\n                1.它不包含或嵌套在其他名称空间声明中\r\n                2.名称空间的名称有效（即没有错误）\r\n            \r\n              - 如果汇编单元（即\r\n","\r\n Symbols representing constructed generic type that is contained within another constructed generic type.\r\n For example: A(Of Integer).B(Of Integer), A(Of Integer).B.C(Of Integer).\r\n ":"\r\n 代表另一个构造的通用类型中包含的构造的通用类型的符号。\r\n 例如：a（integer）.b（integer），a（integer）.b.c（整数）。\r\n \r\n","\r\n Bind the expression within the XmlEmbeddedExpressionSyntax,\r\n and wrap in a BoundXmlEmbeddedExpression.\r\n ":"\r\n 在xmlembeddedexpressyntax中绑定表达式，\r\n 并包裹在边界表达中。\r\n \r\n","The first parameter of the 'in' extension method '{0}' must be a concrete (non-generic) value type.":"“扩展方法” {0}'的第一个参数必须是具体的（非生成）值类型。\r\n","\r\n Get a read-only list of the syntax trees that this compilation was created with PLUS\r\n the trees that were automatically added to it, i.e. Vb Core Runtime tree.\r\n ":"\r\n 获取只读的语法树列表，该汇编是用Plus创建的\r\n 自动添加到它的树，即VB核心运行时树。\r\n \r\n","\r\n            Subclasses must implement this method to provide fixes for any diagnostics that this\r\n            type has registered.  If this subclass wants the same code to run for this single\r\n            diagnostic as well as for when running fix-all, then it should call \r\n            ":"\r\n            子类必须实现此方法，以为任何诊断提供修复程序\r\n            类型已注册。如果此子类希望为此单曲运行相同的代码\r\n            诊断和运行时，应致电\r\n            \r\n","\r\n            The span of the document that the item is based on.\r\n            ":"\r\n            项目所基于的文档的跨度。\r\n            \r\n","Add default case":"添加默认情况\r\n","Implementing a record positional parameter '{0}' with a set accessor requires restarting the application.":"使用SET登录器实现记录位置参数'{0}'需要重新启动应用程序。\r\n","\r\n DO NOT USE DIRECTLY.\r\n USE GetScratch()\r\n ":"\r\n 不要直接使用。\r\n 使用getsCratch（）\r\n \r\n","True if this Is an interface type.":"如果是接口类型，则为true。\r\n","Type that contains lambda method \r\n - it is either Frame or enclosing class in a case if we do not lift anything.":"包含lambda方法的类型\r\n  - 如果我们不举起任何东西，则是框架或封闭类。\r\n","\r\n The key of the anonymous type descriptor used for this type template\r\n ":"\r\n 用于此类型模板的匿名类型描述符的键\r\n \r\n","The return type of the submission":"提交的返回类型\r\n"," holding on values of global variables accessible from the script.\r\n            Must be specified if and only if the script was created with a ":" 保持可从脚本访问的全局变量值。\r\n            必须指定且仅当脚本创建脚本时必须指定\r\n","\r\n Get the highest bound node in the tree associated with a particular syntax node.\r\n ":"\r\n 获取与特定语法节点关联的树中的最高界节点。\r\n \r\n","\r\n A region analysis walker that records jumps out of the region.\r\n ":"\r\n 记录的区域分析步行者跳出了该地区。\r\n \r\n","\r\n Should return full emitted namespace name for a top level type if the name \r\n might be different in case from containing namespace symbol full name, Nothing otherwise.\r\n ":"\r\n 如果名称\r\n 如果没有包含名称空间符号的全名，则可能不同。\r\n \r\n","\r\n The \"While\" keyword.\r\n ":"\r\n “ while”关键字。\r\n \r\n","\r\n The value for the ReDimKeyword property.\r\n ":"\r\n redimkeyword属性的值。\r\n \r\n","The constructed generic type.":"构造的通用类型。\r\n","The switch expression does not handle some values of its input type (it is not exhaustive) involving an unnamed enum value.":"开关表达式不处理其输入类型的某些值（并不详尽），涉及未命名的枚举值。\r\n","\r\n  Looks up a localized string similar to Type '{0}' conflicts with public type defined in added module '{1}'..\r\n":"\r\n  查找类似于类型“ {0}”冲突与添加模块'{1}'..的public类型相似的本地化字符串。\r\n\r\n","\r\n Represents a state machine method other than a MoveNext method.\r\n All such methods are considered non-user code. \r\n ":"\r\n 代表除movenext方法以外的状态机方法。\r\n 所有此类方法均被视为非用户代码。\r\n \r\n","\r\n Create a diagnostic for the given symbol. This could be an error or a warning based on\r\n the ObsoleteAttribute's arguments.\r\n ":"\r\n 为给定符号创建诊断。这可能是基于错误的错误或警告\r\n 过时的论点。\r\n \r\n","punctuation, close":"标点符号，关闭\r\n","\r\n Represents a line If-Then-Else statement.\r\n ":"\r\n 代表一行，如果是else语句。\r\n \r\n"," when they are \r\n analyzed.\r\n\r\n For reasons of lifetime management, this type is distinct from the ":" 当他们是什么时候\r\n 分析。\r\n\r\n 由于一生管理的原因，这种类型与\r\n","\r\n Returns the keyword indicating the kind of declaration being made: \"Class\", \"Structure\", \"Module\", \"Interface\", etc.\r\n ":"\r\n 返回指示声明类型的关键字：“类”，“结构”，“模块”，“接口”，等。\r\n \r\n","The span of the syntax element at the caret position when the ":"当伦敦位置的语法元素的跨度\r\n","\r\n Create the Nullable version of a type.\r\n ":"创建类型的无效版本。\r\n \r\n","\r\n Retrieves Set method for this property or 'most derived' Set method from closest \r\n overridden property if such property exists.\r\n \r\n NOTE: It is not possible in VB, but possible in other languages (for example in C#) to\r\n       override read-write property an provide override only for getter, thus inheriting \r\n       setter's implementation. This method will find the Set method from the most-derived\r\n       overridden property in this case\r\n ":"从最亲密的\r\n 如果存在此类财产，则覆盖财产。\r\n \r\n 注意：在VB中不可能，但其他语言（例如C＃中的其他语言）不可能\r\n       覆盖读写属性仅提供替代，因此继承\r\n       Setter的实现。此方法将从最衍生的\r\n       在这种情况下覆盖财产\r\n \r\n","\r\n Returns a copy of this with the [Inherits] property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，并将[继承]属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Lazily initialized by TypeKind property.\r\n Using Integer type to make sure read/write operations are atomic.\r\n ":"\r\n 懒惰的typekind属性初始化。\r\n 使用整数类型确保读/写操作是原子。\r\n \r\n","The type of the created object expression.":"创建对象表达式的类型。\r\n","\r\n            Returns true if the completion item matches the pattern so far.  Returns 'true'\r\n            if and only if the completion item matches and should be included in the filtered completion\r\n            results, or false if it should not be.\r\n            ":"\r\n            如果完成项目到目前为止，则返回true。返回“ true”\r\n            且仅当完成项目匹配并应包括在过滤后的完成中\r\n            结果，或者如果不这样做，则为错误。\r\n            \r\n","\r\n  Looks up a localized string similar to Conversion from 'Double' to 'Date' requires calling the 'Date.FromOADate' method..\r\n":"\r\n  查找类似于从“双”转换到“日期”的局部字符串，需要调用“ date.fromadate”方法。\r\n\r\n","\r\n Represents aggregation in aggregation range variable declaration of a Group By,\r\n Group Join or Aggregate query operator.\r\n ":"\r\n 代表集合范围范围可变声明的聚合，由\r\n 组加入或汇总查询操作员。\r\n \r\n","\r\n            Single Spacing\r\n        ":"\r\n            单个间距\r\n        \r\n","\r\n Gets a value indicating whether this instance is a sub.\r\n ":"\r\n 获取一个指示此实例是否为子的值。\r\n \r\n","(Unknown)":"（未知）\r\n","A project context with which to generate source for symbol\r\n            if it has no source locations":"为符号生成源的项目上下文\r\n            如果没有源位置\r\n","\r\n Get all the pairs of substitutions, including from the parent substitutions. The substitutions\r\n are in order from outside-in (parent substitutions before child substitutions).\r\n ":"\r\n 获取所有替换对，包括来自父替代。替代\r\n 是按外部的秩序（父母替换之前的父母替换）。\r\n \r\n","Local function '{0}' must declare a body because it is not marked 'static extern'.":"本地函数'{0}'必须声明一个主体，因为它没有标记为“静态外部”。\r\n"," values are equal.\r\n ":" 值相等。\r\n \r\n"," for the\r\n            specific case where the result is only used for testing if any element meets certain conditions.\r\n            ":" 为了\r\n            在任何元素符合某些条件的情况下仅用于测试结果的具体情况。\r\n            \r\n","\r\n            root node of the annotated tree.\r\n            ":"\r\n            注释树的根节点。\r\n            \r\n","\r\n            Gets the location representing the start of the file header.\r\n            ":"\r\n            获取表示文件头开始的位置。\r\n            \r\n","Only attributes, constructor initializers, expressions or statements can be made explicit":"只能使属性，构造函数初始化，表达式或语句才能显式\r\n","\r\n            Organize document\r\n            ":"\r\n            组织文件\r\n            \r\n","form-feed character":"形式喂养字符\r\n"," as well as the optional ":" 以及可选的\r\n","Wrap and align expression":"包裹和对齐表达\r\n","Type of the interface.":"接口的类型。\r\n","\r\n            Indicates the start of a text container. The elements after ":"\r\n            指示文本容器的开始。之后的元素\r\n","\r\n Data for Binder.BindImportClause that maintains flat lists\r\n of members and member syntax references in addition to\r\n the dictionaries needed by BindImportClause.\r\n ":"\r\n Binder.Bindimportclause维护平坦列表\r\n 成员和成员语法参考除了\r\n Bindimportclause所需的字典。\r\n \r\n","\r\n            Equivalent to SuggestedActionSetPriority, but in a location that can be used\r\n            by both local Roslyn and LSP.\r\n            ":"\r\n            相当于建议的eDactionsetpriority，但在可以使用的位置\r\n            由当地的罗斯林和LSP撰写。\r\n            \r\n"," array contains the given kind.\r\n            ":" 数组包含给定的类型。\r\n            \r\n","\r\n            Although in theory any expression is allowed to be embedded in the string such behavior is in practice fundamentally broken.\r\n            The attribute doesn't specify what language (VB, C#, F#, etc.) to use to parse these expressions. Even if it did all languages \r\n            would need to be able to evaluate each other language's expressions, which is not viable and the Expression Evaluator doesn't \r\n            work that way today. Instead it evaluates the embedded expressions in the language of the current method frame. When consuming \r\n            VB objects from C#, for example, the evaluation might fail due to language mismatch (evaluating VB expression using C# parser).\r\n            \r\n            Therefore we limit the expressions to a simple language independent syntax: {clr-member-name} '(' ')' ',nq', \r\n            where parentheses and ,nq suffix (no-quotes) are optional and the name is an arbitrary CLR field, property, or method name.\r\n            We then resolve the member by name using case-sensitive lookup first with fallback to case insensitive and evaluate it.\r\n            If parentheses are present we only look for methods.\r\n            Only parameterless members are considered.\r\n            ":"\r\n            尽管从理论上讲，任何表达式都可以嵌入在字符串中，但实际上，这种行为在根本上被打破了。\r\n            该属性未指定用于解析这些表达式的语言（VB，C＃，F＃等）。即使它有所有语言\r\n            将需要能够评估彼此语言的表达式，这是不可行的，并且表达式评估者不可行\r\n            今天这样工作。取而代之的是，它以当前方法框架的语言评估嵌入式表达式。消费时\r\n            例如，来自C＃的VB对象可能由于语言不匹配而失败（使用C＃解析器评估VB表达式）。\r\n            \r\n            因此，我们将表达式限制为简单的语言独立语法：{clr-ember-name}'（''）'，nq'，\r\n            在括号和NQ后缀（无引用）的情况下，名称是任意的CLR字段，属性或方法名称。\r\n            然后，我们首先使用案例敏感的查找来通过名称解决成员，从而使案例不敏感并对其进行评估。\r\n            如果存在括号，我们只会寻找方法。\r\n            仅考虑无参数成员。\r\n            \r\n","\r\n Represent a field initializer in a With {...} initializer where the field name\r\n is inferred from the initializer expression.\r\n ":"\r\n 表示{...} initializer在fializh in fialtiber中的字段初始化器中的字段名称\r\n 从初始化器表达式推断出来。\r\n \r\n","The position of the first token":"第一个令牌的位置\r\n","\r\n            Attempts to add missing imports to the document within the textspan provided. The imports added will\r\n            not add assembly references to the project. In case of failure, null is returned. Failure can happen\r\n            if there are ambiguous imports, no known resolutions to import, or if no imports that would be provided\r\n            would be added without adding a reference for the project. \r\n            ":"试图将丢失的导入添加到提供的文本中的文档中。添加的导入将\r\n            不向项目添加汇编引用。如果发生故障，则返回空。失败可能发生\r\n            如果有模棱两可的进口，则没有已知的进口决议，或者没有提供的进口\r\n            将在不添加项目参考的情况下添加。\r\n            \r\n"," through (but not\r\n            including) the matching ":" 通过（但不是\r\n            包括）匹配\r\n","\r\n            Automatically detects the underlying PDB format and returns the appropriate reader.\r\n            ":"\r\n            自动检测基础PDB格式并返回适当的读者。\r\n            \r\n","\r\n A wrapper around RootSingleNamespaceDeclaration. The namespace declaration\r\n is evaluated lazily to avoid evaluating the namespace and associated SyntaxTree\r\n for embedded syntax trees before we can determine whether the syntax tree is needed.\r\n ":"\r\n 围绕RootsingLenamespacedEclaration的包装器。名称空间声明\r\n 懒惰地评估以避免评估名称空间和相关的语法\r\n 对于嵌入式语法树，我们才能确定是否需要语法树。\r\n \r\n","Null-checking preferences":"null检查偏好\r\n","\r\n Returns whether this namespace is the unnamed, global namespace that is \r\n at the root of all namespaces.\r\n ":"\r\n 返回此名称空间是否是未命名的全局名称空间\r\n 在所有名称空间的根部。\r\n \r\n","\r\n The value for the Empty property.\r\n ":"\r\n 空属性的值。\r\n \r\n","The local symbol.":"本地符号。\r\n","match one or more times (lazy)":"匹配一次或多次（懒惰）\r\n","The \"yy\" custom format specifier represents the year as a two-digit number. If the year has more than two digits, only the two low-order digits appear in the result. If the two-digit year has fewer than two significant digits, the number is padded with lea ...":"“ YY”自定义格式指定符将本年份表示为两位数的编号。如果一年有两个以上的数字，则结果仅出现两个低阶数字。如果两位数年的数字少于两个，那么这个数字就被Lea填充了...\r\n","\r\n A trivia with kind WhitespaceTrivia containing a single tab character.\r\n ":"\r\n 带有单个标签字符的善良的琐事。\r\n \r\n","\r\n For every other submission referenced by this submission we add a field, so that we can access members of the target submission.\r\n A field is also needed for the host object, if provided.\r\n ":"\r\n 对于本提交的所有其他提交提交的提交，我们添加了一个字段，以便我们可以访问目标提交的成员。\r\n 如果提供，也需要主机对象的字段。\r\n \r\n","\r\n Lookup declaration for FX type in this Assembly.\r\n ":"\r\n 该组件中FX类型的查找声明。\r\n \r\n","The current document.":"当前文档。\r\n","Add 'await' and 'ConfigureAwait(false)'":"添加“等待”和“ configureawait（false）”\r\n","\r\n            Adding, updating and deleting of custom attributes (as distinct from pseudo-custom attributes)\r\n            ":"\r\n            添加，更新和删除自定义属性（与伪custom属性不同）\r\n            \r\n"," property.\r\n            These tags influence the presentation of text.\r\n            ":" 财产。\r\n            这些标签会影响文本的呈现。\r\n            \r\n"," is \"\" then the relative namespace us ":" 是“”然后是相对名称空间\r\n"," \r\n Determines if this constructor calls another constructor of the constructor's containing class. \r\n ":" \r\n 确定该构造函数是否称为构造函数包含类的另一个构造函数。\r\n \r\n","\r\n            Get diagnostics currently stored in the source. returned diagnostic might be out-of-date if solution has changed but analyzer hasn't run for the new solution.\r\n            ":"\r\n            获取当前存储在源中的诊断。如果解决方案已更改，则返回的诊断可能会过时，但是分析仪尚未为新解决方案运行。\r\n            \r\n","\r\n The value for the TypeArgumentList property.\r\n ":"\r\n TypeArgumentList属性的值。\r\n \r\n","The \"MMMM\" custom format specifier represents the full name of the month. The localized name of the month is retrieved from the DateTimeFormatInfo.MonthNames property of the current or specified culture.":"“ MMMM”自定义格式指定符表示本月的全名。从dateTimeFormatInfo.Monthnames属性检索本月的本地名称。\r\n","\r\n  Looks up a localized string similar to '(' expected..\r\n":"\r\n  查找类似于'（'预期的..\r\n\r\n","\r\n Should we record bound node mapping for this node? Generally, we ignore compiler generated, but optionally can\r\n allow.\r\n ":"\r\n 我们应该记录此节点的绑定节点映射吗？通常，我们忽略了编译器生成的，但可以选择\r\n 允许。\r\n \r\n"," that has no ":" 那没有\r\n","\r\n  Looks up a localized string similar to 'With' must end with a matching 'End With'..\r\n":"\r\n  查找类似于“必须“必须结束”的局部字符串，并以'的结尾结尾。\r\n\r\n","Example:":"例子：\r\n","\r\n            Parses the forEachStatement until a child node cannot be converted into a query clause.\r\n            ":"\r\n            解析foreach statement，直到无法将子节点转换为查询子句为止。\r\n            \r\n","\r\n Gets a value indicating whether this instance is vararg.\r\n ":"\r\n 获取一个指示此实例是否为vararg的值。\r\n \r\n","\r\n            If the statement has an ":"\r\n            如果该声明有一个\r\n","\r\n  Looks up a localized string similar to 'Custom' modifier can only be used immediately before an 'Event' declaration..\r\n":"\r\n  查找类似于“自定义”修饰符的本地化字符串只能在“事件”声明之前立即使用。\r\n\r\n","\r\n Returns a copy of this with the Identifier property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，标识符属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Represents a single syntactic token in a VB program. A token is a keyword,\r\n punctuator, literal, identifier or XML token. The type of keyword or punctuator\r\n can be determined from the Kind property.\r\n ":"\r\n 代表VB程序中的单个句法令牌。令牌是关键字，\r\n 标点器，文字，标识符或XML令牌。关键字或标点的类型\r\n 可以从相同的属性确定。\r\n \r\n","Type '{0}' is not defined.":"键入'{0}'未定义。\r\n","\r\n Parses the base address option.\r\n In case an invalid value was passed, nothing is returned.\r\n ":"\r\n 解析基础地址选项。\r\n 如果通过无效的值，则什么都没有返回。\r\n \r\n","\r\n A list of statements to be executed if the condition expression of the \"ElseIf\"\r\n statement evaluates as true.\r\n ":"\r\n 如果“ elseif”的条件表达式，将执行的语句列表\r\n 声明评估为真实。\r\n \r\n","\r\n Gets symbol information about the 'Add' method corresponding to an expression syntax ":"\r\n 获取有关表达语法对应的“添加”方法的符号信息\r\n","\r\n If present, the \"Alias\" keyword. If not present, returns Nothing.\r\n ":"\r\n 如果存在，则“别名”关键字。如果不存在，什么也不会返回。\r\n \r\n","\r\n            Additional information attached to a completion item by it creator.\r\n            ":"\r\n            IT创建者附加到完成项目上的其他信息。\r\n            \r\n","\r\n  Looks up a localized string similar to Array initializer cannot be specified for a non constant dimension; use the empty initializer '{}'..\r\n":"\r\n  查找类似于数组初始化程序的本地化字符串，不能为非恒定尺寸指定；使用空初始化器'{}'..\r\n\r\n","\r\n Creates red tokens for a stream of text\r\n ":"\r\n 为文本流创建红色令牌\r\n \r\n","\r\n Returns ":"\r\n 返回\r\n","\r\n Binder used to bind Catch blocks. \r\n It hosts the control variable (if one is declared) \r\n and inherits BlockBaseBinder since there are no Exit/Continue for catch blocks. \r\n ":"\r\n 粘合剂用于绑定捕获块。\r\n 它托管控制变量（如果声明了）\r\n 并继承BlockbaseBinder，因为没有出口/继续用于捕获块。\r\n \r\n","\r\n Source: Returns whether this method is an iterator; i.e., does it have the Iterator modifier?\r\n Metadata: Returns False; methods from metadata cannot be an iterator.\r\n ":"\r\n 资料来源：返回此方法是否为迭代器；即，它是否具有迭代器修饰符？\r\n 元数据：返回false;来自元数据的方法不能是迭代器。\r\n \r\n","\r\n Returns the type of the elements that are stored in this array.\r\n ":"\r\n 返回该数组中存储的元素的类型。\r\n \r\n","\r\n The value for the FromValue property.\r\n ":"\r\n FromValue属性的值。\r\n \r\n","\r\n Internal helper for ":"\r\n 内部帮手\r\n","\r\n Returns a copy of this with the Token3 property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，Token3属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","The text used to determine if the item matches the filter and is show in the list.":"用于确定项目是否匹配过滤器并在列表中显示的文本。\r\n","Filter expression is a constant 'false', consider removing the catch clause":"滤波器表达式是常数“ false”，请考虑删除捕获子句\r\n","\r\n            Non-empty if this work item is intended to be executed only for specific incremental analyzer(s).\r\n            Otherwise, the work item is applicable to all relevant incremental analyzers.\r\n            ":"\r\n            如果仅针对特定的增量分析仪执行此工作项，则非空。\r\n            否则，工作项适用于所有相关的增量分析仪。\r\n            \r\n","\r\n            Gets, filters, and orders code refactorings.\r\n            ":"\r\n            获取，过滤器和订单代码重构。\r\n            \r\n","\r\n            Gets the service corresponding to the specified document.\r\n            ":"\r\n            获取与指定文档相对应的服务。\r\n            \r\n","\r\n            However, for application purposes, we end up returning a single operation\r\n            that will then apply all our sub actions in order, stopping the moment\r\n            one of them fails.\r\n            ":"\r\n            但是，出于应用目的，我们最终返回一个操作\r\n            然后，这将应用我们所有的子行动，停止时刻\r\n            其中一个失败了。\r\n            \r\n","Warning: Inlining temporary variable may change code meaning.":"警告：内部临时变量可能会更改代码含义。\r\n","\r\n BindRValue evaluates the node and returns a BoundExpression.  \r\n It ensures that the expression is a value that can be used on the right hand side of an assignment.  \r\n If not, it reports an error.\r\n \r\n Note that this function will reclassify all expressions to have their \"default\" type, i.e.\r\n Anonymous Delegate for a lambda, default array type for an array literal, will report an error \r\n for an AddressOf, etc. So, if you are in a context where there is a known target type for the \r\n expression, do not use this function. Instead, use BindValue followed by \r\n ApplyImplicitConversion/ApplyConversion.  \r\n ":"\r\n bindrvalue评估节点并返回边界表达。\r\n 它确保表达式是可以在作业右侧使用的值。\r\n 如果没有，它报告了一个错误。\r\n \r\n 请注意，此函数将重新分类所有表达式以具有其“默认”类型，即\r\n lambda的匿名代表，默认数组类型的数组文字，将报告一个错误\r\n 对于一个地址等。因此，如果您处于存在已知目标类型的上下文中\r\n 表达式，请勿使用此功能。相反，使用bindvalue，然后使用\r\n applyImplicerConversion/applyConversion。\r\n \r\n","\r\n Checks if an applied attribute with the given attributeType matches the namespace name and type name of the given early attribute's description\r\n and the attribute description has a signature with parameter count equal to the given attribute syntax's argument list count.\r\n NOTE: We don't allow early decoded attributes to have optional parameters.\r\n ":"\r\n 检查给定属性的应用属性是否匹配给定早期属性描述的名称名称和类型名称\r\n 并且属性描述具有一个签名，其参数计数等于给定属性语法的参数列表计数。\r\n 注意：我们不允许早期解码属性具有可选参数。\r\n \r\n","\r\n Produces a syntax tree by parsing the source text.\r\n ":"\r\n 通过解析源文本产生语法树。\r\n \r\n","\r\n Collection of 0, 1 or more slots. Allows returning of several slots by some \r\n DataFlowPass methods to handle cases where implicit receiver represents \r\n several variables, like in:\r\n     Dim a, b, c As New C(...) With {...}\r\n \r\n Because such constructions are very rare in real user code, the collection only \r\n allocates an array builder for storing several values if there are indeed more \r\n than one slot to be stored. Because the collection may optionally create an \r\n array builder, collection's Free() method must be called when appropriate.\r\n \r\n Note that the collection is mutable, so one can add or modify the values.\r\n If some collection elements get replaced with 'SlotKind.NotTracked' collection\r\n does NOT \"shrink\", i.e. once allocated the array builder is not freed even if \r\n all the elements are set to 'SlotKind.NotTracked'.\r\n \r\n Collection cannot store 'SlotKind.Unreachable' (0) which has a special meaning.\r\n ":"\r\n 收集0、1或更多插槽。允许某些插槽返回几个插槽\r\n DataFlowPass方法处理隐式接收器代表的情况\r\n 几个变量，例如：\r\n     dim a，b，c作为{...}的新C（...）\r\n \r\n 因为在真实用户代码中，此类构造非常罕见，所以仅收集\r\n 如果确实有更多\r\n 比一个要存储的插槽。因为该集合可以选择创建一个\r\n 阵列构建器，Collection的Free（）方法必须在适当时调用。\r\n \r\n 请注意，该集合是可变的，因此可以添加或修改值。\r\n 如果某些集合元素被“ slotkind.nottracked”收集替换\r\n 不会“收缩”，即一旦分配了阵列构建器，即使\r\n 所有元素都设置为“ slotkind.nottracked”。\r\n \r\n 收集无法存储具有特殊含义的“ slotkind.unrachable”（0）。\r\n \r\n","\r\n Binds all field initializers of a ":"\r\n 绑定一个\r\n","Remove 'this' qualification":"删除“此”资格\r\n","\r\n The value for the FinallyKeyword property.\r\n ":"最终关键字属性的值。\r\n \r\n"," after it has finished binding attributes on the symbol,\r\n has executed ":" 在符号上完成绑定属性后，\r\n 已执行\r\n","\r\n Default implementation to force consideration of appropriate implementation for each new subclass\r\n ":"\r\n 默认实施以强制考虑每个新子类适当实施\r\n \r\n","The script options.":"脚本选项。\r\n","\r\n  Looks up a localized string similar to The 'Async' modifier can only be used on Subs, or on Functions that return Task or Task(Of T)..\r\n":"\r\n  查找类似于“ async”修饰符的本地化字符串，只能在subs上或返回任务或任务（t）的函数上使用。\r\n\r\n","\r\n Consider only labels. If this is not set, labels are not considered at all.\r\n ":"\r\n 仅考虑标签。如果未设置此设置，则根本不考虑标签。\r\n \r\n","\r\n            to the provided ":"\r\n            到提供的\r\n","\r\n Create a BoundBadExpression node for the given syntax node. No symbols or bound nodes are associated with it.\r\n ":"\r\n 为给定的语法节点创建一个boundbadexpression节点。它没有与之关联的符号或绑定节点。\r\n \r\n","Reverse 'for' statement":"反向'for'语句\r\n","\r\n Bound block including \r\n  - call to a base constructor\r\n  - field initializers and top-level code\r\n  - remaining constructor statements (empty for a submission)\r\n ":"\r\n 绑定块，包括\r\n   - 致电基本构造函数\r\n   - 字段初始化器和顶级代码\r\n   - 剩余的构造函数语句（提交提交的空）\r\n \r\n","\r\n Create a duplicate of this compilation with different symbol instances\r\n ":"\r\n 使用不同的符号实例创建此汇编的副本\r\n \r\n","\r\n            Checks if we should wrap the conditional expression over multiple lines.\r\n            ":"\r\n            检查是否应该在多行上包裹条件表达式。\r\n            \r\n","\r\n The \"Get\", \"Set\", \"AddHandler\", \"RemoveHandler\", or \"RaiseEvent\" keyword that\r\n introduces this accessor declaration.\r\n ":"\r\n “ get”，“ set”，“ addhandler”，“ removehandler”或“ raiseevent”关键字\r\n 介绍此登录声声明。\r\n \r\n","\r\n The value for the Token3 property.\r\n ":"\r\n Token3属性的值。\r\n \r\n","\r\n Given an FieldInitializerSyntax, get the corresponding symbol of anonymous type property.\r\n ":"\r\n 给定一个fieldInitializerSyntax，获取匿名类型属性的相应符号。\r\n \r\n","\r\n            Represents a type-pattern, constructed from an is-expression\r\n            ":"\r\n            代表由IS-Expression构建的类型模式\r\n            \r\n","\r\n Represents a \"Return\" statement.\r\n ":"\r\n 代表“返回”语句。\r\n \r\n","Matches an ASCII control character, where X is the letter of the control character. For example, \\cC is CTRL-C.":"匹配ASCII控制字符，其中X是控制字符的字母。例如，\\ cc是ctrl-c。\r\n","\r\n Look up the assembly to which the given metadata type Is forwarded.\r\n ":"\r\n 查找给定的元数据类型被转发到的组件。\r\n \r\n"," only contains suppression fixes -\r\n            the priority of such ":" 仅包含抑制修复 - \r\n            这样的优先事项\r\n","\r\n Returns the type symbol that this type was constructed from. This type symbol\r\n has the same containing type, but has type arguments that are the same\r\n as the type parameters (although its containing type might not).\r\n ":"\r\n 返回此类型的构造的类型符号。此类型符号\r\n 具有相同的包含类型，但具有相同的类型参数\r\n 作为类型参数（尽管其包含类型可能没有）。\r\n \r\n"," doesn't match ":" 不匹配\r\n","\r\n Determines if the unicode character is a underscore character.\r\n ":"\r\n 确定Unicode字符是否是下划线字符。\r\n \r\n","\r\n Returns the list of custom modifiers, if any, associated with the returned value. \r\n ":"\r\n 返回与返回值关联的自定义修饰符列表。\r\n \r\n","\r\n             Subclasses should implement this to provide the refactoring that works in the opposing\r\n             direction of what the option preference is.  This is only called if the user has the\r\n             code style enabled, and has it set to 'info/warning/error'.  In this case it is the\r\n             *analyzer* responsible for making code compliant with the option.\r\n            \r\n             The refactoring then exists to allow the user to update their code to go against that\r\n             option on an individual case by case basis.\r\n            \r\n             For example, if the user had set that they want expression-bodies for methods (at\r\n             warning level), then this would offer 'use block body' on a method that had an\r\n             expression body already.\r\n             ":"\r\n             子类应实施此功能，以提供对抗中有效的重构\r\n             选项偏好的方向。仅当用户具有\r\n             启用了代码样式，并将其设置为“信息/警告/错误”。在这种情况下，是\r\n             *分析仪*负责使代码符合该选项。\r\n            \r\n             然后存在重构，以允许用户更新其代码以违反该代码\r\n             根据情况为基础，选项。\r\n            \r\n             例如，如果用户设置了他们想要方法的表达体，则\r\n             警告级别），然后将其提供“使用块主体”\r\n             表达身体已经。\r\n             \r\n","\r\n Crumbles current node onto the stack and pops one node into current.\r\n Returns false if current node cannot be crumbled.\r\n ":"\r\n 将电流节点碎在堆栈上，并将一个节点弹出到电流中。\r\n 如果电流节点不能崩溃，则返回false。\r\n \r\n","\r\n Helper method to force type parameter constraints to be resolved.\r\n ":"\r\n 强迫类型参数约束的帮助方法要解决。\r\n \r\n"," and update internal state.\r\n            \r\n            since this has a side-effect, this should never be called concurrently. and incremental analyzer (solution crawler) should guarantee that.\r\n            ":" 并更新内部状态。\r\n            \r\n            由于这具有副作用，因此绝不应同时称为。和增量分析仪（解决方案蠕虫）应保证。\r\n            \r\n","\r\n True if the parameter has a default value defined in source via an optional parameter syntax, \r\n or the parameter is from metadata and HasDefault and Optional metadata flags are set,\r\n or the parameter is from metadata, has Optional flag set and ":"\r\n true如果参数具有通过可选参数语法在源中定义的默认值，\r\n 或该参数来自元数据和hasdefault，并设置了可选的元数据标志，\r\n 或该参数来自元数据，具有可选标志集和\r\n","\r\n            This is the root helper that all other TrySimplify methods in this type must call\r\n            through once they think there is a good chance something is simplifiable.  It does the\r\n            work of actually going through the real simplification system to validate that the\r\n            simplification is legal and does not affect semantics.\r\n            ":"\r\n            这是所有其他Trysimifify方法中必须调用的所有其他Trysimify方法的根手\r\n            一旦他们认为某些事情是可以简化的。它做了\r\n            实际操作真实简化系统的工作，以验证\r\n            简化是合法的，不会影响语义。\r\n            \r\n","\r\n Returns the symbol that implicitly defined this symbol, or Nothing if this\r\n symbol was declared explicitly. Examples of implicit symbols are property\r\n accessors and the backing field for an automatically implemented property.\r\n \r\n NOTE: there are scenarios in which ImplicitlyDefinedBy is called while bound members \r\n       are not yet published. This typically happens if ImplicitlyDefinedBy while binding members.\r\n       In such case, if callee needs to refer to a member of enclosing type it must \r\n       do that in the context of unpublished members that caller provides \r\n       (asking encompassing type for members will cause infinite recursion).\r\n \r\n NOTE: There could be several threads trying to bind and publish members, only one will succeed.\r\n       Reporting ImplicitlyDefinedBy within the set of members known to the caller guarantees\r\n       that if particular thread succeeds it will not have information that refers to something\r\n       built by another thread and discarded.\r\n ":"\r\n 返回隐式定义此符号的符号，或者没有\r\n 明确声明符号。隐式符号的示例是属性\r\n 自动实现属性的登录和背景字段。\r\n \r\n 注意：在某些情况下，在绑定成员时调用了隐式定义\r\n       尚未出版。如果在绑定成员时，则通常会发生这种情况。\r\n       在这种情况下，如果Callee需要参考封闭类型的成员，则必须\r\n       在呼叫者提供的未出版成员的背景下这样做\r\n       （要求成员的包含类型会导致无限递归）。\r\n \r\n 注意：可能有几个线程试图绑定和发布成员，只有一个将成功。\r\n       报告在呼叫者担保已知的成员集中的隐式性定义\r\n       如果特定线程成功，它将没有指称某事的信息\r\n       由另一个线程构建并丢弃。\r\n \r\n","from clause":"从条款\r\n","This grouping construct captures a matched 'subexpression', where 'subexpression' is any valid regular expression pattern. Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regu ...":"该分组构造捕获了匹配的“子表达”，其中“亚表达”是任何有效的正则表达模式。捕获使用括号的捕获根据regu的开头括号的顺序自动从左到右编号...\r\n","\r\n Returns the System.String that represents the current TypedConstant.\r\n ":"\r\n 返回代表当前键入的系统。\r\n \r\n","file-scoped namespace":"文件划分的名称空间\r\n","\r\n            Arguments given to the script.\r\n            ":"\r\n            给出脚本的论点。\r\n            \r\n","\r\n The value for the Checksum property.\r\n ":"\r\n 校验和属性的值。\r\n \r\n","\r\n Creates a remarks element within an xml documentation comment.\r\n ":"\r\n 在XML文档注释中创建备注元素。\r\n \r\n","into new overload":"进入新的过载\r\n","\r\n In NetFx 4.0, block array initializers do not work on all combinations of {32/64 X Debug/Retail} when array elements are enums.\r\n This is fixed in 4.5 thus enabling block array initialization for a very common case.\r\n We look for the presence of ":"\r\n 在NetFX 4.0中，当数组元素是枚举时，块数组初始化器不适用于{32/64 x调试/零售}的所有组合。\r\n 这是在4.5中固定的，因此可以为一个非常常见的情况启用块数组初始化。\r\n 我们寻找存在\r\n","\r\n            Individual smaller text changes that are more fine grained than the total ":"\r\n            单个较小的文本更改比总数更细粒度\r\n","Generate read-only property '{1}.{0}'":"生成仅读取属性'{1}。{0}'\r\n","\r\n Is this In parameter (metadata flag Out is set).\r\n ":"\r\n 这是参数（设置元数据标志）。\r\n \r\n","\r\n Represents a .NET assembly. An assembly consists of one or more modules.\r\n ":"\r\n 表示.NET组件。一个组件由一个或多个模块组成。\r\n \r\n",".\r\n            This can be class, struct, interface, record or enum declaration.\r\n            ":"。\r\n            这可以是类，结构，接口，记录或枚举声明。\r\n            \r\n","\r\n            This method goes through all the invocation sites and adds a new argument with the expression to be added.\r\n            It also introduces a parameter at the original method site.\r\n            \r\n            Example:\r\n            public void M(int x, int y)\r\n            {\r\n                int f = [|x * y|];\r\n            }\r\n            \r\n            public void InvokeMethod()\r\n            {\r\n                M(5, 6);\r\n            }\r\n            \r\n            ---------------------------------------------------->\r\n            \r\n            public void M(int x, int y, int f) // parameter gets introduced\r\n            {\r\n            }\r\n            \r\n            public void InvokeMethod()\r\n            {\r\n                M(5, 6, 5 * 6); // argument gets added to callsite\r\n            }\r\n            ":"\r\n            该方法遍历所有调用站点，并添加了一个新参数，并添加了要添加的表达式。\r\n            它还在原始方法网站上引入了一个参数。\r\n            \r\n            例子：\r\n            公共空白M（int x，int y）\r\n            {\r\n                int f = [| x * y |];\r\n            }\r\n            \r\n            公共无效InvokeMethod（）\r\n            {\r\n                m（5，6）;\r\n            }\r\n            \r\n            ------------------------------------------------------------------------------------ - >\r\n            \r\n            公共void m（int x，int y，int f）//引入参数\r\n            {\r\n            }\r\n            \r\n            公共无效InvokeMethod（）\r\n            {\r\n                m（5，6，5 * 6）; //参数被添加到呼叫\r\n            }\r\n            \r\n","\r\n The value for the VarianceKeyword property.\r\n ":"\r\n VarianceKeyword属性的值。\r\n \r\n","\r\n Returns a copy of this with the UsingStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，使用usestatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Represents a simple type name with one or more generic arguments, such as \"X(Of\r\n Y, Z).\r\n ":"\r\n 代表一个或多个通用参数的简单类型名称，例如“ x（of）\r\n 是的，z）。\r\n \r\n","Remove Suppression":"去除抑制\r\n","\r\n Gets the standard Visual Basic script file extension.\r\n ":"\r\n 获取标准的Visual Basic脚本文件扩展名。\r\n \r\n","asynchronous using declaration":"使用声明异步\r\n","Use block body for constructors":"使用块主体作为构造函数\r\n","\r\n            Trims leading and trailing whitespace from ":"\r\n            带领和落后的修剪\r\n","True if forwardedToAssembly is non-null and the type indicated by typeSyntax/diagName is in a forwarder cycle.":"如果转发隔离为非零，则typeyntax/Diagname指示的类型在转发器周期中。\r\n","\r\n Returns a copy of this with the Initializers property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，初始化属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n  Looks up a localized string similar to Member '{0}' cannot override member '{1}' defined in another assembly/project because the access modifier 'Protected Friend' expands accessibility. Use 'Protected' instead..\r\n":"\r\n  查找类似于成员'{0}'的局部字符串，无法覆盖成员'{1}'在另一个汇编/项目中定义的，因为访问修饰符“受保护的朋友”扩展了可访问性。改用“受保护” ..\r\n\r\n"," \r\n This method validates attribute usage for each bound attribute and calls ":" \r\n 此方法验证了每个界属性的属性用法并调用\r\n","\r\n If this flag is set this method will be ignored \r\n in duplicated signature analysis, see ERR_DuplicateProcDef1 diagnostics.\r\n ":"\r\n 如果设置此标志，此方法将被忽略\r\n 在重复的签名分析中，请参见err_duplicateProcdef1诊断。\r\n \r\n"," returns true since the LINQ statement is not followed by an empty new line.\r\n ":" 返回为true，因为LINQ语句未遵循空的新线路。\r\n \r\n","The *? quantifier matches the preceding element zero or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier *":"这 *？量词匹配前面的元素零或更多次，但尽可能少次。这是贪婪量化器 *的懒惰对应物 *\r\n","<class name>":"<类名称>\r\n"," with all the\r\n            local declarations named '_' converted to simple assignments to discard.\r\n            For example, ":" 一切\r\n            名为“ _”的本地声明转换为简单分配以丢弃。\r\n            例如，\r\n","\r\n Options to control the internal working of GetSemanticInfoWorker. Not currently exposed\r\n to public clients, but could be if desired.\r\n ":"\r\n 控制GetSemanticinFoworker内部工作的选项。目前未暴露\r\n 给公共客户，但如果需要的话。\r\n \r\n","\r\n The method that declares this type parameter \r\n ":"\r\n 声明此类型参数的方法\r\n \r\n","backspace character":"backspace角色\r\n","\r\n            Gets the DisplayName for the given node\r\n            ":"\r\n            获取给定节点的显示名\r\n            \r\n"," field is intended to suppress any\r\n rewriter logic that would result in original locals being omitted.\r\n ":" 场旨在压制任何\r\n 重写逻辑将导致原始当地人被省略。\r\n \r\n","Use explicitly provided tuple name":"使用明确提供的元组名称\r\n","The default set of typed characters that cause the selected item to be committed.":"导致所选项目的默认字符集。\r\n","\r\n             Parameters map to variable declaration argument's name.\r\n             This is only used for C# to support the 'out' variable declaration. For VB it should always be empty.\r\n             Before:\r\n             void Caller()\r\n             {\r\n                 Callee(out var x);\r\n             }\r\n             void Callee(out int i) => i = 100;\r\n            \r\n             After:\r\n             void Caller()\r\n             {\r\n                 int x = 100;\r\n             }\r\n             void Callee(out int i) => i = 100;\r\n             ":"\r\n             参数映射到可变声明参数的名称。\r\n             这仅用于C＃来支持“ OUT”变量声明。对于VB，它应该始终为空。\r\n             前：\r\n             void caller（）\r\n             {\r\n                 callee（out var x）;\r\n             }\r\n             void callee（out int i）=> i = 100;\r\n            \r\n             后：\r\n             void caller（）\r\n             {\r\n                 int x = 100;\r\n             }\r\n             void callee（out int i）=> i = 100;\r\n             \r\n","\r\n The value for the Expression property.\r\n ":"\r\n 表达属性的值。\r\n \r\n","\r\n Gets the \"GetResult\" method.\r\n ":"\r\n 获取“ GetResult”方法。\r\n \r\n","\r\n Expand the span in the tree by the maximum number\r\n of tokens required for look ahead and the maximum\r\n number of characters for look behind.\r\n ":"\r\n 通过最大数字扩展树中的跨度\r\n 向前看所需的令牌和最大值\r\n 角色数量的数量。\r\n \r\n","\r\n A map of NoPia local types immediately contained in this assembly.\r\n Maps fully-qualified type name to the row id.\r\n ":"\r\n 该组件中立即包含的NOPIA本地类型地图。\r\n 映射到行ID完全合格的类型名称。\r\n \r\n","\r\n Returns True if this conversion a widening string conversion or a narrowing string conversion as defined in section\r\n 8.7.\r\n ":"\r\n 如果此转换为扩大的字符串转换或部分定义的缩小字符串转换，则返回tru\r\n 8.7。\r\n \r\n","\r\n            Used to supply the OOP server a callback that it can use to search for ReferenceAssemblies or\r\n            nuget packages.  We can't necessarily do that search directly in the OOP server as our \r\n            'SymbolSearchEngine' may actually be running in a *different* process (there is no guarantee\r\n            that all remote work happens in the same process).  \r\n            \r\n            This does mean, currently, that when we call over to OOP to do a search, it will bounce\r\n            back to VS, which will then bounce back out to OOP to perform the Nuget/ReferenceAssembly\r\n            portion of the search.  Ideally we could keep this all OOP.\r\n            ":"\r\n            用于向OOP服务器提供一个回调\r\n            Nuget软件包。我们不一定会直接在OOP服务器中进行该搜索\r\n            “符号搜索”实际上可能在 *不同的 *过程中运行（没有保证\r\n            所有远程工作都在同一过程中发生）。\r\n            \r\n            这确实意味着目前，当我们打电话给OOP进行搜索时，它将反弹\r\n            返回VS，然后将反弹回到OOP以执行Nuget/referenceSeSembly\r\n            搜索的一部分。理想情况下，我们可以将所有OOP保留下来。\r\n            \r\n","\r\n Visit a node, process \r\n ":"\r\n 访问节点，过程\r\n \r\n","\r\n The state associated with a label includes the statement itself, the local state and the nesting.\r\n ":"\r\n 与标签关联的状态包括语句本身，本地状态和嵌套。\r\n \r\n","\r\n  Looks up a localized string similar to Type argument '{0}' does not inherit from or implement the constraint type '{1}'..\r\n":"\r\n  查找类似于类型参数'{0}'的本地化字符串不会从或实现约束类型'{1}'..\r\n\r\n","\r\n The \"Inherits\" keyword.\r\n ":"\r\n “继承”关键字。\r\n \r\n","\r\n            Returns the index right after the last slash that precedes 'position'.  If there is no\r\n            slash in the string, -1 is returned.\r\n            ":"\r\n            在“位置”之前的最后一个斜线之后返回索引。如果没有\r\n            字符串中的斜杠，-1返回。\r\n            \r\n"," is passed in.\r\n            ":" 被传递。\r\n            \r\n","\r\n            cannot find implementation of query pattern\r\n            ":"\r\n            找不到查询模式的实现\r\n            \r\n","\r\n             every predefined type keyword except ":"\r\n             每个预定义的类型关键字除外\r\n","\r\n Create a missing contextual keyword.\r\n ":"\r\n 创建缺少的上下文关键字。\r\n \r\n","\r\n The UsingStatement that begins the Using...End Using block.\r\n ":"\r\n 开始使用块的使用statement。\r\n \r\n","The document that completion is occurring within.":"内部完成的文件。\r\n","\r\n Get a summary of the bound nodes associated with a particular syntax nodes,\r\n and its parent. This is what the rest of the semantic model uses to determine\r\n what to return back.\r\n ":"\r\n 获取与特定语法节点相关的结合节点的摘要，\r\n 和它的父母。这就是其余的语义模型来确定的方法\r\n 什么要返回。\r\n \r\n","\r\n May introduce a temp which it will return. (otherwise returns null)\r\n ":"\r\n 可能会引入将返回的温度。 （否则返回null）\r\n \r\n","\r\n            Full path to the physical assembly file (might be a shadow-copy of the original assembly file).\r\n            ":"\r\n            物理组装文件的完整路径（可能是原始组装文件的阴影副本）。\r\n            \r\n","Array of symbols that include VBC_VER and TARGET.":"包括vbc_ver和target的符号数组。\r\n","\r\n            Determines whether the given SyntaxToken is the first token on a line in the specified SourceText.\r\n            ":"\r\n            确定给定的Santaxtkoken是否是指定源版中的行上的第一个令牌。\r\n            \r\n","\r\n  Looks up a localized string similar to The RequiredAttribute attribute is not permitted on Visual Basic types..\r\n":"\r\n  在视觉基本类型上不允许查找类似于必需的属性属性的本地化字符串。\r\n\r\n","\r\n            Indicates whether a \"TODO\" should be introduced at callsites\r\n            to cause errors that the user can then go visit and fix up.\r\n            ":"\r\n            指示是否应在呼叫仪上引入“待办事项”\r\n            为了引起错误，用户可以访问并修复。\r\n            \r\n","\r\n The \"Sub\" or \"Function\" statement that begins the block.\r\n ":"\r\n 开始块的“ sub”或“函数”语句。\r\n \r\n","\r\n Returns a copy of this with the Types property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，类型属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n            Unwraps first item.  Subsequent items, if wrapped, will be indented:\r\n                 MethodName(int a, int b, int c, int d, int e,\r\n                     int f, int g, int h, int i, int j)\r\n            ":"\r\n            拆开第一项。随后的项目（如果包装）将被缩进：\r\n                 methotName（int a，int b，int c，int d，int e，\r\n                     int f，int g，int h，int i，int j）\r\n            \r\n","\r\n  Looks up a localized string similar to Variables in Modules cannot be declared '{0}'..\r\n":"\r\n  查找类似于模块中变量的本地化字符串，无法声明'{0}'..\r\n\r\n","\r\n            A piece of text with a descriptive tag.\r\n            ":"\r\n            带有描述性标签的文本。\r\n            \r\n","Error while reading file '{0}': {1}":"读取文件'{0}'时错误：{1}\r\n"," in original code has overload resolution failures.\r\n            ":" 在原始代码中具有超载分辨率故障。\r\n            \r\n","\r\n Returns a string representation of an object of primitive type.\r\n ":"\r\n 返回原始类型对象的字符串表示。\r\n \r\n","\r\n Returns a copy of this with the OpenBraceToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中openbraceToken属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            If the token is the '=>' in a lambda, or the 'delegate' in an anonymous function,\r\n            return the syntax for the lambda or anonymous function.\r\n            ":"\r\n            如果令牌是lambda中的'=>'，或者是匿名函数中的“委托”，\r\n            返回lambda或匿名函数的语法。\r\n            \r\n"," - it's up to the individual\r\n            subtype.\r\n            ":"  - 取决于个人\r\n            亚型。\r\n            \r\n","\r\n Module's ordinal within containing assembly's Modules array.\r\n 0 - for a source module, etc.\r\n -1 - for a module that doesn't have containing assembly, or has it, but is not part of Modules array. \r\n ":"\r\n 包含组件模块阵列中的模块的序数。\r\n 0-对于源模块，等。\r\n -1-对于没有包含汇编的模块，或没有包含的模块，但不是模块数组的一部分。\r\n \r\n","\r\n  Looks up a localized string similar to Parameter already declared with name '{0}'..\r\n":"\r\n  查找类似于已经声明的参数类似的本地化字符串，名称为“ {0}”。\r\n\r\n","\r\n            document this result is based on\r\n            ":"\r\n            记录此结果是基于\r\n            \r\n","\r\n RetargetingAssemblySymbol owning retargeting module.\r\n ":"\r\n retargetingAssemblysymbol拥有重新定位模块。\r\n \r\n","Changes made in project '{0}' require restarting the application: {1}":"项目“ {0}”中所做的更改需要重新启动应用程序：{1}\r\n","\r\n Returns a copy of this with the ArgumentTypes property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 将其返回其中的副本，其中参数类型属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Syntax for optional as clause. Can be nothing if no type was supplied.":"可选为子句的语法。如果没有提供类型，则无能为力。\r\n","\r\n Helper visitor to determine what join sides are referenced by an expression.\r\n ":"\r\n 助手访问者确定表达式引用哪个联接侧。\r\n \r\n",", looking for particular\r\n            forms that VS or ReSharper generate to hash fields in the containing type.\r\n            ":"，寻找特定的\r\n            与包含类型中的哈希字段生成的形式或重音器会生成。\r\n            \r\n","atomic group":"原子群\r\n"," needs. This\r\n            provide an easy entry point for swapping out functionality of the host, including for testing purposes.\r\n            ":" 需要。这个\r\n            提供一个简单的切入点来交换主机的功能，包括用于测试目的。\r\n            \r\n","\r\n            ```(?:expr)``` node.\r\n            ":"\r\n            ``（？：expr）````node''。\r\n            \r\n","Type parameter '{0}' is hidden by another type parameter '{1}'.":"类型参数'{0}'由其他类型参数'{1}'隐藏。\r\n"," caches results so that binders are efficiently reused between queries.\r\n ":" 缓存结果，使粘合剂在查询之间有效重复。\r\n \r\n","<range variable>":"<范围变量>\r\n","\r\n Represents a comment.\r\n ":"\r\n 代表评论。\r\n \r\n","The name '{0}' does not exist in the current context.":"名称'{0}'在当前上下文中不存在。\r\n","\r\n            Provides basic REPL functionality.\r\n            ":"\r\n            提供基本的重复功能。\r\n            \r\n","\r\n Get all the members of this symbol that have a particular name.\r\n ":"\r\n 获取具有特定名称的此符号的所有成员。\r\n \r\n","\r\n            The portion of the user string token after to the section we're replacing.  Used for building the\r\n            example format to present.\r\n            ":"\r\n            在我们要替换的部分之后，用户字符串令牌的部分。用于构建\r\n            示例格式要出现。\r\n            \r\n","\r\n If the Kind is ExtendKind.Module, returns the module symbol that this namespace\r\n encompasses. Otherwise throws InvalidOperationException.\r\n ":"\r\n 如果类型是ExtendKind.module，请返回此名称空间的模块符号\r\n 包含。否则会引发无效的exception。\r\n \r\n","\r\n Creates a summary element within an xml documentation comment.\r\n ":"\r\n 在XML文档注释中创建摘要元素。\r\n \r\n","\r\n Knows how to bind FunctionAggregationSyntax and GroupAggregationSyntax\r\n within particular [Into] clause. \r\n \r\n Also implements Lookup/LookupNames methods to make sure that lookup without \r\n container type, uses type of the group as the container type.\r\n ":"\r\n 知道如何绑定functionAggregationsyntax和groupAggregationsyntax\r\n 在特定的[TOS]子句中。\r\n \r\n 还实现查找/查找名称方法，以确保无需查找\r\n 容器类型，将组的类型用作容器类型。\r\n \r\n","Project":"项目\r\n","\r\n Infer type of the group for a Group By operator from the set of available GroupBy methods.\r\n \r\n In short, given already bound itemsLambda and keysLambda, this method performs overload\r\n resolution over the set of available GroupBy operator methods using fake Into lambda:\r\n     Function(key, group As typeToBeInferred) New With {group}\r\n \r\n If resolution succeeds, the type inferred for the best candidate is our result.  \r\n ":"\r\n 从可用组方法集中推出操作员的组类型。\r\n \r\n 简而言之，给定的已经绑定的项目lambda和keyslambda，此方法执行超载\r\n 使用假货中的一组可用组运算符方法的分辨率：\r\n     函数（键，组为TypeTobeInferred），{group}\r\n \r\n 如果解决方案成功，那么最佳候选人推断的类型是我们的结果。\r\n \r\n","\r\n            Grouped by file name and updates in each group are ordered by ":"\r\n            按文件名和每个组中的更新分组\r\n","\r\n Add { prefix, namespace } pairs from the explicitly declared namespaces in the\r\n XmlElement hierarchy. The order of the pairs is the order the xmlns attributes\r\n are declared on each element, and from innermost to outermost element.\r\n ":"\r\n 添加{前缀，命名空间}对从“明确声明的名称空间”配对\r\n XMlelement层次结构。对的顺序是XMLNS属性的顺序\r\n 在每个元素上声明，从最内向到最外面的元素。\r\n \r\n","\r\n            Recent entries are captured in a memory dump.\r\n            If DEBUG is defined, all entries written to ":"\r\n            最近的条目在内存转储中捕获。\r\n            如果定义调试，所有条目都写信给\r\n","The new bound block containing the assignment of the initialization and the try/finally statement with\r\n the passed body.":"包含初始化分配的新结合块，并带有Try/fine语句\r\n 通过的身体。\r\n","\r\n Given a enum block, get the corresponding type symbol.\r\n ":"\r\n 给定枚举块，获取相应的类型符号。\r\n \r\n","Whether to use elastic trivia or not":"是否使用弹性琐事\r\n","\r\n Bind a built in type name to the correct type symbol.\r\n ":"\r\n 将内置的类型名称绑定到正确的类型符号。\r\n \r\n","A bound sequence for the object creation expression containing the invocation expressions.":"包含调用表达式的对象创建表达式的绑定序列。\r\n","\r\n            Specifies whether or not optimizations should be performed on the output IL.\r\n            ":"\r\n            指定是否应在输出IL上进行优化。\r\n            \r\n","\r\n The value for the TypeParameterList property.\r\n ":"\r\n TypeparameterList属性的值。\r\n \r\n","\r\n            return type\r\n            ":"\r\n            返回类型\r\n            \r\n",".\r\n Based on the context, qualify type And member names as little as possible without\r\n introducing ambiguities.\r\n ":"。\r\n 基于上下文，限定类型和成员名称，而没有\r\n 引入歧义。\r\n \r\n","\r\n NamedTypeSymbol calls derived implementations of this method when acyclic base interfaces\r\n are needed for the first time.\r\n This method typically calls GetDeclaredInterfaces, filters for \r\n illegal cycles and other conditions before returning result as acyclic.\r\n ":"\r\n 无环碱接口时命名typeymbol调用该方法的实现\r\n 第一次需要。\r\n 此方法通常调用GetDeclaredInterfaces，过滤器\r\n 在返回结果之前，非法周期和其他条件为无环。\r\n \r\n","\r\n            Current data that matches the version\r\n            ":"\r\n            与版本匹配的当前数据\r\n            \r\n","\r\n Advances to given position if needed (note: no way back)\r\n Gets a nonterminal that can be used for incremental.\r\n May return Nothing if such node is not available.\r\n Typically it is _currentNode.\r\n ":"\r\n 如果需要的话，可以给定位置的进步（注意：没有办法）\r\n 获取可用于增量的非末端。\r\n 如果没有此类节点，则可能不会返回。\r\n 通常是_currentNode。\r\n \r\n"," in memory.\r\n            ":" 在记忆中。\r\n            \r\n","\r\n An \"Else\" clause to be executed if the condition expression evaluates as false.\r\n ":"\r\n 如果条件表达式评估为false，则将执行的“ else”子句。\r\n \r\n","\r\n Represents an string literal token.\r\n ":"\r\n 代表字符串文字令牌。\r\n \r\n"," Creates a token with kind StringLiteralToken from the text and corresponding string value. ":" 从文本和相应的字符串值中创建一个用and StringLiteralToken创建令牌。\r\n","\r\n Represents a range argument, such as \"0 to 5\", used in array bounds. The\r\n \"Value\" property represents the upper bound of the range.\r\n ":"\r\n 代表范围参数，例如在数组范围中使用的“ 0至5”。这\r\n “值”属性表示范围的上限。\r\n \r\n","\r\n  Looks up a localized string similar to Alias '{0}' is already declared..\r\n":"\r\n  查找类似于别名'{0}'的本地化字符串。\r\n\r\n","\r\n Returns PEModuleSymbol containing the namespace.\r\n ":"\r\n 返回包含名称空间的Pemodulesymbol。\r\n \r\n","\r\n If present, a Handles clause indicated the events that this method handles.\r\n ":"\r\n 如果存在，则处理子句指示此方法处理的事件。\r\n \r\n","\r\n Returns True if resolution of user defined conversions is complete, i.e. there were operators\r\n applicable for the \"Most Specific Widening Conversion\" purposes. \r\n This, however, doesn't mean that resolution is successful.\r\n ":"\r\n 如果完成用户定义的转换的分辨率完成，则返回为真，即有操作员\r\n 适用于“最特定的扩大转换”目的。\r\n 但是，这并不意味着解决方案是成功的。\r\n \r\n","\r\n The \"Delegate\" keyword.\r\n ":"\r\n “委托”关键字。\r\n \r\n","\r\n Bind any xmlns declaration attributes and return the bound nodes plus a Dictionary\r\n of { prefix, namespace } pairs that will be used for namespace lookup at and below\r\n the containing XmlElement. Any xmlns declarations that are redundant with Imports\r\n in scope (same prefix and namespace) are dropped, and instead, an entry is added\r\n to the 'importedNamespaces' collection. When the root XmlElement is generated,\r\n xmlns attributes will be added for all entries in importedNamespaces. Any attributes\r\n other than xmlns are added to the 'otherAttributes' collection for binding by the caller.\r\n ":"\r\n 绑定任何XMLN声明属性，然后返回绑定节点以及字典\r\n {前缀，名称空间}对，将用于命名空间查找和下方\r\n 包含Xmlelement。任何随着进口的多余的XMLN声明\r\n 在范围（同一前缀和名称空间）中被删除，而是添加了一个条目\r\n 到“导入的namespaces”集合。生成根Xmlelemt时，\r\n XMLNS属性将为导入的Namespaces中的所有条目添加。任何属性\r\n 除了XMLN以外，添加到“其他Attributes”集合中以绑定呼叫者。\r\n \r\n","The {n,} quantifier matches the preceding element at least n times, where n is any integer. {n,} is a greedy quantifier whose lazy equivalent is {n,}?":"{n，}量词至少匹配前面的元素，其中n是任何整数。 {n，}是一个贪婪的量词，其懒惰的等效物是{n，}？\r\n","NS1.NS2":"NS1.NS2\r\n","\r\n Walk a custom attribute argument bound node and return a TypedConstant.  Verify that the expression is a constant expression.\r\n ":"\r\n 行走自定义属性参数绑定节点并返回键入constant。验证表达是恒定表达式。\r\n \r\n"," could be replaced by ThrowExpression.\r\n            For VB it always return false because ThrowExpression doesn't exist.\r\n            ":" 可以用抛出表达代替。\r\n            对于VB，它总是返回false，因为投掷表达不存在。\r\n            \r\n"," is an optional\r\n            subset of the documents from ":" 是可选的\r\n            文档的子集\r\n","\r\n  Looks up a localized string similar to Interface members must be methods, properties, events, or type definitions..\r\n":"\r\n  查找类似于接口成员的本地化字符串必须是方法，属性，事件或类型定义。\r\n\r\n","Delegates":"代表\r\n"," and then have the host editor navigate to that\r\n            ":" 然后让主机编辑导航到\r\n            \r\n","\r\n  Looks up a localized string similar to An aggregate collection initializer entry must contain at least one element..\r\n":"\r\n  查找类似于汇总集合初始化器条目类似的本地化字符串必须包含至少一个元素。\r\n\r\n","Autoselect disabled due to potential lambda declaration.":"由于潜在的Lambda声明，自动选择残疾。\r\n","\r\n Return compiler generated nested types that are created at Declare phase, but not exposed through GetMembers and the like APIs.\r\n Should return Nothing if there are no such types.\r\n ":"\r\n 返回编译器生成的嵌套类型是在声明阶段创建的，但不会通过getembers和类似的API暴露。\r\n 如果没有这样的类型，则不应返回。\r\n \r\n","Related method signatures found in metadata will not be updated.":"元数据中发现的相关方法签名将不会更新。\r\n","\r\n            Returns variables defined by the scripts in the declaration order.\r\n            ":"\r\n            返回声明顺序中脚本定义的变量。\r\n            \r\n","\r\n            Lightweight analog to ":"\r\n            轻巧的类似物\r\n","\r\n Initialize the state machine class.\r\n ":"\r\n 初始化状态计算机类。\r\n \r\n","\r\n  Looks up a localized string similar to cannot specify both /win32icon and /win32resource.\r\n":"\r\n  查找类似于不能指定 /win32icon和 /win32Resource的本地化字符串。\r\n\r\n","\r\n  Looks up a localized string similar to Attribute '{0}' given in a source file conflicts with option '{1}'..\r\n":"\r\n  查找与源文件中给出的属性'{0}'相似的本地化字符串与选项'{1}'..\r\n\r\n"," \r\n Map of 'MyBase' or 'MyClass' call wrappers; actually each method symbol will \r\n only need one wrapper to call it non-virtually; \r\n \r\n Indeed, if the type have a virtual method M1 overridden, MyBase.M1 will use \r\n a wrapper for base type's method and MyClass.M1 a wrapper for this type's method.\r\n \r\n And if the type does not override a virtual method M1, both MyBase.M1 \r\n and MyClass.M1 will use a wrapper for base type's method.\r\n ":" \r\n “ mybase”或“ myclass”呼叫包装纸的地图；实际上每个方法符号都会\r\n 只需要一个包装器即可非虚拟地称其为非；\r\n \r\n 确实，如果类型具有虚拟方法M1覆盖，mybase.m1将使用\r\n 基本类型方法和myClass.m1的包装器。\r\n \r\n 如果类型不覆盖虚拟方法M1，则Mybase.m1\r\n MyClass.m1将使用包装器用于基本类型的方法。\r\n \r\n","\r\n  Looks up a localized string similar to Type arguments are not valid because attributes cannot be generic..\r\n":"\r\n  查找类似于类型参数的本地化字符串是无效的，因为属性不能通用。\r\n\r\n","\r\n Indicates that this symbol uses metadata that cannot be supported by the language.\r\n \r\n Examples include:\r\n    - Pointer types in VB\r\n    - ByRef return type\r\n    - Required custom modifiers\r\n    \r\n This is distinguished from, for example, references to metadata symbols defined in assemblies that weren't referenced.\r\n Symbols where this returns true can never be used successfully, and thus should never appear in any IDE feature.\r\n \r\n This is set for metadata symbols, as follows:\r\n Type - if a type is unsupported (e.g., a pointer type, etc.)\r\n Method - parameter or return type is unsupported\r\n Field - type is unsupported\r\n Event - type is unsupported\r\n Property - type is unsupported\r\n Parameter - type is unsupported\r\n ":"\r\n 表示此符号使用该语言无法支持的元数据。\r\n \r\n 示例包括：\r\n     -  VB中的指针类型\r\n     -  BYREF返回类型\r\n     - 必需的自定义修饰符\r\n    \r\n 这与例如未引用的组件中定义的元数据符号的引用相比，有所区别。\r\n 返回true的符号永远无法成功使用，因此绝不应该出现在任何IDE功能中。\r\n \r\n 这是为元数据符号设置的，如下：\r\n 类型 - 如果不支持类型（例如，指针类型等）\r\n 方法 - 不支持参数或返回类型\r\n 字段 - 类型不支持\r\n 事件 - 类型不支持\r\n 属性 - 类型不支持\r\n 参数 - 类型不支持\r\n \r\n","\r\n  Looks up a localized string similar to 'Catch' cannot appear outside a 'Try' statement..\r\n":"\r\n  查找类似于“捕获”的本地化字符串，不能出现在“尝试”语句之外。\r\n\r\n","\r\n            Returns true when the input position could be starting an interpolation expression if a curly brace was typed.\r\n            ":"\r\n            如果输入位置可以启动插值表达式，则返回true。\r\n            \r\n","\r\n  Looks up a localized string similar to Statement is not valid inside a method..\r\n":"\r\n  查找类似于语句的本地化字符串在方法中无效。\r\n\r\n","\r\n            Checks that the token at the closing position is a valid closing token.\r\n            ":"\r\n            检查关闭位置的令牌是否是有效的闭合令牌。\r\n            \r\n"," gives users a way to generate constructors for an existing\r\n            type when a user tries to 'new' up an instance of that type with a set of parameter that does\r\n            not match any existing constructor.  i.e. it is the equivalent of 'Generate-Method' but for\r\n            constructors.  Parameters for the constructor will be picked in a manner similar to Generate-\r\n            Method.  However, this type will also attempt to hook up those parameters to existing fields\r\n            and properties, or pass them to a this/base constructor if available.\r\n            \r\n            Importantly, this type is not responsible for generating constructors for a type based on \r\n            the user selecting some fields/properties of that type.  Nor is it responsible for generating\r\n            derived class constructors for all unmatched base class constructors in a type hierarchy.\r\n            ":" 为用户提供一种为现有的生成构造函数的方法\r\n            当用户尝试使用一组参数的实例“ new”实例时键入\r\n            不匹配任何现有的构造函数。即，它等同于“生成方法”，但\r\n            构造函数。构造函数的参数将以类似于生成的方式选择\r\n            方法。但是，这种类型还将尝试将这些参数连接到现有字段\r\n            和属性，或将它们传递到此/基本构造函数（如果有）。\r\n            \r\n            重要的是，这种类型不负责基于\r\n            用户选择该类型的某些字段/属性。它也不负责生成\r\n            类型层次结构中所有无与伦比的基类构造函数的派生类构造函数。\r\n            \r\n","<omit>":"<mit>\r\n","\r\n Returns interface methods explicitly implemented by this method.\r\n ":"\r\n 返回该方法明确实现的接口方法。\r\n \r\n","\r\n            Specified if the edit needs to be merged with other edits of the same ":"\r\n            指定是否需要将编辑与其他相同的其他编辑合并\r\n"," All of the labels seen so far in this forward scan of the body ":" 到目前为止在身体的前扫描中看到的所有标签\r\n","Can't assign '{0}' to '{1}'.":"无法分配'{0}'到'{1}'。\r\n","const field":"const字段\r\n"," will both return false.\r\n ":" 都将返回false。\r\n \r\n","\r\n Gets the current DiagnosticFormatter instance.\r\n ":"\r\n 获取当前的诊断图形实例。\r\n \r\n"," (e.g. fails for shared methods).\r\n ":" （例如，共享方法失败）。\r\n \r\n"," representing the specific kind of\r\n DelegateStatementSyntax. One of DelegateSubStatement,\r\n DelegateFunctionStatement.\r\n ":" 代表特定种类\r\n 授权statementsyntax。委托词之一，\r\n 委托函数。\r\n \r\n","\r\n Represents a named type symbol whose members are declared in source.\r\n ":"\r\n 代表一个命名类型符号，其成员在源中声明。\r\n \r\n","\r\n                int i = 5;\r\n                i.          // -- here\r\n                List ml = new List();\r\n            ":"\r\n                int i = 5;\r\n                一世。 //  -  这里\r\n                列表ML =新列表（）;\r\n            \r\n"," is expected to be an absolute path of a file that does not yet exist.\r\n            ":" 预计将是尚不存在的文件的绝对路径。\r\n            \r\n","\r\n  Looks up a localized string similar to Constructor must be declared as a Sub, not as a Function..\r\n":"\r\n  查找类似于构造函数的本地化字符串必须被声明为子，而不是函数。\r\n\r\n","\r\n Marks property as definitely IsWithEvents or not.\r\n The effects of this change cannot be undone.\r\n Will have no effect if someone already asked if property is IsWithEvents (and will assert since it is not supposed to happen).\r\n ":"\r\n 将属性标记为绝对是ISWITHEVENTS。\r\n 这种变化的效果无法撤销。\r\n 如果有人已经询问财产是否为ISWITHEVENTS（并且因为不应该发生，并且会断言）。\r\n \r\n","The placeholder for the collection expression.":"收集表达的占位符。\r\n","character class subtraction":"字符类减法\r\n","\r\n Returns true if the node is the operand of an AddressOf expression, or the object\r\n of an invocation. This is used for special binding rules around the return value variable \r\n inside Functions and Property Get accessors.\r\n ":"\r\n 如果节点是地址表达式的操作数或对象，则返回true\r\n 调用。这用于围绕返回值变量的特殊绑定规则\r\n 内部功能和属性获取登录器。\r\n \r\n","\r\n Produce a duplicate of this flow analysis state.\r\n ":"\r\n 产生该流量分析状态的重复。\r\n \r\n","The root node to start comparisons from":"启动比较的根节点\r\n","\r\n  Looks up a localized string similar to 'AddHandler' definition missing for event '{0}'..\r\n":"\r\n  查找类似于事件'{0}'的“ Addhandler”定义类似的本地化字符串。\r\n\r\n","\r\n  Looks up a localized string similar to '{0}' cannot be inherited more than once..\r\n":"\r\n  查找类似于'{0}'的本地化字符串不能多次继承。\r\n\r\n","\r\n  Looks up a localized string similar to Attribute parameter '{0}' or '{1}' must be specified..\r\n":"\r\n  必须指定类似于属性参数'{0}'或'{1}'的本地化字符串。\r\n\r\n","\r\n Given a syntax node of query clause returns its leading keyword\r\n ":"\r\n 给定查询子句的语法节点返回其领先的关键字\r\n \r\n","\r\n            Unknown reference type\r\n            ":"\r\n            未知参考类型\r\n            \r\n","Local function is declared but never used":"声明本地功能，但从未使用\r\n","\r\n Force all declaration errors to be generated.\r\n ":"\r\n 强制所有声明错误要产生。\r\n \r\n","\r\n            Returns a span that contains all possible breakpoint spans of top-level ":"\r\n            返回一个包含所有可能的断点跨度的跨度\r\n","target-typed conditional expression":"目标型条件表达\r\n","A collection of KeyValue pairs representing existing symbols.":"代表现有符号的钥匙值对集合。\r\n","\r\n Underlying ":"\r\n 潜在的\r\n","The location at which a file header was expected. This will typically be the\r\n            start of the first line after any directive trivia (":"预期文件头的位置。 这通常是\r\n            任何指令琐事后的第一行开始（\r\n","\r\n            Return all diagnostics for the given project stored in this state\r\n            ":"\r\n            返回存储在此状态的给定项目的所有诊断\r\n            \r\n","\r\n Get parse diagnostics for the entire compilation. This includes diagnostics from parsing BUT NOT from declarations and\r\n the bodies of methods or initializers. The set of parse diagnostics is cached, so calling this method a second time\r\n should be fast.\r\n ":"\r\n 获取整个汇编的解析诊断。这包括解析的诊断，但不包括声明和\r\n 方法或初始化器的身体。放牧诊断集被缓存，因此第二次称此方法\r\n 应该很快。\r\n \r\n","\r\n The value for the OrderKeyword property.\r\n ":"OrderKeyWord属性的值。\r\n \r\n","'{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support static abstract members in interfaces.":"'{0}'无法在类型'{2}'中实现接口成员'{1}'，因为目标运行时不支持接口中的静态抽象成员。\r\n","in {0} ({1} - {2})":"在{0}（{1}  -  {2}）中\r\n","\r\n If this is a generic method return TypeSubstitution for it. \r\n TypeSubstitution for containing type otherwise.\r\n ":"\r\n 如果这是一个通用方法返回类型固定体。\r\n 否则包含类型的类型。\r\n \r\n","\r\n Checks if a parameter is a ParamArray and reports this as an error.\r\n ":"\r\n 检查参数是否为paramarray，并将其报告为错误。\r\n \r\n","\r\n            Mapping from operator name to info about it.\r\n            ":"\r\n            从操作员名称映射到有关它的信息。\r\n            \r\n","\r\n            Searches for extension methods that match the name the user has written.  Returns\r\n            ":"\r\n            搜索与用户编写的名称匹配的扩展方法。返回\r\n            \r\n","\r\n            Searches the documents inside ":"\r\n            搜索里面的文档\r\n","\r\n The \"Sub\" or \"Function\" keyword that introduces this lambda expression.\r\n ":"\r\n 引入此lambda表达式的“ sub”或“函数”关键字。\r\n \r\n","\r\n Handles MyClass.Event1\r\n ":"\r\n 处理myClass.event1\r\n \r\n","\r\n An instance of TypeSubstitution describing substitution for containing type.\r\n ":"\r\n 典型固定的实例，描述了替代包含类型的替代。\r\n \r\n","\r\n            Find an `int MyType.Count` or `int MyType.Length` property.\r\n            ":"\r\n            找到一个`int mytype.count`或`int mytype.length“属性。\r\n            \r\n","\r\n            Creates a query expression.\r\n            ":"\r\n            创建一个查询表达式。\r\n            \r\n","Updating the library name of Declare statement requires restarting the application.":"更新声明语句的库名称需要重新启动该应用程序。\r\n","\r\n  Looks up a localized string similar to 'AddHandler' declaration must end with a matching 'End AddHandler'..\r\n":"\r\n  查找类似于“ Addhandler”声明的本地化字符串必须以匹配的“ End Addhandler”结尾。\r\n\r\n","\r\n Represents the end tag of an XML element of the form </element>.\r\n ":"\r\n 表示表单</element>的XML元素的结尾标签。\r\n \r\n","\r\n True if Option Explicit On is in effect. False if Option Explicit Off is in effect.\r\n Note that even if Option Explicit Off is in effect, there are places (field initializers)\r\n where implicit variable declaration is not permitted. See the ImplicitVariablesDeclarationAllowedHere\r\n property also.\r\n ":"\r\n 如果可以明确说明，则是正确的。错误，如果选项明确关闭。\r\n 请注意，即使脱离选项已生效，也有位置（字段初始化器）\r\n 如果不允许隐式变量声明。请参阅含义的含量\r\n 也是属性。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}{1}' is not valid because '{2}' is inside a scope that defines a variable that is used in a lambda or query expression..\r\n":"\r\n  查找类似于'{0} {1}'的本地化字符串是无效的，因为'{2}'在一个范围内定义了在lambda或Query表达式中使用的变量。\r\n\r\n","Expression tree cannot contain value of ref struct or restricted type '{0}'.":"表达树不能包含REF结构的值或限制类型'{0}'。\r\n","\r\n The second expression inside the parentheses.\r\n ":"\r\n 括号内的第二个表达式。\r\n \r\n","Returns the name of this symbol. Symbols without a name return the empty string;\r\n Nothing is never returned.":"返回此符号的名称。没有名称的符号返回空字符串；\r\n 什么都不会返回。\r\n","\r\n The underlying AssemblySymbol, cannot be an instance of RetargetingAssemblySymbol.\r\n ":"\r\n 基础组合符号不能是retargetingAssemblysymbol的一个实例。\r\n \r\n","unicode escape":"Unicode逃脱\r\n","Fix formatting":"修复格式\r\n","\r\n            In the case where we have leading whitespace in front of the first member and there are no imports, adding imports\r\n            moves that trivia to above the import (and sometimes removes it entirely if the import is later removed). \r\n            So, we want to cache the trivia before, delete it, then add it back in after the imports are added.\r\n            ":"\r\n            如果我们在第一个成员面前有领先的空格并且没有进口，则添加导入\r\n            将琐事移至高于导入的琐事（有时如果以后删除该导入，则将其完全删除）。\r\n            因此，我们想在删除琐事之前将其删除，然后在添加导入后将其添加回。\r\n            \r\n","\r\n Returns a copy of this with the [Property] property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，[属性]属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","A numbered backreference, where 'number' is the ordinal position of the capturing group in the regular expression. For example, \\4 matches the contents of the fourth capturing group.\r\n            \r\n            There is an ambiguity between octal escape codes (such as \\16) and \\numb ...":"编号的反向，其中“编号”是正则表达式中捕获组的序数位置。例如，\\ 4匹配第四个捕获组的内容。\r\n            \r\n            八分路逃生代码（例如\\ 16）和\\ numb ...之间存在歧义。\r\n","\r\n  Looks up a localized string similar to 'Using' must end with a matching 'End Using'..\r\n":"\r\n  查找类似于“使用”的本地化字符串，必须以匹配的“结束”结尾。\r\n\r\n","\r\n For each distinct label, the set of states that need to be dispatched to that label.\r\n Note that there is a dispatch occurring at every try-finally statement, so this\r\n variable takes on a new set of values inside each try block.\r\n ":"\r\n 对于每个不同的标签，需要派往该标签的一组状态。\r\n 请注意，每个试用语句都会发生一个调度，因此\r\n 变量在每个尝试块内部采用新的值集。\r\n \r\n","The lowered statement list for the while statement.":"While语句的降低语句列表。\r\n","\r\n             Finds and wraps 'chained' expressions.  For the purpose of this feature, a chained\r\n             expression is built out of 'chunks' where each chunk is of the form\r\n            \r\n             ":"\r\n             找到并包裹“链式”表达式。出于此功能的目的，链接\r\n             表达是由“块”建立的，每个块是形式的\r\n            \r\n             \r\n","The \"T\" standard format specifier represents a custom date and time format string that is defined by a specific culture's DateTimeFormatInfo.LongTimePattern property. For example, the custom format string for the invariant culture is \"HH:mm:ss\".":"“ t”标准格式指定符表示由特定文化的dateTimeFormatinfo.longtime.longtimepattern属性定义的自定义日期和时间格式字符串。例如，不变文化的自定义格式字符串是“ HH：MM：SS”。\r\n","\r\n A collection of the local variables for which a value assigned outside the region may be used inside the region.\r\n ":"\r\n 该区域内分配的值的局部变量集合可以在该区域内使用。\r\n \r\n","\r\n Find the first non-whitespace character in a given substring.\r\n ":"\r\n 在给定的子字符串中找到第一个非Whitespace字符。\r\n \r\n","\r\n Used to decide if we need to emit 'call' or 'callvirt' for structure method.\r\n It basically checks if the method overrides any other and method's defining type\r\n is not a 'special' or 'special-by-ref' type. \r\n ":"用于确定我们是否需要发出“呼叫”或“呼叫”来进行结构方法。\r\n 它基本上检查该方法是否覆盖了任何其他方法，并且方法的定义类型\r\n 不是“特殊”或“特殊划分”类型。\r\n \r\n","\r\n Gets a summary of the bound nodes associated with an underlying\r\n bound call node for a raiseevent statement.\r\n ":"\r\n 获取与基础相关的绑定节点的摘要\r\n 绑定呼叫节点的raiseevent语句。\r\n \r\n","\r\n            Calculates the distance between two syntax tokens, disregarding trivia. \r\n            ":"\r\n            计算两个语法令牌之间的距离，无视琐事。\r\n            \r\n","Suppression operator has no effect and can be misinterpreted":"抑制操作员无效，可能会被误解\r\n","\r\n            Information about an active and/or a matched lambda.\r\n            ":"\r\n            有关活动和/或匹配的lambda的信息。\r\n            \r\n","\r\n Create a missing character literal.\r\n ":"\r\n 创建一个缺失的字符字面意思。\r\n \r\n","'{0}' cannot be sealed because containing record is not sealed.":"'{0}'不能密封，因为包含记录没有密封。\r\n","\r\n            Attempts extracting a Node of type ":"\r\n            尝试提取类型节点\r\n","\r\n  Looks up a localized string similar to Type '{0}' cannot be used in an attribute because it is not declared 'Public'..\r\n":"\r\n  在属性中查找类似于“ {0}”类型的本地化字符串，因为它没有声明为“ public”。\r\n\r\n","The next binder.":"下一个活页夹。\r\n","\r\n            Contains enough information to determine whether two symbols have the same signature.\r\n            ":"\r\n            包含足够的信息来确定两个符号是否具有相同的签名。\r\n            \r\n","\r\n The value for the UsingKeyword property.\r\n ":"\r\n 使用keyword属性的值。\r\n \r\n","The script requires access to global variables but none were given":"脚本需要访问全局变量，但没有给出\r\n","\r\n Option Strict is On. All Option Strict checks are in effect and produce errors.\r\n ":"\r\n 选项严格即将开始。所有选项严格的检查都是有效的，并产生错误。\r\n \r\n","let clause":"令子句\r\n","Only methods with a single argument, which is not an out variable declaration, can be replaced with a property.":"只有具有单个参数的方法，不是一个不是变量声明的方法，才能被属性替换。\r\n","\r\n Find canonical type for NoPia embedded type.\r\n ":"\r\n 查找NOPIA嵌入式类型的规范类型。\r\n \r\n","\r\n This property should not be confused with general method overloading in Visual Basic, and is not directly related. \r\n This property will only return true if this method hides a base method by name and signature (Overloads keyword).\r\n ":"该属性不应与Visual Basic中的一般方法过载相混淆，也不应直接相关。\r\n 此属性只有在此方法通过名称和签名（Overloads关键字）隐藏基本方法时才能返回True。\r\n \r\n","\r\n Perform a first analysis pass in preparation for removing all lambdas from a method body.  The entry point is Analyze.\r\n The results of analysis are placed in the fields seenLambda, blockParent, variableBlock, captured, and captures.\r\n ":"\r\n 进行第一次分析通过，准备从方法主体中删除所有lambdas。分析入口点。\r\n 分析结果放置在SiewLambda，Blockparent，可变板，捕获和捕获的字段中。\r\n \r\n","Quantifier {x,y} following nothing":"量词{x，y}一无所获\r\n","\r\n The value for the TextTokens property.\r\n ":"\r\n TextTokens属性的值。\r\n \r\n","\r\n When binding \"C\" new C(...), return the constructor of C that was bound to, if C unambiguously\r\n binds to a single type with at least one constructor. \r\n ":"\r\n 当绑定“ C”新C（...）时，返回C的构造函数，如果C明确地绑定到C的构造函数\r\n 与至少一个构造函数的单一类型结合。\r\n \r\n","\r\n            This service provides a way to extract all the folders under a given project, or find the default namespace if it exists.\r\n            ":"\r\n            此服务提供了一种方法，可以提取给定项目下的所有文件夹，或者如果存在默认的名称空间。\r\n            \r\n","\r\n Return True if the statement can be bound by a Binder on its own.\r\n For example Catch statement cannot be bound on its own, only \r\n as part of Try block. Similarly, Next statement cannot be bound on its own,\r\n only as part of For statement.\r\n \r\n Only handles statements that are in executable code.\r\n ":"\r\n 如果陈述可以自行绑定，则返回true。\r\n 例如，捕获语句不能自行绑定\r\n 作为尝试块的一部分。同样，下一个声明不能自行绑定，\r\n 仅作为语句的一部分。\r\n \r\n 仅处理可执行代码中的语句。\r\n \r\n","\r\n            Method to compute well-known diagnostic property maps for different comnbinations of diagnostic properties.\r\n            The property map is added to each instance of the reported diagnostic and is used by the code fixer to\r\n            compute the correct code fix.\r\n            It currently maps to three different properties of the diagnostic:\r\n                1. The underlying ":"\r\n            计算众所周知的诊断属性图的方法，用于不同的诊断性能。\r\n            属性映射添加到报告诊断的每个实例中，并由代码修复程序使用\r\n            计算正确的代码修复。\r\n            目前，它将诊断的三个不同属性映射到：\r\n                1.基础\r\n","\r\n Owning RetargetingModuleSymbol.\r\n ":"\r\n 拥有retargetingModulesymbol。\r\n \r\n","Generate Equals and GetHashCode":"生成平等和gethashcode\r\n","Generate overrides...":"产生覆盖...\r\n","\r\n The value for the ArrayBounds property.\r\n ":"\r\n 阵列属性的值。\r\n \r\n","Make readonly fields writable":"使可读字段可写\r\n","punctuation, dash":"标点符号，破折号\r\n","\r\n            Given a position in a source file, returns the expressions in close proximity that should\r\n            show up in the debugger 'autos' window.  In general, the expressions we place into the autos\r\n            window are things that appear to be 'side effect free'.  Note: because we only use the syntax\r\n            tree for this, it's possible for us to get this wrong.  However, this should only happen in\r\n            code that behaves unexpectedly.  For example, we will assume that \"a + b\" is side effect free\r\n            (when in practice it may not be).  \r\n            \r\n            The general tactic we take is to add the expressions for the statements on the\r\n            line the debugger is currently at.  We will also try to find the 'previous' statement as well\r\n            to add the expressions from that.  The 'previous' statement is a bit of an interesting beast.\r\n            Consider, for example, if the user has just jumped out of a switch and is the statement\r\n            directly following it.  What is the previous statement?  Without keeping state, there's no way\r\n            to know.  So, in this case, we treat all 'exit points' (i.e. the last statement of a switch\r\n            section) of the switch statement as the 'previous statement'.  There are many cases like this\r\n            we need to handle.  Basically anything that might have nested statements/blocks might\r\n            contribute to the 'previous statement'\r\n            ":"\r\n            给定源文件中的位置，以近距离返回表达式\r\n            出现在调试器的“汽车”窗口中。通常，我们将表达式放入汽车中\r\n            窗口似乎是“无副作用”的东西。注意：因为我们只使用语法\r\n            为此，我们有可能弄错这个问题。但是，这只能发生在\r\n            表现出意外的代码。例如，我们将假设“ A + B”是无副作用的\r\n            （在实践中可能不是）。\r\n            \r\n            我们采取的一般策略是添加表达式\r\n            行调试器当前处于。我们还将尝试找到“以前的”陈述\r\n            从中添加表达式。 “以前的”陈述有点有趣。\r\n            例如，考虑用户刚刚跳出开关，并且是语句\r\n            直接关注它。以前的陈述是什么？没有保持状态，没有办法\r\n            知道。因此，在这种情况下，我们对待所有“退出点”（即开关的最后声明\r\n            Switch语句的部分为“以前的语句”。有很多这样的情况\r\n            我们需要处理。基本上任何可能具有嵌套语句/块的东西\r\n            为“以前的说法”做出贡献\r\n            \r\n"," if the text does not have a navigation\r\n            hint.\r\n            ":" 如果文本没有导航\r\n            暗示。\r\n            \r\n","\r\n            Base type of all C#/VB navigation bar items.  Only for use internally to roslyn.\r\n            ":"\r\n            所有C＃/VB导航栏项目的基本类型。仅用于罗斯林内部。\r\n            \r\n","\r\n Bind a list of type arguments to their types.\r\n ":"\r\n 将类型参数列表绑定到其类型。\r\n \r\n","Add optional parameters to '{0}'":"将可选参数添加到'{0}'\r\n","\r\n  Looks up a localized string similar to 'MyBase' must be followed by '.' and an identifier..\r\n":"\r\n  查找类似于“ mybase”的局部字符串，必须紧随其后”。和标识符..\r\n\r\n","\r\n            Represents a source-pattern constructed from C# patterns\r\n            ":"\r\n            代表由C＃模式构建的源模式\r\n            \r\n","Unexpected argument list.":"意外的参数列表。\r\n","'{0}' is not an interpolated string handler type.":"'{0}'不是插值字符串处理程序类型。\r\n","\r\n            Returns the topmost if statement for an else-if clause.\r\n            ":"\r\n            返回else-if子句的最高if语句。\r\n            \r\n"," to add the import.\r\n            ":" 添加导入。\r\n            \r\n","\r\n Represents an argument that is just an optional argument name and an expression.\r\n ":"\r\n 代表一个参数，只是一个可选的参数名称和一个表达式。\r\n \r\n","\r\n If the statement is a block the sequence point will be outside of the scope.\r\n ":"\r\n 如果语句是一个块，则序列点将在范围之外。\r\n \r\n"," for the specified document.\r\n            ":" 对于指定的文档。\r\n            \r\n","Extract local function":"提取本地功能\r\n","object that holds onto enough information to restore trivia later":"对象持有足够的信息以恢复琐事\r\n","\r\n The \"While\" or \"Until\" keyword.\r\n ":"\r\n “ while”或“直到”关键字。\r\n \r\n","separator, line":"分离器，线\r\n","\r\n Parse a compilation unit (a single source file).\r\n ":"\r\n 解析汇编单元（一个源文件）。\r\n \r\n","\r\n Base class for symbols representing constructed generic methods.\r\n For example: A(Of Integer), A.B(Of Integer), A(Of Integer).B.C(Of Integer).\r\n ":"\r\n 代表构造的通用方法的符号的基类。\r\n 例如：A（整数），A.B（整数），A（Integer）.b.c（整数）。\r\n \r\n","Provider of active statement spans tracked by the editor for the solution snapshot of the ":"主动语句的提供商跨越编辑器的解决方案快照\r\n","Reference to undefined group number {0}":"引用未定义的组号{0}\r\n","Use '--' operator":"使用' - '操作员\r\n","The symbols recommended in the active context.":"在活动环境中推荐的符号。\r\n","\r\n  Looks up a localized string similar to Delegate in an interface cannot be declared '{0}'..\r\n":"\r\n  查找类似于接口中类似委托的本地化字符串，无法声明'{0}'..\r\n\r\n","\r\n            Runs the script from the beginning and returns the result of the last code snippet.\r\n            ":"\r\n            从一开始就运行脚本并返回最后一个代码段的结果。\r\n            \r\n","\r\n Represents a \"Do Until\" statement that begins a \"Do ... Loop\" block.\r\n ":"\r\n 代表开始一个“ do do ... loop”块的“直到”语句。\r\n \r\n","\r\n The \"While expression\" or \"Until expression\" clause of the Loop statement, if\r\n present.\r\n ":"\r\n 循环语句的“表达”或“直到表达式”子句，如果\r\n 当下。\r\n \r\n","\r\n Synthesized ComClass interfaces, can have the following values:\r\n     Null - not yet initialized,\r\n     Empty - there are no synthesized ComClass interfaces.\r\n     one interface - only class interface is synthesized.\r\n     two interfaces - both class interface and event interface are synthesized. Class interface is followed by the event interface.\r\n ":"\r\n 合成的comclass接口，可以具有以下值：\r\n     null-尚未初始化，\r\n     空 - 没有合成的comclass接口。\r\n     一个接口 - 仅合成类界面。\r\n     两个接口 - 综合类接口和事件接口。类接口之后是事件接口。\r\n \r\n","\r\n The value for the FirstCommaToken property.\r\n ":"\r\n 第一概述属性的价值。\r\n \r\n","\r\n Returns documentation comment for a type, field, property, event or method, \r\n discards all the diagnostics\r\n ":"\r\n 返回类型，字段，属性，事件或方法的文档注释，\r\n 丢弃所有诊断\r\n \r\n","\r\n            Active statements by instruction id.\r\n            ":"\r\n            通过指令ID的活动语句。\r\n            \r\n","\r\n Represents one of the type characters or literal suffixes of VB. Used to\r\n describe a) the type character suffixes that can be placed on identifiers, and\r\n b) the suffixes that can be placed on integer literals.\r\n ":"\r\n 代表VB的类型字符或字面后缀之一。曾经\r\n 描述a）可以放置在标识符上的类型字符后缀和\r\n b）可以放置在整数文字上的后缀。\r\n \r\n","\r\n            Non-persisted option used to switch to displaying everything while the user is holding ctrl-alt.\r\n            ":"\r\n            在用户持有ctrl-alt时，用于切换到显示所有内容的非权利选项。\r\n            \r\n","MyType":"我的风格\r\n"," for source file directive.\r\n            ":" 用于源文件指令。\r\n            \r\n","Sort accessibility modifiers":"对可访问性修饰符进行排序\r\n","\r\n Creates an empty list of trivia.\r\n ":"\r\n 创建一个空的琐事列表。\r\n \r\n","Braces may be omitted when the entire statement is placed on one line.":"当整个语句放在一行时，大括号可能会被省略。\r\n","\r\n            Determines whether it is possible to navigate to the given virtual position in the specified document.\r\n            ":"\r\n            确定是否可以导航到指定文档中给定的虚拟位置。\r\n            \r\n","\r\n            Searches for extension methods exactly called 'Deconstruct'.  Returns\r\n            ":"\r\n            搜索精确称为“解构”的扩展方法。返回\r\n            \r\n","\r\n The value for the DelegateKeyword property.\r\n ":"\r\n 委托书属性的值。\r\n \r\n","\r\n Return method group or Nothing in case nothing was found.\r\n Note, returned group might have ResultKind = \"Inaccessible\".\r\n ":"\r\n 返回方法组或什么都没有发现。\r\n 注意，返回的组可能具有resultkind =“无法访问”。\r\n \r\n","\r\n The type containing the binding context\r\n ":"\r\n 包含绑定上下文的类型\r\n \r\n","updating usages in containing project":"更新包含项目的用法\r\n","\r\n A (possibly dotted) name denoting the namespace being declared.\r\n ":"\r\n 一个（可能点缀的）名称表示正在声明的名称空间。\r\n \r\n","\r\n            The implementation has to decide what kinds of nodes in top-level match relationship represent a declaration.\r\n            Every member declaration must be represented by exactly one node, but not all nodes have to represent a declaration.\r\n            \r\n            Note that in some cases the set of nodes of the declaration body may differ from the set of active nodes that \r\n            belong to the declaration. For example, in ":"\r\n            实施必须决定顶级匹配关系中哪些节点代表声明。\r\n            每个成员声明必须完全由一个节点表示，但并非所有节点都必须代表声明。\r\n            \r\n            请注意，在某些情况下，声明机构的节点集可能与一组活动节点不同\r\n            属于声明。例如，在\r\n"," if this instance is abstract; otherwise, ":" 如果此实例是抽象的；否则，\r\n","\r\n The expression being cast.\r\n ":"\r\n 表达式被铸造。\r\n \r\n","Namespaces":"名称空间\r\n","\r\n Returns the TypeSyntax of the given AsClauseSyntax if specified.\r\n ":"\r\n 如果指定了给定的asclausesyntax的型号。\r\n \r\n","\r\n            Keep this method in sync with \"AnalyzerExecutor.CreateAnalyzerExceptionDiagnostic\".\r\n            ":"\r\n            将此方法与“ AnalyzeRexeCutor.CreateAnalyzerexceptionDiagnostic”同步。\r\n            \r\n","\r\n            Current data that matches the version.\r\n            ":"\r\n            与版本匹配的当前数据。\r\n            \r\n","\r\n            Since an active statement represents a range between two sequence points and its span is associated with the first of these sequence points,\r\n            we decide whether the active statement is relevant within given span by checking whether its start location is within that span.\r\n            An active statement may overlap a span even if its starting location is not in the span, but such active statement is not relevant \r\n            for analysis of code within the given span.\r\n            \r\n            Assumes that ":"\r\n            由于活动语句表示两个序列点之间的范围，并且其跨度与这些序列点的第一个相关联，因此\r\n            我们通过检查其起始位置是否在该跨度内来确定活动语句是否在给定跨度内是否相关。\r\n            即使其起始位置不在跨度，活动语句也可能重叠一个跨度，但是这种活动语句与\r\n            用于分析给定跨度内的代码。\r\n            \r\n            假设\r\n","\r\n  Looks up a localized string similar to Maximum number of errors has been exceeded..\r\n":"\r\n  查找类似于最大错误数量的本地化字符串。\r\n\r\n"," node at the given index ":" 给定索引的节点\r\n","Matches a UTF-16 code unit whose value is #### hexadecimal.":"匹配一个值为#### hexadecimal的UTF-16代码单元。\r\n","contiguous matches":"连续匹配\r\n","\r\n A valid ":"\r\n 一个有效的\r\n"," of this item less than the default value so that\r\n            completion selects the ":" 该项目的少于默认值，因此\r\n            完成选择\r\n","Wrap long parameter list":"包裹长参数列表\r\n","Syntax node that is the root of the construct associated with \"memberBinder\".":"语法节点是与“ MemberBinder”关联的构造的根。\r\n","The declaration errors for a syntax tree are cached. The first time this method is called, a ll\r\n declarations are analyzed for diagnostics. Calling this a second time will return the cached diagnostics.\r\n ":"语法树的声明错误被缓存。第一次称之为该方法，ll\r\n 分析声明以进行诊断。第二次称呼将返回缓存的诊断。\r\n \r\n","month day":"月日\r\n","\r\n Does this node represent a property or latebound access not yet determined to be Get?\r\n ":"\r\n 该节点是否代表尚未确定获得的属性或末日访问？\r\n \r\n","Generate parameter '{0}' (and overrides/implementations)":"生成参数'{0}'（和覆盖/实现）\r\n","\r\n The value for the Alias property.\r\n ":"\r\n 别名属性的值。\r\n \r\n","\r\n            ```\\p{...}```\r\n            ":"\r\n            ````\\ p {...}''\r\n            \r\n","\r\n Add a type parameter -> type argument substitution to a TypeSubstitution object, returning a new TypeSubstitution object\r\n ByRef.\r\n ":"\r\n 添加类型参数 - >键入参数替换到tybyubstitution对象，返回一个新的centumubstitution对象\r\n Byref。\r\n \r\n","Extract method":"提取方法\r\n",", if computing specific kind of diagnostics for a document request,\r\n            i.e. ":"，如果计算文档请求的特定诊断类型，\r\n            IE。\r\n","\r\n The list of all interfaces of which this type is a declared subtype, excluding this type\r\n itself. This includes all declared base interfaces, all declared base interfaces of base\r\n types, and all declared base interfaces of those results (recursively).  Each result\r\n appears exactly once in the list. This list is topologically sorted by the inheritance\r\n relationship: if interface type A extends interface type B, then A precedes B in the\r\n list. This is not quite the same as \"all interfaces of which this type is a proper\r\n subtype\" because it does not take into account variance: AllInterfaces for\r\n IEnumerable(Of String) will not include IEnumerable(Of Object).\r\n ":"此类型的所有接口的列表是声明的亚型，不包括此类型\r\n 本身。这包括所有声明的基本接口，所有声明为基础的基本接口\r\n 类型，所有这些结果的基本接口（递归）。每个结果\r\n 完全出现在列表中。此列表在拓扑上被继承分类\r\n 关系：如果接口类型A扩展了接口类型B，则A在BE中的B之前\r\n 列表。这与“这种类型的所有接口”不完全相同\r\n 子类型“因为它不考虑差异：\r\n （字符串的）将不包括（对象）。\r\n \r\n","\r\n            The list of diagnostics produced by compilation.\r\n            ":"\r\n            通过汇编产生的诊断列表。\r\n            \r\n","\r\n            Flag indicating if we should perform a rename inside string literals.\r\n            ":"\r\n            标志指示我们是否应该在字符串文字内进行重命名。\r\n            \r\n","\r\n  Looks up a localized string similar to Cannot convert anonymous type to an expression tree because a property of the type is used to initialize another property..\r\n":"\r\n  查找类似于类似的本地化字符串，无法将匿名类型转换为表达树，因为该类型的属性用于初始化另一个属性。\r\n\r\n","\r\n Gets the locations where this symbol was originally defined.\r\n ":"\r\n 获取最初定义此符号的位置。\r\n \r\n","A reference to a type declared inside the namespace to be changed, which is calculated based on results from \r\n            `SymbolFinder.FindReferencesAsync`.":"对要更改的名称空间中声明的类型的引用，这是根据从\r\n            `symbolfinder.findreferencesAsync`。\r\n","\r\n The symbol that was referred to by the identifier, if any. \r\n ":"\r\n 标识符（如果有）所指的符号。\r\n \r\n","\r\n            Reads the MVID of a compiled project.\r\n            ":"\r\n            读取一个编译项目的MVID。\r\n            \r\n","\r\n This symbol is used as the return type of a LambdaSymbol when System.Void is used in code.\r\n ":"\r\n 当System.Void在代码中使用时，该符号用作Lambdasymbol的返回类型。\r\n \r\n","\r\n  Looks up a localized string similar to 'Group' or an identifier expected..\r\n":"\r\n  查找类似于“组”或预期标识符的本地化字符串。\r\n\r\n","\r\n            This overload is required for compatibility with existing extensions.\r\n            ":"\r\n            与现有扩展的兼容性是必需的。\r\n            \r\n","\r\n            Given an ":"\r\n            给定\r\n"," corresponding to the given reference or Nothing if there is none.":" 对应于给定的参考，或者没有。\r\n","\r\n Uses object identity when comparing two references. \r\n ":"\r\n 比较两个引用时使用对象身份。\r\n \r\n"," The argument that need to be cast":" 需要施放的论点\r\n","Modifying the body of {0} requires restarting the application because the body has too many statements.":"修改{0}的主体需要重新启动应用程序，因为身体的语句太多。\r\n","\r\n The \"Try\" statement that begins the \"Try\" block.\r\n ":"\r\n 开始“尝试”块的“尝试”语句。\r\n \r\n","\r\n Generates the name of a field that backs Current property\r\n ":"\r\n 生成备份当前属性的字段的名称\r\n \r\n"," is null.\r\n            Invoked by the debugger on every step. It is critical for stepping performance that this method returns as fast as possible in absence of changes.\r\n            ":" 一片空白。\r\n            每一步都被调试器调用。对于阶梯性能至关重要的是，在没有变化的情况下，此方法尽可能快地返回。\r\n            \r\n","\r\n Returns a copy of this with the Declarators property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，声明属性属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Accesses to this collection must lock the set.":"访问此集合必须锁定该集合。\r\n","\r\n For semantic model scenarios we continue processing documentation comment even in presence\r\n of some errors. Now, we detect semantic model context from '_isForSingleSymbol' flag,\r\n later we might consider introducing an explicit flag\r\n ":"\r\n 对于语义模型方案，我们即使在存在的情况下也继续处理文档评论\r\n 一些错误。现在，我们从'_sisforsinglesymbol'标志中检测到语义模型上下文，\r\n 稍后我们可能会考虑引入一个明确的标志\r\n \r\n","\r\n Returns a copy of this with the IfOrElseIfKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，并使用IforelSeifKeyWord属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Get a SemanticModel object that is associated with a method body that did not appear in this source code.\r\n Given ":"\r\n 获取与该源代码中未出现的方法主体关联的SemanticModel对象。\r\n 给出\r\n","\r\n Lookup a member name in a module, class, struct, enum, or delegate, returning a LookupResult that\r\n summarizes the results of the lookup. See LookupResult structure for a detailed\r\n discussing of the meaning of the results. The supplied binder is used for accessibility\r\n checks and base class suppression.\r\n ":"\r\n 查找模块，类，结构，枚举或委托中的成员名称，返回一个查找，\r\n 总结查找的结果。有关详细信息，请参见查找结构\r\n 讨论结果的含义。提供的粘合剂用于可访问性\r\n 检查和基类抑制。\r\n \r\n","\r\n Represents the \"If ... Then\" statement that begins a multi-line \"If\" block.\r\n ":"代表“如果...然后”语句，该语句启动多行” if”块。\r\n \r\n","\r\n Describes how the parameter is marshalled when passed to native code.\r\n Null if no specific marshalling information is available for the parameter.\r\n ":"\r\n 描述将参数传递给本机代码时的编组方式。\r\n null如果没有特定的编组信息可用于参数。\r\n \r\n","\r\n Binder used for attributes\r\n ":"\r\n 用于属性的粘合剂\r\n \r\n"," \r\n One of the methods has more parameters than the other \r\n AND at least one of the extra parameters IS optional\r\n OR \r\n there is at least one parameter in one method with optionality (being optional or \r\n required) not equal to that of the matching parameter from the other method\r\n ":" \r\n 其中一种方法比其他方法具有更多的参数\r\n 至少有一个额外参数是可选的\r\n 或者\r\n 一种方法中至少有一个参数具有可选性（是可选的或\r\n 必需）不等于其他方法的匹配参数\r\n \r\n","\r\n Creates a speculative AttributeSemanticModel that allows asking semantic questions about an attribute node that did not appear in the original source code.\r\n ":"\r\n 创建一个投机属性：允许询问有关未出现在原始源代码中的属性节点的语义问题。\r\n \r\n","\r\n Returns a copy of this with the ExternalSource property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，外部属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","The initializer syntax for the statement.":"语句的初始化语法。\r\n","\r\n            The expected return type of the script.\r\n            ":"\r\n            脚本的预期返回类型。\r\n            \r\n",", if available on the platform (check ":"，如果在平台上可用（检查\r\n","\r\n Returns true if this symbol was declared to override a base class members; i.e., declared\r\n with the \"Overrides\" modifier. Still returns true if the members was declared\r\n to override something, but (erroneously) no member to override exists.\r\n ":"\r\n 如果该符号被宣布覆盖基类成员，则返回为True；即，宣布\r\n 带有“覆盖”修饰符。如果成员被宣布，仍然返回\r\n 要覆盖某些东西，但是（错误地）没有成员可以覆盖。\r\n \r\n","Record member '{0}' may not be static.":"记录成员'{0}'可能不是静态的。\r\n"," Asserts that the node is NOT from With statement expression ":" 断言该节点不是来自语句表达式\r\n","The text of the end of line. Any text can be specified here, however only carriage return And\r\n line feed characters are recognized by the parser as end of line.":"线的末尾。任何文本都可以在此处指定，但是只有运输返回和\r\n 线条饲料字符被解析器识别为线的结尾。\r\n","\r\n            because we ignore nullability.":"\r\n            因为我们忽略了无效性。\r\n","\r\n  Looks up a localized string similar to Expression cannot be converted into an expression tree..\r\n":"\r\n  查找类似于表达式的本地化字符串无法转换为表达树。\r\n\r\n"," effective for this symbol (type or DllImport method).\r\n Nothing if ":" 对于此符号有效（类型或dllimport方法）。\r\n 没有\r\n","alternation":"交替\r\n","\r\n            Given a document and syntax node, returns a collection of locations of methods that refer to the located node.\r\n            ":"\r\n            给定的文档和语法节点，返回了指涉及位置节点的方法的集合。\r\n            \r\n","\r\n Scan tokens in Xml misc state, these are tokens between document declaration and the root element\r\n ":"\r\n 扫描令牌在XML MISC状态中，这些是文档声明和根元素之间的令牌\r\n \r\n","Re-triage {0}(currently '{1}')":"重新划分{0}（当前'{1}'）\r\n","Parameter {0} occurs after {1} in the parameter list, but is used as an argument for interpolated string handler conversions. This will require the caller to reorder parameters with named arguments at the call site. Consider putting the interpolated string ...":"参数{0}发生在参数列表中的{1}之后，但用作插值字符串处理程序转换的参数。这将要求呼叫者在呼叫站点上重新排序参数。考虑放置插值字符串...\r\n"," considers string\r\n            and object but the compiler's implementation of IsIntrinsicType does not.\r\n            ":" 考虑字符串\r\n            和对象，但是编译器的IsintrinStype的实现却没有。\r\n            \r\n","\r\n  Looks up a localized string similar to '#ElseIf' must be preceded by a matching '#If' or '#ElseIf'..\r\n":"\r\n  查找类似于“ #elseif”的本地化字符串必须先于匹配的“ #if”或“ #elseif” ..\r\n\r\n","\r\n The value for the InKeyword property.\r\n ":"\r\n InKeyWord属性的值。\r\n \r\n","TypeName":"打字\r\n","\r\n  Overrides the current thread's CurrentUICulture property for all\r\n  resource lookups using this strongly typed resource class.\r\n":"\r\n  覆盖当前线程的当前线属性\r\n  使用此强大的资源类别的资源查找。\r\n\r\n","Adding {0} into an interface requires restarting the application.":"将{0}添加到接口中需要重新启动应用程序。\r\n","Updating the base class and/or base interface(s) of {0} requires restarting the application.":"更新{0}的基类和/或基本接口（s）需要重新启动应用程序。\r\n","\r\n            Handles references to source symbols both from the current project the user is invoking\r\n            'add-import' from, as well as symbols from other viable projects.\r\n            \r\n            In the case where the reference is from another project we put a glyph in the add using\r\n            light bulb and we say \"(from ProjectXXX)\" to make it clear that this will do more than\r\n            just add a using/import.\r\n            ":"\r\n            处理用户正在调用的当前项目中对源符号的引用\r\n            来自其他可行项目的“附加信息”以及其他可行项目的符号。\r\n            \r\n            如果参考来自另一个项目的参考，我们在添加中使用字形\r\n            灯泡，我们说“（从ProjectXXX）”，以明确表明这将做得超过\r\n            只需添加使用/导入即可。\r\n            \r\n","\r\n Represents a source parameter cloned from another ":"\r\n 表示从另一个克隆的源参数\r\n","\r\n Blocks that are positioned between a block declaring some lifted variables\r\n and a block that contains the lambda that lifts said variables.\r\n If such block itself requires a closure, then it must lift parent frame pointer into the closure\r\n in addition to whatever else needs to be lifted.\r\n \r\n NOTE: This information is computed in addition to the regular analysis of the tree and only needed for rewriting.\r\n If someone only needs diagnostics or information about captures, this information is not necessary.\r\n ComputeLambdaScopesAndFrameCaptures needs to be called to compute this.\r\n ":"\r\n 位于块之间的块，声明一些提升变量\r\n 还有一个包含lambda的块，升压变量。\r\n 如果这样的块本身需要关闭，则必须将父框架指针提升到闭合\r\n 除了其他需要举起的东西。\r\n \r\n 注意：除了对树的常规分析外，还需要计算此信息，并且仅需要重写。\r\n 如果某人只需要诊断或有关捕获的信息，则无需此信息。\r\n 需要调用ComputelambdAscopesandFrameCaptures来计算此问题。\r\n \r\n","\r\n property.\r\n ":"\r\n 财产。\r\n \r\n","\r\n  Looks up a localized string similar to The implicit return variable of an Iterator or Async method cannot be accessed..\r\n":"\r\n  查找类似于迭代器或异步方法的隐式返回变量类似的本地化字符串。\r\n\r\n","\r\n Get the symbol that logically contains this symbol. \r\n ":"\r\n 获取逻辑上包含此符号的符号。\r\n \r\n"," may be updated by adding a new non-overlapping ":" 可以通过添加新的不重叠来更新\r\n","The embedded statement itself":"嵌入式陈述本身\r\n","<designation name>":"<名称名称>\r\n","\r\n             True, if arguments and parameters match perfectly.\r\n             \"targetArgumentConversionType\" outputs the corresponding parameter type of \"targetArgument\"\r\n             False, otherwise.\r\n             ":"\r\n             是的，如果参数和参数完美匹配。\r\n             “ targetArgumentConversionType”输出“ targetargument”的相应参数类型\r\n             错误，否则。\r\n             \r\n","\r\n The \"TypeOf\" keyword.\r\n ":"\r\n “ typeof”关键字。\r\n \r\n","Add 'this' or 'Me' qualification.":"添加“这个”或“我”的资格。\r\n"," for other languages.\r\n            ":" 对于其他语言。\r\n            \r\n","\r\n Binds the expression in the context of the specified location and gets constant value information. \r\n This method is used to get information about an expression that did not actually appear in the source code.\r\n ":"\r\n 在指定位置的上下文中绑定表达式，并获取恒定值信息。\r\n 此方法用于获取有关未出现在源代码中的表达式的信息。\r\n \r\n","\r\n An abstract node class that is the parent for declarations that are\r\n \"method-like\"; i.e., that have a parameter list and return type. This includes\r\n methods, constructors, properties, events, operators, declares, delegates,\r\n property accessors and custom event accessors.\r\n ":"\r\n 一个抽象节点类是声明的父母\r\n “类似方法”；即，具有参数列表和返回类型。这包括\r\n 方法，构造函数，属性，事件，操作员，声明，委托，\r\n 物业访问者和自定义活动访问者。\r\n \r\n","\r\n            Another interesting case is something like:\r\n            ":"\r\n            另一个有趣的案例是：\r\n            \r\n","\r\n A list of all the modifier tokens that were present on this declaration. If no\r\n modifiers were specified, an empty list is returned.\r\n ":"\r\n 该声明中存在的所有修饰符令牌的列表。如果不\r\n 指定了修饰符，返回一个空列表。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' cannot implement '{1}' because there is no matching {2} on interface '{3}'..\r\n":"\r\n  查找类似于'{0}'无法实现'{1}'的本地化字符串，因为在接口'{3}'..上没有匹配{2}。\r\n\r\n","\r\n  Looks up a localized string similar to Error reading debug information for '{0}'.\r\n":"\r\n  查找类似于“ {0}”的错误读取调试信息的本地化字符串。\r\n\r\n","\r\n Represents a Namespace statement, its contents and the End Namespace statement.\r\n ":"\r\n 代表名称空间语句，其内容和最终名称空间语句。\r\n \r\n","The token to check for cancellation":"要检查取消的令牌\r\n","\r\n No context given (default).\r\n ":"\r\n 没有给出的上下文（默认）。\r\n \r\n","\r\n To handle a label, we resolve all pending forward references to branches to that label.  Returns true if the state of\r\n the label changes as a result. \r\n ":"\r\n 为了处理标签，我们解决了所有对该标签分支的前瞻性引用。如果状态的状态\r\n 标签随之变化。\r\n \r\n","\r\n  Looks up a localized string similar to Extension Method '{0}' defined in '{2}' does not have a signature compatible with delegate '{1}'..\r\n":"\r\n  查找类似于'{2}'中定义的扩展方法'{0}'的本地化字符串，与签名'{1}'..\r\n\r\n",">This replaces both ParseParameter and ParseOptionalParameter in Dev10":">在Dev10中，这替换了选拍选拍药和parseoptional参数仪\r\n","Introduce parameter":"引入参数\r\n","\r\n Given the control variable, limit and step, produce the loop condition.\r\n The principle is simple - \r\n       if step is negative (stepping \"Up\") then it is \"control >= limit\"\r\n       otherwise it is \"control <= limit\"\r\n \r\n It gets more complicated when step is not a constant or not a numeric or \r\n involves overloaded comparison/IsTrue operators\r\n ":"\r\n 给定控制变量，极限和步长，产生循环条件。\r\n 原理很简单 - \r\n       如果步进为负（步进\"向上\"），那么它是\"控制>=限制\"\r\n       否则为\"control<=limit\"\r\n \r\n 当step不是常量或不是数字或 \r\n 涉及重载比较/IsTrue运算符\r\n \r\n","Record defines 'Equals' but not 'GetHashCode'.":"记录定义了“平等”，但不是“ Gethashcode”。\r\n","\r\n  Looks up a localized string similar to Module '{0}' cannot be used as a type..\r\n":"\r\n  查找类似于模块'{0}'的本地化字符串不能用作类型。\r\n\r\n","\r\n Bind Join/From selector that absorbs following Select/Let in context of this binder.\r\n ":"\r\n 从选择器中的选择器中绑定连接/在此粘合剂的上下文中吸收。\r\n \r\n","\r\n            the full line of source that contained the reference\r\n            ":"\r\n            包含参考的完整源\r\n            \r\n","\r\n Construct a body for String Switch Hash Function\r\n ":"\r\n 为字符串开关哈希函数构建一个主体\r\n \r\n","A number sign (#) marks an x-mode comment, which starts at the unescaped # character at the end of the regular expression pattern and continues until the end of the line. To use this construct, you must either enable the x option (through inline options) o ...":"一个数字符号（＃）标记X模式注释，该评论从正则表达式末尾的Unepaper＃farem开始，一直持续到线结束。要使用此构造，您必须启用X选项（通过内联选项）o ...\r\n","\r\n Indicates that previously returned node has been consumed\r\n and scanner needs to advance by the size of the node.\r\n \r\n NOTE: the advancement is done relative to the start of the current token.\r\n Line offset may not match start of current token because of lookahead. \r\n \r\n This operation will discard lookahead tokens and reset preprocessor state \r\n to the state of current token. \r\n ":"\r\n 表明先前返回的节点已被消耗\r\n 扫描仪需要按节点的大小前进。\r\n \r\n 注意：相对于当前令牌的开始，进步是完成的。\r\n 由于Lookahead，线路偏移可能与当前令牌的启动不符。\r\n \r\n 此操作将丢弃LookAhead代币并重置预处理器状态\r\n 到当前令牌状态。\r\n \r\n","\r\n            The set of well known tags used for the ":"\r\n            一组众所周知的标签\r\n","\r\n The value for the Reference property.\r\n ":"\r\n 参考属性的值。\r\n \r\n","\r\n Check for overriding and hiding errors in container and report them via diagnostics.\r\n ":"\r\n 检查容器中的覆盖和隐藏错误，并通过诊断报告。\r\n \r\n","\r\n  Looks up a localized string similar to 'New' constraint cannot be specified multiple times for the same type parameter..\r\n":"\r\n  查找类似于“新”约束的本地化字符串，不能多次指定相同类型参数。\r\n\r\n","\r\n Some symbols do not participate in overriding/hiding (e.g. constructors). Accessors are consider\r\n to override or hide.\r\n ":"有些符号不参与覆盖/隐藏（例如构造函数）。考虑登录器\r\n 覆盖或隐藏。\r\n \r\n","\r\n Helper visitor to report query specific errors for an operand of an Equals expression.\r\n ":"\r\n 助手访问者报告对等式表达式操作数的查询特定错误。\r\n \r\n","local variable":"本地变量\r\n","\r\n Lookup a member name in modules of a namespace, \r\n returning a LookupResult that summarizes the results of the lookup. \r\n See LookupResult structure for a detailed discussion of the meaning of the results. \r\n The supplied binder is used for accessibility checks and base class suppression.\r\n ":"\r\n 查找名称空间模块中的成员名称，\r\n 返回查找查找结果的查找。\r\n 有关结果含义的详细讨论，请参见查找结构。\r\n 提供的粘合剂用于可访问性检查和基类抑制。\r\n \r\n","Implement {0}":"实施{0}\r\n","\r\n  Looks up a localized string similar to 'If' operator requires either two or three operands..\r\n":"\r\n  查找类似于“如果”操作员需要两个或三个操作数的本地化字符串。\r\n\r\n","The container to look in.":"要看的容器。\r\n","Invalid object creation":"无效的对象创建\r\n","\r\n            that, for non-empty selections, returns the smallest encompassing node. A node that can, for certain refactorings, be too large given user-selection even though\r\n            it is the smallest that can be retrieved.\r\n            ":"\r\n            对于非空选择，返回最小的包含节点。对于某些重构，即使用户选择的节点可能太大，即使\r\n            它是可以检索的最小的。\r\n            \r\n","\r\n If the attribute represents an xmlns declaration, populate 'prefix' and 'namespace',\r\n and generate diagnostics and set hasErrors if there are errors. Returns True if this\r\n is an xmlns declaration, even if there are errors. Unless this attribute is from an\r\n Imports statement, generate the BoundExpression for the namespace as well.\r\n (For Imports, binding is skipped, since a BoundNode is not needed, and in the\r\n invalid case of \"xmlns:p=<%= expr %>\", expr may result in a cycle.\r\n ":"\r\n 如果属性代表XMLN声明，则填充“前缀”和“名称空间”，则\r\n 并生成诊断和设置haserrors如果有错误。如果这个返回为true\r\n 即使存在错误，也是XMLN声明。除非此属性来自\r\n 导入语句，生成命名空间的界表。\r\n （对于进口，跳过绑定，因为不需要一个界点，并且在\r\n 无效的“ XMLNS：P = <％= Expr％>”的情况可能会导致周期。\r\n \r\n","\r\n            CompletionItems for indexers/operators should be sorted below other suggestions like methods or properties\r\n            of the type.  We accomplish this by placing a character known to be greater than all other normal identifier\r\n            characters as the start of our item's name. This doesn't affect what we insert though as all derived\r\n            providers have specialized logic for what they need to do.\r\n            ":"\r\n            索引器/运算符的填充元素应在其他建议之下排序，例如方法或属性\r\n            类型。我们通过放置一个已知的角色大于所有其他正常标识符来实现这一目标\r\n            字符作为我们项目名称的开始。这不会影响我们所插入的内容\r\n            提供者具有专门的逻辑，可以做什么。\r\n            \r\n","the context document":"上下文文档\r\n","\r\n Gets the return type of the method. If the method is a Sub, returns\r\n the same type symbol as is returned by Compilation.VoidType.\r\n ":"\r\n 获取该方法的返回类型。如果该方法是子，则返回\r\n 与compilation.voidType返回的相同类型符号。\r\n \r\n","MyBase.":"我想。\r\n","\r\n            Analyzers referenced by the project via a PackageReference.\r\n            ":"\r\n            该项目通过PackageReference引用的分析仪。\r\n            \r\n","Convert to LINQ (call form)":"转换为linq（呼叫表格）\r\n"," Region being analyzed: start node ":" 分析区域：启动节点\r\n","\r\n This class represents a synthesized delegate type derived from an Event declaration\r\n ":"\r\n 该类代表从事件声明得出的合成的委托类型\r\n \r\n","\r\n            Map of base active statements.\r\n            Calculated lazily based on info retrieved from ":"\r\n            基本活动语句的地图。\r\n            根据从检索到的信息中懒惰地计算\r\n","\r\n            Computes all local diagnostics (syntax, semantic) that belong to given document for the given StateSet (analyzer).\r\n            ":"\r\n            计算属于给定状态网（分析仪）给定文档的所有局部诊断（语法，语义）。\r\n            \r\n","\r\n             \r\n             Note: for the sake of simplicity, (arglist) is used both for the argument list of\r\n             an InvocationExpression and an ElementAccessExpression.\r\n             \r\n             'remainder' is all the postfix expression that can follow ":"\r\n             \r\n             注意：为了简单起见，（arglist）两者都用于参数列表\r\n             调用表达和元素表达。\r\n             \r\n             “剩余”是可以关注的所有后缀表达式\r\n","The name or member access expression.":"名称或成员访问表达式。\r\n"," generic type.  These occur only\r\n within a ":" 通用类型。这些仅发生\r\n 在\r\n","\r\n Returns declared base type or actual base type if already known\r\n This is only used by cycle detection code so that it can observe when cycles are broken \r\n while not forcing actual Base to be realized.\r\n ":"\r\n 返回声明为基本类型或实际基本类型，如果已经知道\r\n 这仅是由周期检测代码使用的，因此可以观察到何时破裂\r\n 虽然不强迫实际的基础。\r\n \r\n","\r\n Returns a copy of this with the EndEventStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中EndeventStatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            Methods, Properties, or Events either have \"ordinary\" names,\r\n            or explicit interface names. But even explicit names have an\r\n            underlying ordinary name as well. This is just the value for\r\n            ordinary names, or the underlying ordinary name if this is an\r\n            explicit name.\r\n            ":"\r\n            方法，属性或事件具有“普通”名称，\r\n            或显式接口名称。但是即使是明确的名称也有一个\r\n            普通名称也是基本的。这只是值的价值\r\n            普通名称，或基本的普通名称，如果是\r\n            显式名称。\r\n            \r\n","\r\n  Looks up a localized string similar to Cannot inherit interface '{0}' because the interface '{1}' from which it inherits could be identical to interface '{2}' for some type arguments..\r\n":"\r\n  查找类似于无法继承界面'{0}'的本地化字符串，因为它从中继承的接口'{1}'对于某些类型的参数可能与接口'{2}'相同。\r\n\r\n","\r\n The bound information from a file.\r\n ":"\r\n 文件中的绑定信息。\r\n \r\n","\r\n Set and Get the Visual Basic compilation options.\r\n ":"\r\n 设置并获取视觉基本汇编选项。\r\n \r\n","\r\n            Looks for code of the form:\r\n            \r\n                int i;\r\n                if (int.TryParse(s, out i)) { }\r\n                \r\n            And offers to convert it to:\r\n            \r\n                if (int.TryParse(s, out var i)) { }   or\r\n                if (int.TryParse(s, out int i)) { }   or\r\n            \r\n            ":"\r\n            寻找表格的代码：\r\n            \r\n                int i;\r\n                if（int.tryparse（s，out i））{}\r\n                \r\n            并提出将其转换为：\r\n            \r\n                if（int.tryparse（s，out var i））{}或\r\n                if（int.tryparse（s，out int i））{}或\r\n            \r\n            \r\n","\r\n Cache the CLS diagnostics for the whole compilation so they aren't computed repeatedly.\r\n ":"\r\n 缓存整个汇编的CLS诊断，因此不会重复计算它们。\r\n \r\n","\r\n            Indicates that the code style diagnostic is an IDE-only diagnostic that cannot be enforced on build.\r\n            ":"\r\n            表明代码样式诊断是仅在构建时执行的仅IDE诊断。\r\n            \r\n","\r\n            The reasons why the extract method operation did not succeed.\r\n            ":"\r\n            提取方法操作未成功的原因。\r\n            \r\n","\r\n Return the constraints for the type parameter with any cycles\r\n or conflicting constraints reported as errors and removed.\r\n ":"用任何周期返回类型参数的约束\r\n 或报道为错误并删除的矛盾约束。\r\n \r\n"," Creates a token with kind IntegerLiteralToken from a 4-byte unsigned integer\r\n value. ":" 从4字节的无符号整数中创建一个用善良的integerliteraltoken创建令牌\r\n 价值。\r\n","\r\n            Changes the direction the operator is pointing at.\r\n            ":"\r\n            更改操作员指向的方向。\r\n            \r\n","\r\n  Looks up a localized string similar to 'InterfaceId' and 'EventsId' parameters for 'Microsoft.VisualBasic.ComClassAttribute' on '{0}' cannot have the same value..\r\n":"\r\n  查找类似于'Microsoft.visualbasic.comclassattribute'on'{0}'的'InterfaceId'和'EventsId'参数类似的本地化字符串，无法具有相同的值。\r\n\r\n","\r\n If this is an extension method that can be applied to a instance of the given type,\r\n returns the reduced method symbol thus formed. Otherwise, returns Nothing.\r\n ":"\r\n 如果这是一种扩展方法，可以应用于给定类型的实例，\r\n 返回如此形成的还原方法符号。否则，什么都没有。\r\n \r\n","\r\n Checks if a given symbol is a property that is readable.\r\n ":"\r\n 检查给定符号是否是可读的属性。\r\n \r\n","\r\n             for analysis performed by a ":"\r\n             用于分析\r\n","\r\n Represents an argument that is just an optional argument name and an\r\n expression.\r\n ":"代表一个参数，只是一个可选的参数名称和一个\r\n 表达。\r\n \r\n","\r\n  Looks up a localized string similar to Literal expected..\r\n":"查找类似于字面预期的本地化字符串。\r\n\r\n","\r\n  Looks up a localized string similar to Type '{0}' cannot be used in an attribute because its container '{1}' is not declared 'Public'..\r\n":"\r\n  在属性中查找类似于“ {0}”类型的本地化字符串，因为其容器'{1}'未声明“ public” ..\r\n\r\n","\r\n Represents an \"End XXX\" statement, where XXX is a single keyword.\r\n ":"\r\n 代表“ end xxx”语句，其中xxx是一个关键字。\r\n \r\n","Method referenced implicitly":"隐式引用的方法\r\n","Syntax that overriding or hiding.":"覆盖或隐藏的语法。\r\n","In the grammar ArrayLiteralExpression is a rename of CollectionInitializer":"在语法arrayliteralexpression中\r\n","\r\n Fixed type parameters for a reduced extension method or empty.\r\n ":"\r\n 修复了减少扩展方法或空的类型参数。\r\n \r\n","\r\n            Difference between new span and pre-remap span (new = old + delta).\r\n            ":"\r\n            新的跨度和预示例跨度（new = old + delta）之间的差异。\r\n            \r\n","\r\n Returns True if there are most applicable candidates.\r\n \r\n indexesOfMostApplicableCandidates will contain indexes of equally applicable candidates, which are most applicable\r\n by comparison to the other (non-equal) candidates. The indexes will be in ascending order.\r\n ":"\r\n 如果有最适用的候选人，则返回为真。\r\n \r\n 最多的索引将包含同样适用的候选人的索引，这是最适用的\r\n 与其他（非平等）候选人相比。索引将按顺序排列。\r\n \r\n","\r\n If there was a method that overload resolution considered better than all others,\r\n returns information about that method. A method may be returned even if that method was\r\n not considered a successful overload resolution, as long as it was better than any other\r\n potential method considered.\r\n ":"\r\n 如果有一种方法可以使分辨率超载比其他所有方法更好，\r\n 返回有关该方法的信息。即使该方法是\r\n 只要它比其他任何人都更好\r\n 考虑了潜在方法。\r\n \r\n","\r\n Return the name of the lexically first symbol in \"overloadedMembers\".\r\n ":"\r\n 返回“ OverloadedMembers”中词汇第一个符号的名称。\r\n \r\n","\r\n  Looks up a localized string similar to 'For' must end with a matching 'Next'..\r\n":"\r\n  查找类似于“必须”以匹配的“下一步”结尾的本地化字符串。\r\n\r\n","\r\n True if some symbol in the parent hierarchy is known to be Obsolete. Unknown if any\r\n symbol's Obsoleteness is Unknown. False, if we are certain that no symbol in the parent\r\n hierarchy is Obsolete.\r\n ":"\r\n 是的，如果已知父层次结构中的某些符号已过时。未知是否有\r\n 符号的过度是未知的。错误，如果我们确定父母没有符号\r\n 层次结构已过时。\r\n \r\n","\r\n Represents an XML element with content in an XML literal expression.\r\n ":"\r\n 代表XML元素，其中具有XML文字表达式中的内容。\r\n \r\n","\r\n            Searches for extension methods exactly called 'GetAwaiter'.  Returns\r\n            ":"\r\n            搜索完全称为“ Getawaiter”的扩展方法。返回\r\n            \r\n"," should return true\r\n            for a given brace, opening position, and document.  Only that service will be asked\r\n            for brace completion results.\r\n            ":" 应该返回真实\r\n            用于给定的支撑，打开位置和文件。只会询问该服务\r\n            为了完成支撑结果。\r\n            \r\n","\r\n Normally VB arrays have default sizes and lower bounds - sizes are not specified and all dimensions are zero bound.\r\n This property should return false for any deviations.\r\n ":"\r\n 通常，VB数组具有默认尺寸和下限 - 未指定大小，所有尺寸均为零界。\r\n 此属性应返回任何偏差的false。\r\n \r\n","\r\n The \",\" token.\r\n ":"\r\n “”，令牌。\r\n \r\n","s\r\n            that can be presented in an editor and used to navigate to the defintions and\r\n            references found for a symbol.\r\n            ":"s\r\n            可以在编辑器中呈现，并用于导航到定义和\r\n            为符号找到参考。\r\n            \r\n","\r\n            The solution captured when the debugging session entered run mode (application debugging started),\r\n            or the solution which the last changes committed to the debuggee at the end of edit session were calculated from.\r\n            The solution reflecting the current state of the modules loaded in the debugee.\r\n            ":"\r\n            当调试会话输入运行模式时捕获的解决方案（应用程序调试开始），\r\n            或根据编辑会话结束时进行调试的最后一个更改的解决方案是根据。\r\n            反映辩解中加载模块的当前状态的解决方案。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Custom Event' must end with a matching 'End Event'..\r\n":"\r\n  查找类似于“自定义事件”的本地化字符串必须以匹配的“结束事件”结尾。\r\n\r\n","\r\n Looks up the name in the type parameters\r\n a) type parameters in this type (but not outer or base types)\r\n Returns all members of that name, or empty list if none.\r\n ":"\r\n 在类型参数中查找名称\r\n a）此类型中的类型参数（但不是外部或基本类型）\r\n 返回该名称的所有成员，如果没有，则返回空名单。\r\n \r\n"," object\r\n associated with a member within substituted type, ":" 目的\r\n 与替代类型中的成员相关联\r\n","\r\n            ```\\k'name'``` or ```\\k<name>``` escape.\r\n            ":"\r\n            ````\\ k'name''或````\\ k <name>``\r\n            \r\n","The calling convention of '{0}' is not supported by the language.":"语言不支持“ {0}”的调用约定。\r\n","Flag indicating if any of the processed ":"标志指示是否处理过\r\n","\r\n The value for the Orderings property.\r\n ":"\r\n 订购属性的值。\r\n \r\n","\r\n The \"Is\" or \"IsNot\" keyword.\r\n ":"\r\n “ IS”或“ ISNOT”关键字。\r\n \r\n",". \r\n It is used by ":"。\r\n 它由\r\n","\r\n Returns a copy of this with the IsKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中ISKeyWord属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","The range of text.":"文字范围。\r\n","\r\n            NOTE: Roslyn's LSP completion implementation uses this struct. If a new property is added, either:\r\n                1: The property's type must be serializable\r\n                OR\r\n                2. LSP will need to be updated to not use CompletionTrigger - see\r\n                   Features\\LanguageServer\\Protocol\\Handler\\Completion\\CompletionResolveData.cs\r\n            ":"注意：罗斯林的LSP完成实现使用此结构。如果添加了新属性，又要：\r\n                1：属性的类型必须序列化\r\n                或者\r\n                2. LSP将需要更新以不使用完整击中 - 请参阅\r\n                   功能\\ Lakenageserver \\ stologe \\ handler \\ posterlion \\ pleastionResolvedata.cs\r\n            \r\n","\r\n Given a node that represents a lambda body returns a node that represents the lambda.\r\n ":"\r\n 给定代表lambda身体的节点返回代表lambda的节点。\r\n \r\n"," Creates a token with kind IntegerLiteralToken from the text and corresponding 8-byte unsigned integer value. ":" 从文本和相应的8字节未签名的整数值中创建一个具有元素integerliteraltoken的令牌。\r\n","\r\n The declarations contained in the type or module.\r\n ":"\r\n 类型或模块中包含的声明。\r\n \r\n","\r\n Returns true if calls and delegate invocations with this\r\n expression as the receiver should be non-virtual calls.\r\n ":"\r\n 返回true如果通话并将其委派授权\r\n 作为接收器的表达应为非虚拟呼叫。\r\n \r\n","\r\n The list of interface members being implemented.\r\n ":"\r\n 实现的接口成员列表。\r\n \r\n","\r\n Gets a value indicating whether the symbol was generated by the compiler\r\n rather than declared explicitly.\r\n ":"\r\n 获得一个值，指示符号是否由编译器生成\r\n 而不是明确声明。\r\n \r\n","\r\n Substitutions performed so far (or null for none).\r\n Keys are type parameters, values are types (possibly type parameters).\r\n Will be updated with new substitutions by the callee.\r\n Irrelevant if false is returned.\r\n ":"\r\n 到目前为止执行的替换（或无效）。\r\n 密钥是类型参数，值是类型（可能是类型参数）。\r\n Callee将以新的替换更新。\r\n 如果返回错误，则无关紧要。\r\n \r\n","Contains invalid selection.":"包含无效的选择。\r\n","\r\n Represents a modifier that describes an array type, without bounds, such as\r\n \"()\" or \"(,)\".\r\n ":"\r\n 代表描述数组类型的修饰符，没有界限，例如\r\n “（）“ 或者 ”（，）”。\r\n \r\n","'{0}' cannot be null or empty.":"'{0}'不能为空或空。\r\n","\r\n Check attribute lists quickly to see what attributes might be referenced.\r\n ":"\r\n 快速检查属性列表以查看可能引用哪些属性。\r\n \r\n","Method to wrap":"包装方法\r\n","The type '{2}' must be a non-nullable value type, along with all fields at any level of nesting, in order to use it as parameter '{1}' in the generic type or method '{0}'":"类型的'{2}'必须是不可删除的值类型，以及在任何嵌套级别上的所有字段，以便将其用作通用类型或方法'{0}'中的参数'{1}'\r\n","\r\n Returns a copy of this with the CallKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而CallKeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' cannot be applied because the format of the GUID '{1}' is not correct..\r\n":"\r\n  查找类似于“ {0}”的局部字符串，因为GUID'{1}'的格式不正确。\r\n\r\n","Change return type from {0} to {1}":"将返回类型从{0}更改为{1}\r\n","\r\n Represents an #r directive appearing in scripts.\r\n ":"\r\n 代表脚本中出现的#R指令。\r\n \r\n","\r\n Get the access kind from property access expression.\r\n ":"\r\n 从属性访问表达式获取访问类型。\r\n \r\n","\r\n  Looks up a localized string similar to Conversion operators cannot convert from a type to the same type..\r\n":"\r\n  查找类似于转换操作员的本地化字符串无法从类型转换为同一类型。\r\n\r\n","\r\n            Build enforcement recommendation for a code style analyzer.\r\n            ":"\r\n            为代码样式分析仪构建执法建议。\r\n            \r\n","\r\n Returns a copy of this with the AggregationVariables property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 将其返回此副本，而汇总变量属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Represents the \"Catch ... When ...\" statement that begins a \"Catch\" block.\r\n ":"\r\n 代表开始“捕获”块的“捕获...当...”陈述。\r\n \r\n","Rules about which keys typed caused the completion item to be committed.":"关于哪个键输入的键导致完成项目的规则。\r\n","\r\n            Helper to get the true ReportDiagnostic severity for a given option.  Importantly, this\r\n            handle ReportDiagnostic.Default and will map that back to the appropriate value in that\r\n            case.\r\n            ":"\r\n            为给定选项获得真正的报告诊断严重性。重要的是，这个\r\n            处理reportdiagnostic.default，并将其映射到该值的适当值\r\n            案子。\r\n            \r\n","Methods attributed with 'UnmanagedCallersOnly' cannot have generic type parameters and cannot be declared in a generic type.":"归因于“ UnmanagedCallersonly”的方法不能具有通用类型参数，也不能在通用类型中声明。\r\n","\r\n The argument.\r\n ":"\r\n 论点。\r\n \r\n","\r\n            Code action to remove suppress message attributes for remove suppression.\r\n            ":"\r\n            代码操作以删除抑制消息属性以进行删除抑制。\r\n            \r\n","switch statement":"开关语句\r\n","declaration of expression variables in member initializers and queries":"在成员初始化和查询中的表达变量声明\r\n"," to be processed and updated.":" 要处理和更新。\r\n","The container to search for symbols within. If null then the\r\n enclosing declaration scope around position is used.":"内搜索符号的容器。 如果为null，则\r\n 使用围绕位置的声明范围。\r\n","\r\n Represents an assembly imported from a PE.\r\n ":"\r\n 代表从PE导入的组件。\r\n \r\n","\r\n The \">\" token.\r\n ":"\r\n “>”令牌。\r\n \r\n","\r\n The value for the SelectStatement property.\r\n ":"\r\n Selectstatement属性的值。\r\n \r\n","\r\n Represents a \"While expression\" or \"Until expression\" in a Do or Loop\r\n statement. The Kind of the clause can be \"WhileClause\" or \"UntilClause\" to\r\n indicate which kind of clause.\r\n ":"\r\n 表示在do或循环中的“表达”或“直到表达”\r\n 陈述。该条款的种类可以是“ leileclaus”或“ dercomplause”到\r\n 指示哪种条款。\r\n \r\n","Expected 'warnings', 'annotations', or end of directive":"预期的“警告”，“注释”或指令结束\r\n","\r\n Represents a label statement.\r\n ":"\r\n 代表标签语句。\r\n \r\n"," structure.\r\n ":" 结构体。\r\n \r\n","Split into consecutive '{0}' statements":"分为连续的'{0}'语句\r\n","Decoded well known attribute data.":"解码已知的属性数据。\r\n"," instance.  In order to convert between methods, there need to be\r\n             two overloads that are equivalent except that one takes two ints, and the other takes a\r\n             ":" 实例。为了在方法之间转换，需要\r\n             两个超载等效的超载，除了一个占两个int，另一个int载\r\n             \r\n","Atomic groups (known in some other regular expression engines as a nonbacktracking subexpression, an atomic subexpression, or a once-only subexpression) disable backtracking. The regular expression engine will match as many characters in the input string a ...":"原子组（在其他一些正则表达引擎中已知是非背部跟踪亚表达，原子亚表达或仅一次仅亚表达）禁用回溯。正则表达式引擎将匹配输入字符串中的许多字符A ...\r\n","\r\n            Return true if the declaration is a parameter that is part of a records primary constructor.\r\n            ":"\r\n            如果声明是作为记录主构造函数的一部分的参数，则返回true。\r\n            \r\n","\r\n            Member which user initially selects. It will be selected initially when the dialog pops up.\r\n            ":"\r\n            用户最初选择的成员。当对话框弹出时，最初将选择它。\r\n            \r\n","\r\n Syntax node for the using block.\r\n ":"\r\n 使用块的语法节点。\r\n \r\n"," is `expr.Length` where `expr` is equivalent\r\n            to the ":" 是`expr.length white`expr'是等效的\r\n            到\r\n","\r\n Represents a VB location in source code or metadata.\r\n ":"\r\n 代表源代码或元数据中的VB位置。\r\n \r\n","\r\n            Base class to represent a pattern constructed from various checks\r\n            ":"\r\n            基础类代表从各种检查构建的模式\r\n            \r\n","\r\n The value for the EqualsToken property.\r\n ":"\r\n 平等属性的价值。\r\n \r\n","\r\n            Given a list of completion items that match the current code typed by the user,\r\n            returns the item that is considered the best match, and whether or not that\r\n            item should be selected or not.\r\n            \r\n            itemToFilterText provides the values that each individual completion item should\r\n            be filtered against.\r\n            ":"\r\n            给定一个匹配用户键入当前代码的完成项的列表，\r\n            返回被认为是最佳匹配的项目，以及是否\r\n            项目应选择与否。\r\n            \r\n            ItemTofilterText提供了每个单独完成项应\r\n            被过滤。\r\n            \r\n"," will return True. \r\n If this returns False, neither ":" 将返回真。\r\n 如果这返回false，则不会\r\n","\r\n Returns a copy of this with the GreaterThanToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此的副本，其中大通道的财产更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            Documentation file copy or null if there is none.\r\n            ":"\r\n            文档文件副本或null如果没有。\r\n            \r\n","\r\n Returns platform invocation information for this method if it is a PlatformInvoke method, otherwise returns Nothing.\r\n ":"\r\n 返回该方法的平台调用信息，如果它是一种platforminvoke方法，否则什么都不返回。\r\n \r\n","\r\n A list of expressions denoting the arrays to erase.\r\n ":"\r\n 表示删除阵列的表达式列表。\r\n \r\n","\r\n The boolean expression that controls the While loop.\r\n ":"\r\n 控制WHIL循环的布尔表达。\r\n \r\n","\r\n            Returns a sequence of groups of projects to process.  The sequence is in priority order, and all projects in\r\n            a particular group should be processed before the next group.  This allows us to associate CPU resources in\r\n            likely areas the user wants, while also still allowing for good parallelization.  Specifically, we consider\r\n            the active-document the most important to get results for, as some users use navigate-to to navigate within\r\n            the doc they are editing.  So we want those results to appear as quick as possible, without the search for\r\n            them contending with the searches for other projects for CPU time.\r\n            ":"\r\n            返回一系列项目进行处理。该序列是优先顺序的，所有项目中的所有项目\r\n            应在下一个组之前处理特定组。这使我们能够将CPU资源关联到\r\n            用户可能想要的领域，同时还允许良好的并行化。具体来说，我们考虑\r\n            有效文档获得结果最重要，因为某些用户使用导航到导航\r\n            他们正在编辑的文档。因此，我们希望这些结果尽可能快地出现，而无需搜索\r\n            他们与CPU时间有关其他项目的搜索。\r\n            \r\n","\r\n Gets the merged root namespace that contains all namespaces and types defined in source code or in \r\n referenced metadata, merged into a single namespace hierarchy. This namespace hierarchy is how the compiler\r\n binds types that are referenced in code.\r\n ":"\r\n 获取合并的根名称空间，该空间包含源代码或中定义的所有名称空间和类型\r\n 引用元数据，合并为单个名称空间层次结构。此名称空间层次结构是编译器的方式\r\n 绑定代码中引用的类型。\r\n \r\n","\r\n Returns a copy of this with the Contents property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回其中的副本，其中内容属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            Renames the file to match the type contained in it.\r\n            ":"重命名文件以匹配其中包含的类型。\r\n            \r\n","\r\n Gets the attributes applied on this symbol.\r\n Returns an empty array if there are no attributes.\r\n ":"\r\n 获取在此符号上应用的属性。\r\n 如果没有属性，则返回一个空数组。\r\n \r\n","\r\n Gets a value indicating whether this instance is overridable.\r\n ":"\r\n 获取一个指示此实例是否过多的值。\r\n \r\n","\r\n  Looks up a localized string similar to 'Shared' attribute property '{0}' cannot be the target of an assignment..\r\n":"\r\n  查找类似于“共享”属性属性'{0}'的本地化字符串不能成为分配的目标。\r\n\r\n","The \"MM\" custom format specifier represents the month as a number from 01 through 12 (or from 1 through 13 for calendars that have 13 months). A single-digit month is formatted with a leading zero.":"“ MM”自定义格式指定符表示该月的数字为01至12（或13个月的日历为1到13个）。单位月份的格式为零。\r\n","end-of-line comment":"在线评论\r\n","\r\n Gets a list of all the diagnostics associated with the token and any related trivia.\r\n ":"\r\n 获取与令牌和任何相关琐事相关的所有诊断列表。\r\n \r\n","\r\n            Locates all the call sites of the method that introduced the parameter\r\n            ":"\r\n            找到引入参数的方法的所有呼叫位点\r\n            \r\n","\r\n The base class for all nodes that represent executable statements.\r\n ":"\r\n 所有表示可执行语句的节点的基类。\r\n \r\n","\r\n The text.\r\n ":"\r\n 文本。\r\n \r\n","\r\n The \"End Sub\" or \"End Function\" statement that ends the block.\r\n ":"\r\n 结束块的“端sub”或“ end函数”语句。\r\n \r\n","\r\n Verify the constant value matches the default value from any earlier attribute\r\n (DateTimeConstantAttribute or DecimalConstantAttribute).\r\n If not, report ERR_FieldHasMultipleDistinctConstantValues.\r\n ":"\r\n 验证从任何早期属性的常数值匹配默认值\r\n （DateTimeConstantAttribute或DecimalConstantAttribute）。\r\n 如果不是，请报告err_fieldhasmultipledistincconstantvalues。\r\n \r\n","\r\n True if implicit variable declaration is done (binder is frozen and doesn't\r\n allow additional implicit variable declaration)\r\n ":"如果完成隐式变量声明，则为true（活页夹被冻结并且不\r\n 允许其他隐式变量声明）\r\n \r\n","\r\n            Represents a runtime execution context for scripts.\r\n            ":"代表脚本的运行时执行上下文。\r\n            \r\n","Since nodes are immutable, the only way to create nodes with errors attached is to create a node without an error,\r\n then add an error with this method to create another node.":"由于节点是不可变的，因此创建带有错误的节点的唯一方法是创建一个节点而无需错误，\r\n 然后在此方法中添加错误来创建另一个节点。\r\n"," Check for (and assert that there are no) duplicate case labels in the switch. ":" 检查（并断言开关中没有重复的案例标签。\r\n","\r\n Gets the constructor used in this application of the attribute as an ":"\r\n 在此应用程序中使用构造函数作为一个\r\n"," and the span of ":" 还有\r\n","\r\n            Given the cursor position, find which parameter is selected.\r\n            Returns 0 as the default value. Note that the ChangeSignature dialog adjusts the selection for\r\n            the `this` parameter in extension methods (the selected index won't remain 0).\r\n            ":"\r\n            给定光标位置，查找选择哪个参数。\r\n            返回0作为默认值。请注意，变更符号对话框调整了选择\r\n            扩展方法中的“此”参数（所选索引将保留为0）。\r\n            \r\n","\r\n Tests whether or not the method or property group should be bound without arguments. \r\n In case of method group it may also update the group by filtering out all subs\r\n ":"\r\n 测试方法或属性组是否应在没有参数的情况下被绑定。\r\n 对于方法组，它也可以通过滤除所有潜艇来更新组\r\n \r\n","asynchronous foreach statement":"异步语句\r\n","\r\n The list of contained PEModuleSymbol objects.\r\n The list doesn't use type ReadOnlyCollection(Of PEModuleSymbol) so that we\r\n can return it from Modules property as is.\r\n ":"\r\n 包含的pemodulesymbol对象的列表。\r\n 该列表不使用type readonLyCollection（pemodulesymbol的），以便我们\r\n 可以按原样从模块属性返回。\r\n \r\n","Space preferences":"空间偏好\r\n","\r\n Name of the namespace, must be not empty.\r\n ":"\r\n 名称的名称必须不为空。\r\n \r\n","\r\n A map of types immediately contained within this namespace \r\n grouped by their name (case-insensitively).\r\n ":"\r\n 此名称空间中立即包含的类型地图\r\n 按其名称分组（casemonsitationally）。\r\n \r\n","\r\n Set the current state to one that indicates that it is unreachable.\r\n ":"\r\n 将当前状态设置为表明其无法达到的一种状态。\r\n \r\n"," belongs to multiple declarations,\r\n            such as in VB ":" 属于多个声明，\r\n            例如在VB中\r\n","\r\n  Looks up a localized string similar to \r\n    Extension method '{0}' defined in '{1}'..\r\n":"\r\n  查找类似于\r\n    扩展方法'{0}'在'{1}'..中定义\r\n\r\n","\r\n Dim x = FROM {1, 2, 3}\r\n\r\n ":"\r\n dim x =来自{1、2、3}\r\n\r\n \r\n","white-space character":"白空间角色\r\n"," in C# 9 and above.\r\n            ":" 在C＃9及以上。\r\n            \r\n","\r\n Returns true if the node is the operand of an AddressOf expression\r\n ":"\r\n 如果节点是地址表达式的操作数，则返回true\r\n \r\n","\r\n Returns a string that represents the current object.\r\n ":"\r\n 返回表示当前对象的字符串。\r\n \r\n","A ImmutableArray of diagnostics.":"诊断的不可投射。\r\n","\r\n Include the InternalXmlHelper.Value extension property in the LookupResult\r\n if the container implements IEnumerable(Of XElement), the name is \"Value\",\r\n and the arity is 0.\r\n ":"\r\n 在LookupResult中包括InternalXmlhelper.Value扩展属性\r\n 如果容器实现Ienumerable（Xlement），则名称为“ value”，\r\n 而arity是0。\r\n \r\n","Collection initialization can be simplified":"收集初始化可以简化\r\n","\r\n  Looks up a localized string similar to Lambda expressions are not valid in the first expression of a 'Select Case' statement..\r\n":"\r\n  在“选择案例”语句的第一个表达式中查找类似于lambda表达式的本地化字符串。\r\n\r\n"," from specified metadata. \r\n  ":"来自指定的元数据。\r\n  \r\n","The item to be committed.":"要投入的项目。\r\n","\r\n            internal status of result. more fine grained reason why it is failed. \r\n            ":"\r\n            结果的内部状态。更细的谷物原因导致失败。\r\n            \r\n"," will represent the file at the time this hint was created.\r\n            ":" 将在创建此提示时表示文件。\r\n            \r\n","\r\n A SyntaxTree is a tree of nodes that represents an entire file of VB\r\n code, and is parsed by the parser.\r\n ":"\r\n 语法是一个节点树，代表VB的整个文件\r\n 代码，并由解析器解析。\r\n \r\n","The symbol checker which performs additional checks.":"执行其他检查的符号检查器。\r\n","A sequence of token to be interleaved between the nodes. The number of tokens must\r\n be one less than the number of nodes.":"一系列代币在节点之间交织的序列。代币的数量必须\r\n 比节点的数量少一个。\r\n","\r\n Given a parameter declaration, get the corresponding parameter symbol.\r\n ":"\r\n 给定参数声明，获取相应的参数符号。\r\n \r\n","\r\n The \"End Structure\" statement that ends the block.\r\n ":"\r\n 结束块的“最终结构”语句。\r\n \r\n","\r\n Create a missing identifier.\r\n ":"\r\n 创建缺失的标识符。\r\n \r\n","Updating the variance of {0} requires restarting the application.":"更新{0}的方差需要重新启动应用程序。\r\n"," \r\n One of the methods has more parameters than the other \r\n AND \r\n at least one of the extra parameters is NOT optional\r\n ":" \r\n 其中一种方法比其他方法具有更多的参数\r\n 和\r\n 至少一个额外的参数不是可选的\r\n \r\n","Add 'this.'":"添加“这个。”\r\n","\r\n  Looks up a localized string similar to Exponent is not valid..\r\n":"\r\n  查找类似于指数的本地化字符串无效。\r\n\r\n","\r\n The name of the event being raised.\r\n ":"活动的名称正在提出。\r\n \r\n","\r\n Get the type parameters on this method. If the method has not generic,\r\n returns an empty list.\r\n ":"\r\n 在此方法上获取类型参数。如果该方法没有通用，\r\n 返回一个空列表。\r\n \r\n","\r\n If \"nameSyntax\" resolves to an alias name, return the AliasSymbol corresponding\r\n to A. Otherwise return null.\r\n ":"\r\n 如果“ nameyntax”解析为别名名称，请返回别扬symbol对应\r\n 向A.否则返回null。\r\n \r\n","\r\n            Whether to make the member abstract when added to the new class\r\n            ":"\r\n            将成员摘要添加到新课程时是否使成员摘要\r\n            \r\n","Use block body for indexers":"使用块主体作为索引器\r\n"," with all the new\r\n            local declaration statements annotated with ":" 所有新的\r\n            注释的本地声明声明\r\n","\r\n Return correspondent expression syntax for 'Me', 'MyBase' and 'MyClass' \r\n keywords or SyntaxKind.None for other syntax kinds\r\n ":"\r\n 返回“我”，“ mybase”和“ myclass”的通讯语法\r\n 关键字或语法。其他语法类型\r\n \r\n","\r\n  Looks up a localized string similar to Attribute cannot be used because it does not have a Public constructor..\r\n":"\r\n  查找类似于属性的本地化字符串，因为它没有公共构造函数。\r\n\r\n","\r\n  Looks up a localized string similar to Cannot infer an element type because more than one type is possible. Specifying the type of the array might correct this error..\r\n":"\r\n  查找类似于不能推断元素类型的本地化字符串，因为可以多种类型。指定数组的类型可能会纠正此错误。\r\n\r\n","\r\n Represents an OnError Goto statement.\r\n ":"\r\n 代表OnError Goto声明。\r\n \r\n","\r\n Represents a declaration of Module, its contents and the End statement that\r\n ends it.\r\n ":"\r\n 代表模块的声明，其内容和最终声明\r\n 结束它。\r\n \r\n","\r\n  Looks up a localized string similar to Argument matching parameter '{0}' narrows from '{1}' to '{2}'..\r\n":"\r\n  查找类似于参数匹配参数'{0}'narrows的本地化字符串，从'{1}'到'{2}'..\r\n\r\n","There is no target type for '{0}'":"没有目标类型的“ {0}”\r\n","\r\n Perform overload resolution on the given method group, with the given arguments.\r\n ":"\r\n 用给定参数对给定方法组执行过载分辨率。\r\n \r\n","The locals.":"当地人。\r\n","\r\n            Get diagnostics for the given document.\r\n            \r\n            This is a simple API to get all diagnostics for the given document.\r\n            \r\n            The intended audience for this API is for ones that pefer simplicity over performance such as document that belong to misc project.\r\n            this doesn't cache nor use cache for anything. it will re-caculate new diagnostics every time for the given document.\r\n            it will not persist any data on disk nor use OOP to calculate the data.\r\n            \r\n            This should never be used when performance is a big concern. for such context, use much complex API from IDiagnosticAnalyzerService\r\n            that provide all kinds of knobs/cache/persistency/OOP to get better perf over simplicity.\r\n            ":"\r\n            获取给定文档的诊断。\r\n            \r\n            这是一个简单的API，可以为给定文档获得所有诊断。\r\n            \r\n            此API的预期受众是针对那些对性能的简单性的，例如属于MISC项目的文档。\r\n            这不会缓存或使用缓存。它将每次为给定文档重新计算新的诊断。\r\n            它不会持续存在磁盘上的任何数据，也不会使用OOP来计算数据。\r\n            \r\n            当性能是一个很大的问题时，绝不应该使用这种情况。对于这种情况，请使用Idingnosticanalyzerservice的许多复杂API\r\n            提供各种旋钮/缓存/持久性/OOP，以使其更加完善。\r\n            \r\n","\r\n            \r\n             Note: this analyzer can be updated to run on VB once VB supports 'throw'\r\n             expressions as well.\r\n             ":"\r\n            \r\n             注意：一旦VB支持“投掷”，可以更新此分析仪以在VB上运行\r\n             表达也是。\r\n             \r\n","\r\n Symbols representing constructed generic type that isn't contained within another constructed generic type.\r\n For example: A(Of Integer), A.B(Of Integer), but not A(Of Integer).B.C(Of Integer).\r\n ":"\r\n 代表其他构造的通用类型中不包含的构造的通用类型的符号。\r\n 例如：A（整数），A.B（整数），而不是（整数）.b.c（整数）。\r\n \r\n","\r\n An error type symbol to represent a pointer type.\r\n Pointer types are not supported by VB language, but internally\r\n we need to be able to match them in signatures of methods \r\n imported from metadata.\r\n ":"\r\n 一个错误类型符号代表指针类型。\r\n 指针类型不受VB语言的支持，而是内部的\r\n 我们需要能够在方法的签名中匹配它们\r\n 从元数据进口。\r\n \r\n"," is converted\r\n before being converted to the iteration variable type.\r\n ":" 被转换\r\n 在转换为迭代变量类型之前。\r\n \r\n","\r\n            Generates a method declaration containing a call to the method that introduced the parameter.\r\n            Example:\r\n            \r\n            ***This is an intermediary step in which the original function has not be updated yet\r\n            public void M(int x, int y)\r\n            {\r\n                int f = [|x * y|];\r\n            }\r\n            \r\n            ---------------------------------------------------->\r\n            \r\n            public void M(int x, int y) // Generated overload\r\n            {\r\n                M(x, y, x * y);\r\n            }\r\n            \r\n            public void M(int x, int y) // Original function (which will be mutated in a later step)\r\n            {\r\n                int f = x * y;\r\n            }\r\n            ":"生成一个方法声明，该声明包含对引入参数的方法的调用。\r\n            例子：\r\n            \r\n            ***这是一个尚未更新原始功能的中介步骤\r\n            公共空白M（int x，int y）\r\n            {\r\n                int f = [| x * y |];\r\n            }\r\n            \r\n            ------------------------------------------------------------------------------------ - >\r\n            \r\n            公共void m（int x，int y）//生成的超载\r\n            {\r\n                m（x，y，x * y）;\r\n            }\r\n            \r\n            公共void m（int x，int y）//原始功能（将在以后的步骤中突变）\r\n            {\r\n                int f = x * y;\r\n            }\r\n            \r\n","\r\n Note that identity conversion are also considered widening conversions.\r\n ":"\r\n 请注意，身份转换也被认为是扩大转化率。\r\n \r\n","\r\n This class represents a compiler generated parameterless constructor \r\n ":"\r\n 该类代表编译器生成的无参数构造函数\r\n \r\n","\r\n Match local declarations to names to generate a map from\r\n declaration to local slot. The names are indexed by slot And the\r\n assumption Is that declarations are in the same order as slots.\r\n ":"\r\n 将本地声明与名称匹配，以生成地图\r\n 声明本地插槽。名称由插槽和\r\n 假设声明与插槽的顺序相同。\r\n \r\n","\r\n This instance is used to search for properties that have identical signatures in every regard.\r\n ":"\r\n 此实例用于搜索在各个方面具有相同签名的属性。\r\n \r\n","\r\n  Looks up a localized string similar to Cannot embed interop type '{0}' found in both assembly '{1}' and '{2}'. Consider disabling the embedding of interop types..\r\n":"查找类似于不能嵌入Interop类型'{0}'的本地化字符串，在两个汇编'{1}'和'{2}'中都找到。考虑禁用Interop类型的嵌入。\r\n\r\n","Add both":"同时添加\r\n","\r\n A list of the supplied constraints. If no constraints were supplied, an empty\r\n list is returned.\r\n ":"\r\n 提供的约束列表。如果没有提供约束，则空\r\n 列表已返回。\r\n \r\n","\r\n Checks if the expression is a default value (0 or Nothing)\r\n ":"\r\n 检查表达式是否为默认值（0或没有）\r\n \r\n","\r\n Represents parameter of a curried extension method definition.\r\n ":"\r\n 表示咖喱扩展方法定义的参数。\r\n \r\n","\r\n            operation status paired with data\r\n            ":"\r\n            操作状态与数据配对\r\n            \r\n","\r\n Determines whether derivedType is, inherits from or implements the given interface.\r\n ":"\r\n 确定derivedType是从给定的接口中继承还是实现。\r\n \r\n","using declarations":"使用声明\r\n","\r\n Represents a parenthesized expression.\r\n ":"\r\n 代表括号的表达。\r\n \r\n"," is going to\r\n             preserve semantics.":" 要去\r\n             保存语义。\r\n","\r\n Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or\r\n associated with the token and its related trivia.\r\n ":"\r\n 在将指定节点作为root或\r\n 与令牌及其相关的琐事相关。\r\n \r\n","\r\n Determines whether the current object is equal to another object of the same type.\r\n ":"\r\n 确定当前对象是否等于同一类型的另一个对象。\r\n \r\n","\r\n            True for Edit and Continue edit sessions - when the application is in break state.\r\n            False for Hot Reload edit sessions - when the application is running.\r\n            ":"\r\n            编辑并继续编辑会话 - 当应用程序处于断点状态时。\r\n            false用于热加载编辑会话 - 应用程序正在运行时。\r\n            \r\n","\r\n            The nullable flow state to show in Quick Info; will be ":"\r\n            快速信息中显示的无效流状态；将会\r\n","The +? quantifier matches the preceding element one or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier +":"+？量词匹配前面的元素一次或多次，但尽可能少次。这是贪婪量词 +的懒惰对应物\r\n","The \\Z anchor specifies that a match must occur at the end of the input string, or before \\n at the end of the input string. It is identical to the $ anchor, except that \\Z ignores the RegexOptions.Multiline option. Therefore, in a multiline string, it can ...":"\\ z锚指定必须在输入字符串的末端或在输入字符串末尾进行匹配。它与$锚相同，只是\\ z忽略了regexoptions.multiline选项。因此，在多行字符串中，它可以...\r\n","\r\n  Looks up a localized string similar to Interface in an interface cannot be declared '{0}'..\r\n":"\r\n  查找与接口类似的局部字符串，无法声明“ {0}”。\r\n\r\n","\r\n  Looks up a localized string similar to Failed to emit module '{0}'..\r\n":"\r\n  查找类似于失败的局部字符串，以发射模块'{0}'..\r\n\r\n"," that represents\r\n a module that couldn't be found.\r\n ":" 代表\r\n 找不到的模块。\r\n \r\n","\\w matches any word character. A word character is a member of any of the following Unicode categories:\r\n            \r\n                Ll\tLetter, Lowercase\r\n                Lu\tLetter, Uppercase\r\n                Lt\tLetter, Titlecase\r\n                Lo\tLetter, Other\r\n                Lm\tLetter, Modifier\r\n                Mn\tMark, Nonspacing\r\n                Nd\t ...":"\\ w匹配任何单词字符。单词字符是以下任何一个Unicode类别的成员：\r\n            \r\n                LL字母，小写\r\n                lu信，大写\r\n                上字母，滴定酶\r\n                LO信，其他\r\n                LM字母，修饰符\r\n                Mn Mark，非大个子\r\n                ND ...\r\n"," if the diagnostic is reported on unnecessary code; otherwise, ":" 如果报告了不必要的代码的诊断；否则，\r\n","Enums, classes, and structures cannot be declared in an interface that has an 'in' or 'out' type parameter.":"枚举，类和结构不能在具有“ in”或“ out”类型参数的接口中声明。\r\n","'{0}' cannot be null or whitespace.":"'{0}'不能为零或空格。\r\n","\r\n  Looks up a localized string similar to '{0}' is not a valid value for /moduleassemblyname.\r\n":"\r\n  查找类似于“ {0}”的本地化字符串不是 /moduleassemblyname的有效值。\r\n\r\n","\r\n The value for the EachKeyword property.\r\n ":"\r\n 每个关键字属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to 'Sub New' cannot be declared 'Partial'..\r\n":"\r\n  查找类似于“ sub new”的本地化字符串，不能声明为“部分”。\r\n\r\n","\r\n  Looks up a localized string similar to 'NotInheritable' classes cannot have members declared '{0}'..\r\n":"\r\n  查找类似于“ Notherableable”类的本地化字符串不能使成员声明为“ {0}”。\r\n\r\n","\r\n Can be null in error cases.\r\n ":"\r\n 在错误情况下可以无效。\r\n \r\n","\r\n True if this ":"\r\n 如果这个是正确的\r\n","\r\n Represents a reference to a type nested in an instantiation of a generic type.\r\n e.g. \r\n A{int}.B\r\n A.B{int}.C.D\r\n ":"\r\n 表示对嵌套在通用类型的实例化中的类型的引用。\r\n 例如\r\n a {int} .b\r\n a.b {int} .c.d\r\n \r\n","\r\n Many of the methods want to generically work on properties, methods (and maybe events) as TSymbol. We put all these\r\n methods into a generic class for convenience.\r\n ":"\r\n 许多方法都希望通过属性，方法（可能是事件）作为TSYMBOL。我们把所有这些\r\n 为了方便起见，方法成通用类。\r\n \r\n","Add reference to '{0}'.":"将引用添加到'{0}'。\r\n","\r\n For the property to be considered valid, accessor signatures must be consistent\r\n with each other, and accessor signatures must be consistent with the property\r\n signature ignoring ByRef. These requirements are stricter than Dev11 which\r\n allows many inconsistencies including different numbers of parameters.\r\n ":"\r\n 为了将属性视为有效，登录器签名必须保持一致\r\n 彼此之间，登录签名必须与属性一致\r\n 签名忽略Byref。这些要求比Dev11更严格\r\n 允许许多矛盾之处，包括不同数量的参数。\r\n \r\n","\r\n            Specifies the encoding to be used when debugging scripts loaded from a file, or saved to a file for debugging purposes.\r\n            If it's null, the compiler will attempt to detect the necessary encoding for debugging\r\n            ":"\r\n            指定从文件加载或保存到文件以进行调试目的时使用的编码。\r\n            如果是空的，则编译器将尝试检测到调试的必要编码\r\n            \r\n","\r\n            For preview purposes we return all the operations in a list.  This way the \r\n            preview system stiches things together in the UI to make a suitable display.\r\n            i.e. if we have a SolutionChangedOperation and some other operation with a \r\n            Title, then the UI will show that nicely to the user.\r\n            ":"\r\n            为了预览，我们返回列表中的所有操作。这样\r\n            预览系统将东西固定在UI中以进行合适的显示。\r\n            即，如果我们有解决方案交换和其他操作\r\n            标题，然后UI将对用户很好地显示出来。\r\n            \r\n","A bound call to MoveNext on the instance returned by GetEnumerator if found.":"如果找到了GetEnumerator返回的实例上的MoveNext的绑定呼叫。\r\n","\r\n  Looks up a localized string similar to Generic methods cannot be exposed to COM..\r\n":"\r\n  查找类似于通用方法的本地化字符串不能暴露于com。\r\n\r\n","\r\n Get the syntax node(s) where this symbol was declared in source. Some symbols (for example,\r\n partial classes) may be defined in more than one location. This property should return\r\n one or more syntax nodes only if the symbol was declared in source code and also was\r\n not implicitly declared (see the IsImplicitlyDeclared property). \r\n \r\n Note that for namespace symbol, the declaring syntax might be declaring a nested namespace.\r\n For example, the declaring syntax node for N1 in \"Namespace N1.N2\" is the \r\n NamespaceDeclarationSyntax for N1.N2. For the project namespace, the declaring syntax will\r\n be the CompilationUnitSyntax.\r\n ":"\r\n 获取在源中声明此符号的语法节点。一些符号（例如，\r\n 部分类）可以在多个位置定义。此属性应返回\r\n 仅在源代码中声明符号并且是一个或多个语法节点，并且\r\n 没有隐式声明（请参见IsimplicerDeclared属性）。\r\n \r\n 请注意，对于名称空间符号，声明的语法可能会声明一个嵌套的名称空间。\r\n 例如，“命名空间n1.n2”中N1的声明语法节点是\r\n n1.n2的namespacedeclarationsyntax。对于项目名称空间，声明的语法将\r\n 成为汇编单数。\r\n \r\n","\r\n The \"Finally\" keyword.\r\n ":"\r\n “最后”关键字。\r\n \r\n","Local function can be made static":"可以使本地功能静态\r\n","\r\n  Looks up a localized string similar to Operator '{0}' is not defined for types '{1}' and '{2}'. You can use the 'Value' property to get the string value of the first element of '{3}'..\r\n":"\r\n  查找类似于运算符'{0}'的本地化字符串，不是针对'{1}'和'{2}'定义的。您可以使用'value'属性获取“ {3}”的第一个元素的字符串值。\r\n\r\n","\r\n            Analyzes the first parsed tree to determine the set of capture numbers and names.  These are\r\n            then used to do the second parsing pass as they can change how the regex engine interprets\r\n            some parts of the pattern (though not the groups themselves).\r\n            ":"分析第一个解析树，以确定捕获数字和名称的集合。这些是\r\n            然后用来进行第二次解析，因为他们可以更改正则发动机的解释方式\r\n            模式的某些部分（尽管不是群体本身）。\r\n            \r\n","Method '{0}' specifies a 'default' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is constrained to a reference type or a value type.":"方法'{0}'指定类型参数'{1}'的'默认约束'，但相应的类型参数'{2}'被覆盖或显式实现的方法'{3}'{3}'被限制为参考类型或值类型。\r\n","Wrap call chain":"包装链条\r\n",", and any remaining spans can be analyzed by\r\n            ":"，任何剩余的跨度都可以通过\r\n            \r\n","immediately":"立即地\r\n","\r\n Returns a copy of this with the LetKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"将其返回此副本，其中letkeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n  Looks up a localized string similar to Unable to load referenced library '{0}': {1}.\r\n":"\r\n  查找类似于无法加载引用的库'{0}'的本地化字符串：{1}。\r\n\r\n","\r\n Translates anonymous type method symbol into an implementation method symbol to be used in emit.\r\n ":"\r\n 将匿名类型方法符号转换为要在EMIT中使用的实现方法符号。\r\n \r\n","\r\n            Support ErrorSource information.\r\n            ":"\r\n            支持错误信息。\r\n            \r\n","\r\n            Common interface used by both local Roslyn and LSP to implement\r\n            their specific versions of FixAllSuggestedAction.\r\n            ":"\r\n            本地罗斯林和LSP都使用的常见界面来实施\r\n            他们的特定版本的fixallsuggestectactaction。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Default' cannot be combined with '{0}'..\r\n":"\r\n  查找类似于“默认”的本地化字符串，不能与“ {0}”结合使用。\r\n\r\n","\r\n Represents an XML name of the form <xml-name> appearing in source as part\r\n of an XML literal or member access expression or an XML namespace import\r\n clause.\r\n ":"\r\n 表示形式<xml-name>出现在源中的XML名称作为一部分\r\n XML文字或成员访问表达式或XML名称空间导入\r\n 条款。\r\n \r\n","Use simple 'using' statement":"使用简单的“使用”语句\r\n","'{0}': extern event cannot have initializer":"'{0}'：Extern事件不能具有初始化器\r\n","\r\n Symbol for the type, or MissingMetadataSymbol if the type isn't found.\r\n ":"\r\n 如果找不到类型，则类型或丢失的构成符号。\r\n \r\n",".\r\n            We use this value in ":"。\r\n            我们在\r\n","\r\n A list of modules the assembly consists of. \r\n The first (index=0) module is a SourceModuleSymbol, which is a primary module, the rest are net-modules.\r\n ":"\r\n 组件包含的模块列表。\r\n 第一个（索引= 0）模块是一个sourcemodulesymbol，它是主模块，其余的是净模块。\r\n \r\n","\r\n            Quantifiers can be optionally followed by a ? to make them lazy.  i.e. ```a*?``` or ```a+?```.\r\n            You can even have ```a??```  (zero or one 'a', lazy).  However, only one lazy modifier is allowed\r\n            ```a*??``` or ```a???``` is not allowed.\r\n            ":"\r\n            可以选择量化量子？使他们懒惰。即````a*''````````'''a+？````''。\r\n            您甚至可以拥有``a ??````````'（零或一个'a'，懒惰）。但是，只允许一个懒惰的修饰符\r\n            ````a*??``````a a ???````不允许。不允许。\r\n            \r\n","The type argument for IEnumerable(Of ...)":"iEnumerable的类型参数（...）\r\n","\r\n  Looks up a localized string similar to 'AddressOf' expression cannot be converted to '{0}' because type '{0}' is declared 'MustInherit' and cannot be created..\r\n":"\r\n  查找类似于“地址”表达式的本地化字符串不能转换为'{0}'，因为类型'{0}'被声明为'MustInherit'，也不能创建。\r\n\r\n","\r\n Contextual Nodekind\r\n ":"\r\n 上下文nodekind\r\n \r\n",".\r\n Assumes that the public key has been determined. The result will be cached.\r\n ":"。\r\n 假设已确定了公钥。结果将被缓存。\r\n \r\n","filter clause":"过滤条款\r\n","\r\n  Looks up a localized string similar to Events in interfaces cannot be declared '{0}'..\r\n":"\r\n  查找类似于接口中事件的本地化字符串，无法声明“ {0}”。\r\n\r\n","vertical-tab character":"垂直标签字符\r\n","Changing the type of a captured variable '{0}' previously of type '{1}' requires restarting the application.":"更改以前类型'{1}'的捕获变量的类型需要重新启动应用程序。\r\n"," \r\n Only used in flow analysis for the pseudo-local representing a symbol \r\n of the implicit receiver in case Dim statement defines more than one \r\n variable, but uses the same object initializer for all of them, like in: \r\n     Dim a,b As New C() With { .X = .Y } \r\n ":" \r\n 仅用于伪本地的流量分析代表符号\r\n 如果dim语句定义了多个\r\n 可变，但使用相同的对象初始化器，例如：\r\n     dim a，b作为{.x = .y}的新C（）\r\n \r\n","\r\n            The definition item corresponding to the initial symbol the user was trying to find. This item should get\r\n            prominent placement in the final UI for the user.\r\n            ":"\r\n            与用户试图找到的初始符号相对应的定义项目。这个项目应该得到\r\n            在最终UI中为用户提供了突出的位置。\r\n            \r\n","\r\n            Returns the text changes necessary to format the document after the user enters a Return\r\n            The position provided is the position of the caret in the document after Return.":"\r\n            在用户输入返回后，返回文本更改以格式化文档\r\n            所提供的位置是返回后在文档中的位置。\r\n","\r\n This represents what the user claimed in source through the AssemblyFlagsAttribute.\r\n It may be modified as emitted due to presence or absence of the public key.\r\n ":"\r\n 这代表用户通过汇编FlagSattribute在源中声称的内容。\r\n 由于存在或不存在公共密钥，因此可以将其修改为发射。\r\n \r\n","\r\n            Helper class to detect regex pattern tokens in a document efficiently.\r\n            ":"\r\n            辅助类可以有效地检测文档中的Regex模式令牌。\r\n            \r\n","\r\n where page maps in the stream. Used to validate pages\r\n ":"\r\n 流中的页面地图。用于验证页面\r\n \r\n","relational pattern":"关系模式\r\n","\r\n The value for the WithEventsContainer property.\r\n ":"\r\n withEventsContainer属性的值。\r\n \r\n","\r\n Represents the \"Order By\" query operator.\r\n ":"\r\n 代表“订单”查询操作员。\r\n \r\n","out variable":"输出变量\r\n","Invalid data format.":"无效的数据格式。\r\n","\r\n Creates a syntax tree by parsing the source text.\r\n ":"\r\n 通过解析源文本来创建语法树。\r\n \r\n","Do not use '_' to refer to the type in an is-type expression.":"请勿使用“ _”来指代IS-Type表达式中的类型。\r\n","The switch expression does not handle some null inputs (it is not exhaustive). For example, the pattern '{0}' is not covered. However, a pattern with a 'when' clause might successfully match this value.":"开关表达式无法处理某些空输入（并不详尽）。例如，未涵盖模式'{0}'。但是，具有“ Whes”子句的模式可能会成功匹配此值。\r\n","\r\n Returns a copy of this with the EqualsKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中EqualsKeyWord属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n"," and cannot be removed.\r\n            ":" 并且不能删除。\r\n            \r\n","\r\n            Indicate whether it would cause error if we directly pull Member into destination.\r\n            ":"指示如果我们直接将成员拉入目的地，是否会导致错误。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Warning' expected..\r\n":"\r\n  查找类似于预期的“警告”的本地化字符串。\r\n\r\n","\r\n Given instance method candidates gone through applicability analysis, \r\n figure out if we should consider extension methods, if any.\r\n ":"给定实例方法候选者进行了适用性分析，\r\n 弄清楚我们是否应该考虑扩展方法（如果有）。\r\n \r\n","\r\n The value for the AsKeyword property.\r\n ":"\r\n ASKeyWord属性的值。\r\n \r\n","\r\n Returns a copy of this with the Events property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，事件属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n The value for the Type property.\r\n ":"\r\n 类型属性的值。\r\n \r\n","\r\n Determine if the given string starts with the given prefix if whitespace\r\n is first trimmed from the beginning.\r\n ":"\r\n 确定给定的字符串是否以给定前缀开始\r\n 首先从头开始修剪。\r\n \r\n","\r\n Creates a syntax node for a priliminary element within a xml documentation comment.\r\n ":"\r\n 在XML文档注释中为PRILIMINAL元素创建语法节点。\r\n \r\n","destructor":"驱动器\r\n","\r\n Report a diagnostic, and also produce an error expression with error type.\r\n ":"\r\n 报告诊断，还会产生错误类型的错误表达式。\r\n \r\n","\r\n Determine if two interfaces that were constructed from the same original definition\r\n have variance ambiguity.\r\n \r\n We have something like left=ICocon(Of Mammal, int32[]), right=ICocon(Of Fish, int32[])\r\n for some interface ICocon(Of Out T, In U). And we have to decide if left and right \r\n might lead to ambiguous member-lookup later on in execution.\r\n\r\n To do this: go through each type parameter T, U...\r\n   * For \"Out T\", judge whether the arguments Mammal/Fish cause ambiguity or prevent it.\r\n   * For \"In T\", judge whether the arguments int32[]/int32[] cause ambiguity or prevent it.\r\n\r\n \"Causing/preventing ambiguity\" is described further below.\r\n \r\n Given all that, ambiguity was prevented in any positions, then left/right are fine.\r\n Otherwise, if ambiguity wasn't caused in any positions, then left/right are fine.\r\n Otherwise, left/right have an ambiguity.\r\n ":"\r\n 确定是否从相同的原始定义构建两个接口\r\n 具有差异歧义。\r\n \r\n 我们有左= iCocon（哺乳动物，int32 []），右= icocon（fish，int32 []）之类的东西\r\n 对于某些接口ICOCON（在u中的out t）。我们必须决定左右是否\r\n 后来执行后可能会导致歧义成员的外观。\r\n\r\n 为此：浏览每种类型的参数t，u ...\r\n   *对于“ Out T”，请判断该论点是哺乳动物/鱼类引起歧义还是阻止它。\r\n   *对于“在t”中，判断论点int32 []/int32 []引起歧义或阻止它。\r\n\r\n 下面进一步描述了“引起/预防歧义”。\r\n \r\n 鉴于所有这些，在任何位置都可以防止歧义，然后左/右则可以。\r\n 否则，如果没有在任何位置上引起歧义，则左/右就可以了。\r\n 否则，左/右具有歧义。\r\n \r\n","\r\n Represents an \"Else ...\" block.\r\n ":"\r\n 代表一个“ else ...”块。\r\n \r\n","\r\n  Looks up a localized string similar to Anonymous type must contain at least one member..\r\n":"\r\n  查找类似于匿名类型的本地化字符串必须包含至少一个成员。\r\n\r\n","\r\n The value for the ForStatement property.\r\n ":"\r\n 外观属性的值。\r\n \r\n","\r\n Creates a singleton list of tokens.\r\n ":"\r\n 创建一个名字列表。\r\n \r\n","\r\n The name of the label. If the label is a line number, wraps an IntegerLiteral\r\n that is the line number, otherwise, wraps an Identifier.\r\n ":"\r\n 标签的名称。如果标签是行号，请包装一个IntegerLiteral\r\n 那就是行号，否则会包含标识符。\r\n \r\n","Apply implicit/explicit type preferences":"应用隐式/显式类型首选项\r\n","\r\n Returns a copy of this with the ConstKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 将其返回此副本，而Constkeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            Finds the matches of the expression within the same block.\r\n            ":"\r\n            在同一块中找到表达式的匹配。\r\n            \r\n","\r\n  Looks up a localized string similar to Properties in a Module cannot be declared '{0}'..\r\n":"\r\n  查找类似于模块中属性的本地化字符串，无法声明“ {0}”。\r\n\r\n"," Checks for validity of Construct(...) on this type with these type arguments. ":" 使用这些类型参数检查此类型的构建体有效性（...）。\r\n","\r\n            Syntax is \"nuget:name[/version]\".\r\n            ":"\r\n            语法是“ nuget：name [/version]”。\r\n            \r\n"," is ingrained in muscle memory and is more important to maintain versus\r\n            strict adherence to our normal textual matching procedure.  The user can always still get this item simply\r\n            by typing one additional character and unambiguously referring to ":" 在肌肉记忆中根深蒂固，维持与\r\n            严格遵守我们的正常文本匹配程序。用户总是可以简单地获取此项目\r\n            通过键入一个其他字符并明确指\r\n","\r\n The value for the EndCDataToken property.\r\n ":"\r\n EndCdatatoken属性的值。\r\n \r\n","The new caret position after the change has been applied. If null then the caret\r\n            position is not specified and will be determined by the completion host.":"更改后的新角色位置。如果无效，则\r\n            位置未指定，将由完成主机确定。\r\n","\r\n Returns the number of dimensions of this array. A regular single-dimensional array\r\n has rank 1, a two-dimensional array has rank 2, etc.\r\n ":"\r\n 返回此数组的尺寸数。常规的单维阵列\r\n 有等级1，二维阵列的等级为2，等等。\r\n \r\n","\r\n            Represents a shadow copy of a single file.\r\n            ":"\r\n            表示单个文件的阴影副本。\r\n            \r\n","\r\n The value for the IsKeyword property.\r\n ":"\r\n ISKeyWord属性的值。\r\n \r\n","\r\n            Contains helpers related to asking intuitive semantic questions about a users intent\r\n            based on the position of their caret or span of their selection.\r\n            ":"\r\n            包含与询问有关用户意图的直观语义问题有关的帮助者\r\n            基于他们的商标或选择的跨度。\r\n            \r\n","\r\n  Looks up a localized string similar to Matching '{0}' operator is required for '{1}'..\r\n":"\r\n  查找类似于“ {1}'..”的本地化字符串类似于匹配的“ {0}”运算符。\r\n\r\n","\r\n Introduce a frame around the translation of the given node.\r\n ":"\r\n 引入围绕给定节点的翻译框架。\r\n \r\n","\r\n Ignore accessibility when resolving well-known type\r\n members, in particular for generic type arguments\r\n (e.g.: binding to internal types in the EE).\r\n ":"\r\n 解决知名类型时忽略可访问性\r\n 成员，尤其是通用类型参数\r\n （例如：与EE中的内部类型结合）。\r\n \r\n",",\r\n             it feels very safe to assume this is well behaved and switching to ":"，，，，\r\n             假设这是表现良好的，并且切换到\r\n","\r\n            Documentation files are currently only supported for manifest modules, not modules included in an assembly.\r\n            ":"\r\n            目前，文档文件仅支持清单模块，而不是装配中包含的模块。\r\n            \r\n","?.":"？\r\n","Builder to add computed declarations.":"建造者添加计算的声明。\r\n","Rules about which keys typed are used to filter the list of completion items.":"使用哪个键的规则用于过滤完成项目列表。\r\n","\r\n            A TODO comment that has been found within the user's code.\r\n            ":"\r\n            在用户代码中发现的待办事项评论。\r\n            \r\n","\r\n Is this a reduced extension method?\r\n ":"\r\n 这是一种减少的扩展方法吗？\r\n \r\n","\r\n The value for the CaseStatement property.\r\n ":"\r\n Casestatement属性的值。\r\n \r\n","A syntax node that represents a parsed method declaration. This method should not be\r\n present in the syntax tree associated with this object, but must have identical signature to the method containing\r\n the given ":"表示解析方法声明的语法节点。此方法不应该是\r\n 存在与该对象关联的语法树中，但必须与包含的方法具有相同的签名\r\n 给定\r\n","ref extension methods":"参考扩展方法\r\n"," for methods, operators, constructors, destructors and accessors.\r\n            ":" 用于方法，操作员，构造函数，毁灭者和登录器。\r\n            \r\n","\r\n            Previous state of the script execution.\r\n            ":"\r\n            脚本执行的先前状态。\r\n            \r\n","Unnecessary assignment of a value to '{0}'":"对“ {0}'的值的不必要分配\r\n","The symbol to map":"映射的符号\r\n"," during emit.\r\n ":" 在发射期间。\r\n \r\n","\r\n            Clears all diagnostics reported thru this source.\r\n            We do not track the particular reported diagnostics here since we can just clear all of them at once.\r\n            ":"\r\n            清除所有诊断方法通过此消息来源报告。\r\n            我们在这里没有跟踪特定报告的诊断，因为我们可以一次清除所有这些诊断。\r\n            \r\n","P3":"P3\r\n","Field-like events are not allowed in readonly structs.":"在可读结构中不允许类似现场的事件。\r\n","\r\n            This service will implicitly cache previous Compilations used by each supported Workspace implementation.\r\n            The number of Compilations cached is determined by ":"\r\n            该服务将暗中缓存每个支持的工作空间实现使用的先前汇编。\r\n            缓存的汇编数量由\r\n","\r\n            Helper methods for pragma suppression add/remove batch fixers.\r\n            ":"\r\n            用于巴格马抑制的助手方法添加/删除批处理固定器。\r\n            \r\n","\r\n Checks if the given ":"\r\n 检查给定\r\n","\r\n Gets the available base type members in the context of the specified location.  Akin to\r\n calling ":"\r\n 获取指定位置上下文中的可用基类型成员。  类似于\r\n 打电话来 \r\n","\"Invalid rank specifier: expected ']'":"“无效等级规格：预期']''\r\n","\r\n            Ask solution crawler to re-analyze given ":"\r\n            要求解决方案爬行者重新分析给定\r\n","\r\n            check whether selection contains return statement or not\r\n            ":"\r\n            检查选择是否包含返回语句\r\n            \r\n","\r\n The \"Module\" statement that begins the block.\r\n ":"\r\n 开始块的“模块”语句。\r\n \r\n","The symbol to generate source for":"生成源的符号\r\n","module initializers":"模块初始化器\r\n","\r\n  Looks up a localized string similar to '-' expected..\r\n":"\r\n  查找类似于“  - ”的局部字符串。\r\n\r\n","\r\n The name of the field being initialized.\r\n ":"\r\n 该字段的名称被初始化。\r\n \r\n","\r\n Type parameter definitions. Duplicates aren't allowed. Type parameters of containing type\r\n must precede type parameters of a nested type.  \r\n ":"\r\n 类型参数定义。不允许重复。包含类型的类型参数\r\n 必须先于嵌套类型的类型参数。\r\n \r\n","\r\n Apply generic type arguments, returning the constructed type. Produces errors for constraints\r\n that aren't validated. If the wrong number of type arguments are supplied, the set of types\r\n is silently truncated or extended with the type parameters.\r\n ":"\r\n 应用通用类型参数，返回构造类型。产生约束的错误\r\n 没有得到验证。如果提供了错误数量的类型参数，则类型集\r\n 用类型参数静静地截断或扩展。\r\n \r\n","\r\n The value for the Nullable property.\r\n ":"\r\n 无效属性的值。\r\n \r\n","int _ = Computation();":"int _ = Computation（）;\r\n","\r\n True if the implementation of this method is supplied by the runtime.\r\n ":"\r\n 如果运行时提供了此方法的实现，则是正确的。\r\n \r\n","\r\n            Indicates which code fixes are enabled for a Code Cleanup operation. Each code fix in the set is triggered by\r\n            one or more diagnostic IDs, which could be provided by the compiler or an analyzer.\r\n            ":"指示启用哪些代码修复程序以进行代码清理操作。集合中的每个代码修复都由\r\n            一个或多个诊断ID，可以由编译器或分析仪提供。\r\n            \r\n"," to act as an explicit marker that navigation is not possible.\r\n            ":" 充当明确的标记，无法进行导航。\r\n            \r\n","\r\n Creates an empty ":"\r\n 创建一个空\r\n","\r\n            Sort pairs using conversion types by inheritance distance from the base type in ascending order,\r\n            i.e., less specific type has higher priority because it has less probability to make mistakes\r\n            ":"\r\n            使用转换类型对基本类型的继承距离进行排序，\r\n            即，较少的特定类型的优先级较高，因为它犯错的可能性较小\r\n            \r\n","\r\n            (typically shown as a tooltip for the link). This stack is never empty; when no hyperlink applies to the\r\n            current scope, the top item of the stack will be a default tuple instance.\r\n            ":"\r\n            （通常显示为链接的工具提示）。这个堆栈永远不会空；当没有超链接适用于\r\n            当前范围，堆栈的首要项目将是默认的元组实例。\r\n            \r\n","\r\n The \".\" or \"!\" token.\r\n ":"\r\n 这 ”。”或者 ”！”令牌。\r\n \r\n","\r\n Is the passed in syntax tree in this compilation?\r\n ":"\r\n 在此汇编中是在语法树中传递的吗？\r\n \r\n","\r\n The \"Continue\" keyword.\r\n ":"\r\n “继续”关键字。\r\n \r\n","\r\n            to the input text.  Note the column in the line position can be virtual in that it points\r\n            to a location in the line which does not actually contain whitespace.\r\n            Hosts can determine how best to handle that virtual location.\r\n            For example, placing the character in virtual space (when suppported)\r\n            or inserting an appropriate number of spaces into the document\".\r\n            ":"\r\n            输入文本。注意行位置中的列可以是虚拟的。\r\n            到实际上不包含空格的线路中的位置。\r\n            主机可以确定如何最好地处理该虚拟位置。\r\n            例如，将角色放在虚拟空间中（拟定时）\r\n            或将适当数量的空间插入文档”。\r\n            \r\n","\r\n  Looks up a localized string similar to Extension methods must declare at least one parameter. The first parameter specifies which type to extend..\r\n":"\r\n  查找类似于扩展方法的本地化字符串必须声明至少一个参数。第一个参数指定要扩展的类型。\r\n\r\n","\r\n Returns true if the method is considered in its expanded param array form.\r\n ":"\r\n 如果在其扩展的参数阵列表单中考虑该方法，则返回true。\r\n \r\n","\r\n            organize given node\r\n            ":"\r\n            组织给定的节点\r\n            \r\n","The Output kind to derive the value of TARGET symbol from.":"从中得出目标符号值的输出类型。\r\n"," per the given options. For example, the\r\n severity may be escalated, or the ":" 根据给定的选项。例如，\r\n 严重程度可能会升级，或者\r\n","\r\n Initialize the ObsoleteAttributeData by fetching attributes and decoding ObsoleteAttributeData. This can be \r\n done for Metadata symbol easily whereas trying to do this for source symbols could result in cycles.\r\n ":"\r\n 通过获取属性和解码OmpoleTeatTribedata来初始化闭合构成的ata。这可以\r\n 为元数据符号完成，而试图为源符号执行此操作可能会导致周期。\r\n \r\n","\r\n Called at the point in a loop where the backwards branch would go to.\r\n ":"\r\n 在向后分支将进入的循环中的点。\r\n \r\n","Returns the value returned by running the script.":"返回通过运行脚本返回的值。\r\n","\r\n Returns a copy of this with the ForStatement property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回该副本，而陈述属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n True if the enumerator is, inherits from or implements IDisposable.\r\n ":"\r\n 如果是枚举者，则从iDisposable继承或实现枚举。\r\n \r\n"," associated with position in the document.\r\n            ":" 与文档中的位置相关联。\r\n            \r\n","\r\n If present, a type parameter list with generic parameters for this type. If no\r\n generic parameters were present, Nothing is returned.\r\n ":"\r\n 如果存在，则具有此类型的通用参数的类型参数列表。如果不\r\n 存在通用参数，什么也没有返回。\r\n \r\n","Removal of document not supported":"删除不支持的文件\r\n","\r\n The container of the event. This can either be a simple identifier (identifying\r\n a members of the containing type) or one of the special keywords \"Me\", \"MyBase\"\r\n or \"MyClass\".\r\n ":"\r\n 事件的容器。这可以是一个简单的标识符（识别\r\n 包含类型的成员）或特殊关键字之一“我”，“ mybase”\r\n 或“ myclass”。\r\n \r\n","\r\n            Returns true for type that are arrays/nullable/pointer types of special types\r\n            ":"\r\n            返回true对于阵列/无效/指针类型的特殊类型的类型为true\r\n            \r\n","\r\n            Maps format document code cleanup options to DiagnosticId[]\r\n            ":"\r\n            地图格式文档代码清理选项以诊断[]\r\n            \r\n","Autoselect disabled due to possible tuple type element creation.":"由于可能的元组类型元素创建，因此禁用了自动选择。\r\n","\r\n Represents a ":"代表\r\n","\r\n The \"Structure\" statement that begins the block.\r\n ":"\r\n 开始块的“结构”语句。\r\n \r\n","\r\n  Looks up a localized string similar to Local variable cannot have the same name as the function containing it..\r\n":"\r\n  查找类似于本地变量的本地化字符串不能与包含它的函数具有相同的名称。\r\n\r\n","\r\n            Doesn't affect files that have already been shadow-copied.\r\n            ":"\r\n            不会影响已经被阴影的文件。\r\n            \r\n","  to find the symbol.\r\n ":"  找到符号。\r\n \r\n"," to only show member\r\n            signatures.":" 仅显示会员\r\n            签名。\r\n","Cannot convert &method group '{0}' to non-function pointer type '{1}'.":"无法将＆方法组'{0}'转换为非功能指针类型'{1}'。\r\n","\r\n Return the first Class declaration with explicit base classes to use for\r\n checking base class constraints. Other type declarations (Structures,\r\n Modules, Interfaces) are ignored since other errors will have been\r\n reported if those types include bases.\r\n ":"\r\n 返回带有明确基类的一类声明\r\n 检查基类约束。其他类型的声明（结构，\r\n 模块，接口）被忽略，因为其他错误将是\r\n 报告这些类型是否包括基础。\r\n \r\n"," with debugging information enabled.\r\n            ":" 启用调试信息。\r\n            \r\n"," from different providers\r\n            into another top level suggested action to avoid light bulb clutter. This topmost suggested action is *not* represented by this code action.\r\n            ":" 来自不同的提供商\r\n            进入另一个顶级建议的行动，以避免灯泡混乱。此最高建议的操作是 *不 *由此代码操作表示。\r\n            \r\n","\r\n Indexed type parameters are used in place of type parameters for method signatures.  There is\r\n a unique mapping from index to a single IndexedTypeParameterSymbol.  \r\n \r\n They don't have a containing symbol or locations.\r\n \r\n They do not have constraints, variance, or attributes. \r\n ":"\r\n 索引类型参数代替用于方法签名的类型参数。有\r\n 从索引到单个索引typeparametersymbol的唯一映射。\r\n \r\n 他们没有包含符号或位置。\r\n \r\n 它们没有约束，差异或属性。\r\n \r\n","\r\n  Looks up a localized string similar to 'AddHandler' or 'RemoveHandler' statement event operand must be a dot-qualified expression or a simple name..\r\n":"\r\n  查找类似于“ Addhandler”或“ RemoveHandler”语句事件操作数的本地化字符串必须是dot qualified表达式或一个简单的名称。\r\n\r\n","\r\n Returns a copy of this with the Keys property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，其中键属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n  Looks up a localized string similar to AggregateSyntax not within syntax tree.\r\n":"\r\n  查找类似于语法树中的汇总字符串类似的局部字符串。\r\n\r\n","\r\n Symbol representing non-generic method directly or indirectly contained within constructed\r\n generic type.\r\n For example: A(Of Integer).B or A(Of Integer).B.C\r\n ":"\r\n 符号代表直接或间接包含在构造中的非生成方法的符号\r\n 通用类型。\r\n 例如：a（integer）.b或a（integer）.b.b\r\n \r\n","\r\n            Gets the current presentation and behavior rules.\r\n            ":"\r\n            获取当前的演示和行为规则。\r\n            \r\n","\r\n The SyncLock statement that begins the block.\r\n ":"\r\n 开始块的Synclock语句。\r\n \r\n","\r\n Entry point to the array initialization.\r\n Assumes that we have newly created array on the stack.\r\n \r\n inits could be an array of values for a single dimensional array\r\n or an   array (of array)+  of values for a multidimensional case\r\n \r\n in either case it is expected that number of leaf values will match number \r\n of elements in the array and nesting level should match the rank of the array.\r\n ":"\r\n 阵列初始化的切入点。\r\n 假设我们在堆栈上有新创建的数组。\r\n \r\n INIT可能是单个维数组的值数组\r\n 或多维情况的值的数组（数组）+值\r\n \r\n 无论哪种情况，都可以预期叶值的数量将匹配数字\r\n 数组和嵌套级别中的元素应与数组的等级相匹配。\r\n \r\n","True if the changes include the typed character that caused the ":"如果更改包含引起的键入字符，则为真实\r\n","long time":"很久\r\n"," with a tag added to the ":" 标签添加到\r\n","Configure severity for all '{0}' analyzers":"为所有“ {0}”分析仪配置严重性\r\n"," for it.\r\n            ":" 为了它。\r\n            \r\n","\r\n            Given an argument node, tries to generate an appropriate name that can be used for that\r\n            argument.\r\n            ":"\r\n            给定一个参数节点，试图生成一个可以用于该的适当名称\r\n            争论。\r\n            \r\n","\r\n Used for example for event accessors. The \"remove\" method delegates attribute binding to the \"add\" method. \r\n The bound attribute data are then applied to both accessors.\r\n ":"\r\n 例如，用于事件访问者。 “删除”方法委托属性绑定到“添加”方法。\r\n 然后将界限数据应用于两个登录器。\r\n \r\n","\r\n  Looks up a localized string similar to Event '{0}' cannot implement a Windows Runtime event '{1}' and a regular .NET event '{2}'.\r\n":"\r\n  查找类似于事件“ {0}”的本地化字符串无法实现Windows运行时事件'{1}'和常规.NET事件'{2}'。\r\n\r\n","\r\n This override changes two things:\r\n     1) Return type arguments instead of type parameters.\r\n     2) Handle non-PE types.\r\n ":"\r\n 这覆盖了两件事：\r\n     1）返回类型参数而不是类型参数。\r\n     2）处理非PE类型。\r\n \r\n","\r\n The expression to sort by.\r\n ":"\r\n 表达式排序。\r\n \r\n","\r\n The value for the EndAccessorStatement property.\r\n ":"\r\n EndAccessorStatement属性的值。\r\n \r\n","Interpolated string handler method '{0}' is malformed. It does not return 'void' or 'bool'.":"插值字符串处理程序方法'{0}'已畸形。它不会返回“无效”或“布尔”。\r\n","\r\n Helper class to resolve metadata tokens and signatures.\r\n ":"\r\n 解决元数据代币和签名的帮助课。\r\n \r\n","The project from which the symbol to generate source for came\r\n            from.":"符号生成源的项目\r\n            从。\r\n","\r\n A trivia with kind EndOfLineTrivia containing a single line feed character.\r\n ":"\r\n 带有单线饲料特征的带有类似内膜的琐事。\r\n \r\n","Optional partial name.":"可选的部分名称。\r\n","Removing {0} that accessed captured variables '{1}' and '{2}' declared in different scopes requires restarting the application.":"在不同范围中删除访问捕获的变量'{1}'和'{2}'的{0}需要重新启动应用程序。\r\n","\r\n            True if the node has an active span associated with it, false otherwise.\r\n            ":"\r\n            正确，如果节点具有与之关联的活动跨度，则为false否则。\r\n            \r\n","\r\n Returns a copy of this with the ReturnKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而returnkeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            Compares symbols by their original definition.\r\n            ":"\r\n            通过其原始定义比较符号。\r\n            \r\n","\r\n Returns a copy of this with the Parameters property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回其中的副本，其中参数属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            A map from spans of tokens needing rename within strings or comments to an optional\r\n            set of specific sub-spans within the token span that\r\n            have ":"\r\n            来自代币跨度的地图，需要在字符串或评论中重命名为可选的标记\r\n            令牌跨度内的一组特定子跨度\r\n            有\r\n","\r\n The expression denoting the initial value of the iteration.\r\n ":"\r\n 表示迭代初始值的表达式。\r\n \r\n","\r\n Gets all extension methods in this namespace given a method's name. \r\n ":"给定一个方法的名称，在此名称空间中获取所有扩展方法。\r\n \r\n","\r\n Represents a \"Loop While\" statement that end a \"Do ... Loop\" block.\r\n ":"\r\n 表示结束“ do ...循环”块的“循环”。\r\n \r\n","\r\n Gets a value indicating whether this argument is a named argument.\r\n ":"\r\n 获取一个指示此参数是否为命名参数的值。\r\n \r\n","\r\n Backing field of the event, or Nothing if the event doesn't have any.\r\n ":"\r\n 事件的支持字段，或者如果事件没有任何事物。\r\n \r\n","\r\n The \"Return\" keyword.\r\n ":"\r\n “返回”关键字。\r\n \r\n","\r\n Incrementally bind bindingRoot (which is always a non-lambda enclosed statement, or the\r\n root of this model). Side effect is to store nodes into the guarded node map.\r\n ":"\r\n 逐步绑定bindingroot（始终是非lambda封闭式语句，或\r\n 此模型的根）。副作用是将节点存储到守卫节点映射中。\r\n \r\n","Using a function pointer type in a 'typeof' in an attribute is not supported.":"不支持在属性中使用'typeOf中的函数指针类型。\r\n","\r\n            Project contains compilation errors that block EnC analysis.\r\n            ":"\r\n            项目包含阻止ENC分析的汇编错误。\r\n            \r\n","\r\n  Looks up a localized string similar to Cannot inherit interface '{0}' because it could be identical to interface '{1}' for some type arguments..\r\n":"\r\n  查找类似于无法继承界面'{0}'的本地化字符串，因为对于某些类型的参数，它可能与接口'{1}'相同。\r\n\r\n","\r\n Represents a simple \"Do\" statement that begins a \"Do ... Loop\" block.\r\n ":"\r\n 代表一个简单的“ do”语句，开始一个“ do ... loop”块。\r\n \r\n","\r\n            Organize the whole document.\r\n            \r\n            Optionally you can provide your own organizers. otherwise, default will be used.\r\n            ":"\r\n            组织整个文档。\r\n            \r\n            您可以选择提供自己的组织者。否则，将使用默认值。\r\n            \r\n","Extract base class...":"提取基类...\r\n","\r\n            check whether node contains error for itself but not from its child node\r\n            ":"\r\n            检查节点是否包含自己的错误，但不包含子节点的错误\r\n            \r\n",". \r\n            This will either return already created ":"。\r\n            这要么将返回已经创建\r\n","\r\n Returns a copy of this with the BlockKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而BlockKeyWord属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","stackalloc in nested expressions":"嵌套表达中的stackalloc\r\n","A positive character group specifies a list of characters, any one of which may appear in an input string for a match to occur.":"正面字符组指定字符列表，其中任何一个可能出现在输入字符串中以进行匹配。\r\n","\r\n  Looks up a localized string similar to 'End Try' must be preceded by a matching 'Try'..\r\n":"\r\n  查找类似于“ End Try”的本地化字符串，必须先于匹配的“尝试”。\r\n\r\n","\r\n            Determines if inserting the opening brace at the location could be an attempt to\r\n            escape a previously inserted opening brace.\r\n            E.g. they are trying to type $\"{{\"\r\n            ":"\r\n            确定在该位置插入开头支架是否可能是试图\r\n            逃脱先前插入的开放式支架。\r\n            例如。他们正在尝试键入$“ {{”\r\n            \r\n","A cancellation token that can be used to cancel the process of obtaining the\r\n diagnostics.":"取消令牌，可用于取消获得的过程\r\n 诊断。\r\n","\r\n            Enumerates assemblies in the GAC returning those that match given partial name and\r\n            architecture.\r\n            ":"\r\n            GAC中列举组件，返回那些匹配给定名称的符合的组件，并\r\n            建筑学。\r\n            \r\n","\r\n if all of the type argument lists in its fully qualified name are empty.\r\n Note that the type arguments of an unbound generic type will be returned as error\r\n types because they do not really have type arguments.  An unbound generic type\r\n yields null for its BaseType and an empty result for its Interfaces.\r\n ":"\r\n 如果所有类型的参数列出了其完全合格的名称，则为空。\r\n 请注意，无限通用类型的类型参数将作为错误返回\r\n 类型是因为它们实际上没有类型的参数。无限通用类型\r\n 为其底层类型而产生无效的界面，并为其接口提供了空的结果。\r\n \r\n","\r\n This class is used to cache various information about a lambda in the course of binding an expression/statement\r\n containing the lambda. Even though the members are public, they shouldn't be accessed directly by any code\r\n outside of the UnboundLambda class.\r\n ":"\r\n 该类用于在绑定表达式/语句的过程中缓存有关lambda的各种信息\r\n 包含lambda。即使成员是公开的，也不应通过任何代码直接访问它们\r\n 在Unboundlambda课程之外。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' exists in multiple base interfaces. Use the name of the interface that declares '{0}' in the 'Implements' clause instead of the name of the derived interface..\r\n":"\r\n  在多个基本接口中查找类似于“ {0}”的本地化字符串。使用“实施”子句中声明“ {0}”的接口名称，而不是派生接口的名称。\r\n\r\n","\r\n Represents the list of \"()\" or \"(,,)\" modifiers on the array type.\r\n ":"\r\n 表示数组类型上的“（）”或“（）”修饰符的列表。\r\n \r\n","\r\n The value for the Root property.\r\n ":"\r\n 根属性的值。\r\n \r\n","\r\n            Implements an assembly loader for interactive compiler and REPL.\r\n            ":"\r\n            实现用于交互式编译器和REPL的组装装载机。\r\n            \r\n","\r\n            The span of the syntax element at the caret position.\r\n            \r\n            This is the most common value used for ":"\r\n            语法元素在伦名位置的跨度。\r\n            \r\n            这是最常用的值\r\n","\r\n The value for the EndSyncLockStatement property.\r\n ":"\r\n EndsynclockStatement属性的值。\r\n \r\n","\r\n            Searches for extension methods exactly called 'GetEnumerator'.  Returns\r\n            ":"\r\n            搜索精确称为“ getEnumerator”的扩展方法。返回\r\n            \r\n","\r\n Represents an #End If pre-processing directive appearing in source.\r\n ":"\r\n 表示#ent如果预处理指令出现在源中。\r\n \r\n","\r\n The value for the NamespaceKeyword property.\r\n ":"\r\n 命名pacekeyword属性的值。\r\n \r\n","\r\n The \"UI\" literal suffix denoting \"UInteger\"\r\n ":"\r\n “ ui”字面后缀表示“ uinteger”\r\n \r\n"," that also returns the index of the child node.\r\n            ":" 这也返回子节点的索引。\r\n            \r\n","\r\n A list of the type parameters. There must be at least one type parameter in the\r\n list.\r\n ":"\r\n 类型参数列表。在\r\n 列表。\r\n \r\n",", including all declared variables, return value and caught exception (if applicable).":"，包括所有声明的变量，返回值并捕获异常（如果适用）。\r\n","\r\n Parses the given platform option. Legal strings are \"anycpu\", \"x64\", \"x86\", \"itanium\", \"anycpu32bitpreferred\", \"arm\".\r\n In case an invalid value was passed, anycpu is returned.\r\n ":"\r\n 解析给定平台选项。法律弦是“ Anycpu”，“ X64”，“ X86”，“ Itanium”，“ Anycpu32bitpreferred”，“ Arm”。\r\n 如果通过无效的值，则返回AnyCPU。\r\n \r\n","\r\n            True if at least one of the threads whom this active statement belongs to is in a leaf frame.\r\n            ":"\r\n            如果至少有一个活动语句属于的线程中的至少一个是在叶子框架中，则是真的。\r\n            \r\n","The platform doesn't support GAC.":"该平台不支持GAC。\r\n","\r\n            Provides an argumnet provider that always appears after all built-in argument providers. This argument\r\n            provider does not provide any argument values.\r\n            ":"\r\n            提供了一个ARG室内提供商，该提供商总是在所有内置参数提供商之后出现。这个论点\r\n            提供者不提供任何参数值。\r\n            \r\n","Add explicit cast":"添加明确的铸件\r\n","\r\n Returns a copy of this with the TextTokens property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中TextTokens属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n The End With statement that ends the block.\r\n ":"\r\n 结束块的陈述结尾。\r\n \r\n","Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.":"在显式接口规范中参考类型的无效性不匹配该类型实现的接口。\r\n","\r\n            Remote API.\r\n            ":"\r\n            远程API。\r\n            \r\n","Changing the type of {0} requires restarting the application.":"更改{0}的类型需要重新启动应用程序。\r\n","\r\n Represents a relation clause in a Case statement, such as \"Is > expression\".\r\n ":"\r\n 代表案例语句中的关系子句，例如“ IS>表达”。\r\n \r\n","\r\n Returns a non-null SyntaxTree that owns this node.\r\n If this node was created with an explicit non-null SyntaxTree, returns that tree.\r\n Otherwise, if this node has a non-null parent, then returns the parent's SyntaxTree.\r\n Otherwise, returns a newly created SyntaxTree rooted at this node, preserving this node's reference identity.\r\n ":"\r\n 返回拥有此节点的非弹性语法。\r\n 如果该节点是用明确的非NULL语法Tree创建的，请返回该树。\r\n 否则，如果此节点具有非肺父母，则返回父的语法。\r\n 否则，返回植根于该节点的新创建的语法，并保留该节点的参考身份。\r\n \r\n","\r\n            The changes to make to ":"\r\n            要进行的更改\r\n","\r\n Create an identifier node without brackets or type character.\r\n ":"\r\n 创建一个无括号或类型字符的标识符节点。\r\n \r\n","Relational patterns may not be used for a value of type '{0}'.":"关系模式不得用于类型'{0}'的值。\r\n","\r\n Returns a copy of this with the Modifier property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中修改器属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Generate read-only field '{1}.{0}'":"生成仅读取字段'{1}。{0}'\r\n","word boundary":"单词边界\r\n"," is True.\r\n Chaining of speculative semantic model is not supported.":" 是真的。\r\n 不支持投机语义模型的链接。\r\n","\r\n  Looks up a localized string similar to '{0}' is not a local variable or parameter, and so cannot be used as a 'Catch' variable..\r\n":"\r\n  查找类似于“ {0}”不是本地变量或参数的本地化字符串，因此不能用作“捕获”变量。\r\n\r\n","\r\n            Rewrite the parent of a node which was rewritted by ":"\r\n            重写由由\r\n","All separator characters. This includes the Zs, Zl, and Zp categories.":"所有分离器字符。这包括ZS，ZL和ZP类别。\r\n","\r\n The field of the generated async class used to store the async method builder: an instance of\r\n AsyncVoidMethodBuilder, AsyncTaskMethodBuilder, or AsyncTaskMethodBuilder(Of T) depending on the\r\n return type of the async method.\r\n ":"生成的异步类的字段用于存储异步方法构建器：\r\n 异步无素构造器，异步分子构造器或tsynctaskmethodbuilder（t）取决于\r\n 返回异步方法的类型。\r\n \r\n","\r\n Returns all members of the specific kind, starting at the optional offset.\r\n Members of the same kind are assumed to be contiguous.\r\n ":"\r\n 从可选偏移开始返回特定类型的所有成员。\r\n 假定同类成员是连续的。\r\n \r\n","\r\n            True if both nodes represent the same kind of suspension point \r\n            (await expression, await foreach statement, await using declarator, yield return, yield break).\r\n            ":"\r\n            如果两个节点代表相同的悬架点\r\n            （等待表达，等待着陈述，使用声明人，收益率回报，收益率中断）。\r\n            \r\n","\r\n The right expression in the Join condition.\r\n ":"\r\n 在联接条件下正确的表达式。\r\n \r\n","\r\n One of the type parameter constraints clauses. This represents a constraint\r\n clause in the form of \"As { Constraints }\".\r\n ":"\r\n 类型参数约束条款之一。这代表一个约束\r\n 条款以“ AS {约束}”的形式。\r\n \r\n","\r\n            An optional suffix to be displayed appended to ":"\r\n            可选的后缀以显示为\r\n","\r\n Lookup a type within the compilation's assembly and all referenced assemblies\r\n using its canonical CLR metadata name (names are compared case-sensitively).\r\n ":"\r\n 查找编译组件中的类型和所有引用的组件\r\n 使用其规范的CLR元数据名称（对案例敏感的名称进行比较）。\r\n \r\n","Remarks:":"评论：\r\n","\r\n Represents a reference to a generic type instantiation.\r\n Subclasses represent nested and namespace types.\r\n ":"\r\n 代表对通用类型实例化的引用。\r\n 子类代表嵌套和名称空间类型。\r\n \r\n","\r\n Report an error associated with the accessor accessibility modifier.\r\n ":"\r\n 报告与访问者可访问性修饰符关联的错误。\r\n \r\n","\r\n Rewrite the given node to eliminate lambda expressions.  Also returned are the method symbols and their\r\n bound bodies for the extracted lambda bodies. These would typically be emitted by the caller such as\r\n MethodBodyCompiler.  See this class' documentation\r\n for a more thorough explanation of the algorithm and its use by clients.\r\n ":"\r\n 重写给定的节点以消除lambda表达式。还返回的是方法符号及其\r\n 提取的Lambda身体的结合体。这些通常会由呼叫者散发\r\n MethodBodyCompiler。查看此类文档\r\n 为了对算法及其使用的使用更彻底的解释。\r\n \r\n","\r\n The bound code of the method or initializer being analyzed\r\n ":"\r\n 分析方法或初始化器的界限\r\n \r\n","\r\n  Looks up a localized string similar to Event '{0}' cannot implement event '{1}' on interface '{2}' because their delegate types '{3}' and '{4}' do not match..\r\n":"\r\n  在接口'{2}'上查找类似于事件'{0}'不能实现事件'{1}'的本地化字符串，因为他们的委托类型'{3}'{3}'和'{4}'不匹配。\r\n\r\n","\r\n  Looks up a localized string similar to '{0}' cannot override '{1}' because it is declared 'NotOverridable'..\r\n":"\r\n  查找类似于'{0}'不能覆盖'{1}'的本地化字符串，因为它被声明为'noverridable'..\r\n\r\n","\r\n Writes the full text of this node to the specified TextWriter\r\n ":"\r\n 将此节点的全文写给指定的文本作者\r\n \r\n","\r\n A helper to bind conditional access. \r\n ":"\r\n 辅助有条件访问的助手。\r\n \r\n","\r\n The value for the SubOrFunctionStatement property.\r\n ":"\r\n 子填充属性属性的值。\r\n \r\n","\r\n            Note that VB lambda bodies are represented by a lambda header and that some lambda bodies share \r\n            their parent nodes with other bodies (e.g. join clause expressions).\r\n            ":"\r\n            请注意，vb lambda尸体由lambda标头代表，一些lambda尸体共享\r\n            他们的父母节点与其他身体（例如加入子句表达式）。\r\n            \r\n","\r\n The \"(\" token that introduces the parameter list. If no parameter list was\r\n present, Nothing is returned.\r\n ":"\r\n “”介绍参数列表的令牌。如果没有参数列表\r\n 目前，什么都没有归还。\r\n \r\n","\r\n The underlying NamespaceSymbol, cannot be another RetargetingNamespaceSymbol.\r\n ":"\r\n 基础命名符号，不能是另一个RetargetingNamespaceSymbol。\r\n \r\n","line span directive":"线跨指令\r\n","\r\n Associate the method with a particular property. Returns\r\n false if the method is already associated with a property.\r\n ":"\r\n 将方法与特定属性相关联。返回\r\n false如果该方法已经与属性关联。\r\n \r\n","\r\n Returns a copy of this with the DeclareKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，并更改​​为declekekeyword属性\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Represents an identifier token. This might include brackets around the name,\r\n and a type character.\r\n ":"\r\n 代表标识符令牌。这可能包括围绕名称的括号，\r\n 和类型字符。\r\n \r\n","Unable to read source file '{0}' or the PDB built for the containing project. Any changes made to this file while debugging won't be applied until its content matches the built source.":"无法读取源文件'{0}'或为包含项目构建的PDB。在调试时对此文件进行的任何更改都不会应用于其内容与构建源匹配。\r\n","\r\n  Looks up a localized string similar to Type or 'New' expected..\r\n":"\r\n  查找类似于类型或“新”预期的本地化字符串。\r\n\r\n","\r\n The set of variables that were declared anywhere inside an expression lambda.\r\n ":"\r\n 表达式lambda中任何地方声明的变量集。\r\n \r\n","\r\n  Looks up a localized string similar to Non-intrinsic type names are not allowed in conditional compilation expressions..\r\n":"\r\n  在有条件的汇编表达式中不允许查找类似于非中间类型名称的本地化字符串。\r\n\r\n","\r\n Returns a copy of this with the EndAccessorStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中EndacCessorStatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Get all bound nodes associated with a node, ordered from highest to lowest in the bound tree.\r\n Strictly speaking, the order is that of a pre-order traversal of the bound tree.\r\n As a side effect, caches nodes and binders.\r\n ":"\r\n 获取与节点关联的所有绑定节点，并从最高到最低的树中订购。\r\n 严格来说，该顺序是绑定树的预订遍历。\r\n 作为副作用，缓存节点和粘合剂。\r\n \r\n","match zero or more times (lazy)":"匹配零或更多次（懒惰）\r\n","\r\n Represents an Aggregate query operator.\r\n ":"\r\n 代表一个聚合查询操作员。\r\n \r\n","\r\n  Looks up a localized string similar to 'End Sub' must be preceded by a matching 'Sub'..\r\n":"\r\n  查找类似于“ End sub”的本地化字符串必须先于匹配的“子”。\r\n\r\n","\r\n            The span of the document the completion list corresponds to.  It will be set initially to\r\n            the result of ":"\r\n            文档的跨度列表对应于。它最初将设置为\r\n            的结果\r\n","\r\n Used by ClassifyUserDefinedConversion to pass an ArrayTypeSymbol that has a link back to the BoundArrayLiteral node.\r\n This allows the ClassifyConversionOperatorInOutConversions to properly classify a conversion from the inferred array \r\n type to the input type of a user defined conversion.\r\n ":"\r\n 由分类器定义转换使用，以传递具有链接回到boundarrayliteral节点的arraytypesymbol。\r\n 这允许ClassifyConversionOperatorInOutConversions从推断数组中正确分类转换\r\n 输入用户定义的转换的输入类型。\r\n \r\n"," that corresponds to the assembly symbol.\r\n ":" 这对应于汇编符号。\r\n \r\n","\r\n The new ":"\r\n 新的\r\n","\r\n Creates a ":"\r\n 创建一个\r\n","Adding {0} around an active statement requires restarting the application.":"围绕Active语句添加{0}需要重新启动应用程序。\r\n","\r\n            Suppresses shadow-copying of specified path.\r\n            ":"\r\n            抑制指定路径的阴影复印。\r\n            \r\n","\r\n Information decoded from well-known custom attributes applied on an event.\r\n ":"\r\n 从应用于事件的众所周知的自定义属性解码的信息。\r\n \r\n","Modifying the initializer of {0} in a generic type requires restarting the application.":"在通用类型中修改{0}的初始化器需要重新启动应用程序。\r\n","\r\n Gets the available named namespace And type symbols in the context of the specified location And optional container.\r\n Only members that are accessible And visible from the given location are returned.\r\n ":"\r\n 获取指定位置和可选容器上下文中可用的命名空间和类型符号。\r\n 只返回从给定位置可访问和可见的成员。\r\n \r\n","\r\n The \"position\" Is used to determine what variables are visible And accessible. Even if \"container\" Is\r\n specified, the \"position\" location Is significant for determining which members of \"containing\" are\r\n accessible. \r\n ":"\r\n \"位置\"用于确定哪些变量是可见的和可访问的。 即使\"容器\"是\r\n 指定，\"位置\"位置对于确定\"包含\"的哪些成员是显着的\r\n 可访问。 \r\n \r\n","Cannot retrieve the Span of a null syntax reference.":"无法检索NULL语法引用的跨度。\r\n","\r\n Generates the name of a state machine 'state' field \r\n ":"\r\n 生成状态计算机“状态”字段的名称\r\n \r\n","Use explicit type":"使用显式类型\r\n","\r\n            DiagnosticAnalyzer that looks for is-tests and cast-expressions, and offers to convert them\r\n            to use patterns.  i.e. if the user has ":"\r\n            寻找测试和铸造表达的诊断剂，并提出转换\r\n            使用模式。即如果用户有\r\n","__arglist cannot have an argument passed by 'in' or 'out'":"__ Arglist不能有“在”或“ OUT”中通过的论点\r\n"," is configured to have the given ":" 被配置为给定\r\n","\r\n            Returns true if the character might end a Signature Help session, \r\n            e.g. ')' for method invocations.  \r\n            ":"\r\n            如果角色可能结束签名帮助会话，则返回true，\r\n            例如'）'用于方法调用。\r\n            \r\n"," to just ":" 只是\r\n","\r\n            Try to get a new node to replace given node, which is a reference to a top-level type declared inside the \r\n            namespace to be changed. If this reference is the right side of a qualified name, the new node returned would\r\n            be the entire qualified name. Depends on whether ":"\r\n            尝试获取一个新的节点替换给定节点，这是对在该节点中声明的顶级类型的引用\r\n            名称空间要更改。如果此引用是合格名称的右侧，则返回的新节点将\r\n            成为整个合格名称。取决于是否\r\n","The initializer syntax for the field.":"该字段的初始化语法。\r\n","\r\n The \"AddHandler\" or \"RemoveHandler\" keyword.\r\n ":"\r\n “ Addhandler”或“ Remove Handler”关键字。\r\n \r\n","\r\n Match candidate's parameters to arguments §11.8.2 Applicable Methods.\r\n \r\n Note, similar to Dev10 compiler this process will eliminate candidate requiring narrowing conversions\r\n if strict semantics is used, exception are candidates that require narrowing only from numeric constants.\r\n \r\n Assumptions: \r\n    1) This function is never called for a candidate that should be rejected due to parameter count.\r\n    2) Omitted arguments [ Call Foo(a, , b) ] are represented by OmittedArgumentExpression node in the arguments array.\r\n    3) Omitted argument never has name.\r\n    4) argumentNames contains Nothing for all positional arguments.\r\n \r\n !!! Should keep this function in sync with Binder.PassArguments, which uses data this function populates.              !!!\r\n !!! Should keep this function in sync with Binder.ReportOverloadResolutionFailureForASingleCandidate.                  !!!\r\n !!! Should keep this function in sync with InferenceGraph.PopulateGraph.                                               !!!\r\n !!! Everything we flag as an error here, Binder.ReportOverloadResolutionFailureForASingleCandidate should detect as well. !!!\r\n ":"将候选人的参数匹配到参数§11.8.2适用方法。\r\n \r\n 注意，与DEV10编译器相似，此过程将消除需要缩小转换的候选人\r\n 如果使用严格的语义，则需要仅从数字常数缩小的候选人。\r\n \r\n 假设：\r\n    1）从不要求此功能因参数计数而被拒绝。\r\n    2）省略的参数[call foo（a，b）]由参数数组中的省略argumentExpression节点表示。\r\n    3）省略的论点从来没有名字。\r\n    4）参数名称不包含所有位置参数。\r\n \r\n !!!应将此功能与binder.passarguments保持同步，该数据使用此功能填充。 !!!\r\n !!!应将此函数与Binder同步。ReportoverLoadResolutionFailureFoilForasingLecandidate。 !!!\r\n !!!应将此函数与inferencegraph.populategraph保持同步。 !!!\r\n !!!我们在这里标记为错误的所有内容，binder.ReportoverLoadResolutionFailureForrasingLecandidate也应检测到。 !!!\r\n \r\n","\r\n Represents a ReDim statement.\r\n ":"\r\n 代表一个redim语句。\r\n \r\n","\r\n            it will offer to convert that ":"\r\n            它将提供转换\r\n","\r\n This method is destructive to content of the [group] parameter.\r\n ":"\r\n 此方法对[组]参数的内容具有破坏性。\r\n \r\n","\r\n Returns a copy of this with the Cases property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，案例属性​​更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n"," supports fix all occurrences code fix.\r\n            ":" 支持修复所有出现代码修复。\r\n            \r\n","Returns True if the two items are not Equal.":"如果这两个项目不相等，则返回true。\r\n","\r\n  Looks up a localized string similar to Lambda parameter '{0}' hides a variable in an enclosing block, a previously defined range variable, or an implicitly declared variable in a query expression..\r\n":"\r\n  查找类似于lambda参数'{0}'的本地化字符串将变量隐藏在一个封闭块中，先前定义的范围变量或在查询表达式中隐式声明的变量。\r\n\r\n","s,\r\n so pass ignoringInterfaceImplementationChanges: True if you need a value sooner\r\n and aren't concerned about tweaks made to satisfy interface implementation \r\n requirements.\r\n NOTE: Not ignoring changes can only result in a value that is more true.\r\n ":"S，\r\n 因此，通过忽略InterfaceImplemptionChanges：True如果您需要一个值\r\n 并且不担心为满足界面实现的调整\r\n 要求。\r\n 注意：不忽略更改只能导致更真实的值。\r\n \r\n","\r\n            Spans of active statements in the document, or null if the document has syntax errors or has not changed.\r\n            Calculated even in presence of rude edits so that the active statements can be rendered in the editor.\r\n            ":"文档中有效语句的跨度，如果文档具有语法错误或尚未更改，则跨度为null。\r\n            即使在存在粗鲁的编辑的情况下也计算出来，以便可以在编辑器中呈现主动语句。\r\n            \r\n","Module initializer method '{0}' must be accessible at the module level":"模块初始化器方法'{0}必须在模块级别访问\r\n","\r\n The value for the CaseKeyword property.\r\n ":"\r\n CaseKeyWord属性的值。\r\n \r\n","\r\n Where all diagnostics are deposited.\r\n ":"\r\n 所有诊断存放的地方。\r\n \r\n","\r\n            returns IndentBlockOperations under a node either by itself or by filtering/replacing operations returned by NextOperation\r\n            ":"\r\n            返回节点下的缩进模块，或通过过滤/替换由NextOperation返回的操作\r\n            \r\n","The type to construct from":"构造的类型\r\n","For the purpose of brace usage analysis, the embedded statements of an ":"为了进行支架使用分析，嵌入式陈述\r\n","\r\n Resyncs to next statement terminator. Used in Preprocessor\r\n ":"\r\n 重新同步到下一个语句终结者。用于预处理器\r\n \r\n","A boolean value set to True if character is an underscore character.":"如果字符是下划线角色，则将布尔值设置为True。\r\n","\r\n            Enhances references with the assemblies they bring into the compilation and their dependency hierarchy.\r\n            ":"\r\n            通过将其带入汇编及其依赖性层次结构中的组件来增强参考。\r\n            \r\n","\r\n Type layout information (ClassLayout metadata and layout kind flags).\r\n ":"\r\n 键入布局信息（classLayout元数据和布局类似标志）。\r\n \r\n","This method avoids the performance overhead of calling ":"此方法避免了通话的性能开销\r\n","\r\n The identifier in the name.\r\n ":"\r\n 名称中的标识符。\r\n \r\n","\r\n  General closure.\r\n  Display class may only contain lambdas defined in the same top-level method.\r\n  ":"\r\n  一般关闭。\r\n  显示类可能仅包含在同一顶级方法中定义的lambdas。\r\n  \r\n","The DisabledCode node.":"禁用密码节点。\r\n","This grouping construct applies or disables the specified options within a subexpression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:\r\n            \r\n                i\tUse case-insensitive mat ...":"该分组结构在子表达中应用或禁用指定选项。在问号之后指定了启用的选项，以及在减号之后禁用的选项。允许的选项是：\r\n            \r\n                我用案例不敏感的垫子...\r\n","\r\n            Gets the completions available at the caret position.\r\n            ":"\r\n            获取在Caret位置可用的完成。\r\n            \r\n","year (2 digits)":"年（2位数字）\r\n","\r\n  Looks up a localized string similar to Unmanaged type '{0}' not valid for fields..\r\n":"\r\n  查找类似于非托管类型的本地化字符串'{0}'对字段无效。\r\n\r\n","\r\n Get all the members of this symbol that are namespaces.\r\n ":"\r\n 获取该符号的所有成员是名称空间。\r\n \r\n","\r\n The End XXX statement that ends the block.\r\n ":"\r\n 结束块的结束XXX语句。\r\n \r\n","\r\n Create substitution to handle alpha-renaming of type parameters. \r\n It maps type parameter definition to corresponding alpha-renamed type parameter.\r\n ":"\r\n 创建替换来处理类型参数的α命名。\r\n 它将类型的参数定义映射到相应的alpha命名类型参数。\r\n \r\n","\r\n Returns a copy of this with the Token property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，令牌属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","A collection of strings to be parsed.":"要解析的字符串集合。\r\n","\r\n            clean up this code when we do selection validator work.\r\n            ":"\r\n            当我们进行选择验证器工作时，请清理此代码。\r\n            \r\n","\r\n A list of xml node syntax that will be the content within the xml documentation comment\r\n (e.g. a summary element, a returns element, exception element and so on).\r\n ":"\r\n XML节点语法列表，该语法将是XML文档注释中的内容\r\n （例如，摘要元素，返回元素，异常元素等）。\r\n \r\n","\r\n The statements contained in the block statement. This might be an empty list.\r\n ":"\r\n 块语句中包含的语句。这可能是一个空列表。\r\n \r\n","The type implementing the interface member.":"实现接口成员的类型。\r\n","\r\n Entry point is considered accessible if it is not private and none of the containing types is private (they all might be Family or Friend).\r\n ":"\r\n 如果入口点不是私有的，则可以将其视为访问，并且任何包含类型都不是私有的（它们都可能是家人或朋友）。\r\n \r\n","The \\b anchor specifies that the match must occur on a boundary between a word character (the \\w language element) and a non-word character (the \\W language element). Word characters consist of alphanumeric characters and underscores; a non-word character  ...":"\\ b锚指定该匹配必须发生在单词字符（\\ w语言元素）和非单词字符（\\ w语言元素）之间的边界上。单词字符由字母数字字符和下划线组成；一个非字的角色...\r\n","\r\n The value for the NewExpression property.\r\n ":"\r\n 新表达属性的值。\r\n \r\n","The {n}? quantifier matches the preceding element exactly n times, where n is any integer. It is the lazy counterpart of the greedy quantifier {n}+":"然后}？量词匹配前面的元素n次，其中n是任何整数。这是贪婪量词{n}+的懒惰对应物\r\n","\r\n Returns a copy of this with the LessThanExclamationMinusMinusToken property\r\n changed to the specified value. Returns this instance if the specified value is\r\n the same as the current value.\r\n ":"\r\n 返回使用LessThaneXClamationMinusMinustoken属性的副本\r\n 更改为指定值。如果指定的值为\r\n 与当前值相同。\r\n \r\n","\r\n The \"If\" keyword.\r\n ":"\r\n “如果”关键字。\r\n \r\n","\r\n  Looks up a localized string similar to '=' expected..\r\n":"\r\n  查找类似于“ =”预期的局部字符串。\r\n\r\n","\r\n  Looks up a localized string similar to Friend assembly reference '{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified..\r\n":"\r\n  查找类似于朋友汇编引用'{0}'的本地化字符串无效。 InternalSvisibleto声明不能具有指定的版本，文化，公钥令牌或处理器体系结构。\r\n\r\n","\r\n Negates the value if step is negative\r\n ":"\r\n 如果步进为负，则否定该值\r\n \r\n","\r\n            Displays a message box with an OK button to the user.\r\n            ":"\r\n            向用户显示带有确定按钮的消息框。\r\n            \r\n","\r\n Do additional verification of base types the after acyclic base is found. This is\r\n the chance to generate diagnostics that may require walking bases and as such\r\n can be performed only after the base has been determined and cycles broken.\r\n (For instance, checking constraints on Class B(Of T) Inherits A(Of B(Of T)).)\r\n ":"\r\n 对基本类型进行额外验证，发现了无环碱后。这是\r\n 产生可能需要步行基地的诊断的机会，因此\r\n 只有在确定基座并循环破裂后才可以执行。\r\n （例如，检查B级（t）上的约束将继承A（b（of t）的B（of t））。\r\n \r\n","\r\n The value for the LessThanQuestionToken property.\r\n ":"\r\n LessThanquestiontoken属性的价值。\r\n \r\n"," representing the specific kind of\r\n IfDirectiveTriviaSyntax. One of IfDirectiveTrivia, ElseIfDirectiveTrivia.\r\n ":" 代表特定种类\r\n IFDirectivriviaSyntax。 ifirectivtrivia之一，ElseifDirectivtrivia。\r\n \r\n","\r\n The value for the Members property.\r\n ":"\r\n 成员属性的值。\r\n \r\n","\r\n Scan a single quoted string\r\n ":"\r\n 扫描单个引用的字符串\r\n \r\n","\r\n Type name.\r\n ":"\r\n 类型名称。\r\n \r\n","\r\n Bind parameters declared on the accessor and combine with any\r\n parameters declared on the property. If there are no explicit parameters\r\n and this is a setter, create a synthesized value parameter.\r\n ":"\r\n 绑定在登录机上声明的参数，并与任何\r\n 属性上声明的参数。如果没有明确的参数\r\n 这是一个设置器，创建一个合成的值参数。\r\n \r\n","\r\n            The name token for the invocation node that replaces the extracted code.\r\n            ":"\r\n            替换提取的代码的调用节点的名称令牌。\r\n            \r\n","\r\n Represents part of a single line If statement, consisting of a beginning\r\n if-statement, followed by a body of statement controlled by that beginning\r\n statement. The Kind property returns if this is an SingleLineIf.\r\n ":"\r\n 代表单行if语句的一部分，由开始\r\n 如果说明，则是由该开始控制的一系列陈述\r\n 陈述。如果这是单线线，则属性属性将返回。\r\n \r\n","\r\n The value for the ParameterList property.\r\n ":"\r\n 参数列表属性的值。\r\n \r\n","\r\n most of time all compilation would use same MyTemplate. no reason to create (reparse) one for each compilation\r\n as long as its parse option is same\r\n ":"\r\n 大多数时候，所有汇编都将使用相同的myTemplate。没有理由为每次编译创建（重新）一个\r\n 只要其解析选项相同\r\n \r\n","Add parameters to '{0}'":"将参数添加到'{0}'\r\n","Builder to place exactly-matched inaccessible overridden member candidates in. ":"建造者将完全匹配的不访问的超级成员候选人放在其中。\r\n","\r\n Returns a copy of this with the EnumKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中EnumKeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n  Looks up a localized string similar to There were one or more errors emitting a call to {0}.{1}. Method or its return type may be missing or malformed..\r\n":"\r\n  查找类似于一个或多个错误的本地化字符串，该错误发出了一个呼叫{0}。{1}。方法或其返回类型可能丢失或畸形。\r\n\r\n","\r\n The value for the DoStatement property.\r\n ":"\r\n dostatement属性的值。\r\n \r\n","\r\n            Used to map a symbol to the annotation that was added at the beginning of it's definition. Use the \r\n            annotation the symbol declaration again across edits.\r\n            ":"\r\n            用于将符号映射到其定义开始时添加的注释。使用\r\n            注释符号声明再次跨编辑。\r\n            \r\n"," The definite assignment and/or reachability state at the point currently being analyzed. ":"当前正在分析的点，确定的分配和/​​或可达性状态。\r\n","\r\n  Looks up a localized string similar to 'If' must end with a matching 'End If'..\r\n":"\r\n  查找类似于“如果”必须以匹配的“ end”结尾的本地化字符串。\r\n\r\n","\r\n Creates a list of trivia.\r\n ":"\r\n 创建琐事列表。\r\n \r\n","\r\n Returns a copy of this with the [Implements] property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，并将[insterments]属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n"," is a parameter,\r\n            - a method or an type if the ":" 是一个参数，\r\n             - 方法或类型\r\n","'{0}' does not override expected method from '{1}'.":"'{0}'不会从'{1}'中覆盖预期的方法。\r\n","\r\n            The tree ":"\r\n            那个树\r\n"," Flat array of created methods, non-empty if not-nothing ":" 扁平的创建方法，非空的，即使没有\r\n","Braces are preferred where allowed except in the following limited situations:":"除下列有限情况外，在允许的情况下，大括号是首选:\r\n","\r\n Represents an Xml NCName per Namespaces in XML 1.0\r\n ":"\r\n 代表XML 1.0中每个名称空间的XML NCNAME\r\n \r\n","\r\n            The text used to determine if the item matches the filter and is show in the list.\r\n            This is often the same as ":"\r\n            用于确定项目是否匹配过滤器并在列表中显示的文本。\r\n            这通常与\r\n","\r\n NOTE: Presently, we do not cache the per-tree diagnostics.\r\n ":"\r\n 注意：目前，我们不会缓存每个树诊断。\r\n \r\n","\r\n Represents the \"In\" or \"Out\" variance keyword on a type parameter, if present.\r\n If no variance modifier was present, Nothing is returned.\r\n ":"\r\n 表示类型参数上的“ in”或“ out”方差关键字，如果存在。\r\n 如果没有差异修饰符，则什么都不会返回。\r\n \r\n","\r\n            Lexically, find the last token that looks like it's part of this generic name.\r\n            ":"词汇上，找到看起来像该通用名称的一部分的最后一个令牌。\r\n            \r\n","\r\n            It's intended to be used in conjunction with ":"\r\n            它打算与\r\n","\r\n The \")\" token, if present.\r\n ":"\r\n 如果存在，则“）”令牌。\r\n \r\n","A negative character range specifies a list of characters that must not appear in an input string for a match to occur. 'firstCharacter' is the character that begins the range, and 'lastCharacter' is the character that ends the range.\r\n            \r\n            Two or more characte ...":"负字符范围指定一个不得出现在输入字符串中以进行匹配的字符列表。 “ First Character”是开始范围的字符，“ LastCharacter”是结束范围的字符。\r\n            \r\n            两个或多个characte ...\r\n","\r\n The value for the Initializers property.\r\n ":"\r\n 初始化属性的值。\r\n \r\n","\r\n            True if the region represents an exception region, false if it represents an active statement.\r\n            ":"\r\n            true如果区域代表异常区域，则为false代表活动语句。\r\n            \r\n","\r\n The value for the ImplementsKeyword property.\r\n ":"\r\n strumentementKeyword属性的值。\r\n \r\n","The kind of rule.":"那种规则。\r\n","\r\n            Produces completions using the previous character to determine which set of\r\n            regex items to show.\r\n            ":"\r\n            使用以前的角色确定哪一组\r\n            将显示的正则项目。\r\n            \r\n","universal full date/time":"通用全约日期/时间\r\n","\r\n Create a bad statement.  Report an error only if the statement doesn't have one already\r\n ":"\r\n 创建一个不好的声明。仅在语句尚未报告时报告错误\r\n \r\n","\r\n Creates an xml documentation comment that abstracts xml syntax creation.\r\n ":"\r\n 创建一个XML文档注释，该注释抽象XML语法创建。\r\n \r\n","A bound property access for \"Current\" on the instance returned by GetEnumerator if found.":"如果找到了getEnumerator返回的实例，则限制了属性访问权限。\r\n","\r\n Represents global namespace. Namespace's name is always empty\r\n ":"\r\n 代表全局名称空间。名称空间的名称总是空的\r\n \r\n","\r\n            True if semantic analysis should be skipped for the replaced node and performed starting from parent of the original and replaced nodes.\r\n            This could be the case when custom verifications are required to be done by the caller or\r\n            semantics of the replaced expression are different from the original expression.\r\n            ":"\r\n            如果要跳过替换节点的语义分析，并从原始节点的父母开始执行，则是正确的。\r\n            当需要呼叫者进行自定义验证或\r\n            替换表达式的语义与原始表达式不同。\r\n            \r\n","\r\n The value for the ArrayRankSpecifiers property.\r\n ":"\r\n ArrayRankSpecifiers属性的值。\r\n \r\n","\r\n Represents a \"Stop\" or \"End\" statement. The Kind can be used to determine which\r\n kind of statement this is.\r\n ":"\r\n 代表“停止”或“结束”语句。这种类型可用于确定哪个\r\n 这是一种陈述。\r\n \r\n","True if the related completion item should be initially selected.":"如果应该选择相关的完成项，则为正确。\r\n","\r\n Create a new token with the trivia prepended to the existing preceding trivia\r\n ":"\r\n 创建一个新的代币，琐事曾在现有的琐事上添加\r\n \r\n","Wrap every parameter":"包装每个参数\r\n","\r\n Create a range variable symbol not associated with an identifier token, i.e. with illegal name.\r\n Used for error recovery binding.\r\n ":"创建与标识符令牌无关的范围变量符号，即具有非法名称。\r\n 用于错误恢复绑定。\r\n \r\n","Wrap long argument list":"包裹长论点清单\r\n","\r\n Represents a parenthesized argument list.\r\n ":"\r\n 代表括号的参数列表。\r\n \r\n","\r\n            Helps fix void-returning methods or local functions to return a correct type.\r\n            ":"\r\n            有助于修复返回的返回方法或本地功能以返回正确的类型。\r\n            \r\n","\r\n Get all implicitly declared variables that were declared in this method body.\r\n ":"\r\n 获取该方法主体中声明的所有隐式声明变量。\r\n \r\n","\r\n Attribute location corresponding to this symbol.\r\n ":"\r\n 属性位置与此符号相对应。\r\n \r\n","\r\n            Operation responsible purely for installing a nuget package with a specific \r\n            version, or a the latest version of a nuget package.  Is not responsible\r\n            for adding an import to user code.\r\n            ":"\r\n            操作纯粹用于安装具有特定特定的Nuget软件包\r\n            版本或Nuget软件包的最新版本。不负责\r\n            用于将导入添加到用户代码。\r\n            \r\n","\r\n  Looks up a localized string similar to Cannot update '{0}'; attribute '{1}' is missing..\r\n":"\r\n  查找类似于无法更新'{0}'的本地化字符串;属性'{1}'丢失了。\r\n\r\n","\r\n  Looks up a localized string similar to '{0}' is not valid on a method declaration..\r\n":"\r\n  在方法声明上查找类似于“ {0}”的本地化字符串。\r\n\r\n","\r\n Attempts to fold conversion of a constant expression. \r\n \r\n Returns Nothing if conversion cannot be folded.\r\n \r\n If conversion failed due to non-integer overflow, ConstantValue.Bad is returned. Consumer \r\n is responsible for reporting appropriate diagnostics.\r\n \r\n If integer overflow occurs, integerOverflow is set to True and ConstantValue for overflowed result is returned. \r\n Consumer is responsible for reporting appropriate diagnostics and potentially discarding the result.\r\n ":"\r\n 尝试折叠恒定表达式的转换。\r\n \r\n 如果无法折叠转换，则无需返回。\r\n \r\n 如果转换因非直集溢出而失败，则返回ConstantValue.bad。消费者\r\n 负责报告适当的诊断。\r\n \r\n 如果发生整数溢出，则将InteGerOverFlow设置为True，并且返回溢出结果的ConsentValue。\r\n 消费者负责报告适当的诊断并可能丢弃结果。\r\n \r\n","\r\n Given a namespace symbol, returns the corresponding namespace symbol with Compilation extent\r\n that refers to that namespace in this compilation. Returns Nothing if there is no corresponding \r\n namespace. This should not occur if the namespace symbol came from an assembly referenced by this\r\n compilation. \r\n ":"\r\n 给定的名称空间符号，返回编译范围的相应名称空间符号\r\n 这是指此编辑中的该名称空间。如果没有相应的话，什么也不会返回\r\n 名称空间。如果命名空间符号来自此引用的组件，则不应发生这种情况\r\n 汇编。\r\n \r\n","Changing the return type of {0} requires restarting the application.":"更改{0}的返回类型需要重新启动应用程序。\r\n","Align wrapped arguments":"对齐包裹的论点\r\n","\r\n Returns True if two ":"\r\n 如果两个\r\n","Use discard '_'":"使用丢弃'_'\r\n","\r\n Returns a copy of this with the Standalone property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，独立属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","The label symbol, or Nothing if no such symbol exists.":"标签符号，或者如果不存在这样的符号。\r\n","\r\n Get the label that a Continue XXX statement should branch to, or Nothing if we are\r\n not inside a context that would be exited by that kind of statement. The passed in kind\r\n is the SyntaxKind for the exit statement that would target the label (e.g. SyntaxKind.ContinueDoStatement).\r\n ":"\r\n 获取继续XXX语句应分支到的标签，或者如果我们是什么都不是\r\n 不在这种陈述将退出的上下文中。通过了实物\r\n 是针对标签的退出语句的语法Kind（例如Syntaxkind.ContinueDostatement）。\r\n \r\n","Install package '{0}'":"安装软件包'{0}'\r\n","The character position for determining the enclosing declaration scope and\r\n accessibility.":"确定封闭声明范围的字符位置和\r\n 可访问性。\r\n","\r\n Modified identifier appeared in a local declaration.\r\n ":"\r\n 修改后的标识符出现在本地声明中。\r\n \r\n","\r\n  Looks up a localized string similar to Conflict between the default property and the 'DefaultMemberAttribute' defined on '{0}'..\r\n":"\r\n  查找类似于默认属性和在“ {0}”上定义的“ defaultmemberattribute”之间冲突的本地化字符串。\r\n\r\n","\r\n An \"Else\" block to be executed if the condition expression of the \"If\"\r\n statement and all \"ElseIf\" blocks evaluate as false.\r\n ":"\r\n 如果“ if”的条件表达式执行一个“ else”块\r\n 语句和所有“ elseif”块评估为false。\r\n \r\n","\r\n Represents the beginning statement of a namespace declaration. This node always\r\n appears as the Begin of a BlockStatement with Kind=NamespaceBlock.\r\n ":"代表名称空间声明的开始语句。这个节点总是\r\n 出现是带有bink = namespaceBlock的块开始的开始。\r\n \r\n","\r\n Helper methods for generic type parameter constraints. There are two sets of methods: one\r\n set for resolving constraint \"bounds\" (that is, determining the effective base type, interface set,\r\n etc.), and another set for checking for constraint violations in type and method references.\r\n \r\n Bounds are resolved by calling one of the ResolveBounds overloads. Typically bounds are\r\n resolved by each TypeParameterSymbol at, or before, one of the corresponding properties\r\n (BaseType, Interfaces, etc.) is accessed. Resolving bounds may result in errors (cycles,\r\n inconsistent constraints, etc.) and it is the responsibility of the caller to report any such\r\n errors as declaration errors or use-site errors (depending on whether the type parameter\r\n was from source or metadata) and to ensure bounds are resolved for source type parameters\r\n even if the corresponding properties are never accessed directly.\r\n \r\n Constraints are checked by calling one of the CheckConstraints or CheckAllConstraints\r\n overloads for any generic type or method reference from source. In some circumstances,\r\n references are checked at the time the generic type or generic method is bound and constructed\r\n by the Binder. In those case, it is sufficient to call one of the CheckConstraints overloads\r\n since compound types (such as A(Of T).B(Of U) or A(Of B(Of T))) are checked incrementally\r\n as each part is bound. In other cases however, constraint checking needs to be delayed to\r\n prevent cycles where checking constraints requires binding the syntax that is currently\r\n being bound (such as the constraint in Class C(Of T As C(Of T)). In those cases, the caller\r\n must lazily check constraints, and since the types may be compound types, it is necessary\r\n to call CheckAllConstraints.\r\n ":"\r\n 泛型类型参数约束的帮助器方法。 有两套方法：一\r\n 设置用于解决约束\"边界\"（即确定有效的基类型，接口集,\r\n 等。），以及另一个用于检查类型和方法引用中的约束违规的集合。\r\n \r\n 通过调用其中一个ResolveBounds重载来解析边界。 通常边界是\r\n 由每个TypeParameterSymbol在相应属性之一或之前解析\r\n （BaseType，Interfaces等。)进行访问。 解决边界可能会导致错误（周期,\r\n 不一致的约束等。)而来电者有责任举报任何该等资料\r\n 作为声明错误或使用站点错误的错误（取决于类型参数是否\r\n 是来自源或元数据），并确保解析源类型参数的边界\r\n 即使从不直接访问相应的属性。\r\n \r\n 通过调用CheckConstraints或CheckAllConstraints之一来检查约束\r\n 来自源代码的任何泛型类型或方法引用的重载。 在某些情况下,\r\n 在绑定和构造泛型类型或泛型方法时检查引用\r\n 由粘结剂。 在这种情况下，调用其中一个CheckConstraints重载就足够了\r\n 由于化合物类型(如A(T).B(Of U)或A(Of B(Of T)))进行增量检查\r\n 作为每个部分被束缚。 然而，在其他情况下，约束检查需要延迟到\r\n 防止检查约束需要绑定当前语法的循环\r\n 被约束（例如C类中的约束（T作为C（T））。 在这些情况下，呼叫者\r\n 必须懒惰地检查约束，并且由于类型可能是复合类型，因此有必要\r\n 调用CheckAllConstraints。\r\n \r\n","\r\n  Looks up a localized string similar to Friend access was granted by '{0}', but the public key of the output assembly does not match that specified by the attribute in the granting assembly..\r\n":"\r\n  查找类似于朋友访问的本地化字符串由“ {0}”授予，但是输出组件的公共密钥与授予程序集中的属性指定的公共密钥不匹配。\r\n\r\n","\r\n  Looks up a localized string similar to Explicit initialization is not permitted with multiple variables declared with a single type specifier..\r\n":"\r\n  查找类似于显式初始化的本地化字符串，不允许使用单个类型指示符声明的多个变量。\r\n\r\n","\r\n A Module object providing metadata.\r\n ":"\r\n 提供元数据的模块对象。\r\n \r\n","\r\n If we have a WinRT type event, we need to encapsulate the adder call\r\n (which returns an EventRegistrationToken) with a call to \r\n WindowsRuntimeMarshal.AddEventHandler or RemoveEventHandler, but these\r\n require us to create a new Func representing the adder and another\r\n Action representing the remover.\r\n \r\n The rewritten call looks something like:\r\n \r\n WindowsRuntimeMarshal.AddEventHandler(Of TEventHandler)(\r\n            New Func(Of TEventHandler, EventRegistrationToken)([object].add_T), \r\n            New Action(Of EventRegistrationToken)([object].remove_T), \r\n            New TEventHandler(Me.OnSuspending))\r\n \r\n \r\n where [object] is a compiler-generated local temp.\r\n \r\n For a remover, the call looks like:\r\n \r\n WindowsRuntimeMarshal.RemoveEventHandler(Of TEventHandler)(\r\n            New Action(Of EventRegistrationToken)([object].remove_T), \r\n            New TEventHandler(Me.OnSuspending))\r\n ":"\r\n 如果我们有一个WinRT类型的事件，我们需要封装加法器调用\r\n （它返回一个EventRegistrationToken）与调用 \r\n WindowsRuntimeMarshal.AddEventHandler或RemoveEventHandler，但这些\r\n 要求我们创建一个新的Func表示加法器和另一个\r\n 表示去除器的动作。\r\n \r\n 重写的调用看起来像:\r\n \r\n WindowsRuntimeMarshal.AddEventHandler（TEventHandler的）（\r\n            New Func(Of TEventHandler,EventRegistrationToken)([object].add_T), \r\n            New Action(Of EventRegistrationToken)([object].remove_T), \r\n            新TEventHandler（我。OnSuspending））\r\n \r\n \r\n 其中[object]是编译器生成的本地temp。\r\n \r\n 对于一个卸妆，调用看起来像:\r\n \r\n WindowsRuntimeMarshal.Teventhandler（TEventHandler的）（\r\n            New Action(Of EventRegistrationToken)([object].remove_T), \r\n            新TEventHandler（我。OnSuspending））\r\n \r\n","\r\n            Represents a constant-pattern, constructed from an equality check\r\n            ":"代表由平等检查构建的恒定模式\r\n            \r\n","\r\n  Looks up a localized string similar to '{0}' conflicts with the reserved member by this name that is implicitly declared in all enums..\r\n":"\r\n  查找类似于“ {0}”与此名称的保留成员冲突的本地化字符串，该名称在所有枚举中隐含地声明。\r\n\r\n","\r\n  Looks up a localized string similar to 'Option Infer' can be followed only by 'On' or 'Off'..\r\n":"\r\n  查找类似于“选项推断”的局部字符串，只能在“ on”或“ off”中。\r\n\r\n","\r\n            Get all import statements in scope for this syntax by traversing up the tree and searching in containing namespaces and compilation units.\r\n            ":"\r\n            通过遍历树和包含命名空间和编译单元的搜索，获取此语法范围中的所有导入语句。\r\n            \r\n"," representing the specific kind of\r\n BinaryExpressionSyntax. One of AddExpression, SubtractExpression,\r\n MultiplyExpression, DivideExpression, IntegerDivideExpression,\r\n ExponentiateExpression, LeftShiftExpression, RightShiftExpression,\r\n ConcatenateExpression, ModuloExpression, EqualsExpression, NotEqualsExpression,\r\n LessThanExpression, LessThanOrEqualExpression, GreaterThanOrEqualExpression,\r\n GreaterThanExpression, IsExpression, IsNotExpression, LikeExpression,\r\n OrExpression, ExclusiveOrExpression, AndExpression, OrElseExpression,\r\n AndAlsoExpression.\r\n ":" 代表特定种类\r\n 二进制expressionsyntax。添加表达之一，减去表达，\r\n 多重表达，分裂表达，integerdivide表达，\r\n exponentiateexpression，左置表达，右递表达，\r\n conteNate表达，模量表达，平等性，notequalsexpression，\r\n 较少的X骨，较少的thanorequalexpression，更大的thanorequalexpression，\r\n 更大的thanexpression，is Expression，isnotexpression，类似表达，\r\n 或表达，独家饰面，表达，骨髓表达，\r\n Andalsoexpression。\r\n \r\n","Instance fields of readonly structs must be readonly.":"必须阅读可读结构的实例字段。\r\n","\r\n Represents either text content or an interpolation.\r\n ":"\r\n 代表文本内容或插值。\r\n \r\n","\r\n Given a modified identifier and a type, return the actual type to use. Applies the type character\r\n and type modifiers to the given type.\r\n ":"\r\n 给定修改后的标识符和类型，请返回实际类型要使用。应用类型字符\r\n 并将修饰符键入给定类型。\r\n \r\n","\r\n Modified identifier appeared in a lambda declaration.\r\n ":"\r\n 修改后的标识符出现在Lambda声明中。\r\n \r\n","\r\n Ignore 'throughType' in accessibility checking. Used in checking accessibility of symbols accessed via 'MyBase'.\r\n ":"在可访问性检查中忽略“渐进性”。用于检查通过“ Mybase”访问的符号的可访问性。\r\n \r\n"," \r\n True if 'Overloads' is explicitly specified in method's declaration.\r\n ":" \r\n 正确，如果在方法的声明中明确指定了“超载”。\r\n \r\n","Simplify object initialization":"简化对象初始化\r\n","\r\n The expression that denotes the value being tested against.\r\n ":"\r\n 表示要测试的值的表达式。\r\n \r\n","\r\n Check if XML features are allowed. If not, report an error and return a\r\n separate DiagnosticBag that can be used for binding sub-expressions.\r\n ":"\r\n 检查是否允许XML功能。如果没有，请报告错误并返回\r\n 可用于绑定子表达的单独诊断袋。\r\n \r\n","\r\n represents a single item in Handles list.\r\n ":"\r\n 代表手柄列表中的一个项目。\r\n \r\n","\r\n Given an import clause get the corresponding symbol for the import alias that was introduced.\r\n ":"\r\n 给定一个导入条款获取引入的导入别名的相应符号。\r\n \r\n","second (2 digits)":"第二个（2位数字）\r\n"," is not an existing path.":" 不是现有路径。\r\n","Whether to rewrite keywords in default casing or not":"是否在默认外壳中重写关键字\r\n","\r\n            Are you possibly in the designation part of a deconstruction?\r\n            This is used to enter suggestion mode (suggestions become soft-selected).\r\n            ":"\r\n            您是否可能在解构的指定部分中？\r\n            这用于输入建议模式（建议变软选择）。\r\n            \r\n","Analyzer that looks for code like:":"查找类似代码的分析仪：\r\n","Nullability in constraints for type parameter doesn't match the constraints for type parameter in implicitly implemented interface method'.":"类型参数的约束中的无效性与隐式实现的接口方法中的类型参数的约束不匹配。\r\n","\r\n Issue an error or warning for a symbol if it is Obsolete. If there is not enough\r\n information to report diagnostics, then store the symbols so that diagnostics\r\n can be reported at a later stage.\r\n ":"\r\n 如果符号已过时，就会发出错误或警告。如果没有足够的\r\n 信息以报告诊断，然后存储符号，以便诊断\r\n 可以在以后的阶段进行报告。\r\n \r\n","\r\n  Looks up a localized string similar to Event '{0}' cannot be found..\r\n":"\r\n  查找类似于事件'{0}'的本地化字符串。\r\n\r\n"," that works by delegating to\r\n            ":" 通过委派\r\n            \r\n","event accessor":"事件访问者\r\n","\r\n The expression inside the parentheses.\r\n ":"\r\n 括号内的表达式。\r\n \r\n"," to the iteration variable type.\r\n ":" 到迭代变量类型。\r\n \r\n","\r\n Represents container of an event in a Handles clause item.\r\n ":"\r\n 代表处理子句项目中事件的容器。\r\n \r\n","\r\n  Looks up a localized string similar to Anonymous type member name must be preceded by a period..\r\n":"\r\n  查找类似于匿名类型成员名称的本地化字符串必须先于一个段。\r\n\r\n","\r\n Returns a copy of this with the OperatorKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中operatorkeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n  Looks up a localized string similar to Local variables within generic methods cannot be declared 'Static'..\r\n":"\r\n  在通用方法中查找类似于局部变量的本地化字符串不能声明为“静态”。\r\n\r\n","general long date/time":"一般长期/时间\r\n","\r\n The \"When\" keyword.\r\n ":"\r\n “当”关键字。\r\n \r\n","\r\n            through (but not including) the matching ":"\r\n            通过（但不包括）匹配\r\n","\r\n Represents a compiler generated field for a \"MyGroupCollection\" property.\r\n ":"\r\n 代表“ myGroupCollection”属性的编译器生成的字段。\r\n \r\n","\r\n  Handle ArrayCreationExpressionSyntax\r\n   new integer(n)(,) {...}\r\n   new integer() {...}\r\n ":"\r\n  处理arrayCreationexpressynntax\r\n   新整数（n）（，）{...}\r\n   新Integer（）{...}\r\n \r\n","\r\n Finds a token according to the following rules:\r\n 1)\tIf position matches the End of the node's Span, then its last token is returned. \r\n \r\n 2)\tIf node.FullSpan.Contains(position) then the token that contains given position is returned.\r\n \r\n 3)\tOtherwise an IndexOutOfRange is thrown\r\n ":"\r\n 根据以下规则找到令牌：\r\n 1）如果位置与节点跨度的末端匹配，则返回其最后一个令牌。\r\n \r\n 2）如果node.fullspan.contains（位置），则返回包含给定位置的令牌。\r\n \r\n 3）否则会抛出索引\r\n \r\n","'s name.\r\n            ":"\"她的名字。\r\n            \r\n","\r\n The value for the AggregationVariables property.\r\n ":"\r\n 聚合变量属性的值。\r\n \r\n","\r\n Gets member group information about an attribute syntax node. This is the worker\r\n function that is overridden in various derived kinds of Semantic Models. It can assume that \r\n CheckSyntaxNode has already been called.\r\n ":"\r\n 获取有关属性语法节点的成员组信息。这是工人\r\n 在各种派生的语义模型中被覆盖的函数。它可以假设\r\n checksyntaxnode已被调用。\r\n \r\n","GetConversionClassification":"getConversionClassification\r\n","\r\n            An item that is displayed and can be chosen but which has no action.\r\n            ":"\r\n            显示的项目可以选择但没有任何动作。\r\n            \r\n","\r\n            Emits updates for all projects that differ between the given ":"\r\n            给定的所有项目的发射更新\r\n","name2":"name2\r\n","\r\n  Looks up a localized string similar to Constant expression not representable in type '{0}'..\r\n":"\r\n  查找类似于“ {0}'”类型的常数表达式类似的局部字符串。\r\n\r\n","\r\n Determines if the Unicode character is a newline character.\r\n ":"\r\n 确定Unicode字符是否为newline字符。\r\n \r\n"," so we can \r\n            retrieve the symbol later on when navigating.  This is needed so that we can go to\r\n            metadata-as-source for metadata symbols.  We need to store the ":" 所以我们可以\r\n            稍后在导航时检索符号。这是需要的，以便我们可以去\r\n            元数据符号的元数据。我们需要存储\r\n"," \r\n            except it only returns fix data when there is a single using fix for a given span\r\n            ":" \r\n            除了仅在给定跨度使用单个修复时，它仅返回修复数据\r\n            \r\n","\r\n The value for the SubKeyword property.\r\n ":"\r\n 子关键属性的值。\r\n \r\n","\r\n Get symbol for predefined type from Cor Library used by this assembly.\r\n ":"\r\n 从此组件使用的COR库中获取预定义类型的符号。\r\n \r\n","\r\n  Looks up a localized string similar to 'End SyncLock' must be preceded by a matching 'SyncLock'..\r\n":"\r\n  查找类似于“结束同步”的本地化字符串必须先于匹配的“ Synclock”。\r\n\r\n","\r\n The value for the AscendingOrDescendingKeyword property.\r\n ":"\r\n AscendingOdsCendingKeyWord属性的值。\r\n \r\n","The members.":"成员。\r\n","\r\n The namespace or type being imported.\r\n ":"\r\n 名称空间或类型正在导入。\r\n \r\n","\r\n Represents source or metadata assembly.\r\n ":"\r\n 代表源或元数据组件。\r\n \r\n","\r\n The keyword that ends the block. Must be one of: \"If\", \"Using\", \"With\",\r\n \"Select\", \"Structure\", \"Enum\", \"Interface\", \"Class\", \"Module\", \"Namespace\",\r\n \"Sub\", \"Function\", \"Get, \"Set\", \"Property\", \"Operator\", \"Event\", \"AddHandler\",\r\n \"RemoveHandler\", \"RaiseEvent\", \"While\", \"Try\" or \"SyncLock\".\r\n ":"\r\n 结束块的关键字。必须是：“如果”，“使用”，“ with”，\r\n “选择”，“结构”，“枚举”，“接口”，“类”，“模块”，“ namespace”，\r\n “ sub”，“ function”，“ get”，“ set”，“属性”，“操作员”，“事件”，“ Addhandler”，\r\n “删除Handler”，“ raiseevent”，“ while”，“ try”或“ synclock”。\r\n \r\n","\r\n The syntax node(s) that declared the symbol. If the symbol was declared in metadata\r\n or was implicitly declared, returns an empty read-only array.\r\n ":"\r\n 声明为符号的语法节点。如果在元数据中宣布该符号\r\n 或被隐式声明，返回一个空的只读数组。\r\n \r\n","\r\n Lazy CoClass type if the attribute is specified. Nothing if not.\r\n ":"\r\n 如果指定了属性，则懒惰的瓶类型。如果没有，什么也没有。\r\n \r\n","'&' on method groups cannot be used in expression trees":"'＆'方法组不能在表达树中使用\r\n","unmanaged generic type constraints":"不受管理的通用类型约束\r\n","\r\n  Looks up a localized string similar to Default property access is ambiguous between the inherited interface members '{0}' of interface '{1}' and '{2}' of interface '{3}'..\r\n":"\r\n  查找类似于默认属性访问的本地化字符串在继承的接口成员'{0}'interface'{1}'和'{2}'interface'{3}'..之间的模棱两可。\r\n\r\n","\r\n Used to decide if we need to emit call or callvirt.\r\n It basically checks if the receiver expression cannot be null, but it is not 100% precise. \r\n There are cases where it really can be null, but we do not care.\r\n ":"\r\n 用于决定我们是否需要发出呼叫或通话。\r\n 它基本上检查了接收器表达式是否不能为空，但不是100％精确的。\r\n 在某些情况下，它确实可能是无效的，但我们不在乎。\r\n \r\n","The #line directive value is missing or out of range":"#line指令值丢失或超出范围\r\n","\r\n Represents the clause of an Imports statement that imports all members of a type or namespace or aliases a type or namespace.\r\n ":"\r\n 表示导入类型或名称空间的所有成员或类型或名称空间的所有成员的子句。\r\n \r\n","In Dev10 this was called ParseInitializerList.  It also took several boolean parameters.  \r\n  These were always set as \r\n       AllowExpressionInitializers = true\r\n       AllowAssignmentInitializers = false\r\n       AnonymousTypeInitializer = false\r\n       RequireAtleastOneInitializer = false\r\n \r\n  While the grammar uses the nonterminal CollectionInitializer is modeled as an\r\n  AnonymousArrayCreationExpression which has the identical syntax \"{\" Expression {\",\" Expression }* \"}\"\r\n ":"在Dev10中，这被称为ParseinitializerList。它还需要几个布尔参数。\r\n  这些总是被视为\r\n       允许expresseptryInitializer = true\r\n       允许AssignmentInitializer = false\r\n       AnonymousTypeinItializer = false\r\n       需求feastononeInitializer = false\r\n \r\n  语法使用非末端收集器时，将其建模为\r\n  具有相同语法“ {” expression {，“ expression}*”}“}”的匿名语法expression\r\n \r\n","\r\n            Return true if the invocation expression with new arguments is applicable.\r\n            Otherwise, return false\r\n            ":"\r\n            如果适用带有新参数的调用表达式，则返回true。\r\n            否则，返回false\r\n            \r\n","mark, spacing combining":"马克，间距组合\r\n","\r\n  Looks up a localized string similar to Type characters cannot be used in anonymous type declarations..\r\n":"\r\n  查找类似于类型字符的本地化字符串无法在匿名类型声明中使用。\r\n\r\n","match between 'm' and 'n' times":"匹配“ M”和“ N”时间\r\n","\r\n Represents MDARRAY - multi-dimensional array (possibly of rank 1)\r\n ":"\r\n 代表mdarray-多维数组（可能是等级1）\r\n \r\n","\r\n  Looks up a localized string similar to 'Inherits' not valid in Modules..\r\n":"\r\n  查找类似于模块中无效的“继承”的本地化字符串。\r\n\r\n","All punctuation characters. This includes the Pc, Pd, Ps, Pe, Pi, Pf, and Po categories.":"所有标点字符。这包括PC，PD，PS，PE，PI，PF和PO类别。\r\n","\r\n Calculates a syntax offset for a local (user-defined or long-lived synthesized) declared at ":"\r\n 计算在本地（用户定义或长寿命合成）声明的语法偏移量\r\n","\r\n  Looks up a localized string similar to 'On' expected..\r\n":"\r\n  查找类似于“预期”的局部字符串。\r\n\r\n","\r\n Get a SyntaxReference associated with a given syntax node.\r\n ":"\r\n 获取与给定语法节点关联的语法rreference。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' in class '{1}' cannot override '{2}' in class '{3}' because an intermediate class '{4}' overrides '{2}' in class '{3}' but is not accessible..\r\n":"\r\n  查找类似于'class'{1}'in class'{3}'的'{1}'in Class'{1}'中的'{0}'的本地化字符串，因为'{3}'因为中间类'{4}'覆盖'{2}'in Class in Class' '{3}'但无法访问。\r\n\r\n","\r\n Gets the root node of the syntax tree.\r\n ":"\r\n 获取语​​法树的根节点。\r\n \r\n","'managed' calling convention cannot be combined with unmanaged calling convention specifiers.":"“托管”呼叫约定不能与未管理的呼叫公约规范结合使用。\r\n","\r\n Returns a copy of this with the Condition property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，条件属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            Try to get a new node to replace given node, which is a reference to a top-level type declared inside the namespace to be changed.\r\n            If this reference is the right side of a qualified name, the new node returned would be the entire qualified name. Depends on \r\n            whether ":"\r\n            尝试获取一个新的节点替换给定节点，这是对要更改的名称空间中声明的顶级类型的引用。\r\n            如果此引用是合格名称的右侧，则返回的新节点将是整个合格名称。取决于\r\n            无论\r\n","s.Slice(start, end - start)":"S.Slice（开始，结束 - 开始）\r\n","\r\n Returns the containing assembly. Modules are always directly contained by an assembly,\r\n so this property always returns the same as ContainingSymbol.\r\n ":"\r\n 返回包含的组件。模块始终由组件直接包含\r\n 因此，该属性始终返回与ContiningSymbol相同。\r\n \r\n","\r\n The value for the FinallyBlock property.\r\n ":"\r\n 最后block属性的值。\r\n \r\n","\r\n            Selects the candidate assembly with the largest version number.  Uses culture as a tie-breaker if it is provided.\r\n            All candidates are assumed to have the same name and must include versions and cultures.  \r\n            ":"\r\n            选择具有最大版本编号的候选组件。如果提供的话，将文化用作胜利者。\r\n            所有候选人都被认为具有相同的名称，并且必须包括版本和文化。\r\n            \r\n","else if":"否则\r\n","\r\n            Report a message to be displayed to the user.\r\n            ":"\r\n            报告要向用户显示的消息。\r\n            \r\n","The \"K\" custom format specifier represents the time zone information of a date and time value. When this format specifier is used with DateTime values, the result string is defined by the value of the DateTime.Kind property:\r\n            \r\n                For the local time zone (a ...":"“ K”自定义格式指定符表示日期和时间值的时区信息。当此格式指定符与DateTime值一起使用时，结果字符串由DateTime.kind属性的值定义：kind属性：\r\n            \r\n                对于本地时区（A ...\r\n","\r\n  Structure to wrap the different arrays of members.\r\n ":"\r\n  结构以包裹不同的成员阵列。\r\n \r\n","\r\n Represent a Yield statement.\r\n ":"\r\n 代表收益率声明。\r\n \r\n",". Prior to the use of this enum, the serialized value\r\n            was the ":". 在使用此枚举之前，序列化值\r\n            是 \r\n","\r\n Constructor.\r\n ":"\r\n 构造函数。\r\n \r\n","Modifying a catch/finally handler with an active statement in the try block requires restarting the application.":"在尝试块中使用活动语句修改捕获/最后处理程序需要重新启动应用程序。\r\n","\r\n Get all the members of this symbol. The members may not be in a particular order, and the order\r\n may not be stable from call-to-call.\r\n ":"\r\n 获取此符号的所有成员。成员可能不按特定顺序和订单\r\n 通话通话可能不稳定。\r\n \r\n","\r\n  Infer the type of a for-from-to control variable.\r\n ":"\r\n  推断出for-From-to Control变量的类型。\r\n \r\n","\r\n  Looks up a localized string similar to Character '{0}' ({1}) is not allowed in an XML name..\r\n":"\r\n  在XML名称中不允许查找类似于字符'{0}'（{1}）的本地化字符串。\r\n\r\n","\r\n            Represents a set of transformations that can be applied to a piece of code.\r\n            ":"\r\n            表示可以应用于一块代码的一组转换。\r\n            \r\n"," to the current compilation.\r\n            ":" 到当前汇编。\r\n            \r\n","\r\n The \"Interface\" statement that begins the block.\r\n ":"\r\n 开始块的“接口”语句。\r\n \r\n","\r\n Allows asking semantic questions about a tree of syntax nodes in a Compilation. Typically,\r\n an instance is obtained by a call to Compilation.GetBinding. \r\n ":"\r\n 允许在汇编中询问有关语法节点树的语义问题。通常，\r\n 实例是通过调用compilation.getbinding获得的。\r\n \r\n","Adding {0} that accesses captured variables '{1}' and '{2}' declared in different scopes requires restarting the application.":"添加{0}访问捕获的变量'{1}'和'{2}'在不同范围内声明的{0}需要重新启动应用程序。\r\n"," is true then\r\n this function lookups up members with the given ":" 那是真的\r\n 此功能查找给定的成员\r\n","The return type of the script":"脚本的返回类型\r\n","\r\n Turns the bound initializers into a list of bound assignment statements\r\n ":"\r\n 将绑定的初始化器变成绑定分配语句的列表\r\n \r\n","\r\n  Looks up a localized string similar to {0} parameters cannot be declared 'ByRef'..\r\n":"\r\n  查找类似于{0}参数类似的本地化字符串，无法声明'ByRef'..\r\n\r\n","s\r\n            to the ":"s\r\n            到\r\n","\r\n            The rule used when no rule is specified when constructing a ":"\r\n            构造一个未指定规则时使用的规则\r\n","escape character":"逃脱角色\r\n","\r\n Can we access Me in this location. If False is returned, \r\n also returns the error id associated with that.\r\n ":"\r\n 我们可以在这个位置访问我吗？如果返回错误，\r\n 还返回与之关联的错误ID。\r\n \r\n","\r\n            The script that ran to produce this result.\r\n            ":"\r\n            产生此结果的脚本。\r\n            \r\n","\r\n            The using alias 'A' cannot be used with type arguments\r\n            ":"\r\n            使用的别名'a'不能与类型参数一起使用\r\n            \r\n","\r\n Returns True if this conversion is a widening array conversion or a narrowing array conversion, as defined in\r\n section 8.5.\r\n ":"\r\n 如果此转换是扩展的数组转换或狭窄的数组转换，则返回true\r\n 第8.5节。\r\n \r\n","out var":"淘汰\r\n","\r\n         ''' ":"\r\n         '''\r\n","\r\n Returns a copy of this with the DoubleQuoteToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，并更改​​为Doublequotetkoken属性\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n This class represents a symbol for the compiler generated property that owns implemented getter (like IEnumerable.Current),\r\n The getter method being implemented is passed as a parameter and is used to build\r\n implementation property around it with appropriate parameters, return value type, etc...\r\n ":"\r\n 该类代表编译器生成的属性的符号\r\n 正在实现的Getter方法作为参数传递，用于构建\r\n 围绕它的实现属性，具有适当的参数，返回值类型等...\r\n \r\n","\r\n Get symbol for a special type, reuse symbols for operand types to avoid type \r\n lookups and construction of new instances of symbols.\r\n ":"\r\n 获取特殊类型的符号，用于操作数类型的重用符号以避免类型\r\n 查找和构造新符号实例。\r\n \r\n"," must be called instead,\r\n            with both the individual text changes, and an aggregated text change for hosts that only support that.\r\n            ":" 必须称呼\r\n            随着单个文本的更改，以及对仅支持这一点的主机的汇总文本更改。\r\n            \r\n","Formatting document":"格式文档\r\n","\r\n            Keep track of the last information we reported.  We will avoid notifying the host if we recompute and these\r\n            don't change.\r\n            ":"\r\n            跟踪我们报告的最后信息。如果我们重新计算，我们将避免通知主机\r\n            不要改变。\r\n            \r\n"," that represents\r\n a module that is not missing, i.e. the \"real\" thing.\r\n ":"代表\r\n 一个不丢失的模块，即“真实”的东西。\r\n \r\n","\r\n Associate the method with a particular property. Returns\r\n false if the method is already associated with a property or event.\r\n ":"\r\n 将方法与特定属性相关联。返回\r\n false如果该方法已经与属性或事件关联。\r\n \r\n","\r\n            Ensure this is ordered before the regular invocation signature help provider.\r\n            We must replace the entire list of results, including both Pythia and non-Pythia recommendations.\r\n            ":"\r\n            确保在定期调用签名帮助提供商之前订购这一点。\r\n            我们必须替换整个结果列表，包括毕田和非酸性建议。\r\n            \r\n","\r\n This helper method does all the work to bind Where, Take While and Skip While query operators.\r\n ":"\r\n 这种助手方法可以完成所有工作，以束缚在哪里，在查询操作员时跳过时，然后跳过。\r\n \r\n","\r\n A collection of the local variables for which a value assigned inside the region may be used outside the region.\r\n ":"\r\n 可以在该区域外使用的局部变量集合。\r\n \r\n"," instance representing a missing file header.\r\n            ":" 表示缺少文件头的实例。\r\n            \r\n","\r\n Indicates that previously returned node has been consumed\r\n and scanner needs to advance by the size of the node.\r\n \r\n NOTE: the advancement is done relative to the _lineBufferOffset.\r\n Line offset will likely not match start of current token because this operation\r\n is done while constructing the content of current token.\r\n \r\n NOTE: This operation assumes that there is no tokens read ahead.\r\n \r\n NOTE: This operation does not change preprocessor state. \r\n The assumption is that it is responsibility of the node consumer to update preprocessor\r\n state if needed when using nodes that change preprocessor state.\r\n ":"\r\n 表明先前返回的节点已被消耗\r\n 扫描仪需要按节点的大小前进。\r\n \r\n 注意：相对于_lineBufferOffset进行进步。\r\n 线偏移可能不匹配当前令牌的开始，因为此操作\r\n 在构造当前令牌的内容时完成。\r\n \r\n 注意：此操作假定没有代币读取前方。\r\n \r\n 注意：此操作不会更改预处理器状态。\r\n 假设是节点消费者有责任更新预处理器\r\n 如果需要在使用更改预处理器状态的节点时状态。\r\n \r\n","\r\n            Implements a code fix for all misplaced using statements.\r\n            ":"\r\n            使用语句实现所有放错位置的代码修复。\r\n            \r\n","\r\n Returns a copy of this with the AdditionalJoins property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，额外的属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            A mandatory fix for the overload without cascading.\r\n            ":"无需级联的重载的强制性解决方案。\r\n            \r\n","MethodSymbol or PropertySymbol or EventSymbol (an interface member).":"Methodsymbol或propertySymbol或Eventsymbol（接口成员）。\r\n","\r\n  Looks up a localized string similar to Cryptographic failure while creating hashes..\r\n":"\r\n  在创建哈希时，查找类似于加密故障的局部字符串。\r\n\r\n","\r\n When an answer is a named symbol that is reachable by traversing from the root of the symbol\r\n table, (that is, from an AssemblySymbol of the Compilation), that symbol will be returned\r\n (i.e. the returned value will be reference-equal to one reachable from the root of the\r\n symbol table). Symbols representing entities without names (e.g. array-of-int) may or may\r\n not exhibit reference equality. However, some named symbols (such as local variables) are\r\n not reachable from the root. These symbols are visible as answers to semantic questions.\r\n When the same SemanticModel object is used, the answers exhibit reference-equality.  \r\n ":"\r\n 当答案是通过从符号的根部穿越的命名符号\r\n 表，（即，从编译的汇编符号来看），该符号将返回\r\n （即，返回的值将是从一个词根到达的参考值等于\r\n 符号表）。代表没有名称的实体的符号（例如Int的阵列）可能或可能\r\n 不表现出参考平等。但是，某些命名符号（例如本地变量）是\r\n 无法从根部达到。这些符号可见为语义问题的答案。\r\n 当使用相同的senanticmodel对象时，答案将显示参考 - 平等。\r\n \r\n"," to represent the symbol rather then ":" 代表符号而不是\r\n"," is an indexer declaration the tokens of its expression body.\r\n            \r\n            If ":" 是索引声明的表达主体的令牌。\r\n            \r\n            如果\r\n","\r\n            Suppression code action based on pragma add/remove/edit.\r\n            ":"\r\n            基于Pragma添加/删除/编辑的抑制代码操作。\r\n            \r\n","\r\n            The original path of the assembly before it was shadow-copied.\r\n            For GAC'd assemblies, this is equal to Assembly.Location no matter what path was used to load them.\r\n            ":"\r\n            组件的原始路径在被阴影覆盖之前。\r\n            对于Gac'd组件，这等于组件。Location无论使用哪种路径加载它们。\r\n            \r\n","\r\n Creates a new syntax tree from a syntax node.\r\n ":"\r\n 从语法节点创建一个新的语法树。\r\n \r\n","\r\n            Maps syntax tree to active statements with calculated unmapped spans.\r\n            ":"\r\n            用计算的未覆盖跨度的映射语法为活动语句。\r\n            \r\n","\r\n Binding info for expressions and statements that are part of a member declaration.\r\n ":"\r\n 绑定属于会员声明一部分的表达式和陈述的信息。\r\n \r\n","A syntax node that represents a parsed statement. This statement should not be\r\n present in the syntax tree associated with this object.":"表示解析语句的语法节点。这个声明不应该是\r\n 存在与此对象关联的语法树中。\r\n"," Cache of created anonymous types ":" 创建匿名类型的缓存\r\n","\r\n  Looks up a localized string similar to Array subscript expression missing..\r\n":"\r\n  查找类似于数组订阅表达式缺失的本地化字符串。\r\n\r\n","\r\n True if the type is a Windows runtime type.\r\n ":"\r\n 如果类型是Windows运行时类型，则为true。\r\n \r\n","\r\n A statement that declares an event. If the event being declared is a custom\r\n event, this statement will be the Begin of a PropertyOrEventBlock, and the\r\n accessors will be part of the Accessors of that node.\r\n ":"\r\n 宣布事件的声明。如果被宣布的事件是自定义\r\n 事件，此语句将是PropertyRoreventBlock的开始，\r\n 登录器将成为该节点的登录器的一部分。\r\n \r\n","Selection does not contain a valid token.":"选择不包含有效的令牌。\r\n","The named type symbol where the field initializers are declared.":"声明字段初始化器的命名类型符号。\r\n","location unknown":"位置未知\r\n",".\r\n            - Selection is zero-width and in a header (defined by ISyntaxFacts helpers) of an node of type of type ":"。\r\n             - 选择是零宽，在类型类型的节点的标题（由isyntaxFacts helper定义）中\r\n","\r\n Translates anonymous type public symbol into an implementation type symbol to be used in emit.\r\n ":"\r\n 将匿名类型的公共符号转换为要在EMIT中使用的实现类型符号。\r\n \r\n","\r\n Create the frame types.\r\n ":"\r\n 创建框架类型。\r\n \r\n","\r\n            True if required, false if optional with a default value.\r\n            ":"\r\n            如果需要，则为fals，如果可选为默认值。\r\n            \r\n","Removing {0} that contains an active statement requires restarting the application.":"删除包含一个活动语句的{0}需要重新启动应用程序。\r\n","Partial method '{0}' must have an implementation part because it has accessibility modifiers.":"部分方法'{0}'必须具有实现零件，因为它具有可访问性修饰符。\r\n","The delegate type to assign the result of the AddressOf operator to.":"将操作员地址的结果分配给的委托类型。\r\n","s those types are\r\n            contained in.\r\n            ":"这些类型是\r\n            包含在。\r\n            \r\n","\r\n  Looks up a localized string similar to Anonymous type property '{0}' cannot be used in the definition of a lambda expression within the same initialization list..\r\n":"\r\n  查找类似于匿名类型属性'{0}'的本地化字符串在同一初始化列表中的lambda表达式的定义中无法使用。\r\n\r\n","\r\n The value for the IfStatement property.\r\n ":"\r\n Ifstatement属性的值。\r\n \r\n","\r\n Parse GetType, \r\n GetTypeExpression -> GetType OpenParenthesis GetTypeTypeName CloseParenthesis \r\n ":"\r\n parse getType，\r\n getTypeexpression-> getType open parthenthesis gettypetymame crossexentensess\r\n \r\n","\r\n Return an array of assemblies referenced by this assembly, which are linked (/l-ed) by \r\n each compilation that is using this AssemblySymbol as a reference. \r\n If this AssemblySymbol is linked too, it will be in this array too.\r\n ":"\r\n 返回此组件引用的一组组件，这些组件由（/l-ed）链接\r\n 每次使用此组合符号作为参考的汇编。\r\n 如果此汇编符号也链接在一起，则它也将在此数组中。\r\n \r\n","\r\n The value for the EnumKeyword property.\r\n ":"\r\n EnumKeyWord属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to Method declaration statements must be the first statement on a logical line..\r\n":"\r\n  查找类似于方法声明语句的本地化字符串必须是逻辑行上的第一个语句。\r\n\r\n","New child nodes to compare against":"与比较的新孩子节点\r\n","\r\n The current lexical nesting in the BoundTree. \r\n ":"\r\n 当前的词汇嵌套在边界。\r\n \r\n","\r\n Gets the referenced symbol of the bound expression.\r\n Used for matching variables between For and Next statements.\r\n ":"\r\n 获取绑定表达式的引用符号。\r\n 用于在下一个语句之间和下一个语句之间匹配变量。\r\n \r\n","Type does not implement interface member. Nullability of reference types in interface implemented by the base type doesn't match.":"类型不实现接口成员。基本类型实现的接口中参考类型的无效性不匹配。\r\n","\r\n Gets the type of this parameter.\r\n ":"\r\n 获取此参数的类型。\r\n \r\n","\r\n Retargeting map from underlying module to this one.\r\n ":"\r\n 从基础模块重新定位地图。\r\n \r\n","\r\n            Indicates that this reference should be treated as if it were used.\r\n            ":"\r\n            表明该参考应像使用一样对待。\r\n            \r\n","\r\n  Looks up a localized string similar to Unable to load module file '{0}': {1}.\r\n":"\r\n  查找类似于无法加载模块文件'{0}'的本地化字符串：{1}。\r\n\r\n","Changing type parameters of {0} requires restarting the application.":"更改{0}的类型参数需要重新启动应用程序。\r\n","\r\n MyTemplate automatically embedded from resource in the compiler.\r\n It doesn't feel like it should be managed by EmbeddedSymbolManager\r\n because MyTemplate is treated as user code, i.e. can be extended via\r\n partial declarations, doesn't require \"on-demand\" metadata generation, etc.\r\n \r\n SyntaxTree.Dummy means uninitialized.\r\n ":"\r\n MyTemplate自动从编译器中的资源嵌入。\r\n 觉得应该通过嵌入式摩托马人来管理\r\n 因为将myTemplate视为用户代码，因此可以通过\r\n 部分声明，不需要“按需”元数据，等等。\r\n \r\n 语法。虚拟意味着非专业化。\r\n \r\n","\r\n Provides a way to obtain binders for descendant scopes in method or lambda body.\r\n Factory for a method body does not create binders for scopes inside a lambda, \r\n contained by the method. A dedicated factory must be created for each lambda body.\r\n ":"\r\n 提供了一种在方法或lambda主体中获得后代范围的粘合剂的方法。\r\n 用于方法主体的工厂不会为lambda内部的示波器创建粘合剂，\r\n 由该方法包含。必须为每个Lambda机构创建专用工厂。\r\n \r\n"," class.\r\n ":" 班级。\r\n \r\n","Parameter is for a lambda expression rather than a regular method.":"参数用于lambda的表达，而不是常规方法。\r\n","\r\n First error calculating bounds.\r\n ":"\r\n 第一个错误计算边界。\r\n \r\n","\r\n This binder is for binding the initializer of an implicitly typed \r\n local variable. While binding an implicitly typed local variable\r\n this binder is used to break cycles.\r\n ":"\r\n 该活页夹是为了绑定隐式键入的初始化器\r\n 本地变量。在绑定隐式键入本地变量的同时\r\n 该粘合剂用于打破周期。\r\n \r\n","Remove unused variables":"删除未使用的变量\r\n"," Root syntax node ":" 根语法节点\r\n","\r\n Gets a value indicating whether this instance is abstract or not.\r\n ":"\r\n 获取一个指示此实例是否抽象的值。\r\n \r\n"," property changed to the\r\n specified value. Returns this instance if the specified value is the same as the current value.\r\n ":" 属性更改为\r\n 指定值。如果指定值与当前值相同，则返回此实例。\r\n \r\n","The name '{0}' does not match the corresponding 'Deconstruct' parameter '{1}'.":"名称'{0}'与相应的“解构”参数'{1}'匹配。\r\n","Members named 'Clone' are disallowed in records.":"记录中禁止名为“克隆”的成员。\r\n","\r\n If value is const, returns the value unchanged.\r\n \r\n In a case if value is not a const, a proxy temp is created and added to \"locals\"\r\n In addition to that, code that evaluates and stores the value is added to \"expressions\"\r\n The access expression to the proxy temp is returned.\r\n ":"\r\n 如果值是const，则将返回值不变的值。\r\n \r\n 如果值不是const，则创建代理温度并添加到“当地人”中\r\n 除此之外，评估和存储该值的代码添加到“表达式”中\r\n 返回对代理温度的访问表达式。\r\n \r\n","\r\n The End SyncLock statement that ends the block.\r\n ":"\r\n 结束块的结束Synclock语句。\r\n \r\n","Unable to load Analyzer assembly {0}: {1}":"无法加载分析仪组件{0}：{1}\r\n","\r\n Implements shadowing based on\r\n §11.8.1 Overloaded Method Resolution.\r\n    7.5.\tIf M is not an extension method and N is, eliminate N from the set.\r\n    7.6.\tIf M and N are extension methods and M was found before N, eliminate N from the set.\r\n ":"\r\n 基于\r\n §11.8.1超载方法分辨率。\r\n    7.5。如果m不是扩展方法，而n为n，则从集合中消除n。\r\n    7.6。如果M和N是扩展方法，并且在N之前找到了M，则从集合中消除n。\r\n \r\n","The optional architecture filter.":"可选的体系结构过滤器。\r\n","\r\n  The only valid types are \r\n 1. primitive types except date and decimal, \r\n 2. object, system.type, public enumerated types\r\n 3. one dimensional arrays of (1) and (2) above\r\n ":"\r\n  唯一有效的类型是\r\n 1.原始类型除了日期和十进制外，\r\n 2.对象，系统。类型，公共枚举类型\r\n 3.上面（1）和（2）的一维数组\r\n \r\n","query body":"查询身体\r\n","\r\n Tells whether binding is happening in a lambda context.\r\n ":"\r\n 讲述绑定是否在lambda上下文中发生。\r\n \r\n","\r\n  Looks up a localized string similar to Expression is a value and therefore cannot be the target of an assignment..\r\n":"\r\n  查找类似于表达式的本地化字符串是一个值，因此不能成为分配的目标。\r\n\r\n","\r\n            The kind of this section. Use ":"\r\n            本节的类型。利用\r\n"," when providing completions.\r\n            ":" 提供完成时。\r\n            \r\n","\r\n  Looks up a localized string similar to Expression is not an array or a method, and cannot have an argument list..\r\n":"\r\n  查找类似于表达式的本地化字符串不是数组或方法，也不能具有参数列表。\r\n\r\n","\r\n Modified identifier appeared in a query range variable declaration.\r\n ":"\r\n 修改后的标识符出现在查询范围变量声明中。\r\n \r\n","\r\n            The declaration body node may not contain the ":"\r\n            声明主体节点可能不包含\r\n","null is not a valid parameter name. To get access to the receiver of an instance method, use the empty string as the parameter name.":"空不是有效的参数名称。要访问实例方法的接收器，请使用空字符串作为参数名称。\r\n","\r\n The value for the XmlNamespace property.\r\n ":"\r\n XMLNAMESPACE属性的值。\r\n \r\n","\r\n            Create a new C# script.\r\n            ":"\r\n            创建一个新的C＃脚本。\r\n            \r\n","\r\n Represents the Finally part of a Try...Catch...Finally...End Try. This\r\n statement is always the Begin of a FinallyPart.\r\n ":"\r\n 代表尝试的最后一部分...捕获...最后...结束尝试。这个\r\n 声明始终是最终部分的开始。\r\n \r\n","\r\n The \"#\" token in a preprocessor directive.\r\n ":"\r\n 预处理器指令中的“＃”令牌。\r\n \r\n","static abstract members in interfaces":"界面中的静态抽象成员\r\n","\r\n §11.8.1.1 Applicability\r\n ":"\r\n §11.8.1.1适用性\r\n \r\n","\r\n The type describing the constraint.\r\n ":"\r\n 描述约束的类型。\r\n \r\n","\r\n Gets the conversion that occurred between the expression's type and type implied by the expression's context.\r\n ":"\r\n 获取表达式上下文所隐含的表达式类型和类型之间发生的转换。\r\n \r\n"," if the text does not have a navigation hint.":" 如果文本没有导航提示。\r\n","\r\n Represents the \"Error\" statement.\r\n ":"\r\n 表示“错误”语句。\r\n \r\n","The \"ff\" custom format specifier represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value.":"“ FF”自定义格式指定符表示秒数的两个最重要的数字；也就是说，它代表了日期和时间值的一秒钟。\r\n","\r\n Creates a see element within an xml documentation comment.\r\n ":"\r\n 在XML文档注释中创建一个See元素。\r\n \r\n","\r\n  Looks up a localized string similar to 'Sub New' cannot be declared 'Overrides'..\r\n":"\r\n  查找类似于“ sub new”的本地化字符串，不能声明为“替代”。\r\n\r\n","\r\n Represents a \"Where\" query operator.\r\n ":"\r\n 代表一个“ WHERE”查询操作员。\r\n \r\n"," bit.\r\n            ":" 少量。\r\n            \r\n"," callback; otherwise, ":" 打回来;否则，\r\n","\r\n Returns true if the type can be embedded. If the type is defined in a linked (/l-ed)\r\n assembly, but doesn't meet embeddable type requirements, this function returns\r\n False and reports appropriate diagnostics.\r\n ":"\r\n 如果可以嵌入类型，则返回true。如果类型是在链接（/l-ed）中定义的\r\n 汇编，但不符合可嵌入类型的要求，此功能返回\r\n 错误并报告适当的诊断。\r\n \r\n","\r\n            The location of the source item.\r\n            ":"\r\n            源项目的位置。\r\n            \r\n","\r\n The import clause (a namespace name, an alias, or an XML namespace alias).\r\n ":"\r\n 导入子句（名称名称，别名或XML名称空间别名）。\r\n \r\n","Make 'ref struct'":"制作“ ref struct”\r\n","Place colon on following line":"将结肠放在以下行\r\n","The character position for determining the enclosing declaration scope and accessibility.":"确定封闭声明范围和可访问性的角色位置。\r\n"," for the most common kinds.":" 对于最常见的种类。\r\n","\r\n returns false, then this property throws an InvalidOperationException.\r\n ":"\r\n 返回false，然后此属性抛出InvalidOperationException。\r\n \r\n","The text of the whitespace. Any text can be specified here, however only specific\r\n whitespace characters are recognized by the parser.":"空格的文字。任何文本都可以在此处指定，但是只有特定的\r\n 空格字符被解析器认可。\r\n","AM/PM (full)":"am/pm（完整）\r\n","\r\n The \"Throw\" keyword\r\n ":"\r\n “投掷”关键字\r\n \r\n"," that should be used in features that care about\r\n            pointing at a particular location in a ":" 应该在关心的功能中使用\r\n            指向特定位置\r\n","\r\n Returns a copy of this with the RaiseEventKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中raiseeventkeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","Cannot include class \\{0} in character range":"不能在字符范围内包含类\\ {0}\r\n","\r\n Represents a Join or a Group Join query operator.\r\n ":"\r\n 代表加入或组加入查询操作员。\r\n \r\n","\r\n            An optional fix for the overload with cascading.\r\n            ":"\r\n            可选的解决方案，可用于级联的超负荷。\r\n            \r\n","The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'class' constraint.":"该类型不能用作通用类型或方法中的类型参数。类型参数的无效性不匹配“类”约束。\r\n","\r\n            Obtain the outermost common receiver between two expressions.  This can succeed with a null 'CommonReceiver'\r\n            in the case that the common receiver is the 'implicit this'.\r\n            ":"\r\n            在两个表达式之间获得最外面的公共接收器。这可以通过无效的“普通人”成功\r\n            在常见接收器的情况下是“隐式”。\r\n            \r\n","\r\n Given result of binding preceding query operators, the outer, bind the following Group Join operator.\r\n \r\n     [{Preceding query operators}] Group Join {collection range variable} \r\n                                              [{additional joins}] \r\n                                   On {condition}\r\n                                   Into {aggregation range variables}\r\n \r\n Ex: From a In AA Group Join b in BB          AA.GroupJoin(BB, Function(a) Key(a), Function(b) Key(b), \r\n                  On Key(a) Equals Key(b) ==>              Function(a, group_b) New With {a, group_b.Count()})\r\n                  Into Count()\r\n \r\n Also, depending on the amount of collection range variables in scope, and the following query operators,\r\n translation can produce a nested, as opposed to flat, compound variable (see BindInnerJoinClause for an example).\r\n \r\n Note, that type of the group must be inferred from the set of available GroupJoin operators in order to be able to \r\n interpret the aggregation range variables. \r\n ":"给定绑定前面的查询操作员的结果，外部绑定以下组联接操作员。\r\n \r\n     [{前面的查询操作员}]组加入{Collection range variable}\r\n                                              [{附加连接}]\r\n                                   在{条件}\r\n                                   进入{聚合范围变量}\r\n \r\n ex：从A中的A组中加入B中的B中BB AA.GroupJoin（BB，function（a）键（a），函数（b）键（b），\r\n                  在键（a）上等于key（​​b）==>函数（a，group_b）with {a，group_b.count（）}）\r\n                  进入count（）\r\n \r\n 此外，取决于范围中的收集范围变量的数量，以及以下查询操作员，\r\n 翻译可以产生嵌套，而不是平坦的复合变量（例如，请参见bindinnerjoinclause）。\r\n \r\n 请注意，必须从一组可用的组Join运算符中推断出该组的类型，以便能够\r\n 解释聚合范围变量。\r\n \r\n","\r\n            Get diagnostics for the given solution. all diagnostics returned should be up-to-date with respect to the given solution.\r\n            ":"\r\n            获取给定解决方案的诊断。返回的所有诊断均应相对于给定的解决方案进行最新。\r\n            \r\n","\r\n            Parses out an escape sequence.  Escape sequences are allowed in top level sequences\r\n            and in character classes.  In a top level sequence trivia will be allowed afterwards,\r\n            but in a character class trivia is not allowed afterwards.\r\n            ":"\r\n            解析逃生序列。在顶级序列中允许逃生序列\r\n            和角色课程。在最高级别序列以后将允许琐事，\r\n            但是在角色类中，琐事之后不允许。\r\n            \r\n","\r\n Dummy locals represent implicit control flow\r\n it is not allowed for a regular local span to cross into or \r\n be immediately adjacent to a dummy span.\r\n \r\n specifically:\r\n [1, 3) does conflict with [0, 1)   since that would imply a value flowing into or out of a span surrounded by a branch/label\r\n \r\n ":"虚拟当地人代表隐式控制流\r\n 不允许常规的本地跨越或\r\n 立即与虚拟跨度相邻。\r\n \r\n 具体来说：\r\n [1，3）确实与[0，1）冲突\r\n \r\n \r\n","\r\n            It hasn't been possible to determine whether the current document content does matches the content \r\n            the module was compiled with due to error while reading the PDB or the source file.\r\n            This document state may change to ":"\r\n            无法确定当前文档内容是否与内容匹配\r\n            在读取PDB或源文件时，由于错误而编译了该模块。\r\n            该文件状态可能会更改为\r\n","Cannot create constructed generic type from another constructed generic type.":"无法从另一种构造的通用类型中创建构造的通用类型。\r\n","\r\n The value for the EndStructureStatement property.\r\n ":"\r\n 端结构属性的值。\r\n \r\n","\r\n In order that any expression level special binders are used, lambdas are fully resolved,\r\n and that any other binding context is correctly handled, we only use the binder to create bound\r\n nodes for:\r\n   a) The root syntax of this semantic model (because there's nothing more outer to bind)\r\n   b) A stand-alone statement is that is not inside a lambda.\r\n ":"\r\n 为了使用任何表达水平特殊粘合剂，lambdas已完全解析，\r\n 而且，正确处理任何其他绑定上下文，我们只使用粘合剂来创建绑定\r\n 节点：\r\n   a）该语义模型的根语法（因为没有其他内容可以绑定）\r\n   b）独立的陈述是不在lambda内部。\r\n \r\n","\r\n            Given an input text, and set of options, parses out a fully representative syntax tree \r\n            and list of diagnostics.  Parsing should always succeed, except in the case of the stack \r\n            overflowing.\r\n            ":"\r\n            给定输入文本和一组选项，解析了完全代表性的语法树\r\n            和诊断清单。除非堆栈，否则解析应始终成功\r\n            溢出。\r\n            \r\n","\r\n            false, if explicit typing cannot be used.\r\n            true, otherwise.\r\n            ":"\r\n            false，如果无法使用明确打字。\r\n            是的，否则。\r\n            \r\n","\r\n The type of the elements of the array.\r\n ":"\r\n 数组元素的类型。\r\n \r\n","\r\n An additional Join or Group Join query operator.\r\n ":"\r\n 附加的加入或组加入查询操作员。\r\n \r\n","\r\n A map of namespaces immediately contained within this namespace \r\n grouped by their name (case-insensitively).\r\n ":"\r\n 立即在此名称空间中包含的名称空间的地图\r\n 按其名称分组（casemonsitationally）。\r\n \r\n","Supported architectures used to filter GAC assemblies.":"用于过滤GAC组件的支持架构。\r\n","\r\n            Returns output file path for the project containing the method.\r\n            ":"\r\n            返回包含该方法的项目的输出文件路径。\r\n            \r\n","\r\n Structure is used to store all information which is needed to construct and classify a Delegate creation \r\n expression later on.\r\n ":"\r\n 结构用于存储所有构建和分类委托创建所需的信息\r\n 以后表达。\r\n \r\n","\r\n Returns True if ":"\r\n 如果返回为true\r\n","\r\n The returned assembly may also forward the type.\r\n ":"\r\n 返回的组件也可以转发类型。\r\n \r\n","\r\n            A single character string indicating what the comment character is for the documentation comments\r\n            ":"\r\n            单个字符字符串，指示注释字符在文档注释中是什么\r\n            \r\n"," attempts to locate a matching value in the context of a method invocation.\r\n            ":"尝试在方法调用的上下文中定位匹配值。\r\n            \r\n","\r\n  Looks up a localized string similar to '{0}' statement requires an array..\r\n":"\r\n  查找类似于“ {0}”语句的本地化字符串需要数组。\r\n\r\n","\r\n Generates the name of a state machine's awaiter field \r\n ":"\r\n 生成状态机的等待手字段的名称\r\n \r\n","Modifying a catch handler around an active statement requires restarting the application.":"修改Active语句围绕捕获处理程序需要重新启动应用程序。\r\n","\r\n Creates a BoundCall or BoundPropertyAccess from a MethodOrPropertyGroup.\r\n ":"\r\n 从MedagorPropertyGroup创建一个界或界面级别。\r\n \r\n","\r\n The value for the Filter property.\r\n ":"\r\n 过滤属性的值。\r\n \r\n"," if derivedType is, inherits from or implements the interface; otherwise, ":" 如果是derivedType，则从接口继承或实现界面；否则，\r\n","\r\n Returns a copy of this with the SecondCommaToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，第二个通用属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","The currently set Visual Basic parse options.":"当前设置的Visual Basic Parse选项。\r\n","\r\n Initializer for an executable statement in script code.\r\n ":"\r\n 脚本代码中可执行语句的初始化器。\r\n \r\n","\r\n The While statement that begins the block.\r\n ":"\r\n 开始块的段语。\r\n \r\n","\r\n  Looks up a localized string similar to Lambda expression cannot be converted to '{0}' because type '{0}' is declared 'MustInherit' and cannot be created..\r\n":"\r\n  查找类似于lambda表达式的本地化字符串不能转换为'{0}'，因为类型'{0}'被声明为'MustInherit'，也不能创建。\r\n\r\n","completed":"完全的\r\n","\r\n gets a page for the position.\r\n will initialize it if we have cache miss\r\n ":"\r\n 获取该职位的页面。\r\n 如果我们有缓存错过的话，它将初始化它\r\n \r\n","\r\n Returns a copy of this with the ControlVariable property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中可控属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            When an optional parameter is added, passing an argument for\r\n            it is not required. This indicates that the corresponding argument \r\n            should be omitted. This often results in subsequent arguments needing\r\n            to become named arguments\r\n            ":"\r\n            添加可选参数后，通过参数\r\n            不需要。这表明相应的参数\r\n            应该省略。这通常导致随后的参数需要\r\n            成为命名参数\r\n            \r\n","\r\n If hasFinalizerState is true, this is the state for finalization from anywhere in this try block.\r\n Initially set to -1, representing the no-op finalization required at the top level.\r\n ":"\r\n 如果HasfinalizerState是正确的，那么这是从此尝试块中的任何地方完成最终确定的状态。\r\n 最初设置为-1，表示最高级别所需的NO -OP最终确定。\r\n \r\n","\r\n Given result of binding preceding query operators, the source, bind the following Take operator.\r\n \r\n     {Preceding query operators} Take {expression}\r\n \r\n Ex: From a In AA Take 10 ==> AA.Take(10)\r\n \r\n ":"给定绑定前面的查询操作员的结果，源，绑定以下操作员。\r\n \r\n     {前面的查询操作员}取{expression}\r\n \r\n 例如：从A中的A中取10 ==> aa.take（10）\r\n \r\n \r\n","Function pointer '{0}' does not take {1} arguments":"函数指针'{0}'不接受{1}参数\r\n","\r\n            The class is thread-safe.\r\n            ":"\r\n            该类是线程安全。\r\n            \r\n","MyClass.":"MyClass。\r\n","\r\n The value for the Name property.\r\n ":"\r\n 名称属性的值。\r\n \r\n","\r\n Parse the project level imports, adding errors to the errorBag as necessary\r\n ":"\r\n 解析项目级别导入，根据需要在错误袋中添加错误\r\n \r\n","\r\n Holds all information needed to rewrite a bound for each node.\r\n ":"\r\n 保留为每个节点重写一个绑定所需的所有信息。\r\n \r\n","inline comment":"内联评论\r\n","\r\n Interfaces as \"declared\".\r\n Declared interfaces may contain circularities.\r\n \r\n If DeclaredInterfaces must be accessed while other DeclaredInterfaces are being resolved, \r\n the bases that are being resolved must be specified here to prevent potential infinite recursion.\r\n ":"\r\n 接口为“声明”。\r\n 声明的接口可能包含圆形。\r\n \r\n 如果必须在解决其他删除的Interfaces时必须访问DeckaredInterfaces，则\r\n 必须在此处指定正在解决的基础，以防止潜在的无限递归。\r\n \r\n","\r\n            resolve the given symbol against compilation this snapshot has\r\n            ":"\r\n            解决此快照的给定符号反对编译的符号\r\n            \r\n","\r\n  Looks up a localized string similar to Loop control variable cannot be a property or a late-bound indexed array..\r\n":"\r\n  查找类似于循环控制变量的本地化字符串不能是属性或后期索引数组。\r\n\r\n"," when none is specified.\r\n            ":" 当未指定未指定时。\r\n            \r\n","\r\n            analyzer result operation status\r\n            ":"\r\n            分析仪结果操作状态\r\n            \r\n","\r\n WARN WARN WARN: The result is not guaranteed to have IsSemanticModelBinder set.\r\n ":"\r\n 警告警告：不能保证其issemanticmodelbinder设置。\r\n \r\n","Modifying source file '{0}' requires restarting the application because the file is too big.":"修改源文件'{0}'需要重新启动应用程序，因为文件太大。\r\n"," added.\r\n            ":" 添加。\r\n            \r\n","The local function '{0}' is declared but never used":"声明了本地函数'{0}'\r\n","\r\n Represents an floating literal token.\r\n ":"\r\n 代表浮动的文字令牌。\r\n \r\n"," if this is a shared constructor.":" 如果这是共享构造函数。\r\n","\r\n The expression being synchronized on.\r\n ":"\r\n 表达式被同步。\r\n \r\n","\r\n Compare two symbol objects to see if they refer to the same symbol. You should always use\r\n = and <> or the Equals method, to compare two symbols for equality.\r\n ":"\r\n 比较两个符号对象，以查看它们是否指的是相同的符号。你应该始终使用\r\n = and <>或equals方法，比较两个符号的平等符号。\r\n \r\n","\r\n Returns a copy of this with the Expression property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而表达式属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Returns true if this variable was declared as ReadOnly \r\n ":"\r\n 如果该变量被称为ReadOnly，则返回true\r\n \r\n"," that appears selected in the list presented to the user during suggestion mode.\r\n            \r\n            Suggestion mode disables auto-selection of items in the list, giving preference to the text typed by the user unless a specific item is selected manually.\r\n            \r\n            Specifying a ":" 在建议模式下，在列表中选择了这一点。\r\n            \r\n            建议模式禁用列表中项目的自动选择，除非手动选择特定的项目，否则优先考虑用户键入的文本。\r\n            \r\n            指定\r\n","SyntaxTree is not part of the compilation":"语法不是汇编的一部分\r\n","Do not change this code. Put cleanup code in '{0}' method":"不要更改此代码。将清理代码放入'{0}'方法中\r\n"," \r\n True if there were references to the With statement expression \r\n placeholder which prevent ByRef local from being used \r\n ":" \r\n 如果有陈述表达式提及\r\n 阻止Byref本地使用的占位符\r\n \r\n","\r\n            Return null if not in object creation type context.\r\n            ":"\r\n            如果不是在对象创建类型上下文中，则返回null。\r\n            \r\n","\r\n            Represents a shadow copy of an assembly or a standalone module.\r\n            ":"\r\n            代表组件或独立模块的阴影副本。\r\n            \r\n","Warning: Collection may be modified during iteration.":"警告：在迭代过程中可能会修改收集。\r\n","\r\n A source field with an explicit initializer. In a declaration declaring multiple\r\n fields, such as \"Dim a, b, c = d\", this class is used for the fields other than\r\n the first. (The first field is an instance of SourceFieldSymbolWithInitializer.)\r\n An instance of this class holds a reference to the first field in the declaration\r\n and reuses the bound initializer from that field.\r\n ":"\r\n 具有显式初始化器的源字段。在宣布多次的声明中\r\n 字段，例如“昏暗的A，B，C = D”，此类用于领域以外的其他字段\r\n 首先。 （第一个字段是source fieldsymbolwithinitializer的实例。）\r\n 此类的实例在声明中对第一个字段进行了引用\r\n 并重用该字段的界初始化器。\r\n \r\n","\r\n Get all the declaration errors.\r\n ":"\r\n 获取所有声明错误。\r\n \r\n","\r\n Because this method must semantically analyze all method bodies and initializers to check for diagnostics, it may\r\n take a significant amount of time. Unlike GetDeclarationDiagnostics, diagnostics for method bodies and\r\n initializers are not cached, the any semantic information used to obtain the diagnostics is discarded.\r\n ":"\r\n 因为此方法必须在语义上分析所有方法的身体和初始化器以检查诊断，所以它可能\r\n 花大量时间。与getDeclarationDiagnostics不同，方法身体的诊断和\r\n 初始化器没有缓存，用于丢弃用于获得诊断的任何语义信息。\r\n \r\n","\r\n Describes a unary operator: Plus, Negate, Not or AddressOf.\r\n ":"\r\n 描述一个单一操作员：另外，否定，而不是地址。\r\n \r\n","\r\n            return true if original type had anonymous type or delegate somewhere in the type\r\n            ":"\r\n            如果原始类型具有匿名类型或委托\r\n            \r\n"," applied on the containing module.\r\n Symbols that are embedded are not affected by ":" 应用于包含的模块。\r\n 嵌入的符号不受影响\r\n","\r\n            Represents a span of text in a source code file in terms of file name, line number, and offset within line.\r\n            An alternative for ":"\r\n            用文件名，行号和行中的偏移表示源代码文件中的文本跨度。\r\n            替代方案\r\n"," with just ":" 只是\r\n","reference to undefined group":"参考未定义组\r\n","\r\n  Looks up a localized string similar to 'End RemoveHandler' must be preceded by a matching 'RemoveHandler' declaration..\r\n":"\r\n  查找类似于“ end removerhandler”的本地化字符串必须在匹配的“ removehandler”声明之前。\r\n\r\n","\r\n Lookup all names of extension methods that are available from a single binder, without delegating\r\n to containing binder. The original binder passed in is used for accessibility checking\r\n and so forth.\r\n Names that are available are inserted into \"nameSet\". This is a hashSet that accumulates\r\n names, and should be created with the VB identifierComparer.\r\n ":"\r\n 查找单个粘合剂可用的扩展方法的所有名称，而无需委派\r\n 含有粘合剂。传递的原始粘合剂用于可访问性检查\r\n 等等。\r\n 可用的名称被插入“姓名表”。这是一个积累的主题集\r\n 名称，应使用VB标识符comparer创建。\r\n \r\n","\r\n Specified sizes for dimensions, by position. The length can be less than ":"\r\n 按位置指定的尺寸。长度可能小于\r\n"," Anonymous type field/parameter name, not nothing and not empty ":" 匿名类型字段/参数名称，不是一无所有，不是空的\r\n","\r\n            Cannot convert method group 'X' to non-delegate type 'Y'. Did you intend to invoke the method?\r\n            ":"\r\n            无法将方法组“ X”转换为非贵族类型的“ y”。您打算调用该方法吗？\r\n            \r\n","\r\n Represents a While...End While statement, including the While, body and End\r\n While.\r\n ":"\r\n 代表一会儿...结束时，陈述，包括时，身体和结尾\r\n 尽管。\r\n \r\n","\r\n if any symbol in the list Shadows. This implies that name is not visible through the base.\r\n ":"\r\n 如果列表阴影中的任何符号。这意味着可以通过基础可见名称。\r\n \r\n","full long date/time":"完整的长期/时间\r\n","\r\n Describes the type of the variable being defined.\r\n ":"\r\n 描述要定义的变量的类型。\r\n \r\n","A GlobalImport object to compare with this object":"与此对象进行比较的GlobalImport对象\r\n","\r\n The \"Sub New\" statement that begins the block.\r\n ":"\r\n 开始块的“ Sub New”语句。\r\n \r\n","\r\n Determines if the Unicode character can be a part of a Visual Basic identifier.\r\n ":"\r\n 确定Unicode字符是否可以成为视觉基本标识符的一部分。\r\n \r\n","\r\n This method is called by the binder from ":"\r\n 活页夹从\r\n","Add parameter to '{0}'":"将参数添加到'{0}'\r\n"," was `true` or the one passed to ":" 是“ true”或传递给\r\n","\r\n            Gets or creates a copy of specified assembly or standalone module.\r\n            ":"\r\n            获取或创建指定的组件或独立模块的副本。\r\n            \r\n","\r\n The \"Get\", \"Set\", \"AddHandler\", \"RemoveHandler\", or \"RaiseEvent\" statement that\r\n begins the accessor block.\r\n ":"\r\n “ get”，“ set”，“ addhandler”，“ removehandler”或“ raiseevent”陈述\r\n 开始登录块。\r\n \r\n"," annotations to the file as necessary.  Note that\r\n            this does not try to be 100% accurate, but rather it handles the most common cases out there.  Specifically,\r\n            if a file contains any nullable annotated/not-annotated types, then we prefix the file with ":" 必要时对文件注释。注意\r\n            这不是试图100％准确的，而是处理那里最常见的案例。具体来说，\r\n            如果文件包含任何可取消的注释/未通知的类型，则我们将文件前缀\r\n","\r\n The value for the StepValue property.\r\n ":"\r\n StepValue属性的值。\r\n \r\n","\r\n            The annotation used to track applicable container in each document to be fixed.\r\n            ":"\r\n            用于跟踪要修复的每个文档中适用容器的注释。\r\n            \r\n","\r\n The value for the Inherits property.\r\n ":"\r\n 继承属性的值。\r\n \r\n","\r\n Represents the \"Select\" query operator.\r\n ":"\r\n 代表“选择”查询操作员。\r\n \r\n","\r\n  Looks up a localized string similar to 'Continue While' can only appear inside a 'While' statement..\r\n":"\r\n  查找类似于“继续”的本地化字符串，只能在a语句中出现。\r\n\r\n","\r\n            This option is used by TypeScript.\r\n            ":"Typescript使用此选项。\r\n            \r\n","\r\n            so that the default severity of the diagnostics with the given ":"\r\n            因此，给定的诊断默认严重程度\r\n","Add 'DebuggerDisplay' attribute":"添加“ debuggerdisplay”属性\r\n","\r\n The value for the AttributeLists property.\r\n ":"\r\n 属性属性的值。\r\n \r\n"," Note: Nothing if node is found ":" 注意：如果找到节点，什么也没有\r\n","Simplify Names":"简化名称\r\n","\r\n An expression representing the alignment of the interpolated expression.\r\n ":"表示插值表达的对齐的表达。\r\n \r\n","control character":"控制字符\r\n","match one or more times":"匹配一次或多次\r\n","Global Namespace":"全局名称空间\r\n","\r\n Tracks synthesized fields that are needed in a submission being compiled.\r\n ":"\r\n 跟踪要编译的提交中所需的合成字段。\r\n \r\n","A list of the preceding trivia.":"前面的琐事列表。\r\n","\r\n  Looks up a localized string similar to Constraint '{0}' conflicts with the constraint '{1}' already specified for type parameter '{2}'..\r\n":"\r\n  查找类似于约束'{0}'与约束'{1}'相似的本地化字符串，已经为type参数指定了'{2}'..\r\n\r\n","\r\n            Traverses the syntax tree of the forked document and\r\n            collects a list of nodes that are not being moved.\r\n            This list of nodes are then removed from the forked copy.\r\n            ":"\r\n            穿越分叉文档的语法树和\r\n            收集未移动的节点列表。\r\n            然后将此节点列表从分叉副本中删除。\r\n            \r\n","\r\n            Provides completion items for extension methods from unimported namespace.\r\n            ":"\r\n            提供来自未插入名称空间的扩展方法的完成项。\r\n            \r\n","\r\n Does this node represent a property with Set accessor and AccessKind not yet bound to Get?\r\n ":"\r\n 该节点是否代表带有SET访问者和访问者的属性？\r\n \r\n","\r\n A helper method for ReferenceManager to set the system assembly, which provides primitive \r\n types like Object, String, etc., e.g. mscorlib.dll. \r\n ":"\r\n 引用meanager设置系统组件的辅助方法，该组件提供原始\r\n 诸如对象，字符串等的类型，例如mscorlib.dll。\r\n \r\n","\r\n            Distance is a number within [0, 1], the smaller the more similar the sequences are. \r\n            ":"\r\n            距离是[0，1]中的数字，序列越小。\r\n            \r\n","\r\n The CLI spec says that custom modifiers must precede the ByRef type code in the encoding of a parameter.\r\n Unfortunately, the managed C++ compiler emits them in the reverse order.  In order to avoid breaking\r\n interop scenarios, we need to support such signatures. \r\n Should be 0 for non-ref parameters.\r\n ":"\r\n CLI规格说，自定义修饰符必须先于参数编码中的BYREF类型代码。\r\n 不幸的是，托管的C ++编译器以相反的顺序排放它们。为了避免破裂\r\n 互动场景，我们需要支持此类签名。\r\n 对于非REF参数，应为0。\r\n \r\n","A list of syntax nodes that represents the content of the param element (e.g. \r\n the description and meaning of the parameter).":"代表参数元素内容的语法节点列表（例如\r\n 参数的描述和含义）。\r\n","Take top":"登顶\r\n","\r\n This is a method rather than a property since the\r\n implementation may be expensive.\r\n ":"\r\n 这是一种方法，而不是属性，因为\r\n 实施可能很昂贵。\r\n \r\n","\r\n            Determines whether given file is a candidate for shadow-copy.\r\n            ":"\r\n            确定给定文件是否是影子拷贝的候选者。\r\n            \r\n","Adding a generic {0} requires restarting the application.":"添加通用{0}需要重新启动应用程序。\r\n","\r\n \"Me\" parameter for this lambda will be that of the containing symbol\r\n ":"\r\n 此lambda的“我”参数将是包含符号的参数\r\n \r\n","A global using directive must precede all non-global using directives.":"全局使用指令必须先于所有非全球使用指令。\r\n","\r\n Same as accessing ":"\r\n 与访问相同\r\n","\r\n            Code action for adding an import when we find a symbol in source in either our\r\n            starting project, or some other unreferenced project in the solution.  If we \r\n            find a source symbol in a different project, we'll also add a p2p reference when\r\n            we apply the code action.\r\n            ":"\r\n            当我们在源中找到符号时，用于添加导入的代码操作\r\n            启动项目或解决方案中的其他一些未参考的项目。要是我们\r\n            在另一个项目中找到一个源符号，当\r\n            我们应用代码操作。\r\n            \r\n","Format string contains invalid placeholder":"格式字符串包含无效的占位符\r\n","\r\n  Looks up a localized string similar to DeclarationSyntax not within tree.\r\n":"\r\n  查找类似于不在树中的声明类似的本地化字符串。\r\n\r\n","top-level statements":"顶级语句\r\n","all symbols":"所有符号\r\n","\r\n Represents a state machine MoveNext method.\r\n Handles special behavior around inheriting some attributes from the original async/iterator method.\r\n ":"\r\n 代表状态机Movenext方法。\r\n 处理特殊行为，围绕从原始异步/迭代方法继承某些属性。\r\n \r\n","Constant value may overflow at runtime (use 'unchecked' syntax to override)":"恒定值可能在运行时溢出（使用“未选中”语法覆盖）\r\n","\r\n Represents a synthesized state machine helper field.\r\n ":"\r\n 代表合成的状态机辅助场。\r\n \r\n","\r\n            The text to display inside the collapsed region.\r\n            ":"\r\n            在折叠区域内显示的文本。\r\n            \r\n","The syntax list of the modifiers.":"修饰符的语法列表。\r\n","\r\n            Converts a verbatim interpolated string @$\"\" to an interpolated verbatim string $@\"\"\r\n            ":"\r\n            将逐字插值字符串 @$“”转换为插值的逐字字符串$ @“”\r\n            \r\n","other, control":"其他，控制\r\n","\r\n Returns the list of custom modifiers, if any, associated with the returned value.\r\n ":"\r\n 返回与返回值关联的自定义修饰符列表。\r\n \r\n","\r\n Note: This is only implemented for those subclasses (e.g., SourceParameterSymbol) for which it\r\n is required. Thus, the base implementation throws an exception instead of being MustOverride.\r\n ":"\r\n 注意：仅针对它的那些子类（例如，源parametersymbol）实现\r\n 是必须的。因此，基本实现会引发异常而不是Mustoverride。\r\n \r\n","decimal-digit character":"十进制数字\r\n","\r\n  Looks up a localized string similar to Cannot infer a common type for the second and third operands of the 'If' operator. One must have a widening conversion to the other..\r\n":"\r\n  查找类似于“ IF”操作员的第二和第三操作数的局部字符串，无法推断出公共类型。一个必须对另一个的转换扩大。\r\n\r\n","\r\n The \"If\" statement that begins the \"If\" block.\r\n ":"\r\n 开始“ if”块的“ if”语句。\r\n \r\n"," \r\n The local is not user defined nor it is a copy of a user defined local (e.g. with a substituted type).\r\n Check the value of ":" \r\n 本地不是用户定义的，也不是用户定义的本地的副本（例如，具有替换类型）。\r\n 检查价值\r\n","\r\n            Returns node that represents a declaration of the symbol whose ":"\r\n            返回节点，表示该符号的声明\r\n","\r\n The keyword that identifies the option being set: Explicit, Strict, Compare or\r\n Infer.\r\n ":"\r\n 标识正在设置的选项的关键字：明确，严格，比较或\r\n 推断。\r\n \r\n","\r\n  Looks up a localized string similar to Statement cannot appear within an interface body..\r\n":"\r\n  查找类似于语句的本地化字符串，无法在接口正文中出现。\r\n\r\n","The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is applied with an invalid parameter name.":"应用于参数'{0}'的CallerArgumentExpresseptresseptresseattribute将无效。它使用无效的参数名称应用。\r\n","\r\n This property is actually a triple workaround:\r\n \r\n 1) Unfortunately, when determining overriding/hiding/implementation relationships, we don't\r\n    have the \"current\" compilation available.  We could, but that would clutter up the API\r\n    without providing much benefit.  As a compromise, we consider all compilations \"current\".\r\n \r\n 2) TypeSymbol.Interfaces doesn't roundtrip in the presence of implicit interface implementation.\r\n    In particular, the metadata symbol may declare fewer interfaces than the source symbol so\r\n    that runtime implicit interface implementation will find the right symbol.  Thus, we need to\r\n    know what kind of symbol we are dealing with to be able to interpret the Interfaces property\r\n    properly.  Since a retargeting TypeSymbol will reflect the behavior of the underlying source\r\n    TypeSymbol, we need this property to match as well.  (C# does not have this problem.)\r\n \r\n 3) The Dev12 VB compiler avoided loading private fields of structs from metadata, even though\r\n    they're supposed to affect definite assignment analysis.  For compatibility\r\n    we therefore ignore these fields when doing DA analysis.  (C# has a similar issue.)\r\n ":"\r\n 该属性实际上是三重解决方法：\r\n \r\n 1）不幸的是，在确定压倒/隐藏/实施关系时，我们不\r\n    具有可用的“当前”汇编。我们可以，但这会使API混乱\r\n    没有提供很多好处。作为妥协，我们认为所有汇编“当前”。\r\n \r\n 2）typesymbol.Interfaces在存在隐式接口实现的情况下不会绕线。\r\n    特别是，元数据符号可能比源符号声明的界面更少\r\n    该运行时隐式接口实现将找到正确的符号。因此，我们需要\r\n    知道我们正在处理哪种符号以解释界面属性\r\n    适当地。由于重新定位类型符号将反映基础源的行为\r\n    Typesymbol，我们也需要此属性才能匹配。 （C＃没有这个问题。）\r\n \r\n 3）DEV12 VB编译器避免了从元数据加载结构的私有字段，尽管\r\n    它们应该影响确定的任务分析。兼容\r\n    因此，我们在进行DA分析时忽略了这些领域。 （C＃也有类似的问题。）\r\n \r\n","\r\n Returns a copy of this with the DotToken property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，Dottoken属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n The opening '$\"', '$“', or '$”' token.\r\n ":"\r\n 开头的“ $”，“'$”或“ $”'令牌。\r\n \r\n","\r\n If the binding context requires specific binding options, then modify the given\r\n lookup options accordingly.\r\n ":"\r\n 如果绑定上下文需要特定的绑定选项，请修改给定\r\n 相应地查找选项。\r\n \r\n","Object initialization can be simplified":"对象初始化可以简化\r\n","Adding {0} requires restarting the application.":"添加{0}需要重新启动应用程序。\r\n"," doesn't intersect the node in any way it's not considered to be underselected.\r\n            ":" 不会以任何方式与节点相交。\r\n            \r\n","\r\n Gets the attribute class being applied.\r\n ":"\r\n 获取要应用属性类。\r\n \r\n","\r\n Serialize this node to a byte stream.\r\n ":"\r\n 将此节点序列化为字节流。\r\n \r\n","\r\n Tells whether binding is happening in a query context.\r\n ":"\r\n 讲述绑定是否在查询上下文中发生。\r\n \r\n","\r\n Represents a declare method defined in source.\r\n ":"\r\n 表示源中定义的声明方法。\r\n \r\n","Target type matches":"目标类型匹配\r\n"," for which ":" 为此\r\n","\r\n The language version that was used to parse the syntax trees of this compilation.\r\n ":"\r\n 用于解析此汇编的语法树的语言版本。\r\n \r\n","\r\n            Helper class to configure diagnostic severity or code style option value based on .editorconfig file\r\n            ":"\r\n            基于.editorConfig文件，用于配置诊断严重性或代码样式的助手类选项值\r\n            \r\n","\r\n Returns current candidate for reuse if there is one.\r\n ":"\r\n 返回当前的候选人以进行重复使用。\r\n \r\n","\r\n Returns a copy of this with the NewExpression property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，新的表达属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n  Looks up a localized string similar to Attribute value is not valid; expecting '{0}' or '{1}'..\r\n":"\r\n  查找类似于属性值的本地化字符串无效；期待'{0}'或'{1}'..\r\n\r\n","\r\n  Looks up a localized string similar to Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' exported from module '{3}'..\r\n":"\r\n  查找类似于'{0}'转发到assembly' {1}'类型的局部字符串与从模块'{3}'导出的类型'{2}'相冲突\r\n\r\n","\r\n Creates a hashcode for this instance.\r\n ":"\r\n 为此实例创建一个主题。\r\n \r\n","\r\n Used to resolve continue statements in each statement form that supports it.\r\n ":"\r\n 用来解决支持它的每个语句形式中的继续语句。\r\n \r\n","\r\n If specified called for every child syntax node (not token) that is visited during the comparison. \r\n It returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\r\n ":"\r\n 如果指定了在比较期间访问的每个儿童语法节点（非令牌）的要求。\r\n 它归还了孩子的递归访问，否则孩子及其子树被忽略了。\r\n \r\n","\r\n If the access includes a set, the type of the expression\r\n is the type of the setter value parameter. Otherwise, the\r\n type of the expression is the return type of the getter.\r\n ":"\r\n 如果访问包括一组，则表达式的类型\r\n 是设置器值参数的类型。否则，\r\n 表达式的类型是getter的返回类型。\r\n \r\n","\r\n Represents a multi-line \"If ... Then ... ElseIf ... Then ... Else ... End If\"\r\n block.\r\n ":"\r\n 代表多行的“如果...然后... elseif ...然后... else ...结束如果”\r\n 堵塞。\r\n \r\n"," representing the specific kind of AccessorBlockSyntax.\r\n One of GetAccessorBlock, SetAccessorBlock, AddHandlerAccessorBlock,\r\n RemoveHandlerAccessorBlock, RaiseEventAccessorBlock.\r\n ":" 代表特定类型的连符号。\r\n getAccessorBlock，setAccessorBlock，Addhandleraccessorblock之一，\r\n 删除HandlerAccessorBlock，RaiseeventAccessorBlock。\r\n \r\n","\r\n True if inside in binding arguments of constructor \r\n call with {'Me'/'MyClass'/'MyBase'}.New(...) from another constructor\r\n ":"\r\n 如果在构造函数的绑定参数中，则为true\r\n 用{'me'/'myclass'/'mybase'}。来自另一个构造函数的新（...）\r\n \r\n","\r\n  Looks up a localized string similar to Identifier expected, preceded with a period..\r\n":"\r\n  查找类似于预期标识符的本地化字符串，此前。\r\n\r\n","\r\n This method is called for a type within a namespace when we are building a map of extension methods \r\n for the whole (compilation merged or module level) namespace.\r\n \r\n The 'appendThrough' parameter allows RetargetingNamespaceSymbol to delegate majority of the work \r\n to the underlying named type symbols, but still add RetargetingMethodSymbols to the map.\r\n ":"当我们构建扩展方法地图时\r\n 对于整个（编译合并或模块级别）名称空间。\r\n \r\n “附录”参数允许retargetingNamespaceSymbol委派大部分工作\r\n 在基础命名的类型符号上，但仍将retargetingMethodsymbols添加到地图中。\r\n \r\n","\r\n  Looks up a localized string similar to Method does not have a signature compatible with the delegate..\r\n":"\r\n  查找类似于方法的本地化字符串与代表兼容的签名。\r\n\r\n","\r\n Create a new ParameterSymbol with everything the same except the owner. Used for property\r\n accessor methods, for example.\r\n ":"\r\n 创建一个新的parametersymbol，除所有者外，所有内容都相同。用于属性\r\n 例如，访问者方法。\r\n \r\n","\r\n            Given a document and syntax node, returns the fully qualified name of the located node's declaration.\r\n            ":"\r\n            给定文档和语法节点，返回了位置节点声明的完全合格名称。\r\n            \r\n","\r\n The value for the Argument property.\r\n ":"\r\n 参数属性的值。\r\n \r\n","\r\n Append the full text of this node including children and trivia to the given stringbuilder.\r\n ":"\r\n 将这个节点的全文附加到给定的字符串构造器中。\r\n \r\n","\r\n Get the \"this\" parameter for this property.  This is only valid for source fields.\r\n ":"\r\n 获取此属性的“此”参数。这仅适用于源字段。\r\n \r\n"," \r\n Given anonymous delegate descriptor provided, construct an anonymous delegate symbol\r\n ":" \r\n 给定的匿名代表描述符，构建一个匿名代表符号\r\n \r\n","A collection representing existing symbols. Symbols parsed from ":"代表现有符号的集合。符号从中解析\r\n","Updating the Implements clause of a {0} requires restarting the application.":"更新{0}的实施条款需要重新启动应用程序。\r\n","\r\n            Returns true when the closing token matches the expected closing token for this brace completion service.\r\n            Used by ":"\r\n            当闭合令牌与此支架完成服务的预期关闭令牌匹配时，返回返回。\r\n            使用\r\n","Find and install latest version of '{0}'":"查找并安装最新版本的“ {0}”\r\n","Escapes ":"逃脱\r\n","\r\n            Renames the file containing the target type\r\n            ":"\r\n            重命名包含目标类型的文件\r\n            \r\n","\r\n  Looks up a localized string similar to 'IsNot' operand of type '{0}' can be compared only to 'Nothing' because '{0}' is a type parameter with no class constraint..\r\n":"查找类似于'iSNot'操作数'{0}'的本地化字符串，只能与'Nothing'进行比较，因为'{0}'是一个类型参数，没有类别约束。\r\n\r\n"," are rendered as\r\n            a codeblock in LSP markup.\r\n            ":" 被渲染为\r\n            LSP标记中的CodeBlock。\r\n            \r\n","\r\n            Gets the references that need to be assigned to the compilation.\r\n            This can be different than the list of references defined by the ":"\r\n            获取需要分配给汇编的引用。\r\n            这可能与由\r\n","\r\n            Rules that modify the set of characters that can be typed to filter the list of completion items.\r\n            ":"\r\n            修改可以键入的字符集的规则，这些字符集可以过滤完成项目列表。\r\n            \r\n","\r\n This method does the following set of operations in the specified order:\r\n (1) GetAttributesToBind: Merge the given attributeBlockSyntaxList into a single list of attributes to bind.\r\n (2) GetAttributes: Bind the attributes (attribute type, arguments and constructor).\r\n (3) DecodeWellKnownAttributes: Decode and validate bound well-known attributes.\r\n (4) ValidateAttributes: Perform some additional attribute validations, such as\r\n         1) Duplicate attributes,\r\n         2) Attribute usage target validation, etc.\r\n (5) Store the bound attributes and decoded well-known attribute data in lazyCustomAttributesBag in a thread safe manner.\r\n ":"\r\n 该方法按指定顺序进行以下操作集：\r\n （1）getAttributestobind：将给定的属性blocksyntaxlist合并到要绑定的属性列表中。\r\n （2）getAttributes：绑定属性（属性类型，参数和构造函数）。\r\n （3）解码器已知问题：解码和验证绑定的已知属性。\r\n （4）validateTributes：执行一些其他属性验证，例如\r\n         1）重复属性，\r\n         2）属性使用目标验证等。\r\n （5）以线程安全的方式将界限和解码众所周知的属性数据存储在LazyCustomatTributesBag中。\r\n \r\n","\r\n Return true if and only if an expression is a semantical Nothing literal, \r\n which is defined as follows (the definition is consistent with \r\n definition used by Dev10 compiler):\r\n - A Nothing literal according to the language grammar, or\r\n - A parenthesized expression, for which IsNothingLiteral returns true, or\r\n - An expression of type Object with constant value == Nothing.\r\n ":"\r\n 当且仅当表达式是语义上没有字面意义时，返回true\r\n 定义如下（定义与\r\n Dev10编译器使用的定义）：\r\n  - 根据语言语法或\r\n  - 括号的表达式，对此不返回true或\r\n  - 具有常数值的类型对象的表达式==没有。\r\n \r\n","\r\n Scan interpolated string text content.\r\n ":"\r\n 扫描插值字符串文本内容。\r\n \r\n"," is\r\n            part of the ":" 是\r\n            的一部分\r\n","\r\n  Looks up a localized string similar to 'AddHandler', 'RemoveHandler' and 'RaiseEvent' method parameters cannot be declared '{0}'..\r\n":"\r\n  查找类似于“ Addhandler”，“ Remove Handler”和“ Raiseevent”方法参数的本地化字符串，无法声明'{0}'..\r\n\r\n","\r\n  Looks up a localized string similar to Attribute value is not valid; expecting '{0}'..\r\n":"\r\n  查找类似于属性值的本地化字符串无效；期待'{0}'..\r\n\r\n","\r\n Bind a type name using the given binder. Returns a type symbol if the binding bound to something,\r\n or an error symbol if the binding failed. In either case, errors may be reported via the\r\n context. For example, if an inaccessible type or type with the wrong arity was found, the best possible\r\n type is returned, but an error is also generated.\r\n ":"\r\n 使用给定的粘合剂绑定类型名称。返回类型符号如果绑定到某物的绑定，\r\n 或错误符号如果绑定失败。无论哪种情况，错误都可以通过\r\n 语境。例如，如果发现了错误的类型或类型的类型，则可能是最好的\r\n 返回类型，但也会生成错误。\r\n \r\n"," Region being analyzed: end node ":" 分析区域：结束节点\r\n","Before and after query operators (Aggregate, Distinct, From, Group By, Group Join, Join, Let, \r\n Order By, Select, Skip, Skip While, Take, Take While, Where, In, Into, On, Ascending, and Descending).":"查询运营商之前和之后（聚集，与组的汇总，组合，组加入，加入，让，让，\r\n 订购，选择，跳过，跳过，乘，乘，在，在，进，上，上升和下降的位置，沿何处，登上）。\r\n","The \"tt\" custom format specifier (plus any number of additional \"t\" specifiers) represents the entire AM/PM designator. The appropriate localized designator is retrieved from the DateTimeFormatInfo.AMDesignator or DateTimeFormatInfo.PMDesignator property o ...":"“ TT”自定义格式指定符（加上任何数量的附加“ T”指示符）代表整个AM/PM指定器。从dateTimeFormatinfo.amdesignator或dateTimeFormatinfo.pmdesignator属性属性o ...\r\n","Arguments with 'in' modifier cannot be used in dynamically dispatched expressions.":"带有“ In”修饰符的参数不能用于动态调度表达式中。\r\n",", and is not the first \r\n ":"，不是第一个\r\n \r\n","\r\n Returns whether the parameterless constructor constraint was specified.\r\n ":"\r\n 返回是否指定了无参数构造函数约束。\r\n \r\n"," if the source supports ":" 如果来源支持\r\n","\r\n            Returns a document analysis or kicks off a new one if one is not available for the specified document snapshot.\r\n            ":"\r\n            如果指定的文档快照不可用，则返回文档分析或启动新的文档分析。\r\n            \r\n"," representing the specific kind of\r\n SpecialConstraintSyntax. One of NewConstraint, ClassConstraint,\r\n StructureConstraint.\r\n ":" 代表特定种类\r\n SpecialConstraintSntax。新范围之一，classconstraint，\r\n 结构。\r\n \r\n","\r\n            Looks up specified partial assembly name in the GAC and returns the best matching ":"\r\n            查找GAC中指定的部分组件名称，并返回最佳匹配\r\n",".\r\n            - Selection is zero-width and touching a Token whose ancestor of type ":"。\r\n             - 选择为零，触摸一个令牌的祖先\r\n","\r\n Represents the beginning of a #Region directive appearing in source.\r\n ":"\r\n 表示源出现在源中的#Rigion指令的开头。\r\n \r\n","\r\n Returns true if the specified ":"\r\n 如果指定\r\n","\r\n Returns a copy of this with the ContinueKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此的副本，而继续关键字属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","s for the given ":"给定的\r\n","\r\n            True if at least one of the threads whom this active statement belongs to is in a non-leaf frame.\r\n            ":"\r\n            如果至少有此活动语句属于的线程中的至少一个是在非叶片框架中，则为真实。\r\n            \r\n","mark, enclosing":"标记，封闭\r\n","\r\n             We ignore references that are in a directory that contains the names\r\n             \"Packages\", \"packs\", \"NuGetFallbackFolder\", or \"NuGetPackages\"\r\n             These directories are most likely the ones produced by NuGet, and we don't want\r\n             to offer to add .dll reference manually for dlls that are part of NuGet packages.\r\n             \r\n             Note that this is only a heuristic (though a good one), and we should remove this\r\n             when we can get an API from NuGet that tells us if a reference is actually provided\r\n             by a nuget packages.\r\n             Tracking issue: https://github.com/dotnet/project-system/issues/5275\r\n             \r\n             This heuristic will do the right thing in practically all cases for all. It \r\n             prevents the very unpleasant experience of us offering to add a direct metadata \r\n             reference to something that should only be referenced as a nuget package.\r\n            \r\n             It does mean that if the following is true:\r\n             You have a project that has a non-nuget metadata reference to something in a \"packages\"\r\n             directory, and you are in another project that uses a type name that would have matched\r\n             an accessible type from that dll. then we will not offer to add that .dll reference to\r\n             that other project.\r\n             \r\n             However, that would be an exceedingly uncommon case that is degraded.  Whereas we're \r\n             vastly improved in the common case. This is a totally acceptable and desirable outcome\r\n             for such a heuristic.\r\n             ":"\r\n             我们忽略包含名称的目录中的引用\r\n             \"Packages\"、\"packages\"、\"NuGetFallbackFolder\"或\"NuGetPackages\"\r\n             这些目录很可能是NuGet生成的目录，我们不希望\r\n             提供补充。为作为NuGet包一部分的dll手动引用dll。\r\n             \r\n             请注意，这只是一个启发式（虽然是一个好的），我们应该删除它\r\n             当我们可以从NuGet获取一个API，告诉我们是否实际提供了引用\r\n             一个nuget包。\r\n             追踪问题：https://github.com/dotnet/project-system/issues/5275\r\n             \r\n             这种启发式将在几乎所有情况下为所有人做正确的事情。 它 \r\n             防止我们提供添加直接元数据的非常不愉快的经历 \r\n             引用应该只作为nuget包引用的东西。\r\n            \r\n             它确实意味着，如果以下是真的:\r\n             您有一个项目，该项目具有对\"包\"中的某些内容的非nuget元数据引用\r\n             目录，并且您在另一个使用匹配的类型名称的项目中\r\n             来自该dll的可访问类型。 那么我们就不会提出补充这一点。dll引用到\r\n             另一个项目。\r\n             \r\n             然而，这将是一个极其罕见的退化案例。  而我们是 \r\n             在常见情况下大大改善。 这是一个完全可以接受和可取的结果\r\n             对于这样的启发式。\r\n             \r\n"," this update is associated with.\r\n            ":" 此更新与之关联。\r\n            \r\n","start of string only":"仅启动字符串\r\n","\r\n Returns true if any members that we need are missing or have use-site errors.\r\n ":"\r\n 如果我们需要的任何成员丢失或存在使用站点错误，则返回true。\r\n \r\n","\r\n Performs a check for overloads/overrides/shadows conflicts, generates diagnostics.\r\n ":"\r\n 对超载/覆盖/阴影冲突进行检查，生成诊断。\r\n \r\n","\r\n The parent of this node.\r\n ":"\r\n 该节点的父母。\r\n \r\n","\r\n Transition from scanning XML to scanning VB. As a result,\r\n any single line trivia is consumed and appended to the token\r\n which is assumed to be the token at the transition point.\r\n ":"\r\n 从扫描XML过渡到扫描VB。因此，\r\n 任何单线琐事都被消耗并附加到令牌上\r\n 假定是在过渡点处的令牌。\r\n \r\n","\r\n            This method adjusts the ":"\r\n            此方法调整了\r\n","\r\n Get preprocessor keywords\r\n ":"\r\n 获取预处理器关键字\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' is not valid on a Structure declaration..\r\n":"\r\n  在结构声明上查找类似于“ {0}”的本地化字符串。\r\n\r\n","The EnumeratorCancellationAttribute will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable":"EnumeratorCancellationAttribute将无效。该属性仅对在异步 - 列表方法中返回iAsyncenumerable中的类型concellationToken的参数有效\r\n","\r\n The left expression in the Join condition.\r\n ":"\r\n 在联接条件下的左表达式。\r\n \r\n","\r\n            Collect all the available cast pairs, format is (target argument expression, potential conversion type)\r\n            ":"\r\n            收集所有可用的铸造对，格式为（目标参数表达式，潜在转换类型）\r\n            \r\n","The first parameter of a 'ref' extension method '{0}' must be a value type or a generic type constrained to struct.":"“ REF”扩展方法'{0}'的第一个参数必须是约束构造的值类型或通用类型。\r\n","\r\n            Duplicate typeparam tag\r\n            ":"\r\n            重复的Typeparam标签\r\n            \r\n","s.Get(s.Length - n)":"s.get（s.length -n）\r\n","\r\n Represents a Visual Basic global imports.\r\n ":"\r\n 代表视觉基本的全局导入。\r\n \r\n","\r\n The \"Else\" part in a Case Else statement.\r\n ":"\r\n 案件陈述中的“ else”部分。\r\n \r\n"," for attributes applied on the symbol and has stored the decoded data in the\r\n lazyCustomAttributesBag on the symbol. Bound attributes haven't been stored on the bag yet.\r\n \r\n Post-validation for attributes that is dependent on other attributes can be done here.\r\n \r\n This method should not have any side effects on the symbol, i.e. it SHOULD NOT change the symbol state.\r\n ":" 对于符号上应用的属性，并将解码数据存储在\r\n 符号上的lazycustomattributesbag。绑定属性尚未存储在包上。\r\n \r\n 依赖其他属性的属性的验证后可以在此处完成。\r\n \r\n 此方法不应对符号产生任何副作用，即它不应更改符号状态。\r\n \r\n","\r\n The class to represent all methods imported from a PE/module.\r\n ":"代表从PE/模块导入的所有方法的类。\r\n \r\n",", including all declared variables and return value.":"，包括所有声明的变量和返回值。\r\n","Remove Suppression {0}":"删除抑制{0}\r\n","'{0}' defines 'Equals' but not 'GetHashCode'":"'{0}'定义“等于'但不是“ gethashcode”\r\n"," Creates a token with kind IntegerLiteralToken from an 8-byte signed integer value. ":" 从8字节签名的整数值中创建一个具有元素integerliteraltoken的令牌。\r\n","\r\n Returns True if this conversion is a widening conversion, and not a narrowing conversion.\r\n ":"\r\n 如果这种转换是一种扩大的转换，而不是变窄的转换，则返回真实。\r\n \r\n","AM/PM (abbreviated)":"am/pm（缩写）\r\n","\r\n Encapsulates ComClass specific data and analysis.\r\n ":"\r\n 封装ComClass的特定数据和分析。\r\n \r\n","\r\n  Looks up a localized string similar to This inheritance causes circular dependencies between {0} '{1}' and its nested or base type '{2}'..\r\n":"\r\n  查找类似于此继承的本地化字符串会导致{0}'{1}'及其嵌套或基本类型'{2}'..之间的循环依赖关系。\r\n\r\n","\r\n Mismatch in total number of parameters, both required and optional\r\n ":"\r\n 所需和可选的参数总数不匹配\r\n \r\n"," Method created with their bodies ":" 用他们的身体创建的方法\r\n","\r\n Represents a single keyword in a VB program. Which keyword can be determined\r\n from the Kind property.\r\n ":"\r\n 代表VB程序中的一个关键字。可以确定哪个关键字\r\n 从该物业。\r\n \r\n","\r\n  Looks up a localized string similar to Expected closing '-->' for XML comment..\r\n":"\r\n  查找类似于预期关闭' - >'的本地化字符串，以进行XML评论。\r\n\r\n","\r\n  Looks up a localized string similar to Conflicting options specified: Win32 resource file; Win32 manifest..\r\n":"\r\n  查找类似于指定的相互冲突选项的本地化字符串：WIN32资源文件； Win32清单..\r\n\r\n"," Creates a token with kind DecimalLiteralToken from a decimal value. ":" 从小数值创建一个具有分数的代币。\r\n","\r\n The For or For Each statement that begins the block.\r\n ":"\r\n 对于开始块的每个语句或为每个语句。\r\n \r\n","\r\n Subclasses may override EnterRegion to perform any actions at the entry to the region.\r\n ":"\r\n 子类可以覆盖EnterRegion以在该地区的入口处执行任何操作。\r\n \r\n","Value:":"价值：\r\n","Indicates whether to binding the expression as a full expressions,\r\n or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then\r\n expression should derive from TypeSyntax.":"指示是否将表达式绑定为完整表达式，\r\n 或类型或名称空间。如果提供了猜测bindingoption.bindastypeornamespace，则\r\n 表达应源自型号。\r\n","\r\n            Returns an updated ":"\r\n            返回更新\r\n","Controls generic argument parsing":"控制通用参数解析\r\n","\r\n  Looks up a localized string similar to Expression of type '{0}' is not queryable. Make sure you are not missing an assembly reference and/or namespace import for the LINQ provider..\r\n":"\r\n  查找类似于“ {0}”类型表达式的本地化字符串。确保您不会缺少为LINQ提供商导入的汇编引用和/或名称空间。\r\n\r\n","\r\n NamedTypeSymbol calls derived implementations of this method when declared interfaces\r\n are needed for the first time.\r\n \r\n basesBeingResolved are passed if there are any types already have their bases resolved\r\n so that the derived implementation could avoid infinite recursion\r\n ":"\r\n 声明接口时，该方法的命名typeymbol调用派生的实现\r\n 第一次需要。\r\n \r\n 如果有任何类型已经解决了基地，则通过基地存在\r\n 因此，派生的实施可以避免无限递归\r\n \r\n","\r\n Lookup the given name in the binder and containing binders.\r\n Returns the result of the lookup. See the definition of LookupResult for details.\r\n ":"\r\n 查找粘合剂中的给定名称并包含粘合剂。\r\n 返回查找结果。有关详细信息，请参见LookupResult的定义。\r\n \r\n","Invalid format of the assembly data.":"组装数据的无效格式。\r\n","\r\n This is intended for symbols that are ordinary symbols in the language sense,\r\n and may be used by code, but that are simply declared implicitly rather than\r\n with explicit language syntax.\r\n \r\n Examples include (this list is not exhaustive):\r\n   the default constructor for a class or struct that is created if one is not provided,\r\n   the BeginInvoke/Invoke/EndInvoke methods for a delegate,\r\n   the generated backing field for an auto property or a field-like event,\r\n   the \"this\" parameter for non-static methods,\r\n   the \"value\" parameter for a property setter,\r\n   the parameters on indexer accessor methods (not on the indexer itself),\r\n   methods in anonymous types\r\n ":"\r\n 这是针对语言意义上的普通符号的符号\r\n 并且可以由代码使用，但只是隐式声明而不是\r\n 带有明确的语言语法。\r\n \r\n 示例包括（此列表并不详尽）：\r\n   如果不提供一个类别的类或结构的默认构造函数，则\r\n   委托人的开头/调用/endinvoke方法，\r\n   自动属性或类似现场的事件的生成的背面字段，\r\n   非静态方法的“此”参数，\r\n   属性设置器的“值”参数，\r\n   索引器访问者方法上的参数（不在索引本身上）​​，\r\n   匿名类型的方法\r\n \r\n","\r\n     SemanticInfo SemanticModel.GetSemanticInfo(ExpressionSyntax expression);\r\n     SemanticInfo SemanticModel.BindExpression(SyntaxNode location, ExpressionSyntax expression);\r\n     SemanticInfo SemanticModel.BindType(SyntaxNode location, ExpressionSyntax type);\r\n     SemanticInfo SemanticModel.BindNamespaceOrType(SyntaxNode location, ExpressionSyntax type);\r\n ":"\r\n     semanticinfo semanticmodel.getSemanticinfo（表达式表达式）;\r\n     semanticinfo semanticmodel.bindexpression（语法诺德的位置，表达式词法表达式）;\r\n     semanticinfo semanticmodel.bindtype（语法诺德的位置，表达式类别类型）;\r\n     semanticinfo semanticmodel.bindnamespaceortype（语法诺德位置，表达式yntax type）;\r\n \r\n"," accepts null, to be able to cater to codegen features\r\n            that are about to generate a local declaration and do not have this information to pass in.\r\n            Things (like analyzers) that do have a local declaration already, should pass this in.\r\n            ":" 接受null，能够迎合代码GEN功能\r\n            即将生成本地声明，并且没有此信息要传递。\r\n            确实已经有本地声明的事情（例如分析仪）应该将其传递给。\r\n            \r\n"," to see if it contains the name of ":" 查看它是否包含 \r\n","\r\n  Looks up a localized string similar to 'IsNot' requires operands that have reference types, but this operand has the value type '{0}'..\r\n":"\r\n  查找类似于“ ISNOT”的本地化字符串，需要具有参考类型的操作数，但是该操作数具有值类型'{0}'..\r\n\r\n","s in a row (each containing a ":"连续的s（每个都包含一个\r\n","\r\n The value for the Constraints property.\r\n ":"\r\n 约束属性的值。\r\n \r\n","An expression of type '{0}' cannot be handled by a pattern of type '{1}' in C# {2}. Please use language version {3} or greater.":"类型'{0}'的表达式无法通过c＃{2}中的类型'{1}'的模式来处理。请使用语言版本{3}或更大。\r\n","The CallerArgumentExpressionAttribute may only be applied to parameters with default values":"CallerArgumentExpressexAttribute只能应用于具有默认值的参数\r\n","\r\n The value for the DeclareKeyword property.\r\n ":"\r\n 声明关键字属性的值。\r\n \r\n","\r\n            Raise this when all diagnostics reported from this update source has cleared\r\n            ":"\r\n            当此更新源报告的所有诊断学清除时，请提出这一点\r\n            \r\n","\r\n            Code fixer for unused expression value diagnostics reported by ":"\r\n            未使用的表达值诊断的代码修复程序报告\r\n","\r\n True if RuntimeSpecialName metadata flag is set for this symbol.\r\n ":"\r\n 如果为此符号设置了RunTimes -pecialname元数据标志，则为正确。\r\n \r\n","\r\n Analyzes the tree trying to figure which locals may live on stack. It is \r\n a fairly delicate process and must be very familiar with how CodeGen works. \r\n It is essentially a part of CodeGen.\r\n \r\n NOTE: It is always safe to mark a local as not eligible as a stack local \r\n so when situation gets complicated we just refuse to schedule and move on.\r\n ":"\r\n 分析这棵树试图弄清楚哪些当地人可以居住在堆栈上。这是\r\n 一个相当微妙的过程，必须对Codegen的工作方式非常熟悉。\r\n 它本质上是Codegen的一部分。\r\n \r\n 注意：将本地标记为不符合堆栈本地的本地始终是安全的\r\n 因此，当情况变得复杂时，我们只是拒绝安排并继续前进。\r\n \r\n","\r\n  Looks up a localized string similar to Cannot infer a return type.  Consider adding an 'As' clause to specify the return type..\r\n":"\r\n  查找类似于不能推断返回类型的本地化字符串。考虑添加一个“ AS”子句以指定返回类型。\r\n\r\n","\r\n  Looks up a localized string similar to Method cannot contain both a '{0}' statement and a definition of a variable that is used in a lambda or query expression..\r\n":"\r\n  查找类似于方法的本地化字符串不能包含“ {0}”语句，也不能包含在lambda或查询表达式中使用的变量的定义。\r\n\r\n","\r\n Binder used to bind For and ForEach blocks. \r\n It hosts the control variable (if one is declared) \r\n and inherits ExitableStatementBinder to provide Continue/Exit labels if needed. \r\n ":"\r\n 粘合剂用于绑定和foreach块。\r\n 它托管控制变量（如果声明了）\r\n 并继承ExitableStatementBinder，如果需要，可以提供继续/退出标签。\r\n \r\n","\r\n Binder used for interiors of documentation comment\r\n ":"\r\n 用于文档注释内部的粘合剂\r\n \r\n","A source file contains a header that does not match the required text":"源文件包含一个不匹配所需文本的标头\r\n","\r\n A local symbol created by For from-to statement when Option Infer is on.\r\n ":"\r\n A local symbol created by For from-to statement when Option Infer is on.\r\n \r\n","\r\n Marshalling information for return value (FieldMarshal in metadata). \r\n ":"\r\n 编组信息以获取返回价值（元数据中的fieldmarshal）。\r\n \r\n","\r\n The \"Operator\" statement that begins the block.\r\n ":"\r\n 开始块的“操作员”语句。\r\n \r\n"," Current compilation ":" 当前汇编\r\n","\r\n Gets corresponding primitive type code for this type declaration.\r\n ":"\r\n 获取此类型声明的相应原始类型代码。\r\n \r\n","\r\n The value that branching is based on.\r\n ":"\r\n 分支基于的价值。\r\n \r\n","\r\n            Returns any text changes that need to be made after adding the closing brace.\r\n            ":"\r\n            返回添加闭合支架后需要进行的任何文本更改。\r\n            \r\n","\r\n For each statement with captured variables, identifies the nearest enclosing statement with captured variables.\r\n ":"\r\n 对于带有捕获变量的每个语句，请标识带有捕获变量的最近的封装语句。\r\n \r\n","\r\n Tells if we should emit [Set/Clear]ProjectErrors when entering/leaving handlers\r\n ":"\r\n 告诉我们在输入/离开处理人员时是否应该发射[设置/清除]项目室\r\n \r\n","\r\n An array of cached well known types available for use in this Compilation.\r\n Lazily filled by GetWellKnownType method.\r\n ":"\r\n 一系列可用于此汇编的缓存众所周知的类型。\r\n 懒洋洋地填充了getwellknowntype方法。\r\n \r\n","Convert to verbatim string":"转换为逐字字符串\r\n","\r\n Whether the token was specified in base 10, 16, or 8.\r\n ":"\r\n 无论是在10、16还是8中指定令牌。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' is not accessible in this context because the return type is not accessible..\r\n":"\r\n  在此上下文中无法访问类似于“ {0}”的本地化字符串，因为返回类型无法访问。\r\n\r\n","\r\n  Looks up a localized string similar to The field has multiple distinct constant values..\r\n":"\r\n  查找类似于该字段的局部字符串具有多个不同的常数值。\r\n\r\n","\r\n The value for the Statements property.\r\n ":"\r\n 语句属性的值。\r\n \r\n","For a statement that contains one or more embedded statements, braces may be omitted when\r\n             every embedded statement fits on one line, and the part preceding the embedded statement is placed on one\r\n             line. If any embedded statement uses braces, braces are preferred for all embedded statements of the same\r\n             parent statement. For the purposes of evaluating this rule, if the embedded statement following an\r\n             ":"对于包含一个或多个嵌入语句的语句，当\r\n             每个嵌入式语句放在一行上，嵌入式语句前面的部分放在一行上\r\n             行。 如果任何嵌入语句使用大括号，则大括号对于相同的所有嵌入语句都是首选\r\n             家长陈述。 为了评估此规则的目的，如果嵌入式语句后面的\r\n             \r\n","After assignment operators (=, &=, :=, +=, -=, *=, /=, \\=, ^=, <<=, >>=).":"分配运算符后（=，=，：=， +=， -  =， *=， /=，\\ =， ^=，<< =，>> =）。\r\n","The syntax kind to test for.":"要测试的语法类型。\r\n","\r\n            for each operation block to determine if we should analyze the operation block or bail out.\r\n            ":"\r\n            对于每个操作块，以确定我们是否应该分析操作块或释放。\r\n            \r\n","Generate {0} '{1}' in new file":"在新文件中生成{0}'{1}'\r\n","\r\n Imports touched by a binder with this flag set are not consider \"used\".\r\n ":"\r\n 用此标志集接触的活页夹的导入不被考虑“使用”。\r\n \r\n","\r\n            Gets data for how to fix a set of ":"\r\n            获取如何修复一组的数据\r\n"," is either null or incomplete: it only provides mapping of the changed members of a single partial type declaration.\r\n            ":" 为null或不完整：它仅提供单个部分类型声明的更改成员的映射。\r\n            \r\n","Warning: Semantics may change when converting statement.":"警告：转换语句时的语义可能会改变。\r\n","Constant value '{0}' may overflow '{1}' at runtime (use 'unchecked' syntax to override)":"常数值'{0}'可能在运行时溢出{1}'\r\n","A goto cannot jump to a location before a using declaration within the same block.":"在使用同一块内使用声明之前，goto不能跳到位置。\r\n","\r\n            Clears shadow-copy cache, disposes all allocated metadata, and attempts to delete copied files.\r\n            ":"\r\n            清除阴影拷贝缓存，处置所有分配的元数据，并尝试删除复制的文件。\r\n            \r\n"," then to a backup ":" 然后备份\r\n","s to the ":"S到\r\n","Introduce query variable for '{0}'":"引入“ {0}”的查询变量\r\n","Parameters:":"参数：\r\n","\r\n Returns the syntax tree.\r\n ":"\r\n 返回语法树。\r\n \r\n","\r\n A single field to hold optional auxiliary data.\r\n In many scenarios it is possible to avoid allocating this, thus saving total space in ":"\r\n 单个字段以容纳可选的辅助数据。\r\n 在许多情况下，有可能避免分配此问题，从而节省了总空间\r\n","\r\n  Looks up a localized string similar to Array modifiers cannot be specified on both a variable and its type..\r\n":"\r\n  在变量及其类型上都无法指定类似于数组修饰符的本地化字符串。\r\n\r\n","The message shown within the message box.":"消息框中显示的消息。\r\n","\r\n Blocks that contain (recursively) a lambda that is lifting. \r\n Such blocks are considered as potentially needing closure initialization when doing jump verification.\r\n ":"\r\n 包含（递归）抬起的lambda的块。\r\n 在进行跳跃验证时，此类块被认为可能需要封闭初始化。\r\n \r\n","\r\n            The operation that will actually install the nuget package.\r\n            ":"\r\n            实际安装Nuget软件包的操作。\r\n            \r\n","\r\n By default this information is extracted from ":"\r\n 默认情况下，此信息是从中提取的\r\n","The \"O\" or \"o\" standard format specifier represents a custom date and time format string using a pattern that preserves time zone information and emits a result string that complies with ISO 8601. For DateTime values, this format specifier is designed to p ...":"“ O”或“ O”标准格式指定符代表使用一个模式来保留时区信息并发出符合ISO 8601的结果字符串。对于DateTime值，此格式规格旨在p。 ..\r\n","\r\n            Gets the change to be applied when the specified item is committed.\r\n            ":"\r\n            在指定项目时，获取要应用的更改。\r\n            \r\n","\r\n For each member in \"overloadedMembers\" that is marked Overrides, set its\r\n metadata name to be the metadata name of its overridden member. Return the\r\n first such name, lexically.\r\n \r\n Note: can return null if no override member with an actual overridden member was found.\r\n ":"\r\n 对于标记为替代的“超载符号”中的每个成员\r\n 元数据名称为其覆盖成员的元数据名称。返回\r\n 首先是词汇。\r\n \r\n 注意：如果没有找到实际覆盖成员的替补成员，则可以返回null。\r\n \r\n","\r\n Return true if the accessor accessibility is more restrictive\r\n than the property accessibility, otherwise false.\r\n ":"\r\n 如果登录器可访问性更具限制性，则返回true\r\n 比属性可访问性，否则是错误的。\r\n \r\n","\r\n                 . name (arglist) remainder\r\n             ":"\r\n                 。名称（arglist）剩余\r\n             \r\n","conversion operator":"转换操作员\r\n","\r\n Abstract node class that represents the different kinds of \"As {type-name}\"\r\n clauses in a declaration: simple \"As\" clauses and \"As New\" clauses. The type\r\n has optional attributes associated with it, although attributes are not\r\n permitted in all possible places where this node occurs.\r\n ":"\r\n 代表不同种类的“ AS {type-name}”的抽象节点类\r\n 声明中的从句：简单的“为”子句和“新”子句。类型\r\n 具有与之关联的可选属性，尽管属性不是\r\n 允许在此节点发生的所有可能的地方允许。\r\n \r\n","No valid statement range to extract":"没有提取的有效语句范围\r\n","\r\n            Whether or not this region should be automatically collapsed when the 'Collapse to Definitions' command is invoked.\r\n            ":"\r\n            当调用“崩溃为定义”命令时，该区域是否应自动崩溃。\r\n            \r\n","The default rule that determines if the enter key is passed through to the editor after the selected item has been committed.":"确定所选项目后，确定Enter密钥是否传递给编辑器的默认规则。\r\n","\r\n Is this a symbol for an anonymous type (including delegate).\r\n ":"\r\n 这是匿名类型（包括委托）的符号。\r\n \r\n","File-scoped namespace must precede all other members in a file.":"文件划分的名称空间必须先于文件中的所有其他成员。\r\n","\r\n Used for property accessors. Getter copies its return type attributes from the property return type attributes.\r\n \r\n So far we only need to return ":"\r\n 用于物业访问者。 Getter从属性返回类型属性复制其返回类型属性。\r\n \r\n 到目前为止，我们只需要返回\r\n","PERF: Not using Array.IndexOf here because it results in a call to IndexOf on the\r\n            default EqualityComparer for SyntaxKind.The default comparer for SyntaxKind is the\r\n            ObjectEqualityComparer which results in boxing allocations.":"perf：不使用array.indexof此处，因为它会导致对索引的调用\r\n            语法Kind的默认equalityComparer。语法Kind的默认比较是\r\n            ObjectEqualityComparer导致拳击分配。\r\n","expr1.Length - expr2":"expr1.length -expr2\r\n","\r\n  Looks up a localized string similar to 'End Class' must be preceded by a matching 'Class'..\r\n":"\r\n  查找类似于“ End类”的本地化字符串必须先于匹配的“类”。\r\n\r\n","\r\n  Looks up a localized string similar to '{0}' is a module and cannot be referenced as an assembly..\r\n":"\r\n  查找类似于“ {0}”的本地化字符串是一个模块，不能称为汇编。\r\n\r\n",": the set of intervals analyzed by ":"：由\r\n","\r\n Once we see a lambda lifting something\r\n We mark all scopes from the current up to the one that declares lifted symbol as\r\n containing a lifting lambda.\r\n This is needed so that we could reject jumps that might jump over frame allocations.\r\n \r\n NOTE: because of optimizations lambda _might_ be placed in a frame higher\r\n       than its lexical scope and thus make a jump technically legal.\r\n       However, we explicitly do not consider frame optimizations in this analysis.\r\n ":"\r\n 一旦我们看到Lambda举起东西\r\n 我们将所有范围标记为从电流到声明符号为\r\n 包含举重兰伯达。\r\n 这是需要的，以便我们可以拒绝可能跳过框架分配的跳跃。\r\n \r\n 注意：由于优化，lambda _ -might_放在更高的框架中\r\n       比其词汇范围，因此在技术上合法。\r\n       但是，我们明确不考虑此分析中的框架优化。\r\n \r\n"," type supports retrieving the Me parameter\r\n and false otherwise.  Note that a return value of true does not guarantee a non-Nothing\r\n ":" 类型支持检索ME参数\r\n 否则为错误。请注意，真实的回报值不能保证\r\n \r\n","After an open curly brace ({) or before a closing curly brace (}).":"开放卷曲支撑（{）或闭合卷括号（}）之后。\r\n","\r\n Represents the \"Else ...\" clause of a single-line \"If\" statement.\r\n ":"\r\n 表示单行的“ else ...”条款“如果”语句。\r\n \r\n","\r\n  Looks up a localized string similar to Attributes cannot be applied to parameters of lambda expressions..\r\n":"\r\n  查找类似于属性的本地化字符串不能应用于lambda表达式的参数。\r\n\r\n","\r\n            Returns true if the namespace declaration contains one or more partial types with multiple declarations.\r\n            ":"\r\n            如果命名空间声明包含一个或多个具有多个声明的部分类型，则返回true。\r\n            \r\n","\r\n            Requires Microsoft.DiaSymReader.Native.{platform}.dll to be available for reading Windows PDB.\r\n            ":"\r\n            需要microsoft.diasymreader.native。{platform} .dll可用于读取Windows PDB。\r\n            \r\n","A cache to use for repeated lookups. This should be created with ":"用于重复查找的缓存。这应该用\r\n",".  For now, we'll only\r\n            support implicit caching for VS Workspaces (":"。现在，我们只会\r\n            支持与工作区的隐式缓存（\r\n","\r\n Represents a conditional expression, If(condition, true-expr, false-expr) or\r\n If(expr, nothing-expr).\r\n ":"\r\n 表示条件表达式，如果（条件，true-expr，false-expr）或\r\n if（expr，没有任何内容）。\r\n \r\n","Pull members up to base type...":"将成员拉到基本类型...\r\n","\r\n            Implements SignatureHelp and ParameterInfo for ":"\r\n            实现signatureHelp和parameterInfo\r\n","Remove separators":"卸下分离器\r\n","Place to put diagnostics. If no reasonable type was found, an undefined type\r\n diagnostic is placed in here. Other diagnostics (both related to the type being bound, or\r\n type arguments thereof) can be placed here also. ":"放置诊断的地方。如果找不到合理的类型，则不确定类型\r\n 诊断放在这里。其他诊断（既与所约束类型有关，或\r\n 类型参数也可以在此处放置。\r\n","\r\n Handles SomeWithEventsVariable.Event1\r\n ":"\r\n 处理某些WwithEventsVariable.event1\r\n \r\n","\r\n Represents an Option statement, such as \"Option Strict On\".\r\n ":"\r\n 代表选项说明，例如“ contion on Cortion on Prication on on on prince of to”。\r\n \r\n","The character position for determining the enclosing declaration\r\n scope and accessibility.":"用于确定封闭声明的字符位置\r\n 范围和可访问性。\r\n","\r\n  Looks up a localized string similar to '{0}' is a class type and cannot be used as an expression..\r\n":"\r\n  查找类似于“ {0}”的本地化字符串是类型，不能用作表达式。\r\n\r\n"," is mapped.\r\n            ":"被映射。\r\n            \r\n"," if available. \r\n Since the compiler does only need to know the marshalling type of symbols that aren't emitted \r\n PE symbols just decode the type from metadata and don't provide full marshalling information.\r\n ":" 如果可供使用的话。\r\n 由于编译器确实只需要知道没有发出的符号的编组类型\r\n PE符号只是从元数据中解码类型，并且不提供完整的编组信息。\r\n \r\n"," this bucket is associated with, or ":" 这个水桶与或\r\n","Convert to method":"转换为方法\r\n","An expression to classify. This expression does not need to be\r\n present in the syntax tree associated with this object.":"表达式进行分类。这个表达不需要\r\n 存在与此对象关联的语法树中。\r\n","\r\n The value for the InterfaceKeyword property.\r\n ":"\r\n InterfaceKeyWord属性的值。\r\n \r\n","\r\n The closure only contains a reference to the containing class instance (\"Me\").\r\n We don't emit a display class, lambdas are emitted directly to the containing class as its instance methods.\r\n ":"\r\n 闭合仅包含对包含类实例的引用（“我”）。\r\n 我们不发出显示类别，lambdas直接发射到包含类的实例方法上。\r\n \r\n","Top-level statements must precede namespace and type declarations.":"顶级语句必须先于名称空间和键入声明。\r\n","\r\n This class represents a type symbol for compiler generated implementation methods,\r\n the method being implemented is passed as a parameter and is used to build\r\n implementation method's parameters, return value type, etc...\r\n ":"\r\n 该类代表编译器生成的实现方法的类型符号，\r\n 正在实施的方法作为参数传递，用于构建\r\n 实现方法的参数，返回值类型等...\r\n \r\n","\r\n Determines if the method can be called with empty parameter list.\r\n ":"\r\n 确定该方法是否可以使用空参数列表调用。\r\n \r\n","Matches a form-feed character, \\u000C":"匹配形式喂养字符\\ u000c\r\n","\r\n  Looks up a localized string similar to End of statement expected..\r\n":"\r\n  查找类似于预期语句的局部字符串。\r\n\r\n"," is accessible from within the assembly ":" 可以从组件内访问\r\n","\r\n Return keyword or punctuation text based on SyntaxKind\r\n ":"\r\n 返回基于语法的关键字或标点文字\r\n \r\n","\r\n The class to represent all events imported from a PE/module.\r\n ":"\r\n 代表从PE/模块导入的所有事件的类。\r\n \r\n","The rules that declare how this item should behave.":"声明该项目应如何行事的规则。\r\n","extension":"扩大\r\n","\r\n            Fixed size rolling tracing log. \r\n            ":"\r\n            固定尺寸滚动跟踪日志。\r\n            \r\n","\r\n Return the set of types that should be checked for presence of extension methods in order to build\r\n a map of extension methods for the namespace. \r\n ":"\r\n 返回应检查应检查的一组类型，以构建扩展方法\r\n 名称空间的扩展方法图。\r\n \r\n","\r\n The value for the CommaToken property.\r\n ":"\r\n 致命属性的价值。\r\n \r\n","\r\n Returns a copy of this with the QuestionGreaterThanToken property changed to\r\n the specified value. Returns this instance if the specified value is the same\r\n as the current value.\r\n ":"\r\n 返回其中的副本，并将其更改为\r\n 指定值。如果指定的值相同，则返回此实例\r\n 作为当前值。\r\n \r\n","if (expr) statement":"if（expr）语句\r\n","\r\n Creates the syntax representation of an xml newline token with a documentation comment exterior trivia at \r\n the end (continued documentation comment).\r\n ":"\r\n 使用文档注释外部琐事创建XML Newline令牌的语法表示形式\r\n 结束（持续文档评论）。\r\n \r\n","\r\n Gets current reusable syntax node.\r\n If node is returned its start will be aligned with the start of current token. \r\n NOTE: Line offset may not match start of current token because of lookahead. \r\n ":"\r\n 获取当前可重复使用的语法节点。\r\n 如果返回节点，则其开始将与当前令牌的开始对齐。\r\n 注意：由于LookAhead，线路偏移可能与当前令牌的启动不符。\r\n \r\n","\r\n A BoundForLoopStatement node has a list of control variables (from the attached next statement).\r\n When binding the control variable of a for/for each loop that is nested in another for/for each loop, it must be\r\n checked that the control variable has not been used by a containing for/for each loop. Because bound nodes do not\r\n know their parents and we try to avoid passing around a stack of variables, we just walk the bound tree after the\r\n initial binding to report this error.\r\n In addition, it must be checked that the control variables of the next statement match the loop. Because the inner \r\n most loop contains the next with control variables from outer binders, checking this here is also convenient.\r\n\r\n There are two diagnostics reported by this walker:\r\n 1. BC30069: For loop control variable '{0}' already in use by an enclosing For loop.\r\n 2. BC30070: Next control variable does not match For loop control variable '{0}'.\r\n ":"\r\n boundforloopstatement节点具有控制变量的列表（来自附件的下一个语句）。\r\n 在每个循环中嵌套在另一个循环中的每个循环的a的控制变量时，必须为\r\n 检查控制变量尚未由每个循环的包含/包含。因为绑定节点没有\r\n 认识他们的父母，我们试图避免在一堆变量中传递，我们只是在绑扎的树上走了\r\n 初始绑定以报告此错误。\r\n 此外，必须检查下一个语句的控制变量与循环匹配。因为内在\r\n 大多数循环都包含下一个带有外部粘合剂的控制变量的循环，此处检查此方面也很方便。\r\n\r\n 这个沃克有两种诊断：\r\n 1. BC30069：对于循环控制变量'{0}'已经通过封闭式循环使用。\r\n 2. BC30070：下一个控制变量与循环控制变量'{0}'不匹配。\r\n \r\n","extension GetAsyncEnumerator":"扩展getAsyncenumerator\r\n","\r\n  Looks up a localized string similar to 'Exit Operator' is not valid. Use 'Return' to exit an operator..\r\n":"\r\n  查找类似于“退出操作员”的本地化字符串是无效的。使用“返回”退出操作员。\r\n\r\n","\r\n Check to see if the given ":"\r\n 检查是否给定\r\n","Generate enum member '{1}.{0}'":"生成枚举成员'{1}。{0}'\r\n","\r\n Checks if expression represents directly or indirectly a value with its own home.\r\n In such cases it is possible to get a reference without loading into a temporary.\r\n \r\n This is a CLR concept which is weaker than VB's IsLValue.\r\n For example all locals are homed even if VB may consider some locals read-only.\r\n ":"\r\n 检查表达式是否直接或间接表示具有自己房屋的值。\r\n 在这种情况下，可以在不加载临时的情况下获得参考。\r\n \r\n 这是一个CLR概念，比VB的Islvalue弱。\r\n 例如，即使VB可能会考虑一些当地人，所有当地人都将被归属。\r\n \r\n","\r\n            if a nested type is being moved, this ensures its containing type is partial.\r\n            ":"\r\n            如果移动嵌套类型，则确保其包含类型是部分的。\r\n            \r\n","The attribute target flag for this symbol or 0 if none apply.":"此符号的属性目标标志或0如果不应用。\r\n","\r\n Gets a ":"\r\n 得到一个\r\n","\r\n            Contains syntax maps for all changed data member initializers or constructor declarations (of constructors emitting initializers)\r\n            in the currently analyzed document. The key is the declaration of the member.\r\n            ":"\r\n            包含所有更改的数据成员初始化器或构造函数声明的语法图（发射初始化器的构造函数）\r\n            在当前分析的文档中。关键是成员的声明。\r\n            \r\n","\r\n  A strongly-typed resource class, for looking up localized strings, etc.\r\n":"\r\n  一个强大的资源类，用于查找本地化的字符串等。\r\n\r\n","in Source (attribute)":"在源（属性）中\r\n","\r\n The type the expression is being cast to.\r\n ":"\r\n 表达式被施放到的类型。\r\n \r\n","\r\n Represents a \"Do ... Loop\" block.\r\n ":"\r\n 表示一个“做...循环”块。\r\n \r\n","\r\n            The set of well known intents that Roslyn can calculate edits for.\r\n            ":"\r\n            罗斯林可以计算的一组知名意图。\r\n            \r\n","Add missing cases":"添加缺失的案例\r\n"," with given ":" 给定\r\n","\r\n Helper class to generate synthesized names.\r\n ":"\r\n 助手类生成合成的名称。\r\n \r\n","DecodeParameterListOfDelegateDeclaration":"解解式列出元素\r\n","\r\n             if (a == null) {\r\n               throw SomeException();\r\n             }\r\n            \r\n             x = a;\r\n             ":"\r\n             如果（a == null）{\r\n               抛出一些exception（）;\r\n             }\r\n            \r\n             x = a;\r\n             \r\n","\r\n Returns True if this conversion is a narrowing boolean conversion, as defined in section 8.2.\r\n ":"\r\n 如果这种转换是第8.2节中定义的缩小布尔转换，则返回为true。\r\n \r\n","\r\n Creates a binder for a binding global imports in a source file. This includes the following binders:\r\n    BackstopBinder\r\n    SourceModuleBinder\r\n    SourceFileBinder\r\n    NamespaceBinder (for the global namespace)\r\n    IgnoreBaseClassesBinder (so that base classes are ignore during binding)\r\n ":"\r\n 为源文件中的绑定全局导入创建活页夹。这包括以下粘合剂：\r\n    后脚手\r\n    Sourcemodulebinder\r\n    SourceFileBinder\r\n    名称空间Binder（用于全局名称空间）\r\n    忽略baseclassesbinder（以便在绑定期间忽略基类）\r\n \r\n","\r\n Checks use site error and returns True in case it should be reported for the alias. \r\n In current implementation checks for errors #36924 and #36925\r\n ":"\r\n 检查使用站点错误并返回为True，以防该别名报告。\r\n 在当前的实施检查中，错误＃36924和＃36925\r\n \r\n","\r\n Accept a CR/LF pair or either in isolation as a newline.\r\n Make it a whitespace\r\n ":"\r\n 接受CR/LF对，或孤立地接受新线。\r\n 使它成为空格\r\n \r\n","\r\n            Looks for code of the forms:\r\n            \r\n                var x = o as Type;\r\n                if (x != null) ...\r\n            \r\n            and converts it to:\r\n            \r\n                if (o is Type x) ...\r\n                \r\n            ":"\r\n            寻找表格代码：\r\n            \r\n                var x = o作为类型;\r\n                如果（x！= null）...\r\n            \r\n            并将其转换为：\r\n            \r\n                如果（o是X型）...\r\n                \r\n            \r\n","\r\n The \"I\" literal suffix denoting \"Integer\"\r\n ":"\r\n “我”字面的后缀表示“整数”\r\n \r\n","The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.":"应用于参数'{0}'的CallerArgumentExpresseptresseptresseattribute将无效。它被CallerlineNumberattribute覆盖。\r\n","\r\n Creates the syntax representation of an example element within xml documentation comments.\r\n ":"\r\n 在XML文档注释中创建示例元素的语法表示。\r\n \r\n","\r\n  Looks up a localized string similar to An Object Initializer and a Collection Initializer cannot be combined in the same initialization..\r\n":"\r\n  查找类似于对象初始化器的本地化字符串，并且不能以相同的初始化结合集合初始化器。\r\n\r\n","\r\n            so that the default severity of all diagnostics is configured to be the given\r\n            ":"\r\n            因此，将所有诊断的默认严重程度配置为给定\r\n            \r\n","However, you must include a line-continuation character (_) when you specify a member qualifier when you are using the With keyword.":"但是，当您使用with with关键字时，指定成员预选赛时，必须包括线路接头字符（_）。\r\n","Remove blank line between braces":"卸下括号之间的空白线\r\n","\r\n Returns a copy of this with the CatchBlocks property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而Catchblocks属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","&method group":"和方法组\r\n","\r\n The token that represents the literal. The Kind property determines what type\r\n this property returns: Kind=IntegerLiteral ==> Returns IntegerLiteralToken.\r\n Kind=CharacterLiteral ==> Returns CharacterLiteralToken. Kind=DecimalLiteral\r\n ==> Returns DecimalLiteralToken Kind=FloatingLiteral ==> Returns\r\n FloatingLiteralToken Kind=DateLiteral ==> Returns DateLiteralToken\r\n Kind=StringLiteral ==> Returns StringLiteralToken Kind=BooleanLiteral ==>\r\n Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)\r\n Kind=NothingLiteral ==> Returns Keyword (with it's kind being\r\n NothingKeyword)\r\n ":"\r\n 代表字面意义的代币。该属性确定哪种类型\r\n 此属性返回：kint = integerliteral ==>返回integerliteraltoken。\r\n kint = targinliteral ==>返回tarneLiteralToken。 KIND =十分额\r\n ==>返回分数数= floatingLiteral ==>返回\r\n floatingLiteralToken kint = dateliteral ==>返回dateLiterAltoken\r\n kint = stringliteral ==>返回stringliteraltoken kint = booleanliteral ==>\r\n 返回关键字（以truekeyword或falsekeyword为单位）\r\n bink = nothertliteral ==>返回关键字（与之相关的是\r\n Nothing Keyword）\r\n \r\n","Pass in captured variables as arguments":"传递捕获的变量作为参数\r\n","\r\n            Ordered in the order we want to display operators in the completion list.\r\n            ":"\r\n            按顺序订购，我们要在完成列表中显示操作员。\r\n            \r\n","\r\n Represents text in a false preprocessor block\r\n ":"\r\n 在错误的预处理器块中代表文本\r\n \r\n","\r\n Generate return statements from the state machine method body.\r\n ":"\r\n 从状态机方法主体中生成返回语句。\r\n \r\n",". That type owns it's binders\r\n and that type's lifetime is that of the compilation. Therefore we do not store\r\n binders local to method bodies in that type's cache. \r\n ":"。该类型拥有它的粘合剂\r\n 而这种类型的寿命就是汇编。因此我们不存储\r\n 该类型的缓存中的方法物体本地的BINDERS。\r\n \r\n","\r\n Returns a copy of this with the IfStatement property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中IfStatement属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Creates a separated list from a ":"\r\n 从一个分离的列表中创建\r\n","\r\n            If the specified node represents a member declaration returns all tokens of the member declaration\r\n            that might be covered by an active statement.\r\n            ":"\r\n            如果指定的节点代表成员声明返回会员声明的所有令牌\r\n            这可能会被主动声明所涵盖。\r\n            \r\n","s of all the visible documents in the workspace.\r\n            ":"工作空间中所有可见文档的s。\r\n            \r\n","\r\n The value for the Right property.\r\n ":"正确属性的值。\r\n \r\n","An expression which must occur within the syntax tree\r\n associated with this object.":"语法树中必须发生的表达式\r\n 与此对象关联。\r\n","\r\n How many Cor types have we cached so far.\r\n ":"\r\n 到目前为止，我们已经缓存了多少种COR类型。\r\n \r\n","\r\n  Looks up a localized string similar to 'Sub New' cannot implement interface members..\r\n":"\r\n  查找类似于“ sub new”的本地化字符串无法实现接口成员。\r\n\r\n","\r\n Returns a copy of this with the NextStatement property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，下一步属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Fetches the documentation comment for this element with a cancellation token.\r\n ":"\r\n 通过取消令牌获取此元素的文档评论。\r\n \r\n","\r\n This is a layer on top of the assembly version that generates a diagnostic if the well-known\r\n member isn't found.\r\n ":"\r\n 这是汇编版本顶部的一层，如果众所周知\r\n 找不到会员。\r\n \r\n","Solution that represents sources that match the built binaries on disk.":"代表与磁盘上建造二进制文件相匹配的源的解决方案。\r\n","Pull member(s) up to new base class...":"将成员拉到新的基类...\r\n","\r\n            Create a diagnostic for exception thrown by the given analyzer.\r\n            ":"\r\n            为给定的分析仪创建一个例外诊断。\r\n            \r\n","\r\n            Creates a copy of this ":"\r\n            创建一个副本\r\n","\r\n            Returns a list of all await expressions, await foreach statements, await using declarations and yield statements in the given body,\r\n            in the order in which they occur.\r\n            ":"\r\n            返回所有等待表达式的列表，等待着语句，使用给定机构中的声明和收益声明等待\r\n            按照它们发生的顺序。\r\n            \r\n","If set to true a new missing identifier will be created and added to the incomplete member.":"如果设置为True，将创建新的缺失标识符并将其添加到不完整的成员中。\r\n","\r\n            Creates a query expression or a linq invocation expression.\r\n            ":"\r\n            创建查询表达式或LINQ调用表达式。\r\n            \r\n","\r\n  Looks up a localized string similar to Type constraint '{0}' must be either a class, interface or type parameter..\r\n":"\r\n  查找类似于类型约束'{0}'的本地化字符串必须是类，接口或类型参数。\r\n\r\n","Invalid scope for 'SuppressMessageAttribute'":"无效的“抑制范围”范围\r\n","A list of the following trivia.":"以下琐事列表。\r\n","True if it is a predefined type OR Variant keyword":"如果是预定义的类型或变体关键字，则为true\r\n","\r\n Sets substitution used by the rewriter for a placeholder node.\r\n Each occurrence of the placeholder node is replaced with the node returned.\r\n Throws if there is already a substitution.\r\n ":"\r\n 将重写器使用的替代设置用于占位符节点。\r\n 占位符节点的每个出现都被返回的节点替换。\r\n 如果已经有替代，则投掷。\r\n \r\n","\r\n Rewrites lambda body into a body of a method.\r\n ":"\r\n 将Lambda身体重写为一种方法。\r\n \r\n","\r\n  Looks up a localized string similar to Type parameters cannot be specified on this declaration..\r\n":"\r\n  在此声明中查找类似于类型参数的本地化字符串。\r\n\r\n","\r\n  Looks up a localized string similar to This expression does not have a name..\r\n":"\r\n  查找类似于此表达式的本地化字符串没有名称。\r\n\r\n","\r\n  Looks up a localized string similar to Multiple assemblies with equivalent identity have been imported: '{0}' and '{1}'. Remove one of the duplicate references..\r\n":"\r\n  已经导入了类似于具有等效身份的多个汇编的本地化字符串：'{0}'和'{1}'。删除重复引用之一。\r\n\r\n","\r\n Represents the Else part of a If...End If block (or line If). This statement is\r\n always the Begin of a ElsePart.\r\n ":"\r\n 表示if ...结束的其他部分，如果块（或行if）。这个说法是\r\n 始终是Elsepart的开始。\r\n \r\n","\r\n Scan VB tokens but consume multiline trivia before token. Done at the start of a new statement except after line if.\r\n ":"\r\n 扫描VB令牌，但在代币之前消耗多行琐事。在新语句的开头完成，除了一行。\r\n \r\n"," is empty), there must be no namespace declaration\r\n               inside (i.e. all members are declared in global namespace)\r\n             ":" 是空的），必须没有名称空间声明\r\n               内部（即所有成员都在全球名称空间中声明）\r\n             \r\n","\r\n Creates a singleton list of trivia.\r\n ":"\r\n 创建一个琐事的单身清单。\r\n \r\n","\r\n Implementation of IEqualityComparer for MethodSymbols, with options for various aspects\r\n to compare.\r\n ":"\r\n 实施方法符号符号，并具有各个方面的选项\r\n 比较。\r\n \r\n","\r\n            helper type to package diagnostic arguments to pass around between remote hosts\r\n            ":"助手类型到包装诊断论点，以在远程主机之间传递\r\n            \r\n","\r\n  Looks up a localized string similar to Property accessors cannot be declared '{0}' in a 'Default' property..\r\n":"\r\n  在“默认”属性中查找类似于属性访问者的本地化字符串。\r\n\r\n","\r\n The value for the File property.\r\n ":"\r\n 文件属性的值。\r\n \r\n","Partial method declarations have signature differences.":"部分方法声明具有签名差异。\r\n","\r\n            his is intended for symbols that are ordinary symbols in the language sense, and may be\r\n            used by code, but that are simply declared implicitly rather than with explicit language\r\n            syntax.  For example, a default synthesized constructor in C# when the class contains no\r\n            explicit constructors.\r\n            ":"\r\n            他的旨在在语言意义上是普通符号的符号，可能是\r\n            代码使用，但仅仅是隐式声明而不是用明确的语言声明\r\n            句法。例如，当类包含否时，C＃中的默认合成构造函数\r\n            显式构造函数。\r\n            \r\n","A boolean value set to True if character is a colon character.":"如果字符是结肠字符，则将布尔值设置为真。\r\n","\r\n            A temporarily hack that should be removed once/if https://github.com/dotnet/roslyn/issues/53092 is fixed.\r\n            ":"\r\n            如果https://github.com/dotnet/roslyn/issues/53092已固定，则应删除一次/如果要删除一次。\r\n            \r\n"," Creates a token with kind IntegerLiteralToken from a 4-byte signed integer value. ":" 从4个字节签名的整数值中创建具有元素integerliteraltoken的令牌。\r\n","\r\n Called to report attribute related diagnostics after all attributes have been bound and decoded.\r\n Called even if there are no attributes.\r\n ":"\r\n 在所有属性都被绑定和解码后，要求报告属性相关的诊断。\r\n 即使没有属性也称为。\r\n \r\n","Conditional expression is not valid in language version {0} because a common type was not found between '{1}' and '{2}'. To use a target-typed conversion, upgrade to language version {3} or greater.":"条件表达式在语言版本{0}中无效，因为在'{1}'和'{2}'之间找不到公共类型。要使用目标型转换，请升级到语言版本{3}或更大。\r\n","\r\n Returns a copy of this with the OptionKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中optionKeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n The \"Then\" keyword.\r\n ":"\r\n “然后”关键字。\r\n \r\n","\r\n            When querying the syntax, C# else if chains are \"flattened\" and modeled to look like VB else-if clauses,\r\n            so an \"ifOrElseIf\" can be followed a sequence of else-if clauses and an optional final else clause.\r\n            These else-if clauses are treated as independent when removing or inserting.\r\n            ":"\r\n            查询语法时，C＃else如果链被“平坦”并模拟为vb else-if子句，\r\n            因此，可以遵循“ iForelSeif”序列，以else-if子句和一个可选的最终子句。\r\n            这些其他条款在删除或插入时被视为独立。\r\n            \r\n","\r\n True if NotSerialized metadata flag is set for this symbol.\r\n ":"\r\n 为此符号设置了不正确的元数据标志。\r\n \r\n","\r\n True, if the method kind was determined by examining a syntax node (i.e. for source methods -\r\n including substituted and retargeted ones); false, otherwise.\r\n ":"\r\n 是的，如果方法是通过检查语法节点来确定的（即用于源方法 - \r\n 包括替换和重新定位的）；错误，否则。\r\n \r\n"," Checks for validity of Construct(...) on this method with these type arguments. ":" 使用这些类型参数检查该方法的构建体有效性（...）。\r\n"," \r\n Method to early decode certain well-known attributes which can be queried by the binder. \r\n This method is called during attribute binding after we have bound the attribute types for all attributes, \r\n but haven't yet bound the attribute arguments/attribute constructor. \r\n Early decoding certain well-known attributes enables the binder to use this decoded information on this symbol \r\n when binding the attribute arguments/attribute constructor without causing attribute binding cycle. \r\n ":" \r\n 早期解码某些已知属性的方法可以由粘合剂查询。\r\n 在我们绑定所有属性的属性类型之后，在属性绑定期间调用此方法\r\n 但是尚未绑定属性参数/属性构造函数。\r\n 早期解码某些众所周知的属性使粘合剂能够在此符号上使用此解码信息\r\n 当绑定属性参数/属性构造函数时，而不会引起属性结合周期。\r\n \r\n","The ^ anchor specifies that the following pattern must begin at the first character position of the string. If you use ^ with the RegexOptions.Multiline option, the match must occur at the beginning of each line.":"^锚指定以下模式必须从字符串的第一个字符位置开始。如果您将 ^与regexoptions.multiline选项一起使用，则该匹配项必须在每行的开头发生。\r\n","\r\n Map containing information about all conditional symbol definitions in the source file corresponding to a parsed syntax tree.\r\n ":"\r\n 映射包含有关对应于解析语法树的源文件中所有条件符号定义的信息。\r\n \r\n"," so that the engine can cache data from ":" 使引擎可以从中缓存数据\r\n","\r\n  Looks up a localized string similar to Length of String constant exceeds current memory limit.  Try splitting the string into multiple constants..\r\n":"\r\n  查找类似于字符串常数长度的本地化字符串超过当前内存限制。尝试将字符串分为多个常数。\r\n\r\n","\r\n An expression to order by, plus an optional ordering. The Kind indicates\r\n whether to order in ascending or descending order.\r\n ":"\r\n 通过订购的表达式，以及可选的排序。那种指示\r\n 是按上升订单还是下降订单。\r\n \r\n","\r\n Holds onto data related to reference binding.\r\n The manager is shared among multiple compilations that we expect to have the same result of reference binding.\r\n In most cases this can be determined without performing the binding. If the compilation however contains a circular \r\n metadata reference (a metadata reference that refers back to the compilation) we need to avoid sharing of the binding results.\r\n We do so by creating a new reference manager for such compilation. \r\n ":"\r\n 保留与参考绑定有关的数据。\r\n 经理在多个汇编中共享，我们期望具有参考绑定的结果相同。\r\n 在大多数情况下，这可以在不执行结合的情况下确定。但是，如果汇编包含一个圆形\r\n 元数据参考（元数据引用回编译），我们需要避免共享结合结果。\r\n 我们通过为这种编译创建新的参考经理来做到这一点。\r\n \r\n","\r\n The value for the ErrorNumber property.\r\n ":"\r\n ErrorNumber属性的值。\r\n \r\n","\r\n True if this module has any unified references.\r\n ":"\r\n 如果该模块具有任何统一的参考，则为thus。\r\n \r\n","\r\n Determines if two syntax nodes are the same, disregarding trivia differences.\r\n ":"\r\n 确定两个语法节点是否相同，无视琐事差异。\r\n \r\n","\r\n Represents either a namespace or a type.\r\n ":"\r\n 代表名称空间或类型。\r\n \r\n","Convert to 'foreach'":"转换为“ foreach”\r\n","\r\n The expression used as the initial value.\r\n ":"\r\n 该表达式用作初始值。\r\n \r\n"," form.  This doesn't matter for the first chunk as\r\n            we won't be wrapping that one.\r\n            ":" 形式。对于第一个大块来说，这无关紧要\r\n            我们不会包裹那个。\r\n            \r\n","\r\n The expression being tested.\r\n ":"\r\n 表达式正在测试。\r\n \r\n","\r\n The \"Case\" keyword\r\n ":"“案例”关键字\r\n \r\n","\r\n The value for the StepClause property.\r\n ":"\r\n Stepclause属性的值。\r\n \r\n","\r\n Returns a new compilation with a given event queue.\r\n ":"\r\n 返回给定事件队列的新汇编。\r\n \r\n","s.\r\n            \r\n            Once we get any wrapping actions, we stop looking further.  This keeps the refactorings\r\n            scoped as closely as possible to where the user is, as well as preventing overloading of the\r\n            lightbulb with too many actions.\r\n            ":"s。\r\n            \r\n            一旦我们采取任何包装措施，我们就会停止进一步寻找。这保持了重构\r\n            尽可能接近用户的位置，并防止过载\r\n            灯泡有太多动作。\r\n            \r\n","\r\n            Indicate whether this member's declaration in destination needs to be made to abstract. It is only used by the dialog UI.\r\n            If this property is true, then pull a member up to a class will only generate a abstract declaration in the destination.\r\n            It will always be false if the refactoring is triggered from Quick Action.\r\n            ":"\r\n            指出该成员在目的地中是否需要抽象的声明。它仅由对话UI使用。\r\n            如果此属性是正确的，则将成员拉到一类只会在目标中生成抽象声明。\r\n            如果重构是由快速动作触发的，它将始终是错误的。\r\n            \r\n","\r\n            Gets options and produces a ":"\r\n            获取选项并产生\r\n","Capture number cannot be zero":"捕获号码不能为零\r\n","\r\n            See comment in ":"\r\n            请参阅评论\r\n","\r\n            ```(?'name'expr)``` or ```(?<name>expr)``` node.\r\n            ":"\r\n            ``（？'name'expr）````或``（？<name> expr）``node。\r\n            \r\n","\r\n This function checks if the given expression is a constant from a language point of view and returns \r\n constant value if it is. This is different from the fact that the bound node has a constant value. \r\n This method also adds the required diagnostics for non const values.\r\n ":"\r\n 此函数检查给定表达是否是从语言角度来看的常数并返回\r\n 恒定值如果是。这与结合节点具有恒定值的事实不同。\r\n 此方法还为非const值添加了所需的诊断。\r\n \r\n","\r\n Scan tokens inside of </ ...>\r\n ":"\r\n </ ...>的扫描令牌\r\n \r\n","\r\n Proximity level of a reduced extension method.\r\n ":"\r\n 减少扩展方法的接近度。\r\n \r\n","(T)x":"（t）x\r\n","\r\n            Checks if the conversion might change the resultant boxed type.\r\n            Similar boxing checks are performed elsewhere, but in this case we need to perform the check on the entire conditional expression.\r\n            This will make sure the resultant cast is proper for the type of the conditional expression.\r\n            ":"\r\n            检查转换是否可能更改结果盒装类型。\r\n            类似的拳击检查是在其他地方执行的，但是在这种情况下，我们需要对整个条件表达式进行检查。\r\n            这将确保最终的铸件适合条件表达式的类型。\r\n            \r\n","\r\n Given a list of keywords and an set of keywords kinds to search, return the first keyword\r\n in the list, if any, that matches one of the keyword kinds.\r\n ":"\r\n 给定关键字列表和一组要搜索的关键字类型，返回第一个关键字\r\n 在列表中（如果有的话），与关键字类型之一匹配。\r\n \r\n","\r\n  Looks up a localized string similar to Cannot infer a return type because more than one type is possible. Consider adding an 'As' clause to specify the return type..\r\n":"\r\n  查找类似于不能推断返回类型的本地化字符串，因为可以多种类型。考虑添加一个“ AS”子句以指定返回类型。\r\n\r\n","'{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support default interface implementation.":"'{0}'无法在类型'{2}'中实现接口成员'{1}'，因为目标运行时不支持默认接口实现。\r\n","\r\n Get a reference to the given node.\r\n ":"获取对给定节点的引用。\r\n \r\n"," can be replaced by its framework type in code.\r\n            ":" 可以用代码中的框架类型代替。\r\n            \r\n","Implement interface explicitly with Dispose pattern":"用处置模式明确实施接口\r\n","Init-only property or indexer '{0}' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.":"只能在对象初始化器中分配Init-lyly属性或索引器'{0}'，或在实例构造函数或“ Init”登录中的“ this”或“基础”上分配。\r\n","\r\n Returns a copy of this with the FirstCommaToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本的副本，第一个通用属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Guess the non-error type that the given type was intended to represent, or return\r\n the type itself. If a single, non-ambiguous type is a guess-type inside the type symbol, \r\n return that; otherwise return the type itself (even if it is an error type).\r\n ":"\r\n 猜测给定类型旨在表示或返回的非错误类型\r\n 类型本身。如果单一的，非歧义类型是类型符号内的猜测类型，\r\n 返回；否则返回类型本身（即使是错误类型）。\r\n \r\n","The positional member '{0}' found corresponding to this parameter is hidden.":"与该参数相对应的位置成员'{0}'隐藏。\r\n","\r\n            SearchScope used for searching *all* the symbols contained within a project/compilation.\r\n            i.e. the symbols created from source *and* symbols from references (both project and\r\n            metadata).\r\n            ":"\r\n            用于搜索 * all *项目/汇编中包含的符号。\r\n            即，从源 *和 *符号中创建的符号（既包括项目和\r\n            元数据）。\r\n            \r\n","\r\n The base class for all nodes in the VB syntax tree.\r\n ":"\r\n VB语法树中所有节点的基类。\r\n \r\n","\r\n Binder used for interiors of documentation comment for binding 'name' attribute \r\n value of 'param' and 'paramref' documentation comment tags\r\n ":"\r\n 用于绑定“名称”属性的文档注释内部的活页夹\r\n “ param”和“ paramref”文档评论标签的值\r\n \r\n","\r\n  This method is to be called to assign implementation to a partial method.\r\n  ":"\r\n  该方法应被调用以将实现分配给部分方法。\r\n  \r\n","Convert to hex":"转换为十六进制\r\n","\r\n Returns an unbound generic type of this generic named type.\r\n ":"\r\n 返回此通用命名类型的无限通用类型。\r\n \r\n","\r\n Returns the statement if there is exactly one in the body,\r\n otherwise returns Nothing.\r\n ":"如果身体正好有一个，则返回该陈述，\r\n 否则什么都不会返回。\r\n \r\n","noncapturing group":"非捕捉组\r\n","expr ??= value":"expr ?? =值\r\n","\r\n Represents a property.\r\n ":"\r\n 代表属性。\r\n \r\n","\r\n            Flag indicating if the analyzer telemety info, such as registered analyzer action counts\r\n            and analyzer execution times, should be included in the computed result.\r\n            ":"\r\n            标志指示分析仪是否远程信息信息，例如注册分析仪的动作计数\r\n            分析仪的执行时间应包括在计算结果中。\r\n            \r\n","\r\n Symbol for the ConstructedFrom method.\r\n      A(Of Integer).B(Of ) for A(Of Integer).B(Of Integer),\r\n      A(Of Integer).B.C(Of ) for A(Of Integer).B.C(Of Integer)\r\n \r\n All types in its containership hierarchy must be either constructed or non-generic, or original definitions.\r\n ":"\r\n 构造方法的符号。\r\n      a（integer）.b（of）f for A（Integer）.b（of Integer），\r\n      a（integer）的（of）a（integer）.b.c（of Integer）（of Integer）\r\n \r\n 其集装箱层次结构中的所有类型都必须构建或非代理或原始定义。\r\n \r\n","Sought value":"寻求价值\r\n","\r\n Represents a compiler generated field of given type and name.\r\n ":"\r\n 代表给定类型和名称的编译器生成的字段。\r\n \r\n","\r\n Is parameter explicitly declared ByRef. Can be different from IsByRef only for\r\n String parameters of Declare methods.\r\n ":"\r\n 是参数明确声明为byref。只能与Isbyref不同\r\n 声明方法的字符串参数。\r\n \r\n","\r\n Does this describe a ByRef parameter of an Anonymous Delegate type\r\n ":"\r\n 这是否描述了匿名代表类型的BYREF参数\r\n \r\n","\r\n Returns a copy of this with the InterfaceMembers property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 与Interfacembers属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            Get completion items for all the accessible top level types from the given project and all its references. \r\n            Each array returned contains all items from one of the reachable entities (i.e. projects and PE references.)\r\n            Returns null if we don't have all the items cached and ":"\r\n            从给定项目及其所有参考资料中获取所有可访问的顶级类型的完成项目。\r\n            返回的每个数组都包含来自可触及实体之一（即项目和PE参考）的所有项目。\r\n            如果我们没有所有可缓存的物品，则返回null\r\n","The part of the statement following the embedded statement, for example the\r\n            ":"嵌入式语句之后的语句的一部分，例如\r\n            \r\n","\r\n Emit an element store instruction for a single dimensional array.\r\n ":"\r\n 发出单个维数组的元素存储指令。\r\n \r\n","\r\n            All active statements and the corresponding exception regions in changed documents.\r\n            ":"\r\n            所有活动的语句和更改文档中的相应异常区域。\r\n            \r\n","\r\n The optional list of variables being grouped; the contents of the Group clause.\r\n If none were specified, an empty list is returned.\r\n ":"\r\n 分组的变量的可选列表；组子句的内容。\r\n 如果未指定，则返回空列表。\r\n \r\n"," representing the specific kind of DoLoopBlockSyntax.\r\n One of SimpleDoLoopBlock, DoWhileLoopBlock, DoUntilLoopBlock, DoLoopWhileBlock,\r\n DoLoopUntilBlock.\r\n ":" 代表特定类型的doloopblocksyntax。\r\n SimpleDoloopBlock之一，Dowhileloopblock，DounsilloopBlock，DoloophileBlock，\r\n Doloopuntilblock。\r\n \r\n","\r\n  Looks up a localized string similar to 'Option {0}' statement can only appear once per file..\r\n":"\r\n  查找类似于“选项{0}”语句的本地化字符串只能出现一次。\r\n\r\n","Indent wrapped parameters":"缩进包装参数\r\n","'{0}' is attributed with 'UnmanagedCallersOnly' and cannot be converted to a delegate type. Obtain a function pointer to this method.":"'{0}'归因于'UnmanagedCallersolly'，不能转换为委托类型。获取该方法的功能指针。\r\n","delegate generic type constraints":"委托通用类型约束\r\n","\r\n Compares to tree for structural equivalence.\r\n ":"\r\n 与树结构对等的树相比。\r\n \r\n","\r\n Returns a copy of this with the UsingKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，使用usekeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Malformed \\k<...> named back reference":"畸形\\ k <...>命名备用参考\r\n","The replacement node to use in the rewritten syntax tree; otherwise, ":"在重写语法树中使用的替换节点；否则，\r\n","\r\n Parses a command line.\r\n ":"\r\n 解析命令行。\r\n \r\n","\r\n The underlying FieldSymbol, cannot be another RetargetingFieldSymbol.\r\n ":"\r\n 基础野外符号不能是另一个retargetingfieldsymbol。\r\n \r\n","\r\n  Looks up a localized string similar to Only one of 'Public', 'Private', 'Protected', 'Friend', or 'Protected Friend' can be specified..\r\n":"\r\n  可以指定一个类似于“公共”，“私人”，“受保护”，“朋友”或“受保护的朋友”的局部字符串。\r\n\r\n","\r\n Returns a copy of this with the WhileStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回其中的副本，然后将其更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","The node to start traversing up from":"开始从\r\n"," type.  Needed so that we only fixup code if we see the type\r\n            we're using has an indexer that takes a ":" 类型。需要，以便我们仅在看到类型时修复代码\r\n            我们使用的是一个索引器\r\n"," \r\n Field initializer's declaration syntax node. \r\n It can be a EqualsValueSyntax or AsNewClauseSyntax.\r\n ":" \r\n 字段初始化器的声明语法节点。\r\n 它可以是equalsvaluesyntax或asnewclausesyntax。\r\n \r\n","\r\n            Generates formatted source code containing general information about the symbol's\r\n            containing assembly, and the public, protected, and protected-or-internal interface of\r\n            which the given ISymbol is or is a part of into the given document\r\n            ":"\r\n            生成格式的源代码，其中包含有关符号的一般信息\r\n            包含组件以及公众，受保护和受保护或内部接口\r\n            给定的ISYMBOL是给定文档的一部分\r\n            \r\n","Make method async":"使方法异步\r\n","\r\n this is a SyntaxReference implementation that lazily translates the result (SyntaxNode) of the original syntax reference\r\n to other one.\r\n ":"\r\n 这是一种语法雷神实现，懒惰地翻译了原始语法参考的结果（语法）\r\n 给另一个。\r\n \r\n","\r\n Returns a copy of this with the EndStructureStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中端结构属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n The target of the ReDim statement.\r\n ":"\r\n Redim语句的目标。\r\n \r\n","This language element attempts to match one of two patterns depending on whether it has matched a specified capturing group.\r\n            \r\n            'name' is the name (or number) of a capturing group, 'yes' is the expression to match if 'name' (or 'number') has a match, and 'no ...":"此语言元素试图匹配两种模式之一，具体取决于它是否匹配指定的捕获组。\r\n            \r\n            “名称”是捕获组的名称（或数字），如果“名称”（或“数字”）具有匹配，则“是”是匹配的表达式，而'no ...\r\n","\r\n The \"As\" clause that describes the return type, and possibly includes \"New\",\r\n \"With\" or \"From\". If no As clause was present, Nothing is returned.\r\n ":"\r\n 描述返回类型的“ AS”条款，可能包括“新”，\r\n “用”或“来自”。如果没有作为条款，则什么都不会返回。\r\n \r\n","isWinMd is only necessary for set properties, so any MethodKind which is definitely not\r\n a set property can safely set this value to False.":"ISWINMD仅对于设置属性是必需的，因此任何方法都不是\r\n 设置属性可以安全地将此值设置为false。\r\n","\r\n Helpers to check whether the token is a binary operator\r\n ":"\r\n 助手检查令牌是否是二进制操作员\r\n \r\n","\r\n Binder used for field, auto property initializations and parameter default values.\r\n ":"\r\n 粘合剂用于字段，自动属性初始化和参数默认值。\r\n \r\n","\r\n  Looks up a localized string similar to {0} '{1}' cannot inherit from a type parameter..\r\n":"\r\n  查找类似于{0}'{1}'的本地化字符串无法从类型参数继承。\r\n\r\n","\r\n The \"Where\" keyword.\r\n ":"\r\n “位置”关键字。\r\n \r\n","\r\n Represents the beginning statement of a Structure declaration. This node always\r\n appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.\r\n ":"\r\n 代表结构声明的开始陈述。这个节点总是\r\n 出现是带有bink = structuredeclarationblock的类型块的开始。\r\n \r\n",". Instead, we pass this type to the subclass for it\r\n             register with.  We then check if the registration should proceed given the ":"。相反，我们将此类型传递给子类\r\n             注册。然后，我们检查注册是否应给定给定给\r\n","\r\n Is this a function lambda\r\n ":"\r\n 这是函数lambda吗\r\n \r\n","\r\n Returns True if the expression is a property access expression,\r\n either directly or wrapped in an XML member access expression.\r\n ":"\r\n 如果表达式是属性访问表达式，则返回true，\r\n 直接或包裹在XML成员访问表达式中。\r\n \r\n","generic overloads":"通用超载\r\n","\r\n Creates a trivia with kind WhitespaceTrivia containing the specified text. Elastic trivia are used to\r\n denote trivia that was Not produced by parsing source text, And are usually Not preserved during formatting.\r\n ":"\r\n 用包含指定文本的善良的whitespacrivia创建琐事。弹性琐事习惯\r\n 表示未通过解析源文本产生的琐事，通常在格式期间没有保留。\r\n \r\n","\r\n            Maps from a binary expression kind (like AddExpression) to the corresponding assignment\r\n            form (like AddAssignmentExpression).\r\n            ":"\r\n            从二进制表达式类型（例如addexpression）到相应分配的地图\r\n            形式（例如Addassignment Expressive）。\r\n            \r\n","\r\n Containing namespace.\r\n ":"\r\n 包含名称空间。\r\n \r\n","\r\n Returns an array of assembly identities for assemblies referenced by this module.\r\n Items at the same position from ReferencedAssemblies And from ReferencedAssemblySymbols \r\n correspond to each other.\r\n ":"\r\n 返回该模块引用的汇编数组。\r\n 参考杂志和引用Assemblysymbols的同一位置的项目\r\n 彼此对应。\r\n \r\n","\r\n Parses Conditional Compilations Symbols.   Given the string of conditional compilation symbols from the project system, parse them and merge them with an IReadOnlyDictionary\r\n ready to be given to the compilation.\r\n ":"\r\n 解析条件汇编符号。鉴于项目系统中有条件汇编符号，将它们解析并与Ireadonlydictionary合并\r\n 准备给予汇编。\r\n \r\n"," must be non-null for a non-null analysis kind.\r\n            Only supported non-null values are ":" 对于非无效分析类型，必须是无效的。\r\n            只有支持的非零值是\r\n","\r\n            The type of an object whose members can be accessed by the script as global variables.\r\n            ":"\r\n            可以通过脚本作为全局变量访问其成员的对象的类型。\r\n            \r\n","\r\n            Determines a character's membership in a character class (via the\r\n            string representation of the class).\r\n            ":"\r\n            确定角色在角色类中的成员资格（通过\r\n            类的字符串表示）。\r\n            \r\n","Do not use '{0}'. This is reserved for compiler usage.":"请勿使用'{0}'。这是用于编译器使用情况的。\r\n","\r\n The LocalizableErrorArgument class contains members that allows formatting and serialization of error arguments.\r\n Message IDs may refer to strings that need to be localized.   This struct makes an IFormattable wrapper around a MessageID\r\n ":"\r\n 本地化术语类包含允许格式化和序列化错误参数的成员。\r\n 消息ID可能是指需要本地化的字符串。该结构使围绕MeageDID的易于构造包装器\r\n \r\n","\r\n  Looks up a localized string similar to 'End Namespace' must be preceded by a matching 'Namespace'..\r\n":"\r\n  查找类似于“端命名空间”的本地化字符串必须先于匹配的“名称空间”。\r\n\r\n","\r\n  Looks up a localized string similar to 'Me' cannot be the target of an assignment..\r\n":"\r\n  查找类似于“我”的本地化字符串不能成为作业的目标。\r\n\r\n","\r\n Get all of the syntax errors within the syntax tree associated with this\r\n object. Does not get errors involving declarations or compiling method bodies or initializers.\r\n ":"\r\n 在与此关联的语法树中获取所有语法错误\r\n 目的。没有涉及声明或编译方法或初始化器的错误。\r\n \r\n","\r\n Implements shadowing based on\r\n §11.8.1.3 Depth of genericity\r\n ":"\r\n 基于\r\n §11.8.1.3通用深度\r\n \r\n"," where the first token of each symbol is annotated\r\n            and added to a map to keep track. This allows modification of the trees and later lookup of symbols\r\n            based on the original annotations added. Assumes each symbol only has one location.\r\n            ":" 每个符号的第一个令牌被注释\r\n            并添加到地图中以保持跟踪。这允许修改树木，然后查找符号\r\n            基于添加的原始注释。假设每个符号只有一个位置。\r\n            \r\n","function pointers":"功能指针\r\n","\r\n PermissionSetAttribute needs fixup when it contains an assignment to the 'File' property as a single named attribute argument.\r\n Fixup performed is ported from SecurityAttributes::FixUpPermissionSetAttribute.\r\n It involves following steps:\r\n  1) Verifying that the specified file name resolves to a valid path.\r\n  2) Reading the contents of the file into a byte array.\r\n  3) Convert each byte in the file content into two bytes containing hexa-decimal characters.\r\n  4) Replacing the 'File = fileName' named argument with 'Hex = hexFileContent' argument, where hexFileContent is the converted output from step 3) above.\r\n\r\n Step 1) is performed in this method, i.e. during binding.\r\n Remaining steps are performed during serialization as we want to avoid retaining the entire file contents throughout the binding/codegen pass.\r\n See ":"\r\n PermissionsetAttribute需求Fixup在将“文件”属性分配为单个命名属性参数时。\r\n 执行的FIXUP从SecurityAttributes :: FixUppermissionsetattribute移植。\r\n 它涉及以下步骤：\r\n  1）验证指定的文件名是否解析为有效路径。\r\n  2）将文件的内容读为字节数组。\r\n  3）将文件内容中的每个字节转换为两个包含六边形字符的字节。\r\n  4）用“ hex = hexfilecontent”参数替换命名参数的“ file = filename”参数，其中hexfilecontent是上面的步骤3的转换输出。\r\n\r\n 步骤1）在这种方法中，即在结合过程中执行。\r\n 剩余的步骤是在序列化过程中执行的，因为我们希望避免在整个绑定/代码GASE中保留整个文件内容。\r\n 看\r\n","\r\n Gets a list of all the diagnostics in the syntax tree.\r\n ":"\r\n 获取语​​法树中所有诊断的列表。\r\n \r\n","Invalid group name: Group names must begin with a word character":"无效的组名称：组名称必须以单词字符开头\r\n","\r\n The Script class symbol or null if it is not defined.\r\n ":"\r\n 脚本类符号或null如果未定义。\r\n \r\n","\r\n The value being assigned to the field.\r\n ":"\r\n 分配给字段的值。\r\n \r\n","\r\n            Indicates if the given operation is an expression of an expression body.\r\n            ":"\r\n            指示给定的操作是否是表达主体的表达。\r\n            \r\n","\r\n  Looks up a localized string similar to '{0}' is ambiguous between declarations in Modules '{1}'..\r\n":"\r\n  查找类似于“ {0}”的本地化字符串在模块'{1}'..中的声明之间模棱两可。\r\n\r\n","\r\n Gets a value indicating whether this instance has declared type. This means a field was declared with an AsClause\r\n or in case of const fields with an AsClause whose type is not System.Object\r\n ":"\r\n 获取一个指示此实例是否已声明类型的值。这意味着用clacea声明了一个字段\r\n 或者，如果具有类型不是系统的asclause的const字段。\r\n \r\n","\r\n            Finds the inner-most ancestor of the specified node that has a matching node in the new tree.\r\n            ":"\r\n            找到新树中具有匹配节点的指定节点的最内部祖先。\r\n            \r\n","\r\n Returns a copy of this with the EndOfFileToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中insoffiletoken属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n The \"With\" keyword.\r\n ":"\r\n “ with”关键字。\r\n \r\n"," Start of the region being analyzed, or Nothing if it is not a region based analysis ":" 分析区域的开始，或者如果不是基于区域的分析，则什么都没有\r\n","\r\n Represents a \"Loop Until\" statement that end a \"Do ... Loop\" block.\r\n ":"\r\n 代表一个“循环”，直到”结束“做...循环”块的语句。\r\n \r\n","Flag indicating if the reported diagnostics are configurable by the end users":"标志指示报告的诊断是否由最终用户配置\r\n","Autoselect disabled due to possible explicitly named anonymous type member creation.":"由于可能明确命名的匿名类型成员创建，因此禁用自动选择。\r\n","\r\n  Looks up a localized string similar to '{1}' for the Imports alias to '{0}' does not refer to a Namespace, Class, Structure, Interface, Enum or Module..\r\n":"\r\n  查找类似于'{0}'的导入别名类似的本地化字符串，并不参考名称空间，类，结构，接口，枚举或模块。\r\n\r\n","\r\n Build and cache a map of probable extension methods for this namespace.\r\n ":"\r\n 为此名称空间构建和缓存可能的扩展方法的地图。\r\n \r\n"," - that is left to the caller.\r\n ":"  - 留给来电者。\r\n \r\n"," keyword is an if statement, the embedded statements of the nested if statement are treated as\r\n             children of the parent statement of the ":" 关键字是if语句，嵌套if语句的嵌入语句被视为\r\n             家长陈述的子女 \r\n","\r\n The value for the EqualsKeyword property.\r\n ":"\r\n EqualsKeyWord属性的值。\r\n \r\n","\r\n            C# always requires a type to be present with a local declaration.  (Even if that type is\r\n            ":"\r\n            C＃总是需要使用本地声明来存在类型。 （即使该类型是\r\n            \r\n","\r\n            checks if the type represented by the given symbol is one of the\r\n            simple types defined in the compiler.\r\n            ":"\r\n            检查给定符号表示的类型是否是\r\n            编译器中定义的简单类型。\r\n            \r\n","A positive character range specifies a range of characters, any one of which may appear in an input string for a match to occur.  'firstCharacter' is the character that begins the range and 'lastCharacter' is the character that ends the range.":"正字符范围指定了一系列字符，其中任何一个可能出现在输入字符串中以进行匹配。 “ First Character”是开始范围的字符，而“ LastCharacter”是结束范围的字符。\r\n","\r\n Modified identifier appeared in a field declaration.\r\n ":"\r\n 修改后的标识符出现在字段声明中。\r\n \r\n","\r\n            Property cannot be used like a method\r\n            ":"\r\n            属性不能像方法一样使用\r\n            \r\n","First word capitalized":"第一个单词大写\r\n","\r\n Returns a copy of this with the TextToken property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，带有TextToken属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Type of global object, ":"全局对象的类型\r\n","\r\n Represents a format string clause ':formatString' of an interpolated string embedded expression.\r\n ":"\r\n 代表插值字符串嵌入式表达式的格式字符串子句'：formatstring'。\r\n \r\n","\r\n Describes how the field is marshalled when passed to native code.\r\n Null if no specific marshalling information is available for the field.\r\n ":"\r\n 描述将字段传递给本机代码时如何编辑字段。\r\n null如果没有特定的编组信息可用于该领域。\r\n \r\n","\r\n The value for the Imports property.\r\n ":"\r\n 进口属性的值。\r\n \r\n","\r\n Utility functions to check if two implemented interfaces have variance ambiguity.\r\n \r\n What is \"Variance Ambiguity\"? Here's an example:\r\n Class ReflectionType\r\n   Implements IEnumerable(Of Field)\r\n   Implements IEnumerable(Of Method)\r\n   Public Sub GetEnumeratorF() As IEnumerator(Of Field) Implements IEnumerable(Of Field).GetEnumerator ...\r\n   Public Sub GetEnumeratorM() As IEnumerator(Of Method) Implements IEnumerable(Of Method).GetEnumerator ...\r\n End Class\r\n Dim x as new ReflectionType\r\n Dim y as IEnumerable(Of Member) = x\r\n Dim z = y.GetEnumerator()\r\n\r\n Note that, through variance, both IEnumerable(Of Field) and IEnumerable(Of Method) have widening\r\n conversions to IEnumerable(Of Member). So it's ambiguous whether the initialization of \"z\" would\r\n invoke GetEnumeratorF or GetEnumeratorM. This function avoids such ambiguity at the declaration\r\n level, i.e. it reports a warning on the two implements classes inside ReflectionType that they\r\n may lead to ambiguity.\r\n ":"实用程序功能以检查两个实现的接口是否具有差异歧义。\r\n \r\n 什么是“差异歧义”？这是一个例子：\r\n 类ReflectionType\r\n   实现（字段）\r\n   实现（方法）\r\n   公共sub sub getEnumeratorf（）作为ienumerator（field）实现（field）的Ienumerator。\r\n   公共sub sub getEnumeratorm（方法）（方法）实现了（方法）。getEnumerator ...\r\n 最终课程\r\n DIM X作为新的ReflectionType\r\n Dim y as ienumerable（成员）= x\r\n dim z = y.getEnumerator（）\r\n\r\n 请注意，通过差异，iEnumerable（field）和iEnumerable（方法）均已扩大\r\n 转换为（成员）的Ienumerable。因此，“ Z”的初始化是否会\r\n 调用getEnumeratorf或getEnumeratorm。此功能避免了声明时的歧义\r\n 级别，即，它报告了他们在反射类型中的两个工具类别的警告。\r\n 可能导致歧义。\r\n \r\n","The span of the syntax element in the document associated with this item.":"文档中与此项目关联的文档中的语法元素的跨度。\r\n","Simplify 'default' expression":"简化“默认”表达式\r\n","\r\n  Looks up a localized string similar to Full width characters are not valid as XML delimiters..\r\n":"\r\n  查找类似于完整宽度字符的本地化字符串不像XML定界符有效。\r\n\r\n","\r\n The \"CType\", \"DirectCast\" or \"TryCast\" keyword.\r\n ":"\r\n “ CTYPE”，“ Directcast”或“ Trycast”关键字。\r\n \r\n","1,000ths of a second (non-zero)":"十分之一的一秒钟（非零）\r\n","\r\n Returns a copy of this with the StepClause property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而stepclause属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            Snippets are always included in the completion list.\r\n            ":"\r\n            摘要始终包含在完成列表中。\r\n            \r\n","\r\n            All the references to show.  Note: every ":"\r\n            所有要显示的参考。注意：每个\r\n","\r\n Determines if the unicode character is a hash character.\r\n ":"\r\n 确定Unicode字符是否是哈希字符。\r\n \r\n","\r\n Simple name of the assembly. \r\n ":"\r\n 组装的简单名称。\r\n \r\n","just this anonymous type":"只是这个匿名类型\r\n","\r\n Set to true of any lambda expressions were seen in the analyzed method body.\r\n ":"\r\n 在分析的方法主体中可以看到任何lambda表达式的真实。\r\n \r\n","\r\n Called by ConstraintTypes and Interfaces\r\n to allow derived classes to ensure constraints within the containing\r\n type or method are resolved in a consistent order, regardless of the\r\n order the callers query individual type parameters.\r\n ":"\r\n 通过约束类型和接口调用\r\n 允许派生的类以确保包含的约束\r\n 类型或方法以一致的顺序解析，而不管\r\n 订购呼叫者查询各个类型参数。\r\n \r\n","\r\n            Represents an instruction range in the code that contains an active instruction of at least one thread and that is delimited by consecutive sequence points.\r\n            More than one thread can share the same instance of ":"\r\n            代表代码中包含至少一个线程的主动指令的指令范围，并通过连续序列点进行界定。\r\n            多个线程可以共享相同的实例\r\n","\r\n            Similar to CodeFixSuggestionAction, but in a location that can be used by\r\n            both local Roslyn and LSP.\r\n            ":"\r\n            与CodeFixSuggestionAction类似，但在可以使用的位置\r\n            当地的罗斯林和LSP。\r\n            \r\n","\r\n This is an implementation of a special symbol comparer, which is supposed to be used  for \r\n sorting original definition symbols (explicitly or explicitly declared in source  within the same \r\n container) in lexical order of their declarations. It will not work on  anything that uses non-source locations. \r\n ":"\r\n 这是特殊符号比较的实现，应该用于\r\n 对原始定义符号进行排序（在同一源中明确或明确声明\r\n 集装箱）按声明的词汇顺序。它不会在使用非源地点的任何东西上使用。\r\n \r\n","\r\n            Returns the brace completion context if the caret is located between an already completed\r\n            set of braces with only whitespace in between.\r\n            ":"\r\n            如果Caret位于已经完成的\r\n            一组只有白色之间的牙套。\r\n            \r\n","\r\n Retargeted return type attributes\r\n ":"\r\n 重新定位的返回类型属性\r\n \r\n","A source file is missing a required header.":"源文件缺少所需的标头。\r\n","Changing parameter types of {0} requires restarting the application.":"更改{0}的参数类型需要重新启动应用程序。\r\n","\r\n            Forks the source document, keeps required type, namespace containers\r\n            and adds it the solution.\r\n            ":"\r\n            叉子源文档，保留所需的类型，名称空间容器\r\n            并添加解决方案。\r\n            \r\n","\r\n The expression whose formatted value should be embedded in the resultant\r\n string.\r\n ":"\r\n 格式值应嵌入其合理值的表达式\r\n 细绳。\r\n \r\n","extra trailing tokens to be added to the select clause":"额外的尾随令牌要添加到SELECT子句中\r\n","\r\n True if the assembly contains interactive code.\r\n ":"\r\n 如果程序集包含交互式代码，则为正确。\r\n \r\n","\r\n  Looks up a localized string similar to 'Else' must be preceded by a matching 'If' or 'ElseIf'..\r\n":"\r\n  查找类似于“ else”的本地化字符串必须先于匹配的“ if”或“ elseif”。\r\n\r\n","\r\n Lookup member declaration in predefined CorLib type used by this Assembly.\r\n ":"\r\n 查找成员声明此组件使用的预定义的Corlib类型。\r\n \r\n","\r\n Indicates if the property can be written into, which means this \r\n property has a setter or it is a getter only autoproperty accessed \r\n in a corresponding constructor or initializer\r\n ":"\r\n 指示是否可以写入该物业，这意味着\r\n 属性有一个设置器，或者仅是getter访问的autoperty\r\n 在相应的构造函数或初始器中\r\n \r\n","\r\n            to all lines in range [":"\r\n            到范围内的所有线\r\n","\r\n Given an identifier and an As clause, return true if the identifier does not have a type\r\n declared for it (e.g., no type character and no as clause).\r\n ":"\r\n 给定标识符和AS子句，如果标识符没有类型，则返回true\r\n 为此声明（例如，没有类型的字符，没有作为子句）。\r\n \r\n","The \"mm\" custom format specifier (plus any number of additional \"m\" specifiers) represents the minute as a number from 00 through 59. The minute represents whole minutes that have passed since the last hour. A single-digit minute is formatted with a leadin ...":"“ MM”自定义格式指定符（加上任何数量的其他“ M”指示符）表示该分钟为00至59的数字。单位分钟用铅素格式化...\r\n","<Name>":"<名称>\r\n","The document text that completion is occurring within.":"内部完成的文档文本。\r\n","\r\n            Computes a list of nodes and tokens that need to be reduced in the given syntax root.\r\n            ":"\r\n            计算在给定语法根中需要减少的节点和令牌列表。\r\n            \r\n","\r\n When binding \"C\" new C(...), return the type C and do not return information about\r\n which constructor was bound to. Bind \"new C(...)\" to get information about which constructor\r\n was chosen.\r\n ":"\r\n 绑定“ C”新C（...）时，返回C型，请勿返回有关的信息\r\n 哪个构造函数绑定到。绑定“新C（...）”以获取有关哪个构造函数的信息\r\n 被选中。\r\n \r\n","\r\n  Looks up a localized string similar to 'End' statement cannot be used in class library projects..\r\n":"\r\n  查找类似于“ end”语句的本地化字符串，不能在类库项目中使用。\r\n\r\n","\r\n The list of collection range variables declared by this Aggregate operator.\r\n ":"\r\n 该汇总运算符声明的集合范围变量列表。\r\n \r\n","separator, space":"分离器，空间\r\n","\r\n  Looks up a localized string similar to 'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to a Get or Set..\r\n":"\r\n  查找类似于'system.runtime.interopservices.dllimportattribute'的本地化字符串，不能应用于get或设置。\r\n\r\n","\r\n The token that is the operator.\r\n ":"\r\n 代币是操作员。\r\n \r\n","\r\n  Looks up a localized string similar to 'Finally' cannot appear outside a 'Try' statement..\r\n":"\r\n  查找类似于“最后”的本地化字符串，无法出现在“尝试”语句之外。\r\n\r\n"," if the symbol cannot be represented by an RQName.\r\n            ":" 如果该符号不能由rqname表示。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Loop' cannot have a condition if matching 'Do' has one..\r\n":"\r\n  查找类似于“循环”的本地化字符串，如果匹配的“做”有一个。\r\n\r\n"," from one or more nodes and tokens.\r\n ":" 来自一个或多个节点和令牌。\r\n \r\n"," representing the specific kind of\r\n UnaryExpressionSyntax. One of UnaryPlusExpression, UnaryMinusExpression,\r\n NotExpression, AddressOfExpression.\r\n ":" 代表特定种类\r\n UNARYARYEXPRESSYNTAX。 Unaryplusexpression之一，UnaryMinuseXpression，\r\n 不表达，地址表达。\r\n \r\n","The import statement syntax node.":"导入语句语法节点。\r\n","\r\n            Returns the display name of an ancestor node that contains the specified node and has a display name.\r\n            ":"\r\n            返回包含指定节点并具有显示名称的祖先节点的显示名称。\r\n            \r\n","\r\n            Re-analyze given projects and documents\r\n            ":"\r\n            重新分析给定的项目和文件\r\n            \r\n","\r\n  Looks up a localized string similar to Statement cannot appear within an event body. End of event assumed..\r\n":"\r\n  查找类似于语句的本地化字符串无法在事件正文中出现。假定事件的结束..\r\n\r\n","\r\n Matches an attribute by metadata namespace, metadata type name and metadata signature. Does not load the\r\n type symbol for the attribute.\r\n ":"\r\n 匹配元数据名称空间，元数据类型名称和元数据签名的属性。不加载\r\n 属性的类型符号。\r\n \r\n","\r\n Create a missing string literal.\r\n ":"\r\n 创建一个缺少的字符串文字。\r\n \r\n","Applying source changes while the application is running is not supported by the runtime.":"运行时不支持应用程序运行时应用源更改。\r\n","Top level statement which token is part of.":"最高级别的代币是其中的一部分。\r\n","\r\n Set to true while we are analyzing the interior of an expression lambda.\r\n ":"\r\n 当我们分析表达lambda的内部时，设置为真。\r\n \r\n","\r\n  Looks up a localized string similar to Conversion operators cannot convert from a derived type..\r\n":"\r\n  查找类似于转换运算符的本地化字符串无法从派生类型转换。\r\n\r\n","Use locally installed '{0}' version '{1}'\r\n            This version used in: {2}":"使用本地安装的'{0}'版本'{1}'\r\n            此版本在：{2}中使用\r\n","\r\n Adjusts receiver of a call or a member access.\r\n  * will turn Unknown property access into Get property access\r\n  * will turn TypeOrValueExpression into a value expression\r\n ":"\r\n 调整呼叫或会员访问的接收器。\r\n  *将未知的属性访问转为获取属性访问\r\n  *将把typeorvalueexpression变成值表达式\r\n \r\n","unconstrained type parameters in null coalescing operator":"零聚合操作员中的无约束类型参数\r\n","if (expr) { statement }":"if（expr）{语句}\r\n","A flag indicating whether the bound local's type is,\r\n inherits or implements IDisposable or not.":"指示绑定本地的类型是否为,\r\n 继承或实现IDisposable与否。\r\n","\r\n This property exists purely for performance reasons.\r\n ":"\r\n 该属性纯粹是出于绩效原因而存在。\r\n \r\n","\r\n Return true if the fully qualified name of the type's containing symbol\r\n matches the given name. This method avoids string concatenations\r\n in the common case where the type is a top-level type.\r\n ":"\r\n 如果类型的包含符号的完全合格名称，请返回true\r\n 匹配给定名称。此方法避免了字符串串联\r\n 在常见的情况下，该类型是顶级类型。\r\n \r\n","\r\n            Give a set of least specific types with a limit, and the part exceeding the limit doesn't show any code fix,\r\n            but logs telemetry \r\n            ":"\r\n            给出一组最小特定类型的限制，超过限制的零件不会显示任何代码修复，\r\n            但是日志遥测\r\n            \r\n"," doesn't necessarily\r\n            lead to commission.\r\n            ":" 不一定是\r\n            导致委托。\r\n            \r\n",",\r\n meaning that some trailing dimensions don't have the lower bound specified.\r\n The most common case is all dimensions are zero bound - a null array is returned in this case.\r\n ":"，，，，\r\n 这意味着某些尾随尺寸没有指定的下限。\r\n 最常见的情况是所有尺寸均为零绑定 - 在这种情况下，返回一个空数组。\r\n \r\n","\r\n The \"position\" is used to determine what variables are visible and accessible. Even if\r\n \"container\" is specified, the \"position\" location is significant for determining which\r\n members of \"containing\" are accessible. \r\n \r\n Locations are character locations, just as used as the Syntax APIs such as FindToken, or \r\n returned from the Span property on tokens and syntax node.\r\n \r\n The text of the program is divided into scopes, which nest but don't otherwise\r\n intersect. When doing an operation such as LookupSymbols, the code first determines the\r\n smallest scope containing the position, and from there all containing scopes. \r\n \r\n Scopes that span an entire block statement start at the beginning of the first token of \r\n the block header, and end immediately before the statement terminator token following\r\n the end statement of the block. If the end statement of the block is missing, it ends\r\n immediately before the next token. Examples of these include members and type parameters\r\n of a type, type parameters of a method, and variables declared in a For statement.\r\n \r\n Scopes that span the interior of a block statement start at the statement terminator of \r\n the block header statement, and end immediately before the first token of the end\r\n statement of the block. If the end statement of the block is missing, it ends\r\n immediately before the next statement. Examples of these include local variables, method\r\n parameters, and members of a namespace.\r\n \r\n Scopes of variables declared in a single-line If statement start at the beginning of the\r\n \"Then\" token, and end immediately before the Else token or statement terminator. \r\n \r\n Scopes of variables declared in the Else part of a single-line If start at the beginning\r\n of the \"Else\" token, and end immediately before the statement terminator.\r\n \r\n Some specialized binding rules are in place for a single statement, like Imports or\r\n Inherits. These specialized binding rules begin at the start of the first token of the\r\n statement, and end immediately before the statement terminator of that statement.\r\n \r\n In all of the above, the \"start\" means the start of a token without considering leading\r\n trivia. In other words, Span.Start, not FullSpan.Start. With the exception of\r\n documentation comments, all scopes begin at the start of a token, and end immediately\r\n before the start of a token.\r\n \r\n The scope of the default namespace, and all symbols introduced via Imports statements,\r\n is the entire file.\r\n \r\n Positions within a documentation comment that is correctly attached to a symbol take on\r\n the binding scope of that symbol. \r\n ":"\r\n \"位置\"用于确定哪些变量是可见的和可访问的。 即使\r\n \"容器\"被指定，\"位置\"位置对于确定哪个是重要的\r\n \"包含\"的成员是可访问的。 \r\n \r\n 位置是字符位置，就像FindToken等语法Api一样使用，或者 \r\n 从令牌和语法节点上的Span属性返回。\r\n \r\n 该程序的文本分为范围，其中巢，但不这样做\r\n 相交。 在进行lookupsymbols等操作时，代码首先确定\r\n 包含位置的最小作用域，并且从那里开始都包含作用域。 \r\n \r\n 跨越整个块语句的范围从 \r\n 块头，并在语句终止符令牌后面紧接着结束\r\n 块的结束语句。 如果缺少块的end语句，则结束\r\n 紧接在下一个令牌之前。 这些示例包括成员和类型参数\r\n 类型、方法的类型参数和在For语句中声明的变量。\r\n \r\n 跨越块语句内部的范围从 \r\n 块头语句，并在结束的第一个标记之前立即结束\r\n 块的语句。 如果缺少块的end语句，则结束\r\n 紧接在下一个语句之前。 这些例子包括局部变量、方法\r\n 参数和命名空间的成员。\r\n \r\n 如果语句从\r\n \"Then\"令牌，并在Else令牌或语句终止符之前立即结束。 \r\n \r\n 如果从开头开始，则在单行的Else部分中声明的变量的范围\r\n 的\"Else\"令牌，并在语句终止符之前立即结束。\r\n \r\n 一些专门的绑定规则适用于单个语句，如导入或\r\n 继承。 这些专门的绑定规则从\r\n 语句，并在紧接该语句的语句终止符之前结束。\r\n \r\n 在上述所有内容中，\"开始\"表示令牌的开始而不考虑前导\r\n 琐事。 换句话说，跨度。开始，而不是完整的。开始吧。 除了\r\n 文档注释，所有作用域从令牌的开头开始，并立即结束\r\n 令牌开始之前。\r\n \r\n 默认命名空间的范围，以及通过Imports语句引入的所有符号,\r\n 是整个文件。\r\n \r\n 文档注释中的位置正确地附加到符号上\r\n 该符号的绑定范围。 \r\n \r\n","\r\n or ":"\r\n 或者\r\n","Can't determine valid range of statements to extract":"无法确定要提取的有效语句范围\r\n","\r\n The value for the EraseKeyword property.\r\n ":"\r\n eraseKeyword属性的值。\r\n \r\n","The array of bound initializers to add the newly bound ones to.":"绑定的初始化器的数组将新绑定的初始化器添加到。\r\n","\r\n  Looks up a localized string similar to None of the accessible 'Main' methods with the appropriate signatures found in '{0}' can be the startup method since they are all either generic or nested in generic types..\r\n":"\r\n  查找与“ {0”}'中找到适当签名的可访问的“主”方法类似的本地化字符串可以是启动方法，因为它们都是通用的，要么是嵌套在通用类型中。\r\n\r\n","\r\n The \"While expression\" or \"Until expression\" clause of the Do statement, if\r\n present.\r\n ":"\r\n do语句的“表达”或“直到表达”条款，如果\r\n 当下。\r\n \r\n","The type on which we are looking for a declared implementation of the interface method.":"我们正在寻找接口方法的声明实现的类型。\r\n","\r\n Returns a copy of this with the ElseIfKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 将其返回此副本，其中ElseifKeyWord属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Member access should be qualified.":"会员访问应有资格。\r\n","\r\n Lookup an immediately nested type referenced from metadata, names should be\r\n compared case-sensitively.\r\n ":"\r\n 查找从元数据引用的立即嵌套类型，名称应为\r\n 比较病例敏感。\r\n \r\n","\r\n  Looks up a localized string similar to Cannot continue since the edit includes a reference to an embedded type: '{0}'..\r\n":"\r\n  查找类似于类似的本地化字符串，因为编辑包括对嵌入式类型的引用：'{0}'..\r\n\r\n","\r\n A list of clauses associated with this Case. If Kind=CaseElse, then this list\r\n has exactly one child, which is a ElseCaseClause.\r\n ":"\r\n 与此情况关联的子句列表。如果是bink = caseelse，则此列表\r\n 恰好有一个孩子，这是一个elsecaseclaus。\r\n \r\n","\r\n            Returns valid signature help items at the specified position in the document.\r\n            ":"\r\n            返回文档指定位置处的有效签名帮助项目。\r\n            \r\n","root, of the syntax tree of forked document":"根，分叉文档的语法树\r\n","\r\n  Looks up a localized string similar to 'Await' can only be used within an Async lambda expression. Consider marking this lambda expression with the 'Async' modifier..\r\n":"\r\n  查找类似于“等待”的局部字符串只能在异步lambda表达式中使用。考虑使用“ async”修饰符标记此lambda表达式。\r\n\r\n","\r\n The value for the Mid property.\r\n ":"\r\n 中间物业的价值。\r\n \r\n","\r\n The \"Equals\" keyword.\r\n ":"\r\n “等于”关键字。\r\n \r\n","\r\n Get a read-only list of the syntax trees that this compilation was created with.\r\n ":"\r\n 获取使用此汇编创建的语法树的仅阅读列表。\r\n \r\n","\r\n Initializes m_Namespaces and m_Types maps with information about \r\n namespaces and types immediately contained within this namespace.\r\n ":"\r\n 初始化m_namespaces和m_types地图，并提供有关信息的信息\r\n 该名称空间中立即包含的名称空间和类型。\r\n \r\n","\r\n  Looks up a localized string similar to XML attribute '{0}' must appear before XML attribute '{1}'..\r\n":"查找类似于XML属性'{0}'的本地化字符串必须出现在XML属性'{1}'..之前\r\n\r\n"," for getter of an expression-bodied property/indexer.\r\n            ":" 为了获得表达体属性/索引器。\r\n            \r\n","\r\n Current node. Not necessarily reusable or even a NonTerminal.\r\n Can be null if we are out of nodes.\r\n ":"\r\n 当前节点。不一定可重复使用，甚至是非终端。\r\n 如果我们不超出节点，则可以无效。\r\n \r\n","A using variable cannot be used directly within a switch section (consider using braces).":"使用变量不能直接在开关部分中使用（考虑使用括号）。\r\n","\r\n The value for the ArgumentTypes property.\r\n ":"\r\n 参数类型属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to Conflicts with '{0}', which is implicitly declared for '{1}' in {2} '{3}'..\r\n":"\r\n  查找类似于“ {0}”冲突的本地化字符串，该字符串在{2}'{3}'..中被隐式声明为'{1}'..\r\n\r\n","\r\n Returns the AttributeBlockSyntax of the given AsClauseSyntax if specified.\r\n ":"\r\n 如果指定了给定的asclausesyntax的属性blocksyntax。\r\n \r\n","\r\n            Represents a switch-section constructed from a series of\r\n            if-conditions, possibly combined with logical-or operator\r\n            ":"\r\n            表示由一系列的开关截面\r\n            如果条件，可能与逻辑或操作员结合\r\n            \r\n","In a sequence of consecutive ":"在连续的序列中 \r\n","\r\n For a given namespace in context of a particular Compilation all binders use \r\n either a compilation merged namespace symbol, or a module level namespace symbol \r\n (PE, Source or Retargeting). In order to speed-up lookup of extension methods performed \r\n by a binder, we build and cache a map of all extension methods declared within the namespace \r\n grouped by name (case-insensitively). \r\n \r\n If binder uses compilation merged namespace symbol, the map is built across all underlying \r\n module level namespace symbols, separate maps for underlying namespace symbols are not built.\r\n \r\n If binder uses Retargeting module level namespace symbol, we build the map for the underlying \r\n namespace symbol instead and push all requests through the underlying namespace.\r\n \r\n The map actually stores ImmutableArray(Of MethodSymbol), but we are using ImmutableArray(Of Symbol)\r\n in order to be able to pass the map to a more general API.\r\n ":"\r\n 对于特定汇编的给定名称空间，所有绑定器都使用\r\n 汇编合并的名称空间符号或模块级命名空间符号\r\n （PE，源或重新定位）。为了加快执行扩展方法的查找\r\n 通过活页夹，我们构建并缓存了在名称空间中声明的所有扩展方法的地图\r\n 按名称分组（casemonsitionality）。\r\n \r\n 如果活页夹使用合并合并的名称空间符号，则该地图是在所有基础上构建的\r\n 没有构建模块级命名空间符号，基础名称空间符号的单独地图。\r\n \r\n 如果Binder使用重新定位模块级别名称空间符号，我们将为基础构建地图\r\n 命名空间符号，然后通过基础名称空间推动所有请求。\r\n \r\n 该地图实际上存储了ImmutableArray（方法符号），但我们正在使用Immutablearray（符号）\r\n 为了能够将地图传递给更通用的API。\r\n \r\n","\r\n  Looks up a localized string similar to 'Sub New' cannot be declared '{0}'..\r\n":"\r\n  查找类似于“ sub new”的本地化字符串，无法声明'{0}'..\r\n\r\n","Use pattern matching":"使用模式匹配\r\n","\r\n This instance is used to search for methods that have the same signature, return type,\r\n and constraints according to the VisualBasic definition.  Custom modifiers are ignored.\r\n ":"\r\n 此实例用于搜索具有相同签名，返回类型的方法\r\n 和根据视觉质量定义的约束。自定义修饰符被忽略。\r\n \r\n","Methods":"方法\r\n","\r\n The value of the token.\r\n ":"\r\n 令牌的价值。\r\n \r\n","\r\n The value for the DistinctKeyword property.\r\n ":"\r\n 独特关键字属性的值。\r\n \r\n","nu":"nu\r\n"," element\r\n            itself precedes the content of the container, and is typically a bullet or number header for an item in a\r\n            list.\r\n            ":" 元素\r\n            本身先于容器的内容，通常是一个项目中的子弹或数字标头\r\n            列表。\r\n            \r\n","\r\n Marshalling charset of string data fields within the type (string formatting flags in metadata).\r\n ":"\r\n 在类型（元数据中的字符串格式化标志）中编组字符串数据字段的字符集。\r\n \r\n","\r\n A binder for XmlElement declarations.\r\n ":"\r\n XMlelement声明的活页夹。\r\n \r\n","\r\n Returns a copy of this with the StartTag property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此的副本，而StartTag属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","letter, titlecase":"字母，滴定酶\r\n","Move misplaced using directives":"使用指令移动放错位置\r\n","\r\n            Specifies whether debugging symbols should be emitted.\r\n            ":"\r\n            指定是否应发出调试符号。\r\n            \r\n","\r\n Gets a value indicating whether this do loop is a DoTopLoop or not. In syntax error cases\r\n where both conditions are used, priority is given to the first one.\r\n It's recommended to consistently use this property instead of checking the TopConditionOpt and BottomConditionOpt\r\n directly.\r\n ":"\r\n 获取一个指示此循环是否为dotoploop的值。在语法错误案例中\r\n 在使用两个条件的情况下，将优先级给予第一个条件。\r\n 建议始终使用此属性，而不是检查TopConconditionOpt和BottomSconditionOpt\r\n 直接地。\r\n \r\n","\r\n Create a possibly merged namespace symbol representing global namespace on a compilation level.\r\n ":"\r\n 创建一个可能合并的名称空间符号，代表编译级别的全局名称空间。\r\n \r\n","'{0}' is explicitly implemented more than once.":"'{0}'明确实现了一次。\r\n","\r\n Determine if enum arrays can be initialized using block initialization.\r\n ":"\r\n 确定是否可以使用块初始化来初始化枚举阵列。\r\n \r\n","\r\n            Determine if a code block is eligible for analysis by ":"\r\n            确定代码块是否有资格通过\r\n"," APIs to request that the navigation should activate the tab.\r\n            The default for the platform is to activate the tab, so turning the option off tells the platform to not activate the tab.\r\n            ":" API要求导航应激活选项卡。\r\n            该平台的默认值是激活选项卡，因此关闭选项会告诉平台不要激活选项卡。\r\n            \r\n","Analyzer '{0}' threw an exception of type '{1}' with message '{2}'.":"分析仪'{0}'带有消息'{2}'的类型'{1}'的例外。\r\n"," \r\n The compilation associated with this binding.\r\n ":" \r\n 与该结合有关的汇编。\r\n \r\n","Remove reference to '{0}'.":"删除对“ {0}”的引用。\r\n","\r\n            The rules used to control behavior of the completion list shown to the user during typing.\r\n            ":"在打字过程中，用于控制用户显示的完成列表的行为的规则。\r\n            \r\n","\r\n An ArrayTypeSymbol represents an array type, such as Integer() or Object(,).\r\n ":"\r\n ArrayTypesymbol表示数组类型，例如Integer（）或Object（，）。\r\n \r\n","\r\n Returns a copy of this with the ThenKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中thekeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Generate constructor '{0}({1})'":"生成构造函数'{0}（{1}）'\r\n"," of this item less than the default value so that completion selects\r\n            the ":" 该项目的少于默认值，因此完成选择\r\n            这\r\n","hexadecimal escape":"十六进制逃生\r\n","\r\n The \"ElseIf\" keyword.\r\n ":"\r\n “ Elseif”关键字。\r\n \r\n","\r\n Set and Get the Visual Basic parse options.\r\n ":"\r\n 设置并获取视觉基本解析选项。\r\n \r\n","'{0}' is not a valid function pointer return type modifier. Valid modifiers are 'ref' and 'ref readonly'.":"'{0}'不是有效的函数指针返回类型修饰符。有效的修饰符是“ ref”和“ ref Readonly”。\r\n",",\r\n                   such that is meets a few criteria (see implementation details below).\r\n                5. If field, then it must not be a backing field for an auto property.\r\n                   Backing fields have a non-null ":",\r\n                   这样就满足了一些标准（见下面的实现细节）。\r\n                5. 如果字段，那么它不能是自动属性的支持字段。\r\n                   支持字段具有非空 \r\n","\r\n            Diagnostics for rude edits in the document, or empty if the document is unchanged or has syntax errors.\r\n            If the compilation has semantic errors only syntactic rude edits are calculated.\r\n            ":"\r\n            文档中粗鲁编辑的诊断，如果文档不变或具有语法错误，则为空。\r\n            如果汇编具有语义错误，则仅计算句法粗鲁的编辑。\r\n            \r\n","True, if the reference was updated.":"是的，如果引用已更新。\r\n","\r\n The expression that represents the error number.\r\n ":"\r\n 表示误差号的表达式。\r\n \r\n"," will be merged with this dictionary. ":" 将与该词典合并。\r\n","\r\n  Looks up a localized string similar to 'End While' must be preceded by a matching 'While'..\r\n":"\r\n  查找类似于“ end”的局部字符串，必须先于匹配“ while”。\r\n\r\n","\r\n Get an error symbol.\r\n ":"\r\n 获取错误符号。\r\n \r\n","Introduce parameter for '{0}'":"引入'{0}'的参数\r\n","\r\n Check Expression for being in right context, for example 'For ... Next [x]' \r\n is not correct context\r\n ":"\r\n 检查表达在正确的上下文中，例如“ for ... next [x]'\r\n 不是正确的上下文\r\n \r\n","\r\n These indices correspond to the merged assembly attributes from source and added net modules, i.e. attributes returned by ":"\r\n 这些索引对应于来自源的合并汇编属性，并添加了净模块，即返回的属性\r\n","\r\n Performs internal substitution of types in anonymous type descriptor fields and returns True \r\n if any of the fields was changed, in which case a new descriptor is returned in newDescriptor\r\n ":"\r\n 在匿名类型的描述符字段中执行类型的内部替换，并返回true\r\n 如果更改了任何字段，在这种情况下\r\n \r\n","\r\n The conditions indicating what expressions to compare during the join. Each\r\n condition is a JoinCondition, and the separators are \"And\" keywords.\r\n ":"\r\n 指示在联接过程中比较哪些表达式的条件。每个\r\n 条件是一个joincondition，分隔符为“和”关键字。\r\n \r\n","\r\n A \"Finally\" block to be executed before execution leaves the \"Try\" block.\r\n ":"\r\n 在执行之前要执行一个“最后”块。\r\n \r\n"," for the\r\n             specific case where the result is only used for testing if any element meets certain conditions.":" 为了\r\n             在任何元素符合某些条件的情况下仅用于测试结果的具体情况。\r\n","Blank line not allowed after constructor initializer colon":"构造函数初始化剂结肠后不允许空白行\r\n","\r\n Represents a retargeting custom attribute\r\n ":"\r\n 代表重新定制属性\r\n \r\n","\r\n A list of the modifier tokens \"ByVal\", \"ByRef\", \"Optional\" or \"ParamArray\" that\r\n modify this parameter.\r\n ":"\r\n 修饰符令牌“ byval”，“ byref”，“可选”或“ paramarray”的列表\r\n 修改此参数。\r\n \r\n","Interface is already listed in the interface list with different nullability of reference types.":"接口已经在接口列表中列出，具有不同的参考类型的可取性。\r\n","\r\n  Looks up a localized string similar to Auto-implemented properties cannot have parameters..\r\n":"\r\n  查找类似于自动实现属性的本地化字符串，无法具有参数。\r\n\r\n","\r\n  Looks up a localized string similar to Option Strict On does not allow implicit conversions from '{0}' to '{1}' because the conversion is ambiguous..\r\n":"\r\n  查找类似于Option Option的局部字符串，不允许从“ {0}”到'{1}'的隐式转换，因为转换是模棱两可的。\r\n\r\n","\r\n Methods, Properties, and Events all can override or hide members. \r\n This class has helper methods and extensions for sharing by multiple symbol types.\r\n ":"\r\n 方法，属性和事件都可以覆盖或隐藏成员。\r\n 该类具有辅助方法和扩展，用于通过多种符号类型共享。\r\n \r\n","\r\n            Represents a syntax reference that was passed a null\r\n            reference to a node. In this case, we just hold onto the\r\n            weak tree reference and throw if any invalid properties\r\n            are accessed.\r\n            ":"\r\n            表示通过null的语法参考\r\n            引用节点。在这种情况下，我们只是坚持\r\n            树木参考弱，如果有任何无效的属性\r\n            已访问。\r\n            \r\n","Remove unnecessary parentheses":"删除不必要的括号\r\n","\r\n Represents an alignment clause ', alignment' of an interpolated string embedded expression.\r\n ":"\r\n 代表插值字符串嵌入式表达式的对齐子句“，对齐”。\r\n \r\n","\r\n The \"Mid\" possibly followed by a type character.\r\n ":"\r\n “中间”可能是类型的字符。\r\n \r\n","#nullable enable":"＃nullable启用\r\n","Flag indicating if a query expression should be generated":"标志指示是否应生成查询表达式\r\n","\r\n Imports o = System.Object\r\n Namespace NS\r\n     partial class C : Inherits o : End Class\r\n     partial class C : Inherits Object : End Class\r\n     partial class C : Inherits System.Object : End Class\r\n End Namespace\r\n \r\n ":"\r\n 导入o = system.Object\r\n 名称空间NS\r\n     部分级别C：继承O：结束课程\r\n     部分类C：继承对象：结束类\r\n     部分类C：继承System.Object：End类\r\n 终点空间\r\n \r\n \r\n","Type '{0}' cannot be embedded because it has a re-abstraction of a member from base interface. Consider setting the 'Embed Interop Types' property to false.":"键入'{0}'无法嵌入，因为它具有从基本接口中的成员重新启动。考虑将“嵌入Interop类型”属性设置为false。\r\n","\r\n            Force create all relevant indices\r\n            ":"\r\n            强制创建所有相关索引\r\n            \r\n","R&emove and Sort Usings":"R＆Emove和Sort Susings\r\n","\r\n The \"Error\" keyword.\r\n ":"\r\n “错误”关键字。\r\n \r\n","s in this compilation.\r\n ":"在此汇编中。\r\n \r\n","\r\n The underlying PropertySymbol, cannot be another RetargetingPropertySymbol.\r\n ":"\r\n 基础PropertySymbol不能是另一个RetargetingPropertySymbol。\r\n \r\n","\r\n            Some of the known ":"\r\n            一些已知的\r\n","The {n,m} quantifier matches the preceding element at least n times, but no more than m times, where n and m are integers. {n,m} is a greedy quantifier whose lazy equivalent is {n,m}?":"{n，m}量词至少匹配前面的元素，但不超过m次，其中n和m是整数。 {n，m}是贪婪的量词，其懒惰等效是{n，m}？\r\n","\r\n            True if the variable can't be written to (it's declared as readonly or a constant).\r\n            ":"\r\n            如果变量无法写入（将其声明为读取或常数），则为是真的。\r\n            \r\n","Character class subtraction yields a set of characters that is the result of excluding the characters in one character class from another character class.\r\n            \r\n            'base_group' is a positive or negative character group or range. The 'excluded_group' component is a ...":"字符类减法产生一组字符，这是从另一个字符类中排除一个字符类中字符的结果。\r\n            \r\n            “ base_group”是一个正面或负面角色组或范围。 “ Defkuded_group”组件是...\r\n","\r\n The \"Handles\" keyword.\r\n ":"\r\n “处理”关键字。\r\n \r\n"," of the script.\r\n            ":" 脚本。\r\n            \r\n","\r\n Returns true if this Is a SemanticModel that ignores accessibility rules when answering semantic questions.\r\n ":"\r\n 如果这是一个语义模型，则返回true，它在回答语义问题时会忽略可访问性规则。\r\n \r\n","\r\n            The opening position to insert the brace.\r\n            Note that the brace is not yet inserted at this position in the document.\r\n            ":"\r\n            插入支架的开头位置。\r\n            请注意，撑杆尚未插入文档中的此位置。\r\n            \r\n","non-digit character":"非数字字符\r\n"," if the trivia is of the specified kind; otherwise, ":" 如果琐事是指定类型的；否则，\r\n","\r\n This function generalizes the idea of producing a set of non-conflicting\r\n WinRT members of a given type based on the results of some arbitrary lookup\r\n closure (which produces a LookupResult signifying success as IsGood).\r\n\r\n A non-conflicting WinRT member lookup looks for all members of projected\r\n WinRT interfaces which are implemented by a given type, discarding any \r\n which have equal signatures.\r\n \r\n If ":"\r\n 此函数概括了产生一组非冲突的想法\r\n 根据某些任意查找的结果，给定类型的WinRT成员\r\n 闭合（产生一个象征性的象征，就像Isgood一样）。\r\n\r\n 所有预计的所有成员\r\n 通过给定类型实现的WinRT接口，丢弃任何\r\n 具有相等的签名。\r\n \r\n 如果\r\n","All control characters. This includes the Cc, Cf, Cs, Co, and Cn categories.":"所有控制字符。这包括CC，CF，CS，CO和CN类别。\r\n","Parentheses should be added for clarity":"为了清楚起见，应添加括号\r\n"," whose content exactly matches\r\n            the source file used to compile the binary currently loaded in the debuggee. Returns null\r\n            if it fails to find a document snapshot whose content hash maches the one recorded in the PDB.\r\n            \r\n            The result is cached and the next lookup uses the cached value, including failures unless ":" 其内容完全匹配\r\n            用于编译Debuggee中当前加载的二进制文件的源文件。返回null\r\n            如果未能找到一个文档快照，其内容hash会在PDB中记录下来。\r\n            \r\n            结果是缓存的，下一个查找使用缓存值，包括失败，除非\r\n","\r\n Pending escapes generated in the current scope (or more deeply nested scopes). When jump\r\n statements (goto, break, continue, return) are processed, they are placed in the\r\n Me._pendingBranches buffer to be processed later by the code handling the destination\r\n statement. As a special case, the processing of try-finally statements might modify the\r\n contents of the Me._pendingBranches buffer to take into account the behavior of\r\n \"intervening\" finally clauses.\r\n ":"\r\n 在当前范围（或更深层嵌套的范围）中产生的悬挂逃逸。跳跃时\r\n 对语句（Goto，Break，Consine，Record）进行处理，将其放置在\r\n me._pendingBranches Buffer将在稍后通过处理目的地处理的代码\r\n 陈述。作为一种特殊情况，试用语句的处理可能会修改\r\n me._pendingBranches Buffer的内容要考虑到行为\r\n “干预”最终条款。\r\n \r\n","short date":"短日期\r\n","Add argument name '{0}' (including trailing arguments)":"添加参数名称'{0}'（包括落后参数）\r\n","\r\n Detects cycles in constructor invocations based on the 'constructor-calls-constructor' \r\n map provided in 'constructorCallMap', reports errors if found.\r\n \r\n NOTE: 'constructorCallMap' is being mutated by this method\r\n ":"检测基于“ constructor-calls-constructor'的构造函数调用”中的循环\r\n 在“ constructorcallmap”中提​​供的地图，如果发现了错误。\r\n \r\n 注意：“ constructorcallmap”正在通过这种方法突变\r\n \r\n","day of the month (2 digits)":"每月的一天（2位数字）\r\n","\r\n Returns a copy of this with the AddHandlerOrRemoveHandlerKeyword property\r\n changed to the specified value. Returns this instance if the specified value is\r\n the same as the current value.\r\n ":"\r\n 用Addhandlerorremovehandlerkeyword属性返回此副本\r\n 更改为指定值。如果指定的值为\r\n 与当前值相同。\r\n \r\n","\r\n A SubOrFunctionBodyBinder provides context for looking up parameters/labels in a body of an executable entity (a method, lambda, or top-level script code), \r\n and also for the implementation of ContainingMember, GetLocalForFunctionValue and GetBinder. \r\n ":"\r\n 一个子功能Bodybinder提供了在可执行实体（方法，lambda或顶级脚本代码）中查找参数/标签的上下文，\r\n 并用于实施包含的围栏，getLocalforFunctionValue和GetBinder。\r\n \r\n","\r\n  Looks up a localized string similar to Statement is not valid in a namespace..\r\n":"\r\n  在名称空间中查找类似于语句的本地化字符串。\r\n\r\n","\r\n Parse a type name.\r\n ":"\r\n 解析类型名称。\r\n \r\n"," Adds a symbol to the collection of referenced embedded symbols ":" 在引用的嵌入式符号的集合中添加符号\r\n","Deleting {0} around an active statement requires restarting the application.":"围绕活动语句删除{0}需要重新启动应用程序。\r\n","\r\n            Get's the ":"\r\n            得到\r\n","{0} can be simplified":"{0}可以简化\r\n","\r\n            Inherited interface for interface. Shown as I↑\r\n            ":"\r\n            接口的继承接口。显示为↑\r\n            \r\n"," or an empty array if there are no attributes.":" 或一个空数组，如果没有属性。\r\n","\r\n  Looks up a localized string similar to 'Case' can only appear inside a 'Select Case' statement..\r\n":"\r\n  查找类似于“案例”的本地化字符串只能出现在“选择案例”语句中。\r\n\r\n","Avoid legacy format target in 'SuppressMessageAttribute'":"避免在“抑制messageattribute”中进行遗产格式目标\r\n","\r\n  Looks up a localized string similar to 'NonSerialized' attribute will not have any effect on this member because its containing class is not exposed as 'Serializable'..\r\n":"\r\n  查找类似于“非序列化”属性的本地化字符串对此成员不会产生任何影响，因为其包含的类并未公开为“可序列化”。\r\n\r\n","\r\n If this method is a reduced extension method, gets the extension method (possibly constructed) that\r\n should be used at call site during ILGen. Otherwise, returns Nothing.\r\n ":"\r\n 如果此方法是减少的扩展方法，请获取扩展方法（可能构造）\r\n 应在伊尔根期间在呼叫站点使用。否则，什么都没有。\r\n \r\n","\r\n            Returns the text changes necessary to format the document on paste operation.\r\n            ":"\r\n            返回文本更改所需的更改，以格式化粘贴操作的文档。\r\n            \r\n","The token to get the complexification target for.":"令牌以获取综合目标。\r\n"," is expected to be an absolute path of an existing file.\r\n            ":" 预计将是现有文件的绝对路径。\r\n            \r\n","\r\n A type can me marked as a Windows runtime type in source by applying the WindowsRuntimeImportAttribute.\r\n WindowsRuntimeImportAttribute is a pseudo custom attribute defined as an internal class in System.Runtime.InteropServices.WindowsRuntime namespace.\r\n This is needed to mark Windows runtime types which are redefined in mscorlib.dll and System.Runtime.WindowsRuntime.dll.\r\n These two assemblies are special as they implement the CLR's support for WinRT.\r\n ":"\r\n 通过应用WindowsRuntimeImportAttribute，可以将我标记为Windows运行时类型的类型。\r\n WindowsRuntimeImportAttribute是一种伪自定义属性，该属性定义为System.Runtime.InterOpservices.windowsruntime namespace中的内部类。\r\n 这是在mscorlib.dll和system.runtime.windowsruntime.dll中重新定义的Windows运行时类型所需的。\r\n 这两个组件是特殊的，因为它们实施了CLR对WINRT的支持。\r\n \r\n","\r\n Represents a parameters declared in source, that is not optional, does not have a default value, \r\n attributes, or is a ParamArray. This is a separate class to save memory, since there are LOTS\r\n of parameters.\r\n ":"\r\n 表示源中声明的参数，这不是可选的，没有默认值，\r\n 属性，或者是paramarray。这是一个单独的类，可以节省内存，因为有很多\r\n 参数。\r\n \r\n","\r\n Kind of Handles event container. (Me, MyBase, MyClass or a WithEvents variable)\r\n ":"\r\n 一种处理事件容器。 （我，mybase，myclass或withevents变量）\r\n \r\n","\r\n  Looks up a localized string similar to Only one of 'NotOverridable', 'MustOverride', or 'Overridable' can be specified..\r\n":"\r\n  可以指定一个类似于“俯瞰力”，“ Mustoverride”或“不适当”的局部字符串。\r\n\r\n","\r\n Gets corresponding special TypeId of this type.\r\n ":"\r\n 获得此类型的相应特殊类型。\r\n \r\n","\r\n            True if the extract method operation is possible if the original span is adjusted.\r\n            ":"\r\n            如果可以调整原始跨度，则可以使用提取方法操作。\r\n            \r\n","The syntax node provided via ":"通过\r\n","\r\n  Looks up a localized string similar to Classes can inherit only from other classes..\r\n":"查找类似于类的本地化字符串只能从其他类中继承。\r\n\r\n","\r\n The argument to the aggregation function.\r\n ":"\r\n 集合函数的参数。\r\n \r\n","\r\n            Returns the index of the first non-whitespace trivia in the given trivia list.\r\n            ":"\r\n            在给定的琐事列表中返回第一个非偏视琐事的索引。\r\n            \r\n","\r\n  Looks up a localized string similar to Keyword is not valid as an identifier..\r\n":"\r\n  查找类似于关键字的本地化字符串无效作为标识符。\r\n\r\n","Use local version '{0}'":"使用本地版本'{0}'\r\n","\r\n            Returns null for nodes that don't represent declarations.\r\n            ":"\r\n            返回不代表声明的节点的null。\r\n            \r\n","\r\n            Represents the current Processor architecture.\r\n            ":"\r\n            代表当前的处理器体系结构。\r\n            \r\n","Change to cast":"更改为铸造\r\n","\r\n            List of tuples of possible actions that can be used to transform the code the TextSpan within the original document they're applicable to.\r\n            ":"\r\n            可能用于转换其适用的原始文档中文本范围的代码的可能动作的列表。\r\n            \r\n"," makes multiple calls\r\n to this function, only one result is observable.\r\n ":" 拨打多个电话\r\n 对于此功能，只能观察到一个结果。\r\n \r\n"," \r\n            should be in ":" \r\n            应该进来\r\n"," code style options.\r\n            ":" 代码样式选项。\r\n            \r\n","An in parameter cannot have the Out attribute.":"一个IN参数不能具有OUT属性。\r\n","\r\n Gets symbol information about an attribute syntax node. This is the worker\r\n function that is overridden in various derived kinds of Semantic Models. It can assume that \r\n CheckSyntaxNode has already been called.\r\n ":"\r\n 获取有关属性语法节点的符号信息。这是工人\r\n 在各种派生的语义模型中被覆盖的函数。它可以假设\r\n checksyntaxnode已被调用。\r\n \r\n","\r\n  Looks up a localized string similar to 'From' expected..\r\n":"\r\n  查找类似于“预期”的局部字符串。\r\n\r\n","\r\n A using statement of the form:\r\n      using Expression\r\n          list_of_statements\r\n      end using\r\n\r\n will be rewritten into:\r\n\r\n      temp = Expression\r\n      Try\r\n          list_of_statements\r\n      Finally\r\n          If Temp IsNot Nothing Then\r\n              CType(temp, IDisposable).Dispose()\r\n          End If\r\n      End Try\r\n\r\n when the resource is a using locally declared variable no temporary is generated but the variable is read-only\r\n A using statement of the form:\r\n      Using v As New MyDispose()\r\n          list_of_statements\r\n      End Using\r\n\r\n is rewritten to:\r\n \r\n      Dim v As New MyDispose()\r\n      Try\r\n         list_of_statements\r\n      Finally\r\n          If v IsNot Nothing Then\r\n              CType(v, IDisposable).Dispose()\r\n          End If\r\n      End Try\r\n\r\n A using with multiple variable resources are equivalent to a nested using statement.\r\n So a using statement of the form:\r\n      Using v1 As New MyDispose(), v2 As myDispose = New MyDispose()\r\n          list_of_statements\r\n      end using\r\n\r\n is rewritten to:\r\n      Dim v1 As New MyDispose\r\n      Try\r\n          Dim v2 As MyDispose = new MyDispose()\r\n          Try\r\n              list_of_statements\r\n          Finally\r\n              If v2 IsNot Nothing Then\r\n                  CType(v2, IDisposable).Dispose()\r\n              End If\r\n          End Try\r\n      Finally\r\n          If v1 IsNot Nothing Then\r\n              CType(v1, IDisposable).Dispose()\r\n          End If\r\n      end try\r\n":"\r\n 表格的使用语句：\r\n      使用表达式\r\n          list_of_statement\r\n      结束使用\r\n\r\n 将被改写为：\r\n\r\n      temp =表达\r\n      尝试\r\n          list_of_statement\r\n      最后\r\n          如果温度不是什么都没有的\r\n              ctype（temp，idisposable）.dispose（）\r\n          万一\r\n      结束尝试\r\n\r\n 当资源是使用本地声明的变量时，不会生成临时性，但该变量仅读取\r\n 表格的使用语句：\r\n      使用V作为新的myDispose（）\r\n          list_of_statement\r\n      结束使用\r\n\r\n 被重写为：\r\n \r\n      DIM V为新的myDispose（）\r\n      尝试\r\n         list_of_statement\r\n      最后\r\n          如果v不会什么都没有\r\n              ctype（v，idisposable）.dispose（）\r\n          万一\r\n      结束尝试\r\n\r\n 与多变量资源一起使用的A相当于使用语句的嵌套。\r\n 因此，表格的使用声明：\r\n      使用v1作为新的mydispose（），v2作为mydispose = new mydispose（）\r\n          list_of_statement\r\n      结束使用\r\n\r\n 被重写为：\r\n      DIM V1作为新的mydispose\r\n      尝试\r\n          dim v2 as mydispose = new mydispose（）\r\n          尝试\r\n              list_of_statement\r\n          最后\r\n              如果v2没有什么，那么\r\n                  ctype（v2，idisposable）.dispose（）\r\n              万一\r\n          结束尝试\r\n      最后\r\n          如果v1不算什么\r\n              ctype（v1，idisposable）.dispose（）\r\n          万一\r\n      结束尝试\r\n\r\n"," Bound node defining the root of the bound subtree to be analyzed ":" 定义绑定子树的根的结合节点要分析\r\n","\r\n            Formats the span between the opening and closing points, options permitting.\r\n            Returns the text changes that should be applied to the input document to \r\n            get the formatted text and the end of the close curly brace in the formatted text.\r\n            ":"\r\n            格式化开口和关闭点之间的跨度，选项允许。\r\n            将应应用于输入文档应用于输入文档的文本更改返回\r\n            在格式化的文本中获取格式化的文本和近卷式支架的末端。\r\n            \r\n","\r\n The visitor which searches for a bound node inside a bound subtree\r\n ":"\r\n 搜索绑定子树内的绑定节点的访问者\r\n \r\n","\r\n Compute the type flags from the declaration.\r\n This function DOES NOT diagnose errors in the modifiers. Given the set of modifiers,\r\n it produces the flags, even in the case of potentially conflicting modifiers. We have to\r\n return some answer even in the case of errors.\r\n ":"\r\n 计算声明中的类型标志。\r\n 此功能不会诊断修饰符中的错误。给定一组修饰符\r\n 即使在可能发生冲突的修饰符的情况下，它也会产生旗帜。我们必须\r\n 即使发生错误，也要返回一些答案。\r\n \r\n","\r\n            Provides mutual code action logic for both local and LSP scenarios\r\n            via intermediate interface ":"\r\n            为本地和LSP方案提供共同的代码操作逻辑\r\n            通过中间接口\r\n","\r\n            The source languages this provider can provide fixes for.  See ":"\r\n            该提供商可以为修复程序提供的源语言。看\r\n","\r\n Returns a copy of this with the XmlNamespace property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中XMLNamespace属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Detects situations when a type participates in a dependency loop\r\n And generates appropriate diagnostics.\r\n No diagnostics means there was no loop\r\n ":"\r\n 检测类型参与依赖项循环的情况\r\n 并产生适当的诊断。\r\n 没有诊断意味着没有循环\r\n \r\n","\r\n Returns True for ":"\r\n 返回为\r\n","\r\n Trivia nodes represents parts of the program text that are not parts of the\r\n syntactic grammar, such as spaces, newlines, comments, preprocessors\r\n directives, and disabled code.\r\n ":"\r\n 琐事节点代表程序文本的一部分，这些部分不是\r\n 句法语法，例如空格，新线，评论，预处理器\r\n 指令和禁用代码。\r\n \r\n","\r\n            Indicates the reference should be marked as unused\r\n            ":"\r\n            表示参考应标记为未使用\r\n            \r\n","\r\n This is the base class for all XML expression syntax nodes (XmlDocument and\r\n XmlElement).\r\n ":"\r\n 这是所有XML表达语法节点的基类（xmldocument和\r\n xmlelement）。\r\n \r\n","A non-null member on an interface type.":"接口类型上的非壁成员。\r\n","\r\n  Looks up a localized string similar to '{0}' is not valid on an event declaration..\r\n":"\r\n  在事件声明中查找类似于“ {0}”的本地化字符串。\r\n\r\n","\r\n            Get a multi-Dictionary stores the information about the target of all alias Symbol in the syntax tree.\r\n            Multiple aliases might live under same namespace.\r\n            Key is the namespace of the symbol, value is the name of the symbol.\r\n            ":"\r\n            获取多种形式存储有关语法树中所有别名符号的目标的信息。\r\n            多个别名可能生活在同一名称空间下。\r\n            关键是符号的名称空间，值是符号的名称。\r\n            \r\n","\r\n Adjusts receiver of a call or a member access if the receiver is an\r\n ambiguous BoundTypeOrValueExpression. This can only happen if the\r\n receiver is the LHS of a member access expression in which the\r\n RHS cannot be resolved (i.e. the RHS is an error or a late-bound\r\n invocation/access).\r\n ":"\r\n 如果接收器为\r\n 模棱两可的边界表达。只有在\r\n 接收器是成员访问表达式的LHS\r\n RHS无法解决（即RHS是错误或后期的\r\n 调用/访问）。\r\n \r\n","\r\n Convert a symbol to an array of string parts, each of which has a kind. Useful for\r\n colorizing the display string.\r\n ":"\r\n 将符号转换为一个串件零件，每个符号都有一种。对...有用\r\n 将显示字符串着色。\r\n \r\n","10ths of a second (non-zero)":"十分之一（非零）\r\n","\r\n The \"As\" clause that describes the return type. If no As clause was present,\r\n Nothing is returned.\r\n ":"\r\n 描述返回类型的“ AS”子句。如果没有作为条款，\r\n 什么都没有返回。\r\n \r\n","\r\n Represents a declaration of a Structure, its contents and the End statement\r\n that ends it.\r\n ":"\r\n 代表结构，其内容和最终语句的声明\r\n 结束了。\r\n \r\n","A cancellation token that can be used to cancel the\r\n process of obtaining the diagnostics.":"取消令牌，可用于取消\r\n 获得诊断的过程。\r\n","Convert to binary":"转换为二进制\r\n"," visitor that visits only the single SyntaxNode\r\n passed into its ":" 仅访问单个语法的访客\r\n 进入它\r\n","A character position used to identify a declaration scope and accessibility. This\r\n character position must be within the FullSpan of the Root syntax node in this SemanticModel. In order to obtain\r\n the correct scoping rules for the attribute, position should be the Start position of the Span of the symbol that\r\n the attribute is being applied to.\r\n ":"用于标识声明范围和可访问性的角色位置。这个\r\n 字符位置必须在此semanticmodel中的root语法节点的成面内。为了得到\r\n 属性的正确范围规则，位置应为符号跨度的开始位置\r\n 该属性正在应用于。\r\n \r\n","\r\n  Looks up a localized string similar to 'ByRef' parameter '{0}' cannot be used in a query expression..\r\n":"\r\n  在查询表达式中查找类似于“ byref” parameter'{0}'的本地化字符串。\r\n\r\n","Matches a carriage-return character, \\u000D.  Note that \\r is not equivalent to the newline character, \\n.":"匹配一个回收字符\\ u000d。请注意，\\ r不等于newline字符\\ n。\r\n","\r\n Returns ConstantValue.Bad if, and only if, compound string length is out of supported limit.\r\n The ":"返回ConstantValue.bad，并且只有当复合字符串长度超出受支持的限制时。\r\n 这\r\n","Remove suppression operators":"删除抑制操作员\r\n","Not all code paths return":"并非所有代码路径返回\r\n","\r\n  Looks up a localized string similar to 'Option Compare' must be followed by 'Text' or 'Binary'..\r\n":"\r\n  查找类似于“选项比较”的本地化字符串，后跟“文本”或“二进制”。\r\n\r\n","\r\n The ArraySizeInitializationModifier.\r\n ":"\r\n 阵列InizeInitializationModifier。\r\n \r\n","\r\n            Will be one of the values from ":"\r\n            将是来自\r\n","\r\n Possible create the array version of type, given the element type and the array modifier syntax.\r\n ":"\r\n 给定元素类型和数组修饰符语法创建类型的数组版本。\r\n \r\n","\r\n Returns a copy of this with the Expressions property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而表达式属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","The directory to use to store file copies.":"用于存储文件副本的目录。\r\n","\r\n  Looks up a localized string similar to 'AddHandler' and 'RemoveHandler' method parameters cannot be declared 'ByRef'..\r\n":"\r\n  查找类似于“ Addhandler”和“ RemoveHandler”方法参数的本地化字符串，无法声明为“ Byref”。\r\n\r\n","\r\n Returns aggregate function associated with FunctionAggregationSyntax.\r\n ":"返回与functionAggregationsyntax关联的聚合函数。\r\n \r\n","\r\n Some simple sanity checks if a property can actually be a withevents property\r\n ":"\r\n 一些简单的理智检查物业是否真的可以是事件属性\r\n \r\n","\r\n Gets the semantic information of an Await expression.\r\n ":"\r\n 获取等待表达的语义信息。\r\n \r\n","\r\n Derived from C# Dev10's BSYMMGR::UnifyTypes.\r\n Two types will not unify if they have different custom modifiers.\r\n ":"\r\n 源自C＃DEV10的BSYMMGR :: UNIFYTYPES。\r\n 如果有不同的自定义修饰符，则两种类型将不统一。\r\n \r\n","\r\n Gets the available named symbols in the context of the specified location And optional container. Only\r\n symbols that are accessible And visible from the given location are returned.\r\n ":"\r\n 在指定位置和可选容器的上下文中获取可用的命名符号。仅有的\r\n 从给定位置可访问和可见的符号将返回。\r\n \r\n","\r\n            Formats an array type name (vector or multidimensional).\r\n            ":"\r\n            格式为数组类型名称（向量或多维名称）。\r\n            \r\n","\r\n  Looks up a localized string similar to Operator '{0}' is not defined for types '{1}' and '{2}'..\r\n":"\r\n  查找类似于运算符'{0}'的本地化字符串，未针对类型'{1}'和'{2}'..定义\r\n\r\n","\r\n            Builds a delegate that will execute just this scripts code.\r\n            ":"\r\n            建立一个将仅执行此脚本代码的委托。\r\n            \r\n","\r\n  Looks up a localized string similar to Anonymous type member or property '{0}' is already declared..\r\n":"\r\n  查找类似于匿名类型成员或属性'{0}'的本地化字符串。\r\n\r\n","\r\n Is System.Runtime.InteropServices.ClassInterfaceAttribute applied to this type in code.\r\n ":"\r\n IS System.Runtime.InterOpservices.ClassInterfaceAttribute在代码中应用于此类型。\r\n \r\n","\r\n Bind body of a lambda representing first Select operator selector for an aggregate clause in context of this binder.\r\n ":"\r\n 在此粘合剂的上下文中，将lambda的主体绑定代表骨料子句的第一个选择操作符选择器。\r\n \r\n","\r\n Represents a Get or Set accessor on a property declaration or an AddHandler,\r\n RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of\r\n the node determines what kind of accessor this is. This statement is always the\r\n Begin of a BlockNode, and the body of the accessor is the Body of that node.\r\n ":"\r\n 代表属性声明或加法勒的GET或设置访问者，\r\n 在自定义事件声明中删除Handhandler或Raiseevent访问者。那种\r\n 节点确定这是哪种访问者。这个陈述始终是\r\n 开始一个blockNode，登录器的主体是该节点的主体。\r\n \r\n","\r\n WithEvents property accessor.\r\n ":"\r\n with Events Property Concector。\r\n \r\n","\r\n Binds constant initialization value of the field.\r\n ":"\r\n 绑定场的常数初始化值。\r\n \r\n","\r\n             No overload for method 'X' takes 'N' arguments\r\n            ":"\r\n             方法“ x” take'n'参数没有超载\r\n            \r\n","coalescing assignment":"合并任务\r\n","\r\n            Raised when a text buffer that's not part of a workspace is changed.\r\n            ":"\r\n            当更改不属于工作空间的文本缓冲区时，会提出。\r\n            \r\n","\r\n            The tagged parts to display for this item. If default, the line of text from ":"\r\n            该项目显示的标记零件。如果默认，则来自\r\n","\r\n            Optional fix all context, which is non-null if the given ":"\r\n            可选修复所有上下文，如果给定\r\n","\r\n            Return all diagnostics that belong to given project for the given StateSets (analyzers) either from cache or by calculating them\r\n            ":"\r\n            从缓存或通过计算，返回给定状态集（分析仪）给定项目（分析仪）给定项目的所有诊断\r\n            \r\n","\r\n Represents a Throw statement.\r\n ":"\r\n 代表一个投掷声明。\r\n \r\n","Starting assembly.":"开始组装。\r\n","Display name or path cannot be empty.":"显示名称或路径不能为空。\r\n","\r\n The value for the SubOrFunctionHeader property.\r\n ":"\r\n subfunctionheader属性的值。\r\n \r\n","\r\n This function classifies user-defined conversions between two types.\r\n ":"\r\n 此功能将两种类型之间的用户定义转换进行分类。\r\n \r\n","\r\n            The kind of symbol containing the reference location (such as type, method, property, etc.)\r\n            ":"\r\n            包含参考位置的符号（例如类型，方法，属性等）\r\n            \r\n","Async-iterator '{0}' has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable<>.GetAsyncEnumerator' will be un ...":"异步 - 列表'{0}'具有一个或多个类型的“ cancellationToken”类型的参数，但它们都没有用“ EnumeratorCancellation”属性装饰，因此从生成的“ iasyncencenncenumossent <> getAsyncencenumerator”中的取消令牌参数是Un的。 ..\r\n","\r\n            nested class of ":"\r\n            嵌套类\r\n","\r\n Returns a copy of this with the ReferenceKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此的副本，其中参考键属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n A list of all attribute lists on this declaration. If no attributes were\r\n specified, Nothing is returned.\r\n ":"\r\n 此声明中的所有属性列表的列表。如果没有属性\r\n 指定，什么都没有返回。\r\n \r\n","\r\n Creates a symbol for a method that wraps the call to a method through MyBase/MyClass receiver.\r\n ":"为通过mybase/myclass接收器包装呼叫的方法创建一个符号。\r\n \r\n"," is a colon trivia whose string representation is the COLON (U+003A) character from ASCII range\r\n (specifically excluding cases when it is the FULLWIDTH COLON (U+FF1A) character).\r\n See also: http://fileformat.info/info/unicode/char/FF1A\r\n ":" 是一个结肠琐事，其弦乐表示是ASCII范围的结肠（U+003A）\r\n （特别是当它是全宽结肠（u+ff1a）字符的情况下）。\r\n 另请参阅：http：//fileformat.info/info/unicode/char/ff1a\r\n \r\n","\r\n Bind a basic name to a type or namespace.\r\n ":"\r\n 将基本名称绑定到类型或名称空间。\r\n \r\n","\r\n BoundExpressions to be used for emit. The expressions are assumed\r\n to be lowered and will not be visited by ":"\r\n 用于发射的绑定表达式。假定表达式\r\n 要降低，不会被访问\r\n","the innermost node that contains the span":"包含跨度的最内向节点\r\n","\r\n            See https://github.com/dotnet/roslyn/issues/7536.  IDE should not be analyzing and reporting\r\n            compiler diagnostics for normal constructs.  However, the compiler does not report issues\r\n            for incomplete members.  That means that if you just have `public DateTime` that that is counted \r\n            as an incomplete member where no binding happens at all.  This means that features like 'add import'\r\n            won't work here to offer to add `using System;` if that is all that is written.  \r\n            ":"\r\n            请参阅https://github.com/dotnet/roslyn/issues/7536。 IDE不应分析和报告\r\n            正常结构的编译器诊断。但是，编译器不报告问题\r\n            对于不完整的成员。这意味着，如果您只有“公共dateTime”\r\n            作为根本没有绑定的不完整成员。这意味着诸如“添加导入”之类的功能\r\n            在这里不工作以添加`````'''';\r\n            \r\n","Filter expression is a constant 'false'":"滤波器表达是常数的“ false”\r\n","operator":"操作员\r\n","The token to test. This token must be parented by a SyntaxNode.":"代币进行测试。该令牌必须由语法句归属。\r\n","The \"d\" standard format specifier represents a custom date and time format string that is defined by a specific culture's DateTimeFormatInfo.ShortDatePattern property. For example, the custom format string that is returned by the ShortDatePattern property  ...":"“ D”标准格式指定符表示由特定文化的dateTimeFormatInfo.shortdatePattern属性定义的自定义日期和时间格式字符串。例如，由ShortdatePattern属性返回的自定义格式字符串...\r\n","\r\n The Loop statement that begins a Do-Loop block.\r\n ":"\r\n 开始一个do-loop块的循环语句。\r\n \r\n"," \r\n Returns a bound node for left part of dictionary access node with omitted left syntax. \r\n In particular it handles dictionary access inside With statement.\r\n \r\n By default the method delegates the work to it's containing binder or returns Nothing.\r\n ":" \r\n 返回字典访问节点左侧的界点，并使用省略的左语法返回。\r\n 特别是它可以处理语句内部的字典访问。\r\n \r\n 默认情况下，该方法将工作委托给包含粘合剂或什么都没有返回。\r\n \r\n","\r\n True if Option Compare Text is in effect. False if Option Compare Binary is in effect.\r\n ":"\r\n 如果选项比较文本有效，则为正确。 false如果选项比较二进制有效。\r\n \r\n","\r\n            { A=true, B=false, C=new int[3] { 1, 2, 3 } }\r\n            ":"\r\n            {a = true，b = false，c = new int [3] {1，2，3}}\r\n            \r\n","checked statement":"检查的语句\r\n","\r\n The value for the QuestionMarkToken property.\r\n ":"\r\n 问题标记属性的价值。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}.{1}' is not accessible in this context because it is '{2}'..\r\n":"\r\n  在此上下文中查找类似于'{0}。{1}'的本地化字符串，因为它是'{2}'..\r\n\r\n","\r\n Represents a single punctuation mark or operator in a VB program. Which one can\r\n be determined from the Kind property.\r\n ":"\r\n 代表VB程序中的单个标点标记或操作员。哪一个可以\r\n 可以从类似属性确定。\r\n \r\n","\r\n Creates the syntax representation of a named xml element within xml documentation comments.\r\n ":"\r\n 在XML文档注释中创建命名XML元素的语法表示。\r\n \r\n","\r\n Clone the property parameters for the accessor method. The\r\n parameters are cloned (rather than referenced from the property)\r\n since the ContainingSymbol needs to be set to the accessor.\r\n ":"\r\n 克隆访问器方法的属性参数。这\r\n 克隆参数（而不是从属性引用）\r\n 由于需要设置为登录器，因此要设置为登录器。\r\n \r\n","\r\n SpecialType.TypeId\r\n ":"专业type.typeid\r\n \r\n","Descriptive tags that may influence how the item is displayed.":"可能影响项目显示方式的描述性标签。\r\n","\r\n            The options used by this script.\r\n            ":"\r\n            此脚本使用的选项。\r\n            \r\n","Last expected token of the last statement in a submission.":"最后一次预期的是提交中最后一句话的代币。\r\n","The type to check compatibility for.":"检查兼容性的类型。\r\n","\r\n §11.8.1 Overloaded Method Resolution\r\n      3.\tNext, eliminate all members from the set that require narrowing conversions \r\n         to be applicable to the argument list, except for the case where the argument \r\n         expression type is Object.\r\n      4.\tNext, eliminate all remaining members from the set that require narrowing coercions \r\n         to be applicable to the argument list. If the set is empty, the type containing the \r\n         method group is not an interface, and strict semantics are not being used, the \r\n         invocation target expression is reclassified as a late-bound method access.\r\n         Otherwise, the normal rules apply.\r\n \r\n Returns amount of applicable candidates left.\r\n ":"\r\n §11.8.1超载方法分辨率\r\n      3.接下来，消除需要缩小转换的集合中的所有成员\r\n         适用于参数列表，除了参数\r\n         表达式类型是对象。\r\n      4.接下来，从需要缩小胁迫的集合中消除所有其余成员\r\n         适用于参数列表。如果集合为空，则包含\r\n         方法组不是接口，也没有使用严格的语义，\r\n         调用目标表达式被重新分类为后结合方法访问。\r\n         否则，适用正常规则。\r\n \r\n 退货剩余的适用候选人金额。\r\n \r\n","Command-line syntax error: '{0}' is not a valid value for the '{1}' option. The value must be of the form '{2}'.":"命令行语法错误：'{0}'不是“ {1}”选项的有效值。该值必须为'{2}'的形式。\r\n","\r\n Given a namespace declaration, get the corresponding type symbol.\r\n ":"\r\n 给定名称空间声明，获取相应的类型符号。\r\n \r\n","\r\n            Changes the direction the operator is pointing\r\n            ":"\r\n            改变操作员指向的方向\r\n            \r\n"," if this instance is not overridable; otherwise, ":" 如果此实例不足以剥夺；否则，\r\n","\r\n            'X' does not contain a definition for 'Y' and no extension method 'Y' accepting a first argument of type 'X' could be found (are you missing a using directive for 'System'?)\r\n            Specialized for WinRT\r\n            ":"\r\n            'x'不包含“ y”的定义，也不包含扩展方法“ y”接受类型的第一个参数，可以找到“ x”的第一个参数（您是否缺少使用“系统”指令？）\r\n            专门用于Winrt\r\n            \r\n","\r\n            Indicates the start of a code block.  The elements after ":"\r\n            指示代码块的开始。之后的元素\r\n","\r\n Scans a single piece of trivia\r\n ":"扫描一块琐事\r\n \r\n","\r\n            Determine the classification type for a given token.\r\n            ":"\r\n            确定给定令牌的分类类型。\r\n            \r\n","Fix typo '{0}'":"修复Typo'{0}'\r\n","\r\n Bind ExpressionRangeVariableSyntax in context of this binder.\r\n ":"\r\n 在此粘合剂的上下文中绑定表达式variablesyntax。\r\n \r\n",".  Note, except for the first\r\n            chunk, this cannot be of the form ":"。注意，除了第一个\r\n            大块，这不能是形式\r\n","Pattern-matching is not permitted for pointer types.":"对于指针类型，不允许进行图案匹配。\r\n","\r\n  Looks up a localized string similar to '{0}' cannot shadow a method declared 'MustOverride'..\r\n":"\r\n  查找类似于'{0}'的本地化字符串，无法遮盖声明的“ Mustoverride”的方法。\r\n\r\n","\r\n Derived class type.\r\n ":"\r\n 派生类型。\r\n \r\n","\r\n a link in a dependency chain\r\n it means that \"dependent\" is dependent on the rest of the chain.\r\n \"kind\" tells what kind of dependency this is.\r\n ":"\r\n 依赖链中的链接\r\n 它意味着\"依赖\"依赖于链的其余部分。\r\n \"善良\"讲述了这是一种什么样的依赖。\r\n \r\n","\r\n The list of attribute lists.\r\n ":"\r\n 属性列表。\r\n \r\n","Modifying the body of {0} requires restarting the application due to internal error: {1}":"修改{0}的主体需要由于内部错误而重新启动应用程序：{1}\r\n","\r\n  Looks up a localized string similar to 'Async' and 'Iterator' modifiers cannot be used together..\r\n":"\r\n  查找类似于“ async”和“迭代器”修饰符的局部字符串。\r\n\r\n","\r\n Holds information about a SourceType in a compact form.\r\n ":"\r\n 以紧凑的形式保存有关源型的信息。\r\n \r\n","Locals and parameters":"当地人和参数\r\n","\r\n Returns a copy of this with the EndSubOrFunctionStatement property changed to\r\n the specified value. Returns this instance if the specified value is the same\r\n as the current value.\r\n ":"\r\n 返回此副本，其中enduborFunctionStatement属性更改为\r\n 指定值。如果指定的值相同，则返回此实例\r\n 作为当前值。\r\n \r\n","The event symbol that was declared.":"宣布的事件符号。\r\n","\r\n            Overridden member for member in class or structure. Shown as O↑\r\n            ":"\r\n            在课堂或结构中覆盖成员的成员。显示为o↑\r\n            \r\n","The given expression always matches the provided pattern.":"给定的表达式始终与提供的模式匹配。\r\n","Filter expression is a constant 'false'.":"滤波器表达式是常数的“ false”。\r\n","\r\n            Reports rude edits when an active statement is a when clause in a switch statement and any of the switch cases or the switch value changed.\r\n            This is necessary since the switch emits long-lived synthesized variables to store results of pattern evaluations.\r\n            These synthesized variables are mapped to the slots of the new methods via ordinals. The mapping preserves the values of these variables as long as \r\n            exactly the same variables are emitted for the new switch as they were for the old one and their order didn't change either.\r\n            This is guaranteed if none of the case clauses have changed.\r\n            ":"\r\n            报告Rude编辑当活动语句是Switch语句中的子句以及任何交换机案例或开关值更改时。\r\n            这是必要的，因为开关会发出长寿命的合成变量以存储模式评估的结果。\r\n            这些合成的变量通过序数映射到新方法的插槽。映射只要保留这些变量的值\r\n            与旧开关相同的变量与旧开关相同，它们的订单也没有改变。\r\n            如果没有任何案例子句更改，则可以保证这一点。\r\n            \r\n","\r\n The Diagnostic class allows formatting of Visual Basic diagnostics. \r\n ":"\r\n 诊断类允许格式化视觉基本诊断。\r\n \r\n","\r\n            return trivia attached to namespace declaration. \r\n            Leading trivia of the node and trivia around opening brace, as well as\r\n            trivia around closing brace are concatenated together respectively.\r\n            ":"\r\n            附加在名称空间声明上的返回琐事。\r\n            在开放式支撑周围的节点和琐事的领导琐事以及\r\n            围绕闭合支架的琐事分别被串联在一起。\r\n            \r\n","Generate constant '{1}.{0}'":"生成常数'{1}。{0}'\r\n","\r\n Return all of the type arguments and their modifiers in this type and enclosing types,\r\n from outer-most to inner-most type.\r\n ":"\r\n 将所有类型参数及其修饰符返回此类型和封闭类型，\r\n 从最外部到最内部类型。\r\n \r\n","The whitespace to use for end of line":"用于线结束的空格\r\n","\r\n Bind the attribute in the context of the specified location and get semantic information\r\n such as type, symbols and diagnostics. This method is used to get semantic information about an attribute\r\n that did not actually appear in the source code.\r\n ":"在指定位置的上下文中绑定属性并获取语义信息\r\n 例如类型，符号和诊断。此方法用于获取有关属性的语义信息\r\n 实际上并未出现在源代码中。\r\n \r\n","\r\n Represents #Disable Warning pre-processing directive appearing in source.\r\n ":"\r\n 代表#disable警告预处理指令出现在源中。\r\n \r\n","\r\n Consumes current node and gets next one. \r\n ":"消耗当前节点并获得下一个节点。\r\n \r\n","The CallerArgumentExpressionAttribute will have no effect; it is overridden by the CallerLineNumberAttribute":"CallerArgumentExpresseprysattribute将无效；它被CallerlineNumberattribute覆盖\r\n","\r\n The flow analysis pass.  This pass reports required diagnostics for unreachable\r\n statements and uninitialized variables (through the call to FlowAnalysisWalker.Analyze).\r\n ":"\r\n 流量分析通过。该通行证报告需要诊断无法达到无法达到的诊断\r\n 陈述和非初始化的变量（通过呼叫FlowAlalysiswalker.Analyze）。\r\n \r\n","\r\n  Looks up a localized string similar to Attributes cannot be applied to local variables..\r\n":"\r\n  查找类似于属性的本地化字符串不能应用于本地变量。\r\n\r\n","\r\n Returns a copy of this with the BeginCDataToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，然后将其更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n The map that captures information about what assembly should be retargeted \r\n to what assembly. Key is the AssemblySymbol referenced by the underlying module,\r\n value is the corresponding AssemblySymbol referenced by the retargeting module, \r\n and corresponding retargeting map for symbols.\r\n ":"\r\n 捕获有关应该重新定位哪个组件的信息的地图\r\n 到什么组装。关键是基础模块引用的汇编符号\r\n 值是重新定位模块引用的相应汇编符号\r\n 以及符号的相应重新定位地图。\r\n \r\n","However, you must include a line-continuation character (_) when you specify assembly-level or module-level attributes.":"但是，当您指定汇编级别或模块级属性时，必须包括线路接口字符（_）。\r\n","\r\n            checks if style is preferred and the enforcement is not None.\r\n            ":"\r\n            检查样式是否是首选，执行不是没有。\r\n            \r\n","\r\n The value for the ElseIfStatement property.\r\n ":"\r\n Elseifstatement属性的值。\r\n \r\n","\r\n            'reference' is an ambiguous reference between 'identifier' and 'identifier'\r\n            ":"\r\n            “参考”是“标识符”和“标识符”之间的模棱两可的引用\r\n            \r\n","\r\n            Analyzer that reports diagnostics in strings that we know are regex text.\r\n            ":"\r\n            分析仪报告在字符串中诊断的分析仪，我们知道是正则文本。\r\n            \r\n","\r\n            Gets the appropriate ":"\r\n            得到适当的\r\n","\r\n Analyze data-flow within a set of contiguous statements.\r\n ":"\r\n 分析一组连续语句中的数据流。\r\n \r\n","\r\n            The set of projects that are referencing this metadata-index.  When this becomes empty we can dump the\r\n            index from memory.\r\n            ":"\r\n            引用此元数据指数的一组项目。当这变为空时，我们可以倾倒\r\n            内存索引。\r\n            \r\n","'{0}': Target runtime doesn't support covariant types in overrides. Type must be '{2}' to match overridden member '{1}'":"'{0}'：目标运行时不支持覆盖中的协变量类型。类型必须为'{2}'才能匹配覆盖成员'{1}'\r\n","\r\n Returns a copy of this with the Argument property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，参数属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n The expression being returned, if present.\r\n ":"\r\n 表达式被返回，如果存在。\r\n \r\n","\r\n Given query operator source, infer control variable type from available\r\n 'Select' methods. \r\n \r\n Returns inferred type or Nothing.\r\n ":"\r\n 给定查询操作员源，从可用的\r\n “选择”方法。\r\n \r\n 返回推断的类型或什么都不是。\r\n \r\n","\r\n  Looks up a localized string similar to 'And' expected..\r\n":"\r\n  查找类似于'和'预期的局部字符串。\r\n\r\n","\r\n  Looks up a localized string similar to '{0}' cannot be used as an attribute because it does not inherit from 'System.Attribute'..\r\n":"\r\n  查找类似于'{0}'的局部字符串不能用作属性，因为它不会从'system.attribute'..中继承。\r\n\r\n"," instance representing a missing file header starting at the specified\r\n            position.\r\n            ":" 表示从指定位置开始的缺少文件头的实例\r\n            位置。\r\n            \r\n","The formatting options to apply.  If Nothing Is passed, ":"要应用的格式选项。如果什么都没有通过，\r\n"," that aggregates completions from one or more ":" 从一个或多个汇总完成\r\n","The new root node to compare against":"与之比较的新根节点\r\n","\r\n True if the method has declarative security information (HasSecurity flags).\r\n ":"\r\n 如果该方法具有声明性安全信息（Hassecurity标志），则为正确。\r\n \r\n","\r\n Given a method statement syntax get the corresponding method symbol.\r\n ":"\r\n 给定的方法语句语法获取相应的方法符号。\r\n \r\n","\r\n Forces binding and decoding of attributes.\r\n ":"\r\n 属性结合和解码的力。\r\n \r\n"," to be committed. If false, the completion host will determine if and where the\r\n            commit character is inserted into the document.":" 承诺。如果是错误的，则完成主机将确定是否以及在哪里\r\n            提交字符插入文档。\r\n","\r\n Creates a binder for a source type declaration (the part of a type in a single\r\n type declaration. For partial types this include just one part). This includes the following binders:\r\n    BackstopBinder\r\n    SourceModuleBinder\r\n    TypesOfImportedNamespacesMembersBinder (for modules of project-level imported namespaces)\r\n    ImportedTypesAndNamespacesMembersBinder (for project-level imported namespaces and types)\r\n    SourceFileBinder\r\n    TypesOfImportedNamespacesMembersBinder (for modules of file-level imported namespaces)\r\n    ImportedTypesAndNamespacesMembersBinder (for file-level imported namespaces and types)\r\n    ImportAliasesBinder (for file-level import aliases)\r\n    NamespaceBinder... (for each namespace, starting at the global namespace)\r\n    NamedTypeBinder... (for each type, and nested type)\r\n ":"为源类型声明创建活页夹（单个类型的一部分\r\n 类型声明。对于部分类型，这仅包括一部分）。这包括以下粘合剂：\r\n    后脚手\r\n    Sourcemodulebinder\r\n    typesofimportednamespacespacesmembersbinder（用于项目级导入名称空间的模块）\r\n    importedtypesandnamespacessmembersbinder（用于项目级导入的名称空间和类型）\r\n    SourceFileBinder\r\n    typesofimportednamespacespacesmembersbinder（用于文件级导入名称空间的模块）\r\n    importedtypesandnamespacesmembersbinder（用于文件级导入的名称空间和类型）\r\n    Exufertaliasesbinder（用于文件级导入别名）\r\n    名称空间Binder ...（对于每个名称空间，从全局名称空间开始）\r\n    命名typebinder ...（每种类型，嵌套类型）\r\n \r\n","\r\n Returns a copy of this with the WarningKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中WatningKeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","Generate local '{0}'":"生成本地'{0}'\r\n","After a less-than sign (<) or before a greater-than sign (>) when you specify an attribute.":"在指定属性时，符号（<）或符号（>）大于符号（>>）之后。\r\n","\r\n            If the diagnostic is on a argument, the argument is considered to be the argument to fix.\r\n            There are some exceptions to this rule. Returning null indicates that the fixer needs\r\n            to find the relevant argument by itself.\r\n            ":"\r\n            如果诊断是在参数上，则该论点被认为是要解决的论点。\r\n            该规则有一些例外。返回null表示修复器需要\r\n            单独找到相关论点。\r\n            \r\n","PE symbols don't provide this information and always return Nothing.":"PE符号无法提供此信息，并且总是什么都不返回。\r\n","\r\n            A caller method of a callee\r\n            ":"\r\n            callee的呼叫者方法\r\n            \r\n"," Output (target expression, potential conversion type) pairs":" 输出（目标表达，潜在转换类型）对\r\n","\r\n            Returns the type declaration that contains a specified ":"返回包含指定的类型声明\r\n","Make local function 'static'":"使本地功能“静态”\r\n","\r\n Optimizes some runtime library calls through replacing them with a literal if possible.\r\n VB Spec 11.2 defines the following runtime functions as being constant:\r\n  - Microsoft.VisualBasic.Strings.ChrW\r\n  - Microsoft.VisualBasic.Strings.Chr, if the constant value is between 0 and 128\r\n  - Microsoft.VisualBasic.Strings.AscW, if the constant string is not empty\r\n  - Microsoft.VisualBasic.Strings.Asc, if the constant string is not empty\r\n ":"\r\n 如果可能的话，通过用文字替换它们来优化一些运行时库的调用。\r\n VB规格11.2将以下运行时函数定义为恒定：\r\n  -microsoft.visualbasic.strings.chrw\r\n  -microsoft.visualbasic.strings.chr，如果常数为0到128之间\r\n  -microsoft.visualbasic.strings.ascw，如果常数字符串不是空的\r\n  -microsoft.visualbasic.strings.asc，如果常数字符串不是空的\r\n \r\n","\r\n The boolean expression used for filtering.\r\n ":"\r\n 布尔表达式用于过滤。\r\n \r\n","\r\n Creates a singleton separated list.\r\n ":"\r\n 创建一个单身单独的列表。\r\n \r\n","\r\n            Creates a new parameter symbol paired with the original captured symbol for each captured variables.\r\n            ":"\r\n            创建一个新的参数符号与每个捕获变量的原始捕获符号配对。\r\n            \r\n","\r\n Returns the keyword indicating the kind of declaration being made: \"Sub\", \"Function\", \"Event\", \"Property\", etc. Does not return either the \"Declare\" or \"Delegate\" keywords.\r\n ":"\r\n 返回指示声明类型的关键字：“ sub”，“ function”，“ event”，“属性”等。不会返回“声明”或“委托”关键字。\r\n \r\n"," is \"A.B.C.D\", then\r\n            the relative namespace is \"C.D\".\r\n            - If ":" 是“ A.B.C.D”，然后\r\n            相对名称空间为“ c.d”。\r\n            - 如果\r\n"," keyword.\r\n            This is implemented separately, not as a keyword recommender as it contains extra logic for making container method async.\r\n            ":" 关键词。\r\n            这是单独实现的，不是作为关键字推荐人，因为它包含用于制作容器方法async的额外逻辑。\r\n            \r\n","\r\n  Looks up a localized string similar to Cannot inherit interface '{0}' because the interface '{1}' from which it inherits could be identical to interface '{2}' from which the interface '{3}' inherits for some type arguments..\r\n":"\r\n  查找类似于无法继承界面'{0}'的本地化字符串，因为它继承的接口'{1}'可以与interface'{2}'相同，从而从中从中从某种类型的界面'{3}'继承论点..\r\n\r\n","\r\n Generates the syntax representation of an xml text literal.\r\n ":"生成XML文本文字的语法表示。\r\n \r\n","Apply preferred 'using' placement preferences":"应用首选“使用”位置首选项\r\n","\r\n  Looks up a localized string similar to Constructor call is valid only as the first statement in an instance constructor..\r\n":"\r\n  查找类似于构造函数调用的本地化字符串仅作为实例构造函数中的第一个语句。\r\n\r\n","Roslyn.HostError":"Roslyn.Hosterror\r\n","The symbol for the pre-defined type or Nothing if the type is not defined in the core library":"如果未在核心库中定义类型，则预定义的类型的符号或什么都没有\r\n"," that represents the semantics of the script.\r\n            ":" 这代表了脚本的语义。\r\n            \r\n"," is a type parameter.\r\n            ":" 是类型参数。\r\n            \r\n","\r\n Tracks variables for which we have already reported a definite assignment error.  This\r\n allows us to report at most one such error per variable.\r\n ":"\r\n 跟踪我们已经报告了确定分配错误的变量。这个\r\n 允许我们最多报告每个变量的错误。\r\n \r\n","\r\n Verifies that declaration of a local symbol does not cause name clashes.\r\n ":"\r\n 验证声明本地符号不会引起名称冲突。\r\n \r\n","\r\n            We try to provide additional \"move file\" options if we can find existing folders that matches target namespace.\r\n            For example, if the target namespace is 'DefaultNamesapce.A.B.C', and there's a folder 'ProjectRoot\\A.B\\' already \r\n            exists, then will provide two actions, \"move file to ProjectRoot\\A.B\\C\\\" and \"move file to ProjectRoot\\A\\B\\C\\\".\r\n            ":"\r\n            如果我们可以找到与目标名称空间匹配的现有文件夹，我们会尝试提供其他“移动文件”选项。\r\n            例如，如果目标名称空间为“ DefaultNamesapce.A.B.C”，并且已经有一个文件夹'ProjectRoot \\ a.b \\'\r\n            存在，然后将提供两个操作：“将文件移至ProjectRoot \\ A.B \\ C \\”和“将文件移至ProjectRoot \\ A \\ B \\ C \\”。\r\n            \r\n","The type '{0}' may not be used as the target type of new()":"类型'{0}'不得用作新（）的目标类型\r\n","\r\n Creates the while statement for the for each rewrite\r\n ":"\r\n 为每个重写创建while语句\r\n \r\n","Use discarded local":"使用丢弃的本地\r\n","\r\n Gets a value indicating whether this instance is sub.\r\n ":"\r\n 获取一个指示此实例是否为sub的值。\r\n \r\n","Error reading debug information from the PDB.":"错误阅读PDB的调试信息。\r\n","Visual Basic":"视觉基本\r\n","This language element attempts to match one of two patterns depending on whether it can match an initial pattern.\r\n            \r\n            'expression' is the initial pattern to match, 'yes' is the pattern to match if expression is matched, and 'no' is the optional pattern to mat ...":"此语言元素试图匹配两种模式之一，具体取决于它是否可以匹配初始模式。\r\n            \r\n            “表达式”是匹配的初始模式，如果表达式匹配，则是匹配的模式，而'no'是可选的模式。\r\n","\r\n            Creates a ProjectInfo to represent the fake project created for metadata as source documents.\r\n            ":"\r\n            创建一个ProjectInfo来代表为元数据创建的假项目作为源文档。\r\n            \r\n","\r\n Get all the members of this symbol that are types.\r\n ":"\r\n 获取此符号的所有成员是类型。\r\n \r\n","\r\n Return the integer constant value (if any) from a BoundExpression\r\n ":"\r\n 从界表达返回整数常数（如果有）\r\n \r\n","A default literal 'default' is not valid as a pattern. Use another literal (e.g. '0' or 'null') as appropriate. To match everything, use a discard pattern '_'.":"默认的文字“默认值”无效作为模式。适当地使用另一个文字（例如'0'或'null'）。要匹配所有内容，请使用丢弃模式'_'。\r\n","\r\n Returns a copy of this with the CloseParenToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此的副本，而CloseParentken属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Create a BoundBadExpression node for the given child expression, which is preserved as a sub-expression. Symbols\r\n associated with the child node are not given a result kind.\r\n ":"\r\n 为给定的儿童表达式创建一个boundbadexpression节点，该节点被保留为子表达。符号\r\n 与儿童节点相关联的结果不给出结果。\r\n \r\n","\r\n A source field with an explicit initializer. In a declaration declaring multiple fields,\r\n such as \"Dim a, b, c = d\", this class is used for the first field only. (Other fields in\r\n the declaration are instances of SourceFieldSymbolSiblingInitializer.)\r\n ":"\r\n 具有显式初始化器的源字段。在声明多个字段的声明中，\r\n 例如“ Dim A，B，C = D”，此类仅用于第一个字段。 （其他字段\r\n 声明是SourceFieldSymbolsiitializer的实例。）\r\n \r\n","\r\n The value for the Cases property.\r\n ":"\r\n 案件属性的值。\r\n \r\n","record struct":"记录结构\r\n","variance safety for static interface members":"静态接口成员的差异安全性\r\n","Merge with previous '{0}' statement":"与以前的“ {0}”语句合并\r\n","TODO: free unmanaged resources (unmanaged objects) and override finalizer":"TODO：免费的非托管资源（非托管对象）和覆盖最终确定器\r\n"," array contains the given kind.\r\n ":" 数组包含给定的类型。\r\n \r\n","Set to true if there were multiple distinct spellings.":"如果有多个不同的拼写，则设置为true。\r\n","Use inferred member name":"使用推断的成员名称\r\n"," representing the specific kind of\r\n ResumeStatementSyntax. One of ResumeStatement, ResumeLabelStatement,\r\n ResumeNextStatement.\r\n ":" 代表特定种类\r\n RESUMEMETETTATEMENTSYNTAX。恢复，恢复标签的一种，\r\n 恢复。\r\n \r\n"," must lie within an existing method body of the Root syntax node for this SemanticModel.\r\n Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.\r\n ":" 必须位于该语法模型的根语法节点的现有方法中。\r\n 在这种现有方法主体中声明的当地人和标签不被认为是推测方法主体的范围。\r\n \r\n"," \r\n Draft substitute for With expression placeholder, is based on initial \r\n binding tree and is only to be used for warnings generation as well as \r\n for flow analysis and semantic API; real substitute will be re-calculated \r\n in lowering\r\n ":" \r\n 用表达占位符替代草案，是基于初始的\r\n 绑定树，仅用于警告生成和\r\n 用于流程分析和语义API；真正的替代品将被重新计算\r\n 降低\r\n \r\n","\r\n The \"D\" literal suffix denoting \"Decimal\"\r\n ":"\r\n “ D”字面后缀表示“十进制”\r\n \r\n","The triggering action.":"触发动作。\r\n","\r\n Returns a copy of this with the XmlKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中XMLKeyWord属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","s[start..end]":"s [start..end]\r\n","Corresponding type arguments.":"相应的类型参数。\r\n"," whose parameters\r\n            are a subset of the selected members by comparing name.\r\n            These constructors will not be considered as potential candidates:\r\n             - if the constructor's parameter list contains 'ref' or 'params'\r\n             - any constructor that has a params[] parameter\r\n             - deserialization constructor\r\n             - implicit default constructor\r\n            ":" 谁的参数\r\n            是通过比较名称所选成员的子集。\r\n            这些构造函数不会被视为潜在的候选对象:\r\n             -如果构造函数的参数列表包含'ref'或'params'\r\n             -任何具有params[]参数的构造函数\r\n             -反序列化构造函数\r\n             -隐式默认构造函数\r\n            \r\n","The receiver type '{0}' is not a valid record type and is not a struct type.":"接收器类型'{0}'不是有效的记录类型，也不是结构类型。\r\n","Partial method declarations have inconsistent nullability in constraints for type parameter":"部分方法声明在类型参数的约束中没有不一致的无效性\r\n","Add parentheses":"添加括号\r\n","Element names are not permitted when pattern-matching via 'System.Runtime.CompilerServices.ITuple'.":"通过'system.runtime.compilerservices.ituple'进行模式匹配时，不允许元素名称。\r\n","\r\n            Invalid tag helper bound property '{1}' on tag helper '{0}'. '{2}.{3}' must be null or empty if property has no public setter.\r\n            ":"\r\n            标签助手'{0}'上的无效标记助手绑定属性'{1}'。 '{2}。{3}'如果属性没有公共设置器，则必须为空或空。\r\n            \r\n","The regular expression construct \\P{ name } matches any character that does not belong to a Unicode general category or named block, where name is the category abbreviation or named block name.":"正则表达式构造\\ p {name}匹配任何不属于Unicode常规类别或命名块的字符，其中名称是类别缩写或命名块名称。\r\n","\r\n SyntaxNode.GetCorrespondingLambdaBody(SyntaxNode)\r\n ":"\r\n stytaxnode.getcorrespordinglambdabody（语法）\r\n \r\n","\r\n            Enumerates sorted object members to display.\r\n            ":"\r\n            列举排序的对象成员以显示。\r\n            \r\n"," representing the specific kind of\r\n StopOrEndStatementSyntax. One of StopStatement, EndStatement.\r\n ":" 代表特定种类\r\n stoporendStatementsyntax。停工之一，末端。\r\n \r\n","\r\n Gets a location for the specified text ":"\r\n 获取指定文本的位置\r\n","\r\n Add names of viable extension methods declared in this (compilation merged or module level) \r\n namespace to nameSet parameter.\r\n \r\n The 'appendThrough' parameter allows RetargetingNamespaceSymbol to delegate majority of the work \r\n to the underlying namespace symbol, but still perform viability check on RetargetingMethodSymbol.\r\n ":"\r\n 添加此中声明的可行扩展方法的名称（编译合并或模块级别）\r\n 名称空间到姓名参数。\r\n \r\n “附录”参数允许retargetingNamespaceSymbol委派大部分工作\r\n 到基础命名空间符号，但仍能对RetargetingMethodSymbol进行活跃性。\r\n \r\n","\r\n            All public methods of this type could be called from multiple threads.\r\n            ":"\r\n            这种类型的所有公共方法都可以从多个线程调用。\r\n            \r\n","Use framework type":"使用框架类型\r\n","Convert type to '{0}'":"将类型转换为'{0}'\r\n","\r\n  Looks up a localized string similar to 'AddHandler' is already declared..\r\n":"\r\n  查找类似于“ Addhandler”的本地化字符串已被声明。\r\n\r\n","\r\n Gets a reference to the source for this application of the attribute. Returns null for applications of attributes on metadata Symbols.\r\n ":"\r\n 获取属性此应用程序的来源的引用。返回元数据符号上属性应用的null。\r\n \r\n","Base classes contain inaccessible unimplemented members":"基础类包含无法访问的未完成成员\r\n","\r\n Represents the \"When ...\" clause of a \"Catch\" statement.\r\n ":"\r\n 表示“捕获”语句的“何时...”条款。\r\n \r\n"," characters.\r\n            \r\n             Importantly, this parser attempts to replicate diagnostics with almost the exact same text\r\n             as the native .NET regex parser.  This is important so that users get an understandable\r\n             experience where it appears to them that this is all one cohesive system and that the IDE\r\n             will let them discover and fix the same issues they would encounter when previously trying\r\n             to just compile and execute these regexes.\r\n             ":" 人物。\r\n            \r\n             重要的是，该解析器试图用几乎完全相同的文本复制诊断\r\n             作为本机.NET REGEX解析器。这很重要，以便用户获得可以理解的\r\n             在他们看来，这是一个凝聚力的系统，而IDE是一个凝聚力的系统\r\n             会让他们发现并解决以前尝试时遇到的相同问题\r\n             只是编译和执行这些正则。\r\n             \r\n","\r\n Given a position in the SyntaxTree for this SemanticModel returns the innermost Symbol\r\n that the position is considered inside of. \r\n ":"\r\n 在该语义模型的语法中给定一个位置，返回最内向的符号\r\n 该位置被认为是内部的。\r\n \r\n","s for the specific snapshot of ":"s用于特定快照\r\n","\r\n For example, parameters on delegate Invoke method are cloned to delegate BeginInvoke, EndInvoke methods. \r\n ":"\r\n 例如，将委托召开方法的参数克隆为委托开始，持续方法。\r\n \r\n","\r\n  Looks up a localized string similar to 'SyncLock' statement must end with a matching 'End SyncLock'..\r\n":"\r\n  查找类似于“ Synclock”语句的本地化字符串必须以匹配的“结束同步”的结尾。\r\n\r\n","\r\n Represents the XML declaration prologue in an XML literal expression.\r\n ":"\r\n 代表XML文字表达中的XML声明序言。\r\n \r\n","\r\n Return true if target BoundLiteral represents Nothing literal as defined by the language grammar.\r\n ":"\r\n 如果目标界限无表示语言语法定义的字面意义，则返回true。\r\n \r\n","\r\n            Signifies that the right operand is the constant.\r\n            ":"\r\n            表示正确的操作数是常数。\r\n            \r\n","\r\n            Convert an if statement to an else-if clause, discarding any of its else-if and else clauses.\r\n            ":"\r\n            将if语句转换为否则 - 如果子句，丢弃其任何else-if以及其他条款。\r\n            \r\n","Whether or not trivia is allowed on the next token\r\n            produced.  In the .NET parser trivia is only allowed on a few constructs,\r\n            and our parser mimics that behavior.  Note that even if trivia is allowed,\r\n            the type of trivia that can be scanned depends on the current RegexOptions.\r\n            For example, if ":"下一个令牌是否允许琐事\r\n            生产。在.NET解析器中，琐事仅在几个构造上允许\r\n            我们的解析器模仿了这种行为。请注意，即使允许琐事\r\n            可以扫描的琐事的类型取决于当前的regexoptions。\r\n            例如，如果\r\n","This field also serves as the lock object for updating both ":"该字段也是更新两者的锁定对象\r\n","\r\n            Represents a relational-pattern, constructed from relational operators\r\n            ":"\r\n            代表由关系运营商构建的关系模式\r\n            \r\n","Updating the modifiers of {0} requires restarting the application.":"更新{0}的修饰符需要重新启动应用程序。\r\n","\r\n  Looks up a localized string similar to The specified version string does not conform to the recommended format - major.minor.build.revision.\r\n":"\r\n  查找类似于指定版本字符串的本地化字符串不符合推荐格式-Major.minor.build.revision。\r\n\r\n","\r\n Creates the syntax representation of a permission element within xml documentation comments.\r\n ":"\r\n 在XML文档注释中创建权限元素的语法表示。\r\n \r\n","\r\n Attempts to fold unary operator applied to a constant expression. \r\n \r\n Returns Nothing if operator cannot be folded.\r\n \r\n If folding failed due to non-integer overflow, ConstantValue.Bad is returned. Consumer \r\n is responsible for reporting appropriate diagnostics.\r\n \r\n If integer overflow occurs, integerOverflow is set to True and ConstantValue for overflowed result is returned. \r\n Consumer is responsible for reporting appropriate diagnostics and potentially discarding the result.\r\n ":"\r\n 尝试折叠一元操作员的尝试应用于恒定表达式。\r\n \r\n 如果操作员无法折叠，则什么都没有返回。\r\n \r\n 如果折叠因非直集溢出而导致失败，则返回constantValue.bad。消费者\r\n 负责报告适当的诊断。\r\n \r\n 如果发生整数溢出，则将InteGerOverFlow设置为True，并且返回溢出结果的ConsentValue。\r\n 消费者负责报告适当的诊断并可能丢弃结果。\r\n \r\n","\r\n Represents an XML name of the form 'name' appearing in GetXmlNamespace().\r\n ":"\r\n 代表出现在getxmlnamespace（）中的'名称'的XML名称。\r\n \r\n","\r\n            Run a C# script and return its resulting value.\r\n            ":"\r\n            运行C＃脚本并返回其结果值。\r\n            \r\n","\r\n            Returns true if the given symbol meets the following criteria to be\r\n            a candidate for dead code analysis:\r\n                1. It is marked as \"private\".\r\n                2. It is not an implicitly declared symbol.\r\n                3. It is either a method, field, property or an event.\r\n                4. If method, then it is a constructor OR a method with ":"\r\n            如果给定的符号满足以下条件，则返回true\r\n            死代码分析的候选者:\r\n                1. 它被标记为\"私人\"。\r\n                2. 它不是隐式声明的符号。\r\n                3. 它是方法、字段、属性或事件。\r\n                4. 如果方法，那么它是一个构造函数或具有 \r\n","\r\n            Reference's span start based on the document content\r\n            ":"\r\n            参考的跨度启动基于文档内容\r\n            \r\n","\r\n Returns the list of member imports that apply to all syntax trees in this compilation.\r\n ":"\r\n 返回此编辑中适用于所有语法树的成员导入列表。\r\n \r\n","),\r\n            or null the unmapped document has not been determined (the active statement has not changed from the baseline).\r\n            ":"），\r\n            或尚未确定未限定的文档（主动语句尚未从基线更改）。\r\n            \r\n","\r\n The statements contained in the Using...End Using block. This might be an empty\r\n list.\r\n ":"\r\n 使用块中包含的语句包含...结束。这可能是空的\r\n 列表。\r\n \r\n","\r\n Checks for special member and reports diagnostics if the member is Nothing or has UseSiteError.\r\n Returns True in case diagnostics was actually reported\r\n ":"\r\n 检查特殊会员并报告诊断是否没有或有使用者。\r\n 如果实际上报告了诊断，则返回为true\r\n \r\n","\r\n Creates a new syntax based off this tree using a new source text.\r\n ":"\r\n 使用新的源文本在基于该树的基于此树的基础上创建新的语法。\r\n \r\n","\r\n            Display string for the Call Site column in the Change Signature dialog.\r\n            ":"\r\n            在“更改签名”对话框中显示呼叫站点列的字符串。\r\n            \r\n","Resolve conflict markers":"解决冲突标记\r\n","\r\n Import options of the compilation being built.\r\n ":"\r\n 构建汇编的导入选项。\r\n \r\n","The version of the PDB to read.":"PDB的版本要读取。\r\n","\r\n            Create a filter for extension methods from source.\r\n            The filter is a map from fully qualified type name to info of extension methods it contains.\r\n            ":"\r\n            从源创建一个用于扩展方法的过滤器。\r\n            该过滤器是从完全合格的类型名称到其包含的扩展方法的信息的地图。\r\n            \r\n",". However, if the user likes ":"。但是，如果用户喜欢\r\n","The containing workspace.":"包含工作空间。\r\n","\r\n Adds VB specific parts to the line directive map\r\n ":"\r\n 将VB特定零件添加到行指令地图\r\n \r\n","A lambda expression with attributes cannot be converted to an expression tree":"具有属性的lambda表达式无法转换为表达树\r\n","'if' statement can be simplified":"“如果”语句可以简化\r\n","\r\n  Looks up a localized string similar to 'Microsoft.VisualBasic.ComClassAttribute' cannot be applied to '{0}' because its container '{1}' is not declared 'Public'..\r\n":"\r\n  查找类似于“ Microsoft.visualbasic.comclassattribute”的本地化字符串，不能应用于'{0}'，因为其容器'{1}'未声明为'public'..\r\n\r\n"," methods.\r\n            Encapsulates all RPC logic as well as dispatching to the local service if the remote service is disabled.\r\n            THe facade is useful for targeted testing of serialization/deserialization of EnC service calls.\r\n            ":" 方法。\r\n            如果禁用了远程服务，则将所有RPC逻辑封装并分配到本地服务。\r\n            该外墙对于序列化/避难所呼叫的序列化测试非常有用。\r\n            \r\n","\r\n            Analyzer to report unused expression values and parameters:\r\n            It flags the following cases:\r\n                1. Expression statements that drop computed value, for example, \"Computation();\".\r\n                   These should either be removed (redundant computation) or should be replaced\r\n                   with explicit assignment to discard variable OR an unused local variable,\r\n                   i.e. \"_ = Computation();\" or \"var unused = Computation();\"\r\n                   This diagnostic configuration is controlled by language specific code style option \"UnusedValueExpressionStatement\".\r\n                2. Value assignments to locals/parameters that are never used on any control flow path,\r\n                   For example, value assigned to 'x' in first statement below is unused and will be flagged:\r\n                        x = Computation();\r\n                        if (...)\r\n                            x = Computation2();\r\n                        else\r\n                            Computation3(out x);\r\n                        ... = x;\r\n                   Just as for case 1., these should either be removed (redundant computation) or\r\n                   should be replaced with explicit assignment to discard variable OR an unused local variable,\r\n                   i.e. \"_ = Computation();\" or \"var unused = Computation();\"\r\n                   This diagnostic configuration is controlled by language specific code style option \"UnusedValueAssignment\".\r\n                3. Redundant parameters that fall into one of the following two categories:\r\n                    a. Have no references in the executable code block(s) for its containing method symbol.\r\n                    b. Have one or more references but its initial value at start of code block is never used.\r\n                       For example, if 'x' in the example for case 2. above was a parameter symbol with RefKind.None\r\n                       and \"x = Computation();\" is the first statement in the method body, then its initial value\r\n                       is never used. Such a parameter should be removed and 'x' should be converted into a local.\r\n                   We provide additional information in the diagnostic message to clarify the above two categories\r\n                   and also detect and mention about potential breaking change if the containing method is a public API.\r\n                   Currently, we do not provide any code fix for removing unused parameters as it needs fixing the\r\n                   call sites and any automated fix can lead to subtle overload resolution differences,\r\n                   though this may change in future.\r\n                   This diagnostic configuration is controlled by ":"\r\n            用于报告未使用的表达式值和参数的分析器:\r\n            它标志着以下情况:\r\n                1. 删除计算值的表达式语句，例如\"Computation();\"。\r\n                   这些应该被删除（冗余计算）或应该被替换\r\n                   使用显式赋值来丢弃变量或未使用的局部变量,\r\n                   即\"_=Computation();\"或\"var unused=Computation();\"\r\n                   此诊断配置由语言特定的代码样式选项\"UnusedValueExpressionStatement\"控制。\r\n                2. 值分配给从不在任何控制流路径上使用的局部/参数,\r\n                   例如，在下面的第一个语句中分配给'x'的值是未使用的，将被标记:\r\n                        x=计算();\r\n                        如果（。..)\r\n                            x=计算2();\r\n                        其他\r\n                            计算3(出x);\r\n                        ... =x;\r\n                   就像情况1一样。，这些应该被删除（冗余计算）或\r\n                   应替换为显式赋值以丢弃变量或未使用的局部变量,\r\n                   即\"_=Computation();\"或\"var unused=Computation();\"\r\n                   此诊断配置由语言特定的代码样式选项\"UnusedValueAssignment\"控制。\r\n                3. 属于以下两类之一的冗余参数:\r\n                    在可执行代码块中没有包含方法符号的引用。\r\n                    B.有一个或多个引用，但从不使用其在代码块开始时的初始值。\r\n                       例如，如果'x'在案例2的例子中。 上面是一个带有RefKind的参数符号。无\r\n                       并且\"x=Computation();\"是方法体中的第一个语句，然后是它的初始值\r\n                       永远不会使用。 这样的参数应该被删除，'x'应该被转换为本地。\r\n                   我们在诊断消息中提供了其他信息，以澄清上述两个类别\r\n                   如果包含方法是公共API，还可以检测并提及潜在的突破性更改。\r\n                   目前，我们不提供任何代码修复来删除未使用的参数，因为它需要修复\r\n                   呼叫站点和任何自动修复都可能导致微妙的过载分辨率差异,\r\n                   虽然这可能会在未来改变。\r\n                   此诊断配置由 \r\n","For testing purposes only (so that tests can pass in mock values)":"仅用于测试目的（因此测试可以通过模拟值传递）\r\n","\r\n Add all the tokens in this node and children to the build token list builder. While doing this, add any\r\n diagnostics not on tokens to the given diagnostic info list.\r\n ":"\r\n 将此节点中的所有令牌和儿童添加到构建令牌列表构建器中。在这样做时，添加任何\r\n 诊断不在给定诊断信息列表的令牌上。\r\n \r\n","\r\n Given an AggregationRangeVariableSyntax, get the corresponding symbol.\r\n ":"\r\n 给定一个聚合的variablesyntax，获取相应的符号。\r\n \r\n","\r\n This class represents a base class for compiler generated synthesized method symbols\r\n that must be emitted in the compiler generated PrivateImplementationDetails class.\r\n SynthesizedGlobalMethodBase symbols don't have a ContainingType, there are global to\r\n the containing source module and are Public Shared methods.\r\n ":"\r\n 该类代表编译器生成的合成方法符号的基类\r\n 必须在编译器生成的私有IMPLENTATIONDETAILS类中发出。\r\n 综合globalmethodbase符号没有含有包含的类型，有全球\r\n 包含源模块和公共共享方法。\r\n \r\n","\r\n Returns true if all arguments are of the specified kind and they are also missing.\r\n ":"\r\n 如果所有参数均为指定类型，并且也缺少返回。\r\n \r\n","\r\n If this property overrides another property (because it both had the Overrides modifier\r\n and there correctly was a property to override), returns the overridden property.\r\n ":"\r\n 如果此属性覆盖了另一个属性（因为它都具有覆盖机修饰符\r\n 正确地有一个覆盖物的财产），返回了被覆盖的财产。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' cannot override '{1}' because it is not accessible in this context..\r\n":"\r\n  查找类似于'{0}'不能覆盖'{1}'的本地化字符串，因为它在此上下文中无法访问。\r\n\r\n","\r\n The text of the identifier, not including the brackets or type character.\r\n ":"\r\n 标识符的文本，不包括括号或类型字符。\r\n \r\n",", the collection is enumerable (matches design pattern, IEnumerable \r\n or IEnumerable(Of T); otherwise (string or arrays) it's set to false.":"，该系列是枚举的（匹配设计模式，iEnumerable\r\n 或（t）;否则（字符串或数组）将其设置为false。\r\n","Stream is null.":"流是空的。\r\n","\r\n Returns a copy of this with the WhenNotNull property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，并使用nnotnull属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Get the state of Option Explicit for the code covered by this semantic model.\r\n This takes into effect both file-level \"Option Explicit\" statements and the project-level\r\n defaults.\r\n ":"\r\n 获取该语义模型所涵盖的代码的选项状态。\r\n 这可以生效文件级“选项equallicit”语句和项目级别\r\n 默认。\r\n \r\n","\r\n Return the member imports for this file.\r\n Doesn't contain error types.\r\n ":"\r\n 返回该文件的成员导入。\r\n 不包含错误类型。\r\n \r\n","\r\n Gets a value indicating whether this instance is external method.\r\n ":"\r\n 获取一个指示此实例是否为外部方法的值。\r\n \r\n"," (which does the same,\r\n            but only for code cases where the user has provided an appropriate variable name in\r\n            code that can be used).\r\n            ":" （这样做一样，\r\n            但是仅对于用户在\r\n            可以使用的代码）。\r\n            \r\n","\r\n Parses the file alignment option.\r\n In case an invalid value was passed, nothing is returned.\r\n ":"\r\n 解析文件对齐选项。\r\n 如果通过无效的值，则什么都没有返回。\r\n \r\n","\r\n            Batch fixer for pragma suppression removal code action.\r\n            ":"用于巴格马抑制拆卸代码操作的批次修复器。\r\n            \r\n","\r\n            Fully qualified name of the symbol containing the reference location\r\n            ":"\r\n            包含参考位置的符号的完全合格名称\r\n            \r\n","\r\n  Looks up a localized string similar to Identifier expected..\r\n":"\r\n  查找类似于标识符的局部字符串。\r\n\r\n","\r\n Represents an Operator block member declaration: A declaration that has a\r\n beginning declaration, a body of executable statements and an end statement.\r\n ":"\r\n 代表操作员块成员声明：具有\r\n 开始声明，可执行语句的主体和结束声明。\r\n \r\n"," \r\n Map an anonymous type or delegate's method symbol to a substituted method symbol.\r\n ":" \r\n 将匿名类型或代表的方法符号映射到替换的方法符号。\r\n \r\n","\r\n            If no text has been typed, the item should be soft selected. This is appropriate for \r\n            completion providers that want to provide suggestions that shouldn't interfere with \r\n            typing.  For example a provider that comes up on space might offer items that are soft\r\n            selected so that an additional space (or other puntuation character) will not then \r\n            commit that item.\r\n            ":"\r\n            如果未键入文本，则应选择该项目。这适合\r\n            希望提供不应干扰的建议的完成提供商\r\n            打字。例如，在空间上出现的提供商可能会提供柔软的物品\r\n            选择以使额外的空间（或其他提升字符）不会\r\n            提交该项目。\r\n            \r\n","\r\n The underlying ParameterSymbol, cannot be another RetargetingParameterSymbol.\r\n ":"\r\n 基础ParameterSymbol不能是另一个RetargetingParameterSymbol。\r\n \r\n","Introduce query variable for all occurrences of '{0}'":"引入所有出现“ {0}'的出现的查询变量\r\n","\r\n Get punctuations\r\n ":"\r\n 获得点标\r\n \r\n","\r\n The value for the PrecedingMisc property.\r\n ":"\r\n 先前属性属性的值。\r\n \r\n","\r\n The list of custom modifiers, if any, associated with the member variable.\r\n ":"\r\n 与成员变量关联的自定义修饰符列表（如果有）。\r\n \r\n","The \"m\" custom format specifier represents the minute as a number from 0 through 59. The minute represents whole minutes that have passed since the last hour. A single-digit minute is formatted without a leading zero.\r\n            \r\n            If the \"m\" format specifier is used w ...":"“ M”自定义格式指定符表示为0到59的数字。单位分钟的格式是不带领先的零的。\r\n            \r\n            如果使用“ M”格式指定符\r\n","\r\n A list of the types being inherited.\r\n ":"\r\n 继承类型的列表。\r\n \r\n","\r\n Returns a BoundPropertyGroup if the expression represents a valid\r\n default property access. If there is a default property but the property\r\n access is invalid, a BoundBadExpression is returned. If there is no\r\n default property for the expression type, Nothing is returned.\r\n \r\n Note, that default Query Indexer may be a method, not a property.\r\n ":"\r\n 如果表达式表示有效\r\n 默认属性访问。如果有默认属性，但是该属性\r\n 访问是无效的，返回了boundbadexpression。如果没有\r\n 表达式类型的默认属性，什么都没有返回。\r\n \r\n 请注意，该默认查询索引可能是一种方法，而不是属性。\r\n \r\n","DO NOT call this to get the parameters of a delegate declaration (":"请勿称呼此要获得代表声明的参数（\r\n","A character position used to identify a declaration scope and\r\n accessibility. This character position must be within the FullSpan of the Root syntax\r\n node in this SemanticModel.\r\n ":"用于识别声明范围的角色位置和\r\n 可访问性。此字符位置必须在根语法的成面内\r\n 该语义模型中的节点。\r\n \r\n","\r\n  Looks up a localized string similar to \r\n    '{0}' is constrained to '{1}'..\r\n":"查找类似于\r\n    '{0}'被约束至'{1}'..\r\n\r\n","\r\n If this returns True, the involved conversion method can be obtained with the ":"\r\n 如果返回true，则可以通过\r\n","\r\n Returns a copy of this with the DollarSignDoubleQuoteToken property changed to\r\n the specified value. Returns this instance if the specified value is the same\r\n as the current value.\r\n ":"\r\n 返回此的副本，并更改​​为DollarSignDoublequotoken属性\r\n 指定值。如果指定的值相同，则返回此实例\r\n 作为当前值。\r\n \r\n","TODO: dispose managed state (managed objects)":"TODO：处置托管状态（托管对象）\r\n"," then this\r\n            is the id for the ":" 然后\r\n            是ID\r\n","\r\n Gets the set of interfaces that this type directly implements, plus the base interfaces\r\n of all such types.\r\n ":"\r\n 获取此类型直接实现的一组接口，以及基本接口\r\n 所有此类类型。\r\n \r\n","\r\n Get all the syntax and declaration errors within the syntax tree associated with this object. Does not get\r\n errors involving compiling method bodies or initializers.\r\n ":"\r\n 在与此对象关联的语法树中获取所有语法和声明错误。没有得到\r\n 涉及编译方法物体或初始化器的错误。\r\n \r\n","\r\n  Looks up a localized string similar to Date constant is not valid..\r\n":"\r\n  查找类似于日期常数的本地化字符串无效。\r\n\r\n","\r\n            Cached compile time solution for a forked branch.  This is used primarily by LSP cases where\r\n            we fork the workspace solution and request diagnostics for the forked solution.\r\n            ":"\r\n            缓存的分支分支的编译时解决方案。这主要是由LSP情况使用的\r\n            我们为工作空间解决方案提供了分叉解决方案的诊断。\r\n            \r\n","\r\n Get all the declaration errors in a single tree.\r\n ":"\r\n 在一棵树中获取所有声明错误。\r\n \r\n","\r\n Returns true if this method is an extension method from the VB language perspective; \r\n i.e., declared with an Extension attribute and meets other language requirements.\r\n ":"\r\n 如果此方法是从VB语言角度来看的扩展方法，则返回true；\r\n 即，以扩展属性声明并满足其他语言要求。\r\n \r\n","\r\n In the presence of non-VB types, the meaning of \"same signature\" is rather\r\n complicated.  If this method isn't from source, then it refers to the runtime's\r\n notion of signature (i.e. including return type, custom modifiers, etc).\r\n If this method is from source, use the VB version of signature. Note that \r\n Dev10 C# has a rule that prefers members with less custom modifiers. Dev 10 VB has no\r\n such rule, so I'm not adding such a rule here.\r\n ":"\r\n 在存在非VB类型的情况下，“相同签名”的含义是\r\n 复杂。如果此方法不是来自源的，则指运行时的\r\n 签名概念（即包括返回类型，自定义修饰符等）。\r\n 如果此方法来自源，请使用VB版本的签名。注意\r\n DEV10 C＃具有一条规则，该规则优先考虑具有较少自定义修饰符的成员。开发10 VB没有\r\n 这样的规则，所以我在这里不添加这样的规则。\r\n \r\n","\r\n Represents member access (.name) or dictionary access (!name). The Kind\r\n property determines which kind of access.\r\n ":"\r\n 代表成员访问（.NAME）或字典访问（！名称）。那种\r\n 属性确定哪种访问权限。\r\n \r\n","The type name '{0}' is reserved to be used by the compiler.":"保留了类型名称'{0}'来由编译器使用。\r\n","\r\n            For a description of the key, see GetKeyAsync.\r\n            ":"\r\n            有关密钥的说明，请参见GetKeyAsync。\r\n            \r\n","\r\n Represents an embedded expression in an XML literal e.g. '<name><%=\r\n obj.Name =%></name>'.\r\n ":"\r\n 代表XML文字中的嵌入式表达式，例如'<名称> <％=\r\n obj.name =％> </name>'。\r\n \r\n","\r\n  Looks up a localized string similar to XML name expected..\r\n":"\r\n  查找类似于XML名称的本地化字符串。\r\n\r\n","\r\n Gets the list of constructor arguments specified by this application of the attribute.  This list contains both positional arguments\r\n and named arguments that are formal parameters to the constructor.\r\n ":"\r\n 获取该属性应用程序指定的构造函数参数列表。此列表包含两个位置参数\r\n 并命名为构造函数正式参数的参数。\r\n \r\n","\r\n  Looks up a localized string similar to Object initializer syntax cannot be used to initialize an instance of 'System.Object'..\r\n":"\r\n  查找类似于对象初始化器语法的本地化字符串不能用于初始化“ system.Object”的实例。\r\n\r\n","\r\n Returns a placeholder substitute for a With statement placeholder specified or Nothing if not found\r\n\r\n Note: 'placeholder' is needed to make sure the binder can check that the placeholder is\r\n associated with the statement.\r\n ":"\r\n 返回占位符的替代者，以指定陈述占位符或未找到的占位符\r\n\r\n 注意：需要“占位符”以确保活页夹可以检查占位符是否\r\n 与该陈述相关联。\r\n \r\n","\r\n  Looks up a localized string similar to Implicit reference to object under construction is not valid when calling another constructor..\r\n":"\r\n  在调用另一个构造函数时，查找类似于对构造对象的隐式引用类似的本地化字符串。\r\n\r\n","2, for the length of ":"2、对于长度 \r\n","\r\n  Looks up a localized string similar to '{0}' is not valid on an interface property declaration..\r\n":"\r\n  在接口属性声明上查找类似于“ {0}”的本地化字符串。\r\n\r\n"," and is needed so that existing locals aren't\r\n omitted in the EE (method symbols in the EE will override this property to return True).\r\n ":" 并且需要现有的当地人\r\n 在EE中省略（EE中的方法符号将覆盖此属性以返回true）。\r\n \r\n","\r\n The \"position\" is used to determine what variables are visible and accessible. Even if\r\n \"container\" is specified, the \"position\" location is significant for determining which\r\n members of \"containing\" are accessible.\r\n ":"“位置”用于确定哪些变量可见和可访问。即使\r\n 指定“容器”，“位置”位置对于确定哪个\r\n 可以访问“包含”的成员。\r\n \r\n",". Otherwise, it looks for default properties.\r\n ":"。否则，它寻找默认属性。\r\n \r\n"," are\r\n            { ":" 是\r\n            {\r\n","\r\n Returns a copy of this with the EventMember property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中事件属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Create a binder for the source module. Includes the following:\r\n    BackstopBinder\r\n    SourceModuleBinder\r\n ":"\r\n 为源模块创建活页夹。包括以下内容：\r\n    后脚手\r\n    Sourcemodulebinder\r\n \r\n","\r\n Returns a copy of this with the ElseClause property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中ElSeclausa属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","enum value":"枚举价值\r\n","The type of the specified ":"指定的类型\r\n","\r\n Compare with no regard to type arguments.\r\n ":"\r\n 与不考虑类型参数进行比较。\r\n \r\n","\r\n Returns true if this symbol is \"shared\"; i.e., declared with the \"Shared\"\r\n modifier or implicitly always shared.\r\n ":"\r\n 如果此符号为“共享”，则返回true；即，用“共享”声明\r\n 修改器或隐式总是共享的。\r\n \r\n"," equality should be checked separately!!!\r\n ":" 应分开检查平等！！！\r\n \r\n"," with the references changed.\r\n            ":" 随着参考的变化。\r\n            \r\n"," \r\n Returns #r directives specified in the compilation. \r\n ":" \r\n 返回汇编中指定的#R指令。\r\n \r\n","An expression of type '{0}' always matches the provided pattern.":"类型'{0}'的表达式始终匹配提供的模式。\r\n","\r\n            Indicate if ":"\r\n            指示是否\r\n","\r\n Gets all symbols of the particular name as \r\n a) members of this type\r\n b) members of base types \r\n c) type parameters in this type (but not outer or base types)\r\n In that order.\r\n \r\n Note, that section \"11.4.4 Simple Name Expression\" of VB Language spec \r\n implies that type parameters are examined first, and only then members \r\n of the type are examined. But this is inconsistent with Dev10 behavior.\r\n \r\n Returns all members of that name, or empty list if none.\r\n ":"\r\n 获取特定名称的所有符号\r\n a）这种类型的成员\r\n b）基本类型的成员\r\n c）此类型中的类型参数（但不是外部或基本类型）\r\n 以该顺序。\r\n \r\n 请注意，该节“ 11.4.4简单名称表达式” VB语言规格\r\n 暗示首先检查该类型参数，然后才会成员\r\n 检查了类型。但这与DEV10行为不一致。\r\n \r\n 返回该名称的所有成员，如果没有，则返回空名单。\r\n \r\n","\r\n A trivia with kind EndOfLineTrivia containing both the carriage return And line feed characters.\r\n ":"带有携带返回和线条饲料字符的善良内传输的琐事。\r\n \r\n","\r\n Returns a copy of this with the JoinedVariables property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，加入的Variables属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Information decoded from early well-known custom attributes applied on a parameter.\r\n ":"\r\n 从应用于参数的早期众所周知的自定义属性解码的信息。\r\n \r\n","\r\n If this property returns false, it is certain that there are no extension\r\n methods inside this type. If this property returns true, it is highly likely\r\n (but not certain) that this type contains extension methods. This property allows\r\n the search for extension methods to be narrowed much more quickly.\r\n \r\n !!! Note that this property can mutate during lifetime of the symbol !!!\r\n !!! from True to False, as we learn more about the type.             !!! \r\n ":"\r\n 如果此属性返回false，则可以肯定没有扩展\r\n 这种类型的方法。如果此属性返回真实，则很有可能\r\n （但不确定）这种类型包含扩展方法。此属性允许\r\n 搜索扩展方法要更快地缩小。\r\n \r\n !!!请注意，此属性可以在符号的生命周期中突变！！！\r\n !!!从真实到错误，随着我们更多地了解类型。 !!!\r\n \r\n","\r\n A NamedTypeBinder provides the context for a type symbol; e.g., looking up names\r\n inside the type.\r\n ":"\r\n 命名typebinder为类型符号提供了上下文；例如，查找名称\r\n 内部类型。\r\n \r\n","static local functions":"静态局部功能\r\n","\r\n Get all reserved and contextual keywords\r\n ":"\r\n 获取所有保留和上下文关键字\r\n \r\n","\r\n This method is virtual, but usually there is no need to override it. It\r\n calls the virtual LookupInSingleBinder, which should be overridden instead,\r\n for each binder in turn, and merges the results.\r\n Overriding this method is needed only in limited scenarios, for example for\r\n a binder that binds query [Into] clause and has implicit qualifier.\r\n ":"\r\n 此方法是虚拟的，但通常无需覆盖它。它\r\n 调用虚拟LookupinSinglebinder，应该被覆盖\r\n 对于每个粘合剂，并合并结果。\r\n 仅在有限的情况下才需要覆盖此方法，例如\r\n 将查询绑定到子句中并具有隐式预选赛的粘合剂。\r\n \r\n","\r\n The For statement that begins the block.\r\n ":"\r\n 开始块的语句。\r\n \r\n","\r\n Given a name, find a member field or property (ignoring all other members) in a type.\r\n ":"给定名称，在类型中找到成员字段或属性（忽略所有其他成员）。\r\n \r\n","second (1-2 digits)":"第二个（1-2位数字）\r\n","The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.":"应用于参数'{0}'的CallerArgumentExpresseptresseptresseattribute将无效。它被callerfilepathatribute覆盖。\r\n","\r\n Syntax node class that represents a value of 'cref' attribute inside\r\n documentation comment trivia.\r\n ":"\r\n 语法节点类代表内部“ cref”属性的值\r\n 文档评论琐事。\r\n \r\n","inferred delegate type":"推断的委托类型\r\n","\r\n The syntax node(s) that declared the symbol.\r\n ":"\r\n 声明为符号的语法节点。\r\n \r\n","\r\n The list of ReDim clauses.\r\n ":"\r\n Redim子句列表。\r\n \r\n","\r\n Returns an array of assembly identities for assemblies referenced by this module.\r\n Items at the same position from GetReferencedAssemblies and from GetReferencedAssemblySymbols \r\n should correspond to each other.\r\n \r\n The array and its content is provided by ReferenceManager and must not be modified.\r\n ":"\r\n 返回该模块引用的汇编数组。\r\n 从GetReferendedAssemblies和GetReferendedAssemblysymbols处于同一位置的项目\r\n 应彼此对应。\r\n \r\n 数组及其内容由ReferenceManager提供，不得修改。\r\n \r\n","default type parameter constraints":"默认类型参数约束\r\n","Cannot pass argument with dynamic type to generic local function '{0}' with inferred type arguments.":"用动态类型将参数传递给通用本地函数'{0}'，并使用推断类型参数。\r\n","\r\n Symbols representing constructed generic method that isn't contained within constructed generic type.\r\n For example: A.B(Of Integer), but not A(Of Integer).B.C(Of Integer).\r\n ":"\r\n 代表构造的通用方法的符号，该方法不包含在构造的通用类型中。\r\n 例如：a.b（整数），而不是（整数）.b.c（整数）。\r\n \r\n","\r\n The value for the TypeParameterConstraintClause property.\r\n ":"\r\n TypeparameterContraintClause属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to Property accessors cannot be declared '{0}' in a 'NotOverridable' property..\r\n":"\r\n  在“ notoverridridable”属性中查找类似于属性访问者的本地化字符串。\r\n\r\n","\r\n Represents a cast to a pre-defined type using a pre-defined cast expression,\r\n such as CInt or CLng.\r\n ":"\r\n 使用预定义的铸件表达式表示预定义的类型的铸件，\r\n 例如Cint或Clng。\r\n \r\n","The source code of the script.":"脚本的源代码。\r\n"," representing the specific kind of\r\n MethodStatementSyntax. One of SubStatement, FunctionStatement.\r\n ":" 代表特定种类\r\n MethodStatementsyntax。取代的一种，功能定位。\r\n \r\n","\r\n Returns the list of custom modifiers, if any, associated with the return type of the event. \r\n ":"\r\n 返回与事件的返回类型关联的自定义修饰符列表。\r\n \r\n","Unwrap expression":"解开包装表达式\r\n","\r\n Create an identifier node without brackets or type character or trivia.\r\n ":"\r\n 创建一个无括号或类型字符或琐事的标识符节点。\r\n \r\n","\r\n Gets the \"Current\" property.\r\n ":"\r\n 获取“当前”属性。\r\n \r\n","The syntax node that declares property.":"声明属性的语法节点。\r\n","\r\n A region analysis walker that computes the set of variables whose values flow into (are used in)\r\n the region.\r\n An variable assigned outside is used inside if an analysis\r\n that leaves the variable unassigned on entry to the region would cause the\r\n generation of \"unassigned\" errors within the region.\r\n ":"\r\n 一个区域分析步行者，该步行器计算其值流入的变量集（用于）\r\n 该区域。\r\n 如果分析，则在内部使用一个分配的变量\r\n 在进入该地区时未分配的变量会导致\r\n 该地区内部的“未分配”错误产生。\r\n \r\n","A dictionary holding a placeholder, a conversion from placeholder to IDisposable and \r\n a condition if placeholder IsNot nothing per type.":"持有占位符的字典，从占位符转换为iDisposable和\r\n 条件如果占位符并不是每种类型的任何东西。\r\n","\r\n  Looks up a localized string similar to Labels are not valid outside methods..\r\n":"\r\n  查找类似于标签的本地化字符串不是有效的外部方法。\r\n\r\n","\r\n Gets the parameters of this event. If this event has no parameters, returns\r\n an empty list.\r\n ":"\r\n 获取此事件的参数。如果此事件没有参数，请返回\r\n 一个空列表。\r\n \r\n","The \"yyyyy\" custom format specifier (plus any number of additional \"y\" specifiers) represents the year with a minimum of five digits. If the year has more than five significant digits, they are included in the result string. If the year has fewer than five ...":"“ Yyyyy”自定义格式指定符（加上任意数量的其他“ Y”指数）代表年度至少五位数字。如果这一年有五个以上的重要数字，则将其包含在结果字符串中。如果这一年少于五个...\r\n","\r\n            Single task used to both hydrate the remote host with the initial workspace solution,\r\n            and track if that work completed.  Prior to it completing, we will try to get all\r\n            navigate-to requests from our caches.  Once it is populated though, we can attempt to\r\n            use the latest data instead.\r\n            ":"\r\n            单个任务既用初始工作空间解决方案来补充远程主机，\r\n            并跟踪该工作是否完成。在完成之前，我们将尝试获得所有\r\n            从我们的缓存中导航请求。一旦填充了，我们可以尝试\r\n            改用最新数据。\r\n            \r\n","\r\n The statements contained in the For or For Each loop. This might be an empty\r\n list.\r\n ":"\r\n 每个循环中包含的语句包含。这可能是空的\r\n 列表。\r\n \r\n","extended property patterns":"扩展的属性模式\r\n","\r\n  Looks up a localized string similar to Requested operation is not available because the runtime library function '{0}' is not defined..\r\n":"\r\n  查找与请求操作类似的本地化字符串，因为未定义的运行时库函数'{0}'。\r\n\r\n","\r\n Returns a copy of this with the StepKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而stepkeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Updating the initializer of {0} requires restarting the application.":"更新{0}的初始化器需要重新启动应用程序。\r\n","\r\n Returns a copy of this with the EndPropertyStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回其中的副本，并更改​​为EndProperTystatement属性\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'class' constraint.":"类型'{2}'在通用类型或方法'{0}'中不能用作类型参数'{1}'。类型参数'{2}'不匹配'class'约束。\r\n"," if the assembly is not available.\r\n            ":" 如果组件不可用。\r\n            \r\n"," association with the insertion of a typed character into the document.\r\n            ":" 与插入字符插入文档的关联。\r\n            \r\n","\r\n  Looks up a localized string similar to Resource name '{0}' cannot be used more than once..\r\n":"\r\n  查找类似于资源名称'{0}'的本地化字符串不能多次使用。\r\n\r\n","Check the given type of and report WRN_MutableGenericStructureInUsing if needed.":"如果需要，请检查给定的类型并报告wrn_mutablegenericstructurein。\r\n","\r\n            Checks if the SyntaxNode is a name of a namespace declaration. To be a namespace name, the syntax\r\n            must be parented by an namespace declaration and the node itself must be equal to the declaration's Name\r\n            property.\r\n            ":"\r\n            检查语法是否是名称空间声明的名称。要成为名称名称，语法\r\n            必须由命名空间声明归属，节点本身必须等于声明的名称\r\n            财产。\r\n            \r\n","\r\n Returns an array of AssemblySymbol objects corresponding to assemblies referenced \r\n by this module. Items at the same position from ReferencedAssemblies And \r\n from ReferencedAssemblySymbols correspond to each other.\r\n ":"\r\n 返回与引用的汇编相对应的汇编符号对象\r\n 通过此模块。参考杂志和相同位置的项目\r\n 从引用Assemblysymbols相互对应。\r\n \r\n","The \"FFFFFFF\" custom format specifier represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value. However, trailing zeros or seven zero digits aren't displayed.\r\n            \r\n            Alth ...":"“ fffffff”自定义格式指示符表示秒数的七个最重要的数字；也就是说，它代表了日期和时间价值中的一千万分之一。但是，未显示尾随的零或七个零数字。\r\n            \r\n            阿尔...\r\n","\r\n Try parse the attribute represented as a stand-alone string like [cref=\"A.B\"] and recognize \r\n 'cref' and 'name' attributes like in documentation-comment mode. This method should only be\r\n  used internally from code handling documentation comment includes.\r\n ":"\r\n 尝试解析以[cref =“ a.b”]等独立字符串表示的属性，并识别\r\n “ cref”和“名称”属性，例如文档评论模式。此方法仅应为\r\n  内部从代码处理文档注释中使用。\r\n \r\n","\r\n Represent a RaiseEvent statement.\r\n ":"\r\n 代表Raiseevent声明。\r\n \r\n","\r\n Returns True if the xmlns { prefix, namespace } pair matches\r\n an Imports declaration and there aren't any xmlns declarations\r\n for the same prefix on any outer XElement scopes.\r\n ":"\r\n 如果XMLNS {prefix，namespace}对匹配，则返回true\r\n 进口声明，没有任何XMLN声明\r\n 对于任何外部XElement示波器上的相同前缀。\r\n \r\n","\r\n            Converts an else-if clause to an if statement, preserving its subsequent else-if and else clauses.\r\n            ":"\r\n            将另一个子句转换为if语句，保留其后续的else-if和其他条款。\r\n            \r\n","The name of the symbol to find. If null is specified then symbols\r\n with any names are returned.":"要查找的符号的名称。 如果指定null，则符号\r\n 与任何名称返回。\r\n","\r\n  Looks up a localized string similar to Event '{0}' cannot implement event '{2}.{1}' because its delegate type does not match the delegate type of another event implemented by '{0}'..\r\n":"\r\n  查找类似于事件'{0}'的本地化字符串无法实现事件'{2}。{1}'，因为其委托类型与'{0}'实现的另一个事件的委托类型不匹配。\r\n\r\n","\r\n gets the last token that has nonzero FullWidth. \r\n NOTE: this helper will not descend into structured trivia.\r\n ":"\r\n 获取最后一个具有非零全宽度的令牌。\r\n 注意：该助手不会降临到结构化的琐事中。\r\n \r\n","\r\n The base class for potentially constructible (i.e. with known arity) error type symbols\r\n ":"\r\n 潜在构造（即具有已知ARITY）错误类型符号的基类\r\n \r\n","\r\n Infer type of the group for a Group Join operator from the set of available GroupJoin methods.\r\n \r\n In short, given already bound inner source and the join key lambdas, this method performs overload\r\n resolution over the set of available GroupJoin operator methods using fake Into lambda:\r\n     Function(outerVar, group As typeToBeInferred) New With {group}\r\n \r\n If resolution succeeds, the type inferred for the best candidate is our result.  \r\n ":"\r\n 从一组可用的组加入方法集中推断组的组类型。\r\n \r\n 简而言之，给定的内部源和加入键lambdas，此方法执行超载\r\n 使用假货中的一组可用组的操作员方法的分辨率：\r\n     功能（Outervar，group作为TypeTobeinferred），{group}\r\n \r\n 如果解决方案成功，那么最佳候选人推断的类型是我们的结果。\r\n \r\n","\r\n  Looks up a localized string similar to Access modifier '{0}' is not valid. The access modifier of 'Get' and 'Set' should be more restrictive than the property access level..\r\n":"\r\n  查找类似于访问修饰符'{0}'的本地化字符串无效。 “ GET”和“ SET”的访问修饰符应该比属性访问级别更具限制性。\r\n\r\n","\r\n The \"Const\" keyword.\r\n ":"\r\n “ const”关键字。\r\n \r\n","year (3-4 digits)":"年（3-4位数字）\r\n"," Reference to a With statement syntax this binder is created for ":" 引用语句语法，为此创建了这个粘合剂\r\n","Containing type to check. Should be an original definition.":"包含检查类型。应该是原始定义。\r\n","\r\n  Looks up a localized string similar to 'Option' must be followed by 'Compare', 'Explicit', 'Infer', or 'Strict'..\r\n":"\r\n  查找类似于“选项”的本地化字符串，后跟“比较”，“显式”，“推断”或“严格”。\r\n\r\n","\r\n  Looks up a localized string similar to References to 'ByRef' parameters cannot be converted to an expression tree..\r\n":"\r\n  查找类似于“ BYREF”参数的引用类似的本地化字符串，不能转换为表达树。\r\n\r\n","\r\n  Used by EnC to create symbols for emit baseline. The PE symbols are used by ":"\r\n  由enc用来为发射基线创建符号。 PE符号由\r\n","\r\n            This allows Completion Providers that indicated they were triggered textually to use syntax to\r\n            confirm they are really triggered, or decide they are not actually triggered and should become \r\n            an augmenting provider instead.\r\n            ":"\r\n            这允许完成的提供商，表明它们是在文本上触发的，以使用语法来\r\n            确认它们确实是触发的，或者决定它们实际上没有触发，应该成为\r\n            改为增强提供商。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Await' requires that the return type '{0}' of '{1}.GetAwaiter()' have suitable IsCompleted, OnCompleted and GetResult members, and implement INotifyCompletion or ICriticalNotifyCompletion..\r\n":"\r\n  查找类似于“等待”的本地化字符串，要求“ {1} .getawaiter（）'的返回类型'{0}'具有适当的结论，oncompleted和getResult成员，并实现InotifyCompletion或iCricationNotifeFletion ..\r\n\r\n","\r\n BlockLevel is used to keep track of the lexical nesting level of label and goto statements. \r\n The other most block has a path of {}\r\n ":"\r\n Blocklevel用于跟踪标签和Goto语句的词汇嵌套水平。\r\n 另一个最大的块有{}的路径\r\n \r\n","\r\n            Provides a completion provider that always appears before any built-in completion provider. This completion\r\n            provider does not provide any completions.\r\n            ":"\r\n            提供了一个完整的提供商，总是在任何内置完成提供商面前出现。这个完成\r\n            提供者不提供任何完成。\r\n            \r\n","\r\n Returns a copy of this with the Attributes property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中属性属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","The character position for determining the enclosing declaration scope And\r\n accessibility.":"确定封闭声明范围的字符位置和\r\n 可访问性。\r\n","The best type or namespace that can be found, or and ErrorTypeSymbol if no reasonable type can be found.":"如果找不到合理的类型，则可以找到的最佳类型或名称空间，也可以找到ErrorTypeSymbol。\r\n","\r\n The \"Class\" keyword.\r\n ":"\r\n “类”关键字。\r\n \r\n","The directory to search for mscorlib, or Nothing if not available.":"搜索MSCORLIB的目录，或者如果不可用，则无需任何内容。\r\n","\r\n Determine if the kind represents a reserved keyword\r\n ":"\r\n 确定类型是否代表保留的关键字\r\n \r\n","No valid selection to perform extraction.":"没有有效的选择要进行提取。\r\n","\r\n A quick check whether given conversion operator is a widening operator.\r\n ":"\r\n 快速检查给定的转换操作员是否是扩大的操作员。\r\n \r\n","\r\n If present, an Implements clause indicated the interface methods that this\r\n method implements.\r\n ":"\r\n 如果存在，则一个实施条款指示接口方法\r\n 方法工具。\r\n \r\n"," APIs to request that a provisional (or preview) tab \r\n            be used for any document that needs to be opened, if one is available.\r\n            ":" API要求临时（或预览）选项卡\r\n            如果有可用的话，可用于任何需要打开的文档。\r\n            \r\n","\r\n Returns true if the specified node represents a lambda.\r\n ":"\r\n 如果指定的节点表示lambda，则返回true。\r\n \r\n","\r\n Lookup a nested namespace.\r\n ":"\r\n 查找一个嵌套的名称空间。\r\n \r\n","\r\n Gets the XML that would be written to the documentation comment file for this assembly.\r\n ":"获取将写入此组件的文档注释文件的XML。\r\n \r\n","\r\n            Indicates that the code style diagnostic can be enforced on build and is part of the highly recommended group for build enforcement.\r\n            ":"\r\n            表示可以在构建中执行代码样式诊断，并且是强烈推荐的构建执行组的一部分。\r\n            \r\n","\r\n Represents a reference to a generic type instantiation that is nested in a non-generic type.\r\n e.g. A.B{int}\r\n ":"\r\n 代表对嵌套在非类型类型中的通用类型实例化的引用。\r\n 例如a.b {int}\r\n \r\n","\r\n An abstract node class that is the parent of classes that describe type\r\n parameter constraint clauses.\r\n ":"\r\n 一个抽象节点类，是描述类型的类的父母\r\n 参数约束条款。\r\n \r\n","\r\n Emits receiver in a form that allows member accesses ( O or & ). For verifiably\r\n reference types it is the actual reference. For generic types it is a address of the\r\n receiver with readonly intent. For the value types it is an address of the receiver.\r\n \r\n isAccessConstrained indicates that receiver is a target of a constrained callvirt\r\n in such case it is unnecessary to box a receiver that is typed to a type parameter\r\n \r\n May introduce a temp which it will return. (otherwise returns null)\r\n ":"\r\n 以允许成员访问（O或＆）的形式发射接收器。为了验证\r\n 参考类型是实际参考。对于通用类型，它是\r\n 接收器具有可读意图。对于值类型，它是接收器的地址。\r\n \r\n ISACCESSCONDENS表示接收器是受约束CallVirt的目标\r\n 在这种情况下，不需要键入输入到类型参数的接收器\r\n \r\n 可能会引入将返回的温度。 （否则返回null）\r\n \r\n","\r\n Modified identifier appeared in a parameter.\r\n ":"\r\n 修改后的标识符出现在一个参数中。\r\n \r\n","Wrap long call chain":"包裹长呼叫链\r\n","\r\n Creates a token with kind XmlTextLiteralNewLineToken.\r\n ":"\r\n 用友善的XMLTEXTLITERALNEWLILETOKEN创建一个令牌。\r\n \r\n"," Stores collection of all embedded symbols referenced from IL ":" 商店收集了IL引用的所有嵌入式符号\r\n","\r\n The name of the aggregation function. The \"Group\" aggregation function is\r\n represented by the identifier \"Group\".\r\n ":"\r\n 聚合函数的名称。 “组”聚合函数是\r\n 由标识符“组”代表。\r\n \r\n","\r\n Represents an integer literal token.\r\n ":"\r\n 代表整数字面令牌。\r\n \r\n","The id of the symbol to map":"符号的ID\r\n","\r\n            Parameter has no matching param tag in XML comment\r\n            ":"\r\n            参数在XML注释中没有匹配的参数标签\r\n            \r\n","\r\n Returns true if the parameter explicitly specifies a default value to be passed\r\n when no value is provided as an argument to a call.\r\n ":"\r\n 如果参数明确指定要传递的默认值，则返回true\r\n 当不提供值作为呼叫的参数时。\r\n \r\n","\r\n            Gets the navigation hint for the text, or ":"\r\n            获取文本的导航提示，或\r\n","The assembly in which to look for the type forwarder.":"寻找类型转发器的组件。\r\n","\r\n            returns AnchorIndentationOperations under a node either by itself or by filtering/replacing operations returned by NextOperation\r\n            ":"返回节点下的锚定词或通过过滤/替换由NextOperation返回的操作\r\n            \r\n","\r\n            Returns method's file path.\r\n            ":"\r\n            返回方法的文件路径。\r\n            \r\n"," \r\n we could implement an interface on those two types.\r\n ":" \r\n 我们可以在这两种类型上实现接口。\r\n \r\n","\r\n            Gets all the applicable analyzers to execute for this work item.\r\n            If this work item has any specific analyzer(s), then returns the intersection of ":"\r\n            让所有适用的分析仪执行此工作项目。\r\n            如果此工作项目具有任何特定的分析仪，则返回\r\n","\r\n returns true when expression has NO SIDE-EFFECTS and is known to produce nullable NULL\r\n ":"\r\n 当表达式没有副作用并且已知会产生可空NULL时，返回true\r\n \r\n","The syntax node to check.":"要检查的语法节点。\r\n","\r\n Returns True if the set of references contains those assemblies needed for XML\r\n literals.\r\n If those assemblies are included, we should include the InternalXmlHelper\r\n SyntaxTree in the Compilation so the helper methods are available for binding XML.\r\n ":"\r\n 如果参考集包含XML所需的组件，则返回true\r\n 文字。\r\n 如果包括这些组件，我们应该包括内部XMLHELPER\r\n 汇编中的语法，因此可以使用辅助方法来结合XML。\r\n \r\n",",\r\n            or null if the node isn't contained in a lambda. If a node is returned it must uniquely represent the lambda,\r\n            i.e. be no two distinct nodes may represent the same lambda.\r\n            ":"，，，，\r\n            或null如果节点未包含在lambda中。如果返回节点，则必须唯一代表lambda，\r\n            即没有两个不同的节点可以代表相同的lambda。\r\n            \r\n","\r\n            Finds the definitions for the symbol at the specific position in the document.\r\n            ":"\r\n            在文档中的特定位置找到符号的定义。\r\n            \r\n","\r\n Binds the expression in the context of the specified location and get semantic\r\n information such as type, symbols and diagnostics. This method is used to get semantic\r\n information about an expression that did not actually appear in the source code.\r\n ":"\r\n 在指定位置的上下文中绑定表达式并获得语义\r\n 诸如类型，符号和诊断等信息。此方法用于获得语义\r\n 有关实际上未出现在源代码中的表达式的信息。\r\n \r\n","\r\n Unless the type is inferred, check that all\r\n implemented events have the same type.\r\n ":"\r\n 除非推断出类型，请检查所有\r\n 实施的事件具有相同的类型。\r\n \r\n","\r\n Attributes filtered out from m_lazyCustomAttributes, ParamArray, etc.\r\n ":"\r\n 从m_lazycustomattributes，paramarray等过滤掉属性。\r\n \r\n","recursive patterns":"递归模式\r\n","Use block body for accessors":"使用块主体作为登录机\r\n","A return type can only have one '{0}' modifier.":"返回类型只能具有一个'{0}'修饰符。\r\n","\r\n            Run a C# script.\r\n            ":"\r\n            运行C＃脚本。\r\n            \r\n","\r\n            Try get the relative namespace for ":"\r\n            尝试获取相对名称空间\r\n","Fix all occurrences in":"修复所有发生在\r\n","\r\n            foreach statement cannot operate on variables of type 'X' because 'X' does not contain a public instance or extension definition for 'GetEnumerator'. Did you mean 'await foreach' rather than 'foreach'?\r\n            ":"\r\n            foreach语句无法在“ x”类型的变量上操作，因为'x'不包含“ getEnumerator”的公共实例或扩展定义。您的意思是“等待“ foreach”而不是“ foreach”？\r\n            \r\n","\r\n            Set to true if the corresponding provider can provide extended items with current context,\r\n            regardless of whether those items are actually added. i.e. it might be disabled by default,\r\n            but we still want to show the expander so user can explicitly request them to be added to \r\n            completion list if we are in the appropriate context.\r\n            ":"\r\n            如果相应的提供商可以提供当前上下文的扩展项目，请设置为true，\r\n            不管是否实际添加了这些项目。即，默认情况下可能会禁用它\r\n            但是我们仍然想向扩展器展示，以便用户可以明确要求将其添加到\r\n            完成列表，如果我们处于适当的上下文中。\r\n            \r\n","\r\n Return true if the constraints collection contains the given type constraint.\r\n ":"\r\n 如果约束集合包含给定类型约束，则返回true。\r\n \r\n"," Bound placeholder expression if used, otherwise Nothing ":" 如果使用绑定的占位符表达式，否则什么都没有\r\n","extended partial methods":"扩展部分方法\r\n","The anonymous object creation syntax.":"匿名对象创建语法。\r\n"," that will get changed.\r\n            ":" 那将会改变。\r\n            \r\n","\r\n Note, ":"\r\n 笔记，\r\n","\r\n This method is only to be used for parsing Cref and Name attributes as stand-alone entities\r\n ":"\r\n 此方法仅用于解析CREF和名称属性作为独立实体\r\n \r\n","\r\n            Language of the reference location\r\n            ":"\r\n            参考位置的语言\r\n            \r\n","\r\n The member containing the binding context\r\n ":"\r\n 包含绑定环境的成员\r\n \r\n","Member - for which the enclosing scope has to be found":"成员 - 必须找到封闭范围\r\n","\r\n  Looks up a localized string similar to 'AddHandler' and 'RemoveHandler' method parameters must have the same delegate type as the containing event..\r\n":"\r\n  查找类似于“ Addhandler”和“ RemoveHandler”方法参数的本地化字符串，必须具有与包含事件相同的委托类型。\r\n\r\n","\r\n            ```a{5,}```\r\n            ":"\r\n            ````a {5，}``````''\r\n            \r\n","Modifying whitespace or comments in a generic {0} requires restarting the application.":"在通用{0}中修改空格或注释需要重新启动应用程序。\r\n","\r\n  Looks up a localized string similar to No accessible '{0}' is most specific: {1}.\r\n":"\r\n  查找类似于无访问的'{0}'的本地化字符串是最特定的：{1}。\r\n\r\n","\r\n If present, an \"= initial-value\" clause describing the initial value of the\r\n property.\r\n ":"\r\n 如果存在，则描述了一个“ =初始值”子句\r\n 财产。\r\n \r\n","\r\n Returns a copy of this with the ImportsClauses property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中importsclauses属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Given a declarationSyntax that is part of a enum constant declaration, get the\r\n corresponding symbol.\r\n ":"\r\n 鉴于声明类别是枚举常数声明的一部分，请获取\r\n 相应的符号。\r\n \r\n","\r\n            True if the active statement is located in a version of the method that precedes a later version that was created by Hot Reload update.\r\n            ":"\r\n            正确，如果Active语句位于该方法的版本中，该版本是由Hot Reload Update创建的以后版本之前的。\r\n            \r\n","A boolean value set to True if character represents whitespace.":"如果字符代表空格，则设置为true的布尔值。\r\n","\r\n            Use this attribute to export a ":"\r\n            使用此属性导出\r\n","An ImmutableArray containing all the types that are members of this symbol. If this symbol has no type members,\r\n returns an empty ImmutableArray. Never returns Nothing.":"一个不含此符号成员的类型的不可分割的arrableray。如果此符号没有类型成员，\r\n 返回一个空的Immutablearray。永远不会返回。\r\n","\r\n The \"Imports\" keyword.\r\n ":"\r\n “导入”关键字。\r\n \r\n","Awaited task returns '{0}'":"等待的任务返回'{0}'\r\n","\r\n            Completion was triggered via some other mechanism.\r\n            ":"\r\n            完成是通过其他一些机制触发的。\r\n            \r\n",", if specified.\r\n            ":"，如果指定。\r\n            \r\n","Property reference cannot be updated":"属性参考无法更新\r\n"," \r\n Draft initializers for With statement, is based on initial binding tree \r\n and is only to be used for warnings generation as well as for flow analysis \r\n and semantic API; real initializers will be re-calculated in lowering\r\n ":" \r\n 用语句的草稿初始化器基于初始绑定树\r\n 并且仅用于发电和流量分析\r\n 和语义API；真正的初始化器将在降低时重新计算\r\n \r\n","'symbol' cannot be a namespace.":"“符号”不能是一个名称空间。\r\n","\r\n Local symbol that is not associated with any source.\r\n ":"\r\n 与任何来源无关的本地符号。\r\n \r\n"," \r\n Module implements Dev11 class CRC32 used in anonymous type GetHashCode implementation\r\n See [...\\Language\\Shared\\crc32.cpp] for details\r\n ":" \r\n 模块实现Dev11类CRC32在匿名类型GethashCode实现中使用\r\n 有关详细信息\r\n \r\n",". Can be null.\r\n            Pattern-matching of user input will not be performed against this, but only against ":"。可以是零的。\r\n            用户输入的模式匹配不会针对此，而是仅针对\r\n","\r\n The End Event statement that ends the block.\r\n ":"\r\n 结束块的结束事件语句。\r\n \r\n","\r\n            This is a generally useful feature on strings.  But it's not likely to be something\r\n            people want to use a lot.  Make low priority so it doesn't interfere with more\r\n            commonly useful refactorings.\r\n            ":"\r\n            这是字符串中通常有用的功能。但这不太可能是什么\r\n            人们想使用很多。优先级，因此不会干扰更多\r\n            通常有用的重构。\r\n            \r\n","\r\n Rewrites ForTo loop.\r\n ":"\r\n 重写ForTo循环。\r\n \r\n","\r\n Parses a parameter array of string arrays representing imports to create a collection of GlobalImports.\r\n ":"\r\n 解析字符串阵列的参数数组，代表导入以创建GlobalImports集合。\r\n \r\n","\r\n            Tags that control what glyph is displayed in the lightbulb menu.\r\n            ":"\r\n            控制灯泡菜单中显示的字形的标签。\r\n            \r\n","\r\n Visit a boolean condition expression.\r\n ":"\r\n 访问布尔条件表达。\r\n \r\n","Stream is not readable or seekable.":"流是不可读取或可寻求的。\r\n","\r\n The value for the ValueKeyword property.\r\n ":"\r\n ValueKeyword属性的值。\r\n \r\n","<Pending>":"<待处理>\r\n","\r\n Represents a Lambda parameter for an UnboundLambda.\r\n ":"\r\n 代表未结合lambda的lambda参数。\r\n \r\n","True if the navigation was handled, indicating that the caller should not \r\n            perform the navigation.":"如果处理导航，则为true，表明呼叫者不应\r\n            执行导航。\r\n","\r\n            Checks if the location of the query expression allows to convert it at least to a local function.\r\n            It still does not guarantees that the conversion can be performed. There can be bail outs of later stages.\r\n            ":"\r\n            检查查询表达式的位置是否允许至少将其转换为本地函数。\r\n            仍然不能保证可以执行转换。可以有以后的阶段保释。\r\n            \r\n","\r\n This instance is used to compare all aspects.\r\n ":"\r\n 此实例用于比较所有方面。\r\n \r\n","\r\n Gets the expression of this argument, if any.\r\n ":"\r\n 如果有的话，得到这个论点的表达。\r\n \r\n","The switch expression does not handle some values of its input type (it is not exhaustive) involving an unnamed enum value. For example, the pattern '{0}' is not covered.":"开关表达式不处理其输入类型的某些值（并不详尽），涉及未命名的枚举值。例如，未涵盖模式'{0}'。\r\n","\r\n            The entity spans and navigation span in the originating document where this symbol was found.  Any time\r\n            the caret is within any of the entity spans, the item should be appropriately 'selected' in whatever UI\r\n            is displaying these.  The navigation span is the location in the starting document that should be\r\n            navigated to when this item is selected If this symbol's location is in another document then this will\r\n            be ":"\r\n            实体跨越了找到此符号的原始文档中的导航范围。任何时候\r\n            角色在任何实体跨度内，该项目应适当地“选择”在任何UI中\r\n            正在显示这些。导航跨度是起始文档中应为的位置\r\n            如果此符号的位置在另一个文档中，则导航到选择此项目时，这将\r\n            是\r\n"," Queue of the types to be processed ":" 要处理类型的队列\r\n","\r\n A tuple of type parameter and constraint type.\r\n ":"\r\n 类型参数和约束类型的元组。\r\n \r\n","\r\n            Navigates to the given virtual position in the specified document, opening it if necessary.\r\n            ":"\r\n            导航到指定文档中给定的虚拟位置，如有必要。\r\n            \r\n","\r\n Returns a copy of this with the WhereKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中wherekeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            Arrange fixes into groups based on the issue (diagnostic being fixed) and prioritize these groups.\r\n            ":"\r\n            根据问题（诊断为固定）将修复分组为组，并确定这些组的优先级。\r\n            \r\n","\r\n The list of variable declarator. Each declarator specifies one or more variable\r\n names along with a type and/or initializer.\r\n ":"\r\n 可变声明列表。每个声明器指定一个或多个变量\r\n 名称以及类型和/或初始化器。\r\n \r\n","\r\n  Looks up a localized string similar to Can't reference compilation of type '{0}' from {1} compilation..\r\n":"\r\n  查找类似于{1}汇编的类型“ {0}”类型的本地化字符串。\r\n\r\n","\r\n The \"position\" Is used to determine what variables are visible And accessible. Even if \"container\" Is\r\n specified, the \"position\" location Is significant for determining which members of \"containing\" are\r\n accessible. \r\n \r\n Does Not return INamespaceOrTypeSymbol, because there could be aliases.\r\n ":"\r\n \"位置\"用于确定哪些变量是可见的和可访问的。 即使\"容器\"是\r\n 指定，\"位置\"位置对于确定\"包含\"的哪些成员是显着的\r\n 可访问。 \r\n \r\n 不返回INamespaceOrTypeSymbol，因为可能有别名。\r\n \r\n","Invocation of implicit Index Indexer cannot name the argument.":"隐式索引索引器的调用无法命名参数。\r\n","\r\n Creates the syntax representation of a see element within xml documentation comments,\r\n that points to the 'null' language keyword.\r\n ":"\r\n 创建XML文档注释中的See元素的语法表示，\r\n 这指向“ null”语言关键字。\r\n \r\n","\r\n Returns substitution currently used by the rewriter for a placeholder node.\r\n Each occurrence of the placeholder node is replaced with the node returned.\r\n Throws if there is no substitution.\r\n ":"\r\n 返回替代者目前由占位符节点使用的替代。\r\n 占位符节点的每个出现都被返回的节点替换。\r\n 如果没有替代，则投掷。\r\n \r\n","\r\n            If the specified node represents a member declaration returns a node that represents its body,\r\n            i.e. a node used as the root of statement-level match.\r\n            ":"\r\n            如果指定的节点代表成员声明返回代表其主体的节点，则\r\n            即，用作语句级匹配的根源。\r\n            \r\n","\r\n Represents a \"Let\" query operator.\r\n ":"\r\n 代表一个“ LET”查询操作员。\r\n \r\n","\r\n Represents a name in the global namespace.\r\n ":"\r\n 代表全局名称空间中的名称。\r\n \r\n","\r\n            Inserts ":"\r\n            插入\r\n","Document must be contained in the workspace that created this service":"文档必须包含在创建此服务的工作空间中\r\n","\r\n            The subnodes in this document to walk and update.  If empty, the entire document\r\n            should be walked.\r\n            ":"\r\n            本文档中的子节点要走路和更新。如果空，则整个文档\r\n            应该走路。\r\n            \r\n","Cannot use a collection of dynamic type in an asynchronous foreach":"无法在异步方面使用动态类型的集合\r\n","\r\n            A map of the document ids that were used and what symbols are in them. \r\n            ":"\r\n            使用的文档ID的地图以及其中有哪些符号。\r\n            \r\n","\r\n Returns a constructed type given its type arguments.\r\n ":"\r\n 返回给定类型参数的构造类型。\r\n \r\n","\r\n Did we see [On Error] or [Resume] statement? Used to suppress some diagnostics.\r\n ":"\r\n 我们是否看到[错误]或[简历]语句？用于抑制一些诊断。\r\n \r\n","\r\n            If there are type arguments on either side of assignment, we match type names instead of type equality \r\n            to account for inferred generic type arguments.\r\n            e.g: Tuple.Create(0, true) returns Tuple<X,y> which isn't the same as type Tuple.\r\n            otherwise, we match for type equivalence\r\n            ":"\r\n            如果分配的两侧都有类型的参数，我们匹配类型名称，而不是类型equality\r\n            考虑推断的通用类型参数。\r\n            例如：tuple.create（0，true）返回元组<x，y>，它与类型元组不同。\r\n            否则，我们匹配类型等价\r\n            \r\n","day of the month (1-2 digits)":"每月（1-2位数字）\r\n","\r\n Returns a copy of this with the WhileOrUntilClause property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中包括wheroruntilclause属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Get all the members of this symbol that are types that have a particular name and arity.\r\n ":"\r\n 获取该符号的所有成员是具有特定名称和arity的类型。\r\n \r\n","\r\n            The indent trivia to insert if we are trying to align wrapped chunks with the \r\n            first period of the original chunk.\r\n            ":"\r\n            如果我们试图将包裹的块与\r\n            原始块的第一阶段。\r\n            \r\n","Expected 'enable', 'disable', or 'restore'":"预期的“启用”，“禁用”或“还原”\r\n","\r\n  Looks up a localized string similar to 'Interface' must end with a matching 'End Interface'..\r\n":"\r\n  查找类似于“接口”的本地化字符串必须以匹配的“结束接口”结尾。\r\n\r\n","\r\n Represents a \"Skip While\" or \"Take While\" query operator. The Kind property\r\n tells which.\r\n ":"\r\n 代表一个“跳过”或“ take”查询操作员。同类属性\r\n 告诉哪个。\r\n \r\n","\r\n Collects expressions that are effective return values of the lambda body.\r\n In iterators those would be arguments of Yield statements.\r\n ":"\r\n 收集表达式是Lambda身体的有效回报值。\r\n 在迭代器中，这些将是产量陈述的参数。\r\n \r\n","\r\n  Looks up a localized string similar to Character is not valid..\r\n":"\r\n  查找类似于字符的本地化字符串是无效的。\r\n\r\n","\r\n            The kind of modification.\r\n            ":"\r\n            那种修改。\r\n            \r\n","\r\n The value for the ElseBlock property.\r\n ":"\r\n ElseBlock属性的值。\r\n \r\n","The \"MMM\" custom format specifier represents the abbreviated name of the month. The localized abbreviated name of the month is retrieved from the DateTimeFormatInfo.AbbreviatedMonthNames property of the current or specified culture.":"“ MMM”自定义格式指示符表示本月的缩写名称。从dateTimeFormatInfo.abbreviatedMonthnames属性中检索了本月的局部缩写名称。\r\n"," backed by a given ":" 由给定的\r\n","\r\n            Completion was triggered for snippets only.\r\n            ":"\r\n            仅针对片段触发完成。\r\n            \r\n","global using directive":"全局使用指令\r\n"," is of a specified kind.\r\n            ":" 是指定的。\r\n            \r\n","\r\n Gets a list of text changes that when applied to the old tree produce this tree.\r\n ":"\r\n 获取一个文本更改列表，当应用于旧树时，会产生这棵树。\r\n \r\n","Binder to be used for error reporting, or Nothing.":"粘合剂用于错误报告，或什么都没有。\r\n","\r\n            An exception thrown when the compilation stage of interactive execution produces compilation errors.\r\n            ":"\r\n            当交互式执行的汇编阶段产生汇编错误时，会引发异常。\r\n            \r\n","\r\n            Interface to implement if the provider want to sign up for notifacation when one of the items it provided\r\n            is being committed by the host, since calling ":"\r\n            如果提供者想在提供的一项项目中注册通知，则要实现的接口\r\n            自从打电话以来，主人犯了\r\n","Note that host state sets (i.e. ones retured by ":"请注意，主机状态集（即由\r\n","'{0}' must allow overriding because the containing record is not sealed.":"'{0}'必须允许覆盖，因为包含的记录未密封。\r\n","\r\n            Base type of all regex numeric quantifier nodes.  i.e.  \r\n            ```a{5}```,  ```a{5,}``` and ```a{5,10}```\r\n            ":"\r\n            所有正则数字量词节点的基本类型。 IE。\r\n            ````````````````\r\n            \r\n","The offset within the file at which the header started.":"标头开始的文件内的偏移量。\r\n","\r\n            Returns the text changes necessary to format the document after the user enters a \r\n            character.  The position provided is the position of the caret in the document after\r\n            the character been inserted into the document.\r\n            ":"\r\n            返回文本更改以后，用户输入了文档\r\n            特点。所提供的位置是在文档中的位置\r\n            角色已插入文档。\r\n            \r\n","\r\n Compares anonymous types ignoring custom modifiers\r\n ":"\r\n 比较匿名类型忽略自定义修饰符\r\n \r\n","Take '{0}'":"取'{0}'\r\n","\r\n  Looks up a localized string similar to '{0}' is an Enum type and cannot be used as an expression..\r\n":"\r\n  查找类似于“ {0}”的本地化字符串是一种枚举类型，不能用作表达式。\r\n\r\n","\r\n  Looks up a localized string similar to Expected closing ';' for XML entity..\r\n":"\r\n  查找类似于预期关闭''的局部字符串；对于XML实体..\r\n\r\n","\r\n Returns a copy of this with the EventExpression property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中事件表达属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","using statement":"使用语句\r\n","\r\n            A descriptive tag from ":"\r\n            来自\r\n","\r\n            The individual tagged parts of the description.\r\n            ":"\r\n            描述的单个标记部分。\r\n            \r\n","\r\n            An abstract class for different edits performed by the Move Type Code Action.\r\n            ":"\r\n            由移动类型代码操作执行的不同编辑的抽象类。\r\n            \r\n","\r\n The value for the Body property.\r\n ":"\r\n 身体财产的价值。\r\n \r\n","\r\n            Analyzes if type information is obvious to the reader by simply looking at the assignment expression.\r\n            ":"\r\n            通过简单地查看作业表达式，分析类型信息是否对读者很明显。\r\n            \r\n","\r\n The condition that is used to determine whether to call Dispose or not (contains a placeholder).\r\n ":"\r\n 用于确定是否呼叫处置的条件（包含占位符）。\r\n \r\n","\r\n The boolean expression used for partitioning.\r\n ":"\r\n 布尔表达式用于分区。\r\n \r\n","extension GetEnumerator":"扩展getEnumerator\r\n","\r\n Represents a Do-Loop block. The Kind property can be used to determine if this\r\n is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.\r\n ":"\r\n 代表一个do-loop块。该属性可用于确定是否\r\n 是一段时间，直到循环循环，循环直到或无限循环。\r\n \r\n","Assembly '{0}, Version={1}' has already been loaded from '{2}'. A different assembly with the same name and version can't be loaded: '{3}'.":"汇编'{0}，版本= {1}'已经从'{2}'加载。无法加载具有相同名称和版本的不同组件：'{3}'。\r\n","\r\n Given a field declaration syntax, get the corresponding symbols.\r\n ":"\r\n 给定字段声明语法，获取相应的符号。\r\n \r\n","\r\n            Returns an RQName for the given symbol, or ":"\r\n            返回给定符号的rqname，或\r\n","An parameter array of KeyValue pairs representing existing symbols.":"密钥值对的参数阵列表示现有符号。\r\n","\r\n The value for the ColonToken property.\r\n ":"\r\n Colontoken财产的价值。\r\n \r\n","\r\n  Looks up a localized string similar to Nullable modifier cannot be specified on both a variable and its type..\r\n":"\r\n  在变量及其类型上都不能指定类似于无效修饰符的本地化字符串。\r\n\r\n","\r\n  Looks up a localized string similar to Multi-dimensional array cannot be converted to an expression tree..\r\n":"\r\n  查找类似于多维数组的局部字符串无法转换为表达树。\r\n\r\n","Represents an object whose operations will be resolved at runtime.":"代表一个对象，其操作将在运行时解决。\r\n"," parameter, so that\r\n            it doesn't declare a duplicate variable.\r\n            If the statement has a pattern declaration (such as ":" 参数，这样\r\n            它不会声明重复变量。\r\n            如果该语句有模式声明（例如\r\n","Generate abstract method '{1}.{0}'":"生成抽象方法'{1}。{0}'\r\n","\r\n  Looks up a localized string similar to 'Microsoft.VisualBasic.ComClassAttribute' cannot be applied to a class that is declared 'MustInherit'..\r\n":"\r\n  查找类似于“ Microsoft.visualbasic.com classattribute”类似的本地化字符串，不能应用于被声明为“ MustInherit”的类。\r\n\r\n","\r\n The value for the LessThanExclamationMinusMinusToken property.\r\n ":"\r\n LessthanexClamationMinusMinustoken属性的价值。\r\n \r\n","\r\n Creates a clone of a red node that can be used as a root of given syntaxTree.\r\n New node has no parents, position == 0, and syntaxTree as specified.\r\n ":"\r\n 创建一个红色节点的克隆，可以用作给定语法的根。\r\n New Node没有指定的父母，位置== 0和语法。\r\n \r\n"," \r\n Names on the right of qualified names and member access expressions are not stand-alone expressions.\r\n This method returns the appropriate parent of name syntax nodes that are on right of these constructs.\r\n ":" \r\n 合格名称和成员访问表达式右侧的名称不是独立表达式。\r\n 此方法返回这些构造右侧的名称语法节点的适当父。\r\n \r\n","\r\n Special HasHome for fields. Fields have homes when they are writable.\r\n ":"\r\n 特殊的田野藏品。田野在写作时有房屋。\r\n \r\n","An expression which much occur within the syntax tree associated with this\r\n object.":"与此相关联的语法树中发生了很多事情的表达\r\n 目的。\r\n"," applied on the containing module.\r\n ":" 应用于包含的模块。\r\n \r\n","\r\n Returns True if this conversion is a default conversion (a conversion from the \"Nothing\" literal). \r\n ":"\r\n 如果此转换为默认转换（“毫无意义”的转换），则返回true。\r\n \r\n","\r\n Returns a copy of this with the WhenClause property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 将其返回此副本，并将其何时更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n This value will be checked by the ":"\r\n 此值将由\r\n","The possible derived type.":"可能的派生类型。\r\n","\r\n            make sure solution cralwer is registered for the given workspace.\r\n            ":"\r\n            确保为给定工作区注册Cralwer的解决方案。\r\n            \r\n","\r\n The \"(\" token\r\n ":"\r\n “（”令牌\r\n \r\n",". Otherwise,\r\n            Returns null.\r\n            For example:\r\n            - If ":"。否则，\r\n            返回null。\r\n            例如：\r\n            - 如果\r\n","\r\n  Looks up a localized string similar to Arrays declared as structure members cannot be declared with an initial size..\r\n":"\r\n  查找类似于声明的数组类似的本地化字符串，因为结构成员不能以初始大小声明。\r\n\r\n","Note: this is explicitly ":"注意：这是明确的\r\n","\r\n The class to represent all fields imported from a PE/module.\r\n ":"\r\n 代表从PE/模块导入的所有字段的类。\r\n \r\n","The text changes to be applied to the document.":"文本更改要应用于文档。\r\n","\r\n  Looks up a localized string similar to 'End Operator' expected..\r\n":"\r\n  查找类似于预期的“最终操作员”的本地化字符串。\r\n\r\n","Convert to full property":"转换为完整属性\r\n","The local symbol's type. It is passed in because this method is called while the type is being resolved and before it is set.":"本地符号的类型。之所以传递，是因为在解决类型和设置之前的类型时调用此方法。\r\n","\r\n            True if the active statement is located in a version of the method that's not the latest version of the method.\r\n            ":"\r\n            正确，如果活动语句位于该方法的最新版本中的版本中，则是正确的。\r\n            \r\n","\r\n Returns true if and only if the last statement in the region can complete normally or the region contains no\r\n statements.\r\n ":"\r\n 当且仅当区域中的最后一个语句才能正常完成或该区域包含否时，返回true\r\n 语句。\r\n \r\n","\r\n  Looks up a localized string similar to XML declaration does not allow attribute '{0}{1}{2}'..\r\n":"\r\n  查找类似于XML声明的本地化字符串不允许属性'{0} {1} {2} {2}'..\r\n\r\n","\r\n            Only return this service as valid when we're starting an interpolated string.\r\n            Otherwise double quotes should be completed using the ":"\r\n            仅当我们启动插值字符串时，仅将此服务返回为有效。\r\n            否则双引号应使用\r\n","\r\n            This method avoids the performance overhead of calling ":"\r\n            此方法避免了通话的性能开销\r\n","Async-iterator member has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable<>.GetAsyncEnumerator' will be u ...":"异步 - 列表成员具有一个或多个类型的“ comcellationToken”类型的参数，但它们都没有用“ EnumeratorCancellation”属性装饰，因此从生成的“ iAsyncencenumerable”中的取消令牌参数<>。getAsyncenumerator <>。\r\n"," parameter instead.\r\n            ":" 代替参数。\r\n            \r\n","\r\n gets the last token regardless if it has zero FullWidth or not \r\n NOTE: this helper will not descend into structured trivia.\r\n ":"\r\n 获得最后一个令牌，无论它的全宽度是否为零\r\n 注意：该助手不会降临到结构化的琐事中。\r\n \r\n","\r\n Get the correct enclosing binder for the given position, taking into account  \r\n block constructs and lambdas.\r\n ":"\r\n 考虑到给定位置的正确封闭活页夹\r\n 块构造和lambdas。\r\n \r\n","\r\n            Return all ":"\r\n            返回全部\r\n","Adding a method with an explicit interface specifier requires restarting the application.":"添加具有显式接口规范的方法需要重新启动应用程序。\r\n","The collection of strings to be parsed.":"琴弦的集合要解析。\r\n","\r\n            A variable declared by the script.\r\n            ":"\r\n            脚本声明的变量。\r\n            \r\n","\r\n            The main refactoring\r\n            keeps walking up nodes until it finds the first IWrapper that can handle that node.  That\r\n            way the user is not inundated with lots of wrapping options for all the nodes their cursor\r\n            is contained within.\r\n            ":"\r\n            主要重构\r\n            继续走上节点，直到找到可以处理该节点的第一个iwrapper。那\r\n            用户没有被所有节点的包装选项淹没的方式\r\n            包含在其中。\r\n            \r\n","\r\n The value for the YieldKeyword property.\r\n ":"\r\n faredkeyword属性的值。\r\n \r\n"," decomposing it into the individual tokens and nodes we want to look for chunks in. \r\n            ":" 将其分解为我们想要寻找块的单个令牌和节点。\r\n            \r\n","\r\n             callbacks, and therefore do not need to be analyzed again by a\r\n             ":"\r\n             回调，因此无需再次分析\r\n             \r\n","\r\n  Looks up a localized string similar to 'Is' operand of type '{0}' can be compared only to 'Nothing' because '{0}' is a type parameter with no class constraint..\r\n":"\r\n  查找类似于'isty'{0}'的'iss“操作数”的本地化字符串只能将其比较为“ nothing”，因为'{0}'是一个类型参数，没有类别约束。\r\n\r\n","\r\n Calls are conditionally omitted if all the following requirements are true:\r\n  (a) Me.IsSub == True.\r\n  (b) Containing type is not an interface type.\r\n  (c) Me.IsConditional == True, i.e. it has at least one applied conditional attribute.\r\n  (d) This method is not the Property Set method.\r\n  (e) None of conditional symbols corresponding to these conditional attributes are true at the given syntax node location.\r\n ":"\r\n 如果以下所有要求是正确的，则有条件省略呼叫：\r\n  （a）me.issub == true。\r\n  （b）包含类型不是接口类型。\r\n  （c）me.isconditional == true，即它至少具有一个有条件的属性。\r\n  （d）此方法不是属性集方法。\r\n  （e）在给定的语法节点位置，与这些条件属性相对应的条件符号都不是真实的。\r\n \r\n","'{0}' is not a valid calling convention type for 'UnmanagedCallersOnly'.":"'{0}'不是'UnmanagedCallersoly'的有效调用惯例类型。\r\n","\r\n            [^...] node\r\n            ":"\r\n            [^...]节点\r\n            \r\n","\r\n  Looks up a localized string similar to Property cannot be declared '{0}' because it contains a 'Private' accessor..\r\n":"\r\n  查找类似于属性的本地化字符串不能被声明为“ {0}”，因为它包含“私有”访问者。\r\n\r\n"," for more information about argument values.\r\n            ":" 有关参数值的更多信息。\r\n            \r\n","\r\n Populate the map with all probable extension methods in membersByName parameter.\r\n \r\n Returns True if an extension method was appended, False otherwise.\r\n ":"\r\n 使用MemberByName参数中的所有可能的扩展方法填充地图。\r\n \r\n 如果附加了扩展方法，则返回true，否则为false。\r\n \r\n","\r\n            Diagnostic Analyzer Engine V2\r\n            \r\n            This one follows pattern compiler has set for diagnostic analyzer.\r\n            ":"\r\n            诊断分析仪引擎V2\r\n            \r\n            这是遵循模式编译器为诊断分析仪设置的。\r\n            \r\n","\r\n            Returns unchanged ":"\r\n            返回不变\r\n","\r\n            The new caret position after the change has been applied.\r\n            If null then the new caret position will be determined by the completion host.\r\n            ":"\r\n            更改后的新角色位置。\r\n            如果为null，则新的插入位置将由完成主机确定。\r\n            \r\n","\r\n Some variables that should be considered initially assigned.  Used for region analysis.\r\n ":"\r\n 一些最初分配的变量。用于区域分析。\r\n \r\n","\r\n Returns a copy of this with the TryStatement property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而Trystatement属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Invalid global 'SuppressMessageAttribute'":"无效的全局“抑制措施”\r\n","\r\n returns name used to lookup the method/property in the group.\r\n ":"\r\n 返回用于查找组中的方法/属性的名称。\r\n \r\n","Braces are not required for the embedded statement of an ":"一个嵌入式语句不需要大括号 \r\n","leading digit separator":"领先的数字分离器\r\n","\r\n            Base type for all wrappers that involve wrapping a comma-separated list of items.\r\n            ":"\r\n            所有包装器的基本类型，涉及包装逗号分隔的项目列表。\r\n            \r\n","\r\n Represents a method that has undergone type substitution. This is use for a method\r\n inside a generic type that has undergone type substitution. It also serves as a base class\r\n for ConstructedMethodSymbol, which is used for a method after type substitution in the method type parameters.  \r\n ":"\r\n 代表一种经过类型替代的方法。这是一种方法\r\n 在具有类型替代的通用类型中。它也是基类\r\n 对于构造的莫托符号，该符号用于方法类型参数中的类型替代方法。\r\n \r\n","\r\n If the checkIfCurrentHasOverloads is True, then we only overload if every symbol in \r\n our current result has \"Overloads\" modifier; otherwise we overload \r\n regardless of the modifier.\r\n ":"\r\n 如果CheckifCurrenthAsoverloads为True，那么我们仅在每个符号中的每个符号\r\n 我们当前的结果具有“超载”修饰符；否则我们超载\r\n 不论修饰符。\r\n \r\n","\r\n            Creates a syntax comparer\r\n            ":"\r\n            创建语法比较\r\n            \r\n","Modifying whitespace or comments in {0} inside the context of a generic type requires restarting the application.":"在通用类型的上下文中{0}中修改空格或注释需要重新启动应用程序。\r\n","\r\n The value for the GlobalKeyword property.\r\n ":"\r\n GlobalKeyword属性的值。\r\n \r\n"," preference due to the presence of braces on one or more\r\n            sibling statements (the \"context\").\r\n            ":"由于一个或多个是否存在牙套引起的优先\r\n            兄弟姐妹语句（“上下文”）。\r\n            \r\n","\r\n Returns a copy of this with the ExternalChecksumKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 将其返回此副本，并使用外部checksumkeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Represents the Try part of a Try...Catch...Finally...End Try. This\r\n statement is always the Begin of a TryPart.\r\n ":"\r\n 代表尝试的尝试部分...捕获...最后...结束尝试。这个\r\n 语句始终是枪支的开始。\r\n \r\n","The node to be replaced. This might be an ancestor of original ":"要替换的节点。这可能是原始的祖先\r\n","Generate field assigning constructor '{0}({1})'":"生成字段分配构造函数'{0}（{1}）'\r\n",".\r\n Must be implemented by all methods that may contain user code.\r\n ":"。\r\n 必须通过所有可能包含用户代码的方法实现。\r\n \r\n","\r\n A bound tree walker which search for a bound Me and MyClass references of value type. \r\n Is being only used for calculating the value of 'ExpressionHasByRefMeReference'\r\n ":"\r\n 一个绑定的树步行者，搜索绑定的我和值类型的myClass引用。\r\n 仅用于计算“ expressionhasbyrefmereference”的值\r\n \r\n","\r\n Bind the array bounds and return the sizes for each dimension.\r\n ":"\r\n 绑定阵列边界并返回每个维度的大小。\r\n \r\n","\r\n A NoPiaAmbiguousCanonicalTypeSymbol is a special kind of ErrorSymbol that represents\r\n a NoPia embedded type symbol that was attempted to be substituted with canonical type, \r\n but the canonical type was ambiguous.\r\n ":"\r\n nopiabiguulcanonicaltypesymbol是一种特殊的错误符号，代表\r\n 一种试图用规范类型代替的NOPIA嵌入式类型符号，\r\n 但是规范类型是模棱两可的。\r\n \r\n","\r\n The sequence of groups of TypeDef row ids for types contained within the namespace, \r\n recursively including those from nested namespaces. The row ids are grouped by the \r\n fully-qualified namespace name in case-sensitive manner. There could be multiple groups \r\n for each fully-qualified namespace name. The groups are sorted by their key  \r\n in case-insensitive manner. Empty string is used as namespace name for types \r\n immediately contained within Global namespace. Therefore, all types in this namespace, if any, \r\n will be in several first IGroupings.\r\n \r\n This member is initialized by constructor and is cleared in EnsureAllMembersLoaded \r\n as soon as symbols for children are created.\r\n ":"\r\n 命名空间中包含的类型类型的Typedef行ID组序列，\r\n 递归包括来自嵌套名称空间的。行ID由\r\n 以情况敏感的方式完全合格的名称名称。可能有多个组\r\n 对于每个符合条件的名称空间名称。小组用他们的钥匙排序\r\n 以情况不敏感的方式。空字符串用作类型的名称名称\r\n 立即包含在全球名称空间中。因此，此名称空间中的所有类型（如果有）\r\n 将在几个第一个Igroupings中。\r\n \r\n 该构件由构造函数初始化，并在neareallembers中清除\r\n 创建儿童符号后。\r\n \r\n"," the loader \r\n            responds with the specified dependency if the assembly identity matches the requested one.\r\n            ":" 加载程序\r\n            如果汇编身份匹配所请求的依赖性，则应使用指定的依赖关系响应。\r\n            \r\n","\r\n            Returns all lambda bodies of a node representing a lambda, \r\n            or false if the node doesn't represent a lambda.\r\n            ":"\r\n            返回代表lambda的节点的所有lambda尸体，\r\n            如果节点不代表lambda，则为false。\r\n            \r\n",", if there is no such unique option.\r\n            ":"，如果没有这种独特的选择。\r\n            \r\n","\r\n A list of all the text tokens in the Xml text. This list always contains at\r\n least one token.\r\n ":"\r\n XML文本中所有文本令牌的列表。此列表总是包含在\r\n 至少一个令牌。\r\n \r\n","\r\n            Forces the script through the compilation step.\r\n            If not called directly, the compilation step will occur on the first call to Run.\r\n            ":"\r\n            迫使脚本通过编译步骤。\r\n            如果未直接调用，则将在第一个呼叫运行中发生汇编步骤。\r\n            \r\n","\r\n Add this token to the token list builder.\r\n ":"\r\n 将这个令牌添加到令牌列表构建器中。\r\n \r\n"," to\r\n             indicate that ":" 至\r\n             指出\r\n"," Returns the placeholder used in this With statement to \r\n substitute the expression in initial binding ":" 将其返回该用语中使用的占位符\r\n 在初始结合中代替表达\r\n","\r\n            Generates formatted source code containing general information about the symbol's\r\n            containing assembly and the decompiled source code which the given ISymbol is or is a part of\r\n            into the given document\r\n            ":"\r\n            生成格式的源代码，其中包含有关符号的一般信息\r\n            包含给定ISYMBOL是或属于的源代码的组件和分解源代码\r\n            进入给定文件\r\n            \r\n","\r\n The base class for all nodes that represent statements that declare options,\r\n imports, members, etc.\r\n ":"\r\n 所有表示声明的语句的节点的基类，\r\n 进口，会员等\r\n \r\n","\r\n            The set of well known text tags used for the ":"\r\n            一组众所周知的文本标签\r\n","\r\n The value for the SelectKeyword property.\r\n ":"\r\n SelectKeyWord属性的值。\r\n \r\n","\r\n The \"Global\" keyword.\r\n ":"\r\n “全局”关键字。\r\n \r\n","The substituted members.":"替换成员。\r\n"," Creates a token with kind FloatingLiteralToken from the text and corresponding 8-byte floating point value. ":"从文本和相应的8字节浮点值中创建一个具有友善浮动文字的令牌。\r\n","\r\n A cache of the state at the backward branch point of each loop.  This is not needed\r\n during normal flow analysis, but is needed for region analysis.\r\n ":"\r\n 每个循环的向后分支点处的状态缓存。这不需要\r\n 在正常流量分析期间，需要进行区域分析。\r\n \r\n","\r\n The \"Region\" keyword.\r\n ":"\r\n “区域”关键字。\r\n \r\n","Use 'is null' check":"使用“为null”检查\r\n","\r\n             Defines the containing lists for the current formatting state. The last item in the list is the\r\n             innermost list.\r\n            \r\n             ":"\r\n             定义当前格式状态的包含列表。列表中的最后一项是\r\n             最内向的清单。\r\n            \r\n             \r\n","\r\n  Looks up a localized string similar to Assembly or Module attribute statements must precede any declarations in a file..\r\n":"\r\n  查找类似于汇编或模块属性语句的本地化字符串必须先于文件中的任何声明。\r\n\r\n","\r\n If the specified node represents a \"simple\" lambda returns a node (or nodes) that represent its body (bodies).\r\n Lambda is \"simple\" if all its body nodes are also its child nodes and vice versa.\r\n ":"\r\n 如果指定的节点代表“简单” lambda返回代表其身体（身体）的节点（或节点）。\r\n 如果Lambda所有的身体节点也是其子节点，反之亦然。\r\n \r\n","Capturing variable '{0}' that hasn't been captured before requires restarting the application.":"捕获在需要重新启动应用程序之前未捕获的变量'{0}'。\r\n","\r\n The optional name and \":=\" prefix of a named argument.\r\n ":"\r\n 可选名称和“：=”命名参数的前缀。\r\n \r\n","\r\n If any required special/well-known type/member is not found or has use-site errors\r\n we should not continue with transformation because it may have unwanted consequences;\r\n e.g. we do return Nothing if well-known member symbol is not found. This method should \r\n check all required symbols and return False if any of them are missing or have use-site errors.\r\n We will also return True if signature is definitely bad - contains parameters that are ByRef or have error types\r\n ":"\r\n 如果找不到任何必需的特殊/知名类型/成员，或者有使用站点错误\r\n 我们不应该继续进行转型，因为它可能会带来不必要的后果。\r\n 例如如果找不到知名会员符号，我们什么也不会返回。这个方法应该\r\n 检查所有必需的符号，并返回false，如果其中的任何一个丢失或存在使用站点错误。\r\n 如果签名绝对不好，我们还将返回true  - 包含BYREF或具有错误类型的参数\r\n \r\n","No accessible copy constructor found in base type '{0}'.":"在基本类型'{0}'中找不到可访问的复制构造函数。\r\n","\r\n  Looks up a localized string similar to 'Declare' statements are not allowed in generic types or types contained in generic types..\r\n":"\r\n  在通用类型中包含的通用类型或类型中不允许查找类似于“声明”语句的本地化字符串。\r\n\r\n","\r\n            Indicates the type of reference.\r\n            ":"\r\n            指示参考类型。\r\n            \r\n","The target type to convert this AddressOf expression to.":"将此地址表达式转换为的目标类型。\r\n","\r\n The value for the CaseBlocks property.\r\n ":"\r\n CaseBlocks属性的值。\r\n \r\n","Generate nested {0} '{1}'":"生成嵌套{0}'{1}'\r\n","The \"fffffff\" custom format specifier represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value.\r\n            \r\n            Although it's possible to display the ten millionths of a second co ...":"“ fffffff”自定义格式指示符表示秒数的七个最重要的数字；也就是说，它代表了日期和时间价值中的一千万分之一。\r\n            \r\n            虽然可以显示第二个公司的一千万。\r\n","\r\n The value for the Options property.\r\n ":"\r\n 选项属性的值。\r\n \r\n","\r\n Determines if position is before or within the span of a node, or in the trailing trivia of a node \r\n up to, but not including, a newline or colon trivia (which mark the end of a statement.)\r\n ":"\r\n 确定位置是在节点的跨度之前还是在节点的尾随琐事中\r\n 到但不包括新线或结肠琐事（标志着陈述的结尾。）\r\n \r\n","\r\n            Return all cached local diagnostics (syntax, semantic) that belong to given document for the given StateSet (analyzer).\r\n            Also returns empty diagnostics for suppressed analyzer.\r\n            Returns null if the diagnostics need to be computed.\r\n            ":"\r\n            返回给定状态网（分析仪）给定文档的所有缓存的本地诊断（语法，语义）。\r\n            还返回被抑制分析仪的空诊断。\r\n            如果需要计算诊断，则返回null。\r\n            \r\n","Module initializer cannot be attributed with 'UnmanagedCallersOnly'.":"模块初始化器不能用“无限制的”归因于。\r\n","\r\n The return value is not expected to be syntactically valid Visual Basic.\r\n ":"\r\n 返回值预计不会是句法有效的视觉基础。\r\n \r\n","\r\n The value for the TryStatement property.\r\n ":"\r\n Trystatement属性的值。\r\n \r\n","The field symbol.":"字段符号。\r\n","\r\n Determines whether a stub needed for the delegate creations conversion based on the given method conversions.\r\n ":"\r\n 确定基于给定方法转换的委托创建转换所需的存根。\r\n \r\n","\r\n  Looks up a localized string similar to Associated type does not have type parameters.\r\n":"\r\n  查找类似于关联类型的本地化字符串没有类型参数。\r\n\r\n","\r\n Represents an Implements statement in a Class or Structure.\r\n ":"\r\n 代表类或结构中的实施语句。\r\n \r\n","\r\n If the \"container\" is a non-MustInherit, make sure it has no MustOverride Members\r\n If \"container\" is a non-MustInherit inheriting from a MustInherit, make sure that all MustOverride members\r\n have been overridden.\r\n If \"container\" is a MustInherit inheriting from a MustInherit, make sure that no MustOverride members\r\n have been shadowed.\r\n ":"\r\n 如果“容器”是非固定的，请确保没有Mustoverride成员\r\n 如果“容器”是从必须固定的非寿命，请确保所有Mustoverride成员\r\n 被覆盖了。\r\n 如果“容器”是必须从必备继承的必要遗物，请确保没有Mustoverride成员\r\n 被阴影了。\r\n \r\n","\r\n            Project reference `<ProjectReference ... />`\r\n            ":"\r\n            项目参考`<projectReference ... />``\r\n            \r\n","\r\n  Looks up a localized string similar to Expected a single script (.vbx file).\r\n":"\r\n  查找类似于预期的单个脚本（.vbx文件）的本地化字符串。\r\n\r\n","\r\n            A basic escape that just has \\ and one additional character and needs no further information.\r\n            ":"\r\n            一个基本的逃生，只有\\和一个其他字符，不需要进一步的信息。\r\n            \r\n","\r\n Optimized locations of lambdas. \r\n \r\n Lambda does not need to be placed in a frame that corresponds to its lexical scope if lambda does not reference any local state in that scope.\r\n It is advantageous to place lambdas higher in the scope tree, ideally in the innermost scope of all scopes that contain variables captured by a given lambda.\r\n Doing so reduces indirections needed when captured local are accessed. For example locals from the innermost scope can be accessed with no indirection at all.\r\n \r\n NOTE: This information is computed in addition to the regular analysis of the tree and only needed for rewriting.\r\n If someone only needs diagnostics or information about captures, this information is not necessary.\r\n ComputeLambdaScopesAndFrameCaptures needs to be called to compute this.\r\n ":"\r\n 优化的Lambdas位置。\r\n \r\n 如果Lambda不参考该范围中的任何局部状态，则不需要将Lambda放在与其词汇范围相对应的框架中。\r\n 将lambdas放在范围树中是有利的，理想情况下，在所有范围的最内部范围内包含由给定lambda捕获的变量的范围。\r\n 这样做会减少访问本地捕获时所需的间接。例如，可以完全没有间接访问最内向范围的当地人。\r\n \r\n 注意：除了对树的常规分析外，还需要计算此信息，并且仅需要重写。\r\n 如果某人只需要诊断或有关捕获的信息，则无需此信息。\r\n 需要调用ComputelambdAscopesandFrameCaptures来计算此问题。\r\n \r\n","\r\n If invalid region is dynamically detected this string contains text description of the reason.\r\n \r\n Currently only the following case can cause the region to be invalidated:\r\n \r\n   - We have declaration of several variables using 'As New' having object\r\n     initializer with implicit receiver; if region included such a receiver,\r\n     it should include the whole declaration. Example:\r\n         Dim a, b As New Clazz(...) With { .X = [| .Y |] }\r\n \r\n   - Part of With statement expression which was not captured into locals and\r\n     was not evaluated during With statement body execution. Example:\r\n     initializer with implicit receiver; if region included such a receiver,\r\n     it should include the whole declaration. Example:\r\n         Dim sArray() As StructType = ...\r\n         With sArray([| 0 |])\r\n         End With\r\n \r\n ":"\r\n 如果动态检测到无效区域，则该字符串包含原因的文本描述。\r\n \r\n 目前，只有以下情况会导致该地区无效：\r\n \r\n    - 我们使用“新”对象声明了几个变量\r\n     具有隐式接收器的初始化器；如果地区包括这样的接收器，\r\n     它应该包括整个声明。例子：\r\n         dim a，b作为新的clazz（...），{.x = [| .y |]}}\r\n \r\n    - 陈述表达的一部分，未捕获到当地人和\r\n     在语句执行期间未评估。例子：\r\n     具有隐式接收器的初始化器；如果地区包括这样的接收器，\r\n     它应该包括整个声明。例子：\r\n         dim sarray（）为structType = ...\r\n         与sarray（[| 0 |]）\r\n         结束\r\n \r\n \r\n","\r\n             The matching algorithm will tend to prefer this item unless\r\n             a dramatically better text-based match is available.\r\n             \r\n             With no filter text, this item (or the first item alphabetically \r\n             with this priority) should always be selected.\r\n            \r\n             This is used for specific IDE scenarios like \"Object creation preselection\"\r\n             or \"Enum preselection\" or \"Completion list tag preselection\".\r\n             ":"\r\n             除非\r\n             提供了一个更好的基于文本的匹配。\r\n             \r\n             没有过滤文本，此项目（或第一个项目字母顺序\r\n             使用此优先级）应始终选择。\r\n            \r\n             这用于特定的IDE方案，例如“对象创建预选”\r\n             或“枚举预选”或“完成列表标签预选”。\r\n             \r\n","An ImmutableArray containing all the members of this symbol with the given name. If there are\r\n no members with this name, returns an empty ImmutableArray. The result is deterministic (i.e. the same\r\n from call to call and from compilation to compilation). Members of the same kind appear in the result\r\n in the same order in which they appeared at their origin (metadata or source).\r\n Never returns Nothing.":"一个immutablearray包含带有给定名称的所有符号成员。如果有\r\n 没有这个名字的成员返回一个空的Immutablearray。结果是确定性的（即相同的\r\n 从呼叫到呼叫，从编译到编译）。结果出现在结果中\r\n 按照它们出现在其起源（元数据或来源）的顺序。\r\n 永远不会返回。\r\n","An expression tree may not contain an access of static abstract interface member":"表达树可能不包含静态抽象接口成员的访问\r\n",", which performs an analogous task for LookupSymbols*.\r\n ":"，它对LookupSymbols*执行类似的任务*。\r\n \r\n","The \"g\" standard format specifier represents a combination of the short date (\"d\") and short time (\"t\") patterns, separated by a space.":"“ G”标准格式指定符代表短期（“ D”）和短期（“ T”）模式的组合，被空间隔开。\r\n","\r\n  Looks up a localized string similar to Metadata references not supported..\r\n":"\r\n  查找类似于不支持的元数据参考的本地化字符串。\r\n\r\n"," property for\r\n            ":" 财产\r\n            \r\n","\r\n Rewrites a CollectionInitializerExpression to a list of Add calls and returns the temporary.\r\n E.g. the following code:\r\n     Dim x As New CollectionType(param1) From {1, {2, 3}, {4, {5, 6, 7}}}\r\n gets rewritten to \r\n     Dim temp as CollectionType \r\n     temp = new CollectionType(param1)\r\n     temp.Add(1)\r\n     temp.Add(2, 3)\r\n     temp.Add(4, {5, 6, 7})\r\n     x = temp\r\n where the last assignment is not part of this rewriting, because the BoundCollectionInitializerExpression\r\n only represents the object creation expression with the initialization.\r\n ":"\r\n 将CollectionInitializerExpression重写到Add调用列表并返回临时调用。\r\n 例如以下代码:\r\n     Dim x作为新的CollectionType（param1）从{1, {2, 3}, {4, {5, 6, 7}}}\r\n 被重写为 \r\n     Dim temp作为CollectionType \r\n     temp=新的CollectionType（param1）\r\n     临时工。添加(1)\r\n     临时工。添加(2,3)\r\n     临时工。添加(4, {5, 6, 7})\r\n     x=温度\r\n 其中最后一个赋值不是此重写的一部分，因为BoundCollectionInitializerExpression\r\n 仅用初始化表示对象创建表达式。\r\n \r\n","\r\n  Looks up a localized string similar to End tag </{0}{1}{2}> expected..\r\n":"\r\n  查找类似于End Tag的本地化字符串</{0} {1} {2}>预期..\r\n\r\n","\r\n Returns a copy of this with the ExternalSourceKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中ExternalSourceKeyWord属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","Wrap and align call chain":"包装和对齐呼叫链\r\n","Parentheses can be removed":"可以删除括号\r\n","\r\n            Flag indicating whether or not analyzer should receive analysis callbacks for generated code.\r\n            By default, code style analyzers should not run on generated code, so the value is false.\r\n            ":"\r\n            指示分析仪是否应接收生成代码的分析回调的标志。\r\n            默认情况下，代码样式分析仪不应在生成的代码上运行，因此该值是错误的。\r\n            \r\n","\r\n Add proxy field(s) if any to the array builder provided\r\n \r\n Note: is used for binding BoundStateMachineScope with \r\n       correspondent local/field references\r\n ":"\r\n 添加代理字段（如果有的话）\r\n \r\n 注意：用于绑定BONDSTATEMACHINESCOPE\r\n       通讯本地/字段参考\r\n \r\n","\r\n  Looks up a localized string similar to Visual Basic {0} does not support {1}..\r\n":"\r\n  查找类似于Visual Basic {0}的本地化字符串不支持{1} ..\r\n\r\n",".\r\n            These tags may influence how the item is displayed.\r\n            ":"。\r\n            这些标签可能会影响项目的显示方式。\r\n            \r\n","Symbol part to which the attribute has been applied":"应用属性已应用的符号部分\r\n","\r\n Extra restrictions apply when searching for a well-known type.  In particular, the type must be public.\r\n ":"\r\n 搜索众所周知的类型时，适用额外的限制。特别是，该类型必须是公开的。\r\n \r\n","\r\n            True if this service would like to format the document based on the user typing the\r\n            provided character.\r\n            ":"\r\n            是的，如果此服务想根据用户键入的用户格式化文档\r\n            提供的角色。\r\n            \r\n","Format document":"格式文档\r\n","\r\n The value for the OpenBraceToken property.\r\n ":"\r\n OpenBraceToken属性的价值。\r\n \r\n","\r\n            and the given ":"\r\n            和给定的\r\n","\r\n Binding info for attribute syntax and expressions that are part of a attribute.\r\n ":"\r\n 属性语法的绑定信息和属性一部分的表达式。\r\n \r\n","\r\n Parse an argument list.\r\n ":"\r\n 解析参数列表。\r\n \r\n"," Creates a token with kind IntegerLiteralToken from the text and corresponding 8-byte signed integer value. ":" 从文本和相应的8字节签名的整数值中创建一个具有诸如integerliteraltoken的令牌。\r\n"," new arguments that are cast by corresponding parameter types":"通过相应的参数类型施放的新参数\r\n","\r\n Gets the conversion classification.\r\n ":"\r\n 获取转换分类。\r\n \r\n","\r\n Represents a '$\"' token in an interpolated string expression.\r\n ":"\r\n 在插值字符串表达式中代表“ $”令牌。\r\n \r\n","\r\n This child is optional. If it is not present, then Nothing is returned.\r\n ":"\r\n 这个孩子是可选的。如果不存在，则什么都不会返回。\r\n \r\n","\r\n Default char set for contained types, or null if not specified.\r\n ":"\r\n 默认字符集用于包含类型，如果未指定为null。\r\n \r\n","\r\n            Arrange refactorings into groups.\r\n            ":"\r\n            将重构分组安排。\r\n            \r\n","\r\n folds two concat constants into one if possible\r\n otherwise returns null.\r\n It is generally always possible to concat constants, unless resulting string would be too large.\r\n ":"\r\n 如果可能的话将两个concat常数折叠\r\n 否则返回null。\r\n 通常总是有可能进行concat stromstants，除非产生的字符串太大。\r\n \r\n","\r\n Determine if the token instance represents a syntax trivia such as comment, whitespace, etc...\r\n ":"\r\n 确定令牌实例是否代表语法琐事，例如评论，空格等...\r\n \r\n",",\r\n implicit class can be represented by ":"，，，，\r\n 隐式类可以由\r\n"," Process the result of dominant type inference, generate diagnostics ":" 处理主要类型推理的结果，生成诊断\r\n","record":"记录\r\n","The item to get the change for.":"获取更改的项目。\r\n","\r\n During rewriting, we ignore locals that have already been rewritten to a proxy (a field on a closure class).\r\n However, in the EE, we need to preserve the original slots for all locals (slots for any new locals must be\r\n appended after the originals).  The ":"\r\n 在重写期间，我们忽略了已经被重写为代理的当地人（封闭类中的字段）。\r\n 但是，在EE中，我们需要保留所有当地人的原始插槽（任何新当地人的插槽都必须是\r\n 在原件之后附加）。这\r\n","\r\n Bind and validate parameters declared on the accessor.\r\n ":"\r\n 在登录器上声明的绑定和验证参数。\r\n \r\n","Deleting {0} requires restarting the application.":"删除{0}需要重新启动应用程序。\r\n","\r\n The name of the type being tested against.\r\n ":"\r\n 正在测试的类型的名称。\r\n \r\n","\r\n Implementation of IEqualityComparer for PropertySymbols, with options for various aspects\r\n to compare.\r\n ":"\r\n 实施iqualityComparer for PropertySymbols，具有各个方面的选项\r\n 比较。\r\n \r\n","A placeholder for the collection expression.":"收集表达的占位符。\r\n","'UnmanagedCallersOnly' can only be applied to ordinary static non-abstract methods or static local functions.":"“无管理”只能应用于普通的静态非抽象方法或静态局部功能。\r\n","\r\n Gets the return type of the method.\r\n ":"\r\n 获取该方法的返回类型。\r\n \r\n","\r\n            Prepends a region directive at the top of the document with a name containing\r\n            information about the assembly and a comment inside containing the path to the\r\n            referenced assembly.  The containing assembly may not have a path on disk, in which case\r\n            a string similar to \"location unknown\" will be placed in the comment inside the region\r\n            instead of the path.\r\n            ":"\r\n            用包含一个名称的文档顶部的区域指令预先启动\r\n            有关集会的信息和包含通往路径的评论\r\n            引用组件。包含的组件可能没有磁盘上的路径，在这种情况下\r\n            该区域内的评论将放置类似于“位置未知”的字符串\r\n            而不是路径。\r\n            \r\n","Delegate relaxation to store within the new BoundLambda node.":"将放松委托存储在新的Boundlambda节点中。\r\n","\r\n            Decomposes a name or member access expression into its component parts.\r\n            ":"\r\n            将名称或成员访问表达式分解为其组件零件。\r\n            \r\n","Cannot set {0} specific option {1} because the options were already configured for a different language.":"无法设置{0}特定选项{1}，因为这些选项已经为其他语言配置。\r\n","\r\n Gets the \"GetAwaiter\" method.\r\n ":"\r\n 获取“ getawaiter”方法。\r\n \r\n","All the import/using directives found along the traversal":"沿遍历发现的所有导入/使用指令\r\n","\r\n The possible states that the mini scanning can be in.\r\n ":"\r\n 可能指出的是迷你扫描可以进入。\r\n \r\n","\r\n If CoClassAttribute was applied to the type returns the type symbol for the argument. \r\n Type symbol may be an error type if the type was not found. Otherwise returns Nothing\r\n ":"\r\n 如果将coclassattribute应用于类型，则返回参数的类型符号。\r\n 如果找不到类型，则类型符号可能是错误类型。否则什么都不会返回\r\n \r\n","\r\n            Mapped exception regions around the active statement.\r\n            ":"\r\n            绘制的围绕活动语句的异常区域。\r\n            \r\n","\r\n The statement that ends the block declaration.\r\n ":"\r\n 结束块声明的声明。\r\n \r\n","\r\n  Looks up a localized string similar to Conversion operators cannot convert to an interface type..\r\n":"\r\n  查找类似于转换操作员的本地化字符串无法转换为接口类型。\r\n\r\n","\r\n  Looks up a localized string similar to Missing required white space..\r\n":"\r\n  查找类似于缺失所需的空白的本地化字符串。\r\n\r\n","\r\n            The type of the variable.\r\n            ":"\r\n            变量的类型。\r\n            \r\n","A static anonymous function cannot contain a reference to '{0}'.":"静态匿名函数不能包含对“ {0}”的引用。\r\n","Null check can be clarified":"无效检查可以澄清\r\n","\r\n            Override this if you want to provide customized insertion based on the character typed.\r\n            ":"\r\n            如果您想根据键入的字符提供自定义的插入，请覆盖此内容。\r\n            \r\n","\r\n  Looks up a localized string similar to Attribute '{0}' cannot be applied to '{1}' because the attribute is not valid on this declaration type..\r\n":"\r\n  查找类似于属性'{0}'的本地化字符串不能应用于'{1}'，因为该属性在此声明类型上无效。\r\n\r\n","\r\n            One of \\s \\S \\d \\D \\w \\W\r\n            ":"\r\n            \\ s \\ s \\ d \\ d \\ d \\ w \\ w之一\r\n            \r\n","\r\n Represents an expression that creates a new array without naming the element\r\n type.\r\n ":"\r\n 代表一个创建新数组而不命名元素的表达式\r\n 类型。\r\n \r\n","\r\n This symbol is used as the return type of a LambdaSymbol when we are interpreting \r\n lambda's body in order to infer its return type.\r\n ":"\r\n 当我们解释时，此符号用作lambdasymbol的返回类型\r\n Lambda的身体是为了推断其返回类型。\r\n \r\n","\r\n Continue looking for declaration of predefined CorLib type in this Assembly\r\n while symbols for new type declarations are constructed.\r\n ":"\r\n 继续在此组件中寻找预定义的corlib类型的声明\r\n 而构建了新类型声明的符号。\r\n \r\n","\r\n Returns whether this built-in operator checks for integer overflow.\r\n ":"\r\n 返回该内置操作员是否检查整数溢出。\r\n \r\n","The AddressOf expression.":"地址表达式。\r\n","\r\n            Gets the node used for display info\r\n            ":"\r\n            获取用于显示信息的节点\r\n            \r\n","\r\n Method that is called from the CachingLookup to get all child names. Looks\r\n in all constituent namespaces.\r\n ":"\r\n 从缓存lookup调用以获取所有子名称的方法。看起来\r\n 在所有组成命名空间中。\r\n \r\n","\r\n            Reads compilation outputs such as output assembly and PDB.\r\n            ":"\r\n            读取汇编输出，例如输出组件和PDB。\r\n            \r\n","month (full)":"月（满）\r\n","The single declarations.":"单一声明。\r\n","\r\n            Takes an INCLUSIVE range of trivia from the trivia list. \r\n            ":"\r\n            从琐事名单中获取包容性的琐事。\r\n            \r\n","\r\n  Looks up a localized string similar to Expected closing '?>' for XML processor instruction..\r\n":"\r\n  查找类似于XML处理器指令的预期关闭'？>'的本地化字符串。\r\n\r\n","\r\n            Signature Help was triggered through the 'Type Char' command.\r\n            ":"\r\n            签名帮助是通过“类型char”命令触发的。\r\n            \r\n","\r\n            Gets code actions that, when applied, will fix the missing imports for the document using\r\n            the information from the provided fixes.\r\n            ":"\r\n            获取代码操作，当应用时，将使用使用\r\n            提供的修复程序中的信息。\r\n            \r\n","\r\n Report a given variable as not definitely assigned.  Once a variable has been so\r\n reported, we suppress further reports of that variable.\r\n ":"\r\n 报告给定变量不确定。一旦变量如此\r\n 报告，我们抑制了该变量的进一步报告。\r\n \r\n","This code used to be in ParseEventDefinition.":"该代码曾经在ParseeventDefinition中。\r\n","\r\n            If this item is something that cannot be navigated to.  We store this in our\r\n            ":"\r\n            如果此项目无法导航。我们将其存储在我们的\r\n            \r\n","\r\n Analyzes structure type for circularities. Reports only errors relevant for 'structBeingAnalyzed' type.\r\n ":"\r\n 分析循环系统的结构类型。报告仅与“结构分析”类型相关的错误。\r\n \r\n"," is a named argument.\r\n            ":"是一个名称的参数。\r\n            \r\n","\r\n Imports appearing in ":"\r\n 进口出现在\r\n","s \r\n            in given ":"s\r\n            给定\r\n"," only provides diagnostics for either push or pull purposes (but not both).\r\n            If the caller's desired purpose doesn't match the option value, then this will return nothing, otherwise it\r\n            will return the requested buckets.":"仅提供用于推送或拉的目的（但两者兼而有之）的诊断。\r\n            如果呼叫者的所需目的与选项值不匹配，则将其返回，否则\r\n            将返回请求的存储桶。\r\n","The \"g\" or \"gg\" custom format specifiers (plus any number of additional \"g\" specifiers) represents the period or era, such as A.D. The formatting operation ignores this specifier if the date to be formatted doesn't have an associated period or era string.\r\n             ...":"“ g”或“ gg”自定义格式指定符（加上任何数量的附加“ g”指示符）代表时期或ERA，例如A.D. A.D.格式化操作如果要格式化的日期没有关联的期限，则忽略此说明符或ERA字符串。\r\n             ...\r\n","Add null check":"添加空检查\r\n","Initialize property '{0}'":"初始化属性'{0}'\r\n","\r\n Returns True if the inference algorithm should be restarted.\r\n ":"\r\n 如果应重新启动推理算法，则返回true。\r\n \r\n","\r\n Returns a copy of this with the Reference property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，参考属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n"," as we do not want to \r\n            wrap before a dot in a ":" 因为我们不想\r\n            在点之前包裹\r\n","\r\n The value for the ExitKeyword property.\r\n ":"\r\n ExitKeyWord属性的值。\r\n \r\n","\r\n            Returns the node that should be displayed\r\n            ":"\r\n            返回应显示的节点\r\n            \r\n","lambda attributes":"lambda属性\r\n","Simplify LINQ expression":"简化LINQ表达式\r\n","\r\n The base class for the possible clauses of an Imports statement.\r\n ":"\r\n 导入语句的可能子句的基类。\r\n \r\n",").\r\n            Unresolved references are resolved when the script is about to be executed \r\n            (":"）。\r\n            即将执行脚本时，未解决的参考可以解决\r\n            （（\r\n","\r\n            Here \"stringList.await\" is thought of as the return type of a local function.\r\n            ":"\r\n            这里“ stringlist.await”被认为是本地函数的返回类型。\r\n            \r\n","\r\n            Calculates the distance between two syntax nodes, disregarding trivia. \r\n            ":"\r\n            计算两个语法节点之间的距离，无视琐事。\r\n            \r\n"," by default.\r\n            The only exception is the case where a ":" 默认。\r\n            唯一的例外是\r\n","The method symbol that was declared.":"声明的方法符号。\r\n","\r\n Returns a copy of this with the Operand property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，操作数属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            True if the list should be dismissed when the user deletes the last character in the span.\r\n            ":"\r\n            正确，如果在用户删除跨度中的最后一个字符时应删除列表。\r\n            \r\n"," and \"CodeRefactoringProvider\".\r\n            ":" 和“ CodereFactoringProvider”。\r\n            \r\n","\r\n Represents an interactive code entry point that is inserted into the compilation if there is not an existing one.\r\n ":"\r\n 代表一个交互式代码输入点，如果没有现有的代码输入点，则将其插入汇编。\r\n \r\n","Convert to class":"转换为课程\r\n","var i = 0":"var i = 0\r\n","\r\n Verifies for control variable declaration and outputs diagnostics as needed.\r\n ":"\r\n 验证控制变量声明并根据需要输出诊断。\r\n \r\n","The \"ffffff\" custom format specifier represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value.\r\n            \r\n            Although it's possible to display the millionths of a second component of  ...":"“ FFFFFF”自定义格式指定符表示秒数的六个最重要的数字；也就是说，它代表了日期和时间价值中的百万分之一。\r\n            \r\n            虽然可以显示...的第二个组成部分的百万分之一\r\n","\r\n The binding of the loop body and the next variables cannot happen before the local type inference has\r\n completed, which happens in the specialized binding functions for foreach and for loops. Otherwise we would\r\n loose the diagnostics from the type inference.\r\n ":"\r\n 循环主体的绑定和下一个变量在本地类型推理具有\r\n 完成，发生在foreach和循环的专用绑定函数中。否则我们会\r\n 从类型推理中释放诊断。\r\n \r\n","\r\n NoOpStatementFlavor specifies additional info that NoOp statement may be carrying;\r\n Such info may be used in rewriting or code gen phases to perform some special actions\r\n ":"\r\n NoOpstatementFlavor指定了NOOP语句可能携带的其他信息；\r\n 此类信息可以用于重写或代码阶段来执行一些特殊操作\r\n \r\n","Property referenced implicitly":"隐式引用的属性\r\n","\r\n Creates a TryFinally Statement for the given resource.\r\n \r\n This method creates the following for the arguments:\r\n      <localSymbol> = <initializationExpression>\r\n      Try\r\n         <currentBody>\r\n      Finally\r\n          If <disposeCondition> Then\r\n              <disposeConversion>.Dispose()\r\n          End If\r\n      End Try\r\n \r\n Note: this is used for both kinds of using statements (resource locals and resource expressions).\r\n \r\n ":"\r\n 为给定资源创建一个尝试的语句。\r\n \r\n 此方法为参数创建以下内容：\r\n      <lacalsymbol> = <初始化表达>\r\n      尝试\r\n         <CurrentBody>\r\n      最后\r\n          如果<depdosecondition>则\r\n              <depsoconversion> .dispose（）\r\n          万一\r\n      结束尝试\r\n \r\n 注意：这用于两种使用语句（资源本地和资源表达式）。\r\n \r\n \r\n","\r\n            Provides a completion provider that always appears after all built-in completion providers. This completion\r\n            provider does not provide any completions.\r\n            ":"\r\n            提供了一个完整的提供商，该提供商总是在所有内置完成提供商之后出现。这个完成\r\n            提供者不提供任何完成。\r\n            \r\n","You can only change the signature of a constructor, indexer, method or delegate.":"您只能更改构造函数，索引器，方法或委托的签名。\r\n","\r\n            Try to change the namespace declaration based on the following rules:\r\n                - if neither declared nor target namespace are \"\" (i.e. global namespace),\r\n                then we try to change the name of the namespace.\r\n                - if declared namespace is \"\", then we try to move all types declared \r\n                in global namespace in the document into a new namespace declaration.\r\n                - if target namespace is \"\", then we try to move all members in declared \r\n                namespace to global namespace (i.e. remove the namespace declaration).    \r\n            ":"\r\n            尝试根据以下规则更改名称空间声明：\r\n                 - 如果既不声明和目标名称空间”（即全局名称空间），则\r\n                然后，我们尝试更改名称空间的名称。\r\n                 - 如果声明的名称空间为“”，那么我们尝试移动所有声明的类型\r\n                在文档中的全局名称空间中，将新的名称空间声明。\r\n                 - 如果目标名称空间为“”，那么我们将尝试移动所有成员\r\n                名称空间到全局名称空间（即删除名称空间声明）。\r\n            \r\n"," in each group.\r\n            ":" 在每个组中。\r\n            \r\n","\r\n            The span of the syntax element at the caret position when the ":"\r\n            当伦敦位置的语法元素的跨度\r\n","When false, variables whose data flow is not understood\r\n            will be returned in ":"当false时，数据流的变量不了解\r\n            将返回\r\n"," Check node for being assigned, return the value of unassigned slot in unassignedSlot ":" 检查节点是否被分配，返回未分配的插槽中未分配的插槽的值\r\n","\r\n            Called when a body of a constructor or an initializer of a member is updated or inserted.\r\n            ":"\r\n            更新或插入构造函数或成员的初始化器时调用。\r\n            \r\n","Set of symbols that should not be captured using a copy constructor":"不应使用复制构造函数捕获的一组符号\r\n","\r\n Specifies the binder which requests an access to the bound node for omitted left.\r\n ":"\r\n 指定粘合剂，要求访问对左侧的省略节点的访问。\r\n \r\n","\r\n The \"#\" type character.\"\r\n ":"\r\n “＃”类型字符。\r\n \r\n","\r\n The contents of the interpolated string.\r\n ":"\r\n 插值字符串的内容。\r\n \r\n","\r\n            Helper class used for working with file headers.\r\n            ":"\r\n            用于使用文件标头的助手类。\r\n            \r\n","\r\n Returns the corresponding symbol in this type or a base type that implements \r\n interfaceMember (either implicitly or explicitly), or null if no such symbol \r\n exists (which might be either because this type doesn't implement the container \r\n of interfaceMember, or this type doesn't supply a member that successfully \r\n implements interfaceMember).\r\n ":"\r\n 返回此类型中的相应符号或实施的基本类型\r\n Interfacemember（隐式或显式），如果没有此类符号，则无效\r\n 存在（这可能是因为这种类型无法实现容器\r\n Interfacemember或这种类型的人无法提供成功的成员\r\n 实施Interfacemember）。\r\n \r\n"," [is array].":" [is数组]。\r\n","\r\n True if Option Infer On is in effect. False if Option Infer Off is in effect.\r\n ":"\r\n 如果可以推断选项有效，则为正确。错误如果选项推断有效。\r\n \r\n","x as T":"x为t\r\n","\r\n True if the redundant type parameter constraints should be reported as\r\n errors. For overridden methods, this is False since type substitution of type\r\n arguments for the base/interface may result in redundant constraints.\r\n ":"\r\n 如果应将冗余类型参数约束报告为\r\n 错误。对于覆盖方法，这是错误的，因为类型替换\r\n 基本/接口的参数可能会导致冗余约束。\r\n \r\n","An interpolated string handler construction cannot use dynamic. Manually construct an instance of '{0}'.":"插值字符串处理程序结构不能使用动态。手动构造一个“ {0}”的实例。\r\n","\r\n Represents character data in Xml content also known as PCData or in an Xml\r\n attribute value. All text is here for now even text that does not need\r\n normalization such as comment, pi and cdata text.\r\n ":"\r\n 在XML内容中表示字符数据，也称为pcdata或XML中\r\n 属性值。所有文本现在都在这里，甚至不需要\r\n 标准化，例如评论，PI和CDATA文本。\r\n \r\n","Simplify Member Access":"简化会员访问\r\n","\r\n            Pre-remap PDB span.\r\n            ":"\r\n            预示例PDB跨度。\r\n            \r\n","\r\n Checks that candidate Null expression is a simple expression that produces Null of the desired type\r\n (not a conversion or anything like that) and returns it.\r\n Otherwise creates \"New T?()\" expression.\r\n ":"\r\n 检查候选Null表达式是否是生成所需类型的Null的简单表达式\r\n （不是转换或类似的东西）并返回它。\r\n 否则创建\"新T？()\"的表达。\r\n \r\n","\r\n            Override this method to register custom language specific actions to find symbol usages.\r\n            ":"\r\n            重写此方法以注册特定于自定义语言的操作以查找符号用法。\r\n            \r\n","\r\n Only (original) source symbols and namespaces that can be merged\r\n need override this function if they want to do so for efficiency.\r\n ":"\r\n 仅（原始）源符号和可以合并的名称空间\r\n 如果他们想这样做，就需要覆盖此功能。\r\n \r\n","\r\n            Checks if the already inserted token is a valid opening token at the position in the document.\r\n            By default checks that the opening token is a valid token at the position and not in skipped token trivia.\r\n            ":"\r\n            检查已经插入的令牌是否是文档中该位置的有效开口令牌。\r\n            默认情况下，检查开口令牌是否是该位置的有效令牌，而不是跳过的令牌琐事。\r\n            \r\n","\r\n The \"To\" keyword\r\n ":"\r\n “到”关键字\r\n \r\n","\r\n Use the receiver of the ObjectCreationExpression as the omitted left of a member access.\r\n ":"\r\n 将objectCreationexpression的接收器作为成员访问的剩余省略。\r\n \r\n","\r\n  Looks up a localized string similar to Using DirectCast operator to cast a floating-point value to the same type is not supported..\r\n":"\r\n  不支持查找类似于使用Directcast运算符将浮点值投射到同一类型的本地化字符串。\r\n\r\n","\r\n tells if given node contains a label statement that defines given label symbol\r\n ":"\r\n 告诉给定节点是否包含一个标签语句，该语句定义给定标签符号\r\n \r\n","\r\n Represents an unrecognized pre-processing directive. This occurs when the\r\n parser encounters a hash '#' token at the beginning of a physical line but does\r\n recognize the text that follows as a valid Visual Basic pre-processing\r\n directive.\r\n ":"\r\n 代表未识别的预处理指令。这发生在\r\n 解析器在物理线开始时遇到一个hash'＃'令牌\r\n 识别随后作为有效的视觉基本预处理的文本\r\n 指示。\r\n \r\n","\r\n            Gets the replacement node for a compound assignment expression whose\r\n            assigned value is redundant.\r\n            For example, \"x += MethodCall()\", where assignment to 'x' is redundant\r\n            is replaced with \"_ = MethodCall()\" or \"var unused = MethodCall()\"\r\n            ":"\r\n            获取复合分配表达式的替换节点\r\n            分配的值是多余的。\r\n            例如，“ x += methodCall（）”，其中分配给'x'是多余的\r\n            被“ _ = MethodCall（）”或“ var Unused = MethodCall（）”代替\r\n            \r\n","\r\n  Looks up a localized string similar to Namespace declaration must start with 'xmlns'..\r\n":"\r\n  查找类似于名称空间声明的本地化字符串必须以“ XMLNS”开头。\r\n\r\n","\r\n This binder is for binding the argument to GetType.  It traverses\r\n the syntax marking each open type (\"unbound generic type\" in the\r\n VB spec) as either allowed or not allowed, so that BindType can \r\n appropriately return either the corresponding type symbol or an \r\n error type.  \r\n ":"\r\n 该活页夹是为了将论点绑定到getType。它穿越\r\n 语法标记每个开放类型（在\r\n VB规格）是允许或不允许的，因此BindType可以\r\n 适当返回相应的类型符号或\r\n 错误类型。\r\n \r\n","The source token.":"源代币。\r\n"," finds ":" 找到\r\n","The bound initializing expression":"绑定的初始化表达式\r\n","\r\n This instance is intended to reflect the definition of signature equality used by the runtime (ECMA 335 Section 8.6.1.6).\r\n It considers return type, name, parameters, calling convention, and custom modifiers.\r\n ":"\r\n 此实例旨在反映运行时使用的签名平等的定义（ECMA 335第8.6.1.6节）。\r\n 它考虑返回类型，名称，参数，调用惯例和自定义修饰符。\r\n \r\n","\r\n The value for the HashToken property.\r\n ":"\r\n Hashtoken属性的价值。\r\n \r\n","\r\n The member(s) that are potentially being overridden. This collection only contains \r\n candidates having signature 'exactly' matching the signature of the method/property. \r\n \r\n 'Exact' signature match is defined as 'general' signature match plus NO\r\n mismatches in total number of parameters or optional parameter types.\r\n \r\n See comments on InaccessibleMembers for more details on 'general' signature match.\r\n ":"\r\n 可能被覆盖的成员。该集合仅包含\r\n 具有签名“恰好”匹配方法/属性的签名的候选人。\r\n \r\n “确切”签名匹配被定义为“一般”签名匹配以及否\r\n 参数或可选参数类型的总数不匹配。\r\n \r\n 有关“通用”签名匹配的更多详细信息，请参见有关Inaccessiblembers的评论。\r\n \r\n","\r\n Represents the \"Group Join\" query operator.\r\n ":"\r\n 代表“组加入”查询操作员。\r\n \r\n","Pattern missing":"缺少模式\r\n","Add parameter to '{0}' (and overrides/implementations)":"将参数添加到'{0}'（以及覆盖/实现）\r\n","Add 'string.IsNullOrEmpty' check":"添加'string.isnullorrempty'检查\r\n","\r\n  Looks up a localized string similar to Value '{0}' cannot be converted to '{1}'..\r\n":"\r\n  查找类似于值'{0}'的本地化字符串不能转换为'{1}'..\r\n\r\n","\r\n Creates the index increment statement.\r\n ":"\r\n 创建索引增量语句。\r\n \r\n","\r\n Compiles the method.\r\n ":"\r\n 编译方法。\r\n \r\n","\r\n The list of expression range variables being defined by the Select query\r\n operator.\r\n ":"\r\n 选择查询定义的表达范围变量列表\r\n 操作员。\r\n \r\n","\r\n            The rule removes characters from the existing set of characters.\r\n            ":"\r\n            该规则从现有字符集中删除字符。\r\n            \r\n","Nullability in constraints for type parameter '{0}' of method '{1}' doesn't match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.":"类型参数'方法'{1}'的约束中的删除性与类型参数'{2}'接口方法'{3}'的约束不匹配。考虑使用显式接口实现。\r\n","\r\n  Looks up a localized string similar to Cannot refer to an instance member of a class from within a shared method or shared member initializer without an explicit instance of the class..\r\n":"\r\n  查找类似于类似的本地化字符串，无法从共享方法或共享成员初始化器中的类中的实例成员参考，而没有类的显式实例。\r\n\r\n","An exception handling ancestor of an active statement node.":"Active语句节点的祖先的例外。\r\n","\r\n If the For or For Each statement is of a form that does not declare a new loop\r\n control variable, this is the expression that denotes the loop control\r\n variable. If this loop is of a form that does declare a new control variable,\r\n this is a VariableDeclarator that has the variable being declared.\r\n ":"如果每个语句的for或for for for均为未声明新循环的表格\r\n 控制变量，这是表示循环控制的表达式\r\n 多变的。如果此循环的形式确实声明了新的控制变量，则\r\n 这是一个变量被声明的变量。\r\n \r\n","\r\n            Renames a type to match its containing file name.\r\n            ":"\r\n            重命名类型以匹配其包含的文件名。\r\n            \r\n","\r\n Checks if the node is inside the attribute arguments \r\n ":"\r\n 检查节点是否在属性参数中\r\n \r\n","Pascal Case":"帕斯卡案\r\n","\r\n            The annotation added to the type declaration that was passed in to create the mapping\r\n            ":"\r\n            添加到传递以创建映射的类型声明中的注释\r\n            \r\n","\r\n Represents a For or For Each block, including the introducing statement, the\r\n body and the \"Next\" (which can be omitted if a containing For has a Next with\r\n multiple variables).\r\n ":"\r\n 代表每个块或每个块，包括介绍语句，\r\n 身体和“下一步”（如果包含的下一个，则可以省略\r\n 多个变量）。\r\n \r\n"," if this constructor will include debuggable initializers.":" 如果该构造函数将包含可辩论的初始化器。\r\n","\r\n If the method being compiled is a constructor, CompileMethod returns in this parameter \r\n the symbol of the constructor called from the one being compiled either explicitly or implicitly. \r\n For structure constructors calling parameterless constructor returns the synthesized constructor symbol.\r\n ":"\r\n 如果要编译的方法是构造函数，则compilemethod返回此参数\r\n 从一个被明确或隐式编译的构造函数的符号。\r\n 对于结构构造函数，调用无参数构造函数将返回合成的构造函数符号。\r\n \r\n","\r\n Given an FieldInitializerSyntax, get the corresponding symbol of anonymous type creation.\r\n ":"\r\n 给定一个fieldInitializerSyntax，获取匿名类型创建的相应符号。\r\n \r\n","Use block body for local functions":"将块主体用于本地功能\r\n","Implement abstract class":"实施摘要类\r\n","\r\n Return the flow analysis state associated with a label.\r\n ":"\r\n 返回与标签相关的流分析状态。\r\n \r\n","\r\n            The first syntax error, or null if the document does not have syntax errors reported by the compiler.\r\n            ":"\r\n            第一个语法错误或null如果文档没有编译器报告的语法错误。\r\n            \r\n"," that represents\r\n an assembly that is not missing, i.e. the \"real\" thing.\r\n ":" 代表\r\n 一个不丢失的集会，即“真实”的东西。\r\n \r\n","\r\n Does this symbol represent a missing assembly.\r\n ":"\r\n 此符号代表缺失的组件吗？\r\n \r\n","\r\n Returns a copy of this with the Right property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此的副本，正确的属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n If name is \"xmlns\", set prefix to String.Empty and return True.\r\n If name is \"xmlns:p\", set prefix to p and return True.\r\n Otherwise return False.\r\n ":"\r\n 如果名称为“ XMLNS”，请将前缀设置为String.Empty并返回true。\r\n 如果名称为“ xmlns：p”，请将前缀设置为p并返回true。\r\n 否则返回false。\r\n \r\n","The syntax to bind.":"语法结合。\r\n","\r\n The value for the BeginCDataToken property.\r\n ":"\r\n BeginCdatatoken属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to '#Region' statement must end with a matching '#End Region'..\r\n":"\r\n  查找类似于“ #Region”语句的本地化字符串必须以匹配的“ #end region”结尾。\r\n\r\n","\r\n  Looks up a localized string similar to Class '{0}' must either be declared 'MustInherit' or override the following inherited 'MustOverride' member(s): {1}..\r\n":"查找类似于“ {0}”类的本地化字符串，必须声明为'MustInherit'或覆盖以下继承的“ Mustoverride”成员：{1} ..\r\n\r\n","\r\n            Find an appropriate span to pass the debugger given a point in a snapshot.  Optionally\r\n            pass back a string to pass to the debugger instead if no good span can be found.  For\r\n            example, if the user hovers on \"var\" then we actually want to pass the fully qualified\r\n            name of the type that 'var' binds to, to the debugger.\r\n            ":"\r\n            找到合适的跨度以通过快照中的点通过调试器。可选\r\n            如果找不到良好的跨度，则将字符串传递给调试器。为了\r\n            例如，如果用户徘徊在“ var”上，那么我们实际上要通过完全合格的\r\n            “ var”类型的名称与调试器结合。\r\n            \r\n","Private method '{0}' can be removed as it is never invoked.":"私有方法'{0}'可以被删除，因为它从未被调用。\r\n","\r\n            An optional completion provider that can provide completion items for this\r\n            specific embedded language.\r\n            \r\n            ":"\r\n            可选的完成提供商，可以为此提供完成项目\r\n            特定的嵌入式语言。\r\n            \r\n            \r\n","\r\n            Complexify makes inferred names explicit for tuple elements and anonymous type members. This\r\n            class considers which ones of those can be simplified (after the refactoring was done).\r\n            If the inferred name of the member matches, the explicit name (from Complexify) can be removed.\r\n            ":"\r\n            复杂化使元组元素和匿名类型成员的推断名称明确。这个\r\n            班级认为可以简化哪些可以简化（在进行重构之后）。\r\n            如果会员匹配的推断名称，则可以删除显式名称（从复杂化）。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Option Strict' can be followed only by 'On' or 'Off'..\r\n":"\r\n  查找类似于“选项严格”的局部字符串，只能在“ on”或“ off”中。\r\n\r\n","\r\n The value for the SubNewStatement property.\r\n ":"\r\n 子调查属性的值。\r\n \r\n",",\r\n            - a method, an indexer or a type (delegate) if the ":"，，，，\r\n             - 方法，索引器或类型（委托）\r\n"," returned when no items are found to populate the list.\r\n            ":" 当找不到填充列表的项目时返回。\r\n            \r\n"," a\r\n             single character long).\r\n            \r\n             There are multi-character tokens though.  For example ```10``` in ```a{10,}``` or ```name```\r\n             in ```\\k'name'```\r\n             ":" 一个\r\n             单个字符长）。\r\n            \r\n             不过，有多个特定令牌。例如，````10'''a {10，}\r\n             在``\\ k'name'```\r\n             \r\n","SymReader open on a Portable or Windows PDB.":"Symreader在便携式或Windows PDB上打开。\r\n","\r\n Given an identifier, return true if the identifier declares an array.\r\n (e.g., identifier  specifies ())\r\n ":"\r\n 给定标识符，如果标识符声明数组，则返回true。\r\n （例如，标识符指定（））\r\n \r\n","month (2 digits)":"月（2位数字）\r\n","\r\n            Returns true if the parameters of the symbol are lifted into a scope that is different from the symbol's body.\r\n            ":"\r\n            如果将符号的参数提升为与符号主体不同的范围，则返回true。\r\n            \r\n","\r\n Creates a binder for binding for binding inside the interior of documentation comment \r\n ":"\r\n 创建一个粘合剂，用于在文档注释内部绑定以绑定绑定\r\n \r\n","negative unicode category":"负UNICODE类别\r\n","\r\n This method is overridden by RetargetingNamespaceSymbol and allows it to delegate majority of the work \r\n to the underlying namespace symbol, but still retarget method symbols before they are added to the map\r\n of extension methods.\r\n ":"\r\n 此方法被retargetingnamespaceSymbol覆盖，并允许其委派大部分工作\r\n 到基础名称空间符号，但在将其添加到地图之前仍在重新定位方法符号\r\n 扩展方法。\r\n \r\n","\r\n The value for the EndWithStatement property.\r\n ":"\r\n EndWithStatement属性的值。\r\n \r\n","Apply inline 'out' variables preferences":"应用内联变量首选项\r\n","\r\n Helper method to create a bound sequence to represent the idea:\r\n \"compute this value, and then compute this side effects while discarding results\"\r\n\r\n A Bound sequence is generated for the provided expr and side-effects, say {se1, se2, se3}, as follows:\r\n\r\n If expr is of void type:\r\n     BoundSequence { side-effects: { expr, se1, se2, se3 }, valueOpt: Nothing }\r\n \r\n ElseIf expr is a constant:\r\n     BoundSequence { side-effects: { se1, se2, se3 }, valueOpt: expr }\r\n \r\n Else\r\n     BoundSequence { side-effects: { tmp = expr, se1, se2, se3 }, valueOpt: tmp }\r\n ":"\r\n 辅助方法创建一个绑定序列以表示思想：\r\n “计算此值，然后在丢弃结果时计算此副作用”\r\n\r\n 为提供的expr和副作用（例如{se1，se2，se3}）生成一个绑定序列，如下：\r\n\r\n 如果Expr具有无效类型：\r\n     boundSequence {side-effects：{expr，se1，se2，se3}，valueopt：nothene}\r\n \r\n Elseif expr是一个常数：\r\n     boundSequence {side-effects：{se1，se2，se3}，valueOpt：expr}\r\n \r\n 别的\r\n     boundSequence {side-effects：{tmp = expr，se1，se2，se3}，valueOpt：tmp}\r\n \r\n","The expression of this argument if it is a simple argument; otherwise null.":"如果这是一个简单的参数，则该参数的表达；否则为空。\r\n","\r\n Optional \"As XXX\" clause describing the underlying type of the enumeration. If\r\n no As clause was specified, Nothing is returned.\r\n ":"\r\n 可选的“ AS XXX”子句，描述了枚举的基本类型。如果\r\n 没有指定条款，什么也没有返回。\r\n \r\n","Warning: Iteration variable crossed function boundary.":"警告：迭代变量交叉函数边界。\r\n","\r\n Is the symbol an instance member (i.e. access requires a receiver)\r\n ":"\r\n 是实例成员的符号（即访问需要接收器）\r\n \r\n","\r\n We know that we'll never have a method context because that's what we're\r\n trying to find.  Instead, just return an indexed type parameter that will\r\n make comparison easier.\r\n ":"\r\n 我们知道我们永远不会有方法上下文，因为这就是我们\r\n 试图找到。相反，只需返回索引类型参数\r\n 使比较更容易。\r\n \r\n","\r\n matches one char or another.\r\n it will try normal width and then fullwidth variations.\r\n Typical usage is for matching lowercase and uppercase.\r\n ":"\r\n 匹配一个或另一个字符。\r\n 它将尝试正常的宽度，然后尝试全宽变化。\r\n 典型的用法是匹配小写和大写。\r\n \r\n","\r\n A program location in source code.\r\n ":"\r\n 源代码中的程序位置。\r\n \r\n","Add tuple element name '{0}'":"添加元组元素名称'{0}'\r\n","\r\n            If we have a method ToXXX and its return type is also XXX, then type name is apparent\r\n            e.g: Convert.ToString.\r\n            ":"\r\n            如果我们有一种方法toxxx且其返回类型也是xxx，则类型名称是显而易见的\r\n            例如：转换。\r\n            \r\n","\r\n This method indicates whether or not the runtime will regard the method\r\n as newslot (as indicated by the presence of the \"newslot\" modifier in the\r\n signature).\r\n WARN WARN WARN: We won't have a final value for this until declaration\r\n diagnostics have been computed for all ":"\r\n 此方法指示运行时是否会考虑该方法\r\n 如Newslot（如在“新闻插槽”修饰符中的存在所示\r\n 签名）。\r\n 警告警告：直到宣布，我们不会对此有最终价值\r\n 已经计算出所有人的诊断\r\n","Convert to decimal":"转换为十进制\r\n","Adding an abstract {0} or overriding an inherited {0} requires restarting the application.":"添加摘要{0}或覆盖继承的{0}需要重新启动应用程序。\r\n","The CallerArgumentExpressionAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments":"应用于参数'{0}'的CallerArgumentExpressepresseptresseptresseattribute将无效，因为它适用于不允许可选参数的上下文中使用的成员\r\n"," is underselected given ":" 被安置\r\n","\r\n Returns a copy of this with the DisableKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 将其返回此副本，并将DisableYword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n   Parses an ObjectCollectionInitializer\r\n         ObjectCollectionInitializer -> \"from\" CollectionInitializer\r\n \r\n ":"\r\n   解析objectCollectionInitializer\r\n         ObjectCollectionInitializer->“来自” CollectionInitializer\r\n \r\n \r\n"," may be either a node of the declaration body or an active node that belongs to the declaration.\r\n            ":" 可以是声明体的节点，也可以是属于声明的活动节点。\r\n            \r\n","\r\n Returns false if there were errors reported due to access exposure, true otherwise.\r\n ":"\r\n 如果由于访问曝光而报告错误，则返回错误，否则为否。\r\n \r\n","\r\n Gets the list of named field or property value arguments specified by this application of the attribute.\r\n ":"\r\n 获取本属性应用程序指定的命名字段或属性值参数的列表。\r\n \r\n","\r\n  Looks up a localized string similar to No accessible method '{0}' has a signature compatible with delegate '{1}':{2}.\r\n":"\r\n  查找类似于无访问方法的本地化字符串'{0}'具有与委托'{1}'：{2}兼容的签名。\r\n\r\n","\r\n Given an ExpressionRangeVariableSyntax, get the corresponding symbol.\r\n ":"\r\n 给定表达式variablesyntax，获取相应的符号。\r\n \r\n","\r\n The symbol of method whose body is being analyzed or field or property whose \r\n initializer is being analyzed\r\n ":"\r\n 其身体正在分析的符号，现场或财产的符号\r\n 初始化器正在分析\r\n \r\n","\r\n An expression representing the value of the pre-processing constant being\r\n defined.\r\n ":"\r\n 表示预处理常数的值的表达式\r\n 定义。\r\n \r\n","\r\n            or returns the ":"\r\n            或返回\r\n","\r\n  Looks up a localized string similar to Embedded interop structure '{0}' can contain only public instance fields..\r\n":"\r\n  查找类似于嵌入式Interop结构'{0}'的本地化字符串可以包含公共实例字段。\r\n\r\n","\r\n A method that results from the translation of a single lambda expression.\r\n ":"\r\n 由单个lambda表达式翻译产生的方法。\r\n \r\n"," change\r\n            ":" 改变\r\n            \r\n","\r\n  Looks up a localized string similar to 'Exit For' can only appear inside a 'For' statement..\r\n":"\r\n  查找类似于“退出”的本地化字符串，只能出现在a语句中。\r\n\r\n","\r\n Represents a type parameter constraint that is a type.\r\n ":"\r\n 代表类型类型的类型参数约束。\r\n \r\n"," node, if the cursor is in the name of first \r\n            declaration in global namespace and there's no namespace declaration in this document.\r\n            (3) otherwise, null.\r\n            ":" 节点，如果光标以第一个的名义\r\n            在全球名称空间中声明，并且本文档中没有名称空间声明。\r\n            （3）否则，空。\r\n            \r\n","\r\n Rewrites a for each statement.\r\n ":"\r\n 为每个语句重写a。\r\n \r\n"," if called outside of an edit session.\r\n            The length of the returned array matches the length of ":" 如果在编辑会话中被调用。\r\n            返回阵列的长度与\r\n","Both partial method declarations must have the same return type.":"两种部分方法声明必须具有相同的返回类型。\r\n"," Describes the type descriptor location and property/parameter names associated with this location ":" 描述与此位置关联的类型描述符位置和属性/参数名称\r\n","\r\n            Internal symbol inaccessible because public key is wrong\r\n            ":"\r\n            内部符号无法访问，因为公钥是错误的\r\n            \r\n","\r\n            If inside a parenthesized or tuple expression, unwrap the nestings and return the container.\r\n            ":"\r\n            如果在括号内或元组表达式内部，请拆开巢穴并返回容器。\r\n            \r\n","\r\n            Are you possibly typing a tuple type or expression?\r\n            This is used to suppress colon as a completion trigger (so that you can type element names).\r\n            This is also used to recommend some keywords (like var).\r\n            ":"\r\n            您是否可能要键入元组类型或表情？\r\n            这用于抑制结肠作为完成触发器（因此您可以键入元素名称）。\r\n            这也用于推荐一些关键字（例如var）。\r\n            \r\n","event field":"事件字段\r\n","\r\n  Looks up a localized string similar to Statement cannot appear within a method body. End of method assumed..\r\n":"\r\n  查找类似于语句的本地化字符串无法在方法主体中出现。假设方法的结尾..\r\n\r\n","\r\n Represents an Inherits or Implements statement in a Class, Structure or\r\n Interface.\r\n ":"\r\n 代表班级，结构或\r\n 界面。\r\n \r\n","\r\n Is symbol a user-defined operator method.\r\n ":"\r\n 是用户定义的操作员方法。\r\n \r\n","\r\n The VisualBasicCommandLineParser class contains members used to perform various Visual Basic command line parsing operations.\r\n ":"\r\n VisualBasicCommandLineParser类包含用于执行各种视觉基本命令行解析操作的成员。\r\n \r\n","The delegate resolution result.":"委托解决结果。\r\n","\r\n            this contains all states regarding a ":"\r\n            这包含有关\r\n","\r\n The exprReturnLabel is used to label the return handling code at the end of the async state-machine\r\n method. Return expressions are rewritten as unconditional branches to exprReturnLabel.\r\n ":"\r\n Exprreturnlabel用于标记异步状态机末端的返回处理代码\r\n 方法。返回表达式被重写为无条件分支到Exprreturnlabel。\r\n \r\n","records":"记录\r\n","\r\n            Mapping from the name of receiver type to extension method symbol infos.\r\n            ":"\r\n            从接收器类型的名称映射到扩展方法符号信息。\r\n            \r\n","Generator '{0}' failed to initialize. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'":"生成器'{0}'无法初始化。它不会导致输出，因此可能会出现汇编错误。异常是类型为'{1}'带有消息'{2}'\r\n","\r\n            Wraps first item.  Subsequent items, if wrapped, will be aligned with that first item:\r\n                 MethodName(\r\n                     int a, int b, int c, int d, int e,\r\n                     int f, int g, int h, int i, int j)\r\n            ":"\r\n            包裹第一项。随后的项目（如果包装）将与第一个项目对齐：\r\n                 methodName（\r\n                     int a，int b，int c，int d，int e，\r\n                     int f，int g，int h，int i，int j）\r\n            \r\n","\r\n [methodGroup] can be Nothing if lookup didn't find anything.\r\n ":"\r\n [MethodGroup]如果查找找不到任何东西，则一无所有。\r\n \r\n","\r\n Returns a copy of this with the GetTypeKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中getTypeKeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","conditional group match":"有条件的小组匹配\r\n","\r\n The namespace or type containing the binding context\r\n ":"\r\n 名称空间或包含绑定上下文的类型\r\n \r\n","\r\n            Matching priority for the provided item when ":"\r\n            当提供的项目的优先级\r\n","\r\n The operator in the relational clause. One of \"=\", \"<\", \">\", \"<=\" or\r\n \">=\".\r\n ":"\r\n 关系子句中的操作员。 “ =”，“”，“>”，“”，“ <=”或\r\n “> =”。\r\n \r\n","\r\n  Looks up a localized string similar to Events cannot be declared with a delegate type that has a return type..\r\n":"\r\n  查找类似于事件的本地化字符串，无法使用具有返回类型的委托类型声明。\r\n\r\n","Illegal {x,y} with x > y":"X> y的非法{x，y}\r\n","\r\n  Looks up a localized string similar to The value '{0}' is not a valid subsystem version. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise..\r\n":"\r\n  查找类似于值'{0}'的本地化字符串不是有效的子系统版本。 ARM或AppContainerexe的版本必须为6.02或更高，否则为4.00或更高。\r\n\r\n","\r\n The \"New\", \"Class\" or \"Structure\" keyword that denotes the kind of special\r\n constraint.\r\n ":"\r\n 表示特殊的“新”，“类”或“结构”关键字\r\n 约束。\r\n \r\n","\r\n             Refactor:\r\n                 var x = GetAsync();\r\n            \r\n             Into:\r\n                 var x = await GetAsync();\r\n            \r\n             Or:\r\n                 var x = await GetAsync().ConfigureAwait(false);\r\n             ":"\r\n             重构：\r\n                 var x = getAsync（）;\r\n            \r\n             进入：\r\n                 var x =等待getAsync（）;\r\n            \r\n             或者：\r\n                 var x =等待getAsync（）。configureawait（false）;\r\n             \r\n","\r\n If Option Explicit is Off for this source file, then implicit variable declaration will be allowed\r\n in this binder. \"containerOfLocals\" is the container for implicitly declared variables.\r\n ":"\r\n 如果此源文件的epoct equape nub opare，则允许隐式变量声明\r\n 在这个活页夹中。 “容器输入”是隐式声明变量的容器。\r\n \r\n","\r\n            Parenthesize the left hand size of a member access, invocation or element access expression\r\n            ":"\r\n            括号化成员访问，调用或元素访问表达式的左手大小\r\n            \r\n","\r\n            The kind of character set modification.\r\n            ":"\r\n            角色集修改的种类。\r\n            \r\n","\r\n Given result of binding preceding query operators, the source, bind the following Take While operator.\r\n \r\n     {Preceding query operators} Take While {expression}\r\n \r\n Ex: From a In AA Skip While a > 0 ==> AA.TakeWhile(Function(a) a > b)\r\n \r\n ":"\r\n 给定绑定前面的查询操作员的结果，源，绑定了操作员时的以下拍摄。\r\n \r\n     {前面的查询操作员}以{expression}为例\r\n \r\n 例如：从A中的A跳过A> 0 ==> aa.take（function（a）a> b）\r\n \r\n \r\n","True if this argument is an omitted argument; otherwise false.":"如果此论点是一个省略的论点，则为是真的；否则错误。\r\n","\r\n Gets the separator at the given index in this list.\r\n ":"\r\n 在此列表中的给定索引中获取分离器。\r\n \r\n","number, decimal digit":"数字，十进制数字\r\n","\r\n A local symbol created from a variable declaration or a for statement with an as clause.\r\n ":"\r\n 由变量声明或具有AS子句的语句创建的本地符号。\r\n \r\n","Use local function":"使用本地功能\r\n","\r\n Check two corresponding type arguments T1 and T2 and determine if the cause or prevent variable ambiguity.\r\n \r\n Identical types never cause or prevent ambiguity.\r\n \r\n If there could exist a **distinct** third type T3, such that T1 and T2 both convert via the variance\r\n conversion to T3, then ambiguity is caused. This boils down to:\r\n   * Invariant parameters never cause ambiguity\r\n   * Covariant parameters \"Out T\": ambiguity is caused when the two type arguments \r\n     are non-object types not known to be values (T3=Object)\r\n   * Contravariant parameters \"In U\": ambiguity is caused when both:\r\n       - Neither T1 or T2 is a value type or a sealed (NotInheritable) reference type\r\n       - If T1 and T2 are both class types, one derives from the other. \r\n         (T3 is some type deriving or implementing both T1 and T2)\r\n \r\n  Ambiguity is prevented when there T1 and T2 cannot unify to the same type, and there \r\n  cannot be a (not necessarily distinct) third type T3 that both T1 and T2 convert to via\r\n  the variance conversion.\r\n \r\n  This boils down to:\r\n   * Invariant parameters: Ambiguity is prevented when:\r\n       - they are non-unifying\r\n   * Covariant parameters \"Out T\": Ambiguity is prevented when both:\r\n       - they are non-unifying\r\n       - at least one is a value type\r\n   * Contravariant parameters \"In U\": Ambiguity is prevented when:\r\n       - they are non-unifying AND\r\n          - at least one is known to be a value type OR\r\n          - both are known to be class types and neither derives from the other.\r\n ":"\r\n 检查两个相应的类型参数T1和T2，并确定原因或防止可变的歧义。\r\n \r\n 相同的类型永远不会引起或阻止歧义。\r\n \r\n 如果可能存在一个**不同的**第三类T3，则T1和T2都通过方差转换\r\n 转换为T3，然后引起歧义。这归结为：\r\n   *不变参数永远不会引起歧义\r\n   *协变量参数“ out t”：当两个类型参数时引起歧义\r\n     是非对象类型的不知道是值（T3 =对象）\r\n   *违反参数“在u”中：两者都会引起歧义：\r\n        -  T1或T2都不是值类型或密封（简直可用）的参考类型\r\n        - 如果T1和T2都是类型，则一个源自另一种类型。\r\n         （T3是某种派生或实现T1和T2的类型）\r\n \r\n  当T1和T2无法统一与同一类型时，可以防止歧义\r\n  不能是T1和T2转换为Via的（不一定是不同的）T3\r\n  方差转换。\r\n \r\n  这归结为：\r\n   *不变参数：何时防止歧义。\r\n        - 他们不统一\r\n   *协变量参数“ out t”：两者都可以防止歧义：\r\n        - 他们不统一\r\n        - 至少一种是价值类型\r\n   *违反参数“在u”中：在以下情况下防止歧义。\r\n        - 他们是非自称的，\r\n           - 至少一种是价值类型或\r\n           - 已知两者都是班级类型，并且两者都不来自其他类型。\r\n \r\n","\r\n  Looks up a localized string similar to 'Module' statement must end with a matching 'End Module'..\r\n":"\r\n  查找类似于“模块”语句的本地化字符串必须以匹配的“结束模块”结尾。\r\n\r\n","Blank line required between block and subsequent statement":"空白行所需的块和后续语句之间需要\r\n","\r\n            ```(?(capture_name)result)```\r\n            ":"\r\n            ````（？（capture_name）结果）``````''\r\n            \r\n"," method and produces \r\n a value of the type specified by the ":" 方法并产生\r\n 由\r\n","\r\n Binder to be used for binding New With { ... } expressions. \r\n ":"\r\n 粘合剂用于与{...}表达式绑定新的粘合剂。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' is not valid on a WithEvents declaration..\r\n":"\r\n  查找类似于“ {0}”的本地化字符串在withEvents声明中无效。\r\n\r\n","true if \"str.TrimStart().StartsWith(prefix)\"":"正确，如果“ str.trimstart（）。startswith（prefix）”\r\n","\r\n  Looks up a localized string similar to Attribute '{0}' in '{1}' cannot be applied multiple times..\r\n":"查找类似于属性'{0}'in'{1}''的局部字符串。\r\n\r\n","\r\n Adds an array of initializers to the member collections structure\r\n ":"\r\n 在成员收集结构中添加一系列初始化器\r\n \r\n","\r\n  Looks up a localized string similar to Conversion from 'Date' to 'Double' requires calling the 'Date.ToOADate' method..\r\n":"\r\n  查找类似于从“日期”转换为“ double”的局部字符串，需要调用“ date.tooadate”方法。\r\n\r\n","\r\n  Looks up a localized string similar to 'System.Runtime.InteropServices.DispIdAttribute' cannot be applied to '{0}' because 'Microsoft.VisualBasic.ComClassAttribute' reserves zero for the default property..\r\n":"\r\n  查找类似于'system.runtime.interopservices.dispidattribute'的本地化字符串，不能应用于'{0}'，因为'microsoft.visualbasic.classic.classic.classattribute'保留默认属性的零。\r\n\r\n","\r\n            Reference type so we can read/write atomically.\r\n            ":"\r\n            引用类型，以便我们可以原子地读/写。\r\n            \r\n","Accessing captured variable '{0}' that hasn't been accessed before in {1} requires restarting the application.":"访问{1}之前尚未访问的捕获变量'{0}'需要重新启动应用程序。\r\n","Unterminated [] set":"未终止[]集\r\n","\r\n The \"L\" literal suffix denoting \"Long\"\r\n ":"\r\n 表示“长”的“ L”字面后缀\r\n \r\n","\r\n Returns a copy of this with the SyncLockStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中SynclockStatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n This method finds an attribute by metadata name and signature. The algorithm for signature matching is similar to the one\r\n in Module.GetTargetAttributeSignatureIndex. Note, the signature matching is limited to primitive types\r\n and System.Type.  It will not match an arbitrary signature but it is sufficient to match the signatures of the current set of\r\n well known attributes.\r\n ":"\r\n 此方法通过元数据名称和签名查找属性。 签名匹配的算法类似于\r\n 模块中。GetTargetAttributeSignatureIndex. 注意，签名匹配仅限于基元类型\r\n 和系统。类型。  它不会匹配任意签名，但它足以匹配当前的签名集\r\n 众所周知的属性。\r\n \r\n","Warning: Adding parameters to local function declaration may produce invalid code.":"警告：将参数添加到本地功能声明可能会产生无效的代码。\r\n","awaitable, extension":"等待，扩展\r\n"," instance or null if the compiler generated no PDB (the symbols might be embedded in the assembly).":" 实例或null如果编译器生成没有PDB（符号可以嵌入在汇编中）。\r\n","\r\n Represents the declaration of one or more local variables or constants.\r\n ":"\r\n 表示一个或多个局部变量或常数的声明。\r\n \r\n","\r\n Rewrites a ObjectInitializerExpression to either a statement list (in case the there is no temporary used) or a bound\r\n sequence expression (in case there is a temporary used). The information whether to use a temporary or not is \r\n stored in the bound object member initializer node itself.\r\n \r\n E.g. the following code:\r\n     Dim x = New RefTypeName(param1) With {.FieldName1 = 23, .FieldName2 = .FieldName3, .FieldName4 = x.FieldName1}\r\n gets rewritten to \r\n     Dim temp as RefTypeName \r\n     temp = new RefTypeName(param1)\r\n     temp.FieldName1 = 23\r\n     temp.FieldName2 = temp.FieldName3\r\n     temp.FieldName4 = x.FieldName1\r\n     x = temp\r\n where the last assignment is not part of this rewriting, because the BoundObjectInitializerExpression\r\n only represents the object creation expression with the initialization.\r\n \r\n In a case where no temporary is used the following code:\r\n     Dim x As New ValueTypeName(param1) With {.FieldName1 = 23, .FieldName2 = .FieldName3, .FieldName4 = x.FieldName1}\r\n gets rewritten to \r\n     x = new ValueTypeName(param1)\r\n     x.FieldName1 = 23\r\n     x.FieldName2 = x.FieldName3\r\n     x.FieldName4 = x.FieldName1\r\n ":"\r\n 将ObjectInitializerExpression重写为语句列表（如果没有临时使用）或绑定\r\n 序列表达（万一有临时使用）。 是否使用临时的信息是 \r\n 存储在绑定对象成员初始化器节点本身中。\r\n \r\n 例如以下代码:\r\n     Dim x=新RefTypeName（param1）与{。FieldName1=23，。FieldName2=。FieldName3，。FieldName4=X.FieldName1}\r\n 被重写为 \r\n     Dim temp作为RefTypeName \r\n     temp=新RefTypeName（param1）\r\n     临时工。字段名称1=23\r\n     临时工。FieldName2=temp。字段名称3\r\n     临时工。字段名称4=X.字段名称1\r\n     x=温度\r\n 其中最后一个赋值不是此重写的一部分，因为BoundObjectInitializerExpression\r\n 仅用初始化表示对象创建表达式。\r\n \r\n 在没有使用temporary的情况下，以下代码:\r\n     Dim x作为带有{的新ValueTypeName（param1）。FieldName1=23，。FieldName2=。FieldName3，。FieldName4=X.FieldName1}\r\n 被重写为 \r\n     x=新ValueTypeName（param1）\r\n     X.字段名称1=23\r\n     X.FieldName2=x.FieldName3\r\n     X.FieldName4=X.FieldName1\r\n \r\n","Out: symbols that would have been in the return value but improperly refer to type parameters.":"外：本来可以在返回值中但不正确地指类型参数的符号。\r\n","\r\n This is set for methods with special semantics such as constructors or accessors\r\n as well as in special synthetic methods such as lambdas.\r\n Also set for methods marked with System.Runtime.CompilerServices.SpecialNameAttribute.\r\n ":"\r\n 这是针对具有特殊语义的方法（例如构造函数或访问者）的设置\r\n 以及在特殊的合成方法中，例如lambdas。\r\n 还设置为用System.Runtime.compilerServices.specialnemeattribute标记的方法。\r\n \r\n","\r\n Compare two source locations, using their containing trees, and then by Span.First within a tree. \r\n Can be used to get a total ordering on declarations, for example.\r\n ":"\r\n 比较两个源位置，使用其包含的树，然后在树中首先通过跨度进行比较。\r\n 例如，可以用来在声明上进行总订购。\r\n \r\n","\r\n            True if the completion list should be dismissed if the user's typing causes it to filter\r\n            and display no items.\r\n            ":"\r\n            如果用户的键入导致其过滤，则应驳回完成列表\r\n            并且没有显示项目。\r\n            \r\n","A static anonymous function cannot contain a reference to 'this' or 'base'.":"静态匿名函数不能包含对“ this”或“ base”的引用。\r\n","\r\n The keyword that was used to describe the built-in type.\r\n ":"\r\n 用于描述内置类型的关键字。\r\n \r\n","\r\n            type does not contain a definition of method or extension method\r\n            ":"\r\n            类型不包含方法或扩展方法的定义\r\n            \r\n","\r\n  Looks up a localized string similar to Leading '?' can only appear inside a 'With' statement, but not inside an object member initializer..\r\n":"\r\n  查找类似于领导“？”类似的本地化字符串只能出现在“ with”语句中，而不能在对象成员初始化器中出现。\r\n\r\n"," is converted to\r\n            ":" 被转换为\r\n            \r\n","The initialization expression.":"的初始化表达式。\r\n","\r\n This function builds a bound tree representing an overloaded short circuiting expression\r\n after determining that the necessary semantic conditions are met.\r\n \r\n An expression of the form:\r\n \r\n     x AndAlso y  (where the type of x is X and the type of y is Y)\r\n \r\n is an overloaded short circuit operation if X and Y are user-defined types and an\r\n applicable operator And exists after applying normal operator resolution rules.\r\n \r\n Given an applicable And operator declared in type T, the following must be true:\r\n \r\n     - The return type and parameter types must be T.\r\n     - T must contain a declaration of operator IsFalse.\r\n \r\n If these conditions are met, the expression \"x AndAlso y\" is translated into:\r\n \r\n     !T.IsFalse(temp = x) ? T.And(temp, y) : temp\r\n \r\n The temporary is necessary for evaluating x only once. Similarly, \"x OrElse y\" is\r\n translated into:\r\n \r\n     !T.IsTrue(temp = x) ? T.Or(temp, y) : temp\r\n ":"\r\n 此功能构建了一个绑定的树，代表超载的短路表达式\r\n 确定满足必要的语义条件之后。\r\n \r\n 形式的表达：\r\n \r\n     x andalso y（x的类型为x，y的类型为y）\r\n \r\n 如果X和Y是用户定义的类型，则是超载的短路操作\r\n 应用正常操作员分辨率规则后，适用的操作员并存在。\r\n \r\n 鉴于T型声明的适用和操作员，以下内容必须为真：\r\n \r\n      - 返回类型和参数类型必须为T。\r\n     -T必须包含运营商ISFALSE的声明。\r\n \r\n 如果满足这些条件，则将“ X And​​olso Y”的表达转换为：\r\n \r\n     ！t.isfalse（temp = x）？ t.和（temp，y）：临时\r\n \r\n 临时性对于仅评估X是必要的。同样，“ X Orelse Y”是\r\n 翻译成：\r\n \r\n     ！ t.or（temp，y）：临时\r\n \r\n","\r\n            Refactorings are returned in priority order determined based on ":"\r\n            根据基于优先顺序返回重构\r\n","\r\n  Accumulates different members kinds used while building the members.\r\n ":"\r\n  在建立成员时积累了不同的成员种类。\r\n \r\n"," with the container set to the immediate base type of\r\n the type in which ":" 将容器设置为\r\n 其中的类型 \r\n","\r\n Adjust the trivia on a node so that missing tokens are always before newline and colon trivia.\r\n Because new lines and colons are eagerly attached as trivia, missing tokens can end up incorrectly after the new line.\r\n This method moves the trailing non-whitespace trivia from the last token to the last zero with token.\r\n ":"\r\n 调整节点上的琐事，以便丢失的令牌始终在newline和Colon Trivia之前。\r\n 由于新线条和结肠急切地依附于琐事，因此缺失的令牌可能会在新线路之后出现错误。\r\n 该方法将尾随的非空格琐事从最后的令牌移至最后一个令牌。\r\n \r\n","\r\n Adjust substitution for construction.\r\n This has the following effects:\r\n     1) The passed in additionalSubstitution is used on each type argument.\r\n     2) If any parameters in the given additionalSubstitution are not present in oldConstructSubstitution, they are added.\r\n     3) Parent substitution in oldConstructSubstitution is replaced with adjustedParent. \r\n \r\n oldConstructSubstitution can be cancelled out by additionalSubstitution. In this case, \r\n if the adjustedParent is Nothing, Nothing is returned.\r\n ":"\r\n 调整替代施工。\r\n 这具有以下效果：\r\n     1）在每种类型的参数上都使用了通过的摘要。\r\n     2）如果给定的添加订阅中的任何参数在OldConstructSubstitution中不存在，则将添加它们。\r\n     3）在OldConstructsubstitution中的父母替代被调整后的替代。\r\n \r\n 可以通过添加成本取消OldConstructSubstitution。在这种情况下，\r\n 如果调整后的培训者一无所有，则什么都不会返回。\r\n \r\n","Partial method declarations '{0}' and '{1}' have signature differences.":"部分方法声明'{0}'和'{1}'具有签名差异。\r\n","The document text to trigger completion within ":"文档文本以触发完成\r\n","\r\n Returns expression that -\r\n a) evaluates the operand if needed\r\n b) produces it's ValueOrDefault.\r\n The helper is familiar with wrapping expressions and will go directly after the value \r\n skipping wrap/unwrap steps.\r\n ":"\r\n 返回表达式 -\r\n a)如果需要，计算操作数\r\n b）产生它的ValueOrDefault。\r\n 帮助器熟悉包装表达式，并将直接在值后面 \r\n 跳过包装/展开步骤。\r\n \r\n"," \r\n Returns true if 'Shadows' is explicitly specified on the declaration if the symbol is from\r\n source, or in cases of synthesized symbols, if 'Shadows' is specified on the associated\r\n source symbol. (For instance, ShadowsExplicitly will be set on the backing fields and\r\n accessors for properties and events based on the value from the property or event.)\r\n Returns false in all other cases, in particular, for symbols not from source.\r\n ":" \r\n 如果符号来自符号，则在声明上明确指定了“阴影”\r\n 来源，或在合成符号的情况下，如果在关联上指定了“阴影”\r\n 源符号。 （例如，Shadowsexplicly将设置在背景字段上，并且\r\n 基于属性或事件的值的属性和事件的访问者。）\r\n 在所有其他情况下，尤其是从源中返回false。\r\n \r\n","\r\n ReferenceManager encapsulates functionality to create an underlying SourceAssemblySymbol \r\n (with underlying ModuleSymbols) for Compilation and AssemblySymbols for referenced assemblies \r\n (with underlying ModuleSymbols) all properly linked together based on reference resolution \r\n between them.\r\n \r\n ReferenceManager is also responsible for reuse of metadata readers for imported modules and \r\n assemblies as well as existing AssemblySymbols for referenced assemblies. In order to do that, \r\n it maintains global cache for metadata readers and AssemblySymbols associated with them. \r\n The cache uses WeakReferences to refer to the metadata readers and AssemblySymbols to allow \r\n memory and resources being reclaimed once they are no longer used. The tricky part about reusing \r\n existing AssemblySymbols is to find a set of AssemblySymbols that are created for the referenced \r\n assemblies, which (the AssemblySymbols from the set) are linked in a way, consistent with the \r\n reference resolution between the referenced assemblies.\r\n \r\n When existing Compilation is used as a metadata reference, there are scenarios when its underlying \r\n SourceAssemblySymbol cannot be used to provide symbols in context of the new Compilation. Consider \r\n classic multi-targeting scenario: compilation C1 references v1 of Lib.dll and compilation C2 \r\n references C1 and v2 of Lib.dll. In this case, SourceAssemblySymbol for C1 is linked to AssemblySymbol \r\n for v1 of Lib.dll. However, given the set of references for C2, the same reference for C1 should be \r\n resolved against v2 of Lib.dll. In other words, in context of C2, all types from v1 of Lib.dll \r\n leaking through C1 (through method signatures, etc.) must be retargeted to the types from v2 of Lib.dll.\r\n In this case, ReferenceManager creates a special RetargetingAssemblySymbol for C1, which is responsible \r\n for the type retargeting. The RetargetingAssemblySymbols could also be reused for different \r\n Compilations, ReferenceManager maintains a cache of RetargetingAssemblySymbols (WeakReferences) for each \r\n Compilation.\r\n \r\n The only public entry point of this class is CreateSourceAssembly() method.\r\n ":"\r\n ReferenceMemanager封装功能以创建基础源筛选\r\n （带有基础模块符号）用于参考组件的编译和组件符号\r\n （带有基础模块符号）所有这些都根据参考分辨率正确连接在一起\r\n 它们之间。\r\n \r\n ReferenceManager还负责重复使用元数据读者进口模块和\r\n 用于引用组件的组件以及现有的汇编符号。为此，\r\n 它维护与与之相关的元数据读取器和汇编符号的全局缓存。\r\n 缓存使用虚弱的参考来参考元数据读取器和汇编符号，以允许\r\n 记忆和资源一旦不再使用，就会收回它们。关于重复使用的棘手部分\r\n 现有的汇编符号是找到一组为引用的汇编符号\r\n 汇编（集合中的汇编符号）以某种方式链接，与\r\n 参考组件之间的参考分辨率。\r\n \r\n 当将现有的汇编用作元数据参考时，存在某些情况。\r\n 源切除术不能用于在新汇编的背景下提供符号。考虑\r\n 经典多目标方案：汇编C1参考v1 lib.dll和汇编C2\r\n lib.dll的参考C1和V2。在这种情况下，C1的源切除术与汇编符号链接\r\n 对于lib.dll的v1。但是，鉴于C2的一组参考，C1的参考应为\r\n 针对lib.dll的V2解决。换句话说，在C2的背景下，lib.dll的V1的所有类型\r\n 必须通过C1（通过方法签名等）泄漏到Lib.dll的V2类型。\r\n 在这种情况下，ReferenceManager为C1创建一个特殊的retargetingAssemblysymbol\r\n 用于重新定位的类型。 retargetingsemblysymbols也可以重复使用\r\n 汇编，ReferenceManager维持每个retargetingAssemblysymbols（弱转录）的缓存\r\n 汇编。\r\n \r\n 该类的唯一公共入口点是CreateSourCeassembly（）方法。\r\n \r\n","\r\n            Adding a static or instance method to an existing type.\r\n            ":"\r\n            将静态或实例方法添加到现有类型中。\r\n            \r\n","Unknown property":"未知属性\r\n"," to Read/Write diagnostic data into the stream.\r\n            If any two distinct analyzer have the same diagnostic state name, we will end up sharing the persistence stream between them, leading to duplicate/missing/incorrect diagnostic data.\r\n            ":" 将诊断数据读取到流中。\r\n            如果任何两个不同的分析仪具有相同的诊断状态名称，我们最终将在它们之间共享持久性流，从而导致重复/缺失/错误的诊断数据。\r\n            \r\n","\r\n            String describing the assembly to be used in user facing error messages (e.g. file path).\r\n            ":"\r\n            字符串描述要在用户面向错误消息（例如文件路径）中使用的汇编的字符串。\r\n            \r\n","The bound for each node.":"每个节点的绑定。\r\n"," Original bound expression from With statement ":" 用语句的原始绑定表达\r\n","Simplify member access '{0}'":"简化成员访问'{0}'\r\n","The assembly '{0}' containing type '{1}' references .NET Framework, which is not supported.":"包含类型'{1}'引用.NET框架的汇编'{0}'，不支持。\r\n","The \"M\" custom format specifier represents the month as a number from 1 through 12 (or from 1 through 13 for calendars that have 13 months). A single-digit month is formatted without a leading zero.\r\n            \r\n            If the \"M\" format specifier is used without other custom ...":"“ M”自定义格式指定符表示该月为1到12（或13个月的日历为1到13个）。单位月份的格式不带领先的零。\r\n            \r\n            如果使用“ M”格式指定符，则没有其他自定义...\r\n","\r\n Scan a string that is missing quotes (error recovery)\r\n ":"\r\n 扫描一个缺少报价的字符串（错误恢复）\r\n \r\n","\r\n Returns the type of construct being bound (BaseTypes, MethodSignature,\r\n etc.) to allow the Binder to provide different behavior in certain cases.\r\n Currently, this property is only used by ShouldCheckConstraints.\r\n ":"\r\n 返回构造的类型是绑定的（astetypes，methodsignature，\r\n 等等）允许粘合剂在某些情况下提供不同的行为。\r\n 当前，此属性仅由KredeCheckConstraints使用。\r\n \r\n","\r\n            Given a node representing a declaration or a top-level match node returns:\r\n            - ":"\r\n            给定一个表示声明或顶级匹配节点返回的节点：\r\n             - \r\n"," as a new else-if clause directly below\r\n            ":" 作为新的其他 - 如果直接在下面\r\n            \r\n","if predefined type is not preferred, it implies the preference is framework type.":"如果不是首选预定义的类型，则意味着偏好是框架类型。\r\n","\r\n Returns a copy of this with the EqualsToken property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而平等属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Returns a copy of this with the FunctionName property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中功能名属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Returns user defined DispId for a member or ReservedDispId.None if none specified.\r\n Also reports errors for reserved DispIds.\r\n ":"\r\n 返回用户定义的会员或保留dispid..NONE如果未指定。\r\n 还报告保留分散的错误。\r\n \r\n","indexer":"索引器\r\n","\r\n  Looks up a localized string similar to Classes cannot be declared '{0}'..\r\n":"\r\n  查找类似类似类的本地化字符串，无法声明“ {0}”。\r\n\r\n","\r\n Parse a parameter list.\r\n ":"\r\n 解析参数列表。\r\n \r\n","Cannot set a read-only variable":"无法设置仅读取变量\r\n"," since it is only needed when changes are detected in the solution.\r\n            ":" 由于仅在解决方案中检测到更改时才需要。\r\n            \r\n","\r\n folds two concat operands into one expression if possible\r\n otherwise returns null\r\n ":"\r\n 如果可能\r\n 否则返回null\r\n \r\n","\r\n Return true if and only if an expression represents optionally \r\n parenthesized Nothing literal as defined by the language grammar. \r\n I.e. implicit conversions are Ok, but explicit conversions aren't.\r\n ":"\r\n 当且仅当表达式代表选项时返回true\r\n 语言语法所定义的括号没有任何字面意义。\r\n IE。隐式转换是可以的，但是明确的转换不是。\r\n \r\n","Expected an assembly reference.":"预期组装参考。\r\n","\r\n If is not Nothing and False filters out all Event symbols, and if is not Nothing \r\n and True filters out all non-Event symbols, nos not have any effect otherwise.\r\n Is used for special handling of Events inside COM interfaces.\r\n ":"\r\n 如果不是一无所有，并且错误过滤所有事件符号\r\n 真正的过滤所有非事实符号，否则没有任何效果。\r\n 用于特殊处理COM界面中的事件。\r\n \r\n",").\r\n \r\n Non-reduced extension methods are considered regardless of the value of ":").\r\n \r\n 不考虑减少的扩展方法，而不考虑 \r\n","\r\n  Special slot for untracked variables\r\n ":"\r\n  未跟踪变量的特殊插槽\r\n \r\n","\r\n            Standard symbol names if the user doesn't have any existing naming rules.\r\n            ":"\r\n            标准符号名称如果用户没有任何现有的命名规则。\r\n            \r\n","\r\n  Looks up a localized string similar to Constraint '{0}' conflicts with the indirect constraint '{1}' obtained from the type parameter constraint '{2}'..\r\n":"\r\n  查找类似于约束'{0}'的本地化字符串与从类型参数约束'{2}'..获得的间接约束'{1}'相冲突。\r\n\r\n","\r\n Returns declared accessibility of most accessible type within this namespace or within a containing namespace recursively.\r\n Valid return values:\r\n     Friend,\r\n     Public,\r\n     NotApplicable - if there are no types.\r\n ":"\r\n 返回在此名称空间或递归中包含的名称空间中声明最可访问类型的可访问性。\r\n 有效返回值：\r\n     朋友，\r\n     上市，\r\n     非适当的 - 如果没有类型。\r\n \r\n","\r\n Guarded by ":"\r\n 守护\r\n"," and throw if it returns false.\r\n ":" 如果它返回false，则投掷。\r\n \r\n","Assembly identity.":"组装身份。\r\n"," \r\n Manages anonymous types and delegates created on module level. All requests \r\n for anonymous type/delegate symbols go via the instance of this class.\r\n \r\n Manager also is in charge of creating implementation types which are used in \r\n emit phase to substitute anonymous type/delegate public symbols.\r\n ":" \r\n 管理在模块级别创建的匿名类型和委托。所有请求\r\n 对于匿名类型/委托符号，通过此类的实例进行。\r\n \r\n 经理还负责创建用于使用的实施类型\r\n 发射阶段代替匿名类型/委托公共符号。\r\n \r\n","The string containing the text to be parsed.":"包含要解析的文本的字符串。\r\n","using X = System.DateTime":"使用X = System.DateTime\r\n","\r\n The statement that begins the case block.\r\n ":"\r\n 开始案例块的声明。\r\n \r\n","\r\n            Returns if the token is a valid closing token kind for this brace completion service.\r\n            ":"\r\n            如果令牌是该支架完成服务的有效关闭令牌，则返回。\r\n            \r\n","\r\n  Looks up a localized string similar to 'End Operator' must be preceded by a matching 'Operator'..\r\n":"\r\n  查找类似于“ End Operator”的本地化字符串必须先于匹配的“操作员”。\r\n\r\n","letter, other":"信，其他\r\n"," or null if no item is available.":" 或null如果没有任何物品。\r\n","\r\n  Looks up a localized string similar to Extension methods can be defined only in modules..\r\n":"\r\n  查找类似于扩展方法的本地化字符串只能在模块中定义。\r\n\r\n"," to speed-up type reference resolution\r\n for metadata coming from this module. The map is lazily populated\r\n by ":" 加速类型参考分辨率\r\n 对于来自该模块的元数据。该地图懒洋洋\r\n 经过\r\n"," that computes a reasonable\r\n            hash based on the provided ":" 计算合理的\r\n            基于提供的哈希\r\n","\r\n Whether the method is used as an operator.\r\n ":"\r\n 该方法是否用作操作员。\r\n \r\n","\r\n The source (right hand side) of the assignment.\r\n ":"\r\n 分配的源（右侧）。\r\n \r\n","\r\n The syntax trees of this compilation plus all 'hidden' trees \r\n added to the compilation by compiler, e.g. Vb Core Runtime.\r\n ":"\r\n 该汇编的语法树以及所有“隐藏”树\r\n 由编译器添加到编译中，例如VB核心运行时。\r\n \r\n","\r\n            Get any text changes that should be applied after the enter key is typed inside a brace completion context.\r\n            ":"\r\n            获取在Enter键在支架完成上下文中键入Enter键后应应用的任何文本更改。\r\n            \r\n","\r\n Scan tokens inside of < ... >\r\n ":"\r\n <...>的扫描令牌\r\n \r\n","\r\n            Signifies that the left operand is the constant.\r\n            ":"\r\n            表示左操作数是常数。\r\n            \r\n","Error reading debug information from ":"错误阅读调试信息来自\r\n","\r\n            The number of items in this entry for types declared as public.\r\n            This is used to minimize memory allocation in case non-public items aren't needed.\r\n            ":"\r\n            此条目中的项目数量被称为公共。\r\n            如果不需要非公共项目，则用于最大程度地减少内存分配。\r\n            \r\n",".  i.e.\r\n             member-access expressions, conditional-access expressions, etc.  Effectively, anything\r\n             the language allows at this point as long as it doesn't start another 'chunk' itself.\r\n             \r\n             This approach gives an intuitive wrapping algorithm that matches the common way\r\n             many wrap dotted invocations, while also effectively not limiting the wrapper to\r\n             only simple forms like ":"。 IE。\r\n             会员访问表达式，有条件的访问表达式等有效地\r\n             该语言在这一点上只要不启动另一个“块”本身。\r\n             \r\n             这种方法给出了一种直观的包装算法，该算法与通用方式匹配\r\n             许多包装点缀的调用，同时也没有将包装器限制为\r\n             只有简单的形式\r\n","\r\n  Looks up a localized string similar to Value of type '{0}' cannot be converted to '{1}' because '{2}' is not a reference type..\r\n":"\r\n  查找类似于类型'{0}'的值的本地化字符串，不能转换为'{1}'，因为'{2}'不是参考类型。\r\n\r\n",", which can be read or written by test code.\r\n            ":"，可以通过测试代码读取或编写。\r\n            \r\n","\r\n If this symbol represents a partial method definition or implementation part, its other part (if any).\r\n This should be set, if at all, before this symbol appears among the members of its owner.  \r\n The implementation part is not listed among the \"members\" of the enclosing type.\r\n ":"\r\n 如果此符号代表部分方法定义或实现部分，则其另一部分（如果有）。\r\n 如果有的话，应该设置此符号在其所有者的成员中出现之前。\r\n 实现部分未在封闭类型的“成员”中列出。\r\n \r\n","\r\n The value for the QuestionGreaterThanToken property.\r\n ":"\r\n QuestionGreathantken物业的价值。\r\n \r\n","The \\B anchor specifies that the match must not occur on a word boundary. It is the opposite of the \\b anchor.":"\\ b锚指定匹配不得在单词边界上发生。它与\\ b锚相反。\r\n","\r\n  Looks up a localized string similar to 'Exit While' can only appear inside a 'While' statement..\r\n":"\r\n  查找类似于“退出”的本地化字符串，只能出现在“ while”语句中。\r\n\r\n","\r\n The value for the ControlVariable property.\r\n ":"\r\n 控制变量属性的值。\r\n \r\n","\r\n            Gets the semantic model for the given node.\r\n            If the node belongs to the syntax tree of the original semantic model, then returns originalSemanticModel.\r\n            Otherwise, returns a speculative model.\r\n            The assumption for the later case is that span start position of the given node in it's syntax tree is same as\r\n            the span start of the original node in the original syntax tree.\r\n            ":"\r\n            获取给定节点的语义模型。\r\n            如果该节点属于原始语义模型的语法树，则返回原始版式model。\r\n            否则，返回推测模型。\r\n            后来情况的假设是，在其语法树中给定节点的跨度启动位置与\r\n            原始语法树中原始节点的跨度启动。\r\n            \r\n","\r\n Binds the delegate creation expression.\r\n This comes in form of e.g.\r\n Dim del as new DelegateType(AddressOf methodName)\r\n ":"\r\n 绑定代表创建表达式。\r\n 这以例如\r\n DIM DEL为新授权类型（地址：Name）\r\n \r\n","A sequence of nodes and tokens.":"一系列节点和令牌。\r\n","property setter":"属性设置器\r\n"," representing the specific kind of\r\n DeclareStatementSyntax. One of DeclareSubStatement, DeclareFunctionStatement.\r\n ":" 代表特定种类\r\n declarestatementsyntax。声明提交之一，声明函数statement。\r\n \r\n","\r\n Returns whether this method is generic; i.e., does it have any type parameters?\r\n ":"\r\n 返回该方法是否是通用的；即，它有任何类型的参数吗？\r\n \r\n","\r\n Checks if 'symbol' is accessible from within type 'within', with\r\n an qualifier of type \"throughTypeOpt\". Sets \"failedThroughTypeCheck\" to true\r\n if it failed the \"through type\" check.\r\n ":"\r\n 检查是否可以从类型“内部”中访问“符号”，\r\n 类型为“ Printypeopt”的预选赛。设置“失败的typecheck”\r\n 如果失败了“通过类型”检查。\r\n \r\n","\r\n Represents a type parameter on a source method (as opposed to a type).\r\n ":"\r\n 表示源方法上的类型参数（与类型相反）。\r\n \r\n","do ... while (...);":"做...而（...）;\r\n","\r\n The map that captures information about what assembly should be retargeted \r\n to what assembly. Key is the ":"\r\n 捕获有关应该重新定位哪个组件的信息的地图\r\n 到什么组装。关键是\r\n","\r\n True if overload resolution successfully selected a single best method.\r\n ":"\r\n 如果超负荷分辨率成功选择了单个最佳方法，则为正确。\r\n \r\n","\r\n Identifies the special instance \"Me\"\r\n ":"\r\n 标识特殊实例“我”\r\n \r\n"," describing the item.\r\n            ":" 描述项目。\r\n            \r\n","\r\n The field of the generated async class used in generic task returning async methods to store the value\r\n of rewritten return expressions. The return-handling code then uses SetResult on the async method builder\r\n to make the result available to the caller.\r\n ":"\r\n 在通用任务中使用的生成异步类的字段返回异步方法来存储值\r\n 重写的返回表达式。然后，返回处理代码在异步方法构建器上使用setResult\r\n 为了使结果提供给呼叫者。\r\n \r\n","\r\n            check whether the selection is at the placed where read-only field is allowed to be extracted out\r\n            ":"\r\n            检查选择是否位于允许允许提取仅阅读字段的位置\r\n            \r\n","\r\n  Looks up a localized string similar to Enums must be declared as an integral type..\r\n":"\r\n  查找类似于枚举的本地化字符串必须被声明为积分类型。\r\n\r\n","\r\n Whether the method is used in a lifted to nullable form.\r\n ":"\r\n 该方法是否以提升为无效的形式使用。\r\n \r\n","\r\n  Looks up a localized string similar to Attribute constructor has a parameter of type '{0}', which is not an integral, floating-point or Enum type or one of Object, Char, String, Boolean, System.Type or 1-dimensional array of these types..\r\n":"\r\n  查找类似于属性构造函数的本地化字符串具有“ {0}”的参数，该参数不是一个积分，浮点或枚举类型或对象，char，char，string，boolean，system.type或1维这些类型的数组..\r\n\r\n","\r\n Add this instance to the set of checked types. Returns True\r\n if this type was added, False if the type was already in the set.\r\n ":"\r\n 将此实例添加到一组检查类型中。返回真实\r\n 如果添加了此类型，则false如果该类型已经在集合中。\r\n \r\n","\r\n Represents the Catch part of a Try...Catch...Finally...End Try. This\r\n statement is always the Begin of a CatchPart.\r\n ":"\r\n 代表尝试的捕获部分...捕获...最后...结束尝试。这个\r\n 语句始终是捕捉机构的开始。\r\n \r\n","\r\n            a map of location tag to index in additional locations.\r\n            \"AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer\" for an example of usage.\r\n            ":"\r\n            位置标签的地图，要在其他位置索引。\r\n            “ Abstractremoveunnnnnnecressarenthessdiagnosticanalyzer”用于使用示例。\r\n            \r\n","\r\n The names of the variables being declared. Each name might have a \"?\" or \"()\"\r\n modifier(s) attached.\r\n ":"\r\n 声明的变量的名称。每个名称可能都有“？”或者 ”（）”\r\n 附加的修饰符。\r\n \r\n","\r\n If this method is a Lambda method (MethodKind = MethodKind.LambdaMethod) and \r\n there is an anonymous delegate associated with it, returns this delegate.\r\n \r\n Returns Nothing if the symbol is not a lambda or if it does not have an\r\n anonymous delegate associated with it.\r\n ":"\r\n 如果此方法是lambda方法（MethodKind = MethodKind.lambdamethod）和\r\n 有一个与之关联的匿名代表，返回此代表。\r\n \r\n 如果该符号不是lambda或没有\r\n 与之关联的匿名代表。\r\n \r\n","\r\n  Looks up a localized string similar to Conversion operators cannot convert from a type to its base type..\r\n":"\r\n  查找类似于转换操作员的本地化字符串无法从类型转换为其基本类型。\r\n\r\n","\r\n            Returns base mapped active statement spans contained in each specified document projected to a given solution snapshot\r\n            (i.e. the solution snapshot the base active statements are current for could be different from the given ":"\r\n            返回基础映射的活动语句跨度包含的每个指定文档投影到给定解决方案快照\r\n            （即，解决方案快照基础活动语句最新的可能与给定的\r\n","Captures a matched subexpression and lets you access it by name or by number.\r\n            \r\n            'name' is a valid group name, and 'subexpression' is any valid regular expression pattern. 'name' must not contain any punctuation characters and cannot begin with a number.\r\n            \r\n            If ...":"捕获匹配的子表达，并让您按名称或数字访问它。\r\n            \r\n            “名称”是一个有效的组名称，“子表达”是任何有效的正则表达模式。 “名称”不得包含任何标点字符，也不能以一个数字开始。\r\n            \r\n            如果 ...\r\n","\r\n            save trivia around span and let user restore trivia later\r\n            ":"\r\n            在跨度周围保存琐事，让用户稍后再还原琐事\r\n            \r\n","Adding a constructor to a type with a field or property initializer that contains an anonymous function requires restarting the application.":"将构造函数添加到具有包含匿名函数的字段或属性初始化器的类型中，需要重新启动应用程序。\r\n","\r\n Return TypeSubstitution instance that targets particular\r\n generic definition or one of its containers.\r\n ":"\r\n 针对特定的返回类型实例\r\n 通用定义或其容器之一。\r\n \r\n","\r\n The text of the attribute or pcdata after normalization.\r\n ":"\r\n 归一化后属性或pcdata的文本。\r\n \r\n"," we can find that ":" 我们可以找到\r\n","\r\n Accumulates classification information about conversion to interface.\r\n Returns True when classification gets promoted to Identity, this method should not \r\n be called after that.\r\n ":"\r\n 累积有关转换为接口的分类信息。\r\n 当分类升级为身份时，返回true，此方法不应\r\n 在那之后被打电话。\r\n \r\n"," is a request that the completion host operate in suggestion mode.\r\n            The item specified determines the text displayed and the description associated with it unless a different item is manually selected.\r\n            No text is ever inserted when this item is completed, leaving the text the user typed instead.\r\n            ":" 是要求完成主机在建议模式下运行的请求。\r\n            指定的项目确定显示的文本以及与之关联的描述，除非手动选择其他项目。\r\n            完成此项目后，永远不会插入文本，而是将用户输入的文本。\r\n            \r\n","\r\n            Given a SyntaxNode for which we want to reorder parameters/arguments, find the \r\n            SyntaxNode of a kind where we know how to reorder parameters/arguments.\r\n            ":"给定我们要重新排序参数/参数的语法句号，找到\r\n            我们知道如何重新排序参数/参数的一种语法句。\r\n            \r\n","The \"fffff\" custom format specifier represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value.\r\n            \r\n            Although it's possible to display the hundred thousandths of a se ...":"“ FFFFF”自定义格式指定符表示秒数的五个最重要的数字；也就是说，它代表日期和时间值中的十万秒。\r\n            \r\n            虽然可以显示十万个SE ...\r\n","\r\n The string literal with the library name.\r\n ":"\r\n 带有库名称的字符串文字。\r\n \r\n","Pull '{0}' up to '{1}'":"拉'{0}'for' {1}'\r\n","\r\n            Maps ":"\r\n            地图\r\n","\r\n Returns a copy of this with the ExitKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而Exitkeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            operation has succeeded\r\n            ":"\r\n            操作成功了\r\n            \r\n","\r\n The value for the AccessorStatement property.\r\n ":"\r\n 登录属性的值。\r\n \r\n","\r\n The expression on the left-hand-side of the \".\" or \"!\" token.\r\n ":"\r\n “”左侧的表达式。或者 ”！”令牌。\r\n \r\n","\r\n            Gets the identifier token for the iteration variable of the given foreach statement node.\r\n            ":"\r\n            获取给定foreach语句节点的迭代变量的标识符令牌。\r\n            \r\n","using directive":"使用指令\r\n","True if the completion list should be dismissed if the user's typing causes it to filter and display no items.":"如果用户的键入导致其过滤并显示不显示项目，则应驳回完成列表。\r\n"," is locked, and is not valid after\r\n             ":" 已锁定，在\r\n             \r\n","ObjectMemberInitializer":"ObjectMemberInitializer\r\n","\r\n The Step clause in a For Statement.\r\n ":"\r\n for语句中的步骤子句。\r\n \r\n","Inline temporary variable":"内联临时变量\r\n"," and offers to change that to ":" 并提出将其更改为\r\n","\r\n            Type 'X' does not contain a valid extension method accepting 'Y'\r\n            ":"\r\n            键入“ x”不包含有效的扩展方法接受“ y”\r\n            \r\n","\r\n            This will be raised whenever ":"\r\n            这将在任何时候提出\r\n","\r\n Returns true if this is a write-only property; i.e., has no get accessor.\r\n ":"\r\n 如果这是仅写的属性，则返回true；即，没有登录器。\r\n \r\n","\r\n Determines what type of conversion, if any, would be used if a given expression was\r\n converted to a given type.\r\n ":"\r\n 确定如果给定的表达式为\r\n 转换为给定类型。\r\n \r\n","Compute the field initializer to add to the list of initializers.":"计算字段初始化器以添加到初始化器列表中。\r\n","\r\n In C# this class also stores hidden members (and is named OverriddenOrHiddenMembersResult). \r\n The way VB warns on hidden members, this did not turn out to be useful.\r\n ":"\r\n 在C＃中，此课程还存储隐藏的成员（并被命名为OverridendorhiddenMembersresult）。\r\n VB警告隐藏成员的方式并没有有用。\r\n \r\n","\r\n Provides members for determining Syntax facts about characters and Unicode conversions.\r\n ":"\r\n 提供成员来确定有关字符和Unicode转换的语法事实。\r\n \r\n","\r\n            The full display parts for this definition.  Displayed in a classified \r\n            manner when possible.\r\n            ":"此定义的完整显示部分。在分类中显示\r\n            尽可能的方式。\r\n            \r\n"," value.\r\n            This can be useful for host that do not support diffing changes to find minimal edits.  Even if this is \r\n            provided, ":" 价值。\r\n            这对于不支持扩散更改以查找最小编辑的主机很有用。即使这是\r\n            假如，\r\n","\r\n Returns true if ":"\r\n 如果返回为true\r\n","Implement implicitly":"隐式实施\r\n","\r\n Not guaranteed to return the span of a StatementSyntax.\r\n ":"\r\n 不能保证返回语句的跨度。\r\n \r\n","\r\n Returns a copy of this with the StepValue property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，StepValue属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            This is a copy of ":"\r\n            这是\r\n","\r\n            A service that let people to register new IDiagnosticUpdateSource\r\n            ":"\r\n            一项使人们注册新的IdiNgnosticupDatesource的服务\r\n            \r\n","\r\n Represents a \"With {...} clause used to initialize a new object's members.\r\n ":"代表一个“使用{...}子句来初始化新对象的成员。\r\n \r\n","\r\n We each element of option, imports and attributes on a separate line, where the last element of this the list if \r\n followed by an empty line:\r\n Option Strict On\r\n \r\n Imports System\r\n Imports Foo\r\n \r\n [...]\r\n \r\n Namespace\r\n [...]\r\n ":"\r\n 我们在单独行上的选项，导入和属性的每个元素，其中列表的最后一个元素如果\r\n 其次是空的线：\r\n 选项严格\r\n \r\n 进口系统\r\n 进口foo\r\n \r\n [...]\r\n \r\n 名称空间\r\n [...]\r\n \r\n","\r\n            Supports code like ":"\r\n            支持类似的代码\r\n"," class. The parameters are not initialized and need to be set \r\n by using the ":" 班级。参数未初始化，需要设置\r\n 通过使用\r\n","Change namespace to '{0}'":"将名称空间更改为'{0}'\r\n","\r\n Returns true if there is any applied CompilationRelaxationsAttribute assembly attribute for this module.\r\n ":"\r\n 如果有任何适用的compilationRelaxationsattribute汇编属性，则返回true。\r\n \r\n","\r\n  Looks up a localized string similar to Conversion operators cannot convert from an interface type..\r\n":"\r\n  查找类似于转换操作员的本地化字符串无法从接口类型转换。\r\n\r\n","\r\n  Looks up a localized string similar to Local variables within methods of structures cannot be declared 'Static'..\r\n":"\r\n  查找与结构方法中类似于本地变量的本地化字符串，不能声明为“静态”。\r\n\r\n","\r\n            Base type of a type that is used as ":"\r\n            用作类型的基本类型\r\n","\r\n  Looks up a localized string similar to Type '{0}' must define operator '{1}' to be used in a '{2}' expression..\r\n":"\r\n  查找类似于“ {0}”类型的本地化字符串必须定义operator'{1}'才能在'{2}'expression中使用。\r\n\r\n","The argument list.":"参数列表。\r\n","\r\n  Looks up a localized string similar to Invalid file section alignment '{0}'.\r\n":"\r\n  查找类似于无效的文件部分对齐'{0}'的本地化字符串。\r\n\r\n","\r\n The dispatcher method that handles syntax nodes for all stand-alone statements.\r\n ":"\r\n 为所有独立语句处理语法节点的调度程序方法。\r\n \r\n","\r\n The list of event members being handled.\r\n ":"\r\n 要处理的活动成员列表。\r\n \r\n","\r\n Is method a user-defined operator.\r\n ":"\r\n 是方法是用户定义的操作员。\r\n \r\n"," \r\n Assuming the statement is a constructor call wrapped in bound expression \r\n statement, get the method symbol being called \r\n ":" \r\n 假设该陈述是包裹在绑定表达式中的构造函数调用\r\n 语句，获取被调用的方法符号\r\n \r\n","Unique simple names of GAC assemblies.":"GAC组件的独特简单名称。\r\n","\r\n Get the instance and shared constructors for this type.\r\n ":"\r\n 获取此类型的实例和共享构造函数。\r\n \r\n","using declaration":"使用声明\r\n","\r\n Returns a copy of this with the [Imports] property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，[imports]属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Represents an explicit line continuation character at the end of a line, i.e.,\r\n _\r\n ":"\r\n 代表线路末端的显式线延续字符，即\r\n _\r\n \r\n","Generally used for temporary locals past the initial binding phase.":"通常用于临时当地人经过初始结合阶段。\r\n","\r\n            Provider instance, which takes ownership of the ":"\r\n            提供者实例，该实例获得\r\n"," is \"A.B\" and ":" 是“ A.B”和\r\n","\r\n A list of statements to be executed.\r\n ":"\r\n 要执行的语句列表。\r\n \r\n","\r\n  Looks up a localized string similar to Late binding operations cannot be converted to an expression tree..\r\n":"\r\n  查找类似于后期绑定操作的局部字符串不能转换为表达树。\r\n\r\n","\r\n The value for the LetKeyword property.\r\n ":"\r\n letkeyword属性的值。\r\n \r\n"," \r\n Returns bound block representing method's body. This method is called \r\n by 'method compiler' when it is ready to emit IL code for the method.\r\n \r\n The bound method body is typically a high-level tree - it may contain \r\n lambdas, foreach etc... which will be processed in CompileMethod(...)\r\n ":" \r\n 返回绑定块代表方法的身体。此方法称为\r\n 通过“方法编译器”准备为该方法发射IL代码时。\r\n \r\n 绑定的方法主体通常是一棵高级树 - 它可能包含\r\n lambdas，foreach等...将在CompileMethod（...）中进行处理\r\n \r\n","\r\n Returns true if the type is the implicit class that holds onto invalid global members (like methods or\r\n statements in a non script file).\r\n ":"\r\n 如果类型是将无效的全局成员包含的隐式类（例如方法或\r\n 非脚本文件中的语句）。\r\n \r\n","\r\n Lookup a type defined in a module of a multi-module assembly.\r\n ":"\r\n 查找在多模块组件的模块中定义的类型。\r\n \r\n","\r\n Returns true if this method might be a reducible extension method. This method may return true\r\n even if the method is not an extension method, but if it returns false, it must be the\r\n case that this is not an extension method.\r\n \r\n Allows checking extension methods from source in a quicker manner than fully binding attributes.\r\n ":"\r\n 如果此方法可能是可还原的扩展方法，则返回true。此方法可能返回true\r\n 即使该方法不是扩展方法，但如果它返回false，也必须是\r\n 这不是扩展方法。\r\n \r\n 允许以更快的方式从源检查扩展方法，而不是完全绑定的属性。\r\n \r\n","Operators":"操作员\r\n"," are missing.\r\n The attribute is synthesized only if present.\r\n ":" 缺失。\r\n 仅在存在时才合成该属性。\r\n \r\n"," Bound field access passed may require tracking if it is an access to a non-shared structure field ":" 如果是对非共享结构字段的访问，则传递的绑定字段访问可能需要跟踪\r\n","A copy constructor in a record must call a copy constructor of the base, or a parameterless object constructor if the record inherits from object.":"记录中的复制构造函数必须调用基数的复制构造函数，如果记录从对象继承，则必须调用无参数对象构造函数。\r\n","\r\n Returns the arity of this method, or the number of type parameters it takes.\r\n A non-generic method has zero arity.\r\n ":"\r\n 返回此方法的敏锐度或所采用的类型参数数量。\r\n 一种非生成方法的Arity为零。\r\n \r\n","\r\n The value for the JoinConditions property.\r\n ":"\r\n joinconditions属性的价值。\r\n \r\n","\r\n The value for the SubOrFunctionKeyword property.\r\n ":"\r\n subfunctionKeyword属性的值。\r\n \r\n"," representing the specific kind of\r\n MultiLineLambdaExpressionSyntax. One of MultiLineFunctionLambdaExpression,\r\n MultiLineSubLambdaExpression.\r\n ":" 代表特定种类\r\n Multilinelambdaexpressynntax。多功能lambdaexexpression之一\r\n MultilineSublambdaExpression。\r\n \r\n","\r\n            Whether the runtime supports updating the Param table, and hence related edits (eg parameter renames)\r\n            ":"\r\n            运行时是否支持更新参数表，因此相关编辑（例如参数命名）\r\n            \r\n","\r\n Represents a \"Do While\" statement that begins a \"Do ... Loop\" block.\r\n ":"\r\n 代表开始一个“ do do ... do loop”块的“ do while”语句。\r\n \r\n","\r\n Returns True if this node represents a directive.\r\n ":"\r\n 如果此节点代表指令，则返回true。\r\n \r\n","\r\n The \"position\" Is used to determine what variables are visible And accessible. Even if \"container\" Is\r\n specified, the \"position\" location Is significant for determining which members of \"containing\" are\r\n accessible. \r\n \r\n Labels are Not considered (see ":"\r\n \"位置\"用于确定哪些变量是可见的和可访问的。 即使\"容器\"是\r\n 指定，\"位置\"位置对于确定\"包含\"的哪些成员是显着的\r\n 可访问。 \r\n \r\n 不考虑标签（见 \r\n","\r\n  Looks up a localized string similar to 'GoTo {0}' is not valid because '{0}' is inside a 'For' or 'For Each' statement that does not contain this statement..\r\n":"\r\n  查找类似于'goto {0}'的本地化字符串是无效的，因为'{0}'for a for'for'for'for'for for for for for for for for for for for for for for for每个语句中不包含此语句。\r\n\r\n","\r\n Get all declaration errors in the given filterSpan.\r\n ":"\r\n 在给定的Filterspan中获取所有声明错误。\r\n \r\n","punctuation, open":"标点符号，开放\r\n","\r\n Resolves overloaded methods or constructors or properties for SemanticModel.\r\n ":"\r\n 解决semanticmodel的超载方法或构造函数或属性。\r\n \r\n","The conversion of the enumerator to call Dispose on.":"枚举者的转换要拨打。\r\n","\r\n Returns a copy of this with the ValueKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中valuekeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Scan text inside of <![CDATA[ ... ]]>\r\n ":"\r\n <！[cdata [...]]>的扫描文本>\r\n \r\n","\r\n A ImportAliasesBinder provides lookup for looking up import aliases (A = Foo.Bar),\r\n either at file level or project level.\r\n ":"\r\n 一个重要的aliasesbinder提供查找以查找导入别名（a = foo.bar）的查找，\r\n 在文件级别或项目级别上。\r\n \r\n","\r\n            Parses out code of the form: ...|...|...\r\n            This is the type of code you have at the top level of a regex, or inside any grouping\r\n            contruct.  Note that sequences can be empty in .NET regex.  i.e. the following is legal:\r\n            \r\n                ...||...\r\n            \r\n            An empty sequence just means \"match at every position in the test string\".\r\n            ":"\r\n            解析表格的代码：... | ... | ...\r\n            这是您在正则级别或任何分组内部的代码类型\r\n            出现。请注意，序列可以在.NET Regex中为空。即以下是合法的：\r\n            \r\n                ... || ...\r\n            \r\n            一个空序列仅表示“在测试字符串中的每个位置匹配”。\r\n            \r\n","\r\n The declarations contained in the enumeration.\r\n ":"\r\n 枚举中包含的声明。\r\n \r\n","\r\n  Looks up a localized string similar to 'On Error' and 'Resume' cannot appear inside a lambda expression..\r\n":"\r\n  查找类似于“错误”和“简历”类似的本地化字符串。\r\n\r\n","\r\n Some nodes have special binder's for their contents \r\n ":"\r\n 有些节点有特殊的粘合剂的内容\r\n \r\n","Unknown symbol kind":"未知符号类型\r\n","\r\n  Looks up a localized string similar to 'Global' must be followed by '.' and an identifier..\r\n":"\r\n  查找类似于“全局”的局部字符串，必须是“”。和标识符..\r\n\r\n"," indicating the declared accessibility for the symbol.\r\n Returns NotApplicable if no accessibility is declared.\r\n ":" 指示该符号的声明可访问性。\r\n 如果未声明可访问性，则返回无关紧要。\r\n \r\n","\r\n Perform extension method viability check within AppendExtensionMethodNames method above.\r\n This method is overridden by RetargetingNamedtypeSymbol and RetargetingNamespaceSymbol in order to \r\n perform the check on corresponding RetargetingMethodSymbol.\r\n \r\n Returns true if the method is viable. \r\n ":"\r\n 在上面的AppenDextensionMethodnames方法中执行扩展方法的可行性检查。\r\n 该方法被retargetingNemedTypesymbol和RetargetingNamespaceSymbol覆盖，以便为了\r\n 对相应的retargetingmethodsymbol进行检查。\r\n \r\n 如果该方法可行，则返回true。\r\n \r\n","Fields":"字段\r\n","Variadic SignatureHelpItem must have at least one parameter.":"variadic signatureHelpItem必须至少具有一个参数。\r\n","Keyboard shortcuts:\r\n              Enter         If the current submission appears to be complete, evaluate it.  Otherwise, insert a new line.\r\n              Escape        Clear the current submission.\r\n              UpArrow       Replace the current submission with a previous submission.\r\n              Dow ...":"键盘快捷键：\r\n              输入如果当前提交似乎已经完成，请对其进行评估。否则，插入新行。\r\n              逃脱清除当前提交。\r\n              UPARROW将当前提交替换为先前的提交。\r\n              陶氏...\r\n","\r\n Note: This should be called at most once, immediately after the symbol is constructed. The parameters aren't \r\n Note: passed to the constructor because they need to have their container set correctly.\r\n ":"\r\n 注意：在构造符号之后，最多应一次调用一次。参数不是\r\n 注意：传递给构造函数，因为它们需要正确设置其容器。\r\n \r\n","\r\n Lookup in just a single binder, without delegating to containing binder. The original\r\n binder passed in is used for accessibility checking and so forth.\r\n ":"\r\n 仅在一个粘合剂中查找，而无需委派包含粘合剂。原本的\r\n 传递的粘合剂用于可访问性检查等。\r\n \r\n","string with left brackets removed and replaced by spaces":"卸下左支架的绳子并由空间代替\r\n","Adding a new file requires restarting the application.":"添加新文件需要重新启动应用程序。\r\n","\r\n            Implement to contribute ":"\r\n            实施贡献\r\n","Make class 'abstract'":"使课堂“抽象”\r\n","\r\n Returns a copy of this with the ModuleStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回其中的副本，并将其更改为ModuleStatement属性\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Represents a \"Resume\" statement. The Kind property can be used to determine if\r\n this is a \"Resume\", \"Resume Next\" or \"Resume label\" statement.\r\n ":"\r\n 代表“简历”陈述。可以使用该属性来确定是否\r\n 这是“简历”，“简历下一步”或“简历标签”语句。\r\n \r\n","The bound index expression (bound local).":"绑定索引表达式（绑定本地）。\r\n","\r\n The class to represent top level types imported from a PE/module.\r\n ":"\r\n 代表从PE/模块导入的顶级类型的类。\r\n \r\n","\r\n Collection of names of members declared within this type.\r\n ":"\r\n 在此类型中声明的成员名称的集合。\r\n \r\n","\r\n            Indicates action to perform on the reference.\r\n            ":"\r\n            表示要对参考执行的操作。\r\n            \r\n","\r\n Scan text inside of <!-- ... -->\r\n ":"\r\n <！ -  ...  - >内部的扫描文本\r\n \r\n","\r\n Bind a generic dotted name to a type or namespace.\r\n ":"\r\n 将通用虚线名称绑定到类型或名称空间。\r\n \r\n","\r\n The \"On\" keyword\r\n ":"\r\n “ on”关键字\r\n \r\n","Node not in parent's child list":"节点不在父母的子列表中\r\n","\r\n Bind the given attribute speculatively at the given position, and return back\r\n the resulting bound node summary. May return null in some error cases.\r\n ":"\r\n 在给定位置绑定给定属性，然后返回\r\n 结果结合节点摘要。在某些错误情况下可能会返回null。\r\n \r\n","\r\n            in one ":"\r\n            一个\r\n","\r\n A Binder object represents a general location from where binding is happening, and provides\r\n virtual methods for looking up unqualified names, reporting errors, and also other\r\n operations that need to know about where binding happened from (accessibility checking,\r\n etc.) It also contains most of the methods related to general binding of constructs,\r\n although some large sections are factored into their own classes.\r\n\r\n Yes, Binder is a big grab bag of features. The reason for this is that binders are threaded\r\n through essentially ALL binding functions. So, basically Binder has all the features that\r\n need to be threaded through binding.\r\n\r\n Binder objects form a linked list and each binder links to its containing binder. Each\r\n binder only handles operations that it knows how to handles, and passes on other calls to\r\n its containing binder. This maintains separation of concerns and allows binders to be strung\r\n together in various configurations to enable different binding scenarios (e.g., debugger\r\n expression evaluator).\r\n\r\n In general, binder objects should be constructed via the BinderBuilder class.\r\n\r\n Binder class has GetBinder methods that return binders for scopes nested into the current\r\n binder scope. One should not expect to get a binder from the functions unless a syntax that\r\n originates a scope is passed as the argument. Also, the functions do not cross lambda\r\n boundaries, if binder's scope contains a lambda expression, binder will not return any\r\n binders for nodes contained in the lambda body. In order to get them, the lambda must be\r\n bound to BoundLambda node, which exposes LambdaBinder, which can be asked for binders in the\r\n lambda body (but it will not descend into nested lambdas). Currently, only\r\n ":"\r\n 粘合剂对象表示绑定发生的一般位置，并提供\r\n 查找未合格名称，报告错误以及其他的虚拟方法\r\n 需要知道绑定在哪里发生的操作（可访问性检查，\r\n 等等。）它还包含与构造的一般结合有关的大多数方法，\r\n 尽管一些大型部分被纳入自己的课程。\r\n\r\n 是的，活页夹是一个很大的功能袋。原因是绑定器是螺纹的\r\n 通过本质上所有绑定功能。因此，基本上粘合剂具有所有功能\r\n 需要通过绑定螺纹。\r\n\r\n 粘合剂对象形成一个链接列表，每个粘合剂链接都链接到其包含粘合剂。每个\r\n 活页夹只处理知道如何处理的操作，并将其他呼叫传递给\r\n 它的粘合剂。这保持了关注点的分离，并允许粘合剂串\r\n 一起以各种配置一起启用不同的绑定方案（例如，调试器\r\n 表达评估器）。\r\n\r\n 通常，粘合剂对象应通过BinderBuilder类构建。\r\n\r\n 粘合剂类具有GetBinder方法，可以将嵌套到当前的范围返回binder\r\n 活页夹范围。除非语法是\r\n 发起的范围作为参数传递。另外，功能不会越过lambda\r\n 边界，如果活页夹的范围包含lambda表达式，则粘合剂将不会返回任何\r\n Lambda体内包含的节点的粘合剂。为了获得它们，Lambda必须是\r\n 绑定到Boundlambda节点，该节点暴露了lambdabinder，可以要求在\r\n Lambda的身体（但不会降为嵌套的Lambdas）。目前，只有\r\n \r\n","type constraint":"类型约束\r\n","\r\n Returns true if at least one of the elements of this list needs to be injected into a \r\n constructor because it's not a const or it is a const and it's type is either decimal \r\n or date. Non const fields always require a constructor, so this function should be called to \r\n determine if a synthesized constructor is needed that is not listed in members list.\r\n ":"\r\n 如果至少需要将此列表的元素注入到一个\r\n 构造函数，因为它不是const，也不是const，它的类型是小数\r\n 或日期。非const字段始终需要一个构造函数，因此应调用此功能\r\n 确定是否需要合成的构造函数，该构造函数未在成员列表中列出。\r\n \r\n","\r\n  Looks up a localized string similar to Instance of restricted type '{0}' cannot be used in a query expression..\r\n":"\r\n  查找类似于限制类型的实例“ {0}”的本地化字符串，无法在查询表达式中使用。\r\n\r\n","\r\n The value for the LocalName property.\r\n ":"\r\n LocalName属性的值。\r\n \r\n"," Index of the property in the containing anonymous type ":" 包含匿名类型的属性索引\r\n","\r\n Consider only events. Used to indicate that lookup searches for events only. Is used\r\n to change lookup semantic for searching inside interfaces having CoClass attribute defined. \r\n \r\n Essentially this is a special casing for searching events (and non-event symbols) in \r\n COM interfaces, see the following example from Dev11 code:\r\n\r\n Performing a lookup in a CoClass interface affects how we treat ambiguities between events and other members.\r\n In COM, events are separated into their own binding space, thus it is possible for an event and member to have\r\n the same name.  This is not possible in the .NET world, but for backwards compatibility, especially with Office,\r\n the compiler will ignore ambiguities when performing a lookup in a CoClass interface.  Example:\r\n\r\n     Interface _Foo\r\n        Sub Quit\r\n\r\n     Interface FooSource\r\n        Event Quit\r\n\r\n     < System.Runtime.InteropServices.CoClass(GetType(FooClass)) >\r\n     Interface Foo : Inherits _Foo, FooSource\r\n\r\n     Class FooClass : Implements Foo\r\n         Event Quit Implements Foo.Quit\r\n         Sub Quit Implements Foo.Quit\r\n\r\n ":"\r\n 仅考虑事件。用于指示仅查找事件的查找搜索。用来\r\n 要更改查找语义，以搜索具有定义的尾clast虫属性的内部界面。\r\n \r\n 本质上，这是搜索事件（和非事实符号）的特殊外壳\r\n COM接口，请参见Dev11代码的以下示例：\r\n\r\n 在瓶接口中进行查找会影响我们如何处理事件与其他成员之间的歧义。\r\n 在com中，事件分为自己的绑定空间，因此事件和成员有可能拥有\r\n 同名。在.NET世界中，这是不可能的，但是对于向后兼容，尤其是与办公室的兼容性，\r\n 编译器在尾cass接口中执行查找时会忽略歧义。例子：\r\n\r\n     接口_foo\r\n        子退出\r\n\r\n     接口foosource\r\n        事件退出\r\n\r\n     <system.runtime.interopservices.coclass（getType（fooclass））>\r\n     接口foo：继承_ foo，foosource\r\n\r\n     梭状棒：实施foo\r\n         事件退出工具foo.quit\r\n         子退出工具foo.quit\r\n\r\n \r\n","\r\n on attributes with valid attribute usage.\r\n This method is called by the binder when it is finished binding a set of attributes on the symbol so that \r\n the symbol can extract data from the attribute arguments and potentially perform validation specific to \r\n some well known attributes. \r\n ":"\r\n 在具有有效属性用法的属性上。\r\n 当粘合剂完成绑定符号上的一组属性时，该方法是调用的\r\n 该符号可以从属性参数中提取数据，并可能执行特定于\r\n 一些众所周知的属性。\r\n \r\n","Invalid value provided.":"提供了无效的值。\r\n","\r\n Represents a case statement and its subsequent block.\r\n ":"\r\n 代表一个案例陈述及其后续块。\r\n \r\n","\r\n Represents colons that are syntactically insignificant.\r\n ":"\r\n 代表句法无关紧要的结肠。\r\n \r\n","Install with package manager...":"与软件包管理器安装...\r\n","\r\n Perform a check whether the type or at least one of its generic arguments \r\n is defined in the specified assemblies. The check is performed recursively. \r\n ":"\r\n 执行检查类型还是至少一种通用参数\r\n 在指定的组件中定义。检查是递归执行的。\r\n \r\n","The bound local.":"绑定的本地。\r\n","\r\n            XML comment has syntactically incorrect cref attribute\r\n            ":"\r\n            XML评论在句法上不正确CREF属性\r\n            \r\n","\r\n The type suffix or type character that was on the literal, if any. If no suffix\r\n was present, TypeCharacter.None is returned.\r\n ":"\r\n 字面上的字体或类型字符（如果有的话）。如果没有后缀\r\n 在场，typecharacter.none返回。\r\n \r\n","\r\n            Optional ":"\r\n            可选的\r\n","Negate expression (changes semantics)":"否定表达（改变语义）\r\n","\r\n  Looks up a localized string similar to Static variables cannot appear inside Async or Iterator methods..\r\n":"\r\n  查找类似于静态变量的本地化字符串，无法在异步或迭代器方法中出现。\r\n\r\n","Changing visibility of {0} requires restarting the application.":"更改{0}的可见性需要重新启动应用程序。\r\n","\r\n The set of trees for which a ":"\r\n 一组树木\r\n","\r\n Returns a copy of this with the PercentGreaterThanToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中包括Persotreatthantken物业更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n The initializer including the braces.\r\n ":"\r\n 包括牙套的初始化器。\r\n \r\n","\r\n Gets unique source assembly attributes that should be emitted,\r\n i.e. filters out attributes with errors and duplicate attributes.\r\n ":"\r\n 获取应发射的唯一源组件属性，\r\n 即，使用错误和重复属性过滤属性。\r\n \r\n","\r\n The contents are provided by ReferenceManager and may not be modified.\r\n ":"\r\n 内容由ReferenceManager提供，不得修改。\r\n \r\n"," \r\n Determines if the method is partial \r\n ":" \r\n 确定该方法是否部分\r\n \r\n","\r\n Call ":"\r\n 称呼\r\n","\r\n Binds loop body and the next variables for ForTo and ForEach loops.\r\n ":"\r\n 绑定循环主体和forto和foreach循环的下一个变量。\r\n \r\n","\r\n returns true if feature is available\r\n ":"\r\n 如果功能可用，则返回true\r\n \r\n",".\r\n            \r\n            If specified, the ":"。\r\n            \r\n            如果指定，\r\n","\r\n The \"Of\" keyword.\r\n ":"\r\n “”关键字。\r\n \r\n","\r\n If -1, symbol is in metadata or embedded or otherwise not it source.\r\n Note that TreeOrdinal is only used for EmbeddedSymbolKind.None trees, thus\r\n negative ordinals of embedded trees do not interfere\r\n ":"\r\n 如果-1，符号在元数据或嵌入式或其他不是源中。\r\n 请注意，Treeordinal仅用于嵌入式的bolkind.none树，因此\r\n 嵌入树的负序列不会干扰\r\n \r\n","\r\n A bound call to the MoveNext method.\r\n ":"\r\n 对Movenext方法的界定调用。\r\n \r\n","Unexpected character sequence '...'":"意外的角色序列'...'\r\n","\r\n  Looks up a localized string similar to To return a value from an Iterator function, use 'Yield' rather than 'Return'..\r\n":"\r\n  查找类似于从迭代函数返回值的本地化字符串，使用“收益率”而不是“返回”。\r\n\r\n","A list of matching interfaces.":"匹配接口列表。\r\n"," id within the specified Document.\r\n            Useful when you do not have an instance of the diagnostic, such as when invoked as a remote service.\r\n            ":" 指定文档中的ID。\r\n            当您没有诊断实例时，例如被调用为远程服务时有用。\r\n            \r\n","The initialization syntax.":"初始化语法。\r\n","The rewritten node produced by ":"由\r\n","\r\n  Looks up a localized string similar to There is an error in a referenced assembly '{0}'..\r\n":"\r\n  查找类似于引用的汇编'{0}'..的本地化字符串。\r\n\r\n","\r\n            type or namespace could not be found\r\n            ":"\r\n            找不到类型或名称空间\r\n            \r\n","\r\n Construct a new type from this type definition, substituting the given type arguments for the \r\n type parameters. This method should only be called on the OriginalDefinition. Unlike previous \r\n Construct method, this overload supports type parameter substitution on this type and any number\r\n of its containing types. See comments for TypeSubstitution type for more information.\r\n ":"\r\n 从此类型的定义中构造一种新类型，将给定类型的参数替换为\r\n 类型参数。此方法仅应在原始定义上调用。与以前不同\r\n 构造方法，此过载支持此类型上的类型参数替换和任何数字\r\n 它的包含类型。有关更多信息，请参见评论以获取典型固定类型。\r\n \r\n"," on the symbol, \r\n the string might be null or an invalid guid representation. False, \r\n if there is no ":" 在符号上，\r\n 字符串可能为null或无效的GUID表示。错误的，\r\n 如果没有\r\n","\r\n Validate method type parameter constraints against implemented methods.\r\n ":"\r\n 验证方法类型参数约束针对实现的方法。\r\n \r\n","and update call sites directly":"并直接更新通话网站\r\n","The right value.":"正确的值。\r\n","\r\n Candidate nodes that may be reused.\r\n ":"\r\n 可以重复使用的候选节点。\r\n \r\n"," when analyzing a particular\r\n            semantic model.  This saves the time from having to recreate this for every string literal that features\r\n            examine for a particular semantic model.\r\n            ":" 分析特定\r\n            语义模型。这节省了时间，从必须为每个字符串的字符串重新创建它\r\n            检查特定的语义模型。\r\n            \r\n","\r\n Get the state of Option Infer for the code covered by this semantic model.\r\n This takes into effect both file-level \"Option Infer\" statements and the project-level\r\n defaults.\r\n ":"\r\n 获取该语义模型涵盖的代码的选择状态。\r\n 这可以生效文件级“选项推断”语句和项目级别\r\n 默认。\r\n \r\n","\r\n The type that declares this type parameter\r\n ":"\r\n 声明此类型参数的类型\r\n \r\n","\r\n Returns true if this symbol was automatically created by the compiler, and does not\r\n have an explicit corresponding source code declaration.  \r\n ":"\r\n 如果此符号是由编译器自动创建的，则返回true，而不是\r\n 具有明确的相应源代码声明。\r\n \r\n","letter, lowercase":"字母，小写\r\n"," that contains path, line and column information.\r\n ":" 其中包含路径，行和列信息。\r\n \r\n","\r\n Returns a copy of this with the Root property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，root属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n The statements contained in the While...End While. This might be an empty list.\r\n ":"\r\n 段落中包含的陈述...结束。这可能是一个空列表。\r\n \r\n","\r\n Returns OrderBy/OrderByDescending/ThenBy/ThenByDescending method associated with OrderingSyntax.\r\n ":"\r\n 返回与订购的订单/订购/订购/thenby/thenby/thtbyDescending方法。\r\n \r\n","\r\n Creates a syntax trivia normalizing visitor\r\n ":"\r\n 创建语法琐事正常化的访问者\r\n \r\n","\r\n Is System.Runtime.InteropServices.GuidAttribute applied to this type in code.\r\n ":"\r\n IS System.Runtime.InterOpservices.guidattribute在代码中应用于此类型。\r\n \r\n","\r\n Identifies the XML namespace alias and URI.\r\n ":"\r\n 标识XML名称空间别名和URI。\r\n \r\n","\r\n                var v = expr\r\n                    ? whenTrue\r\n                    : whenFalse\r\n            ":"var v = expr\r\n                    ？ whentrue\r\n                    ：何时\r\n            \r\n","\r\n matches one char or another.\r\n Typical usage is for matching lowercase and uppercase.\r\n ":"\r\n 匹配一个或另一个字符。\r\n 典型的用法是匹配小写和大写。\r\n \r\n","The result of the last code snippet.":"最后一个代码段的结果。\r\n","Changing '{0}' to '{1}' requires restarting the application because it changes the shape of the state machine.":"将'{0}'更改为'{1}'需要重新启动应用程序，因为它会更改状态计算机的形状。\r\n","\r\n The optional \"Key\" keyword.\r\n ":"\r\n 可选的“关键”关键字。\r\n \r\n","\r\n Class C\r\n   Event Name(a As Integer, b As Integer)\r\n End Class\r\n \r\n defines an event and a delegate type:\r\n \r\n Event Name As NamedEventHandler\r\n Delegate Sub NameEventHandler(a As Integer, b As Integer)\r\n \r\n ":"\r\n c\r\n   事件名称（A as Integer，B为整数）\r\n 最终课程\r\n \r\n 定义事件和委托类型：\r\n \r\n 事件名称名为neventhandler\r\n 委托Sub NameEventHandler（A as Integer，B为整数）\r\n \r\n \r\n","\r\n            Aggregates events from various diagnostic sources.\r\n            ":"\r\n            来自各种诊断来源的事件。\r\n            \r\n","The severity of the message.":"消息的严重性。\r\n","\r\n The \"Do\", \"For\" or \"While\" keyword that identifies the kind of loop being\r\n continued.\r\n ":"\r\n “ do”，for“”或“”关键字，以识别循环的类型\r\n 继续。\r\n \r\n","\r\n            Line edits in the document (or mapped documents), or null if the document has syntax errors, rude edits or has not changed.\r\n            ":"\r\n            文档中的行编辑（或映射的文档），或null如果文档有语法错误，粗鲁的编辑或尚未更改。\r\n            \r\n","\r\n  Looks up a localized string similar to 'End AddHandler' must be preceded by a matching 'AddHandler' declaration..\r\n":"\r\n  查找类似于“ End Addhandler”的本地化字符串必须先于匹配的“ Addhandler”声明。\r\n\r\n","Member name can be simplified":"会员名称可以简化\r\n","\r\n            If this value is not set, the argument completion session will insert a language-specific default value for\r\n            the argument.\r\n            ":"\r\n            如果未设置此值，则参数完成会话将插入特定语言的默认值\r\n            论点。\r\n            \r\n","The type substitution":"类型替代\r\n","\r\n Helper structure to classify conversions from named types to interfaces\r\n in accumulating fashion.\r\n ":"\r\n 助手结构将转换从命名类型分类为接口\r\n 以累积的方式。\r\n \r\n","\r\n This binder keeps track of the set of symbols that are currently being evaluated\r\n so that the set can be passed to methods to support breaking infinite recursion\r\n cycles.\r\n ":"\r\n 此活页夹跟踪当前正在评估的符号集\r\n 因此，该集合可以传递到支持破坏无限递归的方法\r\n 周期。\r\n \r\n","\r\n The closure doesn't declare any variables. \r\n Display class Is a singleton And may be shared with other top-level methods.\r\n ":"\r\n 关闭未声明任何变量。\r\n 显示类是单身人士，可以与其他顶级方法共享。\r\n \r\n","Use block body for lambda expressions":"使用块主体进行lambda表达式\r\n","\r\n A list of one or more import clauses. Each clause is either an alias, namespace\r\n or XML namespace import.\r\n ":"\r\n 一个或多个导入条款的列表。每个子句要么是别名，名称空间\r\n 或XML名称空间导入。\r\n \r\n","\r\n System.NonSerializedAttribute applied on an event and determines serializability of its backing field.\r\n ":"System.nerializedAttribute应用于事件，并确定其背部的序列化性。\r\n \r\n","\r\n            Map from unused parameters to a boolean value indicating if the parameter has a read reference or not.\r\n            For example, a parameter whose initial value is overwritten before any reads\r\n            is an unused parameter with read reference(s).\r\n            ":"\r\n            从未使用的参数到布尔值，指示参数是否具有读取参考。\r\n            例如，在任何读取之前，其初始值被覆盖的参数\r\n            是带有读取参考的未使用参数。\r\n            \r\n","\r\n            ```a-z``` node in a character class.\r\n            ":"\r\n            字符类中的节点``a-z''。\r\n            \r\n","\r\n This function must return a BoundConversion node in case of explicit or non-identity conversion.\r\n ":"\r\n 在明确或非身份转换的情况下，此功能必须返回boundconversion节点。\r\n \r\n","\r\n  Looks up a localized string similar to 'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to a Declare..\r\n":"\r\n  查找类似于'system.runtime.interopservices.dllimportattribute'的本地化字符串，不能应用于声明。\r\n\r\n","\r\n Called at the point in a loop where the backward branch is placed.\r\n ":"\r\n 在循环中放置向后分支的循环中的点。\r\n \r\n","\r\n            moved closer to first reference and all the existing\r\n            local declaration statements annotated with ":"\r\n            移动到首次参考和所有现有的参考\r\n            注释的本地声明声明\r\n"," only provides diagnostics for either push or pull purposes (but not both).\r\n            If the caller's desired purpose doesn't match the option value, then this will return nothing, otherwise it\r\n            will return the requested diagnostics.":" 仅提供用于推送或拉的目的（但两者兼而有之）的诊断。\r\n            如果呼叫者的所需目的与选项值不匹配，则将其返回，否则\r\n            将返回请求的诊断。\r\n"," values are not equal.\r\n ":" 值不相等。\r\n \r\n"," if this instance is metadata constant; otherwise, ":" 如果此实例是元数据常数；否则，\r\n","\r\n Bind Select like selector based on the set of expression range variables in context of this binder.\r\n ":"\r\n 根据此粘合剂的上下文，基于表达范围变量的集合，将选择像选择器一样。\r\n \r\n","\r\n Returns a copy of this with the Arguments property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而参数属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n The underlying MethodSymbol, cannot be another RetargetingMethodSymbol.\r\n ":"\r\n 基础方法符号不能是另一个retargetingmethodsymbol。\r\n \r\n","An expression tree may not contain a switch expression.":"表达树可能不包含开关表达式。\r\n","\r\n Construct context with Failed flag\r\n ":"\r\n 用失败的标志构建上下文\r\n \r\n","Separate words":"单独的单词\r\n"," to determine whether to bail from analysis or not.\r\n            ":" 确定是否从分析中保释。\r\n            \r\n","\r\n Returns a copy of this with the specified changes. Returns this instance if\r\n there are no actual changes.\r\n ":"\r\n 返回其中的副本，并带有指定的更改。返回此实例如果\r\n 没有实际的更改。\r\n \r\n","\r\n The value for the EndSubStatement property.\r\n ":"\r\n EndubStatement属性的值。\r\n \r\n","\r\n            Base type of all regex escapes that start with \\ and some informative character (like \\v \\t \\c etc.).\r\n            ":"\r\n            所有正则逃脱的基本类型均以\\和一些有益的字符开头（例如\\ v \\ t \\ c等）。\r\n            \r\n","\r\n Returns a copy of this with the OfKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中OfKeyWord属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n",".\r\n            The scenarios include moving a type declaration from one file to another and moving a member of a partial type from one partial declaration to another.\r\n            ":"。\r\n            该方案包括将类型声明从一个文件移动到另一个文件，并将部分类型的成员从一个部分声明移至另一部分。\r\n            \r\n","\r\n The list of new variables being defined by the aggregation.\r\n ":"\r\n 聚合定义的新变量列表。\r\n \r\n","Optional span within the syntax tree for which to get diagnostics.\r\n If no argument is specified, then diagnostics for the entire tree are returned.":"在语法树中可进行的可选跨度，以获取诊断。\r\n 如果未指定参数，则返回整棵树的诊断。\r\n","Discard can be removed":"丢弃可以删除\r\n","\r\n The \"@\" part of .@ or the second \".\" of \"...\".\r\n ":"\r\n 。的 ”...”。\r\n \r\n","\r\n Create a new token with the trivia appended to the existing following trivia\r\n ":"\r\n 创建一个带有琐事附加到现有琐事的琐事的新令牌\r\n \r\n","\r\n            Returns true if GAC is available on the current platform.\r\n            ":"\r\n            如果在当前平台上可用GAC，则返回true。\r\n            \r\n","\r\n            for the symbol and the project ID that originated the symbol.  With these we can correctly recover the symbol.\r\n            ":"\r\n            对于构成符号的符号和项目ID。有了这些，我们可以正确恢复符号。\r\n            \r\n","\r\n Return true if the node is an immediate child of a call statement.\r\n ":"\r\n 如果节点是呼叫声明的直接孩子，则返回true。\r\n \r\n"," in which symbol is resolved.":" 在其中解决了符号。\r\n","\r\n A mapping from every local variable to its replacement local variable. Local variables \r\n are replaced when their types change due to being inside of a lambda within a generic method.\r\n ":"\r\n 从每个局部变量到其替换本地变量的映射。本地变量\r\n 由于在通用方法中在lambda内部发生变化时，将更换它们的类型。\r\n \r\n","\r\n Modifier validation code shared between properties and methods.\r\n ":"\r\n 修改器验证代码之间共享属性和方法之间的代码。\r\n \r\n","Unicode General Category: {0}":"Unicode常规类别：{0}\r\n","\r\n  Looks up a localized string similar to Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' forwarded to assembly '{3}'..\r\n":"\r\n  查找类似于'{0}'转发到assembly' {1}'类型'{1}'的本地化字符串与type'{2}'转发到汇编'{3}'..\r\n\r\n","\r\n To handle array initialization of arbitrary rank it is convenient to \r\n approach multidimensional initialization as a recursively nested.\r\n \r\n ForAll{i, j, k} Init(i, j, k) ===> \r\n ForAll{i} ForAll{j, k} Init(i, j, k) ===>\r\n ForAll{i} ForAll{j} ForAll{k} Init(i, j, k)\r\n \r\n This structure is used for capturing initializers of a given index and \r\n the index value itself.\r\n ":"\r\n 处理任意等级的数组初始化，很方便\r\n 接近多维初始化作为递归嵌套的方法。\r\n \r\n forall {i，j，k} init（i，j，k）===>\r\n forall {i} forall {j，k} init（i，j，k）===>\r\n forall {i} forall {j} forall {k} init（i，j，k）\r\n \r\n 该结构用于捕获给定索引的初始化器和\r\n 索引值本身。\r\n \r\n","\r\n Look for overridden members in a specific type. Return true if we find an overridden member candidate \r\n with 'exact' signature match, or we hit a member that hides. See comments on MakeOverriddenMembers(...)\r\n for description of 'exact' and 'inexact' signature matches.\r\n \r\n Also remember any inaccessible members that we see.\r\n ":"\r\n 在特定类型中寻找覆盖成员。如果我们找到一个候选人，请返回true\r\n 使用“精确”签名匹配，或者我们击中了一个藏身的成员。请参阅有关MachoverRiddenMbers（...）的评论\r\n 有关“精确”和“不精确”签名匹配的说明。\r\n \r\n 还要记住我们看到的任何无法接近的成员。\r\n \r\n","\r\n  Looks up a localized string similar to Events cannot have a return type..\r\n":"\r\n  查找类似于事件的本地化字符串不能具有返回类型。\r\n\r\n","\r\n A SubstitutedTypeParameterSymbol represents an alpha-renamed type parameter.\r\n They are created only for open generic types and methods that are contained within a \r\n constructed generic type.\r\n \r\n Alpha-renamed type parameters have their constraints substituted according\r\n to type/method's containing type's TypeSubstitution.\r\n For example:\r\n     Class A (Of T)\r\n         Class B(Of S As T)\r\n         End Class\r\n     End Class\r\n  \r\n Given a type A(Of IComparable).B(Of ), alpha-renamed type parameter T will have type constraint IComparable.\r\n The rest will be exactly as for the original type parameter T. In fact, OriginalDefinition will return symbol for T.\r\n ":"\r\n 替换typeparametersymbol代表α命名的类型参数。\r\n 它们仅是针对包含在\r\n 构造的通用类型。\r\n \r\n alpha命名的类型参数的约束替代\r\n type/method的包含类型的类型企业。\r\n 例如：\r\n     A类（T）\r\n         B级（S为T）\r\n         最终课程\r\n     最终课程\r\n  \r\n 给定一个类型A（iComable）.b（Of），alpha命名的类型参数t将具有型号的键入。\r\n 其余的将完全与原始类型参数T一样。实际上，原始定义将返回t的符号。\r\n \r\n","\r\n Compare two symbol objects to see if they refer to the same symbol. You should always use\r\n = and <>, or the Equals method, to compare two symbols for equality.\r\n ":"\r\n 比较两个符号对象，以查看它们是否指的是相同的符号。你应该始终使用\r\n = and <>，或等于比较两个符号的平等符号。\r\n \r\n","\r\n Derive error info from a type symbol.\r\n ":"\r\n 从类型符号中得出错误信息。\r\n \r\n","\r\n  Looks up a localized string similar to Named argument expected..\r\n":"\r\n  查找类似于指定参数的本地化字符串。\r\n\r\n"," node shares body with another declaration.\r\n            ":" 节点与另一个声明共享身体。\r\n            \r\n","\r\n Parse a name.\r\n ":"\r\n 解析名称。\r\n \r\n","Expected to be a member symbol type (e.g. method, property).":"预计将是成员符号类型（例如方法，属性）。\r\n"," to remove based on whether or not all variable declarators\r\n            within a field declaration should be removed,\r\n            i.e. if all the fields declared within a field declaration are unused,\r\n            we can remove the entire field declaration instead of individual variable declarators.\r\n            ":" 根据是否所有变量声明器删除\r\n            在字段声明中应删除，\r\n            即，如果未使用字段声明中声明的所有字段，\r\n            我们可以删除整个字段声明，而不是单个变量声明器。\r\n            \r\n","\r\n  Looks up a localized string similar to '{0}' cannot override '{1}' because they differ by their return types..\r\n":"\r\n  查找类似于'{0}'不能覆盖'{1}'的本地化字符串，因为它们的返回类型有所不同。\r\n\r\n","\r\n Returns a copy of this with the CustomKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，使用CustomKeyWord属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Initialize field '{0}'":"初始化字段'{0}'\r\n","One of the parameters of a binary operator must be the containing type, or its type parameter constrained to it.":"二进制运算符的参数之一必须是包含类型，或者其类型的参数约束。\r\n","\r\n The \"GetType\" keyword.\r\n ":"\r\n “ getType”关键字。\r\n \r\n","\r\n that immediately contains the variable.\r\n \r\n The location of the declarator is used to calculate ":"\r\n 立即包含变量。\r\n \r\n 声明器的位置用于计算\r\n","\r\n            Calculates and caches results of changed documents analysis. \r\n            The work is triggered by an incremental analyzer on idle or explicitly when \"continue\" operation is executed.\r\n            Contains analyses of the latest observed document versions.\r\n            ":"\r\n            计算和缓存文档分析的结果。\r\n            在执行“继续”操作时，由闲置或明确的闲置分析仪触发了这项工作。\r\n            包含对最新观察到的文档版本的分析。\r\n            \r\n","\r\n            Determine whether updates have been made to projects containing the specified file (or all projects that are built,\r\n            if ":"\r\n            确定是否已对包含指定文件的项目进行更新（或已构建的所有项目\r\n            如果\r\n","\r\n  Looks up a localized string similar to 'Namespace' statement must end with a matching 'End Namespace'..\r\n":"\r\n  查找类似于“命名空间”语句的本地化字符串必须以匹配的“端命名空间”结尾。\r\n\r\n","\r\n Returns a copy of this with the LibraryName property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此的副本，libraryname属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Check ForBlockSyntax for being the uppermost For block. By uppermost \r\n For block we mean that if Next clause contains several control variables,\r\n the uppermost block is the one which includes all the For blocks ending with \r\n the same Next clause\r\n ":"\r\n 检查forblocksyntax是否是最高的块。最高\r\n 对于块，我们的意思是，如果下一个子句包含几个控制变量，则\r\n 最上面的块是一个包含所有结尾的块\r\n 相同的下一个子句\r\n \r\n","Locals":"当地人\r\n","Add readonly modifier":"添加可读的修饰符\r\n","\r\n            The stream must be readable and seekable.\r\n            ":"\r\n            该流必须可读和可寻求。\r\n            \r\n"," representing the specific kind of\r\n TypeOfExpressionSyntax. One of TypeOfIsExpression, TypeOfIsNotExpression.\r\n ":" 代表特定种类\r\n typeofexpressionsyntax。 Typeofisexpression之一，TypeOfisnoteXpression。\r\n \r\n","\r\n Returns a NOT-SIDE-EFFECTING expression that represents results of the operand\r\n If such transformation requires a temp, the temp and its initializing expression\r\n are returned in temp/init\r\n ":"\r\n 返回表示操作数结果的非边影响表达式\r\n 如果此类转换需要temp，则temp及其初始化表达式\r\n 在temp/init中返回\r\n \r\n","Wrapping":"包装\r\n","\r\n If this method is a reduced extension method, returns a type inferred during reduction process for the type parameter. \r\n ":"\r\n 如果此方法是减少的扩展方法，请返回类型参数减少过程中推断出的类型。\r\n \r\n","\r\n  Looks up a localized string similar to Illegal call expression or index expression..\r\n":"\r\n  查找类似于非法呼叫表达或索引表达式的本地化字符串。\r\n\r\n","\r\n  Looks up a localized string similar to 'In' or '=' expected..\r\n":"\r\n  查找类似于“ in”或“ in” ='预期的局部字符串。\r\n\r\n"," Creates a token with kind CharacterLiteralToken from the text and corresponding character value. ":" 从文本和相应的字符值中创建一个具有善良的字符的令牌。\r\n","\r\n Is this a symbol that is generated by the compiler and\r\n automatically added to the compilation? Note that\r\n only source symbols may be embedded symbols. \r\n \r\n Namespace symbol is considered to be an embedded symbol\r\n if at least one of its declarations are embedded symbols.\r\n ":"\r\n 这是编译器生成的符号吗？\r\n 自动添加到汇编中？注意\r\n 仅源符号可以嵌入符号。\r\n \r\n 名称空间符号被认为是嵌入式符号\r\n 如果至少有一个声明是嵌入式符号。\r\n \r\n","\r\n This symbol is used as a sentinel while we are binding a lambda in error recovery mode.\r\n ":"\r\n 当我们在错误恢复模式下绑定lambda时，该符号用作前哨。\r\n \r\n","\r\n  Looks up a localized string similar to Auto-implemented properties cannot be WriteOnly..\r\n":"\r\n  查找类似于自动实现属性的本地化字符串，无法写入。\r\n\r\n"," Or ":" 或者\r\n","\r\n            Set of two or more per-language options that can be used to configure the diagnostic severity of the given diagnosticId.\r\n            ":"\r\n            可用于配置给定诊断剂的诊断严重程度的两个或多个每语言选项的集合。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Default' can be applied to only one property name in a {0}..\r\n":"\r\n  查找类似于“默认”的本地化字符串可以应用于{0}中的一个属性名称。\r\n\r\n","Constants":"常数\r\n","\r\n            provide formatting rules to be used when formatting MAS file\r\n            ":"\r\n            提供格式化MAS文件时要使用的格式规则\r\n            \r\n","\r\n Represents a binary operator. The Kind property classifies the operators into\r\n similar kind of operators (arithmetic, relational, logical or string); the\r\n exact operation being performed is determined by the Operator property.\r\n ":"\r\n 代表二进制操作员。善的属性将操作员分类为\r\n 类似的运算符（算术，关系，逻辑或字符串）；这\r\n 要执行的精确操作由操作员属性确定。\r\n \r\n","\r\n  Looks up a localized string similar to Attribute '{0}' is not valid: Incorrect argument value..\r\n":"\r\n  查找类似于属性'{0}'的本地化字符串是无效的：不正确的参数值。\r\n\r\n","Changes made in project '{0}' will not be applied while the application is running":"应用程序运行时不会应用项目'{0}'的更改\r\n","An ImmutableArray containing all the types that are members of this namespace. If this namespace has no module members,\r\n returns an empty ImmutableArray. Never returns Nothing.":"ImmutableArray包含此名称空间成员的所有类型。如果此名称空间没有模块成员，\r\n 返回一个空的Immutablearray。永远不会返回。\r\n","\r\n An exit statement. The kind of block being exited can be found by examining the\r\n Kind.\r\n ":"\r\n 退出声明。可以通过检查\r\n 种类。\r\n \r\n","\r\n            Completion was triggered via an action deleting a character from the document.\r\n            ":"\r\n            通过从文档中删除字符的操作触发完成。\r\n            \r\n","\r\n An optional alias for the namespace or type being imported.\r\n ":"\r\n 命名空间或类型正在导入的可选别名。\r\n \r\n","\r\n            Use an explicit value to populate call sites, without forcing\r\n            the addition of a named argument.\r\n            ":"\r\n            使用明确的值来填充呼叫站点，而无需强迫\r\n            添加指定的论点。\r\n            \r\n","\r\n  Looks up a localized string similar to Expected '%=' at start of an embedded expression..\r\n":"\r\n  在嵌入式表达式开始时查找类似于预期的“％=”的局部字符串。\r\n\r\n","\r\n Generate implementation-specific state machine initialization for the kickoff method body.\r\n ":"\r\n 生成针对开球方法主体的特定实现状态机初始化。\r\n \r\n","\r\n Represents a type parameter symbol defined in source.\r\n ":"\r\n 表示源中定义的类型参数符号。\r\n \r\n","Cannot set a constant variable":"无法设置常数变量\r\n","\r\n            Track if we're in an anonymous method or not.  If so, because of how the language binds lambdas and\r\n            overloads, we'll assume any method access we see inside (instance or otherwise) could end up conflicting\r\n            with an extension method we might pull in.\r\n            ":"\r\n            跟踪是否使用匿名方法。如果是这样，由于语言如何绑定lambdas和\r\n            过载，我们假设我们在内部看到的任何方法访问（实例或其他方式）可能最终会发生冲突\r\n            使用扩展方法，我们可能会加入。\r\n            \r\n","\r\n            Adding an instance field to an existing type.\r\n            ":"\r\n            将实例字段添加到现有类型。\r\n            \r\n","\r\n  Looks up a localized string similar to 'End Set' must be preceded by a matching 'Set'..\r\n":"\r\n  查找类似于“端集”的本地化字符串必须先于匹配的“集合”。\r\n\r\n","\r\n            Checks that the expression is \"new List();\"\r\n            Exclude \"new List(a);\" and new List() { 1, 2, 3}\r\n        ":"检查该表达式是“新列表（）;”\r\n            排除“新列表（a）”；和新列表（）{1，2，3}\r\n        \r\n","\r\n             Refactor:\r\n                 var o = (object)1;\r\n            \r\n             Into:\r\n                 var o = 1 as object;\r\n             ":"\r\n             重构：\r\n                 var o =（对象）1;\r\n            \r\n             进入：\r\n                 var o = 1作为对象;\r\n             \r\n","\r\n  Structure containing all semantic information about a for each statement.\r\n ":"\r\n  结构包含有关每个语句的所有语义信息。\r\n \r\n","\r\n Create a BoundBadExpression node for the given child-expression, which is preserved as a sub-expression. \r\n A ResultKind explains why the node is bad.\r\n ":"\r\n 为给定的儿童表达创建一个boundbadexpression节点，该节点被保留为子表达。\r\n 结果kind解释了为什么节点不好。\r\n \r\n"," snapshot and the one given to the previous successful call or\r\n            the one passed to ":" 快照和以前的成功电话或\r\n            一个传递给\r\n","\r\n Initializers for fields and properties cannot be rewritten to their final form at this place because they might need \r\n to be rewritten to replace their placeholder expressions to the final locals or temporaries (e.g. in case of a field\r\n declaration with \"AsNew\" and multiple variable names. The final rewriting will during local rewriting.\r\n The statement list returned by this function can be copied into the initializer without reprocessing it.\r\n ":"\r\n 字段和属性的初始化器不能在此位置重写其最终形式，因为它们可能需要\r\n 要重写以替换其占位符的表达方式\r\n 用“ ASNEW”和多个变量名称声明。最终的重写将在本地重写期间。\r\n 该功能返回的语句列表可以复制到初始化器中，而无需重新处理。\r\n \r\n","'typeof' can be converted  to 'nameof'":"“ typeof”可以转换为“名称”\r\n","Use expression body for local functions":"将表达式主体用于本地功能\r\n","\r\n Represents an XML CDATA section in an XML literal expression.\r\n ":"\r\n 代表XML文字表达式中的XML CDATA截面。\r\n \r\n","The implementing member.":"实施成员。\r\n","\r\n Is this an auto-generated property of a group class?\r\n ":"\r\n 这是小组类的自动生成属性吗？\r\n \r\n","\r\n            ```\\1``` escape. In contexts where back-references are not allowed.\r\n            ":"\r\n            ````\\ 1``逃脱''。在不允许反向引用的上下文中。\r\n            \r\n"," representing the specific kind of CaseStatementSyntax.\r\n One of CaseStatement, CaseElseStatement.\r\n ":" 代表特定类型的casestatementsyntax。\r\n caseStatement之一。\r\n \r\n"," from a stream of Portable or Windows PDB.\r\n            ":" 从便携式或Windows PDB流。\r\n            \r\n","\r\n Represents a GetType expression.\r\n ":"\r\n 代表getType表达式。\r\n \r\n","Parameter to interpolated string handler conversion occurs after handler parameter":"参数到插值字符串处理程序转换发生在处理程序参数之后\r\n","\r\n            Creates EnC debug information reader.\r\n            ":"\r\n            创建ENC DEBUG信息阅读器。\r\n            \r\n",".\r\n            This will never create new ":"。\r\n            这永远不会创造新的\r\n"," \r\n Finds types or namespaces described by a qualified name. \r\n ":" \r\n 查找由合格名称描述的类型或名称空间。\r\n \r\n","balancing group":"平衡小组\r\n","The syntax node that declares a namespace block.":"声明命名空间块的语法节点。\r\n","\r\n Is System.Runtime.InteropServices.ComSourceInterfacesAttribute applied to this type in code.\r\n ":"\r\n IS System.runtime.interopservices.com.sourceinterfacesattribute在代码中应用于此类型。\r\n \r\n","\r\n  Looks up a localized string similar to Properties cannot be declared '{0}'..\r\n":"\r\n  查找类似于属性的本地化字符串无法声明“ {0}”。\r\n\r\n","\r\n The target of the call or index expression.\r\n ":"呼叫或索引表达式的目标。\r\n \r\n"," } and { ":" } 和 {\r\n","The receiver of a `with` expression must have a non-void type.":"带有“表达式的接收器必须具有非空隙类型。\r\n","\r\n Used for partial method parameters: \r\n Implementation parameter always copies its attributes from the corresponding definition parameter.\r\n Definition is always complex parameter and so it stores the attribute bag.\r\n ":"\r\n 用于部分方法参数：\r\n 实现参数始终从相应的定义参数复制其属性。\r\n 定义始终是复杂的参数，因此它存储属性袋。\r\n \r\n","\r\n Offset assigned to the field when the containing type is laid out by the VM.\r\n Nothing if unspecified.\r\n ":"\r\n 当VM布置包含类型时，分配给字段的偏移量。\r\n 如果未指定，什么也没有。\r\n \r\n"," representing code.\r\n            ":" 代表代码。\r\n            \r\n","If this node is a non-terminal, the parents of the trivia will be the first token of this \r\n non-terminal; NOT this node.":"如果此节点是非末端，那么琐事的父母将是第一个象征\r\n 非末端；不是这个节点。\r\n","The type that contains this method (this.ContainingType).":"包含此方法的类型（this.containingtype）。\r\n"," sequence uses braces. Only\r\n            the embedded statements falling ":" 序列使用牙套。仅有的\r\n            嵌入式陈述下降\r\n","\r\n Represents an AddHandler or RemoveHandler statement. The Kind property\r\n determines which one.\r\n ":"\r\n 代表Addhandler或Remove Handler语句。同类属性\r\n 确定哪一个。\r\n \r\n","\r\n  Looks up a localized string similar to Range variable '{0}' hides a variable in an enclosing block or a range variable previously defined in the query expression..\r\n":"\r\n  查找类似于范围变量'{0}'的局部字符串将变量隐藏在一个封闭块或以前在查询表达式中定义的范围变量。\r\n\r\n","\r\n The value for the WhenNotNull property.\r\n ":"\r\n nontnull属性的值。\r\n \r\n","<pattern variable>":"<模式变量>\r\n","True if \"overridingSym\" is from source (this.IsFromSomeCompilation).":"是的，如果“过度储备”来自源（this.isfromsomecompilation）。\r\n","\r\n Determined based upon value specified via ":"\r\n 根据指定的价值确定\r\n","Invalid characters in assemblyName":"汇编名称中的无效字符\r\n","\r\n  Looks up a localized string similar to Member '{0}' added during the current debug session can only be accessed from within its declaring assembly '{1}'..\r\n":"\r\n  查找类似于当前调试会话中添加的成员'{0}'的本地化字符串，只能从其声明的汇编'{1}'..中访问。\r\n\r\n","\r\n A mapping from the local variable slot to the symbol for the local variable itself.  This is used in the\r\n implementation of region analysis (support for extract method) to compute the set of variables \"always\r\n assigned\" in a region of code.\r\n ":"\r\n 从局部变量插槽到局部变量本身的符号的映射。这在\r\n 实施区域分析（支持提取方法）以计算变量集“始终\r\n 分配“在代码区域中。\r\n \r\n","\r\n  Looks up a localized string similar to Conversion operators must be declared either 'Widening' or 'Narrowing'..\r\n":"\r\n  必须声明一个类似于转换操作员的本地化字符串，必须声明“扩大”或“狭窄”。\r\n\r\n","\r\n  Looks up a localized string similar to 'Continue' must be followed by 'Do', 'For' or 'While'..\r\n":"\r\n  查找类似于“继续”的局部字符串，其后必须是“ do”，“ do”或“ while”。\r\n\r\n","\r\n Returns a copy of this with the KeyKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中Keykeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","). \r\n            Returns the same object if called multiple times with the same path.\r\n            ":"）。\r\n            如果多次调用相同的路径，则返回相同的对象。\r\n            \r\n","\r\n            Returns true if item1 is a better completion item than item2 given the provided filter\r\n            text, or false if it is not better.\r\n            ":"\r\n            如果item1比给出的extracs更好，则返回true。\r\n            文字，或者如果不是更好的话。\r\n            \r\n","\r\n  Looks up a localized string similar to Expected matching closing double quote for XML attribute value..\r\n":"\r\n  查找类似于XML属性值的预期匹配的双引号类似的本地化字符串。\r\n\r\n","\r\n Backing field for the ContainingMember property\r\n ":"\r\n 包含的属性的备份字段\r\n \r\n","\r\n            Provides context information for argument completion.\r\n            ":"\r\n            提供上下文信息以完成参数完成。\r\n            \r\n","Use range operator":"使用范围操作员\r\n","The limit to check the index against.":"检查索引的限制。\r\n","Failed to analyze data-flow for: {0}":"无法分析以下数据流：{0}\r\n","10,000,000ths of a second":"10,000,000秒\r\n","\r\n            One of many possible completions used to form the completion list presented to the user.\r\n            ":"\r\n            用于形成向用户提供的完成列表的许多可能的完成之一。\r\n            \r\n","\r\n            Implement this to participate in diagnostic service framework as one of diagnostic update source\r\n            ":"\r\n            实施此操作以参与诊断服务框架作为诊断更新源之一\r\n            \r\n","\r\n Dig through possibly jagged array type to the ultimate element type\r\n ":"\r\n 挖掘可能的锯齿阵列类型到最终元素类型\r\n \r\n","\r\n            Edit and continue is generally available with the set of capabilities that Mono 6, .NET Framework and .NET 5 have in common.\r\n            ":"\r\n            通常可以使用单声道6，.NET框架和.NET 5具有共同的功能。\r\n            \r\n","\r\n Represents the beginning statement of a Class declaration. This node always\r\n appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.\r\n ":"\r\n 代表班级声明的开始陈述。这个节点总是\r\n 出现是带有bink = classDeclarationBlock的TypeBlock的开始。\r\n \r\n","\r\n The value for the HandlesClause property.\r\n ":"\r\n HandlesClause属性的值。\r\n \r\n","\r\n Represents a ''' prefix for an XML Documentation Comment.\r\n ":"\r\n 代表XML文档注释的“”前缀。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' has no parameters and its return type cannot be indexed..\r\n":"\r\n  查找类似于“ {0}”的本地化字符串没有参数，其返回类型无法索引。\r\n\r\n","\r\n            Note: this function trims all whitespace from both the beginning and the end of given ":"\r\n            注意：此函数从给定的开始和结束都可以修剪所有空格\r\n","Simplify lambda expression":"简化lambda的表达\r\n","\r\n Represents the declaration of one or more variables or constants, either as\r\n local variables or as class/structure members. In the case of a constant, it is\r\n represented by having \"Const\" in the Modifiers (although technically \"Const\" is\r\n not a modifier, it is represented as one in the parse trees.)\r\n ":"\r\n 代表一个或多个变量或常数的声明，要么\r\n 本地变量或类/结构成员。在常数的情况下，它是\r\n 通过修饰符中的“ const”表示（尽管从技术上“ const”是\r\n 不是修饰符，它被表示为解析树中的一个。）\r\n \r\n"," is/inherits from/implements IEnumerable(Of U), and U is/inherits from/implements ":" IS/sharthits来自/instrument iEnumerable（u的u），u是/sharthits/insterment\r\n","\r\n Returns a copy of this with the IfKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中IFKeyWord属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            The current document content matches the content the built module was compiled with.\r\n            This is a final state. Once a document is in this state it won't switch to a different one.\r\n            ":"\r\n            当前的文档内容与已编译的模块所编译的内容匹配。\r\n            这是最终状态。一旦文档处于此状态，它将不会切换到其他文件。\r\n            \r\n","\r\n A ":"\r\n 一个\r\n","\r\n The value for the Contents property.\r\n ":"\r\n 内容属性的值。\r\n \r\n","\r\n Given result of binding preceding query operators, the source, bind the following Distinct operator.\r\n \r\n     {Preceding query operators} Distinct\r\n \r\n Ex: From a In AA Distinct ==> AA.Distinct()\r\n \r\n ":"\r\n 给定绑定前面的查询操作员的结果，源，绑定以下不同的操作员。\r\n \r\n     {前面的查询操作员}不同\r\n \r\n 例如：从aa中的A中==> aa.distinct（）\r\n \r\n \r\n","Containing property declaration.":"包含财产声明。\r\n","The declared or inferred local symbol.":"声明或推断的本地符号。\r\n","\r\n Adjusts receiver of a call or a member access if it is a value\r\n  * will turn Unknown property access into Get property access\r\n ":"\r\n 如果是值，请调整呼叫的接收器或会员访问\r\n  *将未知的属性访问转为获取属性访问\r\n \r\n","\r\n Contains the code for determining VB accessibility rules.\r\n ":"\r\n 包含用于确定VB可访问性规则的代码。\r\n \r\n","Rule about whether the enter key is passed through to the editor after the selected item has been committed.":"在进行选定项目后，有关Enter密钥是否传递给编辑器的规则。\r\n","\r\n Frees a temp without identity.\r\n ":"\r\n 释放一个没有身份的温度。\r\n \r\n","\r\n Statement that declares a property. If this property has accessors declared,\r\n this statement will be the Begin of a BlockNode, and the accessors will be the\r\n Body of that node. Auto properties are property declarations without a\r\n PropertyBlock.\r\n ":"\r\n 宣布财产的声明。如果该属性已声明，\r\n 该语句将是blockNode的开始，登录器将是\r\n 该节点的主体。自动属性是没有一个的属性声明\r\n PropertyBlock。\r\n \r\n","\r\n SyntaxTree of MyTemplate for the compilation. Settable for testing purposes only.\r\n ":"\r\n 汇编的myTemplate的语法。仅用于测试目的。\r\n \r\n","\r\n            Given the body of a local or an anonymous function (lambda or delegate), add the variables captured\r\n            by that local or anonymous function to the \"Captures\" group.\r\n            ":"\r\n            给定本地或匿名功能的正文（Lambda或委托），请添加捕获的变量\r\n            通过“捕获”组的本地或匿名函数。\r\n            \r\n","\r\n            Return all local diagnostics (syntax, semantic) that belong to given document for the given analyzer by calculating them.\r\n            ":"\r\n            通过计算给定分析仪给定文档的所有局部诊断（语法，语义）返回。\r\n            \r\n","<struct name>":"<结构名称>\r\n"," association with the deletion of a character from the document.\r\n            ":" 与文档中字符删除的关联。\r\n            \r\n","A zero-width positive lookbehind assertion, where for a match to be successful, 'subexpression' must occur at the input string to the left of the current position. 'subexpression' is not included in the match result. A zero-width positive lookbehind assert ...":"零宽度的正偏见主张，要成功，必须在当前位置左侧的输入字符串处出现“子表达”。比赛结果中未包含“亚表达”。零宽度的正面掩护...\r\n","symbol, currency":"符号，货币\r\n","Modifying source file '{0}' requires restarting the application due to internal error: {1}":"修改源文件'{0}'需要由于内部错误而重新启动应用程序：{1}\r\n","The type of array.":"数组的类型。\r\n","Use expression body for constructors":"将表达式用于构造函数\r\n","\r\n A walker that computes the set of local variables of an iterator \r\n method that must be moved to fields of the generated class.\r\n ":"\r\n 计算迭代器的局部变量集的步行者\r\n 必须移动到生成类的字段的方法。\r\n \r\n","\r\n True if StandardModuleAttribute was used in the current compilation\r\n ":"\r\n 如果在当前汇编中使用了标准模块化图\r\n \r\n","\r\n            The document to update.\r\n            ":"\r\n            要更新的文档。\r\n            \r\n","\r\n Given a enum declaration, get the corresponding type symbol.\r\n ":"\r\n 给定枚举声明，获取相应的类型符号。\r\n \r\n","\r\n Gets the parameters of this method. If this method has no parameters, returns\r\n an empty list.\r\n ":"\r\n 获取此方法的参数。如果此方法没有参数，请返回\r\n 一个空列表。\r\n \r\n","\r\n The value for the LessThanPercentEqualsToken property.\r\n ":"\r\n Limesthanpercentequalstoken属性的价值。\r\n \r\n","\r\n  Looks up a localized string similar to 'Declare' statements in a Module cannot be declared '{0}'..\r\n":"\r\n  查找类似于模块中“声明”语句的本地化字符串，无法声明“ {0}”。\r\n\r\n"," is committed.\r\n            ":" 承诺。\r\n            \r\n","Pattern matching preferences":"图案匹配的首选项\r\n"," \r\n Manages symbols from automatically embedded syntax trees. \r\n ":" \r\n 通过自动嵌入语法树管理符号。\r\n \r\n","\r\nFigure out the set of best candidates in the following preference order:\r\n  1) Applicable\r\n  2) TypeInferenceFailed\r\n  3) ArgumentMismatch, GenericConstraintsViolated\r\n  4) ArgumentCountMismatch\r\n  5) BadGenericArity\r\n  6) Ambiguous\r\n  7) HasUseSiteError\r\n  8) HasUnsupportedMetadata\r\n \r\n Also return the set of unique symbols behind the set.\r\n \r\n Returns type symbol for the common type, if any.\r\n Otherwise returns ErrorTypeSymbol.UnknownResultType.\r\n ":"\r\n根据以下偏好顺序弄清楚最佳候选人集：\r\n  1）适用\r\n  2）typeInferencefailed\r\n  3）grignmismatch，genericconstraintsviolated\r\n  4）参数countmismatch\r\n  5）BadGenericarity\r\n  6）模棱两可\r\n  7）HasuseSiteError\r\n  8）hasunsupportedmetadata\r\n \r\n 还返回集合背后的唯一符号集。\r\n \r\n 返回常见类型的类型符号（如果有）。\r\n 否则返回errortypesymbol.inknownResultType。\r\n \r\n","The condition used in the if statement around the dispose call":"围绕dispose调用的if语句中使用的条件\r\n","\r\n The value for the GoToKeyword property.\r\n ":"\r\n Gotokeyword属性的值。\r\n \r\n",", next entry's ":"，下一个条目\r\n","\r\n Returns a copy of this with the SelectKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中selectekeword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Represents a compiler \"MyGroupCollection\" property accessor.\r\n ":"\r\n 代表编译器“ myGroupCollection”属性登录器。\r\n \r\n","\r\n Returns a copy of this with the CatchKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而CatchKeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Look up the given metadata type, if it is forwarded.\r\n ":"\r\n 如果转发，请查找给定的元数据类型。\r\n \r\n","\r\n The type to get the Type object for. This can be an open generic type.\r\n ":"\r\n 获取类型对象的类型。这可以是开放的通用类型。\r\n \r\n","\r\n            Reports given set of project or solution level diagnostics. \r\n            ":"\r\n            报告给定的项目或解决方案级别诊断。\r\n            \r\n","\r\n            Edits made in the document, or null if the document is unchanged, has syntax errors or rude edits.\r\n            ":"\r\n            文档中进行的编辑，如果文档不变，则具有语法错误或粗鲁的编辑。\r\n            \r\n","\r\n Returns a copy of this with the TypeOfKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 将其返回此副本，其中typeofkeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Avoid legacy format target '{0}' in 'SuppressMessageAttribute'":"避免在“ pussressmessageattribute”中避免遗产格式'{0}'\r\n","How this item should be selected if no text has been typed after the completion list is brought up.":"如果在完成完成列表后未键入文本，则应如何选择此项目。\r\n","\r\n Represents a block member declaration: A declaration that has a beginning\r\n declaration, a body of executable statements and an end statement. Examples\r\n include methods, constructors, operators, property accessors and custom event\r\n accessors.\r\n ":"\r\n 代表块成员声明：具有开始的声明\r\n 声明，可执行语句的主体和结束陈述。例子\r\n 包括方法，构造函数，操作员，物业访问者和自定义事件\r\n 登录器。\r\n \r\n","\r\n            Returns an ancestor that encompasses all active and statement level \r\n            nodes that belong to the member represented by ":"返回一个祖先，该祖先包括所有活动和语句级别\r\n            属于成员代表的节点\r\n","\r\n            Get the active span that corresponds to specified node (or its part).\r\n            ":"\r\n            获取与指定节点（或其零件）相对应的活动跨度。\r\n            \r\n","\r\n If lookup failed for a qualified name, we don't know which part of the lookup failed.  Therefore, we have\r\n to check for a type forwarder for each prefix of the name.\r\n ":"\r\n 如果查找失败的合格名称，我们不知道查找的哪一部分失败了。因此，我们有\r\n 检查名称的每个前缀的类型转发器。\r\n \r\n","The \"HH\" custom format specifier (plus any number of additional \"H\" specifiers) represents the hour as a number from 00 through 23; that is, the hour is represented by a zero-based 24-hour clock that counts the hours since midnight. A single-digit hour is  ...":"“ HH”自定义格式指定符（加上任何数量的其他“ H”指定符）表示该小时为00至23的数字；也就是说，小时以零基于24小时的时钟为代表，该时钟算在午夜以来的时间。一个数字的小时是...\r\n","\r\n  Looks up a localized string similar to Implementing class '{0}' for interface '{1}' is not accessible in this context because it is '{2}'..\r\n":"\r\n  在此上下文中查找类似于接口'{1}'类的本地化字符串，因为它是'{2}'..\r\n\r\n","\r\n            Allows the solution crawler to start evaluating work enqueued to it. \r\n            Returns an IDisposable that the caller must dispose of to indicate that it no longer needs the crawler to continue evaluating. \r\n            Multiple callers can call into this simultaneously. \r\n            Only when the last one actually disposes the scope-object will the crawler \r\n            actually revert back to the paused state where no work proceeds.\r\n            ":"\r\n            允许解决方案搜寻器开始评估所起的作品。\r\n            返回呼叫者必须处置的IDisposable，以表明它不再需要搜寻器继续进行评估。\r\n            多个呼叫者可以同时致电。\r\n            只有当最后一个实际处理示波器对象时，爬网才\r\n            实际上恢复了没有工作的暂停状态。\r\n            \r\n","\r\n            The caret location in the new text created by applying all ":"\r\n            通过应用全部创建的新文本中的看台位置\r\n","\r\n            Descriptive tags from ":"\r\n            来自描述性标签\r\n","\r\n            Assembly identity. Only non-null if ":"\r\n            组装身份。仅如果非效果\r\n"," when requesting a new argument value.\r\n            ":" 当请求新的参数值时。\r\n            \r\n","\r\n The statements contained in the With...End With block. This might be an empty\r\n list.\r\n ":"\r\n with ... end with block中包含的语句。这可能是空的\r\n 列表。\r\n \r\n"," \r\n Checks if the method has an entry point compatible signature, i.e. \r\n - the return type is either void or int \r\n - has either no parameter or a single parameter of type string[] \r\n ":" \r\n 检查该方法是否具有入口点兼容签名，即\r\n  - 返回类型是无效的，要么是int\r\n  - 没有类型字符串的参数或单个参数[]\r\n \r\n","\r\n The value for the WhileStatement property.\r\n ":"\r\n 义务属性的值。\r\n \r\n","\r\n The key values being used for grouping.\r\n ":"\r\n 用于分组的钥匙值。\r\n \r\n","Split into nested '{0}' statements":"分成嵌套的'{0}'语句\r\n"," A set of namespace or type symbols with given qualified name (might comprise of types with multiple generic arities),  \r\n or an empty set if the member can't be found (the qualified name is ambiguous or the symbol doesn't exist). \r\n ":" 一组具有给定合格名称的名称空间或类型符号（可能包括具有多个通用障碍的类型），\r\n 如果找不到成员，则为空集（合格的名称是模棱两可或不存在符号的）。\r\n \r\n","\r\n The optional name and type of the expression range variable. If omitted, the\r\n name of the expression range variable is inferred from the aggregation\r\n expression.\r\n ":"\r\n 表达范围变量的可选名称和类型。如果省略了\r\n 表达范围变量的名称是从聚合推断的\r\n 表达。\r\n \r\n","\r\n Returns an expression that can be used instead of the original one when\r\n we want to run the expression for side-effects only (i.e. we intend to ignore result).\r\n ":"\r\n 返回一个表达式，该表达式可以在以下情况下使用，而不是原始表达式\r\n 我们只想运行副作用的表达式（即我们打算忽略结果）。\r\n \r\n","\r\n Get the special local symbol with the same name as the enclosing function.\r\n ":"\r\n 获取具有与封闭功能相同名称的特殊本地符号。\r\n \r\n","\r\n Map syntax kind of a modifier keyword to SourceMemberFlags value\r\n ":"\r\n 映射语法是一种修饰符关键字，用于sourcememblags value\r\n \r\n","\r\n The \"GoTo\" keyword\r\n ":"\r\n “ goto”关键字\r\n \r\n","\r\n Helper method for accessors to get the overridden accessor methods. Should only be called by the\r\n accessor method symbols.\r\n ":"\r\n 辅助方法获取覆盖登录器方法的帮助方法。只能由\r\n 登录方法符号。\r\n \r\n","\r\n  Looks up a localized string similar to Error embedding Win32 manifest: Option /win32manifest conflicts with /nowin32manifest..\r\n":"\r\n  查找类似于错误嵌入Win32清单的局部字符串：option /win32 manifest与 /nowin32manifest的冲突..\r\n\r\n","\r\n Copy constructor has one parameter of the same type as the enclosing type.\r\n The purpose is to copy all the lifted values from previous version of the \r\n frame if there was any into the new one.\r\n ":"\r\n 复制构造器具有与封闭类型相同类型的一个参数。\r\n 目的是复制从先前版本的所有提升值\r\n 框架是否有新的框架。\r\n \r\n","\r\n A program location in MyTemplate code.\r\n ":"\r\n MyTemplate代码中的程序位置。\r\n \r\n","\r\n            Determines if any embedded statement of an ":"\r\n            确定是否有任何嵌入式陈述\r\n","\r\n preprocessor state before _currentNode\r\n ":"\r\n _currentNode之前的预处理器状态\r\n \r\n","\r\n            Adds user defined and predefined conversions to the unnamed recommendation set.\r\n            ":"\r\n            将用户定义和预定义的转换添加到未命名的建议集中。\r\n            \r\n"," \r\n Gets the associated ":"获取关联\r\n","The default accessibility. ":"默认可访问性。\r\n","\r\n One of the type parameter constraints clauses. This represents a constraint\r\n clause in the form of \"As Constraint\".\r\n ":"\r\n 类型参数约束条款之一。这代表一个约束\r\n 条款以“约束”的形式。\r\n \r\n","\r\n Information for ComClass specific analysis and metadata generation, created\r\n once ComClassAttribute is encountered.\r\n ":"\r\n comclass特定分析和元数据生成的信息，创建\r\n 一旦遇到Comclassattribute。\r\n \r\n"," for a specific project\r\n             match a specified predicate.\r\n             ":" 对于特定项目\r\n             匹配指定的谓词。\r\n             \r\n","\r\n This method only checks accessibility from the point of view of the accessibility\r\n modifiers on symbol and its containing types. Even if true is returned, the given symbol\r\n may not be able to be referenced for other reasons, such as name hiding.\r\n ":"\r\n 此方法仅从可访问性的角度检查可访问性\r\n 符号及其包含类型的修饰符。即使返回true，给定的符号\r\n 由于其他原因，例如隐藏名称，可能无法引用。\r\n \r\n","\r\n Essentially this is a wrapper around another AssemblySymbol that is responsible for retargeting\r\n symbols from one assembly to another. It can retarget symbols for multiple assemblies at the same time. \r\n \r\n For example, compilation C1 references v1 of Lib.dll and compilation C2 references C1 and v2 of Lib.dll. \r\n In this case, in context of C2, all types from v1 of Lib.dll leaking through C1 (through method \r\n signatures, etc.) must be retargeted to the types from v2 of Lib.dll. This is what \r\n RetargetingAssemblySymbol is responsible for. In the example above, modules in C2 do not \r\n reference C1.m_AssemblySymbol, but reference a special RetargetingAssemblySymbol created for \r\n C1 by ReferenceManager.\r\n \r\n Here is how retargeting is implemented in general:\r\n - Symbols from underlying assembly are substituted with retargeting symbols.\r\n - Symbols from referenced assemblies that can be reused as is (i.e. doesn't have to be retargeted) are\r\n   used as is.\r\n - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.\r\n ":"\r\n 本质上，这是另一个围绕另一个负责重新定位的包装器\r\n 从一个组件到另一个组件的符号。它可以同时重新定位多个组件。\r\n \r\n 例如，lib.dll的c1参考v1和汇编C2参考c1和v2的lib.dll的v2。\r\n 在这种情况下，在C2的背景下，Lib.dll的V1的所有类型都通过C1泄漏（通过方法\r\n 签名等。这是什么\r\n retargetingAssemblysymbol负责。在上面的示例中，C2中的模块不\r\n 参考C1.M_ASSEMBLYSYMBOL，但请参考为创建的特殊retargetingAssemblysymbol\r\n C1由ReferenceManager。\r\n \r\n 这是如何实施重新定位的方式：\r\n  - 基础组件的符号用重新定位符号代替。\r\n  - 可以按原样重复使用的参考组件的符号（即不必重新定位）是\r\n   按原样使用。\r\n  - 必须重新定位的参考组件中的符号被重新定位的结果代替。\r\n \r\n","\r\n Was this local variable implicitly declared, because Option Explicit Off\r\n was in effect, and no other symbol was found with this name.\r\n ":"\r\n 该局部变量是否被隐式声明，因为选项明确关闭\r\n 有效，没有其他符号。\r\n \r\n","\r\n The provider of the event. It is a property of a WithEvents member of the\r\n containing type.\r\n ":"\r\n 活动的提供者。它是伴随事件成员的财产\r\n 包含类型。\r\n \r\n","\r\n            Class responsible for actually computing the entire set of code actions to offer the\r\n            user.  Contains lots of helper functionality used by all the different Wrapper\r\n            implementations.\r\n            \r\n            Specifically subclasses of this type can simply provide a list of code-actions to\r\n            perform.  This type will then take those code actions and will ensure there aren't\r\n            multiple code actions that end up having the same effect on the document.  For example,\r\n            a \"wrap all\" action may produce the same results as a \"wrap long\" action.  In that case\r\n            this type will only keep around the first of those actions to prevent showing the user\r\n            something that will be unclear.\r\n            ":"\r\n            负责实际计算整个代码操作的课程以提供\r\n            用户。包含所有不同包装器使用的大量辅助功能\r\n            实施。\r\n            \r\n            这种类型的特殊子类可以简单地提供代码攻击列表\r\n            履行。然后，这种类型将采取这些代码操作，并确保没有\r\n            最终对文档产生相同效果的多个代码操作。例如，\r\n            “包裹所有”动作可能会产生与“包裹长”动作相同的结果。在这种情况下\r\n            这种类型只会保留第一个动作，以防止向用户展示\r\n            这将不清楚。\r\n            \r\n","\r\n Returns a copy of this with the SubKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，并将子关键属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n The value for the Variables property.\r\n ":"\r\n 变量属性的值。\r\n \r\n"," for live diagnostic\r\n            ":" 用于实时诊断\r\n            \r\n","\r\n Location of an attribute if an explicit location is not specified via attribute target specification syntax.\r\n ":"\r\n 属性的位置如果未通过属性目标规范语法指定显式位置。\r\n \r\n","\r\n Given result of binding preceding query operators, the source, bind the following Let operator.\r\n \r\n     {Preceding query operators} Let {expression range variables}\r\n \r\n Ex: From a In AA Let b  ==> AA.Select(Function(a) New With {a, b})\r\n \r\n Ex: From a In AA Let b, c  ==> AA.Select(Function(a) New With {a, b}).Select(Function({a, b}) New With {a, b, c})\r\n \r\n Note, that preceding Select operator can introduce unnamed range variable, which is dropped by the Let\r\n \r\n Ex: From a In AA Select a + 1 Let b ==> AA.Select(Function(a) a + 1).Select(Function(unnamed) b)  \r\n \r\n Also, depending on the amount of expression range variables declared by the Let, and the following query operators,\r\n translation can produce a nested, as opposed to flat, compound variable.\r\n \r\n Ex: From a In AA Let b, c, d ==> AA.Select(Function(a) New With {a, b}).\r\n                                     Select(Function({a, b}) New With {{a, b}, c}).\r\n                                     Select(Function({{a, b}, c}) New With {a, b, c, d})   \r\n ":"\r\n 给定绑定前面的查询操作员的结果，源，绑定以下让运算符。\r\n \r\n     {前面的查询运算符}让{表达式范围变量}\r\n \r\n 例如：从A中的A中，LET B ==> aa.Select（function（a）with {a，b}）\r\n \r\n ex：从A中的A中，Let b，C ==> aa.Select（function（a）with {a，b}）。select（function（{a，b}）new with {a，b，c}）\r\n \r\n 请注意，先前的选择操作员可以引入未命名的范围变量，该变量由LET删除\r\n \r\n 例如：在AA中选择A + 1中，让B ==> aa.Select（function（a）a + 1）.select（function（named）b）\r\n \r\n 同样，取决于LET和以下查询操作员声明的表达范围变量的数量，\r\n 翻译可以产生嵌套，而不是平坦的复合变量。\r\n \r\n 例如：从aa中的A中，让B，C，d ==> aa.Select（function（a）with {a，b}）。\r\n                                     选择（{{a，b}）使用{{a，b}，c}）。\r\n                                     select（函数（{{a，b}，c}）with {a，b，c，d}）\r\n \r\n","\r\n Returns a copy of this with the DoKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中dokeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Incomplete \\p{X} character escape":"不完整\\ p {x}字符逃脱\r\n","\r\n  Looks up a localized string similar to Event '{0}' specified by the 'DefaultEvent' attribute is not a publicly accessible event for this class..\r\n":"\r\n  查找类似于事件“ {0}”的本地化字符串，由“ defaultevent”属性指定的属性不是此类的公开访问事件。\r\n\r\n","\r\n The \"<\" token.\r\n ":"\r\n “ <”令牌。\r\n \r\n","\r\n Represents an \"ElseIf ... Then ...\" block.\r\n ":"\r\n 代表一个“ elseif ...然后……”块。\r\n \r\n","\r\n            Signature Help was triggered through the 'Invoke Signature Help' command\r\n            ":"\r\n            签名帮助是通过“ Invoke签名帮助”命令触发的\r\n            \r\n","\r\n The value for the ToValue property.\r\n ":"\r\n Tovalue属性的值。\r\n \r\n","\r\n Validate method type parameter constraints. This is handled outside\r\n of ValidateImplementedMember because that method is invoked\r\n while computing the ExplicitInterfaceImplementations value on the\r\n implementing method, but method type parameters rely on the value\r\n of ExplicitInterfaceImplementations to determine constraints correctly.\r\n ":"\r\n 验证方法类型参数约束。这是在外面处理的\r\n 由于调用该方法的验证图\r\n 在计算equarlicitInterfaceImplementations的同时值\r\n 实现方法，但是方法类型参数依赖于值\r\n explicitInterfaceImplementations以正确确定约束。\r\n \r\n","\r\n            Try to get the node that can be used to trigger the refactoring based on current cursor position. \r\n            ":"\r\n            尝试获取可用于根据当前光标位置触发重构的节点。\r\n            \r\n","\r\n  Looks up a localized string similar to 'In' expected..\r\n":"\r\n  查找类似于“预期”的本地化字符串。\r\n\r\n","Generate constructor...":"生成构造函数...\r\n","\r\n            Mapping from a method like ":"\r\n            从类似的方法映射\r\n","\r\n Checks if all special and well-known symbols required for emitting anonymous types \r\n provided exist, if not reports errors and returns True.\r\n ":"\r\n 检查发射匿名类型是否需要所有特殊和知名符号\r\n 提供的存在，如果不报告错误并返回为true。\r\n \r\n","\r\n If present, the keyword that defines the string translation semantics of the\r\n external method.\r\n ":"\r\n 如果存在，则定义字符串翻译语义的关键字\r\n 外部方法。\r\n \r\n"," is accessed off of, if any.\r\n This is needed to properly check accessibility of protected members.\r\n ":" 如果有的话，可以访问。\r\n 需要正确检查受保护成员的可访问性。\r\n \r\n",",\r\n ":"，，，，\r\n \r\n","\r\n A helper method for ReferenceManager to set assembly identities for assemblies\r\n referenced by this module and corresponding AssemblySymbols.\r\n ":"\r\n 引用meanager的辅助方法，以设置汇编的汇编身份\r\n 由该模块和相应的汇编符号引用。\r\n \r\n","\r\n            A rule about whether the enter key is passed through to the editor after the selected item has been committed.\r\n            ":"\r\n            在提交选定项目后，有关Enter密钥是否传递给编辑器的规则。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Extension' attribute can be applied only to 'Module', 'Sub', or 'Function' declarations..\r\n":"\r\n  查找类似于“扩展”属性的本地化字符串只能应用于“模块”，“ sub”或“ function”声明。\r\n\r\n","\r\n            Host interface abstracting over all the external functionality the ":"\r\n            主机接口在所有外部功能上抽象\r\n","tab character":"标签字符\r\n","\r\n  Looks up a localized string similar to Expected one of 'Dim', 'Const', 'Public', 'Private', 'Protected', 'Friend', 'Shadows', 'ReadOnly' or 'Shared'..\r\n":"\r\n  查找类似于预期的“昏暗”，“ const”，“ public”，“ private”，“ protect”，“ friend”，“ shadows”，“ readonly”或“ readonly”或“ shared'的”的局部字符串。\r\n\r\n","The rule that controls snippets behavior.":"控制摘要行为的规则。\r\n"," snapshot and the one given to the previous successful call \r\n            where ":" 快照和先前成功的电话\r\n            在哪里\r\n","P2":"P2\r\n","\r\n Should the name returned by Name property be mangled with [`arity] suffix in order to get metadata name.\r\n Must return False for a type with Arity == 0.\r\n ":"\r\n 是否应将属性返回的名称与[Arity]后缀混合在一起，以获取元数据名称。\r\n 必须返回false fors a arity == 0的类型。\r\n \r\n"," representing the specific kind of DoStatementSyntax.\r\n One of SimpleDoStatement, DoWhileStatement, DoUntilStatement.\r\n ":" 代表特定类型的dostatementsyntax。\r\n 简单的术语之一，Dowhilestatement，DountilStatement。\r\n \r\n","\r\n Is this ByRef parameter.\r\n ":"\r\n 这是BYREF参数。\r\n \r\n","\r\n Returns true if this type does not allow derived types; i.e., declared\r\n with the NotInheritable modifier, or else declared as a Module, Structure,\r\n Enum, or Delegate.\r\n ":"\r\n 如果此类型不允许派生类型，则返回true；即，宣布\r\n 使用不可定制的修饰符，或称为模块，结构，\r\n 枚举或委托。\r\n \r\n","\r\n  Looks up a localized string similar to Relational operator expected..\r\n":"\r\n  查找类似于关系操作员预期的本地化字符串。\r\n\r\n","\r\n Returns a copy of this with the Token1 property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"返回此副本，Token1属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n If present, an initializer with the default value of the parameter. If no\r\n default value is present, Nothing is returned.\r\n ":"\r\n 如果存在，则具有参数默认值的初始器。如果不\r\n 存在默认值，什么也没有返回。\r\n \r\n","\r\n            Get current diagnostics stored in IDiagnosticUpdateSource.\r\n            ":"\r\n            获取当前存储在IDINGNOSTICUPDATESOURCE中的诊断。\r\n            \r\n","Conflict(s) detected.":"检测到的冲突。\r\n","\r\n Scan punctuation in an interpolated string.\r\n ":"\r\n 在插值字符串中扫描标点符号。\r\n \r\n","Compilation has errors.":"汇编有错误。\r\n","'{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement a non-public member in C# {3}. Please use language version '{4}' or greater.":"'{0}'不实现接口成员'{1}'。 '{2}'无法在C {3}中隐式实现非公共成员。请使用语言版本'{4}或更大。\r\n"," of the symbol.\r\n ":" 符号。\r\n \r\n","\r\n Get all the members of this symbol that are types that have a particular name, and any arity.\r\n ":"\r\n 获取具有特定名称和任何arity的类型的所有成员。\r\n \r\n","\r\n Returns a copy of this with the SubOrFunctionHeader property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中subfunctionheader属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Returns a copy of this with the JoinConditions property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中Joinconditions属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Rewrite a bound lambda into a bound node that will create the corresponding expression tree at run time.\r\n ":"\r\n 将绑定的lambda重写为一个结合节点，该节点将在运行时创建相应的表达树。\r\n \r\n","\r\n  Looks up a localized string similar to Methods in a Module cannot be declared '{0}'..\r\n":"\r\n  查找类似于模块中方法的本地化字符串，无法声明“ {0}”。\r\n\r\n","Create and assign field '{0}'":"创建并分配字段'{0}'\r\n","\r\n  Looks up a localized string similar to Type parameters, generic types or types contained in generic types cannot be used as attributes..\r\n":"\r\n  查找类似于类型参数的本地化字符串，通用类型中包含的通用类型或类型不能用作属性。\r\n\r\n","\r\n Represents the clause of an Imports statement that imports all members of a\r\n type or namespace or aliases a type or namespace.\r\n ":"\r\n 代表导入语句的条款，该条款导入了\r\n 类型或名称空间或别名类型或名称空间。\r\n \r\n","\r\n  Looks up a localized string similar to Assembly and module '{0}' cannot target different processors..\r\n":"\r\n  查找类似于汇编和模块'{0}'的本地化字符串不能瞄准不同的处理器。\r\n\r\n","\r\n Add a diagnostic to the bag.\r\n ":"在袋子中添加诊断。\r\n \r\n","\r\n Get the shared constructors for this type.\r\n ":"\r\n 获取此类型的共享构造函数。\r\n \r\n","\r\n The expression on the left-hand-side of the \"?\".\r\n ":"\r\n “？”左侧的表达式。\r\n \r\n","\r\n Represents an occurrence of a Visual Basic built-in type such as Integer or\r\n String in source code.\r\n ":"\r\n 代表视觉基本内置类型的发生，例如整数或\r\n 源代码中的字符串。\r\n \r\n"," has changed\r\n            and what ":" 已经改变\r\n            还有什么\r\n","\r\n Compute the implementation for an interface member in this type, or Nothing if none.\r\n ":"\r\n 计算此类型中接口成员的实现，或者没有任何内容。\r\n \r\n"," The parameters of function":" 功能的参数\r\n","\r\n Gets the current command line parser.\r\n ":"\r\n 获取当前的命令行解析器。\r\n \r\n","s or/and ":"s或/和\r\n","\r\n The \"Loop\" keyword.\r\n ":"\r\n “循环”关键字。\r\n \r\n","\r\n The type-name part of the As clause.\r\n ":"\r\n AS子句的类型名称部分。\r\n \r\n"," adds synthesized explicit implementations to the list of synthesized definitions. \r\n In lieu of running ":" 将合成的显式实现添加到合成定义列表中。\r\n 代替跑步\r\n","\r\n            Comparer that considers to navigate to results the same if they will navigate to the same document and span.\r\n            This ensures that we don't see tons of results for the same symbol when a file is linked into many projects.\r\n            ":"\r\n            如果它们会导航到同一文档和跨度，则考虑导航到结果相同的比较。\r\n            这样可以确保当文件链接到许多项目时，我们不会看到相同符号的大量结果。\r\n            \r\n"," contains the value":" 包含值\r\n","\r\n Provides lookup in types of imported namespaces, either at file level or project level.\r\n ":"\r\n 在文件级别或项目级别上提供导入命名空间类型的查找。\r\n \r\n","\r\n Same as IntoClauseBinder, but disallows references to GroupAggregationSyntax.\r\n ":"\r\n 与intoclausebinder相同，但不允许引用groupAggregationsyntax。\r\n \r\n"," or \r\n    ":" 或者\r\n    \r\n","\r\n            false, if implicit typing cannot be used.\r\n            true, otherwise.\r\n            ":"\r\n            错误，如果无法使用隐式键入。\r\n            是的，否则。\r\n            \r\n","\r\n Gets a value indicating whether this instance has declared type. This means not an inferred type.\r\n ":"\r\n 获取一个指示此实例是否已声明类型的值。这意味着不是推断的类型。\r\n \r\n","\r\n Represents the results of overload resolution for a single method.\r\n ":"\r\n 表示单个方法的过载分辨率的结果。\r\n \r\n","\r\n Resolves the target method for the delegate and classifies the conversion\r\n ":"\r\n 解决委托的目标方法并分类转换\r\n \r\n","\r\n The value for the EventContainer property.\r\n ":"\r\n EventContainer属性的值。\r\n \r\n"," \r\n Represents implicit, script and submission classes. \r\n ":" \r\n 代表隐式，脚本和提交类。\r\n \r\n","\r\n Symbol for the type or Nothing if type cannot be found or ambiguous. \r\n ":"\r\n 如果找不到类型或模棱两可的符号，则没有类型的符号。\r\n \r\n","\r\n            This cannot be merged with ":"\r\n            这不能合并\r\n","Create and assign property '{0}'":"创建并分配属性'{0}'\r\n"," is important for serialization compatibility in\r\n             ":" 对于序列化兼容性很重要\r\n             \r\n","\r\n            The document and navigation span this item should navigate to when the definition is not in the\r\n            originating document. This is used for partial symbols where a child symbol is declared in another file,\r\n            but should still be shown in the UI when in a part in a different file.\r\n            ":"\r\n            文档和导航跨度该项目应导航到定义不在\r\n            原始文件。这用于部分符号，在另一个文件中声明子符号，\r\n            但是，当在另一个文件中的零件中，仍应在UI中显示。\r\n            \r\n","Option controlling if pull diagnostics are allowed for the client.  The ":"选项控制如果允许对客户端进行拉诊断。这\r\n","\r\n Only bits specific to delegate relaxation level are returned.\r\n ":"\r\n 仅返回特定于委托放松水平的位。\r\n \r\n"," The argument list that contains the target argument to be cast ":" 包含要施放的目标参数的参数列表\r\n","\r\n            Unmapped span of the active statement\r\n            (span within the file that contains #line directive that has an effect on the active statement, if there is any).\r\n            ":"\r\n            活动语句的未映射跨度\r\n            （在文件中包含#line指令的跨度，该指令会影响活动语句（如果有））。\r\n            \r\n"," for navigating to a specific position in a document.\r\n            When ":" 用于导航到文档中的特定位置。\r\n            什么时候\r\n","\r\n Returns amount of applicable candidates left.\r\n ":"\r\n 退货剩余的适用候选人金额。\r\n \r\n","positive character group":"积极的角色群\r\n","Property cannot safely be replaced with a method call":"属性无法安全地替换为方法调用\r\n","\r\n For testing purposes only.\r\n ":"\r\n 仅用于测试目的。\r\n \r\n","Convert to interpolated string":"转换为插值字符串\r\n","\r\n The \"Next\" keyword.\r\n ":"\r\n “下一个”关键字。\r\n \r\n","\r\n  Looks up a localized string similar to Constants must have a value..\r\n":"\r\n  查找类似于常数的本地化字符串必须具有值。\r\n\r\n","\r\n  Looks up a localized string similar to Nullable modifier cannot be specified in variable declarations with 'As New'..\r\n":"\r\n  查找类似于无效修饰符的本地化字符串，在“ as new”的变量声明中无法指定。\r\n\r\n","\r\n The \"Into\" keyword.\r\n ":"\r\n “ in in in in to”关键字。\r\n \r\n","\r\n Placeholder for the collection; used only when the collection's type \r\n is not an one dimensional array or string.\r\n ":"\r\n 收藏的占位符；仅在集合的类型时使用\r\n 不是一个维数组或字符串。\r\n \r\n",".\r\n            \r\n             Exception regions for each EH block/clause are marked as |...|.\r\n               try { ... AS ... } |catch { } finally { }|\r\n               try { } |catch { ... AS ... }| finally { }\r\n               try { } catch { } |finally { ... AS ... }|\r\n             \r\n             Contains a minimal set of spans that cover the handlers.\r\n             For example:\r\n               try { } |finally { try { ... AS ... } catch {  } }|\r\n               try { } |finally { try { } catch { ... AS ... } }|\r\n               try { try { } |finally { ... AS ... }| } |catch { } catch { } finally { }|\r\n             ":"。\r\n            \r\n             每个EH块/子句的异常区域都标记为| ... |。\r\n               尝试{... as ...} |捕获{}最后{} |\r\n               尝试{} |捕获{... as ...} |最后 { }\r\n               尝试{}捕获{} |最后{... as ...} |\r\n             \r\n             包含一组覆盖处理程序的跨度最小的跨度。\r\n             例如：\r\n               尝试{} |最后{尝试{... as ...} catch {}} |\r\n               尝试{} |最后{尝试{}抓住{... as ...}} |\r\n               尝试{尝试{} |最后{... as ...} | } |捕获{}捕获{}最后{} |\r\n             \r\n"," overloads for use from other IDE features.\r\n            ":" 超载供其他IDE功能使用。\r\n            \r\n","\r\n Creates a symbol for a synthesized lambda method\r\n ":"\r\n 为合成的lambda方法创建一个符号\r\n \r\n","An instance of analyzer {0} cannot be created from {1}: {2}.":"无法从{1}：{2}创建分析仪的实例{0}。\r\n","\r\n            When present, holds onto last data we broadcasted to outer world.\r\n            ":"\r\n            在场时，请保留我们广播到外界的最后数据。\r\n            \r\n","\r\n Returns a copy of this with the YieldKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"将其返回此副本，而faredkeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            cannot convert from 'int' to 'string'\r\n            ":"\r\n            无法从“ int”转换为“字符串”\r\n            \r\n"," \r\n Marks a control resume point for emitted await operator; is processed by codegen; \r\n only allowed inside MoveNext methods generated for Async methods\r\n ":" \r\n 标志着正在等待运营商发射的控制简历点；由Codegen处理；\r\n 仅在为异步方法生成的MoveNEXT方法中允许\r\n \r\n","\r\n Binder used to bind statements inside With blocks. \r\n ":"\r\n 粘合剂用于将语句与块绑定。\r\n \r\n","Consecutive braces must not have blank line between them":"连续的牙套之间不得有空白线\r\n","Node does not descend from root.":"节点不会从根中降下。\r\n","\r\n Since each language construct must be handled according to the rules of the language specification,\r\n the default visitor reports that the construct for the node is not implemented in the compiler.\r\n ":"由于必须根据语言规范的规则来处理每个语言构造，因此\r\n 默认访问者报告说，该节点的构造未在编译器中实现。\r\n \r\n","\r\n  Looks up a localized string similar to 'End Function' must be preceded by a matching 'Function'..\r\n":"\r\n  查找类似于“ End函数”的本地化字符串必须先于匹配的“函数”。\r\n\r\n","\r\n  Looks up a localized string similar to 'Implements' not valid in Modules..\r\n":"\r\n  查找类似于模块中无效的“实施”的本地化字符串。\r\n\r\n","\r\n The container of the event. It is a simple identifier that refers to a\r\n WithEvents member of the containing type.\r\n ":"\r\n 事件的容器。这是一个简单的标识符，指的是\r\n 符合包含类型的事件成员。\r\n \r\n","\r\n Describes a single variable of the form \"x [As Type] In expression\" for use in\r\n query expressions.\r\n ":"\r\n 描述形式的单个变量“ x [as type in Expression in Expression in Expression in Expression''\r\n 查询表达式。\r\n \r\n","range variable":"范围变量\r\n",".\r\n            This will either return already created ":"。\r\n            这要么将返回已经创建\r\n","\r\n Used only in the data flows out walker, we track unassignments as well as assignments\r\n ":"\r\n 我们仅在数据流出沃克中使用，我们跟踪非分配和作业\r\n \r\n"," if the text does not have a navigation target.":" 如果文本没有导航目标。\r\n"," representing the specific kind of XmlTextTokenSyntax.\r\n One of XmlTextLiteralToken, XmlEntityLiteralToken,\r\n DocumentationCommentLineBreakToken.\r\n ":" 代表特定类型的XmlTextTokenSyntax。\r\n XMLTEXTLITERALTOKEN之一，XmlentityLiteralToken，\r\n DocumentationCommentLine Breaktoken。\r\n \r\n","One or more changes result in a new type being created by the compiler, which requires restarting the application because it is not supported by the runtime":"一个或多个更改导致编译器创建的新类型，该编译器需要重新启动应用程序，因为它不受运行时的支持\r\n","\r\n Given result of binding preceding query operators, if any, bind the following From operator.\r\n \r\n     [{Preceding query operators}] From {collection range variables}\r\n \r\n Ex: From a In AA  ==> AA\r\n \r\n Ex: From a In AA, b in BB  ==> AA.SelectMany(Function(a) BB, Function(a, b) New With {a, b})\r\n \r\n Ex: {source with range variable 'd'} From a In AA, b in BB  ==> source.SelectMany(Function(d) AA, Function(d, a) New With {d, a}).\r\n                                                                        SelectMany(Function({d, a}) BB, \r\n                                                                                   Function({d, a}, b) New With {d, a, b})\r\n \r\n Note, that preceding Select operator can introduce unnamed range variable, which is dropped by the From\r\n \r\n Ex: From a In AA Select a + 1 From b in BB ==> AA.Select(Function(a) a + 1).\r\n                                                   SelectMany(Function(unnamed) BB,\r\n                                                              Function(unnamed, b) b)  \r\n \r\n Also, depending on the amount of collection range variables declared by the From, and the following query operators,\r\n translation can produce a nested, as opposed to flat, compound variable.\r\n \r\n Ex: From a In AA From b In BB, c In CC, d In DD ==> AA.SelectMany(Function(a) BB, Function(a, b) New With {a, b}).\r\n                                                        SelectMany(Function({a, b}) CC, Function({a, b}, c) New With {{a, b}, c}).\r\n                                                        SelectMany(Function({{a, b}, c}) DD, \r\n                                                                   Function({{a, b}, c}, d) New With {a, b, c, d})   \r\n \r\n If From operator translation results in a SelectMany call and the From is immediately followed by a Select or a Let operator, \r\n they are absorbed by the From translation. When this happens, operatorsEnumerator is advanced appropriately.\r\n \r\n Ex: From a In AA From b In BB Select a + b ==> AA.SelectMany(Function(a) BB, Function(a, b) a + b)\r\n \r\n Ex: From a In AA From b In BB Let c ==> AA.SelectMany(Function(a) BB, Function(a, b) new With {a, b, c})\r\n \r\n ":"\r\n 给定绑定前面的查询操作员的结果，如果有的话，将绑定以下从操作员绑定。\r\n \r\n     [{{先前的查询操作员}]来自{Collection Range变量}\r\n \r\n 例如：从aa ==> aa中\r\n \r\n 例如：从aa中的a，b in bb ==> aa.selectmany（function（a）bb，function（a，b）new with {a，b}）\r\n \r\n ex：{带有范围变量'd'}源的aa中的a，bb ==> source.SelectMany（function（d）aa，function（d，a）new with {d，a}））的范围变量'd'}。\r\n                                                                        SelectMany（函数（{d，a}）bb，\r\n                                                                                   函数（{d，a}，b）新的，{d，a，b}）\r\n \r\n 请注意，先前的选择操作员可以引入未命名的范围变量，该变量由From删除\r\n \r\n 例如：从A中的A中，从bb ==> aa.select（function（a）a + 1）中的B选择A + 1。\r\n                                                   selectany（函数（未命名）bb，\r\n                                                              功能（未命名，b）b）\r\n \r\n 同样，取决于来自from和以下查询运营商声明的收集范围变量的数量，\r\n 翻译可以产生嵌套，而不是平坦的复合变量。\r\n \r\n 例如：从bb in bb in a in a in bb，c in cc中，d ==> aa.selectmany（function（a）bb，function（a，b）with {a，b}）。\r\n                                                        selectMany（function（{a，b}）cc，function（{a，b}，c）新的，{{a，b}，c}）。\r\n                                                        selectMany（函数（{{a，b}，c}）dd，\r\n                                                                   函数（{{a，b}，c}，d）with {a，b，c，d}）\r\n \r\n 如果从运算符翻译中导致selectmany调用，并且紧随其后的是select或let oterator，\r\n 它们被翻译中的吸收。当发生这种情况时，操作员会适当提出。\r\n \r\n 例如：从a in a a a b in b in bb in bb选择a + b ==> aa.selectmany（function（a）bb，function（a，b）a + b）\r\n \r\n 例如：从bb in b in a in a in a a in bb in Let c ==> aa.selectmany（function（a）bb，function（a，b）with {a，b，c}）\r\n \r\n \r\n","The currently set core parse options.":"当前设置的核心解析选项。\r\n","\r\n The value for the ColonEqualsToken property.\r\n ":"\r\n Colonequalstoken物业的价值。\r\n \r\n","\r\n Returns a copy of this with the WhileKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中wherkeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Use 'new(...)'":"使用“新（...）”\r\n","\r\n            This also has the impact that a linked file (say from a shared project) will only show up for a single project\r\n            that it is linked into. This is believed to actually be desirable as showing multiple hits for effectively the\r\n            same symbol, just for different projects just feels like clutter in the UI without real benefit for the user\r\n            (since navigating will just take the user to the same location).\r\n            ":"\r\n            这也具有链接文件（例如共享项目）仅出现的单个项目的影响\r\n            它链接到。人们认为这实际上是可取的，因为有效地显示了多次命中\r\n            同样的符号，仅适用于不同项目，就像用户没有真正利益的UI中的混乱\r\n            （由于导航将仅将用户带到同一位置）。\r\n            \r\n","Ignore method's return type for the purpose of calculating 'methodConversions'.":"忽略方法的返回类型是为了计算“方法转换”的目的。\r\n","Convert to record":"转换为记录\r\n","\r\n            create operation status with the given data\r\n            ":"\r\n            使用给定数据创建操作状态\r\n            \r\n","covariant returns":"协变量回报\r\n","\r\n Represents a CType, DirectCast or TryCast conversion expression. The Kind\r\n property determines which kind of cast it is.\r\n ":"\r\n 代表CTYPE，Directcast或Trycast转换表达式。那种\r\n 属性确定它是哪种铸件。\r\n \r\n","\r\n The condition expression to be evaluated.\r\n ":"\r\n 要评估的条件表达式。\r\n \r\n","\r\n            Invalid type for parameter 'parameter number' in XML comment cref attribute\r\n            ":"\r\n            XML评论中的参数“参数编号”的无效类型CREF属性\r\n            \r\n","The error bag.":"错误袋。\r\n"," if this instance is overridable; otherwise, ":" 如果此实例太过填充；否则，\r\n","\r\n Returns true if this field was declared as \"const\" (i.e. is a constant declaration), or\r\n is an Enum member.\r\n ":"\r\n 如果该字段被声明为“ const”（即是恒定声明）或\r\n 是枚举成员。\r\n \r\n","\r\n            Invalid tag helper bound property '{1}' on tag helper '{0}'. '{2}.{3}' must be null unless property type implements '{4}'.\r\n            ":"\r\n            标签助手'{0}'上的无效标记助手绑定属性'{1}'。 '{2}。{3}'必须为null，除非属性类型实现{4}'。\r\n            \r\n","False if the region is invalid":"错误，如果该地区无效\r\n","\r\n Returns a copy of this with the AdditionalQueryOperators property changed to\r\n the specified value. Returns this instance if the specified value is the same\r\n as the current value.\r\n ":"\r\n 返回此副本，并更改​​为额外的QueryOperators属性\r\n 指定值。如果指定的值相同，则返回此实例\r\n 作为当前值。\r\n \r\n","Partial method '{0}' must have accessibility modifiers because it has a non-void return type.":"部分方法'{0}'必须具有可访问性修饰符，因为它具有非流动返回类型。\r\n","\r\n            Placed in the Zeroth column of the text editor\r\n        ":"\r\n            放置在文本编辑器的零列中\r\n        \r\n","\r\n            Walks down ":"\r\n            走下去\r\n","\r\n  Looks up a localized string similar to 'End With' must be preceded by a matching 'With'..\r\n":"\r\n  查找类似于“ with with”的本地化字符串，必须先于“与”。\r\n\r\n"," use zero argument relaxation.":" 使用零论点放松。\r\n",", but it can\r\n            be overwritten during ":"，但可以\r\n            在期间被覆盖\r\n","\r\n Checks if the control variables from the next statement match the control variable of the enclosing \r\n for loop.\r\n Some loops may contain a next with multiple variables.\r\n ":"检查下一个语句的控制变量是否匹配封闭的控制变量\r\n 用于循环。\r\n 一些循环可能包含一个带有多个变量的下一个循环。\r\n \r\n","Change to 'as' expression":"更改为“ AS”表达\r\n","\r\n indentation depth is the declaration depth for statements within the block. for start/end statements\r\n of these blocks (e.g. the if statement), it is a level less\r\n ":"\r\n 凹痕深度是块内语句的声明深度。开始/结束语句\r\n 在这些块中（例如if语句），它是一个较小的级别\r\n \r\n","\r\n Syntax offset is a unique identifier for the local within the emitted method body.\r\n It's based on position of the local declarator. In single-part method bodies it's simply the distance\r\n from the start of the method body syntax span. If a method body has multiple parts (such as a constructor \r\n comprising of code for member initializers and constructor initializer calls) the offset is calculated\r\n as if all source these parts were concatenated together and prepended to the constructor body.\r\n The resulting syntax offset is then negative for locals defined outside of the constructor body.\r\n ":"\r\n 语法偏移是发射方法主体内局部的唯一标识符。\r\n 它基于本地宣告者的位置。在单部分方法的主体中，这只是距离\r\n 从方法的开始，主体语法跨度。如果方法主体有多个部分（例如构造函数\r\n 包括成员初始化器和构造函数初始化器调用的代码）计算偏移量\r\n 好像所有来源的这些部分都被连接在一起，并添加到构造函数上。\r\n 然后，所得的语法偏移量对于在构造函数主体外定义的当地人为负。\r\n \r\n","\r\n            This is invoked when one of the items provided by this provider is being committed.\r\n            ":"\r\n            当该提供商提供的一件项目之一被提交时，这将被调用。\r\n            \r\n",", but may be \r\n much faster to retrieve for source code assemblies, since it does not require binding the assembly-level\r\n attributes that contain the version number and other assembly information.\r\n ":"，但可能是\r\n 对于源代码组件的检索速度要快得多，因为它不需要绑定组件级别\r\n 包含版本号和其他汇编信息的属性。\r\n \r\n",", this has no side effect.\r\n            ":"，这没有副作用。\r\n            \r\n"," is also \"A.B\", then\r\n            the relative namespace is \"\".\r\n            - If ":" 也是“ A.B”，然后\r\n            相对名称空间是“”。\r\n            - 如果\r\n","\r\n Returns the methods conversions for the given conversion kind\r\n\r\n We are trying to classify conversion between methods arguments\r\n delegateInvoke(parameterConvertFrom) -> targetMethod(parameterConvertTo)\r\n \r\n The relaxation stub would look like (stub has same signature as delegate invoke):\r\n Stub(parameterConvertFrom)\r\n     return targetMethod(parameterConvertTo)\r\n End Method\r\n ":"\r\n 返回给定转换类型的方法转换\r\n\r\n 我们正在尝试对方法之间的转换进行分类\r\n 委托书（parameterConvertfrom） - > targetMethod（parameterConvertto）\r\n \r\n 放松存根看起来像（存根具有与委托调用相同的签名）：\r\n 存根（parameterconvertfrom）\r\n     返回targetMethod（parameterconvertto）\r\n 结束方法\r\n \r\n","Non-null if the navigation would be handled.":"如果要处理导航，则非无效。\r\n","negative character group":"负角色组\r\n","Option controlling if pull diagnostics are allowed for the client.  The\r\n            ":"选项控制如果允许对客户端进行拉诊断。这\r\n            \r\n","\r\n The \"Distinct\" keyword.\r\n ":"\r\n “独特的”关键字。\r\n \r\n"," before in order to fill the cache.\r\n ":" 之前为了填充缓存。\r\n \r\n","positive character range":"正性范围\r\n","\r\n Determines if the current object is equal to another object.\r\n ":"\r\n 确定当前对象是否等于另一个对象。\r\n \r\n","\r\n            Helper type to map ":"\r\n            辅助类型\r\n","\r\n Returns declared interfaces or actual Interfaces if already known\r\n This is only used by cycle detection code so that it can observe when cycles are broken \r\n while not forcing actual Interfaces to be realized.\r\n ":"\r\n 返回声明为接口或实际接口（如果已经知道）\r\n 这仅是由周期检测代码使用的，因此可以观察到何时破裂\r\n 虽然不强制实现实际界面。\r\n \r\n","Deconstruct variable declaration":"解构变量声明\r\n","\r\n            True if this parameter is optional or not.  Optional parameters may be presented in a\r\n            different manner to users.\r\n            ":"\r\n            true是否为此参数是可选的。可选参数可以在\r\n            与用户不同的方式。\r\n            \r\n"," to only\r\n            rewrite the node originally rewritten by ":" 只有\r\n            重写最初由\r\n","The symbol whose interface to generate source for":"其界面生成源的符号\r\n","\r\n Create a diagnostic at a particular syntax node and place it in a diagnostic bag.\r\n ":"\r\n 在特定的语法节点上创建诊断，然后将其放入诊断袋中。\r\n \r\n","The \"/\" custom format specifier represents the date separator, which is used to differentiate years, months, and days. The appropriate localized date separator is retrieved from the DateTimeFormatInfo.DateSeparator property of the current or specified cult ...":"“/”自定义格式指定符表示日期分离器，用于区分年份，月份和天数。从dateTimeFormatinfo中检索适当的局部日期分离器。\r\n","\r\n  Looks up a localized string similar to Delegates cannot handle events..\r\n":"\r\n  查找类似于代表的本地化字符串无法处理事件。\r\n\r\n","\r\n            Code refactoring to help convert code like `!a || !b` to `!(a && b)`\r\n            ":"\r\n            代码重构以帮助转换代码，例如`！a || ！b` to`！（A && b）`\r\n            \r\n","\r\n Walks a DocumentationCommentTriviaSyntax, binding the semantically meaningful parts \r\n to produce diagnostics and to replace source crefs with documentation comment IDs.\r\n ":"\r\n 行走DocumentationCommentTriviaSyntax，绑定语义上有意义的部分\r\n 用文档注释ID产生诊断并替换源CREF。\r\n \r\n","\r\n This function is only needed for SemanticModel to perform binding for erroneous cases.\r\n ":"\r\n SemanticModel仅需要对错误的情况进行绑定。\r\n \r\n","\r\n Delegate to emit string compare call and conditional branch based on the compare result.\r\n ":"\r\n 根据比较结果，委派发出字符串比较呼叫和条件分支。\r\n \r\n"," that works by\r\n            comparing the provided ":" 有效\r\n            比较提供的\r\n","New":"新的\r\n","A syntax node that represents a parsed expression. This syntax\r\n node need not and typically does not appear in the source code referred to by SemanticModel\r\n instance.":"表示解析表达式的语法节点。这个语法\r\n 节点无需，通常不会出现在semanticmodel引用的源代码中\r\n 实例。\r\n","\r\n            Line span in the mapped document.\r\n            ":"\r\n            映射文档中的线跨度。\r\n            \r\n","\r\n The value for the GetTypeKeyword property.\r\n ":"\r\n GetTypekeyword属性的值。\r\n \r\n","The placeholder for the expression that get's the current value.":"获得当前价值的表达式的占位符。\r\n"," for each symbol of the same name in a type.\r\n ":" 对于类型中同名的每个符号。\r\n \r\n","\r\n preprocessor state getter after _currentNode\r\n ":"\r\n _currentNode之后的预处理器状态getter\r\n \r\n","\r\n The underlying NamedTypeSymbol, cannot be another RetargetingNamedTypeSymbol.\r\n ":"\r\n 命名为typesymbol的基础，不能是另一个retargetingNeveMedTypesymbol。\r\n \r\n"," token and the new leading trivia for the ":" 令牌和新的领导琐事\r\n","When the inferred type is Object() indicates that the dominant type algorithm computed this type.":"当推断类型为对象（）时，指示了该类型的主要类型算法。\r\n",".\r\n            Specified ":"。\r\n            指定的\r\n","\r\n  Looks up a localized string similar to Inheriting from '{0}' is not valid..\r\n":"\r\n  查找类似于从'{0}'继承的本地化字符串是无效的。\r\n\r\n","\r\n The part of the name that appears to the right of the dot. This must be a\r\n simple identifier.\r\n ":"\r\n 名称的一部分出现在点的右侧。这一定是\r\n 简单标识符。\r\n \r\n","The completion items to present to the user.":"要介绍给用户的完成项目。\r\n","\r\n            Asynchronous foreach statement cannot operate on variables of type 'X' because 'X' does not contain a suitable public instance or extension definition for 'GetAsyncEnumerator'. Did you mean 'foreach' rather than 'await foreach'?\r\n            ":"\r\n            异步语句无法在类型的“ x”类型的变量上操作，因为'x'不包含“ getAsyncenumerator”的合适的公共实例或扩展定义。您的意思是“ foreach”而不是“等待foreach”？\r\n            \r\n","At least one top-level statement must be non-empty.":"至少一个顶级陈述必须是非空的。\r\n","\r\n The \"End Try\" statement.\r\n ":"\r\n “结束尝试”语句。\r\n \r\n","The caller's buffer into which we place any diagnostics for problems encountered":"呼叫者的缓冲区，我们将任何诊断问题放在其中遇到的问题\r\n","\r\n In cases where we are binding C in \"[C(...)]\", the bound nodes return the symbol for the type. However, we've\r\n decided that we want this case to return the constructor of the type instead (based on the SemanticInfoOptions. This \r\n affects only attributes. This method checks for this situation and adjusts the syntax and method group.\r\n ":"\r\n 如果我们在“ [c（...）]”中绑定C的情况下，结合节点返回类型的符号。但是，我们已经\r\n 决定我们希望此案例返回类型的构造函数（基于Semanticinfooptions。\r\n 仅影响属性。此方法检查这种情况并调整语法和方法组。\r\n \r\n","\r\n            Given a Symbol, creates the completion item for it.\r\n            ":"\r\n            给定符号，为其创建完成项。\r\n            \r\n","\r\n Returns a copy of this with the AlignmentClause property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 将其返回此副本，而AlignmentClause属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Returns a copy of this with the Empty property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此的副本，空属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","Remove unreachable code":"删除无法到达的代码\r\n"," for yield break and yield return statements,\r\n            ":" 对于收益率中断和收益回报陈述，\r\n            \r\n","\r\n            Only some languages support:\r\n              - Optional parameters and params arrays simultaneously in declarations\r\n              - Passing the params array as a named argument\r\n            ":"\r\n            只有一些语言支持：\r\n               - 在声明中同时同时参数和参数阵列\r\n               - 将参数数组作为命名参数传递\r\n            \r\n","\r\n Create the optimized plan for the location of lambda methods and whether scopes need access to parent scopes\r\n  ":"\r\n 为lambda方法的位置创建优化的计划，以及范围是否需要访问父范围\r\n  \r\n"," if the message is identical to the title.\r\n            ":" 如果消息与标题相同。\r\n            \r\n","\r\n  Looks up a localized string similar to Agnostic assembly cannot have a processor specific module '{0}'..\r\n":"\r\n  查找类似于不可知论组件的本地化字符串不能具有处理器特定模块'{0}'..\r\n\r\n","Awaited task returns no value":"等待的任务返回没有价值\r\n","target-typed object creation":"目标型对象创建\r\n","Operator cannot be used here due to precedence.":"由于优先级，在这里无法使用操作员。\r\n","\r\n Represents Xml text.\r\n ":"\r\n 代表XML文本。\r\n \r\n","\r\n Creates the the syntax representation of an xml value element (e.g. for xml documentation comments).\r\n ":"\r\n 创建XML值元素的语法表示（例如，用于XML文档注释）。\r\n \r\n","\r\n  Looks up a localized string similar to 'Class' statement must end with a matching 'End Class'..\r\n":"\r\n  查找类似于“类”语句的本地化字符串必须以匹配的“结束类”结尾。\r\n\r\n","\r\n The list of collection variables declared by this From operator.\r\n ":"\r\n 从操作员声明的收集变量列表。\r\n \r\n"," we were originally invoking an accessor/method off\r\n            of.\r\n            ":" 我们最初是在调用访问者/方法关闭\r\n            的。\r\n            \r\n","Implement all interfaces implicitly":"隐式实现所有接口\r\n","Using directive is unnecessary.":"使用指令是不必要的。\r\n","\r\n The expression being operated on.\r\n ":"\r\n 表达式正在运行。\r\n \r\n","\r\n The try statement is the most complex part of the state machine transformation.\r\n Since the CLR will not allow a 'goto' into the scope of a try statement, we must\r\n generate the dispatch to the state's label stepwise.  That is done by translating\r\n the try statements from the inside to the outside.  Within a try statement, we\r\n start with an empty dispatch table (representing the mapping from state numbers\r\n to labels).  During translation of the try statement's body, the dispatch table\r\n will be filled in with the data necessary to dispatch once we're inside the try\r\n block.  We generate that at the head of the translated try statement.  Then, we\r\n copy all of the states from that table into the table for the enclosing construct,\r\n but associate them with a label just before the translated try block.  That way\r\n the enclosing construct will generate the code necessary to get control into the\r\n try block for all of those states.\r\n ":"\r\n 尝试语句是状态机转换中最复杂的部分。\r\n 由于CLR不会允许“ goto”进入尝试语句的范围，因此我们必须\r\n 将调度逐步生成到州的标签上。这是通过翻译完成的\r\n 从内部到外部的尝试语句。在尝试语句中，我们\r\n 从一个空调度表开始（表示状态编号的映射\r\n 到标签）。在Try语句的身体翻译时，调度表\r\n 一旦我们进入尝试\r\n 堵塞。我们在翻译的Try语句的头部生成。然后我们\r\n 将所有状态从该表复制到表格中以进行封闭构造，\r\n 但是在翻译的尝试块之前将它们与标签相关联。那样\r\n 封闭构造将生成所需的代码，以控制到\r\n 尝试所有这些状态的块。\r\n \r\n","The diagnostics.":"诊断。\r\n","\r\n The value for the OperatorStatement property.\r\n ":"\r\n 操作员属性的值。\r\n \r\n","\r\n Represents a Function or Sub block declaration: A declaration that has a\r\n beginning declaration, a body of executable statements and an end statement.\r\n ":"\r\n 代表函数或子块声明：具有\r\n 开始声明，可执行语句的主体和结束声明。\r\n \r\n","\r\n The options used by the parser to produce the syntax tree.\r\n ":"\r\n 解析器使用的选项生产语法树。\r\n \r\n","\r\n            True if the modified text should be formatted automatically.\r\n            ":"\r\n            如果应自动格式化修改后的文本，则为true。\r\n            \r\n","\r\n Does not consider ":"\r\n 不考虑\r\n","\r\n Create a new syntax tree from a syntax node.\r\n ":"\r\n 从语法节点创建一个新的语法树。\r\n \r\n"," should be used.\r\n            ":" 应该使用。\r\n            \r\n","Insert 'await'.":"插入“等待”。\r\n","\r\n Returns a copy of this with the OperatorStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中运算符的属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Represents an interpolated string expression.\r\n ":"\r\n 表示插值字符串表达式。\r\n \r\n"," if the code block should be analyzed by ":" 如果应通过分析代码块\r\n","The conversion.":"转换。\r\n","\r\n            The default set of typed characters that cause the selected item to be committed.\r\n            Individual ":"\r\n            导致所选项目的默认字符集。\r\n            个人\r\n","\r\n  Looks up a localized string similar to '{0}' is not valid on an Enum declaration..\r\n":"\r\n  在枚举声明中查找类似于“ {0}”的本地化字符串。\r\n\r\n","\r\n Represents an XML document prologue option - version, encoding, standalone or\r\n whitespace in an XML literal expression.\r\n ":"\r\n 代表XML文档序言选项 - 版本，编码，独立或\r\n XML文字表达式中的空格。\r\n \r\n","The original string token that ":"原始的字符串令牌\r\n","The optional processor architecture":"可选处理器体系结构\r\n","\r\n            The result of loading an assembly reference to the interactive session.\r\n            ":"\r\n            加载汇编引用到交互式会话的结果。\r\n            \r\n"," if the node or token is of the specified kind; otherwise, ":" 如果节点或令牌是指定类型的；否则，\r\n","\r\n PERF: The framework specializes EqualityComparer for enums, but only if the underlying type is System.Int32\r\n Since SyntaxKind's underlying type is System.UInt16, ObjectEqualityComparer will be chosen instead.\r\n ":"\r\n perf：该框架专门为枚举提供EqualityComparer，但前提是系统类型是System.int32\r\n 由于SyntaxKind的基本类型是System.Uint16，因此将选择ObjectEqualityComparer。\r\n \r\n","\r\n  Looks up a localized string similar to Modules cannot be generic..\r\n":"\r\n  查找类似于模块的本地化字符串不能是通用的。\r\n\r\n","\r\n A class to represent an empty statement. This can occur when a colon is on a\r\n line without anything else.\r\n ":"\r\n 一个代表空语句的课程。当结肠在一个上时，这可能会发生\r\n 没有其他任何东西。\r\n \r\n"," if this instance is external method; otherwise, ":" 如果此实例是外部方法；否则，\r\n","\r\n            Annotation used so that we can track the top-most node we want to format after\r\n            performing all our edits.\r\n            ":"\r\n            使用注释，以便我们可以跟踪我们想要格式化的最高节点\r\n            执行我们所有的编辑。\r\n            \r\n","\r\n Returns a copy of this with the AsClause property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 将其返回此副本，而ASCLAUSE属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Only a single record partial declaration may have a parameter list":"只有单个记录部分声明可以具有参数列表\r\n","A goto cannot jump to a location after a using declaration.":"使用声明后，goto无法跳到位置。\r\n","\r\n Perform a single pass of flow analysis.  Note that after this pass,\r\n this.backwardBranchChanged indicates if a further pass is required.\r\n ":"\r\n 进行单流分析。请注意，通过此通行证，\r\n 此。后链接指示是否需要进一步通过。\r\n \r\n","\r\n Represents a compiler generated \"Main\" sub.\r\n ":"\r\n 代表编译器生成的“主”子。\r\n \r\n","\r\n Special binder for binding ObjectInitializers. \r\n This binder stores a reference to the receiver of the initialization, because fields in an object initializer can be \r\n referenced with an omitted left expression in an member access expression (e.g. .Fieldname = .OtherFieldname).\r\n ":"\r\n 用于绑定的对象化器的特殊粘合剂。\r\n 该活页夹存储对初始化的接收器的引用，因为对象初始化器中的字段可以是\r\n 在成员访问表达式中使用省略的左表达式引用（例如.fieldName = .otherfieldName）。\r\n \r\n","\r\n Determine if the token instance represents a preprocessor keyword\r\n ":"\r\n 确定令牌实例是否表示预处理器关键字\r\n \r\n","\r\n Represents an assembly built by compiler.\r\n ":"\r\n 代表由编译器构建的组件。\r\n \r\n","\r\n Represents a synthesized lambda. \r\n ":"\r\n 代表合成的lambda。\r\n \r\n","\r\n The most encompassed type in a set of types is the one type that is encompassed\r\n by all other types in the set. If no single type is encompassed by all other types,\r\n then the set has no most encompassed type. In intuitive terms, the most encompassed\r\n type is the \"smallest\" type in the set—the one type that can be converted from each\r\n of the other types through a narrowing conversion.\r\n ":"\r\n 一组类型中最包含的类型是包含的一种类型\r\n 集合中的所有其他类型。如果没有所有其他类型都包含单一类型，\r\n 然后该集合没有最包含的类型。用直观的术语，最包容的\r\n 类型是集合中的“最小”类型 - 可以从每种转换的一种类型\r\n 通过狭窄的转换来实现其他类型。\r\n \r\n","\r\n The \"Stop\" or \"End\" keyword.\r\n ":"\r\n “停止”或“ end”关键字。\r\n \r\n","\r\n            This option can be passed to the ":"\r\n            此选项可以传递给\r\n","\r\n            'A' is inaccessible due to its protection level\r\n            ":"\r\n            由于其保护水平，“ A”是无法访问的\r\n            \r\n","\r\n            Reader of debug information needed for EnC.\r\n            This object does not own the underlying memory (SymReader/MetadataReader).\r\n            ":"\r\n            ENC所需的调试信息的读者。\r\n            该对象不拥有基础内存（Symreader/Metadatareader）。\r\n            \r\n","\r\n A collection of the local variables that are read inside the region.\r\n ":"\r\n 该区域内读取的本地变量的集合。\r\n \r\n","\r\n The value for the HandlesKeyword property.\r\n ":"\r\n HandlesKeyWord属性的值。\r\n \r\n","all punctuation characters":"所有标点字符\r\n","\r\n Represents a file-level attribute, in which the attributes have no other\r\n syntactic element they are attached to.\r\n ":"\r\n 代表文件级属性，其中属性没有其他\r\n 它们附着在句法元素。\r\n \r\n"," to add as the final parameter":" 添加为最终参数\r\n","\r\n Find the implemented method denoted by \"implementedMemberSyntax\" that matches implementingSym.\r\n Returns the implemented method, or Nothing if none.\r\n \r\n Also stores into \"candidateSymbols\" (if not Nothing) and resultKind the symbols and result kind that\r\n should be used for semantic model purposes.\r\n ":"\r\n 查找由匹配实现的“实现的emembersyntax”表示的实现方法。\r\n 返回实现的方法，或者无需返回。\r\n \r\n 还将存储到“ candivateSymbols”（如果不是什么都没有）中，并将符号和结果类似\r\n 应将其用于语义模型目的。\r\n \r\n","Suppress or Configure issues":"抑制或配置问题\r\n","\r\n  Looks up a localized string similar to Expression is not a method..\r\n":"\r\n  查找类似于表达的本地化字符串不是一种方法。\r\n\r\n","\r\n Combine new candidate with the list of existing candidates, applying various shadowing and\r\n tie-breaking rules. New candidate may or may not be added to the result, some\r\n existing candidates may be removed from the result.\r\n ":"\r\n 将新候选人与现有候选人列表相结合，应用各种阴影和\r\n 胜利规则。新候选人可能会或可能不会添加到结果中，有些\r\n 现有的候选人可以从结果中删除。\r\n \r\n","(Suggested name)":"（建议的名称）\r\n","Remove unnecessary casts":"删除不必要的演员\r\n"," for the position.\r\n            ":" 对于位置。\r\n            \r\n","\r\n Bind a dotted name to a type or namespace.\r\n ":"\r\n 将虚拟名称绑定到类型或名称空间。\r\n \r\n","\r\n Get the built-in MSCORLIB type identified. If it's not available (an error type), then report the\r\n error with the given syntax and diagnostic bag. If the node and diagBag are Nothing, then don't report the error (not recommended).\r\n ":"\r\n 获取确定内置的MSCORLIB类型。如果没有可用（错误类型），请报告\r\n 给定语法和诊断袋的错误。如果节点和Diagbag一无所有，则不要报告错误（不建议）。\r\n \r\n"," has changed.\r\n            ":" 已经改变。\r\n            \r\n","\r\n Indicates whether a newline may validly follow the specified SyntaxToken without requiring an explicit line continuation sequence ' _' or terminating the containing statement.\r\n ":"\r\n 指示新线是否可以有效地遵循指定的义传语言，而无需明确的行延续序列'_'或终止包含的语句。\r\n \r\n","\r\n The value for the CatchKeyword property.\r\n ":"\r\n CatchKeyWord属性的值。\r\n \r\n","\r\n Returns a copy of this with the NewKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而NewKeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","The bounds if they are constants, if argument is not specified this info is not returned ":"范围如果它们是常数，则如果未指定参数，则不会返回此信息\r\n","\r\n            Calculate all diagnostics for a given project using analyzers referenced by the project and specified IDE analyzers.\r\n            ":"\r\n            使用项目和指定的IDE分析仪引用的分析仪计算给定项目的所有诊断。\r\n            \r\n","\r\n  Looks up a localized string similar to Type parameter '{0}' can only have one constraint that is a class..\r\n":"\r\n  查找类似于类型参数'{0}'类型的本地化字符串只能具有一个类别的约束。\r\n\r\n","\r\n Returns a copy of this with the AliasName property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而AliasName属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","After binary operators (+, -, /, *, Mod, <>, <, >, <=, >=, ^, >>, <<, And, AndAlso, Or, OrElse, Like, Xor) within an expression.":"在二进制运算符（+， - ， /， *，mod，<>，<，>，<=，> =，> =， ^，>>，<<和，andoLSO，orelse，orelse，like，xor） 。\r\n","\r\n Produces a serialized blob of all constant initializers.\r\n Non-constant initializers are matched with a zero of corresponding size.\r\n ":"\r\n 产生所有恒定初始化器的串行斑点。\r\n 非恒定初始化器与相应大小的零匹配。\r\n \r\n","\r\n Returns method's async kind\r\n ":"\r\n 返回方法的异步类型\r\n \r\n","\r\n This is not a general purpose helper!\r\n ":"\r\n 这不是通用助手！\r\n \r\n","\r\n Return source declaration symbols whose name meets given predicate.\r\n ":"\r\n 返回源声明符号的名称符合给定的谓词。\r\n \r\n","\r\n WARNING: Only use this if the node is obtainable without allocating it (even if cached later). E.g., only\r\n if the node is stored in the constructor of the symbol. In particular, do not call this on the result of a GetSyntax()\r\n call on a SyntaxReference.\r\n ":"\r\n 警告：仅当可以在不分配节点的情况下获得该节点时使用此功能（即使稍后缓存）。例如，仅\r\n 如果节点存储在符号的构造函数中。特别是，请勿根据getsyntax（）的结果称呼此事\r\n 调用语法。\r\n \r\n","The number of spaces to ":"空间数量\r\n","A subtraction must be the last element in a character class":"减法必须是字符类中的最后一个元素\r\n","\r\n            Special formatting rule that will convert a conditional expression into the following\r\n            form if it has the ":"\r\n            特殊格式规则，将有条件的表达式转换为以下\r\n            如果有\r\n","\r\n The conversion from the ":"\r\n 从\r\n","A boolean value set to True if character is a newline character.":"如果字符是newline字符，则将布尔值设置为true。\r\n","\r\n Represents an entire Using...End Using statement, including the Using, body and\r\n End Using statements.\r\n ":"\r\n 表示整个使用...使用语句，包括使用，正文和\r\n 使用语句结束。\r\n \r\n","\r\n Returns true if this method is an extension method.\r\n ":"\r\n 如果此方法是扩展方法，则返回true。\r\n \r\n",",\r\n            then it's still possible to convert that, it would just be ":"，，，，\r\n            然后仍然可以将其转换为\r\n"," representing the specific kind of\r\n PartitionClauseSyntax. One of SkipClause, TakeClause.\r\n ":" 代表特定种类\r\n partitionclausesyntax。 kipplause之一，takeclause。\r\n \r\n","\r\n This has the following effects:\r\n     1) The passed in additionalSubstitution is used on each type argument.\r\n     2) If any parameters in the given additionalSubstitution are not present in oldConstructSubstitution, they are added.\r\n \r\n Result is placed into pairs. Identity substitutions are omitted.\r\n \r\n Returns True if the set of pairs have changed, False otherwise.\r\n ":"\r\n 这具有以下效果：\r\n     1）在每种类型的参数上都使用了通过的摘要。\r\n     2）如果给定的添加订阅中的任何参数在OldConstructSubstitution中不存在，则将添加它们。\r\n \r\n 结果成对。省略身份替换。\r\n \r\n 返回true如果对对，则否则为false否则。\r\n \r\n","\r\n            Represents an edit between two tokens.  Specifically, provides the new trailing trivia for\r\n            the ":"表示两个令牌之间的编辑。具体而言，为新的拖延琐事提供了\r\n            这\r\n","An optional additional document that can be used to inform the formatting operation.":"可选的附加文档，可用于通知格式操作。\r\n","\r\n            Set ourselves as an implicit invocation of FindReferences.  This will cause the finding operation to operate\r\n            in serial, not parallel.  We're running ephemerally in the BG and do not want to saturate the system with\r\n            work that then slows the user down.  Also, only process the inheritance hierarchy unidirectionally.  We want\r\n            to find references that could actually call into a particular, not references to other members that could\r\n            never actually call into this member.\r\n            ":"\r\n            将自己视为对发现的隐性调用。这将导致发现操作运行\r\n            在串行中，不平行。我们正在BG中运行ephermer，不想用\r\n            然后工作，然后减慢用户。同样，仅在单向上处理继承层次结构。我们想要\r\n            要查找实际上可以调用特定的参考，而不是对其他可能的参考\r\n            切勿实际打电话给这个成员。\r\n            \r\n","\r\n  Looks up a localized string similar to Expected beginning '<' for an XML tag..\r\n":"\r\n  查找类似于XML标签的预期开始'<'的本地化字符串。\r\n\r\n","\r\n Returns a copy of this with the Invocation property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，调用属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            If this reference is a location where the definition is written to.\r\n            ":"\r\n            如果此引用是将定义写入的位置。\r\n            \r\n","Implicit line continuation may be used in Visual Basic: ":"隐式线延续可以在Visual Basic中使用：\r\n","\r\n The rewriter for removing lambda expressions from method bodies and introducing closure classes\r\n as containers for captured variables along the lines of the example in section 6.5.3 of the\r\n C# language specification.\r\n \r\n The entry point is the public method Rewrite.  It operates as follows:\r\n \r\n First, an analysis of the whole method body is performed that determines which variables are\r\n captured, what their scopes are, and what the nesting relationship is between scopes that\r\n have captured variables.  The result of this analysis is left in LambdaRewriter.analysis.\r\n \r\n Then we make frame, or compiler-generated class, represented by an instance of\r\n LambdaRewriter.Frame for each scope with captured variables.  The generated frames are kept\r\n in LambdaRewriter.frames.  Each frame is given a single field for each captured\r\n variable in the corresponding scope.  These are maintained in LambdaRewriter.proxies.\r\n \r\n Finally, we walk and rewrite the input bound tree, keeping track of the following:\r\n (1) The current set of active frame pointers, in LambdaRewriter.framePointers\r\n (2) The current method being processed (this changes within a lambda's body), in LambdaRewriter.currentMethod\r\n (3) The \"this\" symbol for the current method in LambdaRewriter.currentFrameThis, and\r\n (4) The symbol that is used to access the innermost frame pointer (it could be a local variable or \"this\" parameter)\r\n \r\n There are a few key transformations done in the rewriting.\r\n (1) Lambda expressions are turned into delegate creation expressions, and the body of the lambda is\r\n     moved into a new, compiler-generated method of a selected frame class.\r\n (2) On entry to a scope with captured variables, we create a frame object and store it in a local variable.\r\n (3) References to captured variables are transformed into references to fields of a frame class.\r\n \r\n In addition, the rewriting deposits into the field LambdaRewriter.generatedMethods a (MethodSymbol, BoundStatement)\r\n pair for each generated method.\r\n \r\n LambdaRewriter.Rewrite produces its output in two forms.  First, it returns a new bound statement\r\n for the caller to use for the body of the original method.  Second, it returns a collection of\r\n (MethodSymbol, BoundStatement) pairs for additional method that the lambda rewriter produced.\r\n These additional methods contain the bodies of the lambdas moved into ordinary methods of their\r\n respective frame classes, and the caller is responsible for processing them just as it does with\r\n the returned bound node.  For example, the caller will typically perform iterator method and\r\n asynchronous method transformations, and emit IL instructions into an assembly.\r\n ":"\r\n 从方法主体中删除lambda表达式并引入关闭类的重写者\r\n 作为沿该示例的捕获变量的容器，在第6.5.3节中\r\n C＃语言规范。\r\n \r\n 入口点是公共方法重写。它运行如下：\r\n \r\n 首先，对整个方法主体进行了分析，以确定哪些变量是\r\n 被捕获，它们的范围是什么，以及在范围之间的嵌套关系是什么\r\n 捕获了变量。该分析的结果留在Lambdarewriter。分析中。\r\n \r\n 然后，我们制作框架或编译器生成的类，以实例为代表\r\n lambdarewriter.frame对于带有捕获变量的每个范围。生成的帧保留\r\n 在lambdarewriter.frames中。为每个捕获的每个帧都有一个字段\r\n 相应范围中的变量。这些保留在lambdarewriter.proxies中。\r\n \r\n 最后，我们走路并重写输入绑定的树，跟踪以下内容：\r\n （1）当前的活动帧指针集，在lambdarewriter.framepointers中\r\n （2）正在处理的当前方法（在lambda的身体内部发生了变化），在lambdarewriter.currentmethod中\r\n （3）lambdarewriter.currentframithis和\r\n （4）用于访问最终帧指针的符号（可能是本地变量或“此参数”）\r\n \r\n 重写中有一些关键的转换。\r\n （1）lambda表达式变成代表创造表达式，而lambda的正文是\r\n     移至选定框架类的新编译器生成的方法。\r\n （2）进入具有捕获变量的范围时，我们创建一个帧对象并将其存储在本地变量中。\r\n （3）对捕获变量的引用转换为对帧类字段的引用。\r\n \r\n 此外，将沉积物重写为lambdarewriter.generatedMethods a（methodsymbol，boundstatement）\r\n 对每个生成的方法对。\r\n \r\n lambdarewriter.predrite以两种形式产生其输出。首先，它返回一个新的绑定语句\r\n 使呼叫者用于原始方法的主体。其次，它返回了\r\n （Methodsymbol，BoundStatement）对Lambda重写者产生的其他方法对。\r\n 这些附加方法包含兰巴斯的尸体，进入了其普通方法\r\n 各自的帧类，呼叫者负责处理它们\r\n 返回的绑定节点。例如，呼叫者通常会执行迭代器方法和\r\n 异步方法转换，并将IL指令发射到一个组件中。\r\n \r\n","Unterminated (?#...) comment":"未终止（？＃...）评论\r\n","\r\n Creates a separated list of nodes from a sequence of nodes, synthesizing comma separators in between.\r\n ":"\r\n 从一系列节点中创建一个分离的节点列表，并在之间合成逗号分离器。\r\n \r\n","\r\n            Similar to SuggestedActionSet, but in a location that can be used\r\n            by both local Roslyn and LSP.\r\n            ":"\r\n            类似于建议的eDectionset，但是在可以使用的位置\r\n            由当地的罗斯林和LSP撰写。\r\n            \r\n","Innermost select expression":"最内向的选择表达式\r\n","The \":\" custom format specifier represents the time separator, which is used to differentiate hours, minutes, and seconds. The appropriate localized time separator is retrieved from the DateTimeFormatInfo.TimeSeparator property of the current or specified  ...":"“：”自定义格式指示符表示时间分离器，用于区分小时，分钟和秒。从dateTimeFormatinfo.timeseparator属性中检索适当的本地时间分离器或指定...\r\n","with on anonymous types":"与匿名类型\r\n","The containing namespace to used, IF a merged namespace is created.":"如果创建了合并的名称空间，则包含使用的名称空间。\r\n","\r\n            Implement a subtype of this class and export it to provide completions during typing in an editor.\r\n            ":"\r\n            实现此类的子类型，并导出其在编辑器中输入期间提供完成。\r\n            \r\n","\r\n Gets member group information about an expression syntax node. This is the worker\r\n function that is overridden in various derived kinds of Semantic Models. It can assume that \r\n CheckSyntaxNode has already been called.\r\n ":"\r\n 获取有关表达语法节点的成员组信息。这是工人\r\n 在各种派生的语义模型中被覆盖的函数。它可以假设\r\n checksyntaxnode已被调用。\r\n \r\n","The correct syntactic classification for the token.":"令牌的正确句法分类。\r\n","\r\n            The result of running a script.\r\n            ":"\r\n            运行脚本的结果。\r\n            \r\n","\r\n            If the cap is 0, then there is no cap.\r\n            ":"\r\n            如果帽子为0，则没有帽子。\r\n            \r\n","\r\n Create a new compilation from scratch.\r\n ":"\r\n 从头开始创建新的汇编。\r\n \r\n","\r\n Represents true whitespace: spaces, tabs, newlines and the like.\r\n ":"代表真实空间：空格，标签，新线等。\r\n \r\n","\r\n             There are a few places where we allow breakpoints on expressions. \r\n            \r\n             1) When the expression is the body of a lambda/method/operator/property/indexer.\r\n             2) The expression is a breakable expression inside a query expression.\r\n             3) The expression is in a for statement initializer, condition or incrementor.\r\n             4) The expression is a foreach initializer.\r\n             5) The expression is the value of an arm of a switch expression\r\n             ":"\r\n             在几个地方，我们允许表达式中断。\r\n            \r\n             1）当表达式是lambda/method/operator/property/indexer的主体时。\r\n             2）该表达式是查询表达式内部的可损坏表达式。\r\n             3）表达式在用于语句初始化器，条件或增量器中。\r\n             4）该表达式是一个foreach初始化器。\r\n             5）表达是开关表达式的臂的值\r\n             \r\n","\r\n            True if this search result represents an item that existed in the past, but which may\r\n            not exist currently, or which may have moved to a different location.  Consumers should\r\n            be resilient to that being the case and not being able to necessarily navigate to the\r\n            ":"\r\n            如果此搜索结果代表过去存在的项目，则可以\r\n            当前不存在，或者可能已移至其他位置。消费者应该\r\n            对这种情况有弹性，并且不一定能够导航到\r\n            \r\n","\r\n  Looks up a localized string similar to '{0}' and '{1}' cannot overload each other because only one is declared 'Default'..\r\n":"\r\n  查找类似于'{0}'和'{1}'的本地化字符串不能互相超载，因为只有一个被声明为'默认值'..\r\n\r\n","The Full Date Short Time (\"f\") Format Specifier\r\n            \r\n            The \"f\" standard format specifier represents a combination of the long date (\"D\") and short time (\"t\") patterns, separated by a space.":"全约日期短时间（“ F”）格式指定符\r\n            \r\n            “ F”标准格式指定符代表长期（“ D”）和短时间（“ T”）模式的组合，被空间隔开。\r\n","\r\n  Looks up a localized string similar to 'Char' values cannot be converted to '{0}'. Use 'Microsoft.VisualBasic.AscW' to interpret a character as a Unicode value or 'Microsoft.VisualBasic.Val' to interpret it as a digit..\r\n":"\r\n  查找类似于“ char”值的本地化字符串不能转换为“ {0}”。使用'Microsoft.visualbasic.ascw'将字符解释为Unicode值或'Microsoft.visualbasic.val'将其解释为数字。\r\n\r\n","\r\n  Looks up a localized string similar to Type '{0}' is not supported because it either directly or indirectly inherits from itself..\r\n":"\r\n  不支持类似于“ {0}”类型的本地化字符串，因为它直接或间接从其自身继承。\r\n\r\n","\r\n  Looks up a localized string similar to '{0}' is ambiguous, imported from the namespaces or types '{1}'..\r\n":"\r\n  查找类似于'{0}'的本地化字符串是模棱两可的，从名称空间或类型'{1}'..导入\r\n\r\n","\r\n Checks if the SyntaxNode is an attribute name. To be an attribute name, the syntax\r\n must be parented by an Attribute and the node itself must be equal to the Attribute.Name\r\n property.\r\n ":"\r\n 检查语法句子是否是属性名称。要成为属性名称，语法\r\n 必须由属性归属，并且节点本身必须等于属性。名称\r\n 财产。\r\n \r\n",".  Specifically, because these are just refactorings,\r\n             they should be offered when they would make the code match the desired user preference,\r\n             or even for allowing the user to quickly switch their code to *not* follow their desired\r\n             preference.\r\n             ":"。具体而言，因为这些只是重构，所以\r\n             当他们使代码与所需的用户偏好匹配时，应该提供它们，\r\n             甚至允许用户快速将其代码转换为 *不 *遵循所需的\r\n             偏爱。\r\n             \r\n","\r\n            Could not find matching ']' for required attribute '{0}'.\r\n            ":"\r\n            无法找到所需属性'{0}'的匹配']'。\r\n            \r\n","\r\n The \"?\" token.\r\n ":"这 ”？”令牌。\r\n \r\n","\r\n Function that help implement the overloading rules for VB, in particular the rules\r\n for recasing method and property names.\r\n ":"\r\n 有助于实施VB的过载规则的功能，特别是规则\r\n 用于审理方法和属性名称。\r\n \r\n","\r\n            Information about a symbol's definition that can be displayed in an editor\r\n            and used for navigation.\r\n            \r\n            Standard implmentations can be obtained through the various ":"\r\n            有关可以在编辑器中显示的符号定义的信息\r\n            并用于导航。\r\n            \r\n            标准隐含物可以通过各种\r\n","\r\n The list of custom modifiers, if any, associated with the parameter.\r\n ":"\r\n 与参数关联的自定义修饰符列表（如果有）。\r\n \r\n","\r\n The exposed type.\r\n ":"\r\n 裸露的类型。\r\n \r\n","\r\n  Looks up a localized string similar to Project already has a reference to assembly '{0}'. A second reference to '{1}' cannot be added..\r\n":"\r\n  查找类似于项目的本地化字符串已经引用了汇编'{0}'。无法添加对“ {1}”的第二个引用。\r\n\r\n","\r\n  Looks up a localized string similar to Argument matching parameter '{0}' narrows to '{1}'..\r\n":"\r\n  查找类似于参数匹配参数'{0}'narrows'{1}'..的参数类似的本地化字符串。\r\n\r\n","\r\n  Looks up a localized string similar to Array initializer is missing {0} elements..\r\n":"\r\n  查找类似于数组初始器类似的本地化字符串{0}元素。\r\n\r\n","\r\n The language name this node is syntax of.\r\n ":"\r\n 该节点的语言名称是语法。\r\n \r\n","1,000,000ths of a second (non-zero)":"1,000,000秒（非零）\r\n"," will be\r\n            non-null.":" 将会\r\n            非效果。\r\n","\r\n Represent an call statement (also known as a invocation statement).\r\n ":"\r\n 表示呼叫语句（也称为调用语句）。\r\n \r\n","expr ?? (expr = value)":"expr ?? （expr =值）\r\n","\r\n A class that represents the set of variables in a scope that have been\r\n captured by lambdas within that scope.\r\n ":"\r\n 代表范围中变量集的类\r\n 在该范围内被Lambdas捕获。\r\n \r\n","\r\n Build a lambda that has a shape of the [delegateInvoke] and calls \r\n the only method from the [methodGroup] passing all parameters of the lambda\r\n as arguments for the call.\r\n Note, that usually the receiver of the [methodGroup] should be captured before entering the \r\n relaxation lambda in order to prevent its reevaluation every time the lambda is invoked and \r\n prevent its mutation. \r\n \r\n             !!! Therefore, it is not common to call this overload directly. !!!\r\n \r\n ":"\r\n 构建具有[委托人]形状并调用的lambda\r\n [methodgroup]传递lambda的所有参数的唯一方法\r\n 作为电话的论点。\r\n 请注意，通常在输入之前应捕获[methotgroup]的接收器\r\n 放松lambda，以防止每次调用Lambda的重新评估，并且\r\n 防止其突变。\r\n \r\n             !!!因此，直接调用此过载并不常见。 !!!\r\n \r\n \r\n","The type of list.":"列表的类型。\r\n","Add parameter to constructor":"将参数添加到构造函数\r\n"," so that it will\r\n            be found and used by the per language associated ":" 这样它将\r\n            可以通过相关语言找到和使用\r\n","\r\n all three declarations for class C are equivalent and result in the same symbol table object for C. \r\n However, these alias symbols do appear in the results of certain SemanticModel APIs. \r\n Specifically, for the base clause of the first of C's class declarations, the\r\n following APIs may produce a result that contains an AliasSymbol:\r\n ":"\r\n C类的所有三个声明都是等效的，并导致C的同一符号表对象。\r\n 但是，这些别名符号确实出现在某些SemanticModel API的结果中。\r\n 具体而言，对于C班级声明的第一个基础条款，\r\n 遵循API可能会产生包含异氧合的结果：\r\n \r\n","An update that causes the return type of the implicit Main method to change requires restarting the application.":"导致隐式主要方法的返回类型的更新需要重新启动应用程序。\r\n","\r\n Bind a type or namespace using the given binder. \r\n ":"\r\n 使用给定的粘合剂绑定类型或名称空间。\r\n \r\n","Namespace aliases for this reference.":"命名空间别名为此参考。\r\n","Adding a user defined {0} requires restarting the application.":"添加用户定义{0}需要重新启动应用程序。\r\n","\r\n            Indicate whether this member needs to be changed to public so it won't cause error after it is pulled up to destination.\r\n            ":"\r\n            指示该成员是否需要更改为公共，因此将其拉到目的地后不会导致错误。\r\n            \r\n","\r\n            Original assembly file path.\r\n            ":"\r\n            原始组装文件路径。\r\n            \r\n","\r\n  Looks up a localized string similar to '{0}' cannot expose type '{1}' outside the project through {2} '{3}'..\r\n":"\r\n  查找类似于'{0}'的本地化字符串，无法通过{2}'{3}'..在项目外面公开类型'{1}'..\r\n\r\n","This method is used by the for each rewriter and the using rewriter. The latter should only call \r\n this method with both IsOrInheritsFromOrImplementsIDisposable and needToDispose set to true, as using is not\r\n pattern based and must implement IDisposable.\r\n ":"此方法由for each重写器和using重写器使用。 后者应该只调用 \r\n 此方法与IsOrInheritsFromOrImplementsIDisposable和needToDispose设置为true，因为使用不是\r\n 基于模式并且必须实现IDisposable。\r\n \r\n"," for an explanation.\r\n ":" 用于解释。\r\n \r\n","\r\n BindValue evaluates the node and returns a BoundExpression.  BindValue snaps expressions to values.  For now that means that method groups\r\n become invocations.\r\n ":"\r\n bindValue评估节点并返回结合表达。 bindvalue捕捉值的表达式。现在这意味着方法组\r\n 成为召唤。\r\n \r\n","\r\n            Given a node that represents a lambda body returns all nodes of the body in a syntax list.\r\n            ":"\r\n            给定一个代表lambda身体的节点在语法列表中返回身体的所有节点。\r\n            \r\n","\r\n  Looks up a localized string similar to Cannot refer to '{0}' because it is a member of the value-typed field '{1}' of class '{2}' which has 'System.MarshalByRefObject' as a base class..\r\n":"\r\n  查找类似于“ {0}”的本地化字符串，因为它是class'{2}'的价值型字段'{1}'的成员，其中'system.marshalbyrefobject'作为基类。 。\r\n\r\n","A CommandLineArguments object representing the parsed command line.":"代表解析命令行的命令线核对对象。\r\n","\r\n The value for the MissingIdentifier property.\r\n ":"\r\n 缺失IdentiDifier属性的值。\r\n \r\n","Matching an attribute by name does not load the attribute class.":"按名称匹配属性不会加载属性类。\r\n","\r\n The lower bound of the range. This is typically the integer constant zero.\r\n ":"\r\n 范围的下限。这通常是整数常数零。\r\n \r\n","\r\n These are flags that are implied or computed\r\n ":"\r\n 这些是暗示或计算的标志\r\n \r\n","\r\n            Opens a PDB file produced by the compiler.\r\n            Returns null if the compiler generated no PDB (the symbols might be embedded in the assembly).\r\n            ":"\r\n            打开编译器生成的PDB文件。\r\n            如果编译器生成没有PDB，则返回null（符号可以嵌入在组件中）。\r\n            \r\n","s, False to unwrap them.":"S，假拆开。\r\n","\r\n            Opens metadata section of the assembly file produced by the compiler.\r\n            ":"\r\n            打开编译器生成的组件文件的元数据部分。\r\n            \r\n","\r\n Given an modified identifier that is part of a variable declaration, get the\r\n corresponding symbol.\r\n ":"\r\n 给定一个修改后的标识符，该标识符是变量声明的一部分，获取\r\n 相应的符号。\r\n \r\n","\r\n What is the argument to the (first) CLSCompliantAttribute on this symbol, if there is one?\r\n Do not consider attributes inherited from base types.\r\n ":"\r\n 如果有的话，（第一个）ClsCompliantAtibute的论点是什么？\r\n 不要考虑从基本类型继承的属性。\r\n \r\n"," \r\n Search through the members of a given type symbol to find the method that matches a particular signature. \r\n ":" \r\n 浏览给定类型符号的成员，以找到与特定签名匹配的方法。\r\n \r\n","\r\n            \r\n            this event args contains information such as ":"\r\n            \r\n            此事件ARG包含诸如\r\n","\r\n The value for the EndOfFileToken property.\r\n ":"\r\n 内脚属属性的价值。\r\n \r\n","\r\n Represents SZARRAY - zero-based one-dimensional array \r\n ":"\r\n 代表szarray-基于零的一维数组\r\n \r\n","\r\n Parses StringLiteral\r\n ":"\r\n parses stringliteral\r\n \r\n","\r\n            If no text has been typed, the item should be hard selected.  This is appropriate for\r\n            completion providers that are providing suggestions the user is nearly certain to \r\n            select.  Because the item is hard selected, any commit characters typed after it will\r\n            cause it to be committed.\r\n            ":"\r\n            如果未键入文本，则应很难选择该项目。这适合\r\n            提供建议的完整提供商几乎可以肯定\r\n            选择。因为很难选择该项目，所以在其键入之后输入的任何提交字符都将\r\n            使它被承诺。\r\n            \r\n","Parameter '{0}' is not explicitly provided, but is used as an argument to the interpolated string handler conversion on parameter '{1}'. Specify the value of '{0}' before '{1}'.":"参数'{​​0}'未明确提供，而是用作插值字符串处理程序转换的参数，该转换是参数'{1}'。在'{1}'之前指定“ {0}”的值。\r\n","\r\n Checks if a given symbol is a function that takes no parameters.\r\n ":"\r\n 检查给定符号是否是不使用参数的函数。\r\n \r\n","\r\n The event declaration that begins the block.\r\n ":"\r\n 开始块的事件声明。\r\n \r\n","\r\n The lower bound of the range.\r\n ":"\r\n 范围的下限。\r\n \r\n","\r\n            Analyzes data flow in the member body represented by the specified node and returns all captured variables and parameters (including \"this\").\r\n            If the body is a field/property initializer analyzes the initializer expression only.\r\n            ":"\r\n            分析以指定节点表示的成员体中的数据流，并返回所有捕获的变量和参数（包括“ this”）。\r\n            如果身体是字段/属性初始化器，则仅分析初始化器表达式。\r\n            \r\n","\r\n            Opens an assembly file produced by the compiler.\r\n            ":"\r\n            打开编译器生产的组件文件。\r\n            \r\n","\r\n  Looks up a localized string similar to Expression is of type '{0}', which is not a collection type..\r\n":"\r\n  查找类似于表达式的本地化字符串是“ {0}”类型，这不是集合类型。\r\n\r\n","\r\n            A subtype of ":"\r\n            亚型的\r\n","\r\n Gets the location of this node.\r\n ":"\r\n 获取此节点的位置。\r\n \r\n","\r\n Returns a copy of this with the LabelToken property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而Labeltoken属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Expression value is never used":"表达值永远不会使用\r\n","An expression tree may not contain an interpolated string handler conversion.":"表达树可能不包含插值的字符串处理程序转换。\r\n","\r\n Method symbol or nothing\r\n TODO: Need to try and get rid of this property\r\n ":"\r\n 方法符号或什么都没有\r\n 托多：需要尝试摆脱这一属性\r\n \r\n","\r\n The name of the range variable being defined.\r\n ":"\r\n 定义范围变量的名称。\r\n \r\n"," in case the tree is not a submission.\r\n ":" 如果树不是提交的。\r\n \r\n",". If we ever needed to return a ":"。如果我们需要返回\r\n",", and\r\n            adds the ":"，而\r\n            增加 \r\n","\r\n Completes binding and performs analysis of bound trees for the purpose of obtaining diagnostics.\r\n \r\n NOTE: This method does not perform lowering/rewriting/emit. \r\n       Errors from those stages require complete compile, \r\n       but generally are not interesting during editing.\r\n \r\n NOTE: the bound tree produced by this method are not stored anywhere\r\n       and immediately lost after diagnostics of a particular tree is done.\r\n       \r\n ":"\r\n 完成绑定的树木的结合并进行分析，以获得诊断。\r\n \r\n 注意：此方法不会执行降低/重写/发射。\r\n       这些阶段的错误需要完全编译，\r\n       但是通常在编辑过程中并不有趣。\r\n \r\n 注意：此方法生产的绑定树未存储在任何地方\r\n       在完成特定树的诊断后立即丢失。\r\n       \r\n \r\n","\r\n A specific location for binding.\r\n ":"\r\n 绑定的特定位置。\r\n \r\n","\r\n Represents an OnError Resume Next statement.\r\n ":"\r\n 代表下一个履历的下一步声明。\r\n \r\n","\r\n  Looks up a localized string similar to Line continuation character '_' must be preceded by at least one white space and must be the last character on the line..\r\n":"\r\n  查找类似于行延续字符'_'的局部字符串必须至少有一个空白空间，并且必须是行上的最后一个字符。\r\n\r\n","\r\n  Looks up a localized string similar to 'Set' is already declared..\r\n":"\r\n  查找类似于“集合”的本地化字符串。\r\n\r\n"," is configured to be the given\r\n            ":" 被配置为给定的\r\n            \r\n","\r\n Gets the attributes on event's associated field, if any.\r\n ":"\r\n 获取事件相关字段（如果有）上的属性。\r\n \r\n","\r\n            Represents a switch-label constructed from a series of\r\n            if-conditions, possibly combined by logical-and operator\r\n            ":"\r\n            表示由一系列的开关标签标签\r\n            如果条件，可能由逻辑和操作员组合\r\n            \r\n","\r\n            The id of the unmapped document where the source of the active statement is and from where the statement might be mapped to ":"\r\n            非限制文档的ID处于活动语句所在的位置以及该语句可以映射到的位置\r\n","\r\n Parse an executable statement.\r\n ":"\r\n 解析可执行语句。\r\n \r\n",".\r\n Even for lazily-computed values, it may be possible to avoid allocating ":"。\r\n 即使对于懒惰的值，也可能避免分配\r\n","\r\n Given a namespace symbol, returns the corresponding assembly specific namespace symbol\r\n ":"\r\n 给定的名称空间符号，返回相应的汇编特定的名称空间符号\r\n \r\n",") \r\n            is the same as the code emitted for the corresponding new active statement part (":"）\r\n            与相应的新活动语句零件发出的代码相同（\r\n"," is selected.\r\n            - Selection is zero-width and wanted node is an expression / argument with selection within such syntax node (arbitrarily deep) on its first line.\r\n            - Whole node of a type ":" 选择。\r\n             - 选择为零宽，想要的节点是一种表达式 /参数，在其第一行上的该语法节点（任意深）中选择了选择。\r\n             - 类型的整个节点\r\n","\r\n Given a identifier and a type, return the actual type to use. Uses the type character or the given type.\r\n ":"\r\n 给定标识符和类型，请返回实际类型进行使用。使用类型字符或给定类型。\r\n \r\n","\r\n Return error code that has highest priority while calculating use site error for this symbol. \r\n ":"\r\n 返回错误代码在计算此符号的使用站点错误时具有最高优先级。\r\n \r\n","\r\n Base class for any local symbol that can be referenced in source, might be implicitly declared.\r\n ":"\r\n 可以隐式声明的任何可以在源中引用的本地符号的基类。\r\n \r\n"," for the\r\n namespace or type referenced by the alias.\r\n ":" 为了\r\n 别名引用的名称空间或类型。\r\n \r\n","\r\n            Returns the parameter to which this argument is passed. If ":"\r\n            返回该参数传递的参数。如果\r\n","\r\n  Looks up a localized string similar to Constant '{0}' cannot depend on its own value..\r\n":"\r\n  查找类似于常数'{0}'的本地化字符串不能取决于其自身的值。\r\n\r\n","\r\n Given a DocumentationCommentTriviaSyntax, return the full text, but with\r\n documentation comment IDs substituted into crefs.\r\n ":"\r\n 给出了DocumentationCommentTriviaSyntax，返回全文，但是\r\n 文档评论ID代替Crefs。\r\n \r\n","Receiver for the generated linq invocation. Updated when processing an if statement.":"生成的LINQ调用的接收器。处理if语句时更新。\r\n","\r\n            Determines whether the enter key is passed through to the editor after it has been used to commit a completion item.\r\n            ":"\r\n            确定Enter密钥是否已用于提交完成项目后是否将其传递给编辑器。\r\n            \r\n","\r\n            Rules that modify the set of characters that can be typed to cause the selected item to be committed.\r\n            ":"\r\n            修改可以键入的字符集的规则，以使所选项目被合作。\r\n            \r\n","\r\n  Looks up a localized string similar to Type '{0}' cannot be used across assembly boundaries because it has a generic type parameter that is an embedded interop type..\r\n":"\r\n  查找类似于“ {0}”类型的本地化字符串，因为它具有嵌入式Interop类型的通用类型参数。\r\n\r\n",". These tags may influence how the \r\n            item is displayed.\r\n            ":"。这些标签可能会影响\r\n            显示项目。\r\n            \r\n","\r\n            ```expr1|expr2``` node.\r\n            ":"\r\n            ````expr1 | expr2``节点''。\r\n            \r\n","Matches a tab character, \\u0009":"匹配一个标签字符\\ u0009\r\n","\r\n            Represents a debugging session.\r\n            ":"\r\n            代表调试会话。\r\n            \r\n"," The node needs to be cast.":" 该节点需要施放。\r\n","\r\n Get all the members of this symbol that are modules.\r\n ":"\r\n 获取该符号的所有成员是模块。\r\n \r\n","\r\n Owning assembly.\r\n ":"\r\n 拥有组装。\r\n \r\n","\r\n The value for the Value property.\r\n ":"\r\n 值属性的值。\r\n \r\n","Indicates whether to bind the expression as a full expression,\r\n or as a type or namespace.":"指示是否将表达式绑定为完整表达式，\r\n 或类型或名称空间。\r\n","\r\n Represents a member variable -- a variable declared as a member of a Class or Structure. \r\n ":"\r\n 代表成员变量 - 称为类或结构的成员的变量。\r\n \r\n","\r\n Get the label that a Return statement should branch to, or Nothing if we are\r\n not inside a context that would be exited by that kind of statement. This method\r\n is equivalent to calling ":"\r\n 获取返回语句应分支到的标签，或者如果我们没有\r\n 不在这种陈述将退出的上下文中。这个方法\r\n 等同于打电话\r\n","\r\n Marks StandardModuleAttributeReference type as being references in the \r\n current compilation. This method is to be used when a new type symbol for a \r\n module is being created; we cannot pass the actual StandardModuleAttribute \r\n type symbol because the symbol table is being constructed and calling \r\n Compilation.GetWellKnownType(...) will cause infinite recursion. It does\r\n not seem reasonable to special case this in symbol creation, so we just \r\n mark StandardModuleAttribute attribute as referenced and then add \r\n the actual symbol when MarkAllDeferredSymbols(...) is called.\r\n ":"\r\n 标记标准模块质量偏移类型为作为参考\r\n 当前汇编。当新类型的符号用于\r\n 正在创建模块；我们无法通过实际的标准模块\r\n 键入符号，因为符号表正在构造和调用\r\n 汇编。getWellKonningType（...）将引起无限的递归。确实如此\r\n 在符号创建中，对于特殊情况来说似乎是不合理的，所以我们只是\r\n 标记标准模块属性属性，然后添加\r\n 称为MarkaldeferredSymbols（...）时的实际符号。\r\n \r\n","ConstantValue if the bound expression is compile time constant and can be used \r\n for const field/local initializations or enum member initializations. Nothing if not":"constantValue如果绑定表达式是编译时间常数，并且可以使用\r\n 用于const字段/本地初始化或枚举成员初始化。如果没有，什么也没有\r\n","\r\n The For statement that begins a For-Next block. This statement always occurs as\r\n the Begin of a ForBlock. Most of the time, the End of that ForBlock is the\r\n corresponding Next statement. However, multiple nested For statements are ended\r\n by a single Next statement with multiple variables, then the inner For\r\n statements will have End set to Nothing, and the Next statement is the End of\r\n the outermost For statement that is being ended.\r\n ":"\r\n 开始一个临时块的语句。这个陈述总是发生\r\n FORBLOCK的开始。在大多数情况下，该框架的结尾是\r\n 对应的下一个语句。但是，陈述的多个嵌套结束\r\n 通过一个具有多个变量的下一个语句，然后是内在的\r\n 陈述将结束为一无所有，下一个声明是\r\n 最外面的陈述正在结束。\r\n \r\n","\r\n            The actual wrapping code actions for this group to present to the user.\r\n            ":"\r\n            该组向用户展示的实际包装代码操作。\r\n            \r\n","\r\n Gets a list of all the diagnostics in the sub tree that has the specified node as its root.\r\n ":"\r\n 获取具有指定节点作为词根的子树中所有诊断的列表。\r\n \r\n","\r\n Returns true if all arguments are missing.\r\n ":"\r\n 如果缺少所有参数，则返回true。\r\n \r\n","\r\n            Provider instance, which keeps the ":"\r\n            提供者实例，保留\r\n","\r\n            Display parts for this parameter.  This should normally be presented to the user as part\r\n            of the entire signature display.\r\n            ":"\r\n            显示此参数的零件。通常应该将其作为一部分提交给用户\r\n            整个签名显示。\r\n            \r\n","\r\n Return the xmlns imports for this file. May return Nothing if there are no xmlns imports.\r\n ":"\r\n 返回此文件的XMLN导入。如果没有XMLN导入，则可能不会返回。\r\n \r\n","\r\n Returns a copy of this with the StartQuoteToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"返回此副本，使用StartQuotToken属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n The Do statement that begins a Do-Loop block.\r\n ":"\r\n 开始一个do-loop块的DO语句。\r\n \r\n","\r\n Gets the special type.\r\n ":"\r\n 获取特殊类型。\r\n \r\n","The for block syntax node.":"用于块语法节点。\r\n","\r\n            Object pretty printer.\r\n            ":"\r\n            对象漂亮的打印机。\r\n            \r\n","The selection contains no active statement.":"选择不包含活动语句。\r\n","Updating the attributes of {0} requires restarting the application because it is not supported by the runtime.":"更新{0}的属性需要重新启动应用程序，因为运行时不支持它。\r\n","\r\n  Looks up a localized string similar to 'Into' expected..\r\n":"查找类似于“进入”预期的本地化字符串。\r\n\r\n","\r\n            Brace completion service used for completing curly braces inside interpolated strings.\r\n            In other curly brace completion scenarios the ":"\r\n            支架完成服务用于在插值字符串内完成卷曲括号。\r\n            在其他卷曲支架完成方案中\r\n","\r\n Perform additional validate of implementedSym and issue diagnostics.\r\n Return \"implementedSym\" if the symbol table should record implementedSym as the implemented\r\n symbol (even if diagnostics were issues). Returns Nothing if the code should not treat\r\n implementedSym as the implemented symbol.\r\n ":"执行实施的额外验证并发行诊断。\r\n 如果符号表应记录实现的符号，则返回“已实现”\r\n 符号（即使诊断是问题）。如果代码不在处理，则什么都没有返回\r\n 实现的符号作为实施符号。\r\n \r\n","The method conversions.":"方法转换。\r\n","The left-hand side of a ref assignment must be a ref local or parameter.":"ref分配的左侧必须是参考本地或参数。\r\n"," if the given conversion is a CLR supported conversion; otherwise, ":" 如果给定的转换为CLR支持的转换；否则，\r\n"," in case it contains only whitespace.\r\n            ":" 如果仅包含空格。\r\n            \r\n","\r\n            The span of text to collapse.\r\n            ":"\r\n            文字崩溃的跨度。\r\n            \r\n","\r\n The parent namespace. There is always one, Global namespace contains all\r\n top level namespaces. \r\n ":"\r\n 父命名空间。总是有一个，全局名称空间包含全部\r\n 顶级名称空间。\r\n \r\n","The unicode character.":"Unicode字符。\r\n","Computing fix all occurrences code fix...":"计算修复所有出现代码修复...\r\n","Where to report the error, if any.":"在哪里报告错误（如果有）。\r\n","\r\n            Fix each reference and return a collection of proper containers (innermost container\r\n            with imports) that new import should be added to based on reference locations.\r\n            If ":"\r\n            修复每个参考并返回适当容器的集合（最内向的容器\r\n            随着导入），应根据参考位置添加新导入。\r\n            如果\r\n","\r\n  Looks up a localized string similar to '{0}' cannot be referenced because it is not a valid assembly..\r\n":"\r\n  查找类似于“ {0}”的本地化字符串，因为它不是有效的组件。\r\n\r\n","\r\n Returns a copy of this with the ElseIfStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中ElseifStatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Returns a copy of this with the AccessorStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中登录属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","Hide base member":"隐藏基本成员\r\n","\r\n Rewrites Return as a GoTo is needed (if not the last statement in a method)\r\n ":"\r\n 重写返回是需要goto的（如果不是方法中的最后一个语句）\r\n \r\n","'new' expression can be simplified":"可以简化“新”表达\r\n","The \"H\" custom format specifier represents the hour as a number from 0 through 23; that is, the hour is represented by a zero-based 24-hour clock that counts the hours since midnight. A single-digit hour is formatted without a leading zero.\r\n            \r\n            If the \"H\" for ...":"“ H”自定义格式指定符表示该小时为0到23的数字；也就是说，小时以零基于24小时的时钟为代表，该时钟算在午夜以来的时间。单位小时的格式不带领先的零。\r\n            \r\n            如果“ h”为...\r\n","\r\n            Look for methods like \"SomeType MyType.Slice(int start, int length)\".  Note that the\r\n            names of the parameters are checked to ensure they are appropriate slice-like.  These\r\n            names were picked by examining the patterns in the BCL for slicing members.\r\n            ":"\r\n            查找诸如“ wory oped mytype.slice（int start，int length）”之类的方法。请注意\r\n            检查参数的名称，以确保它们类似于切片。这些\r\n            通过检查切片成员的BCL中的模式来选择名称。\r\n            \r\n","\r\n            Braces are allowed, but not preferred.\r\n            ":"\r\n            大括号是允许的，但不是首选。\r\n            \r\n","\r\n            ```(?<=expr)``` node.\r\n            ":"\r\n            ``（？<= expr）````node''。\r\n            \r\n","\r\n Should be in sync with Binder.ReportByRefConversionErrors.\r\n ":"\r\n 应该与Binder同步。ReportByRefConversionErrors。\r\n \r\n"," \r\n \"C.D\" matches C.D, C(Of T).D, C(Of S,T).D(Of U), etc. \r\n ":" \r\n “ c.d”匹配C.D，C（t）.d，c（s，t）.d（of U），等。\r\n \r\n","\r\n This method reports use site errors if a required attribute constructor is missing.\r\n Some attributes are considered to be optional (e.g. the CompilerGeneratedAttribute). In this case the use site\r\n errors will be ignored.\r\n ":"\r\n 此方法报告如果缺少所需的属性构造函数，请使用站点错误。\r\n 某些属性被认为是可选的（例如，compilergeneratedAtibute）。在这种情况下，使用网站\r\n 错误将被忽略。\r\n \r\n","\r\n            The options that completion was started with.\r\n            ":"开始完成的选项。\r\n            \r\n","\r\n            The compiler has various scenarios that will cause it to synthesize things that might not be covered\r\n            by existing rude edits, but we still need to ensure the runtime supports them before we proceed.\r\n            ":"\r\n            编译器具有各种情况，可以使其合成可能未涵盖的事物\r\n            通过现有的粗鲁编辑，但我们仍然需要确保运行时支持它们。\r\n            \r\n","\r\n Perform overload resolution on the given method or property group, with the given arguments and names.\r\n The names can be null if no names were supplied to any arguments.\r\n ":"\r\n 在给定的方法或属性组上执行过载分辨率，并具有给定的参数和名称。\r\n 如果未向任何参数提供名称，则名称可以为null。\r\n \r\n","\r\n Create a metadata reference to a compilation.\r\n ":"\r\n 创建对汇编的元数据引用。\r\n \r\n","\r\n            Returns a document snapshot for given ":"\r\n            返回给定的文档快照\r\n","The syntax editor for the code fix.":"代码修复的语法编辑器。\r\n","The MoveNext method.":"movenext方法。\r\n","Accessibility modifiers required":"需要可访问性修饰符\r\n","\r\n Return true if and only if an expression is a integral literal with a value of zero.\r\n Non-literal constant value zero does not qualify.\r\n ":"\r\n 当且仅当一个表达式为零值的整体文字时，返回true。\r\n 非文字恒定值零不符合条件。\r\n \r\n","Flaggged node containing the identifier token to be replaced.":"包含要替换的标识符令牌的标志节点。\r\n","\r\n            Finds code like typeof(someType).Name and determines whether it can be changed to nameof(someType), if yes then it offers a diagnostic\r\n            ":"\r\n            查找诸如Typeof（wordy stype）的代码。名称并确定是否可以更改为nameof（wordy stype），如果是，则提供诊断\r\n            \r\n","\r\n Return whether the symbol is either the original definition\r\n or distinct from the original. Intended for use in Debug.Assert\r\n only since it may include a deep comparison.\r\n ":"\r\n 返回符号是否是原始定义\r\n 或与原始不同。旨在用于debug.assert\r\n 仅因为它可能包括深入比较。\r\n \r\n","\r\n Lazily created parsed representation of VB Core content\r\n ":"懒惰的VB核心内容的解析表示\r\n \r\n","\r\n Try to convert an Identifier to a Keyword.  Called by the parser when it wants to force\r\n an identifier to be a keyword.\r\n ":"\r\n 尝试将标识符转换为关键字。当解析器要强迫时被解析器召集\r\n 标识符是关键字。\r\n \r\n","\r\n Returns a new compilation with the given compilation set as the previous submission. \r\n ":"\r\n 返回以给定汇编集作为上一提的提交的新汇编。\r\n \r\n","\r\n Handles Me.Event1\r\n ":"\r\n 处理me.event1\r\n \r\n","Merge with next '{0}' statement":"与下一个'{0}'语句合并\r\n","The #line directive end position must be greater than or equal to the start position":"#line指令终端位置必须大于或等于开始位置\r\n","A boolean value set to True if character can be part of a valid start character in an identifier.":"如果字符可以成为标识符中有效启动字符的一部分，则将布尔值设置为true。\r\n",").\r\n ":"）。\r\n \r\n"," representing the specific kind of OrderingSyntax. One\r\n of AscendingOrdering, DescendingOrdering.\r\n ":" 代表特定类型的有序词法。一\r\n 升序，降序。\r\n \r\n","\r\n Specified lower bounds for dimensions, by position. The length can be less than ":"按位置指定的尺寸的下限。长度可能小于\r\n","\r\n            {\r\n              A: true,\r\n              B: false,\r\n              C: new int[3] { 1, 2, 3 }\r\n            }\r\n            ":"\r\n            {\r\n              答：是的，\r\n              B：错误，\r\n              C：new int [3] {1，2，3}\r\n            }\r\n            \r\n","'{0}' does not override expected property from '{1}'.":"'{0}'不会从'{1}'中覆盖预期属性。\r\n","\r\n Check all accessible, visible members of the base types of container for the given name and kind. If they\r\n all have the same case-sensitive metadata name, return that name. Otherwise, return Nothing.\r\n ":"\r\n 检查给定名称和类型的所有可访问的，可见的基本类型的成员。如果他们\r\n 所有人都具有相同的情况敏感的元数据名称，返回该名称。否则，什么也没返回。\r\n \r\n","\r\n A TypeSymbol is a base class for all the symbols that represent a type\r\n in Visual Basic.\r\n ":"\r\n typesymbol是代表类型的所有符号的基类\r\n 在Visual Basic中。\r\n \r\n","\r\n The left operand.\r\n ":"\r\n 左操作数。\r\n \r\n","\r\n Slow part of AdjustTriviaForMissingTokensCore where we actually do the work when we need to.\r\n ":"\r\n 在需要时，我们实际上要做工作的地方慢慢进行调整。\r\n \r\n","\r\n Construct an object for outside-region analysis\r\n ":"\r\n 构建一个用于外部分析的对象\r\n \r\n","\r\n            The array may contain both resolved and unresolved references (":"\r\n            阵列可能包含已解析和未解决的参考（\r\n","\r\n returns the container of the first member in the group.\r\n ":"\r\n 返回小组中第一个成员的容器。\r\n \r\n","\r\n            The dependencies that this reference transitively brings in to the compilation.\r\n            ":"\r\n            该参考文献将其带入汇编的依赖项。\r\n            \r\n","\r\n            Checks for conditions where we should not generate a variable for an expression\r\n            ":"\r\n            检查我们不应生成一个表达式变量的条件\r\n            \r\n","\r\n The name of the namespace.\r\n ":"\r\n 名称空间的名称。\r\n \r\n"," open on a Portable PDB.":" 在便携式PDB上打开。\r\n","\r\n            Describe a caller method of a callee\r\n            ":"\r\n            描述callee的呼叫者方法\r\n            \r\n","The list of projects each recommended symbol did NOT appear in.":"每个推荐符号的项目列表未出现。\r\n","\r\n Returns true if this property hides a base property by name and signature.\r\n The equivalent of the \"hidebysig\" flag in metadata. \r\n ":"\r\n 如果此属性按名称和签名隐藏基本属性，则将返回true。\r\n 等效于元数据中的“ hidebysig”标志。\r\n \r\n","\r\n Represents a parenthesized list of generic type arguments.\r\n ":"\r\n 表示通用类型参数的括号列表。\r\n \r\n","\r\n  Looks up a localized string similar to Value of type '{0}' cannot be converted to '{1}' because the array types have different numbers of dimensions..\r\n":"\r\n  查找类似于类型'{0}'的值的本地化字符串，不能转换为'{1}'，因为数组类型具有不同的尺寸。\r\n\r\n","\r\n The property declaration that begins the block.\r\n ":"\r\n 开始块的属性声明。\r\n \r\n","\r\n Peeks in a stream of VB tokens.\r\n Note that the first token will be picked according to _allowLeadingMultilineTrivia\r\n The rest will be picked as regular VB as scanner does not always know what to do with\r\n line terminators and we assume that multiple token lookahead makes sense inside a single statement.\r\n ":"\r\n 在VB代币流中窥视。\r\n 请注意，第一个令牌将根据_AllowLeadingMultinIrivia选择\r\n 其余的将被选为常规VB，因为扫描仪并不总是知道该怎么办\r\n 线路终结者，我们假设多个令牌lookahead在单个语句中有意义。\r\n \r\n","Unable to read debug information of method '{0}' (token 0x{1:X8}) from assembly '{2}'":"无法读取方法'{0}'（token 0x {1：x8}）的调试信息。\r\n","\r\n The \"Event\" keyword that introduces this event declaration.\r\n ":"\r\n 介绍此事件声明的“事件”关键字。\r\n \r\n","\r\n Check to see if we need a default instance|shared constructor, and if so, create it.\r\n \r\n NOTE: we only need a shared constructor if there are any initializers to be \r\n injected into it, we don't create a constructor otherwise. In this case we also \r\n ignore const fields which will still require to be injected, because in this case\r\n we don't see the constructor to be visible in symbol table.\r\n ":"\r\n 检查我们是否需要默认实例|共享构造函数，如果是，则创建它。\r\n \r\n 注意：我们只需要一个共享构造函数\r\n 注入其中，我们不会创建构造函数。在这种情况下，我们也\r\n 忽略仍然需要注入的const字段，因为在这种情况下\r\n 我们看不到构造函数在符号表中可见。\r\n \r\n","\r\n            Reference's line based on the document content\r\n            ":"基于文档内容的参考线\r\n            \r\n","\r\n Returns true if our diagnostics were used in the event that there were two threads racing.\r\n ":"\r\n 如果使用两次线程赛车，则使用我们的诊断方法，返回返回。\r\n \r\n","\r\n This symbol is used as the return type of a LambdaSymbol when we are dealing with\r\n query lambda and the return type should be taken from the target delegate upon\r\n successful conversion. The LambdaSymbol will be mutated then. \r\n ":"\r\n 当我们处理时，此符号用作lambdasymbol的返回类型\r\n 查询lambda和返回类型应在目标代表上取\r\n 成功的转换。那时将突变lambdasymbol。\r\n \r\n","\r\n Add names of viable extension methods declared in this (compilation merged or module level) \r\n namespace to nameSet parameter.\r\n \r\n The 'appendThrough' parameter allows RetargetingNamespaceSymbol to delegate majority of the work \r\n to the underlying namespace symbol, but still perform viability check on RetargetingMethodSymbol.\r\n \r\n A cached map of extension methods is used to optimize the operation.\r\n ":"添加此中声明的可行扩展方法的名称（编译合并或模块级别）\r\n 名称空间到姓名参数。\r\n \r\n “附录”参数允许retargetingNamespaceSymbol委派大部分工作\r\n 到基础命名空间符号，但仍能对RetargetingMethodSymbol进行活跃性。\r\n \r\n 扩展方法的缓存图用于优化操作。\r\n \r\n","\r\n Rewrite a for each that uses IEnumerable. It's basic form is:\r\n\r\n     Dim e As E = c.GetEnumerator()\r\n     Do While e.MoveNext()\r\n        controlVariable = e.Current\r\n        <loop body>\r\n     Loop\r\n\r\n To support disposable enumerators, the compiler will generate code to dispose the\r\n enumerator after loop termination.  Only when E implements IDisposable can this be done.\r\n The one exception to this rule is when E is specifically IEnumerator, in which case\r\n the compiler will generate code to dynamically query the enumerator to determine\r\n if it implements IDisposable.\r\n\r\n If E is IEnumerator the loop becomes:\r\n\r\n     Dim e As IEnumerator = c.GetEnumerator()\r\n     Try\r\n         Do While e.MoveNext()\r\n            dim controlVariable = e.Current\r\n            <loop body>\r\n         Loop\r\n     Finally\r\n         If TryCast(e, IDisposable) IsNot Nothing then\r\n             CType(e, IDisposable).Dispose()\r\n         End If\r\n     End Try\r\n\r\n If E is known at compile time to implement IDisposable the loop becomes:\r\n\r\n     Dim e As E = c.GetEnumerator()\r\n     Try\r\n         Do While e.MoveNext()\r\n            dim controlVariable = e.Current\r\n            <loop body>\r\n         Loop\r\n     Finally\r\n         If Not e Is Nothing Then\r\n             CType(e, IDisposable).Dispose()\r\n         End If\r\n     End Try\r\n\r\n The exception to these forms is the existence of On Error in which case the Try/Finally\r\n block will be eliminated (instead the body of the Finally will immediately follow\r\n the end of the loop).\r\n ":"\r\n 为使用IEnumerable的每个重写a。 它的基本形式是:\r\n\r\n     Dim e为E=C.GetEnumerator()\r\n     Do While E.MoveNext()\r\n        controlVariable=e.电流\r\n        <循环体>\r\n     循环\r\n\r\n 为了支持一次性枚举器，编译器将生成代码来处理\r\n 循环终止后的枚举器。  只有当E实现IDisposable时，才能做到这一点。\r\n 此规则的一个例外是当E具体为IEnumerator时，在这种情况下\r\n 编译器将生成代码以动态查询枚举器以确定\r\n 如果它实现了IDisposable。\r\n\r\n 如果E是IEnumerator则循环变为:\r\n\r\n     Dim e作为IEnumerator=c.GetEnumerator（）\r\n     试试\r\n         Do While E.MoveNext()\r\n            dim controlVariable=e.电流\r\n            <循环体>\r\n         循环\r\n     最后\r\n         如果TryCast(e,IDisposable)是Nothing then\r\n             CType（e，IDisposable）。处置()\r\n         结束如果\r\n     结束尝试\r\n\r\n 如果在编译时已知E以实现IDisposable，则循环变为:\r\n\r\n     Dim e为E=C.GetEnumerator()\r\n     试试\r\n         Do While E.MoveNext()\r\n            dim controlVariable=e.电流\r\n            <循环体>\r\n         循环\r\n     最后\r\n         如果不是e什么也不是\r\n             CType（e，IDisposable）。处置()\r\n         结束如果\r\n     结束尝试\r\n\r\n 这些形式的例外是存在错误，在这种情况下，Try/Finally\r\n 块将被消除（而不是最后的身体将立即跟随\r\n 循环的结束）。\r\n \r\n","No overload for '{0}' matches function pointer '{1}'":"对于'{0}'匹配函数指针'{1}'没有过载\r\n","\r\n The \"Sub\" or \"Function\" keyword that introduces this method declaration.\r\n ":"\r\n 引入此方法声明的“ sub”或“函数”关键字。\r\n \r\n","\r\n Returns a copy of this with the ImplementsKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 将其返回使用instermentskeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Returns a sequence of preprocessor symbols specified in ":"\r\n 返回一系列预处理符号\r\n","The constant value that replaces this node, or nothing.":"替换该节点的常数值，或什么都没有。\r\n","\r\n The value for the RaiseEventKeyword property.\r\n ":"\r\n RaiseeVentKeyword属性的值。\r\n \r\n","\r\n Generate a thread-safe accessor for a field-like event.\r\n \r\n DelegateType tmp0 = _event; //backing field\r\n DelegateType tmp1;\r\n DelegateType tmp2;\r\n do {\r\n     tmp1 = tmp0;\r\n     tmp2 = (DelegateType)Delegate.Combine(tmp1, value); //Remove for -=\r\n     tmp0 = Interlocked.CompareExchange< DelegateType> (ref _event, tmp2, tmp1);\r\n } while ((object)tmp0 != (object)tmp1);\r\n \r\n Note, if System.Threading.Interlocked.CompareExchange<T> Is Not available,\r\n we emit the following code And mark the method Synchronized (unless it Is a struct).\r\n \r\n _event = (DelegateType)Delegate.Combine(_event, value); //Remove for -=\r\n \r\n ":"\r\n 为类似现场的事件生成线程安全登录器。\r\n \r\n 授权型TMP0 = _EVENT; //支持字段\r\n 授权型TMP1;\r\n 授权型TMP2;\r\n 做 {\r\n     TMP1 = TMP0;\r\n     tmp2 =（delegateType）delegate.combine（tmp1，value）; //删除 -  =\r\n     tmp0 = Interlocked.compareexchange <delegatetype>（ref _Event，tmp2，tmp1）;\r\n } while（（对象）tmp0！=（object）tmp1）;\r\n \r\n 注意，如果system.threading.interlocked.compareexchange <t>不可用，\r\n 我们发射以下代码并标记该方法同步（除非是结构）。\r\n \r\n _event =（delegateType）delegate.combine（_Event，value）; //删除 -  =\r\n \r\n \r\n"," are print to ":" 打印到\r\n","\r\n The Loop statement that ends the block.\r\n ":"\r\n 结束块的循环语句。\r\n \r\n","Additional information.":"附加信息。\r\n","Implement all interfaces explicitly":"明确实现所有接口\r\n","\r\n Given a namespace symbol, returns the corresponding module specific namespace symbol\r\n ":"\r\n 给定的名称空间符号，返回相应的模块特定名称空间符号\r\n \r\n","A void or int returning entry point cannot be async":"void或int返回的入口点不能呈异步\r\n","True if implicit line continuation is allowed after token.":"如果允许在令牌后允许隐式线延续。\r\n","\r\n Returns: negative value - when current lost, 0 - when neither lost, > 0 - when other lost.\r\n ":"\r\n 返回：负值 - 当电流丢失时，0-当其他损失时都不会丢失时，当丢失> 0时。\r\n \r\n","Cannot specify /main if there is a compilation unit with top-level statements.":"如果有带有顶级语句的汇编单元，则无法指定 /主。\r\n","\r\n Returns the list of custom modifiers, if any, associated with the type of the property. \r\n ":"\r\n 返回与属性类型关联的自定义修饰符列表。\r\n \r\n","\r\n  Looks up a localized string similar to Event '{0}' cannot implement event '{1}' on interface '{2}' because the parameters of their 'RemoveHandler' methods do not match..\r\n":"\r\n  在接口'{2}'上查找类似于事件'{0}'不能实现事件'{1}'的本地化字符串，因为其'removeHandler'方法的参数不匹配。\r\n\r\n","\r\n Represents the beginning statement of a Module declaration. This node always\r\n appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.\r\n ":"\r\n 代表模块声明的开始语句。这个节点总是\r\n 出现是带有bink = moduledeclarationBlock的类型块的开始。\r\n \r\n","\r\n The value for the Count property.\r\n ":"\r\n 计数属性的值。\r\n \r\n","With DateTime values, the \"zzz\" custom format specifier represents the signed offset of the local operating system's time zone from UTC, measured in hours and minutes. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, t ...":"使用DateTime值，“ ZZZ”自定义格式指定符表示本地操作系统时区的签名偏移，该时区与UTC的时区，以小时和分钟的量度进行测量。它不会反映实例dateTime.kind属性的值。因此，...\r\n","\r\n  Looks up a localized string similar to Only conversion operators can be declared '{0}'..\r\n":"\r\n  查找类似于转换操作员的本地化字符串可以声明为'{0}'..\r\n\r\n","\r\n An empty list means there was no IVT attribute with matching ":"\r\n 一个空列表意味着没有IVT属性与匹配\r\n","\r\n            The implementation has to decide what kinds of nodes in top-level match relationship represent a declaration.\r\n            Every member declaration must be represented by exactly one node, but not all nodes have to represent a declaration.\r\n            \r\n            TODO: consider implementing this via ":"\r\n            实施必须决定顶级匹配关系中哪些节点代表声明。\r\n            每个成员声明必须完全由一个节点表示，但并非所有节点都必须代表声明。\r\n            \r\n            TODO：考虑通过\r\n","\r\n if \"node\" argument is a BoundRaiseEvent, returns its underlying boundcall instead.\r\n Otherwise returns \"node\" unchanged.\r\n ":"\r\n 如果“节点”参数是一个界限，则返回其基础界限。\r\n 否则返回“节点”不变。\r\n \r\n","Metadata for the specified file.":"指定文件的元数据。\r\n","\r\n Returns a copy of this with the DelegateExpression property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中委托表达属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","The old pending branches/labels, which are to be merged with the current ones":"旧等待的分支/标签，将与当前的分支合并\r\n","async method builder override":"异步方法构建器覆盖\r\n"," representing the specific kind of CaseBlockSyntax. One\r\n of CaseBlock, CaseElseBlock.\r\n ":" 代表特定类型的caseBlocksyntax。一\r\n CaseBlock，CaseElseblock。\r\n \r\n","Remove unread private members":"删除未读的私人成员\r\n","\r\n  Looks up a localized string similar to 'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to a Sub, Function, or Operator with a non-empty body..\r\n":"\r\n  查找类似于“ system.runtime.interopservices.dllimportattribute”的本地化字符串，不能应用于具有非空白的子，功能或操作员。\r\n\r\n","\r\n            An optional set of additional locations related to the diagnostic.\r\n            Typically, these are locations of other items referenced in the message.\r\n            ":"\r\n            一组与诊断有关的其他位置。\r\n            通常，这些是消息中引用的其他项目的位置。\r\n            \r\n","\r\n            Looks for expressions of the form ":"\r\n            寻找表格的表达\r\n","\r\n Represents a local variable (typically inside a method body). This could also be a local variable implicitly\r\n declared by a For, Using, etc. When used as a temporary variable, its container can also be a Field or Property Symbol.\r\n ":"\r\n 表示局部变量（通常在方法主体内部）。这也可能是隐性的局部变量\r\n 由for，使用等声明。当用作临时变量时，其容器也可以是字段或属性符号。\r\n \r\n","\r\n            Interface for types that can wrap some sort of language construct.\r\n            ":"\r\n            可以包装某种语言构造的类型的接口。\r\n            \r\n","\r\n            Return true if the declaration is a property accessor for a property that represents one of the parameters in a records primary constructor.\r\n            ":"\r\n            返回true如果声明是代表记录主构造函数中一个参数之一的属性的属性登录器。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Next' expected..\r\n":"\r\n  查找类似于“下一个”预期的本地化字符串。\r\n\r\n"," Method, field or property symbol ":" 方法，字段或属性符号\r\n","\r\n Matches an attribute by metadata namespace, metadata type name. Does not load the type symbol for\r\n the attribute.\r\n ":"\r\n 匹配元数据名称空间，元数据类型名称的属性。不加载类型符号\r\n 属性。\r\n \r\n","Updating an active statement requires restarting the application.":"更新活动语句需要重新启动应用程序。\r\n","\r\n  Looks up a localized string similar to Invalid output name: {0}.\r\n":"\r\n  查找类似于无效输出名称的本地化字符串：{0}。\r\n\r\n","\r\n            Add-using gets special privileges as being the most used code-action, along with being a core\r\n            'smart tag' feature in VS prior to us even having 'light bulbs'.  We want them to be computed\r\n            first, ahead of everything else, and the main results should show up at the top of the list.\r\n            ":"\r\n            Add-using作为最常用的代码操作获得特殊特权，同时也是核心\r\n            \"智能标签\"功能在VS之前，我们甚至有\"灯泡\"。  我们希望它们被计算出来\r\n            首先，领先于其他一切，主要结果应该显示在列表的顶部。\r\n            \r\n","\r\n Attempt to retrieve the specified special member, reporting a use-site diagnostic if the member is not found.\r\n ":"\r\n 尝试检索指定的特殊成员，如果找不到该成员，则报告使用站点诊断。\r\n \r\n","Dim x = FROM {1, 2, 3}":"dim x =来自{1、2、3}\r\n","\r\n The While statement that begins a While...End While block. This statement\r\n always occurs as the Begin of a WhileBlock.\r\n ":"\r\n 开始一段时间的句子陈述...结束时块。这个说法\r\n 总是作为wherblock的开始。\r\n \r\n"," \r\n Builds a condition in the following form: \r\n \r\n [preaction: localMyFieldBoxed = DirectCast(Me.field, System.Object)]\r\n [preaction: localOtherFieldBoxed = DirectCast(Other.field, System.Object)]\r\n IF(localMyFieldBoxed IsNot Nothing AndAlso localOtherFieldBoxed IsNot Nothing,\r\n    localMyFieldBoxed.Equals(localOtherFieldBoxed),\r\n    localMyFieldBoxed Is localOtherFieldBoxed\r\n ) \r\n ":" \r\n 以以下形式构建条件：\r\n \r\n [preaction：localmyfieldboxed = directcast（me.field，system.Object）]\r\n [preaction：localotherfieldboxed = directcast（other.field，system.Object）]\r\n 如果（localmyfieldboxed并不一无所有\r\n    localmyfieldboxed.equals（localotherfieldboxed），\r\n    LocalMyFieldBoxed是LocalotherFieldBoxed\r\n ）\r\n \r\n"," from a sequence of else-if clauses, preserving any subsequent clauses.\r\n            ":" 从一系列else-if子句中保留任何后续子句。\r\n            \r\n","\r\n            Base type for the C# and VB wrapping refactorings.  The only responsibility of this type is\r\n            to walk up the tree at the position the user is at, seeing if any node above the user can be\r\n            wrapped by any provided ":"\r\n            C＃和VB包装重构的基本类型。这种类型的唯一责任是\r\n            要在用户所处的位置上行走树，看看用户上方是否可以是\r\n            被任何提供的\r\n","\r\n Intended to be used to create ParameterSymbols for a SignatureOnlyMethodSymbol.\r\n ":"\r\n 打算用于为签名的yllyMethodSymbol创建参数符号。\r\n \r\n","\r\n            Provides APIs to enumerate and look up assemblies stored in the Global Assembly Cache.\r\n            ":"\r\n            提供API来枚举并查找存储在全局组装缓存中的组件。\r\n            \r\n","'s. \r\n            Providers are used with some ":"'\r\n            提供者与一些\r\n","Modules":"模块\r\n","The method group with the only method in it.":"具有其中唯一方法的方法组。\r\n","\r\n            Get the fix multiple occurrences code fix for the given diagnostics with source locations.\r\n            NOTE: This method does not apply the fix to the workspace.\r\n            ":"\r\n            获取使用源位置的给定诊断的多个出现代码修复。\r\n            注意：此方法不将修复程序应用于工作空间。\r\n            \r\n","unchecked statement":"未检查的声明\r\n",", and the other a ":"，另一个\r\n","Method's fully qualified name":"方法的完全合格的名称\r\n","from {0}":"来自{0}\r\n","Simplify collection initialization":"简化收集初始化\r\n","\r\n  Looks up a localized string similar to '#End ExternalSource' must be preceded by a matching '#ExternalSource'..\r\n":"\r\n  查找类似于“ #end externalsource”的本地化字符串必须先于匹配的“ #externalsource”。\r\n\r\n","\r\n            Mark container nodes with our annotation so we can keep track of them across syntax modifications.\r\n            ":"\r\n            用我们的注释标记容器节点，以便我们可以在语法修改中跟踪它们。\r\n            \r\n","\r\n  Looks up a localized string similar to Delegates cannot implement interface methods..\r\n":"\r\n  查找类似于代表的本地化字符串无法实现接口方法。\r\n\r\n","\r\n            Given a search within a particular project, this returns any documents within that project that should take\r\n            precedence when searching.  This allows results to get to the user more quickly for common cases (like using\r\n            nav-to to find results in the file you currently have open\r\n            ":"\r\n            给定特定项目中的搜索，这返回该项目中应采取的任何文档\r\n            搜索时的优先级。这允许结果更快地与常见情况获得用户（例如使用\r\n            nav-to查找您当前已打开的文件中的结果\r\n            \r\n"," Reference to an expression from With statement ":" 引用语句的表达\r\n","\r\n The \"SyncLock\" keyword.\r\n ":"\r\n “ Synclock”关键字。\r\n \r\n","Updating the type of {0} requires restarting the application.":"更新{0}的类型需要重新启动应用程序。\r\n","\r\n Represents the beginning of a #ExternalSource pre-processing directive\r\n appearing in source.\r\n ":"\r\n 代表#ExternalSource预处理指令的开始\r\n 出现在源中。\r\n \r\n","Apply expression/block body preferences":"应用表达/障碍物的偏好\r\n","\r\n            Filters and orders the code fix sets and code refactoring sets amongst each other.\r\n            Should be called with the results from ":"\r\n            过滤器和订购代码修复集和代码重构集相互之间。\r\n            应与\r\n","\r\n Get the instance constructors for this type.\r\n ":"\r\n 获取此类型的实例构造函数。\r\n \r\n","Type \"#help\" for more information.":"键入“ #help”以获取更多信息。\r\n","{0} '{1}'":"{0}'{1}'\r\n","\r\n Returns a copy of this with the WhenFalse property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，并使用whesfalse属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","Updating the Handles clause of {0} requires restarting the application.":"更新{0}的句柄条款需要重新启动应用程序。\r\n","Optional set of roles associated with the editor state.":"与编辑状态关联的可选角色集。\r\n","\r\n            Information about the callee method parameters to compute ":"\r\n            有关计算的Callee方法参数的信息\r\n","\r\n Returns a copy of this with the Minus property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，减去属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","Pick members to be used in Equals/GetHashCode":"挑选以等于/gethashcode使用的成员\r\n","\r\n A collection of the local variables that are read outside the region.\r\n ":"\r\n 本地变量的集合，这些变量在区域之外读取。\r\n \r\n","Relational patterns may not be used for a floating-point NaN.":"关系模式不得用于浮点NAN。\r\n","\r\n The QuickAttributeChecker applies a simple fast heuristic for determining probable\r\n attributes without binding attribute types, just by looking at the final syntax of an \r\n attribute usage. It is accessed via the QuickAttributeChecker property on Binder.\r\n ":"\r\n QuickAttributeChecker适用一个简单的快速启发式方法来确定可能\r\n 仅通过查看一个最终语法，没有绑定属性类型的属性\r\n 属性用法。它可以通过Binder上的QuickAttributechecker属性访问。\r\n \r\n","\r\n Gets the value of the first 'name' attribute on the element, returns Nothing in case \r\n the attribute was not found or has an invalid value, reports necessary diagnostics in \r\n the latest case\r\n ":"\r\n 获取元素上第一个“名称”属性的值，以防万一\r\n 该属性未找到或具有无效的值，报告必要的诊断\r\n 最新情况\r\n \r\n","\r\n  Looks up a localized string similar to 'End Sub' expected..\r\n":"\r\n  查找类似于“ End sub”预期的本地化字符串。\r\n\r\n","\r\n Returns a copy of this with the Filter property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，过滤属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n            Project hasn't been changed.\r\n            ":"\r\n            项目尚未更改。\r\n            \r\n","\r\n Represents a declaration of a Class its contents and the End statement that\r\n ends it.\r\n ":"\r\n 代表班级的声明，其内容和最终声明\r\n 结束它。\r\n \r\n","Special Type to get.":"特殊类型要获得。\r\n","\r\n            Returns true when the input position could be starting an interpolated string if opening quotes were typed.\r\n            ":"\r\n            当输入位置可以启动插值字符串时，返回true。\r\n            \r\n","\r\n Generate implementation-specific state machine member method implementations.\r\n ":"\r\n 生成实现特定状态机器成员方法实现。\r\n \r\n","\r\n            Responsible for actually computing the set of potential wrapping options\r\n            for chained expressions.  The three options we offer are basically\r\n            1. wrap-each. Each chunk will be wrapped and aligned with the first chunk.\r\n            2. wrap-long. The same as '1', except a chunk will only be wrapped\r\n               if it would go past the preferred wrapping column.\r\n            3. Unwrap.  All the chunks will be placed on a single line.\r\n            \r\n            Note: These three options are always computed and returned.  The caller\r\n            is the one that ends up eliminating any if they would be redundant.  i.e.\r\n            if wrap-long produces the same results as wrap-each, then the caller will\r\n            filter it out.\r\n            ":"\r\n            负责实际计算一组潜在包装选项\r\n            用于链式表情。我们提供的三个选项基本上是\r\n            1.包裹。每个块将被包裹并与第一个块对齐。\r\n            2.包裹长。与“ 1”相同，除了只包装块\r\n               如果它将超过首选包装列。\r\n            3.解开。所有块将放在一条线上。\r\n            \r\n            注意：这三个选项始终是计算和返回的。呼叫者，召集者\r\n            如果它们是多余的，则最终消除了任何一个。 IE。\r\n            如果包裹长的结果与Wrap-e EACH产生相同的结果，那么呼叫者将\r\n            过滤出来。\r\n            \r\n",", \r\n 3) methods marked by ":"，，，，\r\n 3）标记的方法\r\n","negative character range":"负字符范围\r\n","Avoid unnecessary value assignments in your code, as these likely indicate redundant value computations. If the value computation is not redundant and you intend to retain the assignment, then change the assignment target to a local variable whose name sta ...":"避免在代码中避免不必要的价值分配，因为这些可能表示冗余的价值计算。如果价值计算不是冗余的，并且您打算保留分配，则将分配目标更改为名称sta ...的本地变量。\r\n","\r\n            Tells if the member access is dynamically invoked and cannot be reduced. In the case of\r\n            ":"\r\n            告诉会员访问是否动态调用，无法减少。如果是\r\n            \r\n","\r\n     Parameter -> Attributes? ParameterModifiers* ParameterIdentifier (\"as\" TypeName)? (\"=\" ConstantExpression)?\r\n ":"\r\n     参数 - >属性？ parametermodifier*参数识别器（“为“ TypeName）？ （“ =”常数表达）？\r\n \r\n","\r\n            Determines if the actual file path matches its logical path in project \r\n            which is constructed as [project_root_path]\\Logical\\Folders\\. The refactoring \r\n            is triggered only when the two match. The reason of doing this is we don't really know\r\n            the user's intention of keeping the file path out-of-sync with its logical path.\r\n            ":"\r\n            确定实际文件路径是否与项目中的逻辑路径匹配\r\n            构建为[Project_Root_Path] \\逻辑\\文件夹\\。重构\r\n            仅在两次匹配时才触发。这样做的原因是我们真的不知道\r\n            用户的目的是将文件路径与逻辑路径保持不同步。\r\n            \r\n","\r\n  Looks up a localized string similar to Cannot inherit interface '{0}' because it could be identical to interface '{1}' from which the interface '{2}' inherits for some type arguments..\r\n":"\r\n  查找类似于无法继承界面'{0}'的本地化字符串，因为它可能与接口'{1}'相同，从中界面'{2}'继承了某种类型的参数。\r\n\r\n","\r\n Implicitly declared variable (w/o variable declaration).\r\n ":"\r\n 隐式声明为变量（w/o变量声明）。\r\n \r\n","\r\n  Looks up a localized string similar to Type '{0}' cannot be embedded because it has generic argument. Consider disabling the embedding of interop types..\r\n":"\r\n  查找类似于“ {0}”类型的本地化字符串，因为它具有通用参数。考虑禁用Interop类型的嵌入。\r\n\r\n","\r\n Returns custom modifiers for the type arguments that have been substituted for the type parameters. \r\n ":"\r\n 返回已替换为类型参数的类型参数的自定义修饰符。\r\n \r\n","The kind of the section. Use ":"该部分的种类。利用\r\n","\r\n            Returns ids of documents for which diagnostics need to be refreshed in-proc.\r\n            ":"\r\n            返回的文档ID需要在该文档中进行诊断，以便在该文档内进行刷新。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Resume' or 'GoTo' expected..\r\n":"\r\n  查找类似于“简历”或“ goto”的局部字符串。\r\n\r\n","Move declaration near reference":"移动声明接近参考\r\n","\r\n            Language specific option that can be used to configure the given ":"\r\n            语言特定的选项，可用于配置给定\r\n","-indexer, and a ":" -  indexer和a\r\n","\r\n Collect user-defined operators.\r\n Operators declared in the same type are grouped together. \r\n Within a group, name1 operators are followed by name2 operators.\r\n ":"\r\n 收集用户定义的操作员。\r\n 以同一类型声明的操作员分组在一起。\r\n 在组中，NAME1运营商之后是NAME2运算符。\r\n \r\n","\r\n            Message for the diagnostic descriptor.\r\n            Null if the message is identical to the title.\r\n            ":"\r\n            诊断描述符的消息。\r\n            null如果消息与标题相同。\r\n            \r\n","\r\n Gets the inferred type of this const field from the initialization value.\r\n ":"\r\n 从初始化值获取此const字段的推断类型。\r\n \r\n","The type of the trivia list.":"琐事列表的类型。\r\n","\r\n            Provides active statement spans within the specified document of a solution.\r\n            ":"\r\n            提供在解决方案的指定文档中提供主动语句跨度。\r\n            \r\n","\r\n            Note: this type is for subclassing by the VB and C# provider only.\r\n            It presumes that the language supports Syntax Trees.\r\n            ":"\r\n            注意：此类型仅用于VB和C＃提供商的子类别。\r\n            它假定该语言支持语法树。\r\n            \r\n"," WARNING: used ONLY in DEBUG ":" 警告：仅用于调试\r\n","\r\n Analyzes method body that belongs to the given method symbol.\r\n ":"\r\n 分析属于给定方法符号的方法主体。\r\n \r\n","Anonymous Types:":"匿名类型：\r\n","\r\n Rewrite an iterator method into a state machine class.\r\n ":"\r\n 将迭代方法重写为状态计算机类。\r\n \r\n","Snippets":"摘要\r\n","\r\n Extension method type parameters that were fixed during currying, if any.\r\n If none were fixed, BitArray.Null should be returned. \r\n ":"\r\n 扩展方法类型的参数在咖喱期间固定（如果有）。\r\n 如果没有修复，则应返回bitarray.null。\r\n \r\n","\r\n  Looks up a localized string similar to Indirect constraint '{0}' obtained from the type parameter constraint '{1}' conflicts with the indirect constraint '{2}' obtained from the type parameter constraint '{3}'..\r\n":"\r\n  查找与从类型参数约束'{1}'获得的间接约束'{0}'相似的本地化字符串，与从类型参数约束'{3}'..获得的间接约束'{2}'冲突。\r\n\r\n","\r\n Perform a check whether the type or at least one of its generic arguments \r\n is an explicitly defined local type. The check is performed recursively. \r\n ":"\r\n 执行检查类型还是至少一种通用参数\r\n 是明确定义的本地类型。检查是递归执行的。\r\n \r\n",".\r\n                6. If property, then it must not be an explicit interface property implementation.\r\n                7. If event, then it must not be an explicit interface event implementation.\r\n            ":".\r\n                6. 如果属性，那么它不能是一个显式的接口属性实现。\r\n                7. 如果事件，那么它不能是一个显式的接口事件实现。\r\n            \r\n","\r\n Helper function that visits the given expression and returns a BoundExpression.\r\n Please use this instead of DirectCast(Visit(expression), BoundExpression)\r\n ":"\r\n 访问给定表达式并返回BoundExpression的Helper函数。\r\n 请用这个代替DirectCast(Visit(expression),BoundExpression)\r\n \r\n","\r\n            trivia to place at the end of a node prior to a chunk that is wrapped.\r\n            For C# this will just be a newline.  For VB this will include a line-\r\n            continuation character.\r\n            ":"\r\n            琐事在包裹的大块之前放在节点的末尾。\r\n            对于C＃，这将是一个新线。对于VB，这将包括一条线 - \r\n            延续特征。\r\n            \r\n","\r\n Bind a generic name to a type.\r\n ":"\r\n 将通用名称绑定到类型。\r\n \r\n","\r\n If this is a partial method declaration without a body, and the method also\r\n has a part that implements it with a body, returns that implementing\r\n definition.  Otherwise null.\r\n ":"\r\n 如果这是没有身体的部分方法声明，则该方法也\r\n 具有将其实现的零件，返回实施\r\n 定义。否则为空。\r\n \r\n","\r\n            Creates a resolver that uses the current platform settings (GAC, platform assembly list).\r\n            ":"\r\n            创建使用当前平台设置（GAC，平台汇编列表）的解析器。\r\n            \r\n","\r\n When binding a name X that was declared with a \"using X=OtherTypeOrNamespace\", return OtherTypeOrNamespace.\r\n ":"\r\n 在用“使用x = earthtypeornamespace”声明的名称x绑定x时，请返回其他typeornamespace。\r\n \r\n","\r\n If a namespace has Assembly or Compilation extent, it may be composed of multiple\r\n namespaces that are merged together. If so, ConstituentNamespaces returns\r\n all the namespaces that were merged. If this namespace was not merged, returns\r\n an array containing only this namespace.\r\n ":"\r\n 如果名称空间具有组装或编译范围，则可以由多个组成\r\n 合并在一起的名称空间。如果是这样，ConstituentNamespaces返回\r\n 合并的所有名称空间。如果没有合并此名称空间，请返回\r\n 仅包含此名称空间的数组。\r\n \r\n","\r\n Represents a property parameter that has undergone type substitution.\r\n ":"\r\n 代表具有经过类型替代的属性参数。\r\n \r\n","Making a method asynchronous requires restarting the application.":"制作方法异步需要重新启动应用程序。\r\n","\r\n A tricky problem is reporting the \"Variable 'x' hides a variable in an enclosing block\" message if the variable in\r\n an enclosing block is an implicit variable that hasn't been declared yet. We handle this by remembering any variable\r\n declarations in enclosed blocks, and then report the error when the implicit variable is declared.\r\n ":"\r\n 一个棘手的问题是报告“变量'x”将变量隐藏在封闭块中的变量，如果变量在\r\n 封闭块是尚未声明的隐式变量。我们通过记住任何变量来处理这一点\r\n 封闭块中的声明，然后在声明隐式变量时报告错误。\r\n \r\n","Autoselect disabled due to possible deconstruction declaration.":"由于可能的解构声明，自动选择禁用。\r\n",",\r\n            since different semantic edits might have been calculated against different solution snapshot and thus symbols are not directly comparable.\r\n            When the edits are processed we map the ":"，，，，\r\n            由于可能已经针对不同的解决方案快照计算了不同的语义编辑，因此符号不能直接可比。\r\n            处理编辑时，我们映射\r\n"," that is responsible for retargeting symbols from one assembly to another. \r\n It can retarget symbols for multiple assemblies at the same time.\r\n \r\n Here is how retargeting is implemented in general:\r\n - Symbols from underlying module are substituted with retargeting symbols.\r\n - Symbols from referenced assemblies that can be reused as is (i.e. don't have to be retargeted) are\r\n   used as is.\r\n - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.\r\n ":" 这是为了将符号从一个组件重新定位到另一个组件。\r\n 它可以同时重新定位多个组件。\r\n \r\n 这是如何实施重新定位的方式：\r\n  - 基础模块的符号用重新定位符号代替。\r\n  - 可以按原样重复使用的参考组件的符号（即不必重新定位）是\r\n   按原样使用。\r\n  - 必须重新定位的参考组件中的符号被重新定位的结果代替。\r\n \r\n","\r\n Specifies whether or not method's ByRef parameters should be analyzed. If there's more than one location in\r\n the method being analyzed, then the method is partial and we prefer to report an out parameter in partial\r\n method error.\r\n Note: VB doesn't support \"out\" so it doesn't warn for unassigned parameters. However, check variables passed\r\n byref are assigned so that data flow analysis detects parameters flowing out.\r\n ":"\r\n 指定是否应分析方法的BYREF参数。如果有多个位置\r\n 进行分析的方法，然后该方法是部分的，我们更喜欢部分报告一个OUT参数\r\n 方法错误。\r\n 注意：VB不支持“输出”，因此不会警告未分配的参数。但是，检查变量通过\r\n 分配BYRF，以便数据流分析检测流出的参数。\r\n \r\n","\r\n Check that the syntax can appear in an attribute argument.\r\n ":"\r\n 检查语法是否可以出现在属性参数中。\r\n \r\n","\r\n            Determines whether projects contain any changes that might need to be applied.\r\n            Checks only projects containing a given ":"\r\n            确定项目是否包含可能需要应用的任何更改。\r\n            仅检查包含给定的项目\r\n","Method that contains lambda expression for which we do the rewrite.":"包含lambda表达式的方法，我们要重写。\r\n","\r\n            Cache of document EnC analyses. \r\n            ":"\r\n            文档的缓存ENC分析。\r\n            \r\n","\r\n Returns a copy of this with the HandlesKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中handleskeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n The \"End Sub\" statement that ends the block declaration.\r\n ":"\r\n 结束块声明的“终结子”声明。\r\n \r\n","\r\n String \"ReadOnly\", \"WriteOnly\", or \"\" describing the kind of property.\r\n ":"\r\n 字符串“ readonly”，“ writeonly”或“”描述属性类型。\r\n \r\n","\r\n            Gets the change to be applied when the item is committed.\r\n            ":"\r\n            在投入项目时获取要应用的更改。\r\n            \r\n","\r\n  Looks up a localized string similar to Comma or ')' expected..\r\n":"\r\n  查找类似于逗号或'）的局部字符串。\r\n\r\n","\r\n This helper is used to wrap nullable argument into something that would return null string if argument is null.\r\n\r\n Unlike conversion to a string where nullable nulls result in an exception,         \r\n concatenation requires that nullable nulls are treated as null strings. \r\n Note that conversion is treated as explicit conversion.\r\n ":"\r\n 该助手用于将无效的参数包装到如果参数为null时将返回null字符串的事物。\r\n\r\n 与转换为一个符号，可为nulls导致异常的字符串不同，\r\n 串联要求将无效的零子视为空字符串。\r\n 请注意，转换被视为显式转换。\r\n \r\n","<value>":"<value>\r\n","time zone":"时区\r\n","\r\n Represents a simple, compound, or Mid assignment statement. Which one can be\r\n determined by checking the Kind.\r\n ":"\r\n 代表简单，复合或中期分配语句。哪一个可以\r\n 通过检查类型来确定。\r\n \r\n","\r\n Returns a copy of this with the Constraint property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中约束属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Returns the referenced ":"\r\n 返回引用\r\n","\r\n Check that the given variable is definitely assigned.  If not, produce an error.\r\n ":"\r\n 检查给定变量是否已分配。如果没有，请产生错误。\r\n \r\n","\r\n Get the following trivia nodes of this node. If this node is a token, returns the following trivia\r\n associated with this node. If this is a non-terminal, returns the following trivia of the last token\r\n of this node. \r\n ":"\r\n 获取此节点的以下琐事节点。如果此节点是令牌，请返回以下琐事\r\n 与此节点相关联。如果这是非末端，则返回最后一个令牌的以下琐事\r\n 这个节点。\r\n \r\n","\r\n first.Where(t IsNot Nothing).Concat(second.Where(t IsNot Nothing))\r\n ":"\r\n 首先。\r\n \r\n","\r\n Returns the default value of this parameter. If ":"\r\n 返回此参数的默认值。如果\r\n","The matching symbol from the correct solution or null":"正确解决方案或空的匹配符号\r\n","In general, statements are considered multiline if any of the following span more than one line:":"通常，如果以下任何一行多一行，则认为陈述是多行的：\r\n","\r\n  Looks up a localized string similar to 'Get' is already declared..\r\n":"\r\n  查找类似于“ get”的本地化字符串已被声明。\r\n\r\n","Convert to block scoped namespace":"转换为块范围命名空间\r\n","\r\n            Check whether the currentToken is a comma and is a delimiter between arguments inside a tuple expression.\r\n            ":"\r\n            检查CurrentToken是否是逗号，并且是元组表达式中的参数之间的定界符。\r\n            \r\n","Remove qualification":"删除资格\r\n","\r\n The value for the EndSelectStatement property.\r\n ":"\r\n EndSelectStatement属性的值。\r\n \r\n","\r\n            Searches for namespaces that match the name the user has written.  Returns ":"\r\n            搜索与用户编写的名称匹配的名称空间。返回\r\n","The symbol that was declared, or Nothing if no such symbol exists.":"声明的符号，或者如果不存在这样的符号。\r\n","\r\n A collection of the local variables that are declared within the region. Note that the region must be \r\n bounded by a method's body or a field's initializer, so parameter symbols are never included in the result.\r\n ":"\r\n 该区域内声明的本地变量的集合。请注意，该地区必须是\r\n 在方法的主体或字段的初始化器中，因此结果符号永远不会包含在结果中。\r\n \r\n","\r\n            Event to get notified as new diagnostics are discovered by IDiagnosticUpdateSource\r\n            \r\n            Notifications for this event are serialized to preserve order.\r\n            However, individual event notifications may occur on any thread.\r\n            ":"\r\n            事件得到通知，因为IdiNaSticupDatesource发现了新诊断。\r\n            \r\n            此事件的通知被序列化以保存订单。\r\n            但是，任何线程上都可能发生单个事件通知。\r\n            \r\n","\r\n Collect user-defined conversion operators.\r\n Operators declared in the same type are grouped together. \r\n Within a group, widening operators are followed by narrowing operators.\r\n ":"\r\n 收集用户定义的转换操作员。\r\n 以同一类型声明的操作员分组在一起。\r\n 在一个小组中，加宽操作员之后是缩小操作员。\r\n \r\n","\r\n Determines if two syntax tokens are the same, disregarding trivia differences.\r\n ":"\r\n 确定两个语法令牌是否相同，无视琐事差异。\r\n \r\n","\r\n Creates a separated list of nodes from a sequence of nodes and a sequence of separator tokens.\r\n ":"\r\n 从一系列节点和一系列分离器令牌中创建一个分离的节点列表。\r\n \r\n","\r\n            The contents of the documents we've created code-actions for.  This is used so that\r\n            we can prevent creating multiple code actions that produce the same results.\r\n            ":"\r\n            我们为代码actions创建的文档的内容。这是为了\r\n            我们可以防止创建产生相同结果的多个代码操作。\r\n            \r\n","\r\n The type of the return value of this visitor's Visit method.\r\n ":"\r\n 此访问者访问方法的返回值的类型。\r\n \r\n","\r\n The value for the LibraryName property.\r\n ":"\r\n LibraryName属性的值。\r\n \r\n","\r\n Gets the merged root namespace that contains all namespaces and types defined in the modules\r\n of this assembly. If there is just one module in this assembly, this property just returns the \r\n GlobalNamespace of that module.\r\n ":"\r\n 获取包含模块中定义的所有名称空间和类型的合并根名称空间\r\n 这个组装。如果此组件中只有一个模块，则此属性只会返回\r\n 该模块的全局名称空间。\r\n \r\n","\r\n This instance is used to compare potential WinRT fake events in type projection.\r\n \r\n FIXME(angocke): This is almost certainly wrong. The semantics of WinRT conflict \r\n comparison should probably match overload resolution (i.e., we should not add a member\r\n  to lookup that would result in ambiguity), but this is closer to what Dev12 does.\r\n \r\n The real fix here is to establish a spec for how WinRT conflict comparison should be\r\n performed. Once this is done we should remove these comments.\r\n ":"\r\n 此实例用于比较类型投影中潜在的WinRT假事件。\r\n \r\n FixMe（Angocke）：这几乎可以肯定是错误的。 Winrt冲突的语义\r\n 比较可能应匹配超载分辨率（即，我们不应添加成员\r\n  查找会导致歧义），但这更接近Dev12的作用。\r\n \r\n 这里的真正解决方案是建立一个规范Winrt冲突应该如何比较\r\n 执行。完成此操作后，我们应该删除这些评论。\r\n \r\n","\r\n Returns information about the reason that this type is in error.\r\n ":"\r\n 返回有关此类型出错的原因的信息。\r\n \r\n","\r\n            True if the node represents any form of a function definition nested in another function body (i.e. anonymous function, lambda, local function).\r\n            ":"\r\n            如果节点表示嵌套在另一个函数主体中的任何形式的函数定义（即匿名函数，lambda，本地函数）。\r\n            \r\n","\r\n The base class for all nodes that represent statements. This includes both\r\n declaration statements, such as class declarations as well as executable\r\n statements.\r\n ":"\r\n 所有表示语句的节点的基类。这两者都包括\r\n 声明声明，例如班级声明以及可执行文件\r\n 语句。\r\n \r\n","\r\n Perform data flow analysis, reporting all necessary diagnostics.\r\n ":"\r\n 执行数据流分析，报告所有必要的诊断。\r\n \r\n","\r\n            Gets a description for the inline hint, suitable to show when a user hovers over the editor adornment.  The\r\n            ":"\r\n            获取有关内联提示的描述，适合在用户徘徊在编辑器上时显示。这\r\n            \r\n","\r\n            The change to be applied to the document when a ":"\r\n            当\r\n","Use pattern matching (may change code meaning)":"使用模式匹配（可能会更改代码含义）\r\n"," for the first invocation.\r\n            ":" 第一个调用。\r\n            \r\n","\r\n            Returns the specified argument index that the provided position is at in the current document.  This \r\n            index may be greater than the number of arguments in the selected ":"\r\n            返回指定的参数索引，即提供的位置位于当前文档中。这个\r\n            索引可能大于所选参数数量\r\n","\r\n  Looks up a localized string similar to Debug entry point must be a definition of a method declared in the current compilation..\r\n":"\r\n  查找类似于调试入口点的本地化字符串必须是当前汇编中声明的方法的定义。\r\n\r\n","\r\n Constructs a concrete frame type if needed.\r\n ":"如果需要，构造混凝土框架类型。\r\n \r\n"," that have a parameter called\r\n            'pattern'.  These are helpers (like ":"具有称为参数的\r\n            '图案'。这些是帮助者（例如\r\n","\r\n True if the type has declarative security information (HasSecurity flags).\r\n ":"\r\n 如果类型具有声明性安全信息（Hassecurity标志），则为正确。\r\n \r\n","\r\n Creates a syntax node for a name attribute in a xml element within a xml documentation comment.\r\n ":"\r\n 在XML文档注释中，在XML元素中为名称属性创建语法节点。\r\n \r\n","\r\n Represents the beginning statement of a Interface declaration. This node always\r\n appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.\r\n ":"\r\n 代表接口声明的开始语句。这个节点总是\r\n 出现是带有interfaceclarationBlock的类型块的开始。\r\n \r\n","\r\n            Creates a linq invocation expression for the ":"\r\n            为\r\n","Pick members to override":"选择成员替代\r\n","\r\n Only WithEvent property may have any attributes applied on its backing field.\r\n ":"\r\n 只有withEvent属性才能在其备份字段上应用任何属性。\r\n \r\n","Use 'System.HashCode'":"使用“ system.hashcode”\r\n","This is in/out.  It comes in with sizes from explicit bounds but will be updated based on the number of initializers for dimensions without bounds":"这是进出的。它带有明确界限的大小，但将根据尺寸的初始化数量进行更新\r\n","\r\n Returns a copy of this with the ControlVariables property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，而ControlVariables属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            Base type of all non-trivia ```(...)``` nodes\r\n            ":"\r\n            所有非裂缝的基本类型````（...）``节点'\r\n            \r\n","\r\n            Gets or sets the default argument value.\r\n            ":"\r\n            获取或设置默认参数值。\r\n            \r\n"," sequence.\r\n            ":" 序列。\r\n            \r\n","\r\n True if this symbol has been marked with the Obsolete attribute. \r\n This property returns Unknown if the Obsolete Attribute hasn't been cracked yet.\r\n ":"\r\n 如果已标记了该符号，则为exultectute属性。\r\n 该属性是否尚未破解该属性是否尚未破解。\r\n \r\n","\r\n The value for the Operand property.\r\n ":"\r\n 操作数属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to Extension method '{0}' has type constraints that can never be satisfied..\r\n":"\r\n  查找类似于扩展方法'{0}'的本地化字符串具有永远无法满足的类型约束。\r\n\r\n","\r\n Checks if two interfaces have a base-derived relationship\r\n ":"\r\n 检查两个接口是否具有碱性关系\r\n \r\n","\r\n Create assignment expressions initializing for this capture, is only supposed to be\r\n used for proper handling of reference assignments\r\n ":"\r\n 创建本捕获初始化的作业表达式，只应该是\r\n 用于正确处理参考作业\r\n \r\n","\r\n            Tries to build a specific converter that covers e.g. Count, ToList, yield return or other similar cases.\r\n            ":"\r\n            试图构建一个涵盖例如计数，宽容，收益率或其他类似情况。\r\n            \r\n","\r\n The \"Lib\" keyword.\r\n ":"\r\n “ lib”关键字。\r\n \r\n",".\r\n            Priority for all ":"。\r\n            所有人的优先级\r\n","\r\n Returns the syntax node that declares the variable.\r\n ":"\r\n 返回声明变量的语法节点。\r\n \r\n","== ":"==\r\n"," is cached and reused across completion sessions. \r\n             This might be used by completion system for things like deciding whether it can safely cache and reuse\r\n             other data corresponding to this item.\r\n            \r\n             TODO: Revisit the approach we used for caching VS items.\r\n                   https://github.com/dotnet/roslyn/issues/35160\r\n             ":" 在完成会议上被缓存和重复使用。\r\n             完成系统可能会用于确定是否可以安全缓存和重复使用等事情\r\n             与此项目相对应的其他数据。\r\n            \r\n             TODO：重新访问我们用于缓存与项目的方法。\r\n                   https://github.com/dotnet/roslyn/issues/35160\r\n             \r\n","3 is int i":"3是我\r\n","\r\n            String to display in the lightbulb menu.\r\n            ":"\r\n            在灯泡菜单中显示的字符串。\r\n            \r\n","\r\n Returns a copy of this with the WithEventsContainer property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中withEventsContainer属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n If the Using statement is of a form that does not declare a new variable, this\r\n is the expression used in the using. Otherwise, Nothing is returned.\r\n ":"\r\n 如果使用语句是未声明新变量的表单，则\r\n 是使用中使用的表达式。否则，什么都不会返回。\r\n \r\n","\r\n Represents a declaration of a Class, Interface, Structure, Module, its contents\r\n and the End statement that ends it.\r\n ":"\r\n 代表一类，界面，结构，模块，其内容的声明\r\n 以及结束它的最终声明。\r\n \r\n","\r\n Spill an expression list with a receiver (e.g. array access, method call), \r\n where at least one of the receiver or the arguments contains an await expression.\r\n ":"\r\n 用接收器溢出表达式列表（例如，数组访问，方法调用），\r\n 至少一个接收器或参数包含等待表达的地方。\r\n \r\n","\r\n Should be in sync with OverloadResolution.MatchArgumentToByRefParameter\r\n ":"\r\n 应该与过载分辨率同步。\r\n \r\n","\r\n Represents a name and value in an EnumDeclarationBlock.\r\n ":"\r\n 代表枚举和值中的名称和值。\r\n \r\n","\r\n This instance is used to compare potential WinRT fake methods in type projection.\r\n \r\n FIXME(angocke): This is almost certainly wrong. The semantics of WinRT conflict \r\n comparison should probably match overload resolution (i.e., we should not add a member\r\n  to lookup that would result in ambiguity), but this is closer to what Dev12 does.\r\n \r\n The real fix here is to establish a spec for how WinRT conflict comparison should be\r\n performed. Once this is done we should remove these comments.\r\n ":"\r\n 此实例用于比较类型投影中的潜在winrt假方法。\r\n \r\n FixMe（Angocke）：这几乎可以肯定是错误的。 Winrt冲突的语义\r\n 比较可能应匹配超载分辨率（即，我们不应添加成员\r\n  查找会导致歧义），但这更接近Dev12的作用。\r\n \r\n 这里的真正解决方案是建立一个规范Winrt冲突应该如何比较\r\n 执行。完成此操作后，我们应该删除这些评论。\r\n \r\n","\r\n The Next statement that ends the block. If two For or For Each statements are\r\n ended by a single Next statement, the inner For will not have a Next statement.\r\n ":"\r\n 结束块的下一个语句。如果每个语句的两个或两个语句\r\n 以单个下一个语句结尾，内在将没有下一个语句。\r\n \r\n","\r\n            Finds member declaration node(s) containing given ":"\r\n            查找包含给定的成员声明节点\r\n","\r\n Set to true if method body contains any back branches (loops).\r\n ":"\r\n 如果方法主体包含任何背部（环路），则设置为True。\r\n \r\n"," or the memory it reads.\r\n            ":" 或它读取的内存。\r\n            \r\n","\r\n            Set to true if the items added here should be the only items presented to the user.\r\n            ":"\r\n            如果此处添加的项目应该是唯一提交给用户的项目，则设置为true。\r\n            \r\n"," should be shown only when expanded items is requested.\r\n            ":" 仅在请求扩展的项目时才显示。\r\n            \r\n"," code style option for the given language.\r\n            ":" 给定语言的代码样式选项。\r\n            \r\n","The node if it could be created, otherwise null":"节点如果可以创建，否则为null\r\n","\r\n            True if the provider produces snippet items.\r\n            ":"\r\n            如果提供商生产摘要项目，则为是真的。\r\n            \r\n","\r\n Returns UnaryOperatorKind.Error in case of error, otherwise adjusted operator kind.\r\n \r\n For comparison operators, the operator type computed here is not\r\n the result type of the comparison (which is typically boolean),\r\n but is the type to which the operands are to be converted. For\r\n other operators, the type computed here is both the result type\r\n and the common operand type.\r\n ":"\r\n 返回Unaryoperatorkind.Error如果发生错误，则否则调整了操作员。\r\n \r\n 对于比较操作员，此处计算的运算符类型不是\r\n 比较的结果类型（通常是布尔值），\r\n 但这是要转换操作数的类型。为了\r\n 其他操作员，此处计算的类型是结果类型\r\n 和公共操作数类型。\r\n \r\n","\r\n Base class for method symbols that are associated with some syntax and can receive custom attributes (directly or indirectly via another source symbol).\r\n ":"\r\n 与某些语法关联并可以接收自定义属性的方法符号的基类（直接或间接通过其他源符号）。\r\n \r\n","\r\n            Defines global members that common REPL (Read Eval Print Loop) hosts make available in \r\n            the interactive session.\r\n            ":"\r\n            定义全球成员，即常见的repl（阅读评估打印循环）主机可提供\r\n            交互式会话。\r\n            \r\n","\r\n            public void Goo(string goo,\r\n                            #nullable disable\r\n                            string bar\r\n                            #nullable enable\r\n                            string baz);\r\n            ":"\r\n            public void goo（字符串Goo，\r\n                            #Nullable禁用\r\n                            字符串栏\r\n                            ＃nullable启用\r\n                            字符串baz）;\r\n            \r\n","\r\n Decodes PermissionSetAttribute applied in source to determine if it needs any fixup during codegen.\r\n ":"\r\n 解码在源中应用的PermissionsetAttribute确定它是否需要在CodeGen期间进行任何修复。\r\n \r\n","\r\n Lookup declaration for predefined CorLib type in this Assembly. Only should be\r\n called if it is know that this is the Cor Library (mscorlib).\r\n ":"\r\n 该组件中预定义的Corlib类型的查找声明。只应该是\r\n 如果知道这是COR库（MSCORLIB）。\r\n \r\n","\r\n            This is used for categories which are composed of other categories - L, N, Z, W...\r\n            These groups need special treatment when they are negated\r\n            ":"\r\n            这用于由其他类别组成的类别-L，N，Z，W ...\r\n            这些小组被否定时需要特殊待遇\r\n            \r\n","\r\n Cache the symbol for well-known type System.Type because we use it frequently\r\n (for attributes).\r\n ":"\r\n 缓存众所周知类型system.type的符号，因为我们经常使用它\r\n （对于属性）。\r\n \r\n"," is being\r\n            inserted into.":" 正在\r\n            插入。\r\n","Dim a, b As New T":"昏暗的A，B为新T\r\n"," \r\n Returns the Me symbol associated with a member. \r\n sym must be a member (method, field or property)\r\n ":" \r\n 返回与成员关联的ME符号。\r\n SYM必须是成员（方法，字段或属性）\r\n \r\n","\r\n The value for the LibKeyword property.\r\n ":"\r\n libkeyword属性的值。\r\n \r\n","\r\n Kind of a Handles item represented by a HandledEvent\r\n ":"\r\n 有点用handledevent表示的手柄项目\r\n \r\n","\r\n Determines if two lists of tokens are the same, disregarding trivia differences.\r\n ":"\r\n 确定两个令牌列表是否相同，无视琐事差异。\r\n \r\n","\r\n True if integer overflow checking is off.\r\n ":"\r\n 是的，如果整数溢出检查关闭。\r\n \r\n","join clause":"加入条款\r\n","\r\n            If the search was performed against cached data from a previous run.\r\n            ":"\r\n            如果搜索是针对先前运行中的缓存数据执行的。\r\n            \r\n","\r\n Returns data decoded from early bound well-known attributes applied to the symbol or null if there are no applied attributes.\r\n ":"\r\n 如果没有应用属性，则从符号或null上应用的早期绑定良好属性解码的返回数据解码。\r\n \r\n","Convert to 'switch' statement":"转换为“开关”语句\r\n"," property.\r\n            These tags influence the presentation of quick info section.\r\n            ":" 财产。\r\n            这些标签会影响快速信息部分的介绍。\r\n            \r\n","\r\n  Looks up a localized string similar to XML processing instruction name '{0}' is not valid..\r\n":"\r\n  查找类似于XML处理指令名称'{0}'的本地化字符串无效。\r\n\r\n","\r\n Set the metadata name for this symbol.\r\n Called from ":"\r\n 设置此符号的元数据名称。\r\n 来自\r\n","\r\n Represents the state of compilation of one particular type.\r\n This includes, for example, a collection of synthesized methods created during lowering.\r\n WARNING: Note that the underlying collection classes are not thread-safe and this will \r\n need to be revised if emit phase is changed to support multithreading when\r\n translating a particular type.\r\n ":"\r\n 代表一种特定类型的汇编状态。\r\n 例如，其中包括在降低过程中创建的合成方法的集合。\r\n 警告：请注意，基础收集课程不是线程安全，这将是\r\n 如果更改EMIT阶段以支持多线程，则需要修改\r\n 翻译特定类型。\r\n \r\n","\r\n For test purposes only.\r\n ":"\r\n 仅出于测试目的。\r\n \r\n","Assign a slot for a regular variable.":"为常规变量分配插槽。\r\n","The operation may overflow '{0}' at runtime (use 'unchecked' syntax to override)":"操作可能会在运行时溢出'{0}'（使用'未选中的'语法覆盖）\r\n"," has a\r\n cache of further binders within the method.\r\n \r\n The ":" 有个\r\n 该方法中其他粘合剂的缓存。\r\n \r\n 这\r\n","\r\n A binder to expose namespaces from Imports<xmlns:...> statements.\r\n ":"\r\n 一个粘合剂，可以从导入<xmlns：...>语句中暴露名称空间。\r\n \r\n","\r\n            Calculates a syntax map of the entire method body including all lambda bodies it contains (recursively).\r\n            ":"\r\n            计算整个方法主体的语法图，包括所有lambda物体（递归）。\r\n            \r\n","\r\n            A rule that modifies a set of characters.\r\n            ":"\r\n            修改一组字符的规则。\r\n            \r\n","generic attributes":"通用属性\r\n","\r\n The value for the CallKeyword property.\r\n ":"\r\n CallKeyword属性的值。\r\n \r\n","\r\n Type substitution if applicable or Nothing\r\n ":"如果适用或不用的类型替换\r\n \r\n","\r\n            CS0029: Cannot implicitly convert from type 'x' to 'y'\r\n            ":"\r\n            CS0029：无法隐式从类型的“ x”转换为“ y”\r\n            \r\n","\r\n Scan first text inside f <? ... ?>, the first text can have leading trivia\r\n ":"\r\n 扫描f <？ ...？>，第一篇文本可以有领先的琐事\r\n \r\n","\r\n A MethodTypeParametersBinder provides the context for looking up type parameters on a method.\r\n It is split out since binding of type in the parameters and return value need to happen with a context\r\n that includes the type parameters, but we don't have a fully complete method symbol yet.\r\n ":"\r\n MethodTypeparametersbinder提供了一个上下文，用于在方法上查找类型参数。\r\n 它被拆分出来，因为类型的绑定在参数中，返回值需要在上下文中发生\r\n 其中包括类型参数，但我们还没有完全完整的方法符号。\r\n \r\n","\r\n Substitute the given type substitution within this type, returning a new type. If the\r\n substitution had no effect, return Me. \r\n !!! Only code implementing construction of generic types is allowed to call this method !!!\r\n !!! All other code should use Construct methods.                                        !!! \r\n ":"\r\n 在此类型中替换给定类型的替换，返回一种新类型。如果是\r\n 替代没有任何效果，归还我。\r\n !!!只有实施通用类型的构建代码才能调用此方法！！！\r\n !!!所有其他代码都应使用构造方法。 !!!\r\n \r\n","\r\n            Represents a syntax reference that doesn't actually hold onto the \r\n            referenced node.  Instead, enough data is held onto so that the node\r\n            can be recovered and returned if necessary.\r\n            ":"\r\n            代表语法引用，实际上并不保留\r\n            引用节点。相反，将足够的数据保存在上\r\n            如有必要，可以回收并退还。\r\n            \r\n"," is an extension point, we don't\r\n            perform any validation on ":" 是一个扩展点，我们不\r\n            对\r\n","\r\n The \"Try\" keyword.\r\n ":"\r\n “尝试”关键字。\r\n \r\n","\r\n The header part of the lambda that includes the \"Sub\" or \"Function\" keyword,\r\n the argument list and return type.\r\n ":"\r\n lambda的标题部分，包括“ sub”或“ function”关键字，\r\n 参数列表和返回类型。\r\n \r\n"," generate finally blocks,\r\n            but they do not contain non-hidden sequence points.\r\n            ":"生成最终阻止，\r\n            但是它们不包含非隐藏序列点。\r\n            \r\n","The title bar to be shown in the message box. May be ignored by some implementations.":"标题栏将显示在消息框中。某些实现可能会忽略。\r\n","\r\n  Looks up a localized string similar to {0} '{1}' conflicts with a member implicitly declared for {2} '{3}' in {4} '{5}'..\r\n":"\r\n  查找类似于{0}'{1}'的本地化字符串与{2}'{3}'在{4}'{5}'..中的{2}'{3}'..\r\n\r\n","The \"FFFFF\" custom format specifier represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value. However, trailing zeros or five zero digits aren't displayed.\r\n            \r\n            Alt ...":"“ FFFFF”自定义格式指定符表示秒数的五个最重要的数字；也就是说，它代表日期和时间值中的十万秒。但是，未显示尾随的零或五个零数字。\r\n            \r\n            alt ...\r\n","\r\n            Moves a type to it's own file\r\n            ":"\r\n            将一种类型移至自己的文件\r\n            \r\n","\r\n The boolean expression after the While or Until.\r\n ":"\r\n 布尔语表达之后或直到。\r\n \r\n","\r\n            Return up to date diagnostics for the given span for the document\r\n            ":"\r\n            返回文档给定跨度的最新诊断\r\n            \r\n","\r\n  Looks up a localized string similar to Unmanaged type '{0}' is only valid for fields..\r\n":"\r\n  查找类似于非托管类型的本地化字符串'{0}'仅适用于字段。\r\n\r\n","A boolean value.  True if the current object is equal to the other parameter; otherwise, False.":"布尔值。如果当前对象等于其他参数，则为正确；否则，错误。\r\n","MyType.Get(int)":"mytype.get（int）\r\n","Partial method declarations of '{0}' have inconsistent nullability in constraints for type parameter '{1}'":"“ {0}'的部分方法声明在类型参数'{1}'的约束中的不一致性不一致\r\n","\r\n            Gets a reference to ":"\r\n            得到一个参考\r\n","\r\n Represents a declaration of a Interface, its contents and the End statement\r\n that ends it.\r\n ":"\r\n 表示界面的声明，其内容和最终语句\r\n 结束了。\r\n \r\n","\r\n Produces a bound expression representing a pointer to a frame of a particular frame type.\r\n ":"\r\n 产生代表指向特定帧类型框架的指针的界表达式。\r\n \r\n","\r\n            Maps an escaped character to the actual character it was escaping.  For something like\r\n            'a' this will map to actual '\\a' char (the bell character).  However, for something like\r\n            '(' this will just map to '(' as that's all that \\( does in a regex.\r\n            ":"\r\n            地图逃脱了它逃脱的实际角色。对于类似的东西\r\n            'a'这将映射到实际'\\ a'char（铃铛字符）。但是，类似\r\n            '（'这只会映射到'（“这就是全部\\（在正则是在正则是。\r\n            \r\n","'else' cannot start a statement.":"“其他”无法启动声明。\r\n","\r\n Combine two substitutions into one by concatenating. \r\n \r\n They may not directly or indirectly (through Parent) target the same generic definition.\r\n sub2 is expected to target types lower in the containership hierarchy.\r\n Either or both can be Nothing. \r\n \r\n targetGenericDefinition specifies target generic definition for the result. \r\n If sub2 is not Nothing, it must target targetGenericDefinition.\r\n If sub2 is Nothing, sub1 will be \"extended\" with identity substitutions to target \r\n targetGenericDefinition.\r\n ":"\r\n 通过串联将两个取代组合为一个。\r\n \r\n 它们可能不会直接或间接（通过父​​）定位相同的通用定义。\r\n SUB2预计将在集装箱层次结构中降低目标类型。\r\n 两者都不是什么。\r\n \r\n TargetGenericDefinition指定结果的目标通用定义。\r\n 如果SUB2不是什么都没有的，则必须靶TargetGenericDefinition。\r\n 如果sub2一无\r\n TargetGenericDefinition。\r\n \r\n"," to be used to resolve missing dependencies, unresolved metadata references and #r directives.\r\n            ":" 用于解决缺失的依赖项，未解决的元数据参考和#R指令。\r\n            \r\n","\r\n Gets the \"Dispose\" method.\r\n ":"\r\n 获取“处置”方法。\r\n \r\n","\r\n            The full assembly paths that this reference directly adds to the compilation.\r\n            ":"\r\n            该引用直接添加到汇编的完整组件路径。\r\n            \r\n"," within collection initializer.\r\n This is the worker function that is overridden in various derived kinds of Semantic Models. It can assume that \r\n CheckSyntaxNode has already been called and the ":" 在集合初始化器中。\r\n 这是在各种派生类型的语义模型中被覆盖的工作函数。它可以假设\r\n checksyntaxnode已经被调用了\r\n","\r\n Parses\r\n \"With \"{\" FieldInitializerList \"}\"\r\n FieldInitializerList -> FieldInitializer {\",\" FieldInitializer}*\r\n FieldInitializer -> {Key? \".\" IdentifierOrKeyword \"=\"}? Expression\r\n \r\n  e.g.\r\n  Dim x as new Customer With {.Id = 1, .Name = \"A\"}\r\n ":"\r\n 解析\r\n “使用“ {” fieldInitializerList“}”\r\n fieldInitializerList-> fieldInitializer {“，” fieldInitializer}*\r\n fieldInitializer-> {键？ “。” dissinifierOrkeyword“ =”}？表达\r\n \r\n  例如\r\n  dim x作为新客户，{.id = 1，.name =“ a”}\r\n \r\n","\r\n Given result of binding preceding query operators, the source, bind the following Select operator.\r\n \r\n     {Preceding query operators} Select {expression range variables}\r\n \r\n From a In AA Select b  ==> AA.Select(Function(a) b)\r\n \r\n From a In AA Select b, c  ==> AA.Select(Function(a) New With {b, c})\r\n ":"给定绑定前面查询操作员的结果，源，绑定以下选择操作员。\r\n \r\n     {前面的查询操作员}选择{表达式范围变量}\r\n \r\n 在AA中选择B ==> aa.Select（function（a）b）\r\n \r\n 从A中的A选择B中，C ==> aa.Select（function（a）with {b，c}）\r\n \r\n"," that represents the current AttributeData.\r\n ":"这代表当前的属性。\r\n \r\n","zero-width positive lookahead assertion":"零宽度的正lookahead断言\r\n","\r\n Represents the \"Distinct\" query operator.\r\n ":"\r\n 代表“独特的”查询操作员。\r\n \r\n","\r\n Returns a copy of this with the CatchStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，随着关注的属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            EventArgs for ":"\r\n            Eventargs\r\n","Use '{0}'":"使用'{0}'\r\n","\r\n  Looks up a localized string similar to 'Throw' operand must derive from 'System.Exception'..\r\n":"\r\n  查找类似于“投掷”操作数的本地化字符串必须从“ system.exception”中衍生。\r\n\r\n","\r\n  Looks up a localized string similar to '{0}' cannot override '{1}' because they have different access levels..\r\n":"\r\n  查找类似于'{0}'不能覆盖'{1}'的本地化字符串，因为它们具有不同的访问级别。\r\n\r\n",".a(...).b(...).c(...)":".a（...）。b（...）。c（...）\r\n","\r\n            Try to create a CodeAction representing these edits.  Can return ":"\r\n            尝试创建代表这些编辑的编码。可以返回\r\n","\r\n Emit code for a null-coalescing operator.\r\n ":"\r\n 发射代码为无污染的操作员。\r\n \r\n","\r\n            Called by the debugger to determine whether a non-leaf active statement is in an exception region,\r\n            so it can determine whether the active statement can be remapped. This only happens when the EnC is about to apply changes.\r\n            If the debugger determines we can remap active statements, the application of changes proceeds.\r\n            \r\n            TODO: remove (https://devdiv.visualstudio.com/DevDiv/_workitems/edit/1310859)\r\n            ":"\r\n            调试器召集以确定非叶子活动语句是否在异常区域中，\r\n            因此，它可以确定是否可以重新重新启动活动语句。这仅在ENC即将应用更改时才发生。\r\n            如果调试器确定我们可以重建活动语句，则更改的应用将进行。\r\n            \r\n            todo：remove（https：//devdiv.visualstudio.com/devdiv/_workitems/edit/1310859）\r\n            \r\n","\r\n            Represents the submission states and globals that get passed to a script entry point when run.\r\n            ":"\r\n            代表运行时传递给脚本入口点的提交状态和全球。\r\n            \r\n"," represents a body of a lambda.\r\n ":" 代表一个lambda的身体。\r\n \r\n","The document to generate source into":"将源生成源到的文档\r\n","\r\n A variable declared with As New can be considered assigned before the initializer is executed in case the variable\r\n is a value type. The reason is that in this case the initialization happens in place (not in a temporary) and \r\n the variable already got the object creation expression assigned.\r\n ":"在执行初始化器之前，可以考虑使用新的AS的变量，以防变量\r\n 是值类型。原因是在这种情况下，初始化发生了（不是临时）和\r\n 该变量已经分配了对象创建表达式。\r\n \r\n"," if the file header is missing; otherwise, ":" 如果缺少文件头；否则, \r\n","Add parentheses for clarity":"添加括号为了清晰\r\n","Note that this feature only works if the code literally has ":"请注意，此功能仅在代码字面的情况下才起作用\r\n","\r\n            portion. The namespace part is not encoded into the IL, but the specific types in\r\n            ":"\r\n            部分。名称空间部分未编码到IL中，而是在\r\n            \r\n","\r\n WARNING: Only use this if the location is obtainable without allocating it (even if cached later). E.g., only\r\n if the location object is stored in the constructor of the symbol.\r\n ":"\r\n 警告：仅在可以在不分配的情况下获得位置时使用此（即使稍后缓存）。例如，仅\r\n 如果位置对象存储在符号的构造函数中。\r\n \r\n","\r\n Ensure that ":"\r\n 确保这件事\r\n","\r\n Allocates a temp without identity.\r\n ":"\r\n 分配一个没有身份的温度。\r\n \r\n","\r\n The \"If\" keyword\r\n ":"\r\n “如果”关键字\r\n \r\n","\r\n Returns a copy of this with the AttributeLists property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中属性属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Determine whether this assembly has been granted access to ":"\r\n 确定该议会是否已被授予访问\r\n","\r\n Owning RetargetingPropertySymbol.\r\n ":"\r\n 拥有RetargetingPropertySymbol.\r\n \r\n"," does not support read and seek operations.":" 不支持阅读和寻求操作。\r\n"," Creates a token with kind FloatingLiteralToken from the text and corresponding 4-byte floating point value. ":" 从文本和相应的4字节浮点值中创建一个具有友善浮动文字的令牌。\r\n","Make static":"静态\r\n","Only legal to call on the UI thread.":"只能打电话给UI线程的合法。\r\n","s within the specified Document.\r\n            The fix data can be used to create code actions that apply the fixes.\r\n            ":"指定文档中的s。\r\n            修复数据可用于创建应用修复程序的代码操作。\r\n            \r\n","\r\n  Looks up a localized string similar to Implemented type must be an interface..\r\n":"\r\n  查找类似于实现类型的本地化字符串必须是接口。\r\n\r\n","\r\n  Looks up a localized string similar to 'Optional' expected..\r\n":"\r\n  查找类似于预期的“可选”的本地化字符串。\r\n\r\n","\r\n Gets the \"GetEnumerator\" method.\r\n ":"\r\n 获取“ getEnumerer”方法。\r\n \r\n","\r\n  Looks up a localized string similar to Iterator methods cannot have ByRef parameters..\r\n":"\r\n  查找类似于迭代方法的本地化字符串，无法具有BYREF参数。\r\n\r\n"," return false since the statement is followed by an empty new line.\r\n 3. ":" 返回false，因为该语句之后是一个空的新行。\r\n 3。\r\n","One or more characters. These are typically punctuation characters.":"一个或多个字符。这些通常是标点字符。\r\n","\r\n  Looks up a localized string similar to Type of '{0}' is ambiguous because the loop bounds and the step clause do not convert to the same type..\r\n":"\r\n  查找类似于“ {0}”类型的本地化字符串是模棱两可的，因为循环界限和步骤子句不会转换为同一类型。\r\n\r\n","10,000ths of a second":"10,000秒\r\n","The collection which might have been converted to IEnumerable or IEnumerable(Of T) if needed.":"如果需要，可能已转换为IEnumerable或Ienumerable的集合。\r\n","Declare Sub":"声明sub\r\n","\r\n Returns a copy of this with the [Alias] property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，[别名]属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Represents the \"SyncLock\" statement. This statement always occurs as the Begin\r\n of a SyncLockBlock.\r\n ":"\r\n 代表“ Synclock”语句。此陈述总是在开始时发生\r\n Synclockblock。\r\n \r\n","\r\n The expression that is the argument.\r\n ":"\r\n 是参数的表达。\r\n \r\n","After a comma (,).":"逗号之后（）。\r\n","\r\n The list of initializers between the braces.\r\n ":"\r\n 牙套之间的初始化列表。\r\n \r\n","The increment statement.":"增量语句。\r\n","\r\n Returns the list of alias imports that apply to all syntax trees in this compilation.\r\n ":"\r\n 返回适用于本汇编中所有语法树的别名导入列表。\r\n \r\n","\r\n            Parameters which have at least one read/write reference.\r\n            ":"\r\n            具有至少一个读/写引用的参数。\r\n            \r\n","\r\n This is a helper method to create a BoundQueryLambda for an Into clause \r\n of a Group By or a Group Join operator. \r\n ":"\r\n 这是为创建bondquerylambda的辅助方法\r\n 组成的组或组加入操作员。\r\n \r\n","\r\n            Return prioritized set of fix groups such that fix group for suppression always show up at the bottom of the list.\r\n            ":"\r\n            返回优先级的修复组集，使抑制作用的修复组总是显示在列表的底部。\r\n            \r\n","\r\n Frequently the identity conversion.\r\n ":"\r\n 通常的身份转换。\r\n \r\n","\r\n The value for the JoinedVariables property.\r\n ":"\r\n 加入Variobles属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to 'AddHandler' and 'RemoveHandler' methods must have exactly one parameter..\r\n":"\r\n  查找类似于“ Addhandler”和“ Remove Handler”方法的本地化字符串，必须具有一个参数。\r\n\r\n"," representing the specific kind of\r\n ContinueStatementSyntax. One of ContinueWhileStatement, ContinueDoStatement,\r\n ContinueForStatement.\r\n ":" 代表特定种类\r\n ContunustatementSyntax。持续策略的继续之一，持续的术语，\r\n 继续宣传。\r\n \r\n","\r\n Gets the location in terms of path, line and column for a given ":"\r\n 在给定的路径，线和列中获取位置\r\n","\r\n            SearchScope is used to control where the ":"\r\n            SearchScope用于控制位置\r\n","The syntax node.":"语法节点。\r\n","\r\n Bind array type syntax to the correct type symbol.\r\n ":"\r\n 将数组类型语法绑定到正确的类型符号。\r\n \r\n","time separator":"时间分离器\r\n","\r\n            Returns the providers always available to the service.\r\n            This does not included providers imported via MEF composition.\r\n            ":"\r\n            返回服务始终可用的提供商。\r\n            这不包括通过MEF组成导入的提供商。\r\n            \r\n","\r\n Represents a #Const pre-processing constant declaration appearing in source.\r\n ":"\r\n 代表#const预处理常数声明出现在源中。\r\n \r\n","\r\n A list of the Inherits declarations for the type.\r\n ":"\r\n 类型的继承声明列表。\r\n \r\n","\r\n             If this declaration or identifier is part of a deconstruction, find the deconstruction.\r\n             If found, returns either an assignment expression or a foreach variable statement.\r\n             Returns null otherwise.\r\n            \r\n             copied from SyntaxExtensions.GetContainingDeconstruction\r\n             ":"\r\n             如果此声明或标识符是解构的一部分，请找到解构。\r\n             如果发现，则返回分配表达式或for for for for varable语句。\r\n             否则返回null。\r\n            \r\n             复制从语法上复制\r\n             \r\n","\r\n Used to sort types - members of group collection.\r\n ":"\r\n 用于排序类型 - 集团集合的成员。\r\n \r\n"," representing the specific kind of\r\n MemberAccessExpressionSyntax. One of SimpleMemberAccessExpression,\r\n DictionaryAccessExpression.\r\n ":" 代表特定种类\r\n 会员cessexpressynntax。 SimpleMemberAccessexpression之一，\r\n 字典表达。\r\n \r\n","\r\n This might simplify error reporting. If not, consider getting rid of this property. \r\n ":"\r\n 这可能会简化错误报告。如果没有，请考虑摆脱此属性。\r\n \r\n"," \r\n Given anonymous delegate public symbol construct an anonymous type symbol to be \r\n used in emit; the type symbol may be created based on generic type generated for \r\n each 'unique' anonymous delegate structure OR if the delegate's signature is \r\n 'Sub()' it will be an instance of NonGenericAnonymousDelegateSymbol type.\r\n ":" \r\n 给定匿名代表公共符号构造一个匿名类型符号为\r\n 用于发射；可以基于生成的通用类型创建类型符号\r\n 每个“唯一”匿名代表结构或代表的签名是\r\n “ sub（）”它将是nongenericanymonymousdelegatesymbol类型的实例。\r\n \r\n","Method full path":"方法完整路径\r\n","\r\n Returns true if this type is known to be a reference type. It is never the case\r\n that IsReferenceType and IsValueType both return true. However, for an unconstrained\r\n type parameter, IsReferenceType and IsValueType will both return false.\r\n ":"\r\n 如果已知该类型是参考类型，则返回true。从来没有\r\n IsReferenceType和ISVALUETYPE都返回true。但是，对于不受限制的\r\n 类型参数，IsReferenceType和ISVALUETYPE都将返回false。\r\n \r\n","The previously visited const fields; used to detect cycles.":"先前访问的const领域；用于检测周期。\r\n","\r\n Returns True if this conversion is an identity conversion. \r\n ":"\r\n 如果此转换是身份转换，则返回true。\r\n \r\n","\r\n            o Deconstruct instance or extension method was found for type 'X', with N out parameters\r\n            ":"o针对“ x”类型找到解构实例或扩展方法，其中n out参数\r\n            \r\n","\r\n The \"NameOf\" keyword.\r\n ":"\r\n “名称”关键字。\r\n \r\n","\r\n value definitions for this variable\r\n ":"\r\n 该变量的价值定义\r\n \r\n"," for the immediately containing symbol.\r\n ":" 对于立即包含符号。\r\n \r\n","Requested assembly already loaded from '{0}'.":"请求的汇编已经从“ {0}”加载。\r\n","\r\n Create a possibly merged namespace symbol (namespace group). If only a single namespace is passed it, it is just returned directly.\r\n If two or more namespaces are passed in, then a new merged namespace is created\r\n ":"\r\n 创建一个可能合并的名称空间符号（名称空间组）。如果仅通过一个名称空间，则直接返回。\r\n 如果传递了两个或多个命名空间，则创建一个新的合并名称空间\r\n \r\n","\r\n            Report unchanged document results.\r\n            ":"\r\n            报告未改变的文档结果。\r\n            \r\n","\r\n Emit code for a ternary conditional operator.\r\n ":"\r\n 为三元条件操作员发射代码。\r\n \r\n"," the enumerator needs to be disposed.":" 需要处置枚举者。\r\n"," \r\n Creates a new compilation that can be used in scripting. \r\n ":" \r\n 创建可用于脚本的新汇编。\r\n \r\n","Remove 'in' keyword":"删除“在”关键字中\r\n","Implement interface":"实施接口\r\n","The {n,m}? quantifier matches the preceding element between n and m times, where n and m are integers, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,m}":"{n，m}？量词匹配N和M次之间的前面元素，其中N和M是整数，但尽可能少的次。这是贪婪量词{n，m}的懒惰对应物\r\n","\r\n Given a label statement, get the corresponding label symbol.\r\n ":"\r\n 给定标签语句，获取相应的标签符号。\r\n \r\n"," \r\n Marks a control yield point for emitted await operator; is processed by codegen; \r\n only allowed inside MoveNext methods generated for Async methods\r\n ":" \r\n 标志着正等待运营商的控制收益点；由Codegen处理；\r\n 仅在为异步方法生成的MoveNEXT方法中允许\r\n \r\n","\r\n            Doesn't (and doesn't need to) reflect the number of digits in ":"\r\n            不（也不需要）反映数字的数量\r\n","Expression-bodied members":"表达型成员\r\n","\r\n A representation of a method symbol that is intended only to be used for comparison purposes\r\n (esp in MethodSignatureComparer).\r\n ":"\r\n 方法符号的表示，仅用于比较目的\r\n （ESP在MethodSignatureComparer中）。\r\n \r\n","Use '++' operator":"使用'++'操作员\r\n","match zero or more times":"匹配零或更多次\r\n","A syntax node that represents a parsed attribute. This syntax node\r\n need not and typically does not appear in the source code referred to SemanticModel instance.":"表示解析属性的语法节点。此语法节点\r\n 不需要，通常不会出现在引用SemanticModel实例的源代码中。\r\n","\r\n Returns a copy of this with the DelegateKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 将其返回此副本，其中delegatekeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n The End While statement that ends the block.\r\n ":"\r\n 结束块的语句结束。\r\n \r\n","\r\n            Completion was trigger by a direct invocation of the completion feature \r\n            (ctrl-j in Visual Studio).\r\n            ":"\r\n            完成是通过直接调用完成功能触发的\r\n            （在Visual Studio中的CTRL-J）。\r\n            \r\n","A reference to a type declared inside the namespace to be changed, which is calculated \r\n            based on results from `SymbolFinder.FindReferencesAsync`.":"对要更改的名称空间中声明的类型的引用，该类型已计算\r\n            基于`symbolfinder.findreferencesAsync'的结果。\r\n","\r\n Represents an embedded expression in an interpolated string expression e.g. '{expression[,alignment][:formatString]}'.\r\n ":"\r\n 代表插值字符串表达式中的嵌入式表达式，例如'{expression [，对齐] [：formatstring]}'。\r\n \r\n","\r\n  Looks up a localized string similar to Type '{0}' must define operator '{1}' to be used in a 'For' statement..\r\n":"\r\n  查找类似于“ {0}”类型的本地化字符串必须定义operator'{1}'才能在'for'语句中使用。\r\n\r\n","generating source for symbols of this type is not supported":"不支持这种类型符号的生成源\r\n","\r\n Represents an identifier token. This might include brackets around the name and\r\n a type character.\r\n ":"\r\n 代表标识符令牌。这可能包括围绕名称和\r\n 类型字符。\r\n \r\n","\r\n Represents a Lambda parameter.\r\n ":"\r\n 代表lambda参数。\r\n \r\n","\r\n A source module binder provides the context associated with a source module.\r\n ":"\r\n 源模块粘合剂提供了与源模块关联的上下文。\r\n \r\n","\r\n  Looks up a localized string similar to Cannot infer a common type, and Option Strict On does not allow 'Object' to be assumed..\r\n":"\r\n  查找类似于不能推断常见类型的本地化字符串，并且对选项严格不允许假设“对象”。\r\n\r\n","\r\n            ```(?inmsx)``` node.  Changes options in a sequence for all subsequence nodes.\r\n            ":"\r\n            ``（？inmsx）````node''。为所有子序列节点以顺序更改选项。\r\n            \r\n","\r\n Take forwarded types into account.\r\n ":"\r\n 考虑转发类型。\r\n \r\n","\r\n Returns true if this symbols is a type. Equivalent to Not IsNamespace.\r\n ":"\r\n 如果此符号是一种类型，则返回true。等效于不是iSnamespace。\r\n \r\n","\r\n An elastic trivia with kind EndOfLineTrivia containing a single line feed character. Elastic trivia are used\r\n to denote trivia that was Not produced by parsing source text, And are usually Not preserved during\r\n formatting.\r\n ":"\r\n 具有单线饲料特征的弹性琐事具有类似的内膜。使用弹性琐事\r\n 表示未通过解析源文本产生的琐事，通常在\r\n 格式化。\r\n \r\n","\r\n Represents the \"Implements ...\" clause on a type member, which describes which\r\n interface members this member implements.\r\n ":"\r\n 代表类型成员上的“实施...”子句，该子句描述了哪个\r\n 接口成员该成员实施。\r\n \r\n","Error creating instance of CodeFixProvider '{0}'":"错误创建CodeFixProvider的实例'{0}'\r\n","s.Get(^n)":"s.get（^n）\r\n","Introduce query variable":"引入查询变量\r\n","Type parameters:":"类型参数：\r\n"," Keeps track on current nesting level of try statements ":" 跟踪当前的尝试语句嵌套级别\r\n"," \r\n A helper class for synthesizing quantities of code. \r\n ":" \r\n 用于合成大量代码的辅助类。\r\n \r\n","\r\n            \r\n             and offers to change it to\r\n            \r\n             ":"\r\n            \r\n             并提出将其更改为\r\n            \r\n             \r\n","\r\n            DeclaredSymbolInfos always come from some actual declaration in source.  So they're\r\n            never implicitly declared.\r\n            ":"\r\n            声明的Symbolinfos始终来自来源中的一些实际声明。所以他们\r\n            从不隐含地宣布。\r\n            \r\n","\r\n Checks if 'symbol' is accessible from within 'within', which must be a NamedTypeSymbol or \r\n an AssemblySymbol.  If 'symbol' is accessed off\r\n of an expression then 'throughTypeOpt' is the type of that expression. This is needed to\r\n properly do protected access checks. Sets \"failedThroughTypeCheck\" to true if this protected\r\n check failed.\r\n ":"\r\n 检查是否可以从“内部”内部访问“符号”，该内部必须是命名tytypesymbol或\r\n 一个组合符号。如果访问“符号”\r\n 然后“透明型”的表达是该表达式的类型。这是需要的\r\n 正确执行保护访问检查。如果此保护\r\n 检查失败。\r\n \r\n","\r\n The value for the EnumStatement property.\r\n ":"\r\n 枚举属性的值。\r\n \r\n"," \r\n Indicate the fact that binding of initializers produced a tree with errors. \r\n This property does not indicate whether or not a diagnostic was produced during the \r\n binding of the initializers. \r\n ":" \r\n 表明初始化器的结合产生了一个错误的树。\r\n 该属性未指示在此期间是否产生了诊断\r\n 初始化器的结合。\r\n \r\n","\r\n  Looks up a localized string similar to 'ByRef' parameter '{0}' cannot be used in a lambda expression..\r\n":"\r\n  在lambda表达式中查找类似于“ byref” parameter'{0}'的本地化字符串。\r\n\r\n","Inheriting from a record with a sealed 'Object.ToString' is not supported in C# {0}. Please use language version '{1}' or greater.":"C＃{0}不支持从密封的“对象”的记录继承。请使用语言版本'{1}'或更大。\r\n","\r\n The \"Skip\" or \"Take\" keyword.\r\n ":"\r\n “跳过”或“取”关键字。\r\n \r\n","\r\n Returns information about each method that was considered during overload resolution,\r\n and what the results of overload resolution were for that method.\r\n ":"\r\n 返回有关在超载分辨率期间考虑的每种方法的信息，\r\n 以及该方法的超载分辨率结果是什么。\r\n \r\n","\r\n Type parameter that represents another type parameter while being applied on a different symbol\r\n ":"\r\n 在应用于其他符号上时代表其他类型参数的类型参数\r\n \r\n","\r\n Create a NamespaceExtent that represents a given AssemblySymbol.\r\n ":"\r\n 创建一个代表给定的汇编符号的命名续文。\r\n \r\n","\r\n This functionality exists for parity with C#, which requires it for\r\n legacy reasons (see Microsoft.CodeAnalysis.CSharp.Emit.PEAssemblyBuilderBase.metadataName).\r\n ":"\r\n 此功能与C＃均衡存在，这需要它\r\n 遗产原因（请参阅Microsoft.codeanalysis.csharp.emit.peassemblybuilderbase.metadataname）。\r\n \r\n"," \r\n Returns a unification use-site error (if any) for a symbol contained in this module \r\n that is referring to a specified ":" \r\n 返回本模块中包含的符号的统一用途错误（如果有）\r\n 这是指定的\r\n","\r\n  Looks up a localized string similar to Copying the value of 'ByRef' parameter '{0}' back to the matching argument narrows from type '{1}' to type '{2}'..\r\n":"\r\n  查找一个本地化的字符串，类似于将byref'parameter'{0}'的值复制回到匹配的参数从type'{1}'到type'{2}'..\r\n\r\n","\r\n A mapping from each state of the state machine to the new state that will be used to execute\r\n finally blocks in case the state machine is disposed.  The Dispose method computes the new \r\n state and then runs MoveNext.\r\n ":"\r\n 从状态机的每个状态到新状态的映射，该状态将用于执行\r\n 最后，如果处置状态机器，则阻止。处理方法计算新的\r\n 状态，然后运行movenext。\r\n \r\n","\r\n The \"}\" token.\r\n ":"\r\n “}”令牌。\r\n \r\n","One or more namespaces to merged. If just one, then it is returned.\r\n The merged namespace symbol may hold onto the array.":"合并的一个或多个名称空间。如果只是一个，则将其返回。\r\n 合并的名称空间符号可以包含在数组上。\r\n","\r\n Events imported from metadata return Nothing.\r\n ":"\r\n 从元数据中导入的事件一无所获。\r\n \r\n","\r\n Implementation for an ordinary method (based on usage).\r\n ":"\r\n 普通方法的实现（基于用法）。\r\n \r\n","\r\n Get the types that were directly specified as constraints on this type parameter.\r\n Duplicates and cycles are removed, although the collection may include redundant\r\n constraints where one constraint is a base type of another.\r\n ":"\r\n 获取有关此类型参数的直接指定为约束的类型。\r\n 重复和周期被删除，尽管该收藏可能包括多余\r\n 约束一个约束是另一种约束的基本类型。\r\n \r\n","\r\n Returns a copy of this with the OperatorToken property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中Operatortoken属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n"," is implemented by this class since WorkspaceService doesn't allow a class to implement\r\n            more than one ":" 由于WorkspaceService不允许类实现\r\n            超过一个\r\n","\r\n            \r\n            And requires it to be of the form:\r\n            ":"\r\n            \r\n            并要求其形式：\r\n            \r\n","\r\n            CS0266: Cannot implicitly convert from type 'x' to 'y'. An explicit conversion exists (are you missing a cast?)\r\n            ":"\r\n            CS0266：无法隐式从类型的“ X”转换为“ Y”。存在明确的转换（您是否缺少演员？）\r\n            \r\n","\r\n Returns True if this conversion is a widening reference conversion or narrowing reference conversion, as defined in\r\n section 8.4.\r\n ":"\r\n 如果此转换是扩大的参考转换或缩小参考转换，则返回为true\r\n 第8.4节。\r\n \r\n","\r\n  Looks up a localized string similar to 'ReadOnly' attribute property '{0}' cannot be the target of an assignment..\r\n":"\r\n  查找类似于“ readonly”属性属性'{0}'的本地化字符串不能成为分配的目标。\r\n\r\n","\r\n Determines if Unicode character represents a whitespace.\r\n ":"\r\n 确定Unicode字符是否代表空格。\r\n \r\n","\r\n Represents analysis context attributes such as compilation, region, etc...\r\n ":"\r\n 代表分析上下文属性，例如编译，区域等...\r\n \r\n","\r\n            Returns false if only and precisely one ":"\r\n            如果仅返回false\r\n","\r\n The declarations contained in the namespace statement.\r\n ":"\r\n 名称空间语句中包含的声明。\r\n \r\n","\r\n            Associates a full assembly name with its location. The association is used when an assembly \r\n            is being loaded and its name needs to be resolved to a location.\r\n            ":"\r\n            将一个完整的组装名称与其位置相关联。组装时使用协会\r\n            正在加载，其名称需要解决到一个位置。\r\n            \r\n","\r\n  Looks up a localized string similar to Class '{0}' cannot inherit from itself: {1}.\r\n":"\r\n  查找类似于类'{0}'类的本地化字符串不能从自身继承：{1}。\r\n\r\n","The \"dddd\" custom format specifier (plus any number of additional \"d\" specifiers) represents the full name of the day of the week. The localized name of the day of the week is retrieved from the DateTimeFormatInfo.DayNames property of the current or specif ...":"“ DDDD”自定义格式指定符（加上任何数量的其他“ D”指定符）代表一周中的全名。从dateTimeFormatinfo.当前或指定的daynames属性中检索本周一天的本地名称...\r\n"," \r\n Map an anonymous type or delegate public symbol to an implementation symbol to be \r\n used in emit.\r\n \r\n NOTE: All anonymous types/delegated (except for delegate with signature 'Sub()') with the \r\n same set of fields/parameters (field names and IsKey flags are taken into account) are \r\n generated based on the same generic type template.\r\n ":" \r\n 将匿名类型或将公共符号映射到实现符号为\r\n 用于发射。\r\n \r\n 注意：所有匿名类型/委派\r\n 相同的一组字段/参数（考虑到字段名称和ISKEY标志）\r\n 基于相同的通用类型模板生成。\r\n \r\n","\r\n A list of the supplied constraints. If no constraints were supplied, Nothing is\r\n returned.\r\n ":"\r\n 提供的约束列表。如果没有提供约束，则没有什么\r\n 回来。\r\n \r\n","\r\n Lazy cache of special members.\r\n Not yet known value is represented by ErrorTypeSymbol.UnknownResultType\r\n ":"\r\n 特别成员的懒惰缓存。\r\n 尚不知道的值由errortypesymbol.inknownresulttype表示\r\n \r\n","\r\n The value for the WithStatement property.\r\n ":"\r\n 升级属性的值。\r\n \r\n","\r\n Returns Nothing for identity substitution.\r\n ":"\r\n 返回身份替代的任何内容。\r\n \r\n","\r\n            NuGet package reference `<PackageReference ... />`\r\n            ":"\r\n            nuget软件包参考`<packageReference ... />`\r\n            \r\n","\r\n Force all declaration diagnostics to be generated for the symbol.\r\n ":"\r\n 强制为该符号生成所有声明诊断。\r\n \r\n","Indicates whether to binding the name as a full expression,\r\n or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then\r\n expression should derive from TypeSyntax.":"指示是否将名称绑定为完整的表达式，\r\n 或类型或名称空间。如果提供了猜测bindingoption.bindastypeornamespace，则\r\n 表达应源自型号。\r\n","\r\n            syntax node types this organizer is applicable to\r\n            ":"\r\n            语法节点类型此组织者适用于\r\n            \r\n","\r\n Returns true if this symbol was declared to override a base class members and was\r\n also restricted from further overriding; i.e., declared with the \"NotOverridable\"\r\n modifier. Never returns true for types.\r\n ":"\r\n 如果该符号被宣布覆盖基类成员，则返回true\r\n 还限制了进一步的覆盖；即，用“可忽视的”声明\r\n 修饰符。类型永远不会返回。\r\n \r\n","\r\n Represents an \"= initializer\" clause in a declaration for a variable, parameter\r\n or automatic property.\r\n ":"\r\n 代表变量，参数的声明中的“ = initializer”子句\r\n 或自动属性。\r\n \r\n","\r\n Get the fully qualified namespace name using the spelling used in the declaration enclosing the given\r\n syntax tree and location.\r\n I.e., if this namespace was declared with:\r\n Namespace zAp\r\n  Namespace FOO.bar\r\n    'location\r\n  End Namespace\r\n End Namespace\r\n Namespace ZAP\r\n  Namespace foo.bar\r\n  End Namespace\r\n End Namespace\r\n \r\n It would return \"ProjectNamespace.zAp.FOO.bar\".\r\n ":"使用封闭给定的声明中使用的拼写获取完全合格的名称名称\r\n 语法树和位置。\r\n 即，如果该名称空间被声明：\r\n 名称空间ZAP\r\n  名称空间foo.bar\r\n    '地点\r\n  终点空间\r\n 终点空间\r\n 名称空间ZAP\r\n  名称空间foo.bar\r\n  终点空间\r\n 终点空间\r\n \r\n 它将返回“ projectNamespace.zap.foo.bar”。\r\n \r\n","The syntax node that declares method, property or event.":"声明方法，属性或事件的语法节点。\r\n","\r\n A sum of widths of spans of all preceding initializers\r\n (instance and static initializers are summed separately, and trivias are not counted).\r\n ":"\r\n 所有先前初始化器的跨度的宽度之和\r\n （实例和静态初始化器分别汇总，琐事不计算）。\r\n \r\n","\r\n  Looks up a localized string similar to Alignment value is outside of the supported range..\r\n":"\r\n  查找类似于对齐值的本地化字符串超出了受支持的范围。\r\n\r\n","\r\n Determine if the given ":"\r\n 确定是否给定\r\n","\r\n Returns a copy of this with the ElseBlock property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"返回此副本，其中Elseblock属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","A list of symbols that were found. If no symbols were found, an empty list Is returned.":"找到的符号列表。 如果未找到任何符号，则返回一个空列表。\r\n","Struct contains assignment to 'this' outside of constructor. Make readonly fields writable.":"结构包含构造函数外部“此”的分配。使可读字段可写。\r\n","\r\n            The copyright text, as parsed from the header.\r\n            ":"\r\n            从标题解析的版权文本。\r\n            \r\n","\r\n  Looks up a localized string similar to '{0}' cannot inherit from {1} '{2}' because it expands the access of type '{3}' outside the assembly..\r\n":"\r\n  查找类似于'{0}'的本地化字符串不能从{1}'{2}'继承，因为它扩展了汇编外的类型'{3}'的访问。\r\n\r\n","You cannot break a line between the keywords of query operators that are made up of multiple keywords \r\n (Order By, Group Join, Take While, and Skip While).":"您不能在由多个关键字组成的查询运算符的关键字之间打破界限\r\n （订购，小组加入，随身携带，然后跳过）。\r\n","Use compound assignment":"使用复合分配\r\n","Selection can not cross over preprocessor directives.":"选择不能跨越预处理器指令。\r\n","\r\n            Given a list of symbols, and a mapping from each symbol to its original SemanticModel, \r\n            creates the list of completion items for them.\r\n            ":"\r\n            给定一个符号列表，以及从每个符号到其原始semanticmodel的映射，\r\n            为他们创建完成项目的列表。\r\n            \r\n","\r\n The value for the SyncLockKeyword property.\r\n ":"\r\n SynclockKeyword属性的值。\r\n \r\n","\r\n Indicates if the property can be read, which means this \r\n type overrides OR inherits a getter for this property.\r\n ":"\r\n 指示是否可以阅读该属性，这意味着\r\n 键入覆盖或继承此属性的getter。\r\n \r\n","\r\n            Assembly name with Version, Culture and PublicKeyToken components filled in:\r\n            \"SimpleName, Version=#.#.#.#, Culture=XXX, PublicKeyToken=XXXXXXXXXXXXXXXX\".\r\n            In addition Retargetable flag and ContentType are set.\r\n            ":"\r\n            带有版本，文化和公共关键组件的组装名称填充：\r\n            “ SimpleName，版本=＃。＃。＃。＃，文化= xxx，publicKeyToken = xxxxxxxxxxxxxxxxx x”。\r\n            另外，设置了可重新定位的标志和ContentType。\r\n            \r\n","\r\n Returns true if and only if baseType is a base class of derivedType.\r\n ":"\r\n 当且仅当底型是派生类型的基类时，返回true。\r\n \r\n","\r\n Get the Binder from a lambda node, or return Nothing if this isn't \r\n a lambda node.\r\n ":"从lambda节点获取活页夹，或者如果不是，则什么都没有返回\r\n lambda节点。\r\n \r\n"," with bounds checking on integer arithmetic enforced.\r\n            ":" 范围检查整数强制执行。\r\n            \r\n","\r\n If node has an immediate parent that is an expression or statement or attribute, return\r\n that (making sure it can be bound on its own). Otherwise return Nothing.\r\n ":"\r\n 如果节点具有表达式或语句或属性的直接父母，请返回\r\n （确保它可以自行绑定）。否则什么都没有。\r\n \r\n","\r\n Represents a single attribute declaration within an attribute list.\r\n ":"\r\n 代表属性列表中的单个属性声明。\r\n \r\n","\r\n Implements visitor pattern.\r\n ":"\r\n 实施访客模式。\r\n \r\n","\r\n            The singular completion provider that will hook into completion and will\r\n            provider all completions across all embedded languages.\r\n            \r\n            Completions for an individual language are provided by\r\n            ":"\r\n            单数完成提供商，将涉足完整并将\r\n            提供者在所有嵌入式语言中的所有完成。\r\n            \r\n            单个语言的完成由\r\n            \r\n","A alternating sequence of nodes and tokens.":"节点和令牌的交替序列。\r\n","\r\n A NoPiaMissingCanonicalTypeSymbol is a special kind of ErrorSymbol that represents\r\n a NoPia embedded type symbol that was attempted to be substituted with canonical type, \r\n but the canonical type couldn't be found.\r\n ":"\r\n nopiamissingcanonicaltypesymbol是一种特殊的错误符号，代表\r\n 一种试图用规范类型代替的NOPIA嵌入式类型符号，\r\n 但是找不到规范类型。\r\n \r\n","\r\n Returns a copy of this with the FormatStringToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中formatstringtoken属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            We pass the project here to retrieve information about the ":"\r\n            我们在此处通过该项目以检索有关\r\n","\r\n The value for the PercentGreaterThanToken property.\r\n ":"\r\n Persongreathantken物业的价值。\r\n \r\n","), followed by a newline.\r\n            ":"），然后是新线。\r\n            \r\n","\r\n The \"Assembly\" or \"Module\" attribute modifier, is present. If no attribute\r\n modifier is present, Nothing is returned.\r\n ":"\r\n 存在“汇编”或“模块”属性修饰符。如果没有属性\r\n 存在修饰符，什么也没有返回。\r\n \r\n","\r\n Returns a copy of this with the IntoKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中intekeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n The NamedTypeSymbol for the .NET System.Object type, which could have a TypeKind of\r\n Error if there was no COR Library in a compilation using the assembly.\r\n":"\r\n .net system.Object类型的命名typeymbol\r\n 错误，如果使用组件中没有COR库中的COR库。\r\n\r\n","\r\n  Looks up a localized string similar to 'System.Void' can only be used in a GetType expression..\r\n":"\r\n  查找类似于“ system.void”的局部字符串，只能在getType表达式中使用。\r\n\r\n","\r\n Determines if two lists of syntax nodes are the same, disregarding trivia differences.\r\n ":"\r\n 确定语法节点的两个列表是否相同，无视琐事差异。\r\n \r\n","auto-property":"自动专业\r\n","The symbols recommended in linked documents":"链接文档中建议的符号\r\n","Updating a complex statement containing an await expression requires restarting the application.":"更新包含等待表达式的复杂语句需要重新启动应用程序。\r\n","Record member '{0}' must return '{1}'.":"记录成员'{0}'必须返回'{1}'。\r\n","\r\n  Looks up a localized string similar to Expected matching closing single quote for XML attribute value..\r\n":"\r\n  查找类似于XML属性值的预期匹配的单个报价类似的本地化字符串。\r\n\r\n","Renaming {0} requires restarting the application.":"重命名{0}需要重新启动应用程序。\r\n"," we can only remove the ":" 我们只能删除\r\n","\r\n An extension property in reduced form, with first parameter\r\n removed and exposed as an explicit receiver type.\r\n ":"\r\n 以简化形式的扩展属性，带有第一个参数\r\n 删除并暴露为显式接收器类型。\r\n \r\n","Implement explicitly":"明确实施\r\n","Document snapshot to analyze.":"文档快照要分析。\r\n","\r\n            Enumerates assemblies in the GAC returning their simple names.\r\n            ":"\r\n            GAC中列举组件以返回他们的简单名称。\r\n            \r\n","An object instance whose members can be accessed by the script as global variables.":"可以通过脚本作为全局变量访问其成员的对象实例。\r\n","\r\n The value for the ToKeyword property.\r\n ":"\r\n tokeyword属性的值。\r\n \r\n","\r\n Represents a For or For Each block.\r\n ":"代表每个块或每个块。\r\n \r\n","\r\n target.ReturnType is ignored and must be Void, only parameter types are taken into consideration.\r\n ":"\r\n target.terntype被忽略，必须是无效的，仅考虑参数类型。\r\n \r\n","Warning: Inlining temporary into conditional method call.":"警告：将临时方法插入条件方法调用中。\r\n","\r\n  Looks up a localized string similar to Classes that are generic or contained in a generic type cannot inherit from an attribute class..\r\n":"\r\n  查找类似于通用类型或通用类型中包含的类的本地化字符串，无法从属性类中继承。\r\n\r\n","\r\n Represents the beginning of an #If pre-processing directive appearing in\r\n source.\r\n ":"\r\n 代表#if预处理指令的开始\r\n 资源。\r\n \r\n","\r\n Returns True if this types has Arity >= 1 and Construct can be called. This is primarily useful\r\n when deal with error cases.\r\n ":"\r\n 如果此类型具有Arity> = 1，并且可以调用构造，则返回true。这主要有用\r\n 处理错误情况时。\r\n \r\n","\r\n Binds a constant local's value. \r\n ":"\r\n 绑定恒定本地的价值。\r\n \r\n","\r\n  Looks up a localized string similar to 'ElseIf' must be preceded by a matching 'If' or 'ElseIf'..\r\n":"\r\n  查找类似于“ elseif”的本地化字符串必须先于匹配的“ if”或“ elseif”。\r\n\r\n","Use coalesce expression":"使用联合表达\r\n","Add blank line after block":"在块之后添加空白行\r\n","\r\n  Looks up a localized string similar to 'Widening' and 'Narrowing' cannot be combined..\r\n":"\r\n  查找类似于“扩大”和“狭窄”的局部字符串。\r\n\r\n"," Current enclosing Catch block if there is any. ":" 当前封闭捕获块如果有的话。\r\n","\r\n Returns a copy of this with the NameOfKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中nameFkeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Represents #Enable Warning pre-processing directive appearing in source.\r\n ":"\r\n 代表#enable警告预处理指令出现在源中。\r\n \r\n","Ref mismatch between '{0}' and function pointer '{1}'":"参考“ {0}'和功能指针'{1}'之间的不匹配\r\n","fixed":"固定\r\n","\r\n The keyword that identifiers the value being set for the option: On, Off, Text\r\n or Binary.\r\n ":"\r\n 标识为选项设置的值的关键字：打开，关闭，文本\r\n 或二进制。\r\n \r\n","\r\n The value for the TypeOfKeyword property.\r\n ":"\r\n TypeOfkeyword属性的值。\r\n \r\n","\r\n The list of new variables that calculate aggregations.\r\n ":"\r\n 计算聚合的新变量列表。\r\n \r\n","\r\n The right operand.\r\n ":"\r\n 合适的操作数。\r\n \r\n","The CallerArgumentExpressionAttribute applied to parameter will have no effect because it's self-refential.":"应用于参数的CallerArgumentExpressextribute将没有效果，因为它是自我依赖的。\r\n","\r\n            Gets the description of the specified item.\r\n            ":"\r\n            获取指定项目的描述。\r\n            \r\n"," is used for\r\n            other double quote completions.\r\n            ":" 是用来\r\n            其他双引号完成。\r\n            \r\n","\r\n  Looks up a localized string similar to AnonymousObjectCreationExpressionSyntax not within syntax tree.\r\n":"\r\n  查找类似于语法树中的anonymobjectCreationexpressyntax类似的本地化字符串。\r\n\r\n","\r\n Abstract class for the beginning statement of a Module, Class, Interface or\r\n Structure declaration. This node always appears as the Begin of a TypeBlock\r\n with Kind=ModuleDeclarationBlock, ClassDeclarationBlock,\r\n InterfaceDeclarationBlock or StructureDeclarationBlock.\r\n ":"\r\n 用于模块，类，接口或\r\n 结构声明。该节点总是以类型块的开始出现\r\n 与bink = moduledeclaration block，classDeclarationBlock，\r\n InterfaceClarationBlock或结构性电信block。\r\n \r\n","\r\n A simple Binder that wraps another Binder and reports a specific\r\n binding location, but otherwise delegates to the other Binder.\r\n ":"\r\n 一个简单的粘合剂，包裹另一个粘合剂并报告特定的\r\n 绑定的位置，但其他委托给另一个活页夹。\r\n \r\n","\r\n  Looks up a localized string similar to Conversion operators cannot convert from a type to its derived type..\r\n":"\r\n  查找类似于转换运算符的本地化字符串无法从类型转换为其派生类型。\r\n\r\n","\r\n            This is technically innacurate for possible, but very uncommon cases.  For example, if the user's code\r\n            explicitly did something like this:\r\n            \r\n            ":"\r\n            对于可能的可能但罕见的情况，这在技术上是无关紧要的。例如，如果用户的代码\r\n            明确地做了这样的事情：\r\n            \r\n            \r\n","\r\n Traverse the symbol table and properly add/process synthesized extra metadata if needed.\r\n ":"\r\n 遍历符号表，并在需要时正确添加/过程合成额外的元数据。\r\n \r\n","\r\n Get the name of this assembly.\r\n ":"\r\n 获取此组件的名称。\r\n \r\n","True if the modified text should be formatted automatically.":"如果应自动格式化修改后的文本，则为true。\r\n","Diagnostic ID reported by this analyzer":"该分析仪报告的诊断ID\r\n","Use expression body for properties":"使用表达式主体作为属性\r\n","\r\n Ensure all attributes on all members in the named type are bound.\r\n ":"\r\n 确保命名类型中所有成员的所有属性都绑定。\r\n \r\n","\r\n Return the most derived type from the set of constraint types on this type\r\n parameter and any type parameter it depends on. Returns Nothing if there\r\n are no concrete constraint types. If there are multiple constraints, returns\r\n the most derived, ignoring any subsequent constraints that are neither\r\n more or less derived. This method assumes there are no constraint cycles.\r\n ":"\r\n 从此类型上的一组约束类型返回最派生的类型\r\n 参数及其取决于的任何类型参数。如果那里什么也没返回\r\n 没有具体约束类型。如果有多个约束，返回\r\n 最派生的，忽略任何后续约束都不是\r\n 或多或少派生。该方法假定没有约束周期。\r\n \r\n","\r\n            Gets the previously-provided argument value for this parameter.\r\n            ":"获取此参数先前提供的参数值。\r\n            \r\n","\r\n            Constructor for a code style analyzer with a single diagnostic descriptor and\r\n            two or more ":"\r\n            带有单个诊断描述符的代码样式分析仪的构造函数和\r\n            两个或更多\r\n","\r\n Returns a copy of this with the ArgumentList property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回其中的副本，其中参数清单属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","The destination type to convert to.":"要转换的目标类型。\r\n","10ths of a second":"十分之一\r\n","\r\n Spill field allocator controls allocation and reuse of the set of fields \r\n used to spilling expressions; current implementation allows reuse of fields \r\n of the same type on high-level statement level\r\n ":"\r\n 溢出场分配器控制和重复使用该场集\r\n 用于溢出表达；当前实施允许重复使用字段\r\n 高级语句级别的相同类型\r\n \r\n","Cast":"投掷\r\n","\r\n            This is the new name we want to change the namespace to.\r\n            Empty string means global namespace, whereas null means change namespace action is not available.\r\n            ":"\r\n            这是我们要更改名称空间的新名称。\r\n            空字符串表示全局名称空间，而空字符串表示不可用的更改名称空间操作。\r\n            \r\n","\r\n Returns a copy of this with the CommaTokens property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而Commatokens属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            Navigates to the given line/offset in the specified document, opening it if necessary.\r\n            ":"\r\n            导航到指定文档中的给定行/偏移，如有必要。\r\n            \r\n","\r\n  Looks up a localized string similar to '{0}' is not valid on a local variable declaration..\r\n":"\r\n  在本地变量声明上查找类似于“ {0}”的本地化字符串。\r\n\r\n","\r\n Try to parse the local name and return ":"\r\n 尝试解析本地名称并返回\r\n","\r\n Represents a Decimal literal token.\r\n ":"\r\n 代表小数十进制的文字令牌。\r\n \r\n"," representing the specific kind of\r\n AssignmentStatementSyntax. One of SimpleAssignmentStatement,\r\n MidAssignmentStatement, AddAssignmentStatement, SubtractAssignmentStatement,\r\n MultiplyAssignmentStatement, DivideAssignmentStatement,\r\n IntegerDivideAssignmentStatement, ExponentiateAssignmentStatement,\r\n LeftShiftAssignmentStatement, RightShiftAssignmentStatement,\r\n ConcatenateAssignmentStatement.\r\n ":" 代表特定种类\r\n sigitionStatementsyntax。简单的签名阶级之一，\r\n 中级安排，addAssignmentStatement，scntractAssignmentStatement，\r\n 多重设施统计，分隔签名，\r\n IntegerDivideAssignmentStatement，ExponentiateAseSignmentStatement，\r\n 左shiftAssignmentStatement，右shiftAssignmentStatement，\r\n ConcateNateAssignmentStatement。\r\n \r\n","\r\n  Looks up a localized string similar to Cannot infer a return type. Consider adding an 'As' clause to specify the return type..\r\n":"\r\n  查找类似于不能推断返回类型的本地化字符串。考虑添加一个“ AS”子句以指定返回类型。\r\n\r\n","returns True if any errors are reported":"如果报告任何错误，返回true\r\n","\r\n Creates an empty separated list.\r\n ":"\r\n 创建一个空的分开列表。\r\n \r\n"," \r\n A mapping from local variables to the index of their slot in a flow analysis local state. \r\n WARNING: if variable identifier maps into SlotKind.NotTracked, it may mean that VariableIdentifier \r\n          is a structure without traceable fields. This mapping is created in MakeSlotImpl(...)\r\n ":" \r\n 从局部变量到其插槽索引的映射在局部状态。\r\n 警告：如果可变标识符映射到slotkind。\r\n          是一个没有可追溯字段的结构。此映射是在MakeLotimpl（...）中创建的\r\n \r\n","\r\nParse the input for leading trivia.\r\n ":"\r\n解析领先琐事的输入。\r\n \r\n","Ceasing to capture variable '{0}' requires restarting the application.":"停止捕获变量'{0}'需要重新启动应用程序。\r\n","An ImmutableArray of diagnostics created during parse.":"在解析过程中创建的诊断的不可分割的读物。\r\n","\r\n Returns True if this conversion is a widening anonymous delegate conversion as defined in section 8.8, or a\r\n narrowing anonymous delegate conversion as defined in section 8.9.\r\n ":"\r\n 如果此转换是第8.8节中定义的匿名代表转换，则返回true，或\r\n 按照第8.9节中定义的狭窄匿名代表转换。\r\n \r\n","\r\n Create an identifier node with brackets or type character.\r\n ":"\r\n 创建具有括号或类型字符的标识符节点。\r\n \r\n","\r\n Represents a reference to a generic method instantiation, closed over type parameters, \r\n e.g. MyNamespace.Class.Method{T}()\r\n ":"\r\n 代表对通用方法实例化的引用，封闭了类型参数，\r\n 例如mynamespace.class.method {t}（）\r\n \r\n","\r\n An array of ":"\r\n 一系列\r\n"," representing the specific kind of MethodBlockSyntax.\r\n One of SubBlock, FunctionBlock.\r\n ":" 代表特定类型的方法嵌入。\r\n 一个子块之一，功能框架。\r\n \r\n","The \"G\" standard format specifier represents a combination of the short date (\"d\") and long time (\"T\") patterns, separated by a space.":"“ G”标准格式指定符代表短期（“ D”）和长时间（“ T”）模式的组合，被空间隔开。\r\n","\r\n  Looks up a localized string similar to 'Microsoft.VisualBasic.ComClassAttribute' cannot be applied to a class that is generic or contained inside a generic type..\r\n":"\r\n  查找类似于“ microsoft.visualbasic.com classattribute”类似的本地化字符串，不能应用于通用类型中的通用类或包含的类。\r\n\r\n","nui":"nui\r\n","\r\n To go the opposite direction (from syntax node to symbol), see ":"\r\n 要转向相反的方向（从语法节点到符号），请参阅\r\n","\r\n For each captured variable, the corresponding field of its frame\r\n ":"\r\n 对于每个捕获的变量，其框架的相应字段\r\n \r\n","Target runtime doesn't support static abstract members in interfaces.":"目标运行时不支持接口中的静态抽象成员。\r\n",", and it must have both an\r\n             ":"，并且必须既有\r\n             \r\n","Braces are always allowed, and generally preferred except in limited situations involving single-line\r\n             statements and expressions:":"括号始终是允许的，并且通常是首选，除非在涉及单行的有限情况下\r\n             语句和表达式:\r\n","\r\n The member containing the binding context. \r\n This property is the main reason for this binder, because the binding context for an initialization \r\n needs to be the field or property symbol.\r\n ":"\r\n 包含绑定上下文的成员。\r\n 此属性是该粘合剂的主要原因，因为初始化的绑定上下文\r\n 需要是字段或属性符号。\r\n \r\n","A syntax node that represents a name. This syntax\r\n node need not and typically does not appear in the source code referred to by the\r\n SemanticModel instance.":"代表名称的语法节点。这个语法\r\n 节点无需，通常不会出现在该源代码中\r\n Semanticmodel实例。\r\n","\r\n            One or more characters.\r\n            ":"\r\n            一个或多个字符。\r\n            \r\n","\r\n The expression used to initialize the expression variable.\r\n ":"\r\n 表达式用于初始化表达变量。\r\n \r\n","\r\n Get the syntax node(s) where this symbol was declared in source.\r\n ":"\r\n 获取在源中声明此符号的语法节点。\r\n \r\n","The \"FF\" custom format specifier represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value. However, trailing zeros or two zero digits aren't displayed.":"“ FF”自定义格式指定符表示秒数的两个最重要的数字；也就是说，它代表了日期和时间值的一秒钟。但是，未显示尾随的零或两个零数字。\r\n"," keyword over it as the user starts typing.\r\n            ":" 当用户开始键入时，关键字上的关键字。\r\n            \r\n","\r\n Constructor arguments on the attribute.\r\n ":"关于属性的构造函数参数。\r\n \r\n"," since it is tightly coupled with it.\r\n            \r\n            ":" 由于它与它紧密结合。\r\n            \r\n            \r\n","\r\n  Looks up a localized string similar to Late-bound extension methods are not supported..\r\n":"查找类似于晚期扩展方法的局部字符串。\r\n\r\n","or pattern":"或图案\r\n","\r\n Information about a candidate from a group.\r\n Will have different implementation for methods, extension methods and properties.\r\n ":"\r\n 有关候选人的信息。\r\n 对于方法，扩展方法和属性，将具有不同的实现。\r\n \r\n","Introduce field for all occurrences of '{0}'":"介绍所有出现“ {0}”的字段\r\n","\r\n The class to represent all, but Global, namespaces imported from a PE/module.\r\n Namespaces that differ only by casing in name are merged.\r\n ":"\r\n 从PE/模块导入的全部（全局）名称空间。\r\n 仅通过名称中的外壳而有所不同的名称空间是合并的。\r\n \r\n","\r\n Represents a compiler generated backing field for an automatically implemented property.\r\n ":"\r\n 代表自动实现属性的编译器生成的备份字段。\r\n \r\n"," is a request that the completion host operate in suggestion mode.\r\n            The item specified determines the text displayed and the description associated with it unless a different item is manually selected.\r\n            \r\n            No text is ever inserted when this item is completed, leaving the text the user typed instead.\r\n            ":" 是要求完成主机在建议模式下运行的请求。\r\n            指定的项目确定显示的文本以及与之关联的描述，除非手动选择其他项目。\r\n            \r\n            完成此项目后，永远不会插入文本，而是将用户输入的文本。\r\n            \r\n"," clause when the embedded statement is an ":" 当嵌入语句是 \r\n","\r\n            Check if the symbol is a relevant kind.\r\n            Only relevant if symbol could cause a conflict with a local variable.\r\n            ":"\r\n            检查符号是否是相关的。\r\n            仅当符号可能与局部变量发生冲突时相关。\r\n            \r\n","Identifier or a simple member access expected.":"标识符或预期的简单成员访问。\r\n","\r\n Creates the syntax representation of a param element within xml documentation comments (e.g. for\r\n documentation of method parameters).\r\n ":"\r\n 创建XML文档注释中参数元素的语法表示（例如\r\n 方法参数的文档）。\r\n \r\n","\r\n The declaration table that holds onto declarations from source. Incrementally updated\r\n between compilation versions when source changes are made.\r\n ":"\r\n 声明表中保留了来自来源的声明。逐步更新\r\n 在汇编版本之间进行源更改时。\r\n \r\n","\r\n Symbol representing a using alias appearing in a compilation unit. \r\n Generally speaking, these symbols do not appear in the set of symbols reachable\r\n from the unnamed namespace declaration.  In other words, when a using alias is used in a\r\n program, it acts as a transparent alias, and the symbol to which it is an alias is used in\r\n the symbol table.  For example, in the source code\r\n ":"代表汇编单元中出现的使用别名的符号。\r\n 一般来说，这些符号在可触时的符号集中没有出现\r\n 从未命名的名称空间声明中。换句话说，当使用使用别名\r\n 程序，它充当透明别名，并且它是一个别名的符号\r\n 符号表。例如，在源代码中\r\n \r\n","\r\n            Caught exception originating from the script top-level code.\r\n            ":"\r\n            从脚本顶级代码中获取异常。\r\n            \r\n"," \r\n Given anonymous type public symbol construct an anonymous type symbol to be used \r\n in emit; the type symbol is created based on generic type generated for each \r\n 'unique' anonymous type structure.\r\n ":" \r\n 给定的匿名类型公共符号构造要使用的匿名类型符号\r\n 在发射中；类型符号是基于为每个生成的通用类型创建的\r\n “唯一”匿名类型结构。\r\n \r\n","Updating the alias of Declare statement requires restarting the application.":"更新声明声明的别名需要重新启动应用程序。\r\n","\r\n Creates a trivia with kind WhitespaceTrivia containing the specified text.\r\n ":"\r\n 用包含指定文本的善良的whitespacrivia创建琐事。\r\n \r\n","\r\n The second of the two optional Select methods associated with ":"\r\n 两个可选的选择方法中的第二个与\r\n","\r\n            Looks at ":"\r\n            看着 \r\n","\r\n The \"=\" token.\r\n ":"\r\n “ =”令牌。\r\n \r\n","\r\n A region analysis walker that records jumps into the region.  Works by overriding NoteBranch, which is\r\n invoked by a superclass when the two endpoints of a jump have been identified.\r\n ":"\r\n 记录的区域分析步行者跳入该地区。通过覆盖笔记的作品，这是\r\n 当已经确定了跳跃的两个端点时，被超类引用。\r\n \r\n"," Set unconditional state ":" 设置无条件状态\r\n","Specified assembly is not supported (e.g. it's a dynamic assembly).":"不支持指定的组件（例如，这是动态组件）。\r\n","\r\n The value for the Names property.\r\n ":"名称属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to Async methods cannot have ByRef parameters..\r\n":"\r\n  查找类似于异步方法的本地化字符串不能具有BYREF参数。\r\n\r\n","\r\n            Represents an and/or pattern, constructed from a logical and/or expression.\r\n            ":"\r\n            代表由逻辑和/或表达式构建的一个和/或模式。\r\n            \r\n","\r\n Does the compilation this symbol belongs to output to a winmdobj?\r\n ":"\r\n 该符号属于输出的汇编是否属于Winmdobj？\r\n \r\n","Target runtime doesn't support default interface implementation.":"目标运行时不支持默认接口实现。\r\n","Use interpolated verbatim string":"使用插值的逐字字符串\r\n","\r\n            Searches for types that match the name the user has written.  Returns ":"\r\n            搜索与用户编写的名称匹配的类型。返回\r\n","\r\n Returns a copy of this with the DistinctKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此的副本，而独特的键属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Represents a format string clause ':formatString' of an interpolated string\r\n embedded expression.\r\n ":"\r\n 代表插值字符串的格式字符串子句'：FEMATSTRING'\r\n 嵌入式表达。\r\n \r\n","\r\n  Looks up a localized string similar to Type parameter '{0}' must have either a 'New' constraint or a 'Structure' constraint to satisfy the 'New' constraint for type parameter '{1}'..\r\n":"\r\n  查找类似于类型参数'{0}'类型的本地化字符串，必须具有“新的”约束或“结构”约束，以满足“新的”约束类型参数'{1}'..\r\n\r\n","\r\n The value for the OptionKeyword property.\r\n ":"\r\n OptionKeyword属性的值。\r\n \r\n","Replace '{0}' with property":"用属性替换'{0}'\r\n","Delegate invocation can be simplified.":"可以简化委托调用。\r\n","\r\n Returns an array of AssemblySymbol objects corresponding to assemblies referenced \r\n by this module. Items at the same position from GetReferencedAssemblies and \r\n from GetReferencedAssemblySymbols should correspond to each other. If reference is \r\n not resolved by compiler, GetReferencedAssemblySymbols returns MissingAssemblySymbol in the\r\n corresponding item.\r\n \r\n The array and its content is provided by ReferenceManager and must not be modified.\r\n ":"\r\n 返回与引用的汇编相对应的汇编符号对象\r\n 通过此模块。从GetRefercrededsemblies和\r\n 从GetRefercedsed Assemblysymbols中应相对应。如果参考为\r\n 编译器无法解决，getRefercrededAssemblysymbols返回在此处返回的Assemblysymbol\r\n 相应的项目。\r\n \r\n 数组及其内容由ReferenceManager提供，不得修改。\r\n \r\n","True if detect type circularity code should step into 'typeToTest' type ":"正确，如果检测到类型的循环代码应逐步进入“ TypeTotest”类型\r\n"," location in a ":" 位置\r\n","\r\n            Derived type for class or struct. Shown as O↓\r\n            ":"\r\n            类或结构的派生类型。显示为o↓\r\n            \r\n","Original lambda node.":"原始的lambda节点。\r\n","\r\n            Determines if the items are similar enough they should be represented by a single item in the list.\r\n            ":"\r\n            确定项目是否足够相似，应由列表中的单个项目表示。\r\n            \r\n","\r\n A representation of a property symbol that is intended only to be used for comparison purposes\r\n (esp in PropertySignatureComparer).\r\n ":"\r\n 属性符号的表示，仅用于比较目的\r\n （ESP在PropertySignatureComparer中）。\r\n \r\n","numbered backreference":"编号的反向\r\n"," like normal, but will end up inserting more than just a name into\r\n            the editor.  For example, committing a conversion will insert the conversion prior to the expression being\r\n            dotted off of.\r\n            ":" 像正常人一样，但最终会插入更多的名称\r\n            编辑。例如，进行转换会在表达式之前插入转换\r\n            点缀了。\r\n            \r\n","\r\n Binder for Finally blocks. \r\n Its purpose is to hide exit try label of the enclosing try binder.\r\n ":"\r\n 粘合剂最终阻止。\r\n 它的目的是隐藏封闭尝试粘合剂的尝试标签。\r\n \r\n","In order to do convert between indexers, the type must look 'indexable'.  Meaning, it must\r\n             have an ":"为了在索引器之间进行转换，该类型必须看起来“可索引”。意思是，它必须\r\n             有一个\r\n"," Current region span, valid only for region based analysis ":" 当前的区域跨度，仅适用于基于区域的分析\r\n"," since they are only needed when changes are detected in the solution.\r\n            ":" 由于仅在解决方案中检测到更改时才需要它们。\r\n            \r\n","\r\n Returns a copy of this with the Declaration property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，声明属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n The For Each statement that begins a For Each-Next block. This statement always\r\n occurs as the Begin of a ForBlock, and the body of the For Each-Next is the\r\n Body of that ForBlock. Most of the time, the End of that ForBlock is the\r\n corresponding Next statement. However, multiple nested For statements are ended\r\n by a single Next statement with multiple variables, then the inner For\r\n statements will have End set to Nothing, and the Next statement is the End of\r\n the outermost For statement that is being ended.\r\n ":"\r\n 对于每个隔壁块开始a的每个语句。总是这个说法\r\n 发生作为for骨的开始，每个接口的主体是\r\n 那个Forblock的主体。在大多数情况下，该框架的结尾是\r\n 对应的下一个语句。但是，陈述的多个嵌套结束\r\n 通过一个具有多个变量的下一个语句，然后是内在的\r\n 陈述将结束为一无所有，下一个声明是\r\n 最外面的陈述正在结束。\r\n \r\n","\r\n Decodes a set of modifier flags, reported any errors with the flags.\r\n ":"\r\n 解码一组修饰符标志，报告了标志的任何错误。\r\n \r\n","\r\n Returns a copy of this with the WhenTrue property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，Whentrue属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Symbol to copy bound return type attributes from, or null if the attributes are not shared among multiple source symbols.\r\n ":"\r\n 符号以从多个源符号之间共享属性，以复制绑定的返回类型属性或null。\r\n \r\n","\r\n An array of assemblies involved in canonical type resolution of\r\n NoPia local types defined within this assembly. In other words, all \r\n references used by a compilation referencing this assembly.\r\n The array and its content is provided by ReferenceManager and must not be modified.\r\n ":"\r\n 参与规范类型分辨率的一系列组件\r\n NOPIA在此组件中定义的本地类型。换句话说，所有人\r\n 参考此组件的汇编使用的参考文献。\r\n 数组及其内容由ReferenceManager提供，不得修改。\r\n \r\n"," Creates a token with kind FloatingLiteralToken from a 4-byte floating point value. ":" 从4字节浮点值创建一个具有友善浮点数的令牌。\r\n","\r\n  Looks up a localized string similar to Source interface '{0}' is missing method '{1}', which is required to embed event '{2}'..\r\n":"\r\n  查找类似于源界面'{0}'的本地化字符串丢失方法'{1}'，这是嵌入事件'{2}'..所必需的\r\n\r\n","\r\n Helper to check whether the token is a predefined type\r\n ":"\r\n 助手检查令牌是否是预定义的类型\r\n \r\n","Parameter '{0}' can be removed; its initial value is never used":"可以删除参数'{0}'；它的初始值永远不会使用\r\n","Fix Name Violation: {0}":"修复名称违规：{0}\r\n","\r\n            Service that can be used to generate ":"\r\n            可用于生成的服务\r\n"," Creates a token with kind DecimalLiteralToken from the text and corresponding decimal value. ":" 从文本和相应的十进制值中创建一个用善良的分数数字来创建一个令牌。\r\n","After the Is and IsNot operators.":"在IS和ISNOT运算符之后。\r\n","\r\n A symbol referenced by a cref attribute (e.g. in a <see> or\r\n <seealso> documentation comment tag). For example, the M in <see\r\n cref=\"M\" />.\r\n ":"\r\n Cref属性引用的符号（例如，在A <see>或\r\n <Seealso>文档评论标签）。例如，m in <见\r\n cref =“ m” />。\r\n \r\n",", with that single ":"，与那个单曲\r\n","\r\n            Determines whether the specified TypeSyntax is actually 'var'.\r\n            ":"\r\n            确定指定的型号是否实际上是“ var”。\r\n            \r\n","Child nodes that should always be compared":"应该始终比较的儿童节点\r\n","\r\n The \"As\" keyword, if any type constraints were supplied. If no type constraints\r\n were supplied, Nothing is returned.\r\n ":"如果提供了任何类型的约束，则“ AS”关键字。如果没有类型的约束\r\n 被提供，什么也没有归还。\r\n \r\n","\r\n Type or member exposing the type.\r\n ":"\r\n 类型或成员暴露类型。\r\n \r\n","\r\n Strangely enough there is such a thing as unary concatenation and it must be rewritten.\r\n ":"\r\n 奇怪的是，有一件事，必须重写。\r\n \r\n","\r\n Manages automatically embedded content.\r\n ":"\r\n 管理自动嵌入内容。\r\n \r\n","\r\n            Return all the available cast pairs, format is (target argument expression, potential conversion type)\r\n            ":"\r\n            返回所有可用的铸造对，格式为（目标参数表达式，潜在转换类型）\r\n            \r\n","\r\n Gets a value indicating whether this instance is overloads.\r\n ":"\r\n 获取一个指示此实例是否过载的值。\r\n \r\n","#nullable\r\n            enable":"#nullable\r\n            使能够\r\n","\r\n            The path to the script source if it originated from a file, empty otherwise.\r\n            ":"\r\n            脚本源的路径如果起源于文件，则否则为空。\r\n            \r\n","s containing fixes is set to\r\n            ":"c contage fixes设置为\r\n            \r\n","\r\n Create an Expression Tree Node with the given name and arguments\r\n ":"\r\n 用给定名称和参数创建一个表达树节点\r\n \r\n",". Not available to clients. Only used by \r\n            the Completion subsystem itself for things like getting description text\r\n            and making additional change during commit.\r\n            ":"。客户不可用。仅使用\r\n            完成子系统本身，例如获取描述文本\r\n            并在提交期间做出额外的更改。\r\n            \r\n","\r\n            The full names of uncollectible assemblies generated by this context must be unique,\r\n            so that we can resolve references among them. Note that CLR can load two different assemblies of the very same \r\n            identity into the same load context.\r\n            \r\n            We are using a certain naming scheme for the generated assemblies (a fixed name prefix followed by a number). \r\n            If we allowed the compiled code to add references that match this exact pattern it might happen that \r\n            the user supplied reference identity conflicts with the identity we use for our generated assemblies and \r\n            the AppDomain assembly resolve event won't be able to correctly identify the target assembly.\r\n            \r\n            To avoid this problem we use a prefix for assemblies we generate that is unlikely to conflict with user specified references.\r\n            We also check that no user provided references are allowed to be used in the compiled code and report an error (\"reserved assembly name\").\r\n            ":"\r\n            此上下文生成的不可收回的组件的全名必须是唯一的，\r\n            这样我们就可以解决其中的参考。请注意，CLR可以加载非常相同的两个不同的组件\r\n            身份到同一负载上下文中。\r\n            \r\n            我们正在为生成的程序集使用某个命名方案（固定名称前缀，然后是数字）。\r\n            如果我们允许编译的代码添加与此确切模式匹配的引用，则可能发生\r\n            用户提供的参考身份与我们用于生成的程序集的身份发生冲突\r\n            AppDomain组件解决事件将无法正确识别目标组件。\r\n            \r\n            为了避免此问题，我们使用一个前缀用于我们生成的组件，该组件不太可能与用户指定的引用冲突。\r\n            我们还检查是否允许在编译代码中使用任何用户提供的参考文献并报告错误（“保留汇编名称”）。\r\n            \r\n","\r\n This is a base class for all query operators.\r\n ":"\r\n 这是所有查询操作员的基类。\r\n \r\n","\r\n Returns true if this type is known to be a value type. It is never the case\r\n that ":"\r\n 如果已知该类型是值类型，则返回true。从来没有\r\n 那\r\n","\r\n Returns a flag indicating whether this symbol has at least one applied conditional attribute.\r\n ":"\r\n 返回一个标志，指示此符号至少具有一个有条件的属性。\r\n \r\n","\r\n            Defines the text changes needed to apply an intent.\r\n            ":"\r\n            定义应用意图所需的文本更改。\r\n            \r\n","\r\n Gets a value indicating whether this instance is shared.\r\n ":"\r\n 获取一个指示该实例是否共享的值。\r\n \r\n","\r\n            TODO: Rewrite this to track backward through references instead of binding everything\r\n            ":"\r\n            TODO：将其重写以通过引用向后跟踪，而不是绑定所有内容\r\n            \r\n"," Set of processed structure types ":" 一组处理结构类型\r\n","\r\n            True, if there is at least one potential conversion pair, and they are assigned to \"potentialConversionTypes\"\r\n            False, if there is no potential conversion pair.\r\n            ":"\r\n            是的，如果至少有一个潜在的转换对，并且它们被分配给“势换型”\r\n            假，如果没有潜在的转换对。\r\n            \r\n","\r\n Gets the ordinal order of this type parameter. The first type parameter has ordinal zero.\r\n ":"\r\n 获取此类型参数的顺序顺序。第一个类型参数具有序数零。\r\n \r\n","Introduce local":"介绍本地\r\n","Place statement on following line":"在以下行上放置语句\r\n","\r\n            The description of a ":"\r\n            描述\r\n","The target runtime doesn't support extensible or runtime-environment default calling conventions.":"目标运行时不支持可扩展或环境默认通话惯例。\r\n","Moving {0} requires restarting the application.":"移动{0}需要重新启动应用程序。\r\n","Upgrade all C# projects to language version '{0}'":"将所有C＃项目升级到语言版本'{0}'\r\n","The assignment statement of the current value.":"当前值的赋值语句。\r\n","\r\n            Signifies that the higher-bound of a range pattern\r\n            ":"\r\n            表示范围模式的较高限制\r\n            \r\n","\r\n Represents a type parameter in a RetargetingModuleSymbol. Essentially this is a wrapper around \r\n another TypeParameterSymbol that is responsible for retargeting symbols from one assembly to another. \r\n It can retarget symbols for multiple assemblies at the same time.\r\n ":"\r\n 表示RetargetingModuleSymbol中的类型参数。 从本质上讲，这是一个包装 \r\n 另一个TypeParameterSymbol，负责将符号从一个程序集重新定位到另一个程序集。 \r\n 它可以在同一时间为多个程序集重新定位符号。\r\n \r\n",".\r\n            - Token whose direct parent of type ":"。\r\n             - 名字的直接父母\r\n","'{0}.{1}' is not supported in this version":"'{0}.此版本不支持{1}'\r\n","Source file can only contain one file-scoped namespace declaration.":"源文件只能包含一个文件窃取的名称空间声明。\r\n","Simplify interpolation":"简化插值\r\n","Alias ambiguous type '{0}'":"别名模棱两可的类型'{0}'\r\n","diagnostic bag if errors are to be reported":"如果要报告错误，诊断袋\r\n","Assigning to readonly fields must be done in a constructor : [{0}].":"必须在构造函数中进行分配给读取字段：[{0}]。\r\n","\r\n The assembly to which the given type Is forwarded Or null, if there isn't one.\r\n ":"\r\n 如果没有，则给定类型的组件转发或无效。\r\n \r\n","\r\n Gets the attributes on this symbol. Returns an empty ImmutableArray if there are\r\n no attributes.\r\n ":"\r\n 获取此符号上的属性。如果有的话，将返回一个空的immutablearray\r\n 没有属性。\r\n \r\n","\r\n            Calculate the inheritance distance between baseType and derivedType.\r\n            ":"\r\n            计算底型和派生类型之间的继承距离。\r\n            \r\n","\r\n This instance is used when trying to determine which implemented interface event is implemented\r\n by a event with an Implements clause, according to VB rules.\r\n This comparer uses event signature that may come from As clause delegate or from a parameter list.\r\n The event signatures are compared without regard to name (including the interface part, if any)\r\n and the return type must match. (NOTE: that return type of implementing event is always Void)\r\n ":"\r\n 试图确定实现哪个实现的接口事件时使用此实例\r\n 根据VB规则，通过具有工具子句的事件。\r\n 该比较使用可能来自子句委托或参数列表的事件签名。\r\n 比较事件签名而无需考虑名称（包括接口部分，如果有）\r\n 返回类型必须匹配。 （注意：实施事件的返回类型始终是无效的）\r\n \r\n"," keyword over it as the user starts typing.  Being able to type ":" 当用户开始键入时，关键字上的关键字。能够输入\r\n","\r\n            This class handles rewriting initializer expressions that refer to the variable\r\n            being initialized into a simpler form.  For example, in \"int x = x = 1\", we want to\r\n            get just \"1\" back as the initializer.\r\n            ":"\r\n            该类负责重写初始化器表达式，该表达式参考变量\r\n            被初始化为更简单的形式。例如，在“ int x = x = 1”中，我们要\r\n            仅作为初始化器获得“ 1”。\r\n            \r\n","\r\n Represents literal text content in an interpolated string.\r\n ":"\r\n 表示插值字符串中的字面文本内容。\r\n \r\n","\r\n            A mapping containing the simple names of all imported extension methods, mapped to the import that\r\n            they're brought in by.  This doesn't keep track of arity because methods can be called with type\r\n            arguments.\r\n            ":"\r\n            包含所有导入扩展方法的简单名称的映射，映射到导入的\r\n            他们带来了。这不会跟踪Arity，因为可以使用类型调用方法\r\n            参数。\r\n            \r\n","\r\n            Indicate the relationship between the member and its inheritance target\r\n            ":"\r\n            指示成员与其继承目标之间的关系\r\n            \r\n","symbol, other":"符号，其他\r\n","\r\n The value for the AdditionalJoins property.\r\n ":"\r\n 附加属性的值。\r\n \r\n","\r\n Returns the appropriate AttributeTarget for a symbol.  This is used to validate attribute usage when\r\n applying an attribute to a symbol. For any symbol that does not support the application of custom\r\n attributes 0 is returned.\r\n ":"\r\n 返回符号的适当属性。这用于验证属性用法\r\n 将属性应用于符号。对于不支持自定义应用的任何符号\r\n 属性0返回。\r\n \r\n","\r\n            Gets the matches of the expression and replaces them with the identifier.\r\n            Special case for the original matching expression, if its parent is a LocalDeclarationStatement then it can\r\n            be removed because assigning the local dec variable to a parameter is repetitive. Does not need a rename\r\n            annotation since the user has already named the local declaration.\r\n            Otherwise, it needs to have a rename annotation added to it because the new parameter gets a randomly\r\n            generated name that the user can immediately change.\r\n            ":"\r\n            获取表达式的匹配，并用标识符代替它们。\r\n            原始匹配表达式的特殊情况，如果其父属于localdeclarationstatement，则可以\r\n            被删除是因为将本地DEC变量分配给参数是重复的。不需要重命名\r\n            注释由于用户已经命名了本地声明。\r\n            否则，它需要在其上添加重命名注释，因为新参数随机获取\r\n            用户可以立即更改的生成名称。\r\n            \r\n","\r\n  Looks up a localized string similar to You cannot use '{0}' in top-level script code.\r\n":"\r\n  在顶级脚本代码中查找类似于您无法使用'{0}'的本地化字符串。\r\n\r\n","\r\n The value for the OperatorKeyword property.\r\n ":"\r\n OperatorKeyWord属性的值。\r\n \r\n","\r\n Should be called on the binder, at which the check should begin.\r\n ":"\r\n 应在粘合剂上调用检查应开始检查的活页夹。\r\n \r\n","\r\n The expression that serves as the source of items for the range variable.\r\n ":"\r\n 作为范围变量的项目来源的表达式。\r\n \r\n","The display name of an assembly":"组件的显示名称\r\n","\r\n Indices of duplicate assembly attributes, i.e. attributes that bind to the same constructor and have identical arguments, that must not be emitted.\r\n ":"\r\n 重复组装属性的索引，即与同一构造函数结合并具有相同参数的属性，不得发出。\r\n \r\n","With DateTime values, the \"zz\" custom format specifier represents the signed offset of the local operating system's time zone from UTC, measured in hours. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, the \"zz\" forma ...":"使用DateTime值，“ ZZ”自定义格式指定符表示本地操作系统时区与UTC的签名偏移，以小时为单位测量。它不会反映实例dateTime.kind属性的值。因此，“ ZZ” forma ...\r\n","separator, paragraph":"分离器，段落\r\n","The style(s) to apply to the text.":"适用于文本的样式。\r\n","\r\n Virtual dispatch based on a symbol's particular class. \r\n ":"\r\n 基于符号的特定类的虚拟调度。\r\n \r\n","\r\n Checks if 'symbol' is accessible from within assembly 'within'.  \r\n ":"\r\n 检查“符号”是否可以从汇编内“内部”内部访问。\r\n \r\n"," contain its checksum.\r\n            False if the document is not found in the PDB.\r\n            Null if it can't be determined because the PDB is not available or an error occurred while reading the PDB.\r\n            ":" 包含其校验和。\r\n            错误，如果在PDB中找不到文档。\r\n            null如果无法确定，因为PDB不可用或读取PDB时发生错误。\r\n            \r\n","The syntax tree to use for generating the location.":"用于生成位置的语法树。\r\n","A namespace symbol representing the merged namespace.(of /returns)\r\n":"代表合并名称空间的名称空间符号。（of /返回）\r\n\r\n","Generate new type...":"生成新类型...\r\n","\r\n  Looks up a localized string similar to Explicit initialization is not permitted for arrays declared with explicit bounds..\r\n":"\r\n  查找类似于显式初始化类似的本地化字符串，对于以显式范围声明的数组。\r\n\r\n","\r\n Because flags can be combined, use the method IsIdentityConversion when testing for ConversionKind.Identity\r\n ":"\r\n 因为可以组合标志，请在测试convensionkind.Identity时使用方法IsidentityConversion\r\n \r\n"," flags.\r\n 4) Synthesized constructors of ComImport types\r\n ":" 标志。\r\n 4）Comimport类型的合成构造函数\r\n \r\n","{0} must return a stream that supports read and seek operations.":"{0}必须返回支持阅读和寻求操作的流。\r\n","\r\n            The left operand is the constant.\r\n            ":"\r\n            左操作数是常数。\r\n            \r\n","\r\n Cache of value types which were already calculated by LocalOrFieldNeedsToBeCleanedUp \r\n in this lowering, serves as an optimization \r\n ":"\r\n 价值类型的缓存，这些类型已经由locelorfieldneedstobecleanedup计算\r\n 在此降低中，作为优化\r\n \r\n","\r\n Modifies an input ":"\r\n 修改输入\r\n","\r\n Returns a copy of this with the LowerBound property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此的副本，而下部属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Create a missing punctuation mark.\r\n ":"\r\n 创建一个缺失的标点符号。\r\n \r\n"," for remaining fixup steps.\r\n ":" 用于剩余的修复步骤。\r\n \r\n","\r\n Whether the method is used as extension method vs. called as a static method.\r\n ":"\r\n 该方法是否用作扩展方法，而称为静态方法。\r\n \r\n","\r\n  Looks up a localized string similar to 'Handles' in classes must specify a 'WithEvents' variable, 'MyBase', 'MyClass' or 'Me' qualified with a single identifier..\r\n":"\r\n  查找类似于类中的“手柄”的本地化字符串必须指定“ withEvents”变量，“ mybase”，“ myclass”或“ me”或“我”，具有单个标识符。\r\n\r\n","\r\n Should be in sync with Binder.ReportByValConversionErrors.\r\n ":"\r\n 应该与binder同步。\r\n \r\n","\r\n Gets the associated \"get\" method for this property. If this property\r\n has no get accessor, returns Nothing.\r\n ":"\r\n 获取此属性相关的“获取”方法。如果此属性\r\n 没有登录器，什么也没返回。\r\n \r\n","\r\n  Looks up a localized string similar to Forwarded type '{0}' conflicts with type declared in primary module of this assembly..\r\n":"\r\n  查找类似于转发类型'{0}'冲突的本地化字符串与此汇编主模块中声明的类型冲突。\r\n\r\n","\r\n This is a SyntaxReference implementation that lazily finds the beginning of the block (if any) of the original syntax reference\r\n ":"\r\n 这是一种语法雷神实现，懒惰地找到了原始语法参考的块（如果有）的开始\r\n \r\n","Assembly symbol or Nothing.":"装配符号或什么都没有。\r\n","Record member '{0}' must be public.":"记录成员'{0}'必须公开。\r\n","Generate implicit conversion operator in '{0}'":"在'{0}'中生成隐式转换运算符\r\n","Remove operator (preserves semantics)":"删除操作员（固定语义）\r\n","\r\n Represents a TypeOf...Is or IsNot expression.\r\n ":"\r\n 代表一个类型... IS或ISNOT表达式。\r\n \r\n","Available":"可用的\r\n","A boolean value set to True if character is a hash character.":"如果字符是哈希字符，则将布尔值设置为true。\r\n","\r\n The value for the EndOperatorStatement property.\r\n ":"\r\n endoperatorStatement属性的值。\r\n \r\n","\r\n Analyzes method body for error conditions such as definite assignments, unreachable code etc...\r\n \r\n This analysis is done when doing the full compile or when responding to GetCompileDiagnostics.\r\n This method assume that the trees are already bound and will not do any rewriting/lowering\r\n It is possible and common for this analysis to be done in the presence of errors.\r\n ":"\r\n 分析方法主体，以了解错误条件，例如确定的作业，无法到达的代码等...\r\n \r\n 进行完整的编译或响应GetCompileDiagnostics时，进行了此分析。\r\n 该方法假设树已经被绑定了，不会进行任何重写/降低\r\n 在存在错误的情况下，可以进行此分析的可能性和常见。\r\n \r\n","\r\n            this holds onto changes made by formatting engine.\r\n            ":"\r\n            这可以通过格式化引擎进行更改。\r\n            \r\n","A function pointer cannot be called with named arguments.":"函数指针无法使用命名参数调用。\r\n","\r\n A type used as a tag that indicates which type of modification applies.\r\n ":"\r\n 用作标签的类型，指示应用哪种类型的修改。\r\n \r\n","\r\n The conversion of the return value of the current call to the type of the control variable \r\n (contains a placeholder).\r\n ":"\r\n 当前调用的返回值转换为控制变量的类型\r\n （包含一个占位符）。\r\n \r\n","The resolution result.":"分辨率结果。\r\n","\r\n Non-user code lambdas are synthesized lambdas that create an instance of an anonymous type representing a pair of values,\r\n or otherwise transform sequences/anonymous types from one form to another without calling user code.\r\n TODO: Could we avoid generating proper lambdas for these?\r\n ":"\r\n 非用户代码lambdas是合成的lambdas，创建一个代表一对值的匿名类型的实例，\r\n 或者否则将序列/匿名类型从一种形式转换为另一种形式，而无需调用用户代码。\r\n 托多：我们可以避免为这些生成适当的兰伯达吗？\r\n \r\n","\r\n  Looks up a localized string similar to 'Sub' or 'Function' expected after 'Delegate'..\r\n":"\r\n  查找类似于“委托”之后预期的“ sub”或“函数”的本地化字符串。\r\n\r\n","\r\n The value for the CloseBraceToken property.\r\n ":"\r\n ClosebraceToken属性的价值。\r\n \r\n","\r\n Given result of binding preceding query operators, the source, bind the following Group By operator.\r\n \r\n     [{Preceding query operators}] Group [{items expression range variables}] \r\n                                   By {keys expression range variables}\r\n                                   Into {aggregation range variables}\r\n \r\n Ex: From a In AA Group By Key(a)          AA.GroupBy(Function(a) Key(a), \r\n                  Into Count()     ==>                Function(key, group_a) New With {key, group_a.Count()})\r\n                  \r\n Ex: From a In AA Group Item(a)            AA.GroupBy(Function(a) Key(a), \r\n                  By Key(a)        ==>                Function(a) Item(a), \r\n                  Into Count()                        Function(key, group_a) New With {key, group_a.Count()})\r\n \r\n Note, that type of the group must be inferred from the set of available GroupBy operators in order to be able to \r\n interpret the aggregation range variables. \r\n ":"\r\n 给定绑定前面的查询运算符的结果，源，由操作员绑定以下组。\r\n \r\n     [{{先前的查询运算符}] group [{项目表达式范围变量}]\r\n                                   由{键表达范围变量}\r\n                                   进入{聚合范围变量}\r\n \r\n 例如：从键（a）aa.groupby（function（a）键（a），从A组中）\r\n                  incount（）==> function（key，group_a）新的，{key，group_a.count（）}）\r\n                  \r\n 例如：从AA组项目（a）aa.groupby（function（a）键（a），\r\n                  通过键（a）==>函数（a）项目（a），\r\n                  进入count（）函数（key，group_a）使用{key，group_a.count（）}）\r\n \r\n 请注意，必须从一组可用的组运算符中推断出该组的类型，以便能够\r\n 解释聚合范围变量。\r\n \r\n","\r\n            Invalid character '{0}' in required attribute '{1}'. Expected supported CSS operator or ']'.\r\n            ":"无效的字符'{0}'在必需属性'{1}'中。预期支持的CSS操作员或“]”。\r\n            \r\n","\r\n Represents a single-line \"If ... Then ... Else ...\" statement.\r\n ":"\r\n 表示单行“如果...然后... else ...”语句。\r\n \r\n","\r\n            This implementation reports diagnostics via ":"\r\n            该实施通过\r\n","\r\n  Looks up a localized string similar to Method type arguments unexpected..\r\n":"\r\n  查找类似于方法类型参数的本地化字符串意外。\r\n\r\n","\r\n            Builds up the suffix to show for something with parameters in navigate-to.\r\n            While it would be nice to just use the compiler SymbolDisplay API for this,\r\n            it would be too expensive as it requires going back to Symbols (which requires\r\n            creating compilations, etc.) in a perf sensitive area.\r\n            \r\n            So, instead, we just build a reasonable suffix using the pure syntax that a \r\n            user provided.  That means that if they wrote \"Method(System.Int32 i)\" we'll \r\n            show that as \"Method(System.Int32)\" not \"Method(int)\".  Given that this is\r\n            actually what the user wrote, and it saves us from ever having to go back to\r\n            symbols/compilations, this is well worth it, even if it does mean we have to\r\n            create our own 'symbol display' logic here.\r\n            ":"\r\n            构建后缀以显示导航到中有参数的内容。\r\n            虽然只使用编译器Symboldisplay API是很好的，但是\r\n            它太贵了，因为它需要返回符号（这需要\r\n            在perf敏感区域中创建汇编等）。\r\n            \r\n            因此，相反，我们只是使用纯语法构建合理的后缀\r\n            提供的用户。这意味着，如果他们写“方法（system.int32 i）”，我们将\r\n            显示为“方法（System.int32）”非“方法（int）”。鉴于这是\r\n            实际上，用户写的是什么，它使我们免于不得不回到\r\n            符号/汇编，这是值得的，即使这确实意味着我们必须\r\n            在这里创建我们自己的“符号显示”逻辑。\r\n            \r\n","\r\n The value for the PropertyStatement property.\r\n ":"\r\n 属性属性属性的值。\r\n \r\n","\r\n            Enumerates tokens of all nodes in the list. Doesn't include separators.\r\n            ":"\r\n            列举列表中所有节点的令牌。不包括分离器。\r\n            \r\n","\r\n  Looks up a localized string similar to Type '{0}' exported from module '{1}' conflicts with type '{2}' exported from module '{3}'..\r\n":"\r\n  查找类似于从模块'{1}'导出的类型“ {0}”类型的本地化字符串与从模块'{3}的导出的类型'{2}'相冲突。\r\n\r\n","\r\n Containing module.\r\n ":"\r\n 包含模块。\r\n \r\n","\r\n  Looks up a localized string similar to Expressions used with an 'If' expression cannot contain type characters..\r\n":"\r\n  查找类似于“ if”表达式所用表达式类似的本地化字符串，无法包含类型字符。\r\n\r\n","\r\n §11.8.1 Overloaded Method Resolution\r\n      7.\tOtherwise, given any two members of the set, M and N, apply the following tie-breaking rules, in order.\r\n ":"\r\n §11.8.1超载方法分辨率\r\n      7.否则，鉴于集合M和N的任何两个成员，请按顺序应用以下抢七规则。\r\n \r\n",".  The generated function will\r\n            defer to HashCode.Combine if it exists.  Otherwise, it will determine if it should\r\n            generate code directly in-line to compute the hash, or defer to something like\r\n            ":"。生成的功能将\r\n            如果存在，请延迟到hashcode.combine。否则，它将确定是否应该\r\n            直接在线生成代码以计算哈希或延迟类似\r\n            \r\n","The interface '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The constraint interface '{1}' or its base interface has static abstract members.":"在通用类型或方法'{0}'中，接口'{3}'不能用作类型参数'{2}'。约束接口'{1}'或其基本接口具有静态抽象成员。\r\n","Invocation of implicit Range Indexer cannot name the argument.":"隐式范围索引器的调用无法命名参数。\r\n","\r\n            Note: For a nested type, a matching document name could be just the type name or a\r\n            dotted qualified name of its type hierarchy.\r\n            ":"\r\n            注意：对于嵌套类型，匹配的文档名称可能只是类型名称或\r\n            该类型层次结构的虚线合格名称。\r\n            \r\n","\r\n            this will be used in the unit test to indicate certain action has happened or not.\r\n            ":"\r\n            这将在单位测试中使用，以表明某些动作是否发生了。\r\n            \r\n","\r\n True if conditional calls may be omitted when the required preprocessor symbols are not defined.\r\n ":"\r\n 如果未定义所需的预处理器符号时，则可能会省略条件调用。\r\n \r\n","\r\n            returns AdjustSpacesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation\r\n            ":"\r\n            返回两个令牌之间的awadspaceSoperation，或者通过过滤/替换下一次播放返回的操作\r\n            \r\n","\r\nCreates a string representing the unformatted LocalizableErrorArgument instance.\r\n ":"\r\n创建代表未格式化的本地化术语实例的字符串。\r\n \r\n","\r\n An elastic trivia with kind WhitespaceTrivia containing no characters. Elastic marker trivia are included\r\n automatically by factory methods when trivia Is Not specified. Syntax formatting will replace elastic\r\n markers with appropriate trivia.\r\n ":"\r\n 带有善良的弹性琐事，没有字符。包括弹性标记琐事\r\n 当未指定琐事时，会自动通过出厂方法。语法格式将取代弹性\r\n 具有适当琐事的标记。\r\n \r\n","The typed character that caused the item to be committed. \r\n            This character may be used as part of the change. \r\n            This value is null when the commit was caused by the [TAB] or [ENTER] keys.":"导致项目投入的打字字符。\r\n            该字符可以用作更改的一部分。\r\n            当提交是由[tab]或[enter]键引起的时，此值为null。\r\n","\r\n Returns a copy of this with the EnableKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 将其返回此副本，并更改​​为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Returns a copy of this with the ElseKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中ElseKeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' cannot override '{1}' because it is not declared 'Overridable'..\r\n":"\r\n  查找类似于'{0}'不能覆盖'{1}'的本地化字符串，因为它没有声明为“'trovilable'..\r\n\r\n","\r\n  Looks up a localized string similar to 'GoTo {0}' is not valid because '{0}' is inside a 'Using' statement that does not contain this statement..\r\n":"\r\n  查找类似于'goto {0}'的本地化字符串是无效的，因为'{0}'在a内部使用“使用”语句中不包含此语句。\r\n\r\n","\r\n            Is this method or property a valid place to set a breakpoint and does it match the expected parameter count?\r\n            ":"\r\n            该方法或属性是设置断点的有效位置，并且与预期参数计数匹配吗？\r\n            \r\n","it provides a custom way of resolving annotations to retrieve right tokens to attach trivia":"它提供了一种自定义的方法来解决注释以检索正确的令牌以附加琐事\r\n","\r\n            Contains metadata that can be used to identify the kind of sub-action these edits\r\n            apply to for the requested intent.\r\n            ":"\r\n            包含可用于识别这些编辑的亚法类型的元数据\r\n            申请要求的意图。\r\n            \r\n"," with ref-specific exclusions\r\n            ":" 带有特定于参考的排除\r\n            \r\n"," instance or null if the assembly is not available.":" 实例或null如果程序集不可用。\r\n","\r\n            1) extended nodes that can be converted into clauses\r\n            2) identifiers introduced in nodes that can be converted\r\n            3) statements that cannot be converted into clauses\r\n            4) trailing comments to be added to the end\r\n            ":"\r\n            1）可以转换为从句的扩展节点\r\n            2）在节点中引入的标识符可以转换\r\n            3）不能转换为条款的陈述\r\n            4）尾随的评论要添加到最后\r\n            \r\n"," Creates a token with kind CharacterLiteralToken from a character value. ":" 从字符值创建具有善良的字符的令牌。\r\n","\r\n  Looks up a localized string similar to The '{0}' keyword is used to overload inherited members; do not use the '{0}' keyword when overloading 'Sub New'..\r\n":"\r\n  查找类似于“ {0}”关键字的本地化字符串用于超载继承成员。超载'sub new'时，请勿使用'{0}'关键字。\r\n\r\n","\r\n Add an error to the given node, creating a new node that is the same except it has no parent,\r\n and has the given error attached to it. The error span is the entire span of this node.\r\n ":"\r\n 在给定节点上添加错误，创建一个新节点，除非没有父母，否则\r\n 并带有给定的错误。误差跨度是该节点的整个跨度。\r\n \r\n"," for everything, and you have ":" 对于一切，你有\r\n","\r\n The value for the Condition property.\r\n ":"\r\n 条件属性的值。\r\n \r\n","This will be the  original document that\r\n            ":"这将是原始文件\r\n            \r\n","\r\n The name of the label. If the label is a line number, returns an IntegerLiteral\r\n that is the line number, otherwise, returns an Identifier.\r\n ":"\r\n 标签的名称。如果标签是行号，请返回IntegerLiteral\r\n 那就是行号，否则将返回标识符。\r\n \r\n","\r\n Get symbol for predefined type member from Cor Library referenced by this compilation.\r\n ":"\r\n 从本汇编引用的COR库中获取预定义类型成员的符号。\r\n \r\n","Matches a backspace character, \\u0008":"匹配backspace字符\\ u0008\r\n","\r\n  Looks up a localized string similar to End of expression expected..\r\n":"\r\n  查找类似于预期表达式的局部字符串。\r\n\r\n","New expression to replace the original expression.":"新表达式以替换原始表达式。\r\n","\r\n This class represent a compiler generated method\r\n ":"\r\n 此类代表编译器生成的方法\r\n \r\n","\r\n            Duplicate param tag\r\n            ":"\r\n            重复参数标签\r\n            \r\n","The bound as clause type":"绑定为子句类型\r\n"," match a specified predicate.\r\n            ":" 匹配指定的谓词。\r\n            \r\n","\r\n  Looks up a localized string similar to Implicit variable '{0}' is invalid because of '{1}'..\r\n":"\r\n  查找类似于隐式变量'{0}'的本地化字符串，因为'{1}'..\r\n\r\n","The initial set of spans to align.":"初始跨度对齐。\r\n","_ = Computation();":"_ = Computation（）;\r\n"," member if it exists.\r\n            ":" 成员如果存在。\r\n            \r\n","A GlobalImport instance.":"一个全球IMPORT实例。\r\n","\r\n If \"node\" is a block statement return the Begin statement  of \"node\", otherwise return \"node\".\r\n ":"\r\n 如果“节点”是块语句返回“节点”的开头语句，则否则返回“ node”。\r\n \r\n","\r\n Owning RetargetingMethodSymbol.\r\n ":"\r\n 拥有RetargetingMethodSymbol.\r\n \r\n","\r\n Position within the tree. Doesn't need to exactly match the span returned by Locations, just\r\n be good enough to sort. In other words, we don't need to go to extra work to return the location of the identifier,\r\n just some syntax location is fine.\r\n \r\n Negative value indicates that the structure was not initialized yet, is used for lazy \r\n initializations only along with LexicalSortKey.NotInitialized\r\n ":"\r\n 在树内的位置。不需要与位置返回的跨越完全匹配，只是\r\n 足够排序。换句话说，我们不需要去额外的工作来返回标识符的位置，\r\n 只是一些语法位置就可以了。\r\n \r\n 负值表示该结构尚未初始化，用于懒惰\r\n 初始化仅与词汇园区一起进行。\r\n \r\n","\r\n The attribute class.\r\n ":"\r\n 属性类。\r\n \r\n","\r\n The value for the CloseParenToken property.\r\n ":"\r\n CloseParentoken属性的价值。\r\n \r\n","A syntax node that represents a parsed RangeArgumentSyntax node. This node should not be\r\n present in the syntax tree associated with this object.":"表示解析的rangeargumentsyntax节点的语法节点。这个节点不应该是\r\n 存在与此对象关联的语法树中。\r\n","\r\n            Assembly manifest module copy or a standalone module copy.\r\n            ":"\r\n            汇编清单模块副本或独立模块副本。\r\n            \r\n","The delegate invoke method.":"委托调用方法。\r\n","\r\n The value for the LowerBound property.\r\n ":"\r\n 下部属性的值。\r\n \r\n","\r\n            The set of text changes that should be applied to the input text to retrieve the\r\n            brace completion result.\r\n            ":"\r\n            应该应用于输入文本的文本更改集以检索\r\n            支架完成结果。\r\n            \r\n","\r\n The \"Next\"\r\n ":"\r\n 下一个”\r\n \r\n","s to be added to the script.\r\n            ":"s要添加到脚本中。\r\n            \r\n","\r\n  Looks up a localized string similar to Statement cannot appear within an Enum body. End of Enum assumed..\r\n":"\r\n  查找类似于语句的本地化字符串，无法在枚举主体内出现。枚举的末日。\r\n\r\n","It is assumed that if the type follows this shape that it is well behaved and that this\r\n             transformation will preserve semantics.  If this assumption is not good in practice, we\r\n             could always limit the feature to only work on an allow list of known safe types.":"假定如果类型遵循这种形状，则表现良好，并且\r\n             转型将保留语义。如果这个假设在实践中不好，我们\r\n             总是可以将功能限制为仅在已知安全类型的允许列表上工作。\r\n","The stream returned by ":"返回的流\r\n","\r\n Returns what symbol(s), if any, the given expression syntax bound to in the program.\r\n \r\n An AliasSymbol will never be returned by this method. What the alias refers to will be\r\n returned instead. To get information about aliases, call GetAliasInfo.\r\n \r\n If binding the type name C in the expression \"new C(...)\" the actual constructor bound to\r\n will be returned (or all constructor if overload resolution failed). This occurs as long as C\r\n unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple\r\n types, or C binds to a static class, then type(s) are returned.\r\n ":"\r\n 返回程序中绑定到的给定表达式语法（如果有的话）。\r\n \r\n 这种方法将永远不会返回别名鲍尔。别名是什么\r\n 而是返回。要获取有关别名的信息，请致电Getaliasinfo。\r\n \r\n 如果在“新c（...）”表达式中绑定类型名称c\r\n 将返回（如果过载分辨率失败，则将返回所有构造函数）。这是在C\r\n 明确地与具有构造函数的单一类型结合。如果c模糊地与多个结合\r\n 类型或C结合到静态类，然后返回类型。\r\n \r\n","\r\n Should return syntax node that originated the method. \r\n ":"\r\n 应返回该方法的语法节点。\r\n \r\n","\r\n Returns a copy of this with the EndSubStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中端态属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Gets the core Parse options.\r\n ":"\r\n 获取核心解析选项。\r\n \r\n","\r\n Called in member lookup right before going into the base class of a type. Results a set of named types whose\r\n bases classes are currently in the process of being resolved, so we shouldn't look into their bases\r\n again to prevent/detect circular references.\r\n ":"\r\n 进入成员查找，然后进入类型的基类。结果一组命名类型\r\n 基地课程目前正在解决，因此我们不应该研究他们的基础\r\n 再次防止/检测循环引用。\r\n \r\n","True if it is a predefined type":"如果是预定义的类型，则为true\r\n","\r\n            when true, solution crawler will be initialized when there is the first workspace event fired. \r\n            otherwise, it will be initialized when workspace is registered right away. \r\n            something like \"Build\" will use initializeLazily:false to make sure diagnostic analyzer engine (incremental analyzer)\r\n            is initialized. otherwise, if build is called before workspace is fully populated, we will think some errors from build\r\n            doesn't belong to us since diagnostic analyzer engine is not there yet and \r\n            let project system to take care of these unknown errors.\r\n            ":"如果是正确的，则解决第一个工作空间事件时将初始化解决方案牵引器。\r\n            否则，当工作空间立即注册时，它将初始化。\r\n            诸如“ build”将使用initializelazily：false以确保诊断分析仪引擎（增量分析仪）\r\n            被初始化。否则，如果在工作区完全填充之前调用构建，我们会认为构建中的某些错误\r\n            不属于我们，因为诊断分析仪引擎还没有，并且\r\n            让项目系统照顾这些未知错误。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Equals' cannot compare a value of type '{0}' with a value of type '{1}'..\r\n":"\r\n  查找类似于“ equals”的本地化字符串无法比较类型的值'{0}'的值'{1}'..\r\n\r\n","\r\n            The document in which the refactoring is triggered.\r\n            ":"\r\n            触发重构的文档。\r\n            \r\n",". The list will be returned in\r\n            top down order.  \r\n            ":"。列表将返回\r\n            自上而下的顺序。\r\n            \r\n"," and will\r\n            be automatically assigned to any ":" 还会\r\n            自动分配给任何\r\n","\r\n The \"Is\" keyword, if present.\r\n ":"\r\n 如果存在，则“是”关键字。\r\n \r\n","\r\n Full type name possibly with generic name mangling.\r\n ":"\r\n 完整类型的名称可能带有通用名称熔断。\r\n \r\n","\r\n The \"ReDim\" keyword.\r\n ":"\r\n “ redim”关键字。\r\n \r\n","Duplicate null suppression operator ('!')":"重复的null抑制操作员（'！'）\r\n","\r\n            A group of wrapping actions placed under a common title.  For example:\r\n                Unwrap group:\r\n                    unwrap option 1\r\n                    unwrap option 2\r\n                Wrap all group:\r\n                    wrap all option 1\r\n                    wrap all optoin 2\r\n                    ...\r\n            ":"\r\n            一组包裹动作置于公共标题下。例如：\r\n                UNABRAP组：\r\n                    UNABRAP选项1\r\n                    UNABRAP选项2\r\n                包裹所有小组：\r\n                    包裹所有选项1\r\n                    包裹所有光电2\r\n                    ...\r\n            \r\n","\r\n Source: Returns whether this method is async; i.e., does it have the Async modifier?\r\n Metadata: Returns False; methods from metadata cannot be async.\r\n ":"\r\n 资料来源：返回此方法是否为异步；即，它是否具有异步修饰符？\r\n 元数据：返回false;来自元数据的方法不能异步。\r\n \r\n","\r\n            contains information to restore trivia later on to the annotated tree\r\n            ":"\r\n            包含以后在带注释的树上恢复琐事的信息\r\n            \r\n","The currently set Visual Basic compilation options.":"当前设置的视觉基本汇编选项。\r\n"," property, as well as an indexer\r\n             that takes a ":" 属性以及索引器\r\n             那需要\r\n","\r\n Represents the header part of a lambda expression\r\n ":"\r\n 代表lambda表达式的标题部分\r\n \r\n","\r\n The End Property statement that ends the block.\r\n ":"\r\n 结束块的最终属性语句。\r\n \r\n","\r\n            Determines if any of the state sets in ":"\r\n            确定是否有任何状态设置\r\n","\r\n            Completion was triggered with a request to commit if a unique item would be selected \r\n            (ctrl-space in Visual Studio).\r\n            ":"\r\n            如果选择唯一项目\r\n            （视觉工作室中的CTRL空间）。\r\n            \r\n","\r\n Indicates whether a newline may validly precede the specified SyntaxToken without requiring an explicit line continuation sequence ' _' or terminating the containing statement.\r\n ":"\r\n 指示newline是否可以在指定的语法上有效之前，而无需明确的行延续序列'_'或终止包含的语句。\r\n \r\n","\r\n Used by Add*LookupSymbolsInfo* to determine whether the symbol is of interest.\r\n Distinguish from ":"\r\n 由添加* lookupsymbolsinfo*使用来确定符号是否是感兴趣的。\r\n 与众不同\r\n","\r\n            Adds to ":"\r\n            添加到\r\n","property getter":"属性Getter\r\n","\r\n  Looks up a localized string similar to 'Loop' must be preceded by a matching 'Do'..\r\n":"\r\n  查找类似于“循环”的局部字符串必须先于匹配的“ do”。\r\n\r\n","\r\n Return the most derived class type from the set of constraint types on this type\r\n parameter and any type parameter it depends on. Returns Nothing if there are\r\n no concrete constraint types. If there are multiple constraints, returns the most\r\n derived, ignoring any subsequent constraints that are neither more or less derived.\r\n This method assumes there are no constraint cycles. Unlike GetBaseConstraintType,\r\n this method will always return a NamedTypeSymbol representing a class: returning\r\n System.ValueType for value types, System.Array for arrays, and System.Enum for enums.\r\n ":"\r\n 从此类型上的一组约束类型返回最派生的类类型\r\n 参数及其取决于的任何类型参数。如果有任何东西，没有返回\r\n 没有具体约束类型。如果有多个约束，则返回最多\r\n 派生，忽略任何既不更或多或少派生的后续约束。\r\n 该方法假定没有约束周期。与getBaseConstraintType不同，\r\n 此方法将始终返回代表类的命名typeymbol：返回\r\n system.Valuetype for值类型，系统。数组的阵列和枚举的系统。\r\n \r\n","\r\n Used to store the bound field and property initializers and the associated list of\r\n bound assignment statements because they are reused for multiple constructors\r\n ":"\r\n 用于存储绑定字段和属性初始化器以及关联的列表\r\n 绑定分配声明是因为它们被重复用于多个构造函数\r\n \r\n","\r\n Given an expression that produces some result and \r\n has some observable evaluation side effects, return two expressions:\r\n   1) First - produces the same result with the same observable side effects,\r\n   2) Second - produces the same result, but without observable side effects, whenever possible.\r\n \r\n This is used for compound assignment, method call ByRef parameter copy back, etc.\r\n ":"\r\n 鉴于产生一些结果的表达\r\n 有一些可观察的评估副作用，返回两个表达式：\r\n   1）首先 - 产生相同的结果，具有相同的可观察副作用，\r\n   2）第二 - 产生相同的结果，但在可能的情况下没有可观察到的副作用。\r\n \r\n 这用于复合分配，方法调用ByRef参数复制，等等。\r\n \r\n","\r\n Returns a copy of this with the AttributeModifier property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中属性属性属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            The problem is that \"i.List\" gets parsed as a type.  In this case we need to try binding again as if \"i\" is\r\n            an expression and not a type.  In order to do that, we need to speculate as to what 'i' meant if it wasn't\r\n            part of a local declaration's type.\r\n            ":"\r\n            问题是“ i.list”被解析为一种类型。在这种情况下，我们需要再次尝试绑定，好像“我”是\r\n            表达而不是类型。为了做到这一点，我们需要推测“我”的意思是\r\n            本地声明类型的一部分。\r\n            \r\n","\r\n Get the state of Option Strict for the code covered by this semantic model.\r\n This takes into effect both file-level \"Option Strict\" statements and the project-level\r\n defaults.\r\n ":"\r\n 对此语义模型涵盖的代码进行严格的选择状态。\r\n 这可以生效文件级“选项严格”语句和项目级别\r\n 默认。\r\n \r\n","The delegate type could not be inferred.":"不能推断出代表类型。\r\n","Generator threw the following exception:\r\n            '{0}'.":"发电机抛出以下例外：\r\n            '{0}'。\r\n","\r\n Returns a copy of this with the FromValue property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此的副本，其中fromValue属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Represents a parenthesized list of argument types for a signature inside\r\n CrefReferenceSyntax syntax.\r\n ":"\r\n 表示内部签名的参数类型的括号列表\r\n crefreferencenceSyntax语法。\r\n \r\n","\r\n Returns a copy of this with the EndIfStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中Endiftatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","True if the method can be used as an entry point.":"如果可以将方法用作入口点，则为true。\r\n","\r\n Manages anonymous types declared in this compilation. Unifies types that are structurally equivalent.\r\n ":"\r\n 管理此汇编中声明的匿名类型。统一在结构上等效的类型。\r\n \r\n","\r\n            Enumerates all use sites of a specified variable within the specified syntax subtrees.\r\n            ":"\r\n            列举指定语法子树中指定变量的所有使用站点。\r\n            \r\n","\r\n The value for the EndEnumStatement property.\r\n ":"\r\n EndEnumStatement属性的值。\r\n \r\n","\r\n A symbol representing the implicit Script class. This is null if the class is not\r\n defined in the compilation.\r\n ":"\r\n 代表隐式脚本类的符号。如果班级不\r\n 在汇编中定义。\r\n \r\n","\r\n Materialize the capture, e.g. return an expression to be used instead of captured symbol\r\n ":"\r\n 实现捕获，例如返回要使用的表达式而不是捕获的符号\r\n \r\n","\r\n            Generates a file on disk containing general information about the symbol's containing\r\n            assembly, and the formatted source code for the public, protected, and\r\n            protected-or-internal interface of which the given ISymbol is or is a part of.\r\n            ":"\r\n            在包含有关该符号的一般信息的磁盘上生成文件\r\n            集会以及公众的格式化源代码，受保护和\r\n            给定的ISYMBOL是或是内部界面是或内部界面。\r\n            \r\n","switch statement case clause":"切换语句案例子句\r\n","\r\n The alias name.\r\n ":"\r\n 别名名称。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' cannot refer to itself through its default instance; use 'Me' instead..\r\n":"\r\n  查找类似于'{0}'的局部字符串，无法通过其默认实例引用自身；改用“我” ..\r\n\r\n","\r\n This is a symbol to represent Anonymous Delegate for a lambda\r\n like:\r\n        Sub() ...\r\n \r\n This delegate type doesn't have generic parameters. Unlike generic anonymous types,\r\n for which we are constructing new instance of substituted symbol for each use site \r\n with reference to the location, we are creating new instance of this symbol with its\r\n own location for each use site. But all of them are representing the same delegate \r\n type and are going to be equal to each other. \r\n ":"\r\n 这是代表lambda的匿名代表的符号\r\n 喜欢：\r\n        sub（）...\r\n \r\n 该委托类型没有通用参数。与通用匿名类型不同，\r\n 我们正在为每个使用站点构建替换符号的新实例\r\n 关于位置，我们正在创建此符号的新实例\r\n 每个使用站点的位置。但是所有人都代表同一代表\r\n 类型并将彼此相等。\r\n \r\n","non-word boundary":"非词边界\r\n","All symbols. This includes the Sm, Sc, Sk, and So categories.":"所有符号。这包括SM，SC，SK和SO类别。\r\n","\r\n            Batch fixer for pragma suppress code action.\r\n            ":"\r\n            PRAGMA的批次修复器抑制代码操作。\r\n            \r\n","\r\n Create a temp local of the given type and initial value.\r\n The resulting local is treated as an rvalue, and the\r\n initialization assignment is added to 'sideEffects'.\r\n ":"\r\n 创建给定类型和初始值的温度局部。\r\n 由此产生的本地被视为rvalue，\r\n 初始化分配添加到“副作用”中。\r\n \r\n","\r\n Slight performance improvement.\r\n ":"\r\n 略有性能改善。\r\n \r\n","\r\n The value for the Content property.\r\n ":"\r\n 内容属性的值。\r\n \r\n","\r\n Represents a compile time constant.\r\n ":"\r\n 代表编译时间常数。\r\n \r\n","\r\n  Looks up a localized string similar to You must reference at least one range variable on both sides of the 'Equals' operator. Range variable(s) {0} must appear on one side of the 'Equals' operator, and range variable(s) {1} must appear on the other..\r\n":"\r\n  查找类似于您的本地化字符串，必须在“平等”操作员两侧的至少一个范围变量中引用一个范围。范围变量（S）{0}必须出现在“ equals”运算符的一侧，并且范围变量必须出现在另一侧。\r\n\r\n","The (?# comment) construct lets you include an inline comment in a regular expression. The regular expression engine does not use any part of the comment in pattern matching, although the comment is included in the string that is returned by the Regex.ToSt ...":"（？＃评论）构造让您在正则表达式中包含内联评论。正则表达式引擎在图案匹配中不使用注释的任何部分，尽管该评论包含在Regex.tost返回的字符串中。\r\n"," if none is otherwise specified.\r\n            ":" 如果没有其他指定。\r\n            \r\n","\r\n The value of the character, after removing the quotation marks.\r\n ":"\r\n 删除引号后，角色的价值。\r\n \r\n","\r\n            A preferred name used to generated a declaration when the\r\n            inline method's body is not a valid expresion in ExpressionStatement\r\n            Example:\r\n            void Caller()\r\n            {\r\n                Callee();\r\n            }\r\n            int Callee()\r\n            {\r\n                return 1;\r\n            };\r\n            After it should be:\r\n            void Caller()\r\n            {\r\n                int temp = 1;\r\n            }\r\n            int Callee()\r\n            {\r\n                return 1;\r\n            };\r\n            '1' is not a valid expression in ExpressionStatement so a declaration is needed to be generated.\r\n            ":"\r\n            一个首选名称，用于生成声明\r\n            Inline Method的主体不是表达阶段中的有效表达\r\n            例子：\r\n            void caller（）\r\n            {\r\n                callee（）;\r\n            }\r\n            int callee（）\r\n            {\r\n                返回1;\r\n            };\r\n            之后应该是：\r\n            void caller（）\r\n            {\r\n                int temp = 1;\r\n            }\r\n            int callee（）\r\n            {\r\n                返回1;\r\n            };\r\n            '1'不是表达阶段中的有效表达式，因此需要生成声明。\r\n            \r\n","\r\n Rewrite an async method into a state machine class.\r\n ":"\r\n 将异步方法重写为状态计算机类。\r\n \r\n","\r\n  Looks up a localized string similar to Anonymous type member name can be inferred only from a simple or qualified name with no arguments..\r\n":"\r\n  查找类似于匿名类型成员名称的本地化字符串只能从没有参数的简单或合格名称中推断出。\r\n\r\n","The name '{0}' does not identify tuple element '{1}'.":"名称'{0}'不识别元组元素'{1}'。\r\n","A SemanticModel object that can be used to inquire about the semantic\r\n information associated with syntax nodes within ":"可以用来查询语义的语义模型对象\r\n 与语法节点相关的信息\r\n","\r\n            Returns the predefined keyword kind for a given ":"\r\n            返回给定的预定义关键字类型\r\n","\r\n Returns True if we should stop climbing inheritance hierarchy.\r\n ":"\r\n 如果我们应该停止攀登继承层次结构，将返回。\r\n \r\n","\r\n The value for the RegionKeyword property.\r\n ":"\r\n regionKeyword属性的值。\r\n \r\n","The bound AddressOf expression.":"绑定的地址表达式。\r\n",",\r\n            in which case ":"，，，，\r\n            在这种情况下\r\n","\r\n Apply \"conversion\" to the source based on the target AsClause Type of the CollectionRangeVariableSyntax.\r\n Returns implicit BoundQueryClause or the source, in case of an early failure.\r\n ":"\r\n 根据CollectionRangeVariablesyntax的目标Asclause类型应用“转换”。\r\n 在早期失败的情况下，返回隐式边界普通或来源。\r\n \r\n","\r\n This class associates a symbol with particular custom format for display.\r\n It can be passed as an argument for an error message in place where symbol display should go, \r\n which allows to defer building strings and doing many other things (like loading metadata) \r\n associated with that until the error message is actually requested.\r\n ":"\r\n 此类将一个符号与特定自定义格式相关联。\r\n 可以将其作为参数传递，以获取符号显示的位置中的错误消息，\r\n 这允许推迟建筑字符串并做许多其他事情（例如加载元数据）\r\n 与此关联，直到实际请求错误消息为止。\r\n \r\n"," portion of a ":" 一部分\r\n","Summary:":"概括：\r\n","\\S matches any non-white-space character. It is equivalent to the [^\\f\\n\\r\\t\\v\\x85\\p{Z}] regular expression pattern, or the opposite of the regular expression pattern that is equivalent to \\s, which matches white-space characters.\r\n            \r\n            If ECMAScript-compliant  ...":"\\ s匹配任何非白色空间字符。它等同于[^\\ f \\ n \\ r \\ t \\ t \\ v \\ x85 \\ p {z}]正则表达模式，或与\\ s相当的正则表达模式的相反，与\\ s相匹配，与\\ s匹配白空间字符。\r\n            \r\n            如果符合ecmascript的...\r\n"," is greater than 0.\r\n            ":" 大于0。\r\n            \r\n","\r\n While resolving the name, consider only types following CLS-compliant generic type names and arity encoding (ECMA-335, section 10.7.2).\r\n I.e. arity is inferred from the name and matching type must have the same emitted name and arity.\r\n ":"\r\n 在解决该名称时，仅考虑按照CLS兼容的通用类型名称和ARITY编码（ECMA-335，第10.7.2节）的类型。\r\n IE。从名称中推断出Arity，并且匹配类型必须具有相同的发射名称和Arity。\r\n \r\n","other, private use":"其他，私人用途\r\n","\r\n            Whether or not converting would transition the code to the style the user prefers. i.e. if the user likes\r\n            ":"\r\n            是否转换会将代码转换为用户喜欢的样式。即如果用户喜欢\r\n            \r\n","\r\n Properties imported from metadata return Nothing.\r\n ":"\r\n 从元数据中导入的属性一无所获。\r\n \r\n","\r\n Do not consider the return value local variable.\r\n This is similar to the C# LookupOption.MustBeInvocableMember.\r\n \r\n The only non-invocable member in Visual Basic is the function return variable \r\n (see language specification 10.1.1). If this flag is set, lookup will not \r\n return the function return variable, but instead return the containing function or property,\r\n and any overloads thereof.\r\n ":"\r\n 不要考虑返回值本地变量。\r\n 这类似于c＃lookupoption.mustbeinvocablemember。\r\n \r\n Visual Basic中唯一不可弹的成员是函数返回变量\r\n （请参阅语言规范10.1.1）。如果设置了此标志，查找不会\r\n 返回函数返回变量，而是返回包含的函数或属性，\r\n 及其任何过载。\r\n \r\n","\r\n            Return the set of direct Project and Package references for the given project. This\r\n            is used to get the initial state of the TreatAsUsed attribute for each reference.\r\n            ":"\r\n            返回给定项目的直接项目和软件包参考。这个\r\n            用于获取每个参考的治疗方法的初始状态。\r\n            \r\n","\r\n The \"state\" of the state machine that is the translation of the iterator method.\r\n ":"\r\n 状态机的“状态”是迭代方法的翻译。\r\n \r\n","\r\n Converts ImmutableDictionary of definitions used internally into IReadOnlyDictionary of definitions \r\n returned to a caller (of public API)\r\n ":"\r\n 将内部使用的定义的不可分割的定义转换为定义\r\n 返回给呼叫者（公共API）\r\n \r\n","\r\n             and the current ":"\r\n             和电流\r\n","\r\n Always returns False.\r\n ":"\r\n 总是返回false。\r\n \r\n","\r\n Do not do lookup in base classes (similar to how types in Imports are bound).\r\n ":"\r\n 请勿在基类中查找（类似于导入类型的绑定方式）。\r\n \r\n","\r\n Replaces substitution currently used by the rewriter for a placeholder node with a different substitution.\r\n Asserts if there isn't already a substitution.\r\n ":"\r\n 取代重写者目前使用的替代替代占位符节点的替代替代。\r\n 断言是否还没有替代。\r\n \r\n","\r\n Create a local symbol associated with an identifier token.\r\n ":"\r\n 创建与标识符令牌关联的本地符号。\r\n \r\n",".\r\n \r\n Otherwise, this returns ":"。\r\n \r\n 否则，这将返回\r\n","\r\n Handles MyBase.Event1\r\n ":"\r\n 处理mybase.event1\r\n \r\n","\r\n This subclass of MetadataDecoder is specifically for finding\r\n method symbols corresponding to method MemberRefs.  The parent \r\n implementation is unsuitable because it requires a PEMethodSymbol\r\n for context when decoding method type parameters and no such\r\n context is available because it is precisely what we are trying\r\n to find.  Since we know in advance that there will be no context\r\n and that signatures decoded with this class will only be used\r\n for comparison (when searching through the methods of a known\r\n TypeSymbol), we can return indexed type parameters instead.\r\n ":"\r\n 元二核编码器的这个子类专门用于查找\r\n 方法对应于方法成员RERFS的方法符号。父母\r\n 实施不合适，因为它需要pemethodsymbol\r\n 对于解码方法类型参数时的上下文，没有此类\r\n 可以使用上下文，因为它正是我们正在尝试的\r\n 找到。由于我们事先知道不会有上下文\r\n 并且该课程解码的签名只会使用\r\n 进行比较（搜索已知的方法\r\n typesymbol），我们可以返回索引类型参数。\r\n \r\n","\r\n The value for the ReferenceKeyword property.\r\n ":"\r\n ReferenceKeyword属性的值。\r\n \r\n","Generate comparison operators":"生成比较操作员\r\n","\r\n            The ```(...)``` node you get when the group does not start with ```(?```\r\n            ":"\r\n            ``（...）``当组不以``（？``````````````````````````````\r\n            \r\n","\r\n Returns a copy of this with the ErrorKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此的副本，其中errorkeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Represents a range \"expression To expression\" in a Case.\r\n ":"\r\n 在情况下表示“表达式”范围。\r\n \r\n","\r\n The With clause to initialize the new object.\r\n ":"\r\n 带有从句初始化新对象的子句。\r\n \r\n","\r\n            Specialized formatter for the \"return a == obj.a && b == obj.b && c == obj.c && ...\r\n            code that we spit out.\r\n            ":"“返回a == obj.a && b == obj.b && c == obj.c && ...\r\n            我们吐出的代码。\r\n            \r\n","\r\n Creates a half width form Unicode character string. \r\n ":"\r\n 创建半宽形式Unicode字符串。\r\n \r\n","\r\n A map between syntax trees and the root declarations in the declaration table.\r\n Incrementally updated between compilation versions when source changes are made.\r\n ":"\r\n 语法树和声明表中的根声明之间的地图。\r\n 进行源更改时，在编译版本之间进行了逐步更新。\r\n \r\n","\r\n            Constructor for a code style analyzer with a multiple diagnostic descriptors with a mix of language-specific and per-language options that can be used to configure each descriptor.\r\n            ":"\r\n            代码样式分析仪的构造函数，带有多个诊断描述符，其中包含语言特定和语言选项的混合，可用于配置每个描述符。\r\n            \r\n","An absolute path.":"绝对路径。\r\n","\r\n The value for the FirstExpression property.\r\n ":"\r\n 第一表达属性的值。\r\n \r\n"," As clause syntax. Can be nothing if no type was supplied.":" 作为子句语法。如果没有提供类型，则无能为力。\r\n","\r\n Compare SubstitutedNamedTypes with no regard to type arguments.\r\n ":"\r\n 比较替换的neamedtypes，而无需考虑类型参数。\r\n \r\n"," from spans provided by ":" 从提供的跨度\r\n","\r\n The actual text of this token.\r\n ":"\r\n 这个令牌的实际文本。\r\n \r\n"," \r\n Anonymous type field/parameter type, may be nothing when field descriptor is created,\r\n must be assigned before passing the descriptor to anonymous type descriptor.\r\n Once assigned, is considered to be 'sealed'. \r\n ":" \r\n 创建字段描述符时，匿名类型字段/参数类型可能无需\r\n 必须在将描述符传递给匿名类型描述符之前分配。\r\n 一旦分配，被视为“密封”。\r\n \r\n","Move file to '{0}'":"将文件移至'{0}'\r\n","\r\n The class to represent all generic type parameters imported from a PE/module.\r\n ":"\r\n 代表从PE/模块导入的所有通用类型参数的类。\r\n \r\n","\r\n            the beginning of the span within reference text that was the use of the reference\r\n            ":"\r\n            参考文本中跨度的开始，是参考的使用\r\n            \r\n","\r\n            Last array of module updates generated during the debugging session.\r\n            Useful for crash dump diagnostics.\r\n            ":"\r\n            在调试会话期间生成的最后一系列模块更新。\r\n            对于碰撞转储诊断有用。\r\n            \r\n","MyType.Get(System.Index)":"myType.get（system.index）\r\n","\r\n            Gets the capabilities of the runtime with respect to applying code changes.\r\n            Retrieved lazily from ":"\r\n            获取有关应用代码更改的运行时间功能。\r\n            懒洋洋地从\r\n","\r\n Method context for resolving generic method type arguments.\r\n ":"\r\n 解决通用方法类型参数的方法上下文。\r\n \r\n"," for a metadata reference used to create this compilation.\r\n ":" 对于用于创建此汇编的元数据参考。\r\n \r\n","The syntax facts for the current language.":"当前语言的语法事实。\r\n","\r\n  Looks up a localized string similar to the file '{0}' is not a text file.\r\n":"\r\n  查找类似于文件'{0}'的本地化字符串不是文本文件。\r\n\r\n","\r\n            Computes the fix all occurrences code fix and returns the changed solution.\r\n            ":"\r\n            计算修复程序所有出现代码修复并返回更改的解决方案。\r\n            \r\n","\r\n The default implementation is always correct, but may be unnecessarily slow.\r\n ":"\r\n 默认实现始终是正确的，但可能不必要地放慢速度。\r\n \r\n","\r\n The identifier that names the item being declared.\r\n ":"\r\n 名称所声明的项目的标识符。\r\n \r\n","\r\n            Flag indicating if suppressed diagnostics should be returned.\r\n            ":"\r\n            标志指示是否应退回被抑制的诊断。\r\n            \r\n","Add null checks for all parameters":"添加所有参数的空检查\r\n"," is not run. This is problematic because \r\n ":" 不运行。这是有问题的，因为\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' is not valid on an interface event declaration..\r\n":"\r\n  在接口事件声明上查找类似于“ {0}”的本地化字符串。\r\n\r\n","\r\n  Looks up a localized string similar to 'If' operator cannot be used in a 'Call' statement..\r\n":"在“呼叫”语句中查找类似于“如果”运算符的本地化字符串。\r\n\r\n","\r\n            Indicates if we should bail from removable assignment analysis for the given\r\n            symbol write operation.\r\n            Removable assignment analysis determines if the assigned value for the symbol write\r\n            has no side effects and can be removed without changing the semantics.\r\n            ":"指示我们是否应该从给定的可移动分配分析中保释\r\n            符号写操作。\r\n            可移动分配分析确定符号写的分配值是否\r\n            没有副作用，可以在不更改语义的情况下删除。\r\n            \r\n","\r\n            to be committed.  If false the completion host will determine if and where the commit \r\n            character is inserted into the document.\r\n            ":"\r\n            承诺。如果false，则完成主机将确定是否以及在何处\r\n            字符插入文档中。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Is' operator does not accept operands of type '{0}'. Operands must be reference or nullable types..\r\n":"\r\n  查找类似于“ IS”运算符的本地化字符串不接受类型'{0}'的操作数。操作数必须是参考或无效类型。\r\n\r\n","\r\n Data for Binder.BindImportClause that maintains flat lists of members, aliases,\r\n and corresponding syntax references in addition to the dictionaries needed by\r\n BindImportClause. The syntax references, instances of GlobalImportInfo, are used\r\n later, when validating constraints, to generate Locations for constraint errors.\r\n ":"\r\n Binder.Bindimportclause维护成员，别名，\r\n 以及相应的语法引用，除了所需的字典外\r\n bindimportclause。使用语法引用，Globalimportinfo的实例\r\n 稍后，在验证约束时，以生成约束错误的位置。\r\n \r\n","A set of type arguments to be applied. Must have the same length\r\n as the number of type parameters that this type has.":"一组要应用的类型参数。必须具有相同的长度\r\n 作为此类型具有的类型参数数量。\r\n","\r\n The \"US\" literal suffix denoting \"UShort\"\r\n ":"\r\n 表示“ ushort”的“我们”字面后缀\r\n \r\n","\r\n Create an inferred local symbol from a For-each statement.\r\n ":"从一个详情的语句中创建一个推断的本地符号。\r\n \r\n","lambda":"兰姆达\r\n","\r\n  Looks up a localized string similar to Comma, ')', or a valid expression continuation expected..\r\n":"\r\n  查找类似于逗号的局部字符串，或者预期的有效表达式连续。\r\n\r\n","\r\n            the length of the span of the reference\r\n            ":"\r\n            参考跨度的长度\r\n            \r\n","\r\n            Represents a span of an active statement tracked by the client editor.\r\n            ":"\r\n            表示客户端编辑器跟踪的活动语句的跨度。\r\n            \r\n","\r\n Sets the parameters.\r\n ":"\r\n 设置参数。\r\n \r\n"," is used to build up the map of all ":" 用于建立所有的地图\r\n","\r\n            The priority this item should have in the lightbulb list.\r\n            ":"\r\n            该项目应在灯泡列表中具有优先级。\r\n            \r\n","\r\n Report diagnostics relating to access shared/nonshared symbols. Returns true if an ERROR (but not a warning)\r\n was reported. Also replaces receiver as a type with DefaultPropertyInstance when appropriate.\r\n ":"\r\n 报告与访问共享/非心理符号有关的诊断。如果错误（但没有警告），则返回true\r\n 已经报道。在适当的情况下，还可以将接收器替换为具有DefaultPropertyinstance的类型。\r\n \r\n","\r\n The value for the NameKeyword property.\r\n ":"\r\n NameKeyword属性的值。\r\n \r\n","\r\n The value for the AddHandlerOrRemoveHandlerKeyword property.\r\n ":"\r\n AddhandLerorreMoveHandlerKeyword属性的值。\r\n \r\n","\r\n Given a method, infer control variable type. \r\n \r\n Returns inferred type or Nothing.\r\n ":"\r\n 给定方法，推断控制变量类型。\r\n \r\n 返回推断的类型或什么都不是。\r\n \r\n","lambda discard parameters":"lambda丢弃参数\r\n","\r\n  Looks up a localized string similar to '{0}' cannot be used as an attribute because it is declared 'MustInherit'..\r\n":"\r\n  查找类似于'{0}'的局部字符串，因为它被声明为'MustInherit'。\r\n\r\n","\r\n Scan a quoted string RIGHT_DOUBLE_QUOTATION_MARK\r\n ":"\r\n 扫描一个引用的字符串right_double_quotation_mark\r\n \r\n","\r\n A type can me marked as a ComImport type in source by applying the ":"\r\n 我可以通过应用\r\n","\r\n  Looks up a localized string similar to Constant cannot be the target of an assignment..\r\n":"\r\n  查找类似于常数的本地化字符串不能成为分配的目标。\r\n\r\n","\r\n The method (e.g. lambda) which is currently being rewritten. If we are \r\n rewriting a lambda, currentMethod is the new generated method.\r\n ":"\r\n 当前正在重写的方法（例如lambda）。如果是\r\n 重写lambda，CurrentMethod是新生成的方法。\r\n \r\n"," is available with the ":" 可与\r\n"," \r\n Describes anonymous type/delegate in terms of fields/parameters\r\n ":" \r\n 用字段/参数描述匿名类型/委托\r\n \r\n","\r\n Returns the method symbol that this method was constructed from. This method symbol\r\n has the same containing type (if any), but has type arguments that are the same\r\n as the type parameters (although its containing type might not).\r\n ":"\r\n 返回该方法是由此构建的方法符号。此方法符号\r\n 具有相同的包含类型（如果有），但具有相同的类型参数\r\n 作为类型参数（尽管其包含类型可能没有）。\r\n \r\n"," \r\n which also creates a map from ":" \r\n 它也创建了一张地图\r\n","\r\n  Looks up a localized string similar to 'End Get' must be preceded by a matching 'Get'..\r\n":"\r\n  查找类似于“ end get”的本地化字符串，必须先于匹配的“ get”。\r\n\r\n","Location of the field":"场地\r\n","Method '{0}' will not be used as an entry point because a synchronous entry point '{1}' was found.":"方法'{0}'将不会用作入口点，因为找到了同步入口点'{1}'。\r\n","To determine the conversion between two types (instead of an expression and a type), use\r\n Compilation.ClassifyConversion.":"要确定两种类型之间的转换（而不是表达式和​​类型），请使用\r\n compilation.classifyConversion。\r\n","from metadata":"来自元数据\r\n","\r\n            Placed at one less indent to the current context\r\n        ":"\r\n            放置在当前情况的缩进不足\r\n        \r\n"," from its code action.  This will end up calling\r\n            ":" 从其代码操作。这最终会打电话\r\n            \r\n","\r\n The value for the EndUsingStatement property.\r\n ":"\r\n 终结属性属性的值。\r\n \r\n","\r\n            Overrrding member for member in class or structure. Shown as O↓\r\n            ":"\r\n            班级或结构成员成员的覆盖成员。显示为o↓\r\n            \r\n"," Split state ":" 拆分状态\r\n","Given {0} parameter types and {1} parameter ref kinds. These arrays must have the same length.":"给定{0}参数类型和{1}参数ref类型。这些阵列必须具有相同的长度。\r\n","\r\n  Looks up a localized string similar to Property or field '{0}' does not have a valid attribute type..\r\n":"\r\n  查找类似于属性或字段'{0}'的本地化字符串没有有效的属性类型。\r\n\r\n","\r\n Misc implementation metadata flags (ImplFlags in metadata).\r\n ":"\r\n MISC实施元数据标志（元数据中的Implflags）。\r\n \r\n","\r\n The \"Order\" keyword\r\n ":"\r\n “顺序”关键字\r\n \r\n","The name '_' refers to the type '{0}', not the discard pattern. Use '@_' for the type, or 'var _' to discard.":"名称'_'是指类型'{0}'，而不是丢弃模式。使用'@_'进行类型或'var _'丢弃。\r\n",", assuming that the declaration bodies only differ in trivia.\r\n            ":"，假设声明机构在琐事中只有不同。\r\n            \r\n","\r\n Return an empty body if the body is a single, zero-width EmptyStatement,\r\n otherwise returns the entire body.\r\n ":"\r\n 如果身体是一个单一的，零宽的空statement，请退回空的身体\r\n 否则返回整个身体。\r\n \r\n","\r\n Decode an option \"On\" or \"Off\" values into true or false. Not specified is considered true.\r\n ":"\r\n 将选项“ on”或“ off”值解码为真或错误。未指定是正确的。\r\n \r\n","MemberNotNull attribute":"成员notnull属性\r\n","\r\n The \"F\" literal suffix denoting \"Single\"\r\n ":"\r\n “ f”字面后缀表示“单”\r\n \r\n","in Suppression File":"在抑制文件中\r\n","\r\n Allows asking semantic questions about a tree of syntax nodes that did not appear in the original source code.\r\n Typically, an instance is obtained by a call to SemanticModel.TryGetSpeculativeSemanticModel. \r\n ":"\r\n 允许询问有关原始源代码中未出现的语法节点树的语义问题。\r\n 通常，通过呼叫semanticmodel.trygetspeculativesemanticmodel获得了一个实例。\r\n \r\n","\r\n A dictionary holding a placeholder, a conversion from placeholder to IDisposable and a condition if placeholder IsNot nothing\r\n per type.\r\n ":"\r\n 持有占位符的词典，从占位符到iDisposable的转换以及如果占位符，则没有任何条件\r\n 每种类型。\r\n \r\n","\r\n            String that describes \"null\" literal in the language.\r\n            ":"\r\n            用语言描述“ null”字面的字符串。\r\n            \r\n","\r\n Determines if the symbol is accessible from the specified location.\r\n ":"\r\n 确定是否可以从指定位置访问符号。\r\n \r\n",", which owns the opened PDB and must be disposed once the caller is done reading the data,\r\n            or null if PDB is not available.\r\n            ":"，拥有打开的PDB，必须在呼叫者阅读数据后处置，\r\n            如果没有PDB，则为null。\r\n            \r\n","\r\n            Document's file path\r\n            ":"\r\n            文档的文件路径\r\n            \r\n","\r\n Returns when classification gets promoted to Identity.\r\n ":"\r\n 当分类晋升为身份时，回报。\r\n \r\n","typeArgument":"typearmument\r\n","\r\n A SubstitutedNamedType represents a named type that has had some sort\r\n of substitution applied to it. I.e., its not a pure instance type, but at least\r\n one type parameter in this type or a containing type has a substitution made for\r\n it. \r\n ":"\r\n 一个替换的namedType代表具有某种形式的命名类型\r\n 替换适用于此。即，它不是纯实例类型，而是至少\r\n 此类型或包含类型的一种类型参数具有替换\r\n 它。\r\n \r\n","where clause":"在哪里条款\r\n","\r\n            Output the current type information of the target node and the conversion type(s) that the target node is \r\n            going to be cast by.\r\n            Implicit downcast can appear on Variable Declaration, Return Statement, Function Invocation, Attribute\r\n            ":"\r\n            输出目标节点的当前类型信息以及目标节点为\r\n            要被铸造。\r\n            隐式降落可以出现在变量声明，返回语句，功能调用，属性上\r\n            \r\n","#nullable disable":"#Nullable禁用\r\n","\r\n Represents a literal. The kind of literal is determined by the Kind property:\r\n IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,\r\n FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be\r\n determined by casting the associated Token to the correct type and getting the\r\n value from the token.\r\n ":"\r\n 代表字面意思。这种字面的类型是由善良的属性确定的：\r\n Integerliteral，contureliteral，booleanliteral，十分列表\r\n FloatingLiteral，DateLiteral或StringLiteral。字面的价值可以是\r\n 通过将关联的令牌施放为正确的类型并获得\r\n 来自令牌的价值。\r\n \r\n","\r\n  Looks up a localized string similar to '>' expected..\r\n":"\r\n  查找类似于“>”预期的局部字符串。\r\n\r\n","\r\n            ```expr+```\r\n            ":"\r\n            ``expr+````````''\r\n            \r\n","\r\n Lookup a member name in a type, returning a LookupResult that\r\n summarizes the results of the lookup. See LookupResult structure for a detailed\r\n discussing of the meaning of the results. The supplied binder is used for accessibility\r\n checked and base class suppression.\r\n ":"\r\n 查找类型中的成员名称，返回一个查找\r\n 总结查找的结果。有关详细信息，请参见查找结构\r\n 讨论结果的含义。提供的粘合剂用于可访问性\r\n 检查和基类抑制。\r\n \r\n"," will be\r\n            ":" 将会\r\n            \r\n","\r\n The value for the ControlVariables property.\r\n ":"\r\n 控制变量属性的值。\r\n \r\n","\r\n Given result of binding preceding query operators, the source, bind the following Order By operator.\r\n \r\n     {Preceding query operators} Order By {orderings}\r\n \r\n Ex: From a In AA Order By a ==> AA.OrderBy(Function(a) a)\r\n \r\n Ex: From a In AA Order By a.Key1, a.Key2 Descending ==> AA.OrderBy(Function(a) a.Key1).ThenByDescending(Function(a) a.Key2)\r\n \r\n ":"\r\n 给定绑定前面查询操作员的结果，源，由操作员绑定以下顺序。\r\n \r\n     {先前的查询操作员} {orderings}订购订单\r\n \r\n 例如：从a in o a a ==> aa.orderby（function（a）a）的a o a a o。\r\n \r\n 例如：从A.Key1的A a a a a a a.key2 descing ==> aa.orderby（function（a）a.key1）。thenbyDescending（function（a）a.key2）\r\n \r\n \r\n","\r\n We should be intentional about behavior of derived classes regarding guarding against stack overflow. \r\n ":"\r\n 我们应该有意地考虑派生类的行为，以防止堆栈溢出。\r\n \r\n","\r\n  Looks up a localized string similar to A nullable type cannot be inferred for variable '{0}'..\r\n":"\r\n  在变量'{0}'..中，无法推断出类似于无效类型的本地化字符串。\r\n\r\n","\r\n            The document is not compiled into the module. It's only included in the project\r\n            to support design-time features such as completion, etc.\r\n            This is a final state. Once a document is in this state it won't switch to a different one.\r\n            ":"\r\n            该文档未编译到模块中。它仅包含在项目中\r\n            支持设计时间功能，例如完成等。\r\n            这是最终状态。一旦文档处于此状态，它将不会切换到其他文件。\r\n            \r\n","The type, either from the type character or the as clause type. Uses Object as default if needed.":"类型，来自类型字符或AS子句类型。如果需要，将对象用作默认值。\r\n","An ImmutableArray of KeyValue pairs representing existing symbols.":"一个代表现有符号的密钥价值对的不可关系。\r\n","\r\n Represents the state of Option Strict checking.\r\n ":"\r\n 代表选项的严格检查状态。\r\n \r\n","\r\n            Classifier impl for embedded regex strings.\r\n            ":"\r\n            分类器的嵌入式正则弦字符串。\r\n            \r\n","\r\n The Xml namespace name being referenced.\r\n ":"\r\n 引用的XML名称名称。\r\n \r\n","\r\n For a source assembly, the associated compilation.\r\n For any other assembly, null.\r\n For a source module, the DeclaringCompilation of the associated source assembly.\r\n For any other module, null.\r\n For any other symbol, the DeclaringCompilation of the associated module.\r\n ":"\r\n 对于源组件，相关的汇编。\r\n 对于任何其他组件，null。\r\n 对于源模块，声明相关源组件的声明填充。\r\n 对于任何其他模块，null。\r\n 对于任何其他符号，请声明相关模块的声明缩写。\r\n \r\n","\r\n Formats string literal.\r\n ":"\r\n 格式字符串文字。\r\n \r\n","\r\n            Code action we use when just adding a using, possibly with a project or\r\n            metadata reference.  We don't use the standard code action types because\r\n            we want to do things like show a glyph if this will do more than just add\r\n            an import.\r\n            ":"我们仅添加使用，可能与项目或\r\n            元数据参考。我们不使用标准代码操作类型，因为\r\n            我们想做一些诸如显示字形之类的事情，如果这会做更多的事情，而不仅仅是添加\r\n            进口。\r\n            \r\n"," to skip analysis of the block. If a block is skipped, one or more child\r\n            blocks may be analyzed by ":" 跳过对块的分析。如果跳过了一个或多个孩子\r\n            可以通过\r\n","\r\n Bind Let operator selector for a particular ExpressionRangeVariableSyntax.\r\n Takes care of \"carrying over\" of previously declared range variables as well as introduction of the new one.\r\n ":"\r\n 将特定表达式变量词法的操作符选择器绑定。\r\n 照顾“携带”以前声明的范围变量以及新的变量的介绍。\r\n \r\n","\r\n Lazy cache of well known members.\r\n Not yet known value is represented by ErrorTypeSymbol.UnknownResultType\r\n ":"\r\n 知名会员的懒惰缓存。\r\n 尚不知道的值由errortypesymbol.inknownresulttype表示\r\n \r\n","\r\n  Looks up a localized string similar to Array initializer has too few dimensions..\r\n":"\r\n  查找类似于数组初始化器的本地化字符串的尺寸太少。\r\n\r\n","\r\n            Get a read only collection of the ":"\r\n            仅获取只读的集合\r\n","\r\n Binds CollectionInitializeSyntax. i.e. { expr, ... } from an ArrayCreationExpressionSyntax\r\n ":"\r\n 绑定collectionInitializesyntax。即{expr，...}来自arrayCreationexpressyntax\r\n \r\n","\r\n            get the original type with anonymous type removed\r\n            ":"\r\n            删除使用匿名类型的原始类型\r\n            \r\n","\r\n A label for a GoTo, Resume, or On Error statement. An identifier, line number,\r\n or next keyword.\r\n ":"\r\n goto，简历或错误语句的标签。标识符，行号，\r\n 或下一个关键字。\r\n \r\n","\r\n            Brace completion service for double quotes marking an interpolated string.\r\n            Note that the ":"\r\n            双引号的支撑完成服务标记插值字符串。\r\n            请注意\r\n","\r\n            From the IDE perspective, we also include object and string to be simplified\r\n            to var. ":"\r\n            从IDE的角度来看，我们还包括要简化的对象和字符串\r\n            到var。\r\n"," representing the source code of the script.":" 表示脚本的源代码。\r\n","\r\n            If we're adding a reference to another project, it's ok to still add, even if there\r\n            is an existing source-import in the file.  We won't add the import, but we'll still\r\n            add the project-reference.\r\n            ":"\r\n            如果我们要添加对另一个项目的参考，即使在那里，也可以添加\r\n            是文件中的现有源象征。我们不会添加进口，但我们仍然会\r\n            添加项目参考。\r\n            \r\n","\r\n            Runs the script from the beginning.\r\n            ":"\r\n            从一开始就运行脚本。\r\n            \r\n","Diagnostic bag, or Nothing.":"诊断袋或什么都没有。\r\n","<infer>":"<推论>\r\n","Alternation conditions do not capture and cannot be named":"交替条件没有捕获，也不能命名\r\n","\r\n Represents an \"As New {type-name} [arguments] [initializers]\" clause in a\r\n declaration. The type has optional attributes associated with it, although\r\n attributes are not permitted in many places where this node occurs (they are\r\n permitted, for example, on automatically implemented properties.)\r\n ":"\r\n 代表一个“新的{type-name} [gragments] [initializers]”子句\r\n 宣言。该类型具有与之关联的可选属性\r\n 在此节点发生的许多地方不允许属性（它们是\r\n 例如，在自动实现的属性上允许。）\r\n \r\n","\r\n Parts are not localized until they are converted to strings.\r\n ":"\r\n 零件直到将其转换为字符串之前才能定位。\r\n \r\n","\r\n  Looks up a localized string similar to 'End Property' must be preceded by a matching 'Property'..\r\n":"\r\n  查找类似于“ End属性”的本地化字符串必须先于匹配的“属性”。\r\n\r\n","\r\n  Symbol for the containing type, either specialized or constructed.\r\n ":"\r\n  包含类型的符号，无论是专业化还是构造。\r\n \r\n","\r\n Sets the access kind on the property access expression. To clear the access\r\n kind, 'newAccessKind' should be Unknown. Otherwise, the current property\r\n access kind should be Unknown or equal to 'newAccessKind'.\r\n ":"\r\n 在属性访问表达式上设置访问类型。清除访问\r\n 善良，“ newaccesskind”应该是未知的。否则，当前属性\r\n 访问类型应未知或等于“ newAccesskind”。\r\n \r\n","\r\n Determines if a submission contains an LINQ query not followed by an empty line.\r\n\r\n Examples:\r\n 1. ":"\r\n 确定提交是否包含LINQ查询，然后没有一个空行。\r\n\r\n 例子：\r\n 1。\r\n","\r\n This diagnostic indicates when a symbol is not good for binding against.\r\n \r\n Client code can obtain the bad symbol via the BadSymbol property.\r\n ":"\r\n 此诊断表明何时不适合绑定符号。\r\n \r\n 客户端代码可以通过BadSymbol属性获得坏符号。\r\n \r\n","Deleting captured variable '{0}' requires restarting the application.":"删除捕获的变量'{0}'需要重新启动应用程序。\r\n","\r\n Returns a copy of this with the ByKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而Bykeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Returns a copy of this with the MissingIdentifier property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中缺失的IdentiDifier属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Returns a copy of this with the Accessors property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 将其返回此副本，登录属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Class for a local symbol that has a different name than the identifier token.\r\n In this case the real name is returned by the name property and the \"VB User visible name\" can be\r\n obtained by accessing the IdentifierToken.\r\n ":"\r\n 具有与标识符令牌不同的本地符号的类。\r\n 在这种情况下，真实名称由名称属性返回，“ VB用户可见名称”可以是\r\n 通过访问标识。\r\n \r\n","\r\n For enum types, gets the underlying type. Returns null on all other\r\n kinds of types.\r\n ":"\r\n 对于枚举类型，获取基础类型。返回所有其他\r\n 类型的种类。\r\n \r\n","\r\n Returns a copy of this with the AggregateKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，汇总键属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n"," Anonymous type field/parameter type, must be not nothing when \r\n the field is passed to anonymous type descriptor ":" 匿名类型字段/参数类型，当\r\n 该字段传递给匿名类型描述符\r\n","Exactly one of ":"正是一个\r\n","\r\n            Calculates the edits that transform one sequence of syntax tokens to another, disregarding trivia.\r\n            ":"\r\n            计算将一个语法令牌序列转换为另一个序列的编辑，无视琐事。\r\n            \r\n","A character position used to identify a declaration scope and accessibility. This\r\n character position must be within the FullSpan of the Root syntax node in this SemanticModel.":"用于标识声明范围和可访问性的角色位置。这个\r\n 字符位置必须在此semanticmodel中的root语法节点的成面内。\r\n","\r\n The \"GetXmlNamespace\" keyword.\r\n ":"\r\n “ getxmlnamespace”关键字。\r\n \r\n","\r\n Gets the optional bound condition expression for this do loop statement. In syntax error cases\r\n where both conditions are used, priority is given to the first one.\r\n It's recommended to consistently use this property instead of accessing TopConditionOpt or BottomConditionOpt\r\n directly.\r\n ":"\r\n 获取此DO循环语句的可选绑定条件表达式。在语法错误案例中\r\n 在使用两个条件的情况下，将优先级给予第一个条件。\r\n 建议始终使用此属性，而不是访问TopConconditionOpt或BottomSconditionOpt\r\n 直接地。\r\n \r\n","\r\n Returns a copy of this with the Clauses property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中条款属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Represents an XML comment of the form <!-- Comment --> appearing in an\r\n XML literal expression.\r\n ":"\r\n 表示表格的XML评论<！ - 评论 - >出现在\r\n XML字面表达。\r\n \r\n","\r\n            Minimal copy of https://github.com/dotnet/corefx/blob/main/src/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexCharClass.cs\r\n            Used to accurately determine if something is a WordChar according to the .NET regex engine.\r\n            ":"\r\n            https://github.com/dotnet/corefx/blob/main/src/src/system.text.regularexpressions/src/system/text/regularexpressions/regexCarCharChlclass.cs的最小副本\r\n            用于准确确定根据.NET REGEX引擎的某些内容是一个WordChar。\r\n            \r\n","\r\n When performing a lookup in interface do NOT lookup in System.Object \r\n ":"\r\n 在接口中执行查找时，请勿在System.Object中查找\r\n \r\n","\r\n            Represents a chunk of text (usually just a single char) from the original pattern.\r\n            ":"\r\n            代表原始图案的一部分文本（通常只是一个字符）。\r\n            \r\n","\r\n Returns a copy of this with the Encoding property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，编码属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","The passed in name is interpreted as a stand-alone name, as if it\r\n appeared by itself somewhere within the scope that encloses \"position\".":"以名称通过的名称被解释为独立名称，好像\r\n 自行出现在包围“位置”的范围内的某个地方。\r\n","\r\n Can take a reference.\r\n ":"\r\n 可以参考。\r\n \r\n","Create and assign remaining as fields":"创建并分配剩余的字段\r\n","\r\n             Subclasses should implement this to provide their feature as a refactoring.  This will\r\n             be called when the user has the code style set to 'refactoring only' (or if the\r\n             diagnostic is suppressed).\r\n            \r\n             The implementation of this should offer all refactorings it can that are relevant at the\r\n             provided ":"\r\n             子类应实施此功能作为重构。这将\r\n             当用户将代码样式设置为“仅重构”时，请致电（或\r\n             诊断被抑制）。\r\n            \r\n             实施的实施应提供所有与之相关的重构\r\n             假如\r\n","PERF: Not using Array.IndexOf here because it results in a call to IndexOf on the default EqualityComparer for SyntaxKind. The default comparer for SyntaxKind is\r\n the ObjectEqualityComparer which results in boxing allocations.":"perf：在此处不使用array.indexof，因为它会导致语法上的默认equalityComparer上的索引。语法Kind的默认比较是\r\n objectequalityComparer导致拳击分配。\r\n","\r\n The value for the Token1 property.\r\n ":"\r\n Token1属性的值。\r\n \r\n","\r\n The value for the GetXmlNamespaceKeyword property.\r\n ":"\r\n GetXmlNamespaceKeyword属性的值。\r\n \r\n","Generate constructor in '{0}' (with fields)":"在'{0}'（带字段）中生成构造函数\r\n"," or all projects of the solution if ":" 或解决方案的所有项目\r\n","\r\n  Looks up a localized string similar to '{0}' is not a valid format specifier.\r\n":"\r\n  查找类似于“ {0}”的本地化字符串不是有效的格式指定符。\r\n\r\n","\r\n Returns Nothing if there is no documentation comment on the type or \r\n there were errors preventing such a comment from being generated,\r\n XML string otherwise\r\n ":"\r\n 如果没有有关类型或类型的文档评论，则不会返回\r\n 有错误阻止这种评论产生的错误，\r\n XML字符串否则\r\n \r\n","Invalid assembly name":"无效的组装名称\r\n"," representing the specific kind of SyntaxTrivia. One of\r\n WhitespaceTrivia, EndOfLineTrivia, ColonTrivia, CommentTrivia,\r\n LineContinuationTrivia, DocumentationCommentExteriorTrivia, DisabledTextTrivia.\r\n ":" 代表特定种类的语法。之一\r\n Whitespactrivia，Endoflinetrivia，Colontrivia，评论，评论，\r\n LinecontinuationTrivia，DocumentationCommentExteriortrivia，disabledttrivia。\r\n \r\n","\r\n Create the array version of type, given the element type and the array modifier syntax. Throws if\r\n there aren't any array modifiers and the result is not an array type.\r\n ":"\r\n 给定元素类型和数组修饰符语法创建类型的数组版本。如果\r\n 没有任何数组修饰符，结果不是数组类型。\r\n \r\n","The syntax node that declares an enum block.":"声明枚举块的语法节点。\r\n","\r\n Rewrites GlobalStatementInitializers to ExpressionStatements and gets the initializers for fields and properties.\r\n ":"\r\n 重写全局statementInitializers以表达式建立，并获取字段和属性的初始化器。\r\n \r\n","\r\n             For the node specified by ":"\r\n             对于由\r\n","\r\n The value for the ImportsKeyword property.\r\n ":"\r\n importSkeyword属性的值。\r\n \r\n","\r\n            Determines which of two items should represent the matching pair.\r\n            ":"\r\n            确定两个项目中的哪个应表示匹配对。\r\n            \r\n","\r\n  Looks up a localized string similar to Cannot infer a common type for the first and second operands of the binary 'If' operator. One must have a widening conversion to the other..\r\n":"\r\n  查找类似于类似的本地化字符串，无法推断二进制“ IF”操作员的第一和第二操作数的共同类型。一个必须对另一个的转换扩大。\r\n\r\n","\r\n  Looks up a localized string similar to Arrays used as attribute arguments are required to explicitly specify values for all elements..\r\n":"\r\n  查找类似于属性参数的数组类似的本地化字符串，以明确指定所有元素的值。\r\n\r\n","\r\n            The right operand is the constant.\r\n            ":"\r\n            正确的操作数是常数。\r\n            \r\n","\r\n Returns a copy of this with the Type property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，类型属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n            Creates an `^expr` index expression from a given `expr`.\r\n            ":"\r\n            从给定的`expr'创建`^expr`索引表达式。\r\n            \r\n","\r\n The fields or properties being initialized, or Nothing if this represents an executable statement in script code.\r\n We can get into a multiple properties case when multiple WithEvents fields are initialized with As New ...\r\n ":"\r\n 初始化的字段或属性，或者如果这代表脚本代码中的可执行语句，则无需。\r\n 当多个with Events字段初始化为新的...\r\n \r\n","A bound call to the MoveNext method.":"对Movenext方法的界定调用。\r\n","\r\n            Implementation of a ":"\r\n            实施\r\n","Whether this comparer is in \"statement mode\"":"该比较是否处于“语句模式”\r\n","\r\n            Represents a configuration code action with nested actions registered by individual ":"\r\n            代表具有个人注册的嵌套操作的配置代码操作\r\n"," for top level statements\r\n            \r\n            A null reference otherwise.\r\n            ":" 对于顶级语句\r\n            \r\n            否则，零引用。\r\n            \r\n","\r\n Gets the type of this variable.\r\n ":"\r\n 获取此变量的类型。\r\n \r\n","generic overload":"通用超载\r\n","\r\n  Looks up a localized string similar to 'Yield' cannot be used inside a 'Catch' statement or a 'Finally' statement..\r\n":"\r\n  查找类似于“收益”的本地化字符串，不能在“捕获”语句或“最后”语句中使用。\r\n\r\n","Dev10 ParseCType does not parse exact grammar in the spec, since dev10 accepts Expression whereas the grammar uses CCExpression.\r\n This function only does not parse CastTarget ( ... ), it is parsed in ParseTerm\r\n ":"Dev10 parsectype不会在规格中解析精确的语法，因为DEV10接受表达式，而语法使用CCEXPRESSION。\r\n 此功能仅不能解析casttarget（...），它是在Parseterm中解析的\r\n \r\n","\r\n External methods are \r\n 1) Declare Subs and Declare Functions, \r\n 2) methods marked by ":"\r\n 外部方法是\r\n 1）声明subs并声明功能，\r\n 2）标记的方法\r\n","\r\n Returns a copy of this with the FormatClause property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中formatclause属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","The object creation expression syntax.":"对象创建表达语法。\r\n","\r\n            This intermediate class is used to hide method `TryGetReplacementReferenceSyntax` from ":"\r\n            此中级类用于隐藏方法`trygetReplacementReferencesYntax`\r\n",").\r\n            Returns a new solution after changing namespace, and a list of IDs for documents that also changed because they reference\r\n            the types declared in the changed namespace (not include the document contains the declaration itself).\r\n            ":"）。\r\n            更改名称空间后返回一个新解决方案，以及文档的ID列表，该列表也更改了，因为它们引用了\r\n            更改名称空间中声明的类型（不包括文档包含声明本身）。\r\n            \r\n","\r\n            Represents the number of references to a given symbol.\r\n            ":"\r\n            表示给定符号的引用数量。\r\n            \r\n","else":"别的\r\n","\r\n The label of the code region being defined.\r\n ":"\r\n 定义的代码区域的标签。\r\n \r\n","Encapsulate fields (and use property)":"封装字段（并使用属性）\r\n","\r\n Get all the type members of this symbol. The types may not be in a particular order, and the order\r\n may not be stable from call-to-call.\r\n ":"\r\n 获取此符号的所有类型成员。这些类型可能不在特定顺序和顺序\r\n 通话通话可能不稳定。\r\n \r\n","\r\n Unlike in C#, we don't need to use a set because the ":"\r\n 与C＃不同，我们不需要使用集合，因为\r\n","\r\n We may synthesize some well-known attributes for this assembly symbol.  However, at synthesis time, it is\r\n too late to report diagnostics or cancel the emit.  Instead, we check for use site errors on the types and members\r\n we know we'll need at synthesis time.\r\n ":"\r\n 我们可能会为此组装符号综合一些众所周知的属性。但是，在合成时，它是\r\n 为了报告诊断或取消EMIT的时间太晚。相反，我们在类型和成员的类型上检查使用网站错误\r\n 我们知道我们需要在合成时间。\r\n \r\n","\r\n The value for the EventMember property.\r\n ":"\r\n 事件成员属性的值。\r\n \r\n","\r\n            \r\n            Specifically, all blocks followed by another statement must have a blank line between them.\r\n            ":"\r\n            \r\n            具体而言，所有块紧随其后的块之间必须在它们之间有空白。\r\n            \r\n","The given expression never matches the provided pattern.":"给定的表达式永远不匹配提供的模式。\r\n","\r\n This helper method does all the work to bind Take and Skip query operators.\r\n ":"\r\n 这种助手方法可以完成所有工作来绑定和跳过查询操作员。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' is not valid on an Interface declaration..\r\n":"\r\n  在接口声明上查找类似于“ {0}”的本地化字符串。\r\n\r\n"," if the module is not loaded.":" 如果未加载模块。\r\n","Implement through '{0}'":"通过'{0}'实施\r\n","\r\n            The portion of the user string token prior to the section we're replacing.  Used for building the\r\n            example format to present.\r\n            ":"\r\n            在我们要替换之前，用户字符串令牌的部分。用于构建\r\n            示例格式要出现。\r\n            \r\n","Modifying {0} which contains an Aggregate, Group By, or Join query clauses requires restarting the application.":"修改{0}包含一个聚合，组成或加入查询子句需要重新启动应用程序。\r\n","\r\n Return all of the type parameters in this type and enclosing types,\r\n from outer-most to inner-most type.\r\n ":"\r\n 返回此类型中的所有类型参数和封闭类型中的参数，\r\n 从最外部到最内部类型。\r\n \r\n","\r\n Creates the syntax representation of a named empty xml element within xml documentation comments.\r\n ":"\r\n 在XML文档注释中创建命名为空XML元素的语法表示。\r\n \r\n","\r\n Set to true after an analysis scan if the analysis was incomplete due to a backward\r\n \"goto\" branch changing some analysis result.  In this case the caller scans again (until\r\n this is false). Since the analysis proceeds by monotonically changing the state computed\r\n at each label, this must terminate.\r\n ":"\r\n 分析后扫描后设置为TRUE，如果由于向后分析不完整\r\n “ goto”分支改变了一些分析结果。在这种情况下，呼叫者再次扫描（直到\r\n 这是错误的）。由于分析是通过单调更改计算状态进行的\r\n 在每个标签上，必须终止。\r\n \r\n"," representing the specific kind of\r\n EndBlockStatementSyntax. One of EndIfStatement, EndUsingStatement,\r\n EndWithStatement, EndSelectStatement, EndStructureStatement, EndEnumStatement,\r\n EndInterfaceStatement, EndClassStatement, EndModuleStatement,\r\n EndNamespaceStatement, EndSubStatement, EndFunctionStatement, EndGetStatement,\r\n EndSetStatement, EndPropertyStatement, EndOperatorStatement, EndEventStatement,\r\n EndAddHandlerStatement, EndRemoveHandlerStatement, EndRaiseEventStatement,\r\n EndWhileStatement, EndTryStatement, EndSyncLockStatement.\r\n ":" 代表特定种类\r\n endBlockStatementsyntax。结构化的之一，终结statement，\r\n EndWithStatement，EndSelectStatement，EndstructureStatement，EndenumStatement，\r\n EndInterFaCestatement，EndClassStatement，EndmoduleStatement，\r\n EndNamesPactatement，Endubstatement，EndFunctionStatement，EndgetStatement，\r\n 末端集，末端序列，内传术，末端statement，\r\n Endaddhandlellstatement，EndremoveHandlerstatement，EndraiseeventStatement，\r\n 终点，终结，终结。\r\n \r\n","\r\n The type of the expression after it has undergone an implicit conversion. If the type\r\n did not undergo an implicit conversion, returns the same as Type.\r\n ":"\r\n 表达式之后的类型经历了隐式转换。如果类型\r\n 没有进行隐式转换，返回与类型相同。\r\n \r\n","TODO: set large fields to null":"托多：将大字段设置为null\r\n","\r\n Implements shadowing based on\r\n §11.8.1 Overloaded Method Resolution.\r\n •\tIf M has fewer parameters from an expanded paramarray than N, eliminate N from the set.\r\n ":"\r\n 基于\r\n §11.8.1超载方法分辨率。\r\n •如果M从扩展的Paramarray中具有较少的参数，则从集合中消除N。\r\n \r\n","Embedded statements must be on their own line":"嵌入式陈述必须在自己的线上\r\n","\r\n  Looks up a localized string similar to String constant expected..\r\n":"\r\n  查找与预期字符串常数类似的本地化字符串。\r\n\r\n","The parent node of this node, or Nothing if this node is the root.":"该节点的父节点，如果该节点是根。\r\n","\r\n Members that would be in OverriddenMembers if they were accessible.\r\n ":"\r\n 如果可以访问的成员将在覆盖成员中。\r\n \r\n","\r\n Given a delegate declaration, get the corresponding type symbol.\r\n ":"\r\n 给定代表声明，获取相应的类型符号。\r\n \r\n","\r\n Adds a field initializer for the field to list of field initializers\r\n ":"\r\n 为字段添加一个字段初始化器中的字段初始化列表\r\n \r\n"," characters.  Unlike the\r\n             native C# and VB lexer, this lexer is much more tightly controlled by the parser.  For\r\n             example, while C# can have trivia on virtual every token, the same is not true for\r\n             RegexTokens.  As such, instead of automatically lexing out tokens to make them available for\r\n             the parser, the parser asks for each token as necessary passing the right information to\r\n             indicate which types and shapes of tokens are allowed.\r\n            \r\n             The tight coupling means that the parser is allowed direct control of the position of the\r\n             lexer.\r\n            \r\n             Note: most of the time, tokens returned are just a single character long, including for long\r\n             sequences of text characters (like ```\"goo\"```).  This is just three ":" 人物。不像\r\n             本机C＃和VB Lexer，该lexer受解析器的紧密控制。为了\r\n             例如，虽然C＃可以在每个令牌上都具有琐事\r\n             Regextokens。因此，而不是自动发出令牌以使其可用\r\n             解析器，解析器要求将每个令牌作为必要的将正确的信息传递给\r\n             指示允许使用哪些类型和形状。\r\n            \r\n             紧密耦合意味着可以直接控制解析器\r\n             勒克斯。\r\n            \r\n             注意：大多数情况下，返回的代币只是一个字符，包括长时间\r\n             文本字符的序列（例如````''''）。这只是三个\r\n"," has AwaitExpression in it.\r\n            ":" 其中有awaitexpression。\r\n            \r\n","\r\n            Get a read only collection of all the unique visible documents in the workspace that are\r\n            contained within ":"\r\n            仅获取工作空间中所有独特可见文档的读取\r\n            包含在内\r\n","Remove unused private members":"删除未使用的私人成员\r\n","\r\n  Looks up a localized string similar to 'Exit' must be followed by 'Sub', 'Function', 'Property', 'Do', 'For', 'While', 'Select', or 'Try'..\r\n":"\r\n  查找类似于“退出”的本地化字符串，其后必须是“ sub”，“ function”，“ property”，“ do”，“ for”，“ for”，“ while”，“ select”，“ select”或“ try” ..\r\n\r\n","The number of candidates found during inference":"推理期间发现的候选人数量\r\n","\r\n            If we want to add a ":"\r\n            如果我们想添加\r\n","\r\n The method MAY return a binder used for binding so it can be reused later in method compiler\r\n ":"\r\n 该方法可以返回用于绑定的粘合剂，以便以后在方法编译器中重复使用\r\n \r\n","\r\n Create a BoundBadExpression node for the given child-expression, which is preserved as a sub-expression. \r\n No ResultKind is associated\r\n ":"\r\n 为给定的儿童表达创建一个boundbadexpression节点，该节点被保留为子表达。\r\n 没有结果\r\n \r\n","\r\n  Looks up a localized string similar to 'Microsoft.VisualBasic.ComClassAttribute' and '{0}' cannot both be applied to the same class..\r\n":"\r\n  查找类似于'Microsoft.visualbasic.comclassattribute'和'{0}'的本地化字符串，不能同时应用于同一类。\r\n\r\n","An expression tree may not contain a range ('..') expression.":"表达树可能不包含范围（'..'）表达式。\r\n","The symbol to build an RQName for.":"为构建rqname的符号。\r\n","\r\n If present, an Implements clause indicates the interface methods that this\r\n method implements.\r\n ":"\r\n 如果存在，则instress子句指示接口方法\r\n 方法工具。\r\n \r\n","Generate type '{0}'":"生成类型'{0}'\r\n","\r\n  Looks up a localized string similar to Type '{0}' has no constructors..\r\n":"\r\n  查找类似于“ {0}”类型的本地化字符串没有构造函数。\r\n\r\n","\r\n The name of the attribute.\r\n ":"\r\n 属性的名称。\r\n \r\n","\r\n Traverses the symbol table checking for CLS compliance.\r\n ":"\r\n 遍历CLS合规性检查符号表。\r\n \r\n","\r\n Determines if the Unicode character can be the starting character of a Visual Basic identifier.\r\n ":"\r\n 确定Unicode字符是否可以是视觉基本标识符的启动字符。\r\n \r\n","\r\n            An active statement (leaf or not) inside a \"catch\" makes the catch block read-only.\r\n            An active statement (leaf or not) inside a \"finally\" makes the whole try/catch/finally block read-only.\r\n            An active statement (non leaf)    inside a \"try\" makes the catch/finally block read-only.\r\n            ":"\r\n            “捕获”内部的主动语句（是否没有叶）使捕获块只读。\r\n            “最终”内部的一个主动语句（是否没有叶子）使整个尝试/捕获/最终仅阻止阅读。\r\n            “尝试”内部的活动语句（非叶子）使捕获/最终阻止只读。\r\n            \r\n","\r\n Non-0 indicates that the collection of referenced symbols is sealed\r\n and so no new symbols are supposed to be added.\r\n ":"\r\n non-0表示参考符号的集合已密封\r\n 因此，不应该添加新符号。\r\n \r\n","\r\n  Looks up a localized string similar to 'Class' constraint cannot be specified multiple times for the same type parameter..\r\n":"\r\n  查找类似于“类”约束的本地化字符串，不能多次指定相同类型的参数。\r\n\r\n","true if there were errors; otherwise false":"如果有错误，则为真实；否则错误\r\n","A list of symbols that were found. If no symbols were found, an empty list is\r\n returned.":"找到的符号列表。 如果没有找到符号，则空列表为\r\n 回来了。\r\n","\r\n Represents an empty XML element of the form <element />\r\n ":"\r\n 代表表单<element />的空XML元素\r\n \r\n","\r\n  Looks up a localized string similar to Type '{0}' in assembly '{1}' has been forwarded to assembly '{2}'. Either a reference to '{2}' is missing from your project or the type '{0}' is missing from assembly '{2}'..\r\n":"\r\n  查找类似于“汇编” {1}'类型的本地化字符串已转发到汇编'{2}'。您的项目中缺少对“ {2}”的引用，或者汇编'{2}'..中缺少“ {0}”。\r\n\r\n","\r\n A list of \"ElseIf\" blocks to be evaluated, in order, if the condition\r\n expression of the \"If\" statement evaluates as false.\r\n ":"\r\n 如果条件\r\n “如果”语句的表达评估为false。\r\n \r\n","\r\n A list of the types being implemented.\r\n ":"\r\n 正在实施的类型列表。\r\n \r\n","\r\n            Returns true if the code emitted for the old active statement part (":"\r\n            如果为旧活动语句零件发出的代码，则返回true（\r\n"," but do not want to root a potentially\r\n            very stale ":" 但是不想扎根\r\n            非常陈旧\r\n","s containing refactorings is set to\r\n            ":"含有重构的S设置为\r\n            \r\n","\r\n Represents a entire SyncLock...End SyncLock block, including the SyncLock\r\n statement, the enclosed statements, and the End SyncLock statement.\r\n ":"代表整个Synclock ...结束同步块，包括Synclock\r\n 语句，封闭的语句和最终Synclock语句。\r\n \r\n","A VB syntax node to check.":"vb语法节点要检查。\r\n","Unwrap and indent all parameters":"解开和缩进所有参数\r\n","Implement '{0}' implicitly":"隐式实现'{0}'\r\n","\r\n The value for the AdditionalQueryOperators property.\r\n ":"\r\n 附加权限器属性的值。\r\n \r\n"," holding on values for global variables accessible from the script.\r\n            Must be specified if and only if the script was created with ":" 保留可从脚本访问的全局变量的值。\r\n            必须指定且仅当创建脚本时，必须指定\r\n","\r\n A region analysis walker that computes the set of variables that are always assigned a value in the region.\r\n A variable is \"always assigned\" in a region if an analysis of the\r\n region that starts with the variable unassigned ends with the variable\r\n assigned.\r\n ":"\r\n 一个区域分析步行器计算始终在区域中分配值的变量集。\r\n 如果对区域的分析，则在区域中“始终为”\r\n 以变​​量为单位的变量端开始的区域\r\n 分配。\r\n \r\n","Note: Tab twice to insert the '{0}' snippet.":"注意：Tab两次插入“ {0}”片段。\r\n","\r\n            Returns the list of subsequent else-if clauses and a final else clause (if present).\r\n            ":"\r\n            返回后续的else-if-if子句和最终子句（如果存在）。\r\n            \r\n","\r\n Not intended for use in Expression Compiler scenarios.\r\n ":"\r\n 不打算用于表达编译器方案。\r\n \r\n","\r\n Creates a binder for a source attribute block when a containing binder is available. Used by semantic model.\r\n ":"\r\n 当可用的粘合剂可用时，为源属性块创建粘合剂。语义模型使用。\r\n \r\n"," but will return ones already created.\r\n            Difference with ":" 但是将返回已经创建的。\r\n            与\r\n","\r\n            Builds the RQName for a given symbol.\r\n            ":"\r\n            为给定符号构建RQNAME。\r\n            \r\n","\r\n  Looks up a localized string similar to Member '{0}.{1}' that matches this signature cannot be implemented because the interface '{2}' contains multiple members with this same name and signature:\r\n   '{3}'\r\n   '{4}'.\r\n":"\r\n  查找类似于成员'{0}的本地化字符串。{1}'，与此签名匹配，因为接口'{2}'包含具有相同名称和签名的多个成员：\r\n   '{3}'\r\n   '{4}'。\r\n\r\n","\r\n The value for the AlignmentClause property.\r\n ":"\r\n AlignmentClause属性的值。\r\n \r\n","\r\n  Return the location from syntax reference only.\r\n ":"\r\n  仅从语法参考返回位置。\r\n \r\n","\r\n  True if 'Overrides' is explicitly specified in method's declaration.\r\n ":"\r\n  是的，如果在方法的声明中明确指定了“覆盖”。\r\n \r\n","\r\n  Looks up a localized string similar to 'GoTo {0}' is not valid because '{0}' is inside a 'SyncLock' statement that does not contain this statement..\r\n":"\r\n  查找类似于'goto {0}'的本地化字符串是无效的，因为'{0}'在不包含此语句的'synclock'语句中。\r\n\r\n","\r\n            Force computes diagnostics and raises diagnostic events for the given project or solution. all diagnostics returned should be up-to-date with respect to the given project or solution.\r\n            ":"\r\n            力计算诊断并提高给定项目或解决方案的诊断事件。与给定的项目或解决方案有关的所有诊断均应最新。\r\n            \r\n","\r\n Emits address as in & \r\n \r\n May introduce a temp which it will return. (otherwise returns null)\r\n ":"\r\n 发出的地址如＆\r\n \r\n 可能会引入将返回的温度。 （否则返回null）\r\n \r\n","\r\n NOTE: implicit line continuation will not be handled here and an error will be generated, \r\n but explicit one (like \".... _\\r\\n ....\") should work fine\r\n ":"\r\n 注意：隐式线延续将不会在此处处理，并且将生成错误，\r\n 但是明确一个（例如“ .... _ \\ r \\ n ....”应该正常工作\r\n \r\n","\r\n Create an end-of-text token.\r\n ":"\r\n 创建一个文本令牌。\r\n \r\n","\r\n Returns a copy of this with the Value property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回其副本，其中值属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n Returns a copy of this with the Aggregation property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，汇总属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Abstract class that represent a single field initializer used in a \"With {...}\"\r\n field initializer list.\r\n ":"\r\n 代表“ with {...}”中使用的单个字段初始化器的抽象类\r\n 字段初始化器列表。\r\n \r\n","\r\n Implements shadowing based on\r\n §11.8.1 Overloaded Method Resolution.\r\n    7.4.\tIf M is less generic than N, eliminate N from the set.\r\n ":"\r\n 基于\r\n §11.8.1超载方法分辨率。\r\n    7.4。如果M不如N，则从集合中消除n。\r\n \r\n","\r\n Optional attribute target. Assembly|Module :\r\n ":"\r\n 可选属性目标。汇编|模块：\r\n \r\n","\r\n Creates a threadsafty element within an xml documentation comment.\r\n ":"\r\n 在XML文档注释中创建线程安全元素。\r\n \r\n"," Create a new instance of With statement binder for a statement syntax provided ":" 使用语句粘合剂为语句语法创建新实例\r\n","\r\n            Looks for code of the form:\r\n            \r\n                Func<int, int> fib = n =>\r\n                {\r\n                    if (n <= 2)\r\n                        return 1\r\n                        \r\n                    return fib(n - 1) + fib(n - 2);\r\n                }\r\n                \r\n            and converts it to:\r\n            \r\n                int fib(int n)\r\n                {\r\n                    if (n <= 2)\r\n                        return 1\r\n                        \r\n                    return fib(n - 1) + fib(n - 2);\r\n                }\r\n            ":"\r\n            寻找表格的代码：\r\n            \r\n                func <int，int> fib = n =>\r\n                {\r\n                    如果（n <= 2）\r\n                        返回1\r\n                        \r\n                    返回fib（n -1） + fib（n -2）;\r\n                }\r\n                \r\n            并将其转换为：\r\n            \r\n                int fib（int n）\r\n                {\r\n                    如果（n <= 2）\r\n                        返回1\r\n                        \r\n                    返回fib（n -1） + fib（n -2）;\r\n                }\r\n            \r\n","the symbol for changing the signature":"更改签名的符号\r\n","\r\n            The member needs to be pulled up.\r\n            ":"\r\n            需要拉起成员。\r\n            \r\n","\r\n The dispatcher method that handles syntax nodes for all stand-alone expressions.\r\n ":"\r\n 处理所有独立表达式的语法节点的调度器方法。\r\n \r\n","Align wrapped parameters":"对齐包装参数\r\n","\r\n In case a cyclic dependency was detected during base type resolution \r\n this field stores the diagnostic.\r\n ":"\r\n 如果在基本类型分辨率期间检测到循环依赖性\r\n 该字段存储诊断。\r\n \r\n","\r\n            The enter key is never passed through to the editor after it has been used to commit the completion item.\r\n            ":"\r\n            Enter密钥用于提交完成项目后，它永远不会传递给编辑器。\r\n            \r\n"," \r\n Represents a result of lookup operation over a 0 or 1 symbol (as opposed to a scope).\r\n The typical use is to represent that a particular symbol is good/bad/unavailable.\r\n\r\nFor more explanation of Kind, Symbol, Error - see LookupResult.\r\n ":" \r\n 代表在0或1符号上查找操作的结果（与范围相反）。\r\n 典型的用途是表示特定符号是好/坏/不可用。\r\n\r\n有关类型，符号，错误的更多说明 - 请参见LookupResult。\r\n \r\n","The syntax node for the optional initialization.":"可选初始化的语法节点。\r\n"," for the specific snapshot of ":" 对于特定快照\r\n","Namespace can not be added in this destination.":"名称空间无法在此目的地中添加。\r\n","\r\n            Error tolerance case for\r\n                \"goo[$$]\" or \"goo?[$$]\"\r\n            which is parsed as an ArrayTypeSyntax variable declaration instead of an ElementAccessExpression  \r\n        ":"\r\n            误差案例\r\n                “ Goo [$$]”或“ Goo？[$$]\r\n            将其解析为arrayTypesyNtax变量声明，而不是元素cessexpression\r\n        \r\n","\r\n  Looks up a localized string similar to Conversion operators cannot convert to Object..\r\n":"\r\n  查找类似于转换操作员的本地化字符串无法转换为对象。\r\n\r\n",".  The purpose\r\n            of the span is to:\r\n                1. Signify where the completions should be presented.\r\n                2. Designate any existing text in the document that should be used for filtering.\r\n                3. Specify, by default, what portion of the text should be replaced when a completion \r\n                   item is committed.\r\n            ":"。目的\r\n            跨度是：\r\n                1.表示应在何处提供完成。\r\n                2.指定文档中应用于过滤的任何现有文本。\r\n                3.默认情况下指定完成后应更换文本的哪些部分\r\n                   项目是投入的。\r\n            \r\n","\r\n            A value of null indicates that the operation has been cancelled.\r\n            ":"\r\n            null值表示该操作已被取消。\r\n            \r\n","\r\n Returns the value of the Option Compare Text/Binary declaration if there was one, otherwise Null. True means\r\n Text, False means Binary.\r\n ":"\r\n 返回该选项的值，如果有一个，则比较文本/二进制声明，否则将其返回。真正的意思\r\n 文字，错误表示二进制。\r\n \r\n"," used when resolving assembly references, or null to prefer no culture.\r\n            ":" 在解决组装参考文献或零以不喜欢文化时使用。\r\n            \r\n","\r\n            Return true to display the file path of ":"\r\n            返回true以显示的文件路径\r\n","This symbol has related definitions or references in metadata. Changing its signature may result in build errors.\r\n            \r\n            Do you want to continue?":"该符号在元数据中具有相关的定义或参考。更改其签名可能会导致构建错误。\r\n            \r\n            你想继续吗？\r\n","\r\n Helper that tells if symbol has Overloads (hidebysig) on it\r\n ":"\r\n 助手告诉符号是否有超载（hidebysig）\r\n \r\n"," only provides diagnostics for either push or pull purposes (but not both).  If\r\n            the caller's desired purpose doesn't match the option value, then this will return nothing, otherwise it\r\n            will return the requested buckets.":" 仅提供用于推送或拉的目的（但两者兼而有之）的诊断。如果\r\n            呼叫者的期望目的与选项值不符，然后这将一无所获，否则\r\n            将返回请求的存储桶。\r\n","\r\n Returns true if the node is in a position where an unbound type\r\n such as (C(of)) is allowed.\r\n ":"\r\n 如果节点处于未结合类型的位置，则返回true\r\n 例如（c（of））。\r\n \r\n","Only records may inherit from records.":"只有记录可以从记录中继承。\r\n",".  \r\n             ":"。\r\n             \r\n",". To do so it traverses all the statements, handling blocks and other\r\n statements that create scopes. For efficiency reasons, it does not traverse into\r\n expressions. This means that blocks within lambdas and queries are not created. \r\n Blocks within lambdas are bound by their own ":"。为此，它遍历了所有陈述，处理块和其他陈述\r\n 创建范围的语句。出于效率原因，它不会穿越\r\n 表达。这意味着未创建lambdas和查询中的块。\r\n Lambdas中的街区受到自己的约束\r\n"," Looks explicitly for an ":" 明确地看\r\n","\r\n Given aggregationVariables, bind Into selector in context of this binder.\r\n ":"\r\n 给定的聚合变量，在此粘合剂的上下文中结合到选择器中。\r\n \r\n","The containing symbol.":"包含符号。\r\n","\r\n As you might hope, for an array, it is the element type of the array.\r\n ":"\r\n 您可能希望，对于一个数组，它是数组的元素类型。\r\n \r\n","\r\n Returns true if calls to this method are omitted in the given syntax tree at the given syntax node location.\r\n Calls are omitted when the called method is a partial method with no implementation part, or when the\r\n called method is a conditional method whose condition is not true at the given syntax node location in the source file\r\n corresponding to the given syntax tree.\r\n ":"\r\n 如果在给定的语法节点位置省略了给定语法树中对此方法的调用，则返回true。\r\n 当调用方法是没有实现部分的部分方法时，省略了呼叫\r\n 称为方法是条件方法，其条件在源文件中的给定语法节点位置不正确\r\n 对应给定的语法树。\r\n \r\n","\r\n A field of a frame class that represents a variable that has been captured in a lambda.\r\n ":"\r\n 框架类的字段，代表在lambda中捕获的变量。\r\n \r\n","\r\n Generates the name of a state machine field name for captured me reference of lambda closure\r\n ":"\r\n 生成捕获我的状态机字段名称的名称\r\n \r\n","True if the member access can be qualified; otherwise, False.":"如果成员访问可以限定，则为True；否则为False。\r\n","s within a method body, and the associated\r\n ":"在方法主体和相关的\r\n \r\n","\r\n Defines whether or not fields of intrinsic type should be tracked. Such fields should \r\n not be tracked for error reporting purposes, but should be tracked for region flow analysis\r\n ":"\r\n 定义是否应跟踪内在类型的字段。这样的领域应该\r\n 未进行错误报告目的跟踪，但应跟踪以进行区域流量分析\r\n \r\n","\r\n Rewrites field.\r\n ":"\r\n 重写字段。\r\n \r\n",". We assume that the dependencies of the baseline metadata are \r\n  the same as the dependencies of the current compilation. This is not exactly true when the dependencies use \r\n  time-based versioning pattern, e.g. AssemblyVersion(\"1.0.*\"). In that case we assume only the version\r\n  changed And nothing else.\r\n  \r\n  Each AssemblyRef is matched against the assembly identities using an exact equality comparison modulo version. \r\n  AssemblyRef with lower version in metadata is matched to a PE assembly symbol with the higher version \r\n  (provided that the assembly name, culture, PKT And flags are the same) if there is no symbol with the exactly matching version. \r\n  If there are multiple symbols with higher versions selects the one with the minimal version among them.\r\n  \r\n  Matching to a higher version is necessary to support EnC for projects whose P2P dependencies use time-based versioning pattern. \r\n  The versions of the dependent projects seen from the IDE will be higher than \r\n  the one written in the metadata at the time their respective baselines are built.\r\n  \r\n  No other unification or further resolution is performed.\r\n  ":"。我们假设基线元数据的依赖关系是\r\n  与当前汇编的依赖关系相同。当依赖项使用时，这并不完全正确\r\n  基于时间的版本控制模式，例如汇编（“ 1.0。*”）。在这种情况下，我们仅假设版本\r\n  改变了，别无其他。\r\n  \r\n  使用精确的平等比较模量版本，将每个汇编Ref与汇编身份匹配。\r\n  元数据中具有较低版本的issablyRef匹配具有更高版本的PE组装符号\r\n  （前提是汇编名称，文化，PKT和标志是相同的），如果没有精确匹配的版本的符号。\r\n  如果有较高版本的多个符号，则选择其中一个具有最小版本的符号。\r\n  \r\n  与更高版本的匹配是为了支持P2P依赖性使用基于时间的版本模式的项目的ENC。\r\n  从IDE看到的依赖项目的版本将高于\r\n  它们各自的基线建造时用元数据写的那本。\r\n  \r\n  没有执行其他统一或进一步解决。\r\n  \r\n","\r\n Defines the collection range variables being joined to.\r\n ":"\r\n 定义要连接的收集范围变量。\r\n \r\n","\r\n            of delegate type.\r\n            ":"\r\n            代表类型。\r\n            \r\n","\r\n Generates the documentation comment for the type, writes it into \r\n the writer\r\n ":"\r\n 生成该类型的文档评论，将其写入\r\n 笔者\r\n \r\n","\r\n http://msdn.microsoft.com/en-us/library/std9609e(v=vs.110)\r\n Specify the full name and extension of the file to create. If you do not, the .exe file takes \r\n its name from the source-code file containing the Sub Main procedure, and the .dll file takes\r\n its name from the first source-code file.\r\n \r\n However, vbc.cpp has: \r\n ":"\r\n http://msdn.microsoft.com/en-us/library/std9609e(v=vs.110）\r\n 指定要创建文件的全名和扩展名。如果不这样\r\n 其名称来自包含子主过程的源代码文件，并且.dll文件采用\r\n 它的名称来自第一个源代码文件。\r\n \r\n 但是，vbc.cpp有：\r\n \r\n","\r\n            A lock to guard parallel accesses to this type. In practice, we presume that it's not \r\n            an important scenario that we can be generating multiple documents in parallel, and so \r\n            we simply take this lock around all public entrypoints to enforce sequential access.\r\n            ":"\r\n            锁定并行访问此类型的锁。实际上，我们认为不是\r\n            我们可以并行生成多个文档的重要情况，因此\r\n            我们只需将此锁定围绕所有公共入口点即可实施顺序访问。\r\n            \r\n","After the concatenation operator (&).":"串联操作员（＆）之后。\r\n"," \r\n    with ":" \r\n    和\r\n","\r\n            get tokens with given annotation in current document\r\n            ":"\r\n            在当前文档中使用给定注释获取令牌\r\n            \r\n"," True if 'Overloads' is explicitly specified in method's declaration ":" 是的，如果在方法的声明中明确指定了“超载”\r\n","\r\n The type of an expression that ":"\r\n 表达式的类型\r\n","\r\n  Looks up a localized string similar to Expected closing ']]>' for XML CDATA section..\r\n":"\r\n  查找类似于XML CDATA部分的预期关闭']]>'的本地化字符串。\r\n\r\n","The modified identifier that declares a variable.":"声明变量的修改后标识符。\r\n","Updating a {0} around an active statement requires restarting the application.":"围绕活动语句更新{0}需要重新启动应用程序。\r\n","\r\n Bind AggregationRangeVariableSyntax in context of this binder.\r\n ":"\r\n 在此粘合剂的上下文中，绑定聚集的variablesyntax。\r\n \r\n","\r\n Returns the index of the first member of the specific kind.\r\n Returns the number of members if not found.\r\n ":"\r\n 返回特定类型的第一个成员的索引。\r\n 如果找不到的话，将返回会员人数。\r\n \r\n","\r\n Lookup a type within the assembly using its canonical CLR metadata name (names are compared case-sensitively).\r\n ":"\r\n 使用其规范的CLR元数据名称查找装配体中的类型（对案例敏感性比较名称）。\r\n \r\n","The + quantifier matches the preceding element one or more times. It is equivalent to the {1,} quantifier. + is a greedy quantifier whose lazy equivalent is +?.":"+量化器匹配前面的元素一次或多次。它等效于{1，}量词。 +是贪婪的量词，其懒惰的等效物是 +？\r\n","ref local or expression":"参考本地或表达\r\n","\r\n The value for the StartQuoteToken property.\r\n ":"\r\n startquotetoken属性的价值。\r\n \r\n","\r\n Returns Nothing if Kind=ReDim, returns the \"Preserve\" keyword if\r\n Kind=RedimPreserve.\r\n ":"\r\n 如果chind = redim，返回什么都没有返回，则返回“保存”关键字，如果\r\n Kind = redimpreserve。\r\n \r\n","dot":"点\r\n","\r\n            number of pending work item in the queue. \r\n            null means N/A for the associated ":"\r\n            队列中未决的工作项目数量。\r\n            零表示相关的不适用\r\n"," can return an instance of this operation along with the other \r\n            operations they want to apply.  For example, an implementation could generate a new ":" 可以返回此操作的实例\r\n            他们想申请的操作。例如，实现可以生成新的\r\n","\r\n Options that can be used to modify the symbol lookup mechanism. Multiple options can be combined together.\r\n ":"\r\n 可用于修改符号查找机制的选项。可以将多个选项组合在一起。\r\n \r\n","year (4 digits)":"年（4位数字）\r\n","A copy constructor '{0}' must be public or protected because the record is not sealed.":"复制构造函数'{0}'必须公开或受保护，因为记录未密封。\r\n","\r\n            When another in-memory assembly references the ":"\r\n            当另一个内存组件引用\r\n","\r\n Equivalent to MethodKind = MethodKind.LambdaMethod, but can be called on a symbol directly.\r\n ":"\r\n 等效于MethodKind = MethodKind.lambdamethod，但可以直接在符号上调用。\r\n \r\n","\r\n Returns the nearest lexically enclosing type, or Nothing if there is none.\r\n ":"\r\n 返回最近的词汇封闭类型，或者如果没有，则无需返回。\r\n \r\n"," spans may vary.\r\n            ":" 跨度可能会有所不同。\r\n            \r\n","\r\n This is a layer on top of the Compilation version that generates a diagnostic if the well-known\r\n member isn't found.\r\n ":"\r\n 这是汇编版本顶部的一层，如果众所周知\r\n 找不到会员。\r\n \r\n","Warning: Collection was modified during iteration.":"警告：在迭代期间进行了修改。\r\n","A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.\r\n                \r\n            'name1' is the current group (optional), 'name2' is a previous ...":"平衡组的定义删除了先前定义的组和存储的定义，在当前组中，以前定义的组与当前组之间的间隔。\r\n                \r\n            “ name1”是当前组（可选），'name2'是以前的...\r\n"," \r\n The root node of the syntax tree that this binding is based on.\r\n ":" \r\n 该绑定基于的语法树的根节点。\r\n \r\n","\r\n            searches.  We search different scopes in different ways.  For example we use \r\n            SymbolTreeInfos to search unreferenced projects and metadata dlls.  However,\r\n            for the current project we're editing we defer to the compiler to do the \r\n            search.\r\n            ":"\r\n            搜索。我们以不同的方式搜索不同的范围。例如，我们使用\r\n            符号TreeInfos搜索未引用的项目和元数据DLL。然而，\r\n            对于当前的项目，我们正在编辑我们推迟到编译器进行编译器\r\n            搜索。\r\n            \r\n","\r\n            Opens a PDB file produced by the compiler.\r\n            ":"\r\n            打开编译器生成的PDB文件。\r\n            \r\n","\r\n The value for the CatchStatement property.\r\n ":"\r\n 关注属性属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to '#If' block must end with a matching '#End If'..\r\n":"\r\n  查找类似于“ #if”块的本地化字符串，必须以匹配的“ #end”结尾。\r\n\r\n","\r\n The name of the type being declared.\r\n ":"\r\n 被声明的类型的名称。\r\n \r\n","\r\n If analysis is being performed in a context of a method returns method's return type, \r\n otherwise returns Nothing\r\n ":"\r\n 如果在方法返回方法的返回类型的上下文中进行分析，\r\n 否则什么都不会返回\r\n \r\n","Modifying an active {0} which contains On Error or Resume statements requires restarting the application.":"修改包含错误或简历语句的活动{0}需要重新启动应用程序。\r\n","\r\n            Whether or not this definition should be presented if we never found any references to\r\n            it.  For example, when searching for a property, the FindReferences engine will cascade\r\n            to the accessors in case any code specifically called those accessors (can happen in \r\n            cross-language cases).  However, in the normal case where there were no calls specifically\r\n            to the accessor, we would not want to display them in the UI.  \r\n            \r\n            For most definitions we will want to display them, even if no references were found.  \r\n            This property allows for this customization in behavior.\r\n            ":"\r\n            如果我们从未找到任何参考文献，是否应该提出此定义\r\n            它。例如，在搜索属性时，FindReferences引擎将级联\r\n            如果任何专门称为这些访问者的代码，可以在登录中进行（可以发生在\r\n            跨语言案例）。但是，在没有专门打电话的正常情况下\r\n            对于登录器，我们不想在UI中显示它们。\r\n            \r\n            对于大多数定义，即使找不到参考，我们也希望显示它们。\r\n            此属性允许在行为中进行自定义。\r\n            \r\n","\r\n Returns a copy of this with the SkipOrTakeKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，并使用Skiportakekeyword属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Returns a copy of this with the LessThanQuestionToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回其中的副本，而LessThanquestiontoken属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n  Looks up a localized string similar to Default member of '{0}' is not a property..\r\n":"\r\n  查找类似于“ {0}”的默认成员的本地化字符串不是属性。\r\n\r\n","\r\n Returns a copy of this with the FirstExpression property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此的副本，而第一表达属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n"," then the controller will\r\n            pick the first item that has enough arguments to be viable based on what argument \r\n            position the user is currently inside of.\r\n            ":" 然后控制器将\r\n            根据哪个参数选择足够的论点可行的第一个项目\r\n            定位用户当前在内部。\r\n            \r\n","Not Available ⚠":"不可用\r\n","\r\n Represents a single handled event in a \"Handles ...\" clause.\r\n ":"\r\n 代表“句柄...”子句中的一个处理事件。\r\n \r\n","\r\n This instance is used to compare parameter and return types, including byref.\r\n ":"\r\n 此实例用于比较参数和返回类型，包括BYREF。\r\n \r\n","\r\n            Check if there are interleaved directives on the statement.\r\n            Handles special case with if/else.\r\n            ":"\r\n            检查该声明中是否有交错指令。\r\n            处理特殊情况IF/else。\r\n            \r\n","\r\n The type of the object being initialized.\r\n ":"\r\n 初始化对象的类型。\r\n \r\n","\r\n Definition of a symbol which this instance of TypeSubstitution primarily targets.\r\n ":"符号的定义类型实例主要针对的。\r\n \r\n","\r\n            The kind of action that triggered completion to start.\r\n            ":"\r\n            触发完成的动作。\r\n            \r\n","\r\n Represents the expression with the number of items to take or skip.\r\n ":"代表要采取或跳过的项目数量的表达式。\r\n \r\n","\r\n Creates a speculative SemanticModel for a TypeSyntax or a RangeArgumentSyntax node at a position within an existing MemberSemanticModel.\r\n ":"\r\n 在现有的成员emanticmodel中的位置上为型尺寸或rangeargumentsyntax节点创建投机词素模型。\r\n \r\n","\r\n Creates the syntax representation of an xml element that spans multiple text lines.\r\n ":"\r\n 创建跨多个文本行的XML元素的语法表示。\r\n \r\n","\r\n A lot of code is #If False disabled until it can be tested. \r\n ":"\r\n 许多代码是#if false禁用，直到可以进行测试。\r\n \r\n","Cannot convert method group to function pointer (Are you missing a '&'?)":"不能将方法组转换为函数指针（您是否缺少'＆'？）\r\n"," in which ":" 其中\r\n","\r\n Returns a copy of this with the EndTag property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此的副本，其中EndTag属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n            The item is the pair of target argument expression and its conversion type\r\n            ":"\r\n            该项目是一对目标参数表达式及其转换类型\r\n            \r\n","\r\n Returns a copy of this with the Prefix property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此副本，前缀属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n Determines the method conversion for delegates based on the arguments.\r\n ":"\r\n 根据参数确定代表的方法转换。\r\n \r\n","\r\n            Given the following assumptions:\r\n            - source generators are deterministic,\r\n            - source documents, metadata references and compilation options have not changed,\r\n            - additional documents have not changed,\r\n            - analyzer config documents have not changed,\r\n            the outputs of source generators will not change.\r\n            \r\n            Currently it's not possible to change compilation options (Project System is readonly during debugging).\r\n            ":"\r\n            给定以下假设：\r\n             - 源生成器是确定性的，\r\n             - 源文档，元数据参考和汇编选项尚未更改，\r\n             - 其他文档没有更改，\r\n             - 分析仪配置文档没有更改，\r\n            源发电机的输出不会更改。\r\n            \r\n            当前，不可能更改编译选项（在调试期间已阅读项目系统）。\r\n            \r\n","\r\n Returns true if this member is overridable, has an implementation,\r\n and does not override a base class member; i.e., declared with the \"Overridable\"\r\n modifier. Does not return true for members declared as MustOverride or Overrides.\r\n ":"\r\n 如果此成员不满意，则返回true，具有实现，\r\n 并且不覆盖基类成员；即，以“过度润滑”声明\r\n 修饰符。对于声明为Mustoverride或替代的成员，不返回True。\r\n \r\n","\r\n The underlying ModuleSymbol for the retargeting module.\r\n ":"\r\n 重新定位模块的基础模块符号。\r\n \r\n","\r\n Returns Symbol for String type.\r\n ":"\r\n 返回字符串类型的符号。\r\n \r\n","\r\n The \")\" token that concludes the parameter list. If no parameter list was\r\n present, Nothing is returned.\r\n ":"总结参数列表的“）”令牌。如果没有参数列表\r\n 目前，什么都没有归还。\r\n \r\n","\r\n            The delegate doesn't hold on this script or its compilation.\r\n            ":"\r\n            代表不在此脚本或其汇编上。\r\n            \r\n","Use expression body for accessors":"使用表达式主体作为登录机\r\n","\r\n Add fields to the state machine class that control the state machine.\r\n ":"\r\n 将字段添加到控制状态计算机的状态计算机类中。\r\n \r\n","\r\n A ExecutableCodeBinder provides context for looking up labels within a context represented by a syntax node, \r\n and also implementation of GetBinder. \r\n ":"\r\n ExecutableCodeBinder提供了上下文，以在语法节点表示的上下文中查找标签，\r\n 以及GetBinder的实施。\r\n \r\n","\r\n  Looks up a localized string similar to 'Continue Do' can only appear inside a 'Do' statement..\r\n":"\r\n  查找类似于“继续do”的本地化字符串只能出现在“ do”语句中。\r\n\r\n","\r\n Namespace or type that \"gains\" access to the type.\r\n ":"\r\n 名称空间或键入“获得”访问该类型的空间。\r\n \r\n","Namespace \"{0}\" does not match folder structure, expected \"{1}\"":"名称空间“ {0}”不匹配文件夹结构，预期“ {1}”\r\n","\r\n Receiver type for extension method. Otherwise, containing type.\r\n ":"\r\n 扩展方法的接收器类型。否则，包含类型。\r\n \r\n","\r\n            Provides access to compilation outputs based only on the path of the output asssembly.\r\n            If PDB path is known upfront use ":"\r\n            仅基于输出评估路径的路径提供对汇编输出的访问。\r\n            如果已知PDB路径预先使用\r\n","the position in the document with \r\n            the signature of the method, used for binding types (e.g. for added\r\n            parameters)":"文档中的位置与\r\n            该方法的签名，用于绑定类型（例如，添加\r\n            参数）\r\n","\r\n            Represents a constant-pattern constructed from an equality check\r\n            ":"\r\n            表示由平等检查构建的恒定图案\r\n            \r\n","\r\n The \"Class\" statement that begins the block.\r\n ":"\r\n 开始块的“类”语句。\r\n \r\n","\r\n            (1) a node of type ":"\r\n            （1）类型节点\r\n","\r\n Simplified version of ExtractAnonymousTypeMemberName implemented on inner tokens.\r\n ":"\r\n 在内部令牌上实现的简化版本的ExtractAnonymoustypemembername。\r\n \r\n"," which will have current syntax tree as its parent.\r\n \r\n Caller must guarantee that if the same instance of ":" 它将以当前的语法树作为父。\r\n \r\n 呼叫者必须保证，如果相同的实例\r\n","\r\n The value for the EndEventStatement property.\r\n ":"\r\n EndeventStatement属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to Overload resolution failed because no accessible '{0}' can be called:{1}.\r\n":"\r\n  查找类似于过载分辨率的本地化字符串失败，因为无法称呼“ {0}”'可以：{1}。\r\n\r\n","\r\n The parameters forming part of this signature.\r\n ":"\r\n 构成此签名的一部分的参数。\r\n \r\n","\r\n            ```$``` or ```^```.\r\n            ":"\r\n            ``$````````'''''。\r\n            \r\n","\r\n  Looks up a localized string similar to '#ElseIf', '#Else', or '#End If' must be preceded by a matching '#If'..\r\n":"\r\n  查找类似于“ #elseif”，“ #else”或“ #end”的本地化字符串，必须先于匹配的'#if'..\r\n\r\n","\r\n Binds the name in the context of the specified location and sees if it resolves to an\r\n alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.\r\n ":"\r\n 在指定位置的上下文中绑定名称，并查看是否解决\r\n 别名。如果确实如此，请返回与之相对应的别秒词。否则，返回null。\r\n \r\n","The document to format.":"格式的文档。\r\n","True if the list should be dismissed when the user deletes the last character in the span.":"正确，如果在用户删除跨度中的最后一个字符时应删除列表。\r\n","\r\n            Navigates to the given position in the specified document, opening it if necessary.\r\n            ":"\r\n            导航到指定文档中的给定位置，如有必要。\r\n            \r\n","commits changes if true, discards if false":"如果是真的，则提交会更改，如果false\r\n","\r\n Represents an XML member element access (node.<Element>), attribute\r\n access (node.@Attribute) or descendants access (node...<Descendant>). The\r\n Kind property determines which kind of access.\r\n ":"\r\n 代表XML成员元素访问（node。<element>），属性\r\n 访问（node。@attribute）或后代访问（node ... <descendant>）。这\r\n 友好属性确定哪种访问权限。\r\n \r\n","\r\n A mapping from (source) iterator or async methods to the compiler-generated classes that implement them.\r\n ":"\r\n 从（源）迭代器或异步方法映射到实现它们的编译器生成类。\r\n \r\n","\r\n Symbol for the type or null if type cannot be found or is ambiguous. \r\n ":"\r\n 如果找不到类型或模棱两可，则类型或空的符号。\r\n \r\n","A comparer for comparing signatures of TSymbol according to metadata implementation rules.":"根据元数据实施规则比较TSymbol的签名的比较。\r\n","Expected string or char literal":"预期的字符串或字符字面量\r\n","Add file header":"添加文件标头\r\n","\r\n Returns a copy of this with the SelectStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此的副本，而SelectStatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","'{0}' is not null here.":"'{0}'在这里不是零。\r\n","\r\n Returns false if operator should be ignored.\r\n ":"\r\n 如果应忽略操作员，返回false。\r\n \r\n","\r\n Represents a For Each block, including the introducing statement, the body and\r\n the \"Next\" (which can be omitted if a containing For has a Next with multiple\r\n variables).\r\n ":"\r\n 代表每个块，包括介绍陈述，身体和\r\n “下一个”（如果包含一个有多个\r\n 变量）。\r\n \r\n","\r\n            Annotation used to find the closing brace location after formatting changes are applied.\r\n            The closing brace location is then used as the caret location.\r\n            ":"\r\n            使用格式化更改后用于查找闭合支架位置的注释。\r\n            然后，闭合支架位置被用作看台位置。\r\n            \r\n","\r\n            Flag indicating if we should perform a rename inside comment trivia.\r\n            ":"\r\n            标志指示我们是否应该在评论琐事中进行重命名。\r\n            \r\n","'{0}' cannot implement interface member '{1}' in type '{2}' because feature '{3}' is not available in C# {4}. Please use language version '{5}' or greater.":"'{0}'无法在类型'{2}'中实现接口成员'{1}'，因为功能'{3}'在c＃{4}中不可用。请使用语言版本'{5}'或更大。\r\n","s that are added as the given ":"添加为给定的\r\n","Make private fields readonly when possible":"尽可能地阅读私人字段\r\n"," for those specific members.\r\n            ":" 对于那些特定的成员。\r\n            \r\n","\r\n Helper to generate binary expressions.\r\n Performs some trivial constant folding.\r\n TODO: Perhaps belong to a different file\r\n ":"\r\n 生成二进制表达式的助手。\r\n 执行一些琐碎的常量折叠。\r\n TODO：也许属于不同的文件\r\n \r\n","\r\n Represents a field in a RetargetingModuleSymbol. Essentially this is a wrapper around \r\n another FieldSymbol that is responsible for retargeting symbols from one assembly to another. \r\n It can retarget symbols for multiple assemblies at the same time.\r\n ":"\r\n 代表retargetingModulesymbol中的字段。本质上，这是周围的包装纸\r\n 另一个负责从一个组件重新定位符号到另一个组件的fieldSymbol。\r\n 它可以同时重新定位多个组件。\r\n \r\n","\r\n The value for the Declarators property.\r\n ":"\r\n 声明者属性的价值。\r\n \r\n"," if successful.\r\n            ":" 如果成功。\r\n            \r\n","\r\n Given a result of binding of initial set of collection range variables, the source,\r\n bind the rest of the operators in the enumerator.\r\n \r\n There is a special method to bind an operator of each kind, the common thing among them is that\r\n all of them take the result we have so far, the source, and return result of an application \r\n of one or two following operators. \r\n Some of the methods also take operators enumerator in order to be able to do a necessary look-ahead\r\n and in some cases even to advance the enumerator themselves.\r\n Join and From operators absorb following Select or Let, that is when the process of binding of \r\n a single operator actually handles two and advances the enumerator. \r\n ":"\r\n 鉴于初始集合范围变量的结合结果，源，\r\n 绑定枚举器中其余的操作员。\r\n \r\n 有一种特殊的方法可以绑定每种操作员，其中的常见是\r\n 他们所有人都采取了我们到目前为止的结果，申请的来源和返回结果\r\n 一个或两个接下来的操作员。\r\n 其中一些方法还使运营商枚举器能够进行必要的外观\r\n 在某些情况下，甚至可以自己推进枚举者。\r\n 加入和从操作员吸收以下选择或让，这就是绑定过程\r\n 单个操作员实际上处理两个操作员并推进枚举者。\r\n \r\n"," case when ":" 何时\r\n","\r\n            Returns a script variable of the specified name. \r\n            ":"\r\n            返回指定名称的脚本变量。\r\n            \r\n","\r\n For each captured variable, identifies the statement in which it will be moved to a frame class.  This is\r\n normally the block where the variable is introduced, but method parameters are moved\r\n to a frame class within the body of the method.\r\n ":"\r\n 对于每个捕获的变量，请标识将其移至帧类的语句。这是\r\n 通常是引入变量的块，但是移动方法参数\r\n 到该方法主体内的框架类。\r\n \r\n","\r\n            Opens an assembly file produced by the compiler (corresponds to OutputAssembly build task parameter).\r\n            ":"\r\n            打开编译器生成的汇编文件（对应于OutputAssembly构建任务参数）。\r\n            \r\n","\r\n  Looks up a localized string similar to Array declared as for loop control variable cannot be declared with an initial size..\r\n":"\r\n  查找类似于声明的数组的本地化字符串，因为循环控制变量不能以初始大小声明。\r\n\r\n","\r\n            as we need to swap the editor tracking mode of the closing point from positive to negative\r\n            in BraceCompletionSessionProvider.BraceCompletionSession.Start after completing the brace and before\r\n            doing any kind of formatting on it.  So these must be two distinct steps until we fully move to LSP.\r\n            ":"\r\n            由于我们需要将截止点的编辑跟踪模式从正面到负面\r\n            在BraceCompletionsessesseessessesses.bracecompletionsessession.Start完成支架后开始\r\n            在上面做任何格式。因此，这些必须是两个不同的步骤，直到我们完全移至LSP。\r\n            \r\n","\r\n  Looks up a localized string similar to Format specifier may not contain trailing whitespace..\r\n":"\r\n  查找类似于格式指定符的本地化字符串可能不包含尾随的空格。\r\n\r\n","\r\n Returns True if this conversion a widening user defined or a narrowing user defined conversion, as defined in\r\n section 8.11.\r\n ":"\r\n 如果此转换为ven的用户定义或缩小用户定义的转换，则返回true（如\r\n 第8.11节。\r\n \r\n","Use expression body for methods":"使用表达式主体进行方法\r\n","\r\n The value for the IfKeyword property.\r\n ":"\r\n IFKeyWord属性的值。\r\n \r\n","Absolute path.":"绝对路径。\r\n","\r\n            Per-language option that can be used to configure the given ":"\r\n            可用于配置给定的每个语言选项\r\n","\r\n            XML comment on 'construct' has syntactically incorrect cref attribute 'name'\r\n            ":"\r\n            XML对“构造”的评论在句法上不正确cref属性“名称”\r\n            \r\n","\r\n If the new source text is a minor change from the current source text an incremental parse will occur\r\n reusing most of the current syntax tree internal data.  Otherwise, a full parse will occur using the new\r\n source text.\r\n ":"\r\n 如果新源文本是当前源文本的较小更改，则会发生增量解析\r\n 重用大多数当前语法树内部数据。否则，将使用新的\r\n 源文本。\r\n \r\n","\r\n Retargeted custom attributes\r\n ":"重新定制属性\r\n \r\n","\r\n Represents a lambda expression, either single line or multi-line.\r\n ":"\r\n 代表单线或多行的lambda表达式。\r\n \r\n","\r\n A local symbol created by a for-each statement when Option Infer is on.\r\n ":"\r\n A local symbol created by a for-each statement when Option Infer is on.\r\n \r\n","\r\n            The indent trivia to insert if we are trying to simply smart-indent all wrapped\r\n            parts of the expression.\r\n            ":"\r\n            如果我们只是想简单地包装所有包装的缩进的琐事\r\n            表达的一部分。\r\n            \r\n","\r\n Returns a copy of this with the EventKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中EventKeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","True if this argument is a named argument; otherwise false.":"如果此论点是一个命名的参数，则为是的；否则错误。\r\n","\r\n            Additional locations to present in the UI.  A definition may have multiple locations \r\n            for cases like partial types/members.\r\n            ":"\r\n            UI中要出现的其他位置。定义可能有多个位置\r\n            对于部分类型/成员等案例。\r\n            \r\n","\r\n Returns a copy of this with the ColonToken property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而Colontoken财产更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","punctuation, other":"标点符号，其他\r\n"," \r\n Returns a list of attributes to emit to CustomAttribute table.\r\n ":" \r\n 返回一个属性列表，以排放到自定义大限表。\r\n \r\n"," is a method, accessor, operator, destructor, or constructor without an initializer,\r\n            tokens of its block body, or tokens of the expression body.\r\n            \r\n            If ":" 是一种方法，访问者，操作员，击振孔或构造函数，没有初始化器，\r\n            其块体的代币或表达体的令牌。\r\n            \r\n            如果\r\n","\r\n Return the length of the common ending between the two\r\n sets of trivia. The valid trivia (following skipped tokens)\r\n of one must be contained in the valid trivia of the other. \r\n ":"返回两者之间的共同结尾的长度\r\n 一组琐事。有效的琐事（跳过令牌后面）\r\n 一个必须包含在另一个的有效琐事中。\r\n \r\n","\r\n Optional AsQueryable/AsEnumerable/Cast(Of Object) method used \r\n to \"convert\" ":"\r\n 可选的Asqueryable/susenumerable/cast（对象）方法所使用的\r\n 转换”\r\n","\r\n            Returns an array of ":"返回一系列\r\n","The ? quantifier matches the preceding element zero or one time. It is equivalent to the {0,1} quantifier. ? is a greedy quantifier whose lazy equivalent is ??.":"这 ？量词匹配前面的元素零或一次。它等效于{0,1}量词。 ？贪婪的量词是懒惰的等效物是??。\r\n","\r\n Represent an expression in a statement context. This may only be a invocation\r\n or await expression in standard code but may be any expression in VB\r\n Interactive code.\r\n ":"\r\n 表示语句上下文中的表达。这可能只是调用\r\n 或等待标准代码中的表达方式，但可能是VB中的任何表达式\r\n 交互式代码。\r\n \r\n","The place to report errors for the generic type as a whole":"报告整体通用类型的错误的地方\r\n","\r\n            Adds a file at the given path as a solution item.\r\n            NOTE: ":"\r\n            在给定路径上添加文件作为解决方案项目。\r\n            笔记：\r\n","\r\n Represents an #End Region directive appearing in source.\r\n ":"\r\n 表示源出现在源中的#end区域指令。\r\n \r\n","An ImmutableArray containing all the modules that are members of this namespace with the given name. \r\n If this symbol has no modules with this name,\r\n returns an empty ImmutableArray. Never returns Nothing.":"一个ImmutableArray包含具有给定名称的所有模块。\r\n 如果此符号没有此名称的模块，\r\n 返回一个空的Immutablearray。永远不会返回。\r\n","\r\n  Looks up a localized string similar to Type parameter already declared with name '{0}'..\r\n":"\r\n  查找类似于已经声明的类型参数的本地化字符串，名称为“ {0}”。\r\n\r\n","Returns:":"返回：\r\n","\r\n  Looks up a localized string similar to Namespace declaration with prefix cannot have an empty value inside an XML literal..\r\n":"\r\n  查找类似于前缀的名称空间声明的本地化字符串，在XML文字中不能具有空值。\r\n\r\n","\r\n Returns true if there is no illegal access exposure, false otherwise.\r\n \r\n Four cases:\r\n 1: Member is not protected, non of its enclosing scopes are protected\r\n 2: Member is not protected, but some of its enclosing scopes are protected\r\n 3: Member is protected, non of its enclosing scopes are protected\r\n 4: Member is protected, some of its enclosing scopes are also protected\r\n ":"\r\n 如果没有非法访问曝光，则返回true，否则为false。\r\n \r\n 四个案例：\r\n 1：不受保护的成员，其封闭范围不受保护\r\n 2：成员不受保护，但其某些封闭范围受到保护\r\n 3：会员受到保护，其封闭范围的非范围受到保护\r\n 4：会员受到保护，其某些封闭范围也受到保护\r\n \r\n","\r\n Gets what kind of method this is. There are several different kinds of things in the\r\n VB language that are represented as methods. This property allow distinguishing those things\r\n without having to decode the name of the method.\r\n ":"\r\n 得到这是什么方法。有几种不同的东西\r\n 表示为方法的VB语言。该属性允许区分这些东西\r\n 无需解码该方法的名称。\r\n \r\n","True if Option Infer On, False if Option Infer Off.":"如果选项推断，则为true，如果选项推断，false。\r\n","\r\n            None of operands were constant.\r\n            ":"\r\n            操作数没有恒定。\r\n            \r\n","select clause":"选择子句\r\n","\r\n Private helper to make sure identity substitutions are injected for types between \r\n targetGenericDefinition and parent.TargetGenericDefinition.\r\n ":"\r\n 私人助手以确保身份替换被注入\r\n targetGenericDefinition和parent.targetGenericDefinition。\r\n \r\n"," \r\n Determines if the method is partial and does NOT have implementation provided \r\n ":" \r\n 确定该方法是否部分且没有提供实施\r\n \r\n","\r\n Lookups labels by label names, returns a label or Nothing\r\n ":"\r\n 通过标签名称查找标签，返回标签或什么都没有\r\n \r\n","\r\n            Available if ":"\r\n            可用\r\n","\r\n Create an Expression node with the given name, type arguments, and arguments.\r\n ":"\r\n 使用给定名称，类型参数和参数创建一个表达节点。\r\n \r\n","\r\n This function finds the inner most enclosing scope whose Access\r\n is lesser than or equal to the given access \"StopAtAccess\".\r\n ":"\r\n 此功能找到了内部最封闭的范围的访问权限\r\n 比给定的访问“ stopataccess”少或等于。\r\n \r\n"," output.\r\n            ":" 输出。\r\n            \r\n","Convert to LINQ":"转换为Linq\r\n","\r\n Returns True if this conversion a widening nullable value type conversion or a narrowing nullable value type\r\n conversion as defined in section 8.6.1.\r\n ":"\r\n 如果此转换为延伸的无效价值类型转换或可缩小的无效价值类型，则返回true\r\n 第8.6.1节中定义的转换。\r\n \r\n","\r\n The \":=\" token.\r\n ":"\r\n “：=”令牌。\r\n \r\n","\r\n This function classifies user-defined conversions.\r\n ":"\r\n 此功能对用户定义的转换进行了分类。\r\n \r\n"," if successful.\r\n ":"如果成功。\r\n \r\n","\r\n Returns a copy of this with the ElseStatement property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中ElSestatement属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            Called when the diagnostic analyzer engine decides to remove existing diagnostics.\r\n            For example, this can happen when a document is removed from a solution.  In that\r\n            case the analyzer engine will delete all diagnostics associated with that document.\r\n            Any layers caching diagnostics should listen for these events to know when to \r\n            delete their cached items entirely.\r\n            ":"\r\n            当诊断分析仪引擎决定删除现有诊断时，请致电。\r\n            例如，当从解决方案中删除文档时，这可能会发生。在那里面\r\n            案例分析仪引擎将删除与该文档相关的所有诊断。\r\n            任何层缓存诊断都应聆听这些事件，以了解何时\r\n            完全删除他们的缓存物品。\r\n            \r\n","Move to namespace...":"移至名称空间...\r\n","Matches a bell (alarm) character, \\u0007":"匹配铃（警报）字符\\ u0007\r\n","An array of nodes and tokens.":"一系列节点和令牌。\r\n","\r\n  Looks up a localized string similar to '{0}' is an interface type and cannot be used as an expression..\r\n":"\r\n  查找类似于“ {0}”的局部字符串是接口类型，不能用作表达式。\r\n\r\n","\r\n            Updates the project’s reference by removing or marking references as\r\n            TreatAsUsed in the project file.\r\n            ":"\r\n            通过删除或标记引用为\r\n            在项目文件中进行处理。\r\n            \r\n","True if symbol is accessible. False otherwise.":"如果可以访问符号，则为true。否则为错误。\r\n","\r\n Specifies a kind of an Async method\r\n \r\n None is returned for non-Async methods or methods with wrong return type\r\n ":"\r\n 指定一种异步方法\r\n \r\n 没有返回错误的返回类型的非ASYNC方法或方法\r\n \r\n","interpolated string handlers":"插值字符串处理程序\r\n","\r\n  Looks up a localized string similar to 'End Enum' must be preceded by a matching 'Enum'..\r\n":"\r\n  查找类似于“ End Enum”的本地化字符串必须先于匹配的“枚举”。\r\n\r\n","\r\n NOTE: in some cases, like for binding inside anonymous object creation expression, this \r\n method returns bound node for the whole expression rather than only for omitted left part. \r\n ":"\r\n 注意：在某些情况下，例如在匿名对象创建表达式中绑定，此\r\n 方法返回整个表达式的绑定节点，而不仅仅是省略左侧部分。\r\n \r\n","\r\n The member(s) that are potentially being overridden. This collection only contains \r\n candidates having signature 'generally' matching the signature of the method/property. \r\n \r\n Two signatures 'generally' match if DetailedSignatureCompare (...) returns no \r\n mismatches defined in SymbolComparisonResults.AllMismatches ignoring mismatches \r\n grouped in SymbolComparisonResults.MismatchesForConflictingMethods.\r\n ":"\r\n 可能被覆盖的成员。该集合仅包含\r\n 签名“通常”与方法/属性的签名相匹配的候选人。\r\n \r\n 如果详细的SignatureCompare（...）返回否，则两个签名“通常”匹配\r\n 在符号范围中定义的不匹配。\r\n 分组中的符号范围。\r\n \r\n","Selection can not be part of constant initializer expression.":"选择不能成为恒定初始器表达式的一部分。\r\n"," changed.\r\n            ":" 更改。\r\n            \r\n"," representing the specific kind of\r\n RelationalCaseClauseSyntax. One of CaseEqualsClause, CaseNotEqualsClause,\r\n CaseLessThanClause, CaseLessThanOrEqualClause, CaseGreaterThanOrEqualClause,\r\n CaseGreaterThanClause.\r\n ":" 代表特定种类\r\n 关系caseclausesyntax。 Caseequalsclause之一，casenotequalspause，\r\n caselessthanclause，caselessthanorequalause，casegreatthanorequalause，\r\n casegreaterthanclause。\r\n \r\n","\r\n            Indicates if the operation block has an operation that leads to a delegate escaping the current block,\r\n            which would prevent us from performing accurate flow analysis of lambda/local function invocations\r\n            within this operation block.\r\n            Some examples:\r\n                1. Delegate assigned to a field or property.\r\n                2. Delegate passed as an argument to an invocation or object creation.\r\n                3. Delegate added to an array or wrapped within a tuple.\r\n                4. Delegate converted to a non-delegate type.\r\n            We use this value in ":"\r\n            指示该操作块是否具有导致委托逃脱当前块的操作，\r\n            这将阻止我们对lambda/局部功能调用进行准确的流动分析\r\n            在此操作块中。\r\n            一些例子：\r\n                1.分配给字段或属性的委托。\r\n                2.委托作为参数传递给调用或对象创建。\r\n                3.添加到阵列或包裹在元组中的委托。\r\n                4.委派转换为非贵族类型。\r\n            我们在\r\n","\r\n            Completion was triggered via an action inserting a character into the document.\r\n            ":"\r\n            完成通过将角色插入文档中的操作触发。\r\n            \r\n","\r\n Add names of viable extension methods declared in this type to nameSet parameter.\r\n \r\n The 'appendThrough' parameter allows RetargetingNamedTypeSymbol to delegate majority of the work \r\n to the underlying named type symbol, but still perform viability check on RetargetingMethodSymbol.\r\n ":"\r\n 将此类型中声明的可行扩展方法的名称添加到姓名参数。\r\n \r\n “附录”参数允许retargetingnemedtypesymbol委派大多数作品\r\n 到基础命名类型符号，但仍能对RetargetingMethodSymbol进行生存性检查。\r\n \r\n","\r\n  Looks up a localized string similar to Imports alias '{0}' conflicts with '{1}' declared in the root namespace..\r\n":"\r\n  查找类似于导入别名'{0}'与'{1}'在root namespace中声明的'{1}'冲突的本地化字符串。\r\n\r\n","\r\n The expression denoting the final value of the iteration.\r\n ":"\r\n 表示迭代的最终值的表达式。\r\n \r\n","s.\r\n            Note that the code fix/light bulb engine groups all such ":"s。\r\n            请注意，代码修复/灯泡发动机组所有\r\n","index operator":"索引操作员\r\n","\r\n Operator for Equality with GlobalImport Objects.\r\n ":"\r\n 使用GlobalImport对象的平等运算符。\r\n \r\n","\r\n Creates a syntax node for a cref attribute within a xml documentation comment.\r\n ":"\r\n 在XML文档注释中为CREF属性创建语法节点。\r\n \r\n"," The argument list of invocation expression":" 调用表达式的参数列表\r\n","Configure {0} severity":"配置{0}严重性\r\n","\r\n The value for the RankSpecifiers property.\r\n ":"\r\n RankSpecifiers属性的值。\r\n \r\n","\r\n Get all the errors within the syntax tree associated with this object. Includes errors involving compiling\r\n method bodies or initializers, in addition to the errors returned by GetDeclarationDiagnostics and parse errors.\r\n ":"\r\n 在与此对象关联的语法树中获取所有错误。包括涉及编译的错误\r\n 方法主体或初始化器除了GetDeclarationDiagnostics和解析错误返回的错误外。\r\n \r\n","\r\n The containing compilation for compilation namespaces.\r\n ":"\r\n 汇编名称空间的包含汇编。\r\n \r\n","\r\n  Looks up a localized string similar to Indirect constraint '{0}' obtained from the type parameter constraint '{1}' conflicts with the constraint '{2}'..\r\n":"\r\n  查找与从类型参数约束'{1}'相似的间接约束'{0}'相似的本地化字符串，与约束'{2}'..\r\n\r\n","\r\n An optional value for the enum member.\r\n ":"\r\n 枚举成员的可选值。\r\n \r\n","\r\n Represents an XML processing instruction of the form '<? XMLProcessingTarget\r\n XMLProcessingValue ?>'.\r\n ":"\r\n 代表表单'<？的XML处理指令XMLProcessingTarget\r\n xmlProcessingValue？>'。\r\n \r\n","\r\n Binds the object collection or member initializer from a object creation.\r\n E.g. \"new CollType() From {...}\" or \"new AType() With {...}\"\r\n ":"\r\n 从对象创建中绑定对象集合或成员初始化器。\r\n 例如。 “来自{...}}的new CollType（）”或“ with {...}”的“ new Atype（）”\r\n \r\n","\r\n Identifies one of the special instances \"Me\", \"MyClass\" or \"MyBase\". The Kind\r\n property identifies which.\r\n ":"\r\n 标识“我”，“ myclass”或“ mybase”的特殊实例之一。那种\r\n 财产标识哪个。\r\n \r\n"," representing the specific kind of\r\n XmlMemberAccessExpressionSyntax. One of XmlElementAccessExpression,\r\n XmlDescendantAccessExpression, XmlAttributeAccessExpression.\r\n ":" 代表特定种类\r\n xmlmemberaccessexpressynntax。 XmlelementAccessexpression之一，\r\n XMLDESCENDANTACCESSEXPRESSION，XMLATTRIBUTEACCESSExpression。\r\n \r\n"," for variable declarators of fields, properties with an initializer expression, or \r\n              for method-like member declarations with expression bodies (methods, properties, indexers, operators)\r\n            - ":" 对于字段的可变声明器，具有初始化器表达式的属性或\r\n              用于具有表达式的类似方法的成员声明（方法，属性，索引器，操作员）\r\n             - \r\n","\r\n            Constructor for a code style analyzer with a multiple diagnostic descriptors with per-language options that can be used to configure each descriptor.\r\n            ":"代码样式分析仪的构造函数，带有多个诊断描述符，具有每语言选项，可用于配置每个描述符。\r\n            \r\n","Matches an ASCII character, where ## is a two-digit hexadecimal character code.":"匹配ASCII字符，其中##是两位数的十六进制字符代码。\r\n","\r\n            Documentation for this parameter.  This should normally be presented to the user when\r\n            this parameter is selected.\r\n            ":"\r\n            此参数的文档。通常应在\r\n            选择此参数。\r\n            \r\n","Ceasing to access captured variable '{0}' in {1} requires restarting the application.":"在{1}中停止访问捕获的变量'{0}'需要重新启动应用程序。\r\n","The starting offset in the string":"字符串中的起始偏移\r\n","\r\n Gets the instance initializers.\r\n ":"\r\n 获取实例初始化器。\r\n \r\n","\r\n The value for the Expressions property.\r\n ":"\r\n 表达属性的值。\r\n \r\n","\r\n Represents an \"= initializer\" clause in a declaration for a variable,\r\n parameter or automatic property.\r\n ":"\r\n 代表变量声明中的“ = initializer”子句，\r\n 参数或自动属性。\r\n \r\n","Implement interface through '{0}'":"通过'{0}'实现接口\r\n","\r\n            Marks the start of an item in a list; called before each item.\r\n            ":"标记列表中项目的开始；在每个项目之前调用。\r\n            \r\n","\r\n Applies Visual Basic-specific modification and filtering of ":"\r\n 应用视觉基本特定的修改和过滤\r\n","\r\n The argument list.\r\n ":"\r\n 参数列表。\r\n \r\n","\r\n The value for the EndNamespaceStatement property.\r\n ":"EndNamesPaCestatement属性的值。\r\n \r\n","\r\n            Represents a possibly-empty sequence of regex expressions.  For example, the regex \"\"\r\n            will produce an empty RegexSequence nodes, and \"a|\" will produce an alternation with an\r\n            empty sequence on the right side.  Having a node represent the empty sequence is actually\r\n            appropriate as these are legal regexes and the empty sequence represents 'a pattern\r\n            that will match any position'.  Not having a node for this would actually end up \r\n            complicating things in terms of dealing with nulls in the tree.\r\n            \r\n            This does not deviate from Roslyn principles.  While nodes for empty text are rare, they\r\n            are allowed (for example, OmittedTypeArgument in C#).\r\n            ":"\r\n            代表了正则表达式的可能空格序列。例如，正则“”\r\n            将产生一个空的REGEXSESECENCENCENCENNES和“ A |”将与\r\n            右侧的空序列。有一个节点表示空序列实际上是\r\n            这些是合法的，是法律上的，空序列代表“模式”\r\n            那将与任何位置匹配。没有节点实际上会最终\r\n            在处理树上的零子方面使事情变得复杂。\r\n            \r\n            这不会偏离罗斯林原则。虽然很少有空文本节点\r\n            允许（例如，在C＃中省略了typeargument）。\r\n            \r\n","The type of the AsClauseOpt before applying any modifiers":"应用任何修饰符之前，Asclauseopt的类型\r\n"," if this instance is overloads; otherwise, ":" 如果此实例超载；否则，\r\n","\r\n Given a string, find the index of the first non-whitespace char.\r\n ":"\r\n 给定一个字符串，找到第一个非Whitespace char的索引。\r\n \r\n","zero-width positive lookbehind assertion":"零宽度的正面主张\r\n","with on structs":"与结构\r\n","Original expression to be replaced.":"原始表达式要替换。\r\n"," \r\n Determines whether this method is a candidate for a default \r\n assembly entry point. Any method called \"Main\" is.\r\n ":" \r\n 确定此方法是否是默认的候选者\r\n 组装入口点。任何称为“主要”的方法。\r\n \r\n","\r\n A list of statements to be executed if the condition expression evaluates as\r\n true. Multiple statements must be separated by colons.\r\n ":"\r\n 如果条件表达式评估为\r\n 真的。多个陈述必须由结肠隔开。\r\n \r\n","\r\n            this regex is used to remove escaped brackets from\r\n            the format string before looking for valid {} pairs\r\n            ":"\r\n            此正则义务用于从\r\n            格式字符串在寻找有效{}对之前\r\n            \r\n","Use expression body for indexers":"将表达式用于索引器\r\n","\r\n            Determines whether await should be suggested in a given position.\r\n            ":"\r\n            确定是否应在给定职位上提出等待。\r\n            \r\n","\r\n AssemblySymbol to represent missing, for whatever reason, CorLibrary.\r\n The symbol is created by ReferenceManager on as needed basis and is shared by all compilations\r\n with missing CorLibraries.\r\n ":"\r\n 汇编符号代表缺失的，无论出于何种原因）。\r\n 该符号由ReferenceManager根据需要创建，并由所有汇编共享\r\n 缺少圆锥形。\r\n \r\n","\r\n Indicates if the property has a Set accessor.\r\n ":"\r\n 指示该属性是否具有设置访问者。\r\n \r\n","The loaded assembly references .NET Framework, which is not supported.":"加载的汇编参考.NET框架，不支持。\r\n"," if\r\n the computed value is a well-known \"empty\" value. In this case, bits in ":" 如果\r\n 计算值是众所周知的“空”值。在这种情况下，点\r\n","Wrapper method name":"包装器方法名称\r\n","\r\n Represents a property that has undergone type substitution.\r\n ":"\r\n 代表经过类型替代的财产。\r\n \r\n","\r\n            Computes the fix all occurrences code fix, brings up the preview changes dialog for the fix and\r\n            returns the code action operations corresponding to the fix.\r\n            ":"\r\n            计算修复程序所有出现代码修复，从而提出了修复程序的预览更改对话框\r\n            返回与修复程序相对应的代码操作。\r\n            \r\n","\r\n Given a possibly constructed/specialized generic type, create a symbol\r\n representing an unbound generic type for its definition.\r\n ":"\r\n 给定可能构造/专业的通用类型，创建一个符号\r\n 代表其定义的无限通用类型。\r\n \r\n","\r\n The \"Else\" keyword.\r\n ":"\r\n “ else”关键字。\r\n \r\n","\r\n Creates a copy of a token.\r\n ":"\r\n 创建令牌的副本。\r\n \r\n"," applied on this module.\r\n ":" 应用于此模块。\r\n \r\n","hint":"暗示\r\n","\r\n This class is used to validate the compiler options.\r\n ":"\r\n 此类用于验证编译器选项。\r\n \r\n","Simplify name '{0}'":"简化名称'{0}'\r\n","\r\n Backing field of the property, or Nothing if the property doesn't have any.\r\n ":"\r\n 属性的备份字段，或者如果没有任何物业，则什么都没有。\r\n \r\n"," representing the specific kind of LoopStatementSyntax.\r\n One of SimpleLoopStatement, LoopWhileStatement, LoopUntilStatement.\r\n ":" 代表特定类型的loopstatementsyntax。\r\n SimpleLoopStatement，LoopwhilStatement，Loopuntilstatement之一。\r\n \r\n","\r\n            Gets all the diagnostics for this event, respecting the callers setting on if they're getting it for pull\r\n            diagnostics or push diagnostics.  Most clients should use this to ensure they see the proper set of\r\n            diagnostics in their scenario (or an empty array if not in their scenario).\r\n            ":"\r\n            获取此事件的所有诊断，尊重呼叫者的设置，如果他们获得拉力\r\n            诊断或推送诊断。大多数客户应该使用它来确保他们看到适当的集合\r\n            在其场景中的诊断（如果不在场景中，则为空数组）。\r\n            \r\n","Variable declaration can be inlined":"可变声明可以被内衬\r\n","\r\n  Looks up a localized string similar to 'Structure' constraint cannot be specified multiple times for the same type parameter..\r\n":"\r\n  查找类似于“结构”约束的本地化字符串，不能多次指定相同类型的参数。\r\n\r\n","\r\n  Looks up a localized string similar to Type '{0}' must be a value type or a type argument constrained to 'Structure' in order to be used with 'Nullable' or nullable modifier '?'..\r\n":"\r\n  查找类似于“ {0}”类型的本地化字符串必须是一个值类型或限制为“结构”的类型参数，以便与“无效”或“无效的修饰符”一起使用？'..\r\n\r\n","obsolete on property accessor":"过时的物业登录器\r\n","\r\n page represents a cached array of chars.\r\n ":"\r\n 页面代表一个符号的char阵列。\r\n \r\n","\r\n            Represents the result of a FindReferences Count operation.\r\n            ":"\r\n            代表FindReferences计数操作的结果。\r\n            \r\n","\r\n            name does not exist in context\r\n            ":"\r\n            名称不存在于上下文中\r\n            \r\n","\r\n Gets bound node summary of the underlying invocation in a case of RaiseEvent\r\n ":"\r\n 在raiseevent的情况下，获得基础调用的绑定节点摘要\r\n \r\n","\r\n We start with the current submission class and walk the submission chain back to the first submission.\r\n The search has two phases\r\n 1) We are looking for any symbol matching the given name, arity, and options. If we don't find any the search is over.\r\n    If we find an overloadable symbol(s) (a method or a property) we start looking for overloads of this kind \r\n    (lookingForOverloadsOfKind) of symbol in phase 2.\r\n 2) If a visited submission contains a matching member of a kind different from lookingForOverloadsOfKind we stop \r\n    looking further. Otherwise, if we find viable overload(s) we add them into the result. Overloads modifier is ignored.\r\n ":"\r\n 我们从当前提交类开始，然后将提交链带回第一个提交。\r\n 搜索有两个阶段\r\n 1）我们正在寻找与给定名称，arity和选项匹配的任何符号。如果我们找不到任何搜索结束。\r\n    如果我们找到一个可超载的符号（s）（方法或属性），我们将开始寻找此类过载\r\n    （fookforoverloadsofkind）在第2阶段中的符号。\r\n 2）如果访问的提交包含与lookforoverloadsofkind不同的匹配成员，我们会停止\r\n    走得更远。否则，如果我们发现可行的过载，我们将它们添加到结果中。超载修饰符被忽略。\r\n \r\n"," is the containing namespace of ":" 是包含的名称空间\r\n","\r\n DistinctClauseSyntax -       Returns Distinct method associated with DistinctClauseSyntax.\r\n \r\n WhereClauseSyntax -          Returns Where method associated with WhereClauseSyntax.\r\n \r\n PartitionWhileClauseSyntax - Returns TakeWhile/SkipWhile method associated with PartitionWhileClauseSyntax.\r\n \r\n PartitionClauseSyntax -      Returns Take/Skip method associated with PartitionClauseSyntax.\r\n \r\n GroupByClauseSyntax -        Returns GroupBy method associated with GroupByClauseSyntax.\r\n \r\n JoinClauseSyntax -           Returns Join/GroupJoin method associated with JoinClauseSyntax/GroupJoinClauseSyntax.\r\n \r\n SelectClauseSyntax -         Returns Select method associated with SelectClauseSyntax, if needed.\r\n \r\n FromClauseSyntax -           Returns Select method associated with FromClauseSyntax, which has only one \r\n                              CollectionRangeVariableSyntax and is the only query clause within \r\n                              QueryExpressionSyntax. NotNeeded SymbolInfo otherwise. \r\n                              The method call is injected by the compiler to make sure that query is translated to at \r\n                              least one method call. \r\n \r\n LetClauseSyntax -            NotNeeded SymbolInfo.\r\n \r\n OrderByClauseSyntax -        NotNeeded SymbolInfo.\r\n \r\n AggregateClauseSyntax -      Empty SymbolInfo. GetAggregateClauseInfo should be used instead.\r\n ":"\r\n 独特的ClaseyNtax-返回与不同的Clausesyntax关联的不同方法。\r\n \r\n whereclausesyntax-返回与whereclaisesyntax关联的方法。\r\n \r\n partitionwhileclausesyntax-返回与partition whileclausesyntax相关的同时/skipwhile方法。\r\n \r\n partitionClausesyntax-与PartitionClausesyntax关联的返回/跳过方法。\r\n \r\n GroupByClausesyNTAX-返回与GroupByClausesyntax关联的GroupBy方法。\r\n \r\n Joinclausesyntax-返回与joinclausesyntax/groupjoinclausesyntax关联的join/groupjoin方法。\r\n \r\n SelectClausesyntax-返回选择与SelectClausesyntax关联的方法，如果需要。\r\n \r\n 来自Clausesyntax-返回与ClrofClausesyNntax关联的选择方法，只有一个\r\n                              collectionRangeVariablesyntax，是其中唯一的查询子句\r\n                              QueryExpressionsyntax。否则，没有符号。\r\n                              编译器注入了方法调用，以确保查询被翻译成AT\r\n                              至少一个方法调用。\r\n \r\n letclausesyntax-未经符号。\r\n \r\n orderbyClausesyntax-未经符号的符号。\r\n \r\n gentRegateClausesyntax-空符号。应该使用getaggregateclauseinfo。\r\n \r\n","Also after a greater-than sign (>) when you specify an attribute.":"同样，在指定属性时，符号大于符号（>）之后。\r\n","The potential triggering action.":"潜在的触发动作。\r\n","\r\n            The baseline of each updated project is linked to its initial baseline that reads from the on-disk metadata and PDB.\r\n            Therefore once an initial baseline is created it needs to be kept alive till the end of the debugging session,\r\n            even when it's replaced in ":"\r\n            每个更新项目的基线链接到其初始基线，该基线从磁盘元数据和PDB读取。\r\n            因此\r\n            即使被替换为\r\n","\r\n The expression being awaited.\r\n ":"\r\n 表达正在等待。\r\n \r\n","\r\n            True if semantic analysis should fail when any of the invocation expression ancestors of ":"\r\n            如果语义分析在任何调用表达式祖先时都应该失败，则为真实\r\n","\r\n            Will unwrap a block with a single statement in it to just that block.  Used so we can\r\n            support both ":"\r\n            将用其中一个语句拆开一个块，仅限该块。使用了，我们可以\r\n            两者都支持\r\n","\r\n            Performs the same action as ":"\r\n            执行与\r\n","\r\n Returns a copy of this with the InterfaceStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中frofactatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","Avoid unused parameters in your code. If the parameter cannot be removed, then change its name so it starts with an underscore and is optionally followed by an integer, such as '_', '_1', '_2', etc. These are treated as special discard symbol names.":"避免代码中未使用的参数。如果无法删除参数，则更改其名称，以便从下划线开始，然后选择一个整数，例如'_ _'，'_1'，'_2'等。这些被视为特殊的丢弃符号名称。\r\n","\r\n Returns true if this local is a ReadOnly local. Compiler has a concept of ReadOnly locals.\r\n ":"\r\n 如果此本地是可读的本地，则返回true。编译器有一个可读的当地人的概念。\r\n \r\n"," representing the specific kind of\r\n SingleLineLambdaExpressionSyntax. One of SingleLineFunctionLambdaExpression,\r\n SingleLineSubLambdaExpression.\r\n ":" 代表特定种类\r\n SINGLELINELAMBDAEXPRESSYNNTAX。 SinglelineFunctionlambdaexexpression之一\r\n SINGLELINESUBLAMBDAExpression。\r\n \r\n","\r\n Represents a custom modifier (modopt/modreq).\r\n ":"\r\n 代表自定义修饰符（MODOPT/MODREQ）。\r\n \r\n","\r\n            Additional diplayable properties that can be attached to the definition for clients that want to\r\n            display additional data.\r\n            ":"\r\n            可以为想要的客户定义附加的其他可外交属性\r\n            显示其他数据。\r\n            \r\n","\r\n  Looks up a localized string similar to Type constraint cannot be a 'NotInheritable' class..\r\n":"\r\n  查找类似于类型约束的本地化字符串不能是“简直可取的”类。\r\n\r\n","\r\n            Base type of all regex primitives that start with \\\r\n            ":"\r\n            以\\开头的所有正则原语的基本类型\r\n            \r\n","\r\n            wrong number of type args\r\n            ":"\r\n            类型ARG的错误数量\r\n            \r\n","\r\n Represents an #End ExternalSource pre-processing directive appearing in source.\r\n ":"\r\n 代表#End ExternalSource预处理指令出现在源中。\r\n \r\n"," (top-level statement).\r\n ":" （顶级语句）。\r\n \r\n","Program using top-level statements must be an executable.":"使用顶级语句的程序必须是可执行的。\r\n","\r\n Return TypeSubstitution instance that targets particular generic definition.\r\n ":"\r\n 返回类型的实例，该实例针对特定的通用定义。\r\n \r\n","\r\n An identifier declaring a new variable or naming an existing variable to store\r\n the exception caught by the \"Catch\" statement.\r\n ":"\r\n 宣布新变量或命名现有变量以存储的标识符\r\n “捕获”声明捕获的例外。\r\n \r\n","\r\n            foreach statement cannot operate on variables of type 'X' because 'X' does not contain a public instance or extension definition for 'GetEnumerator'\r\n            ":"\r\n            foreach语句无法在“ x”类型的变量上操作，因为'x'不包含“ getEnumerator”的公共实例或扩展定义\r\n            \r\n","\r\n In case the method is an 'Async' method, stores the reference to a state machine type \r\n synthesized in AsyncRewriter. Note, that this field is mutable and is being assigned  \r\n by calling AssignAsyncStateMachineType(...).\r\n ":"\r\n 如果该方法是“异步”方法，请存储对状态机类型的引用\r\n 在异步螺丝蛋白中合成。请注意，该字段是可变的，正在分配\r\n 通过调用分配assyncstatemachinetype（...）。\r\n \r\n","\r\n Bind Nullable (?) type syntax to the correct type symbol.\r\n ":"\r\n 将无效（？）类型语法绑定到正确的类型符号。\r\n \r\n","\r\n Returns the Documentation Comment ID for the symbol, or Nothing if the symbol\r\n doesn't support documentation comments.\r\n ":"\r\n 返回该符号的文档注释ID，或者如果符号\r\n 不支持文档评论。\r\n \r\n","The feature '{0}' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.":"功能'{0}'当前在预览中，并且 *不支持 *。要使用预览功能，请使用“预览”语言版本。\r\n"," symbol is missing,\r\n or any of the members in ":" 符号缺失，\r\n 或任何成员\r\n","The current content of source file '{0}' does not match the built source. Any changes made to this file while debugging won't be applied until its content matches the built source.":"源文件'{0}'的当前内容与构建源不匹配。在调试时对此文件进行的任何更改都不会应用于其内容与构建源匹配。\r\n","end of string or line":"字符串或线的结尾\r\n","\r\n The target (left hand side) of the assignment.\r\n ":"\r\n 分配的目标（左侧）。\r\n \r\n","\r\n The statements contained in the SyncLock...End SyncLock statement. This might\r\n be an empty list.\r\n ":"\r\n Synclock ... End Synclock语句中包含的语句。这有可能\r\n 成为一个空列表。\r\n \r\n","\r\n If the Kind is ExtendKind.Compilation, returns the compilation symbol that this namespace\r\n encompasses. Otherwise throws InvalidOperationException.\r\n ":"\r\n 如果类型是ExtendKind.com，请返回此名称空间的编译符号\r\n 包含。否则会引发无效的exception。\r\n \r\n","The \"d\" custom format specifier represents the day of the month as a number from 1 through 31. A single-digit day is formatted without a leading zero.\r\n            \r\n            If the \"d\" format specifier is used without other custom format specifiers, it's interpreted as the \"d\"  ...":"“ D”自定义格式指定符表示本月的一天为1至31个数字。单位日期的格式化而没有领先的零。\r\n            \r\n            如果使用“ D”格式指定符，而没有其他自定义格式指定符，则将其解释为“ D” ...\r\n","Options used to customize formatting of an Object value.":"用于自定义对象值格式的选项。\r\n","\r\n Returns a copy of this with the ErrorNumber property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而Erronumber属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n"," Marks slot as reported, propagates 'reported' flag to the children if necessary ":" 标记插槽如报告，如有必要，向孩子们传播了“报告”标志\r\n","id for the new document to be added":"添加新文档的ID\r\n","\r\n This method does not filter diagnostics based on compiler options like /nowarn, /warnaserror etc.\r\n ":"\r\n 此方法不会基于 /nowarn， /warnaserror等的编译器选项过滤诊断。\r\n \r\n","\r\n            If a separate PDB stream is not available (":"\r\n            如果没有单独的PDB流（\r\n","\r\n            A mapping containing the simple names and arity of all imported types, mapped to the import that they're\r\n            brought in by.\r\n            ":"\r\n            包含所有导入类型的简单名称和敏锐的映射，映射到它们的导入\r\n            带来。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Exit Try' can only appear inside a 'Try' statement..\r\n":"查找类似于“退出尝试”的本地化字符串只能出现在“尝试”语句中。\r\n\r\n","\r\n The value for the EndWhileStatement property.\r\n ":"\r\n 最终属性属性的值。\r\n \r\n","\r\n Set the correct metadata name for all overloads of a particular name and symbol kind\r\n (must be method or property) inside a container.\r\n \r\n The rules are as follows:\r\n    1) If a method or property overrides one from its base class, its metadata name\r\n       must match that.\r\n    2) If method overloads those in the base (because the Overloads keyword is used), and\r\n       all metadata names in the base are consistent in case, use that name.\r\n    3) All overloads with a class should match, except possibly for overrides. If there is\r\n       an override or overload from base, use that. Otherwise, use casing of first member in\r\n       class.\r\n ":"\r\n 为特定名称和符号类型的所有超载设置正确的元数据名称\r\n （必须是方法或属性）在容器内。\r\n \r\n 规则如下：\r\n    1）如果方法或属性从其基类覆盖了一个，则其元数据名称\r\n       必须匹配。\r\n    2）如果方法过载基数中的那些（因为使用了过载关键字），并且\r\n       如果使用该名称，则基础中的所有元数据名称都是一致的。\r\n    3）除了覆盖外，所有的超载都应匹配。如果有\r\n       基地的覆盖或超载，使用它。否则，请在\r\n       班级。\r\n \r\n","\r\n Gets the attribute class being applied as an ":"\r\n 将属性类应用于\r\n","\r\n  Looks up a localized string similar to Interface '{0}' is not implemented by this class..\r\n":"\r\n  查找类似于接口'{0}'的本地化字符串。\r\n\r\n","\r\n  Looks up a localized string similar to Conversion operators cannot convert from a base type..\r\n":"\r\n  查找类似于转换操作员的本地化字符串无法从基本类型转换。\r\n\r\n","\r\n Given a identifier and as clause syntax, return the actual type to use. Uses the type character or the type syntax.\r\n ":"\r\n 给定标识符和作为子句语法，返回实际类型要使用。使用类型字符或类型语法。\r\n \r\n","All uppercase":"所有大写\r\n","\r\n Lookup a typeSyntax, confining the lookup to namespaces or types. Returns a LookupResult\r\n that summarizes the results of the lookup, which might contain a Diagnostic associated with the lookup.\r\n However, other diagnostics associated with parts of the binding process (i.e., binding type arguments) \r\n will be emitted via the diagnostic bag.\r\n \r\n The LookupResult will always have at most one symbol in it, since types and namespaces are not overloadable symbols.\r\n ":"\r\n 查找型号，将查找限制在名称空间或类型上。返回查找\r\n 这总结了查找的结果，该结果可能包含与查找相关的诊断。\r\n 但是，与绑定过程的一部分相关的其他诊断（即绑定类型参数）\r\n 将通过诊断袋发射。\r\n \r\n 由于类型和名称空间不是可超载的符号，因此LookupResult最多将始终具有一个符号。\r\n \r\n","Modifying a method inside the context of a generic type requires restarting the application.":"在通用类型的上下文中修改方法需要重新启动应用程序。\r\n","\r\n Represents an event.\r\n ":"\r\n 代表事件。\r\n \r\n","\r\n            Input:\r\n            foreach(...)\r\n            {\r\n                ...\r\n                ...\r\n                counter++;\r\n             }\r\n             \r\n             Output:\r\n             counter += queryGenerated.Count();\r\n        ":"\r\n            输入：\r\n            foreach（...）\r\n            {\r\n                ...\r\n                ...\r\n                计数器++;\r\n             }\r\n             \r\n             输出：\r\n             counter += queryGenerated.count（）;\r\n        \r\n","\r\n  Looks up a localized string similar to Member '{0}' that matches this signature cannot be overridden because the class '{1}' contains multiple members with this same name and signature: {2}.\r\n":"\r\n  查找类似于成员'{0}'的本地化字符串，它与此签名匹配，因为类'{1}'包含具有相同名称和签名的多个成员：{2}。\r\n\r\n","\r\n §11.12.2 Object Operands\r\n The value Nothing is treated as the default value of the type of \r\n the other operand in a binary operator expression. In a unary operator expression, \r\n or if both operands are Nothing in a binary operator expression, \r\n the type of the operation is Integer or the only result type of the operator, \r\n if the operator does not result in Integer.\r\n ":"\r\n §11.12.2对象操作数\r\n 该值没有将其视为类型的默认值\r\n 另一个操作数在二进制操作员表达式中。在单一操作员的表达中，\r\n 或者，如果两个操作数在二进制运算符表达式中都不是\r\n 操作的类型是整数或操作员的唯一结果类型，\r\n 如果操作员不会导致整数。\r\n \r\n","\r\n For performance reason we may not want to check if synthetic gotos are legal.\r\n Those are the majority, but should not be ever illegal (how user would fix them?).\r\n ":"\r\n 出于绩效原因，我们可能不想检查合成GOTO是否合法。\r\n 这些是多数人，但不应该是非法的（用户将如何修复它们？）。\r\n \r\n","\r\n The expression denoting the value being thrown.\r\n ":"\r\n 表示所抛出的值的表达式。\r\n \r\n","\r\n Holds all information needed to rewrite a bound using block node.\r\n ":"\r\n 保留使用块节点重写绑定所需的所有信息。\r\n \r\n","\r\n            Flag to indicate if the code fix can introduce local declaration statements\r\n            that need to be moved closer to the first reference of the declared variable.\r\n            This is currently only possible for the unused value assignment fix.\r\n            ":"\r\n            标志以指示代码修复是否可以引入本地声明语句\r\n            需要将其移至更接近声明变量的第一个引用。\r\n            目前仅用于未使用的值分配修复。\r\n            \r\n","\r\n The value for the NameColonEquals property.\r\n ":"\r\n Namecolonequals属性的值。\r\n \r\n","\r\n Returns a copy of this with the Left property changed to the specified value.\r\n Returns this instance if the specified value is the same as the current value.\r\n ":"\r\n 返回此的副本，左属性更改为指定值。\r\n 如果指定值与当前值相同，则返回此实例。\r\n \r\n","\r\n Represents a local and its Def-Use-Use chain\r\n \r\n NOTE: stack local reads are destructive to the locals so \r\n if the read is not last one, it must be immediately followed by another definition. \r\n For the rewriting purposes it is irrelevant if definition was created by a write or \r\n a subsequent read. These cases are not ambiguous because when rewriting, definition \r\n will match to a single node and  we always know if given node is reading or writing.\r\n ":"\r\n 代表本地及其链条链\r\n \r\n 注意：堆栈本地阅读对当地人来说是破坏性的\r\n 如果读取不是最后一个，则必须立即遵循另一个定义。\r\n 为了重写目的，如果写作或\r\n 随后的阅读。这些情况不含糊不清，因为在重写时，定义\r\n 将与单个节点匹配，我们始终知道给定节点是读数还是写作。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' is ambiguous because multiple kinds of members with this name exist in {1} '{2}'..\r\n":"\r\n  查找类似于'{0}'的本地化字符串是模棱两可的，因为{1}'{2}'..中存在多种具有此名称的成员。\r\n\r\n","\r\n The \"New\" keyword in the constructor declaration.\r\n ":"\r\n 构造函数声明中的“新”关键字。\r\n \r\n","\r\n  Looks up a localized string similar to Name of field or property being initialized in an object initializer must start with '.'..\r\n":"\r\n  查找类似于在对象初始化器中初始化的字段或属性名称的本地化字符串必须以'。\r\n\r\n","\r\n            Indicate whether this member needs to be changed to non-static so it won't cause error after it is pulled up to destination.\r\n            ":"\r\n            指示该成员是否需要更改为非静态，因此将其拉到目的地后不会导致错误。\r\n            \r\n","The type, as modified by the type character, type modifiers. Uses Object as default if needed.":"该类型，按类型字符修改，类型修饰符。如果需要，将对象用作默认值。\r\n","\r\n Used to resolve exit statements in each statement form that has an Exit statement\r\n (loops, switch).\r\n ":"\r\n 用于在具有退出语句的每个语句中解析出口语句\r\n （循环，开关）。\r\n \r\n","\r\n            Document contains changes.\r\n            ":"\r\n            文档包含更改。\r\n            \r\n","\r\n  Looks up a localized string similar to '{0}' is an event, and cannot be called directly. Use a 'RaiseEvent' statement to raise an event..\r\n":"\r\n  查找类似于“ {0}”的本地化字符串是一个事件，无法直接调用。使用“ raiseevent”声明提出活动。\r\n\r\n","\r\n Compare two lexical sort keys in a compilation.\r\n ":"\r\n 比较汇编中的两个词汇排序键。\r\n \r\n","\r\n The \"Do\" keyword.\r\n ":"\r\n “做”关键字。\r\n \r\n","\r\n The value being assigned.\r\n ":"\r\n 分配的值。\r\n \r\n"," representing the specific kind of\r\n AccessorStatementSyntax. One of GetAccessorStatement, SetAccessorStatement,\r\n AddHandlerAccessorStatement, RemoveHandlerAccessorStatement,\r\n RaiseEventAccessorStatement.\r\n ":" 代表特定种类\r\n consectorStatementsyntax。 getAccessorStatement，setAccessorStatement，\r\n AddhandlerAccessorStatement，Remove HandlerAccessorStatement，\r\n raiseeventAccessorStatement。\r\n \r\n","\r\n The \"Finally\" statement that begins the \"Finally\" block.\r\n ":"\r\n 开始“最后”块的“最后”语句。\r\n \r\n","\r\n Returns what symbol(s), if any, the given cref reference syntax bound to in the documentation comment.\r\n \r\n An AliasSymbol will never be returned by this method. What the alias refers to will be\r\n returned instead.\r\n ":"\r\n 返回文档注释中绑定到的给定CREF参考语法的符号（如果有）。\r\n \r\n 这种方法将永远不会返回别名鲍尔。别名是什么\r\n 而是返回。\r\n \r\n","Introduce constant for '{0}'":"引入'{0}'的常数\r\n","\r\n If this variable serves as a backing variable for an automatically generated\r\n property or event, returns that property or event. \r\n Otherwise returns Nothing.\r\n Note, the set of possible associated symbols might be expanded in the future to \r\n reflect changes in the languages.\r\n ":"\r\n 如果此变量用作自动生成的后台变量\r\n 属性或事件，返回该属性或事件。\r\n 否则什么都不会返回。\r\n 注意，将来可能会扩展一组可能的相关符号\r\n 反映语言的变化。\r\n \r\n","\r\n  Looks up a localized string similar to '{0}' cannot be made nullable..\r\n":"\r\n  查找类似于'{0}'的本地化字符串，无法使其无效。\r\n\r\n","\r\n Raw assembly version as specified in the AssemblyVersionAttribute, or Nothing if none specified.\r\n If the string passed to AssemblyVersionAttribute contains * the version build and/or revision numbers are set to ":"\r\n 原始汇编版本如“汇编”中指定，或者没有指定。\r\n 如果字符串传递给assemblyVersionAttribute *\r\n","\r\n The value for the Version property.\r\n ":"\r\n 版本属性的值。\r\n \r\n","\r\n Initializes a new instance of the ":"\r\n 初始化一个新实例\r\n","Assign a slot for a regular variable in a given state.":"在给定状态下为常规变量分配插槽。\r\n","matched subexpression":"匹配的子表达\r\n","\r\n Return why the candidate symbols were bad.\r\n ":"\r\n 返回为什么候选符号不好。\r\n \r\n","\r\n            Root of all the primary nodes (similar to unary nodes in C#).\r\n            ":"所有主要节点的根（类似于C＃中的单元节点）。\r\n            \r\n","Implement remaining members explicitly":"明确实施其余成员\r\n"," isn't lambda representing node (the first range variable of a clause)\r\n but its equivalent peer (another range variable of the same clause).\r\n ":" 不是代表节点的lambda（子句的第一个范围变量）\r\n 但是它的等效对等（同一子句的另一个范围变量）。\r\n \r\n","\r\n            Represents a ```[:...:]``` node in a character class.  Note: the .NET regex parser\r\n            simply treats this as the character ```[``` and ignores the rest of the ```:...:]```.\r\n            They latter part has no impact on the actual match engine that is produced.\r\n            ":"\r\n            表示字符类中的节点``````[：...：]。注意：.NET REGEX解析器\r\n            只需将其视为角色``[````````````''''''：...：]\r\n            后者对实际生产的实际匹配引擎没有影响。\r\n            \r\n","\r\n We're going through the containing module, rather than the containing assembly,\r\n because of /addmodule (symbols in such modules should return null).\r\n \r\n Remarks, not \"ContainingCompilation\" because it isn't transitive.\r\n ":"\r\n 我们正在通过包含的模块，而不是包含的组件，\r\n 由于 /addModule（此类模块中的符号应返回null）。\r\n \r\n 备注，而不是“包含综合”，因为它不是传递的。\r\n \r\n","\r\n  Looks up a localized string similar to Structure in an interface cannot be declared '{0}'..\r\n":"\r\n  查找类似于接口中结构的本地化字符串，无法声明“ {0}”。\r\n\r\n","A syntax node that represents a parsed expression. This syntax\r\n node need not and typically does not appear in the source code referred to by the\r\n SemanticModel instance.":"表示解析表达式的语法节点。这个语法\r\n 节点无需，通常不会出现在该源代码中\r\n Semanticmodel实例。\r\n","\r\n Indicates whether event created a new delegate type.\r\n In such case the Type must be added to the members of the containing type\r\n ":"指示事件是否创建了新的委托类型。\r\n 在这种情况下，必须将类型添加到包含类型的成员\r\n \r\n","\r\n            Signifies that the lower-bound of a range pattern\r\n            ":"\r\n            表示范围模式的下限\r\n            \r\n","Introduce constant":"引入常数\r\n"," and must return the provided ":" 并且必须退还提供的\r\n","\r\n Lookup a top level type referenced from metadata, names should be\r\n compared case-sensitively.\r\n ":"\r\n 查找从元数据引用的顶级类型，名称应为\r\n 比较病例敏感。\r\n \r\n","\r\n Information decoded from early well-known custom attributes applied on a method.\r\n ":"\r\n 从应用在方法上的早期众所周知的自定义属性解码的信息。\r\n \r\n","stackalloc initializer":"Stackalloc初始化器\r\n","\r\n Returns a copy of this with the IdentifierName property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，并更改​​为标识名称属性\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Initially binding using blocks.\r\n A Using statement names a resource that is supposed to be disposed on completion.\r\n The resource can be an expression or a list of local variables with initializers.\r\n the type of the resource must implement System.IDispose\r\n A using statement of the form:\r\n      using Expression\r\n          list_of_statements\r\n      end using\r\n\r\n when the resource is a using locally declared variable no temporary is generated but the variable is read-only\r\n A using statement of the form:\r\n      using v as new myDispose\r\n          list_of_statements\r\n      end using\r\n It is also possible to use multiple variable resources:\r\n      using v1 as new myDispose, v2 as myDispose = new myDispose()\r\n          list_of_statements\r\n      end using\r\n":"\r\n 最初使用块绑定。\r\n 使用语句名称一个应该在完成后处置的资源。\r\n 资源可以是带有初始化器的局部变量的表达式或列表。\r\n 资源的类型必须实现系统。\r\n 表格的使用语句：\r\n      使用表达式\r\n          list_of_statement\r\n      结束使用\r\n\r\n 当资源是使用本地声明的变量时，不会生成临时性，但该变量仅读取\r\n 表格的使用语句：\r\n      使用V作为新的mydispose\r\n          list_of_statement\r\n      结束使用\r\n 也可以使用多个变量资源：\r\n      使用v1作为新的mydispose，v2作为mydispose = new mydispose（）\r\n          list_of_statement\r\n      结束使用\r\n\r\n","\r\n  Looks up a localized string similar to Attribute parameter '{0}' must be specified..\r\n":"\r\n  必须指定类似于属性参数'{0}'的本地化字符串。\r\n\r\n","\r\n            Produces the actual top-level code wrapping actions for the original node provided.\r\n            ":"\r\n            为提供的原始节点生成实际的顶级代码包装操作。\r\n            \r\n","\r\n Does this symbol represent a missing Module.\r\n ":"\r\n 此符号是否代表缺失的模块。\r\n \r\n","\r\n A tuple of TypeParameterSymbol and DiagnosticInfo, created for errors\r\n reported from ConstraintsHelper rather than creating Diagnostics directly.\r\n This decouples constraints checking from syntax and Locations, and supports\r\n callers that may want to create Location instances lazily or not at all.\r\n ":"\r\n TypeParameterSymbol和DiagnosticInfo的元组，为错误创建\r\n 从ConstraintsHelper报告，而不是直接创建诊断。\r\n 这将约束检查与语法和位置分离，并支持\r\n 可能想要懒惰地或根本不创建位置实例的调用者。\r\n \r\n","\r\n            The indent trivia to insert if we are trying to align wrapped code with the \r\n            start of the original expression.\r\n            ":"\r\n            如果我们试图将包装代码与\r\n            原始表达式的开始。\r\n            \r\n","\r\n The value for the Constraint property.\r\n ":"\r\n 约束属性的值。\r\n \r\n","\r\n Return all of the type arguments in this type and enclosing types,\r\n from outer-most to inner-most type.\r\n ":"\r\n 返回此类型中的所有类型参数，并封闭类型，\r\n 从最外部到最内部类型。\r\n \r\n","\r\n Returns true if this symbol was declared as requiring an override; i.e., declared\r\n with the \"MustOverride\" modifier. Never returns true for types. \r\n Also methods, properties and events declared in interface are considered to have MustOverride.\r\n ":"\r\n 如果该符号被宣布为替代，则返回为真；即，宣布\r\n 带有“ Mustoverride”修饰符。类型永远不会返回。\r\n 接口中声明的方法，属性和事件也被认为具有Mustoverride。\r\n \r\n"," both return true. However, for an unconstrained\r\n type parameter, ":" 两者都返回true。但是，对于不受限制的\r\n 类型参数，\r\n","Type that contains wrapper method.":"包含包装法的类型。\r\n","No available location found to add statements to.":"找不到可将语句添加到的可用位置。\r\n","\r\n Returns a copy of this with the EndWhileStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，而EndWhilStatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            ```expr?```\r\n            ":"\r\n            ``Expr？'''\r\n            \r\n","\r\n The base class for all symbols (namespaces, classes, method, parameters, etc.) that are \r\n exposed by the compiler.\r\n ":"\r\n 所有符号（名称空间，类，方法，参数等）的基类是\r\n 由编译器暴露。\r\n \r\n","\r\n Construct context from model and region\r\n \r\n 'boundNode' defines a bound sub-tree to be analyzed and is being used in \r\n both region-based and not region based analysis processes. \r\n \r\n The last three parameters define a region. In most cases firstInRegion and lastInRegion \r\n are being used for identifying when we should enter or leave the region. \r\n \r\n Text span is also being passed to define the region which is used in few places. Those \r\n places can be rewritten to use first/last bound nodes, but simple [region.Contains(...)] \r\n check simplifies the code significantly. (Note, C# implementation uses the same logic, \r\n but calculates the region's text span based on first/last node; in VB to perform such \r\n calculation would have to traverse bound subtree under first/last nodes to detect \r\n region boundaries; we avoid this additional cost by passing the original text span as \r\n a separate parameter because we do have it anyways)\r\n ":"\r\n 从模型和区域构建上下文\r\n \r\n “界点”定义了要分析的绑定子树，并正在使用\r\n 两者都是基于区域的和不是基于区域的分析过程。\r\n \r\n 最后三个参数定义了一个区域。在大多数情况下，第一区和最后一个区域\r\n 用于识别我们何时应该进入或离开该地区。\r\n \r\n 文本跨度也被传递以定义在几个地方使用的区域。那些\r\n 可以重写的位置以使用第一个/最后一个绑定的节点，但是简单[region.Contains（...）]\r\n 检查显着简化了代码。 （注意，C＃实现使用相同的逻辑，\r\n 但是，基于第一个/最后一个节点来计算区域的文本跨度；在VB中执行此类\r\n 计算必须在第一个/最后一个节点下遍历绑定的子树才能检测\r\n 区域边界；我们通过将原始文本跨度作为\r\n 一个单独的参数，因为我们确实有）\r\n \r\n","\r\n Ensures that lookup eagerly looks for extension methods and merges them with \r\n instance methods, if any. \r\n \r\n If this flag is not set and lookup found viable instance method, it will not look \r\n for extension methods that might be in scope. \r\n \r\n It is not an error to combine this flag with LookupOptions.IgnoreExtensionMethods, \r\n the LookupOptions.IgnoreExtensionMethods takes precedence. \r\n ":"\r\n 确保查找急切地寻找扩展方法并将其合并\r\n 实例方法（如果有）。\r\n \r\n 如果未设置此标志并找到可行的实例方法，则不会查看\r\n 对于可能处于范围的扩展方法。\r\n \r\n 将此标志与lookupoptions.ignoreextensionmethods相结合不是错误\r\n LookupOptions.ignoreextensionMethods优先。\r\n \r\n","\r\n Base class for the possible kinds of arguments that can appear in an argument\r\n list.\r\n ":"\r\n 基础类别可能出现在参数中的可能的参数\r\n 列表。\r\n \r\n","\r\n Is there any content in the methods collection.\r\n ":"\r\n 方法集合中是否有任何内容。\r\n \r\n","\r\n A list of statements to be executed if the condition expression evaluates as\r\n true.\r\n ":"\r\n 如果条件表达式评估为\r\n 真的。\r\n \r\n","\r\n            True if the extract method operation succeeded.\r\n            ":"\r\n            如果提取方法操作成功，则为正确。\r\n            \r\n","\r\n Symbol for the canonical type or an ErrorTypeSymbol. Never returns null.\r\n ":"\r\n 规范类型或错误型符号的符号。永远不会返回零。\r\n \r\n","\r\n Makes a snapshot of the current set of referenced symbols filtered by, \r\n the set of symbols provided; may be called before the referenced symbol \r\n collection is sealed.\r\n ":"\r\n 制作当前一组引用的符号集的快照，\r\n 提供的符号集；可以在引用符号之前调用\r\n 收集是密封的。\r\n \r\n","\r\n Mutate 'self' flow analysis state to reflect the fact that there is a control-flow\r\n sequence with the 'other' flow analysis state - in other words, this occurs and then\r\n the other.\r\n ":"突变“自我”流分析状态以反映有控制流的事实\r\n 使用“其他”流分析状态的序列 - 换句话说，这是发生的，然后发生\r\n 另一个。\r\n \r\n","The range variable syntax that declares a variable.":"声明变量的范围变量语法。\r\n","\r\n Information decoded from well-known custom attributes applied on a method.\r\n ":"\r\n 从方法上应用的众所周知的自定义属性解码的信息。\r\n \r\n","Declare as nullable":"声明为无效\r\n","\r\n Returns a copy of this with the ArrayRankSpecifiers property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回使用ArrayrankSpecifiers属性的副本更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Operator kind and expected number of parameters.\r\n ":"\r\n 运算符和预期的参数数。\r\n \r\n","\r\n Checks if the resulting Cref or Name attribute value has valid trivia\r\n Note, this may be applicable not only to regular trivia, but also to syntax \r\n nodes added to trivia when the parser was recovering from errors\r\n ":"\r\n 检查生成的CREF或名称属性值是否具有有效的琐事\r\n 请注意，这不仅适用于常规琐事，还适用于语法\r\n 解析器从错误中恢复时添加到琐事中的节点\r\n \r\n","\r\n Source types may have dependencies via inheritance or containment\r\n The diagnostics is different in those cases.\r\n ":"\r\n 源类型可能具有通过继承或包含的依赖关系\r\n 在这些情况下，诊断是不同的。\r\n \r\n","\r\n            An optional set of additional locations related to the diagnostic.\r\n            Typically, these are locations of other items referenced in the message.\r\n            These locations are joined with ":"\r\n            一组与诊断有关的其他位置。\r\n            通常，这些是消息中引用的其他项目的位置。\r\n            这些位置与\r\n"," parameter contains value corresponding to the \r\n ":" 参数包含对应于\r\n \r\n","\r\n Returns a copy of this with the LessThanPercentEqualsToken property changed to\r\n the specified value. Returns this instance if the specified value is the same\r\n as the current value.\r\n ":"\r\n 返回其中的副本，而LessThanperCentEqualStoken属性更改为\r\n 指定值。如果指定的值相同，则返回此实例\r\n 作为当前值。\r\n \r\n","Lambda expression which is represented by this method.":"由该方法表示的lambda表达。\r\n","Convert to conditional expression":"转换为条件表达\r\n","\r\n  Looks up a localized string similar to 'Custom' modifier is not valid on events declared without explicit delegate types..\r\n":"\r\n  查找类似于“自定义”修饰符的本地化字符串在没有明确委托类型的情况下声明的事件无效。\r\n\r\n","\r\n            The documentation comment text to replace the span with\r\n            ":"\r\n            文档评论文本以替换跨度\r\n            \r\n","\r\n Given base being resolved chain and current type produce the diagnostics \r\n or Nothing if there is no cycle detected\r\n ":"\r\n 给定的基被解析链和当前类型产生诊断 \r\n 如果没有检测到循环，则什么也没有\r\n \r\n","\r\n            A optional highlighter that can highlight spans for an embedded language string.\r\n            ":"\r\n            可以突出显示嵌入式语言字符串的可选荧光笔。\r\n            \r\n","A boolean value set to True if character can be part of a valid identifier.":"如果字符可以成为有效标识符的一部分，则将布尔值设置为true。\r\n","The \"t\" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.ShortTimePattern property. For example, the custom format string for the invariant culture is \"HH:mm\".":"“ T”标准格式指定符表示由当前DateTimeFormatInfo.shortTimePattern属性定义的自定义日期和时间格式字符串。例如，不变文化的自定义格式字符串是“ HH：MM”。\r\n","\r\n This binder keeps track of the set of parameters that are currently being evaluated\r\n so that the set can be passed into the next call to ParameterSymbol.DefaultConstantValue (and\r\n its callers).\r\n ":"\r\n 此活页夹跟踪当前正在评估的参数集\r\n 因此，该集合可以传递到parametersymbol.defaultconstantvalue的下一个调用中（和\r\n 它的呼叫者）。\r\n \r\n","\r\n The comma-separated list of field initializers.\r\n ":"\r\n 逗号分隔的字段初始化列表。\r\n \r\n",". name (arglist)":"。名称（arglist）\r\n","\r\n            True if the diagnostics produced by the session should be reported to the diagnotic analyzer.\r\n            ":"\r\n            如果会话产生的诊断应报告给诊断分析仪，则是事实。\r\n            \r\n","\r\n  Looks up a localized string similar to Character '{0}' ({1}) is not allowed at the beginning of an XML name..\r\n":"\r\n  在XML名称的开头中不允许查找类似于字符'{0}'（{1}）的局部字符串。\r\n\r\n"," will aggregate all these\r\n            individual providers and expose them as one single completion provider to\r\n            the rest of Roslyn.\r\n            ":" 将汇总所有这些\r\n            个人提供者并将其公开为一个完成提供者\r\n            罗斯林的其余部分。\r\n            \r\n","\r\n            Additional properties for the reference.\r\n            For example, { \"ContainingTypeInfo\" } = { \"MyClass\" }\r\n            ":"\r\n            参考的其他属性。\r\n            例如，{“ contingTypeinfo”} = {“ myclass”}\r\n            \r\n","\r\n            Check whether the invocation expression with new arguments is applicable.\r\n            ":"\r\n            检查带有新参数的调用表达式是否适用。\r\n            \r\n","\r\n Creates the syntax representation of a paramref element within xml documentation comments (e.g. for\r\n referencing particular parameters of a method).\r\n ":"\r\n 在XML文档注释中创建参数元素的语法表示（例如\r\n 引用方法的特定参数）。\r\n \r\n","The unicode character":"Unicode字符\r\n","constraints for override and explicit interface implementation methods":"覆盖和显式接口实现方法的约束\r\n","\r\n Intersect bit arrays taking into account 'all bits set' flag\r\n ":"\r\n 相交的位阵列考虑了“所有位设置”标志\r\n \r\n","\r\n            This can be expensive since it is force analyzing diagnostics if it doesn't have up-to-date one yet. If\r\n            ":"\r\n            这可能很昂贵，因为如果诊断还没有最新的诊断，则可以分析诊断。如果\r\n            \r\n","\r\n The \"End\" keyword.\r\n ":"\r\n “结束”关键字。\r\n \r\n","Variable declaration can be deconstructed":"可变声明可以解构\r\n","A GlobalImport instance. ":"一个全球IMPORT实例。\r\n","Containing method declaration.":"包含方法声明。\r\n","The CallerArgumentExpressionAttribute is applied with an invalid parameter name.":"使用无效的参数名称应用CallerArgumentExpressexAttribute。\r\n","\r\n            Distance is a number within [0, 1], the smaller the more similar the nodes are. \r\n            ":"\r\n            距离是[0，1]中的数字，节点越小。\r\n            \r\n","\r\n A list of array modifiers for the type. If no array modifiers were present, an\r\n empty list is returned.\r\n ":"\r\n 该类型的数组修饰符列表。如果没有阵列修饰符，则\r\n 返回空列表。\r\n \r\n","Set if some prefix matches a forwarded type.":"设置一些前缀匹配转发类型。\r\n","Optional architecture filter.":"可选的体系结构过滤器。\r\n","\r\n Determine if \"sym\" is accessible from the location represented by this binder. For protected\r\n access, use the qualifier type \"accessThroughType\" if not Nothing (if Nothing just check protected\r\n access with no qualifier).\r\n ":"\r\n 确定是否可以从该粘合剂代表的位置访问“ SYM”。用于保护\r\n 访问，使用预选赛类型“ AccessThroughType”（如果没有）（如果没有什么话，请检查受保护\r\n 访问没有预选赛）。\r\n \r\n","\r\n  Looks up a localized string similar to Elements cannot be null..\r\n":"\r\n  查找类似于元素的本地化字符串不能为空。\r\n\r\n","\r\n Represents a Select Case block, including the Select Case that begins it, the\r\n contains Case blocks and the End Select.\r\n ":"\r\n 代表一个选择的案例块，包括开始它的选择案例，\r\n 包含案例块，然后选择结束。\r\n \r\n","\r\n Creates an empty list of tokens.\r\n ":"\r\n 创建一个空的令牌列表。\r\n \r\n","\r\n  Looks up a localized string similar to Type in a Module cannot be declared '{0}'..\r\n":"\r\n  查找类似于模块中类型的本地化字符串，无法声明“ {0}”。\r\n\r\n","The left value.":"左值。\r\n","\r\n The initial dot \".\" part of the separator.\r\n ":"\r\n 初始点“。”。分离器的一部分。\r\n \r\n","\r\n            Tokens covering all possible breakpoint spans associated with the member, \r\n            or null if the specified node doesn't represent a member declaration or \r\n            doesn't have a body that can contain active statements.\r\n            ":"\r\n            涵盖与成员相关的所有可能的断点跨度的令牌，\r\n            或null如果指定的节点不代表成员声明或\r\n            没有可以包含活动语句的身体。\r\n            \r\n","Implement all members explicitly":"明确实施所有成员\r\n","Move contents to namespace...":"将目录移至名称空间...\r\n","\r\n  Looks up a localized string similar to Character sequence '--' is not allowed in an XML comment..\r\n":"\r\n  在XML评论中不允许查找类似于字符序列' - '的本地化字符串。\r\n\r\n","\r\n Type parameters in documentation comments are complicated since they sort of act as declarations,\r\n rather than references. Like in the following example:\r\n \r\n     ":"\r\n 文档注释中的类型参数很复杂，因为它们是声明的作用，\r\n 而不是参考。如下以下示例：\r\n \r\n     \r\n","parameterless struct constructors":"无参数结构构造函数\r\n","\r\n            The item to select by default.  If this is ":"\r\n            默认情况下选择的项目。如果是\r\n"," if called outside of an edit session, or active statements for the document can't be determined for some reason\r\n            (e.g. the document has syntax errors or is out-of-sync).\r\n            ":" 如果在编辑会话外召集，则无法确定文档的活动语句\r\n            （例如，该文档具有语法错误或不同步）。\r\n            \r\n","\r\n Represents a parameter that has undergone type substitution.\r\n ":"\r\n 代表经历类型替代的参数。\r\n \r\n"," node's syntax tree.":"节点的语法树。\r\n","\r\n Defines a XML namespace for XML expressions.\r\n ":"\r\n 为XML表达式定义XML名称空间。\r\n \r\n","A node representing a declaration or a top-level edit node.":"表示声明或顶级编辑节点的节点。\r\n","Attribute '{0}' is not valid on event accessors. It is only valid on '{1}' declarations.":"属性'{0}'在事件访问器上无效。它仅在“ {1}”声明上有效。\r\n","The \"R\" or \"r\" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.RFC1123Pattern property. The pattern reflects a defined standard, and the property is read-only. Therefore, it is always the  ...":"“ R”或“ R”标准格式指定符表示由DateTimeFormatInfo.RFC1123Pattern属性定义的自定义日期和时间格式字符串。该模式反映了定义的标准，并且该属性仅读取。因此，永远是...\r\n","\r\n  Looks up a localized string similar to Attribute '{0}' cannot be applied to '{1}' of '{2}' because the attribute is not valid on this declaration type..\r\n":"\r\n  查找类似于属性'{0}'的本地化字符串不能应用于'{2}'的'{1}'，因为该属性在此声明类型上无效。\r\n\r\n","\r\n The value of the string, after removing the quotation marks and combining\r\n doubled quotation marks.\r\n ":"\r\n 删除引号并组合后，字符串的值\r\n 引号加倍。\r\n \r\n","\r\n  Looks up a localized string similar to 'Join' expected..\r\n":"\r\n  查找类似于“加入”预期的本地化字符串。\r\n\r\n","\r\n This is ONLY used for debugging purpose\r\n ":"\r\n 这仅用于调试目的\r\n \r\n","\r\n The name used to emit definition of the type. Will be set when the type's \r\n metadata is ready to be emitted, Name property will throw exception if this field \r\n is queried before that moment because the name is not defined yet.\r\n ":"\r\n 用于发射类型定义的名称。将在类型时设置\r\n 元数据已经准备好发射，如果此字段\r\n 在那一刻之前被查询，因为尚未定义名称。\r\n \r\n","\r\n            The definition this reference corresponds to.\r\n            ":"\r\n            该引用对应的定义与。\r\n            \r\n","\r\n            The actual text to be displayed.\r\n            ":"\r\n            要显示的实际文本。\r\n            \r\n","\r\n Scan VB tokens\r\n ":"\r\n 扫描VB令牌\r\n \r\n","and pattern":"和模式\r\n","\r\n The value for the ConstraintKeyword property.\r\n ":"约束键属性的值。\r\n \r\n","\r\n The value for the Declaration property.\r\n ":"\r\n 声明属性的值。\r\n \r\n","\r\n If nothing is present, an empty list is returned.\r\n ":"如果什么都没有，则返回一个空列表。\r\n \r\n","\r\n  Looks up a localized string similar to Constraint type '{0}' already specified for this type parameter..\r\n":"\r\n  查找类似于该类型参数的约束类型的局部字符串。\r\n\r\n","Analyzer that looks for several variants of code like ":"分析仪查找几种代码变体的分析仪\r\n","\r\n The underlying ":"\r\n 基础\r\n","Explicit implementation of a user-defined operator '{0}' must be declared static":"必须声明静态的用户定义运算符的明确实现'{0}\r\n","Matches a new-line character, \\u000A":"匹配新线角色\\ u000a\r\n","Cannot use '{0}' as a {1} type on a method attributed with 'UnmanagedCallersOnly'.":"不能将'{0}'用作{1}键入'unmanagedCallersonly'的方法。\r\n","Not enough )'s":"还不够）\r\n","\r\n Bind the constraint declarations for the given type parameter.\r\n ":"\r\n 绑定给定类型参数的约束声明。\r\n \r\n","\r\n The End Select statement that ends the block.\r\n ":"\r\n 结束块的最终选择语句。\r\n \r\n","The argument need to be cast.":"该论点需要进行。\r\n","\r\n            Recomputes span segments so that all text lines appear to have the same reduction in indentation.\r\n            This operation is typically used to align text for display when the initial span does not include all of the first line's identation.\r\n            This operation will potentially split spans that cover multiple lines into separate spans.\r\n            ":"\r\n            重新计算跨度段，因此所有文本线似乎都具有相同的缩进缩减。\r\n            当初始跨度不包括所有第一行的标识时，此操作通常用于对齐文本以显示显示。\r\n            该操作将有可能拆分跨度，这些跨度覆盖多条线，分为单独的跨度。\r\n            \r\n","\r\n            Invalid required attribute character '{0}' in required attribute '{1}'. Separate required attributes with commas.\r\n            ":"\r\n            必需的属性字符'{0}'在必需属性'{1}'中。带有逗号的单独所需属性。\r\n            \r\n","Remove unused parameter '{0}'":"删除未使用的参数'{0}'\r\n","\r\n Represents an XML Document literal expression.\r\n ":"\r\n 代表XML文档的文字表达式。\r\n \r\n","The language services available on the text document.":"文本文档上可用的语言服务。\r\n","\r\n Returns a copy of this with the CaseStatement property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，而Casestatement属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n The most encompassing type in a set of types is the one type that encompasses\r\n all other types in the set. If no single type encompasses all other types, then\r\n the set has no most encompassing type. In intuitive terms, the most encompassing\r\n type is the \"largest\" type in the set—the one type to which each of the other\r\n types can be converted through a widening conversion.\r\n ":"\r\n 一组类型中最包含的类型是包含的一种类型\r\n 集合中的所有其他类型。如果没有单一类型包含所有其他类型，则\r\n 该集合没有最包含的类型。用直观的术语来说，最包容\r\n 类型是集合中的“最大”类型 - 彼此之间的一种类型\r\n 类型可以通过扩大的转换来转换。\r\n \r\n","\r\n  Looks up a localized string similar to Multiline lambda expression is missing 'End Sub'..\r\n":"\r\n  查找类似于Multiline Lambda表达式类似的局部字符串，缺少“ End Sub”。\r\n\r\n","\r\n The string literal with the alias. If not present, returns Nothing.\r\n ":"\r\n 字符串字面与别名。如果不存在，什么也不会返回。\r\n \r\n","\r\n Ignore accessibility checking when determining if a symbol is a viable match.\r\n ":"\r\n 确定符号是否可行时，请忽略可访问性检查。\r\n \r\n","\r\n            For example:\r\n            class Base { }\r\n            class Derived1 : Base { }\r\n            class Derived2 : Derived1 { }\r\n            \r\n            void Foo(Derived1 d1) { }\r\n            void Foo(Derived2 d2) { }\r\n            \r\n            Base b = new Derived1();\r\n            Foo([||]b);\r\n            \r\n            operations:\r\n            1. Convert type to 'Derived1'\r\n            2. Convert type to 'Derived2'\r\n            \r\n            'Derived1' is less specific than 'Derived2' compared to 'Base'\r\n            ":"\r\n            例如：\r\n            班级{}\r\n            类派生1：基础{}\r\n            类derived2：derived1 {}\r\n            \r\n            void foo（derived1 d1）{}\r\n            void foo（derived2 d2）{}\r\n            \r\n            b = new derived1（）;\r\n            foo（[||] b）;\r\n            \r\n            操作：\r\n            1.将类型转换为'derived1'\r\n            2.将类型转换为'derived2'\r\n            \r\n            与“ base”相比，“派生1”的特异性不如“ derived2”。\r\n            \r\n","\r\n            A default case that should not be used.\r\n            ":"\r\n            不应使用的默认情况。\r\n            \r\n","Convert switch statement to expression":"将开关语句转换为表达式\r\n","Updating the kind of a property/event accessor requires restarting the application.":"更新属性/事件访问者的类型需要重新启动应用程序。\r\n","\r\n            Get the metadata name of all the base types and interfaces this type derived from.\r\n            ":"\r\n            获取所有基本类型和接口的元数据名称此类型。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Handles' is not valid on operator declarations..\r\n":"\r\n  查找类似于“手柄”的本地化字符串在运营商声明中无效。\r\n\r\n","\r\n            flag to show whether task return type is due to await\r\n            ":"\r\n            标志以显示任务返回类型是否在等待\r\n            \r\n","\r\n            The non-generic type 'A' cannot be used with type arguments\r\n            ":"\r\n            非生成类型的“ a”不能与类型参数一起使用\r\n            \r\n","\r\n            The capabilities that the runtime has with respect to edit and continue\r\n            ":"\r\n            运行时在编辑方面具有的功能\r\n            \r\n","Wrap expression":"包裹表达\r\n","\r\n The identifier after the \".\", \".@\" or \"...\"\r\n ":"\r\n “。”，“”。@”或“ ...”之后的标识符\r\n \r\n","\r\n Returns a copy of this with the ThrowKeyword property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 将其返回此副本，而ThrowKeyword属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n"," occurs.  However, the accessibility rules\r\n are different: protected members of the base type will be visible.\r\n \r\n Consider the following example:\r\n \r\n   Public Class Base\r\n       Protected Sub M()\r\n       End Sub\r\n   End Class\r\n   \r\n   Public Class Derived : Inherits Base\r\n       Sub Test(b as Base)\r\n           b.M() ' Error - cannot access protected member.\r\n           MyBase.M()\r\n       End Sub\r\n   End Class\r\n \r\n Protected members of an instance of another type are only accessible if the instance is known\r\n to be \"this\" instance (as indicated by the \"MyBase\" keyword).\r\n ":" 发生。  但是，可访问性规则\r\n 是不同的：基类型的受保护成员将是可见的。\r\n \r\n 考虑以下示例:\r\n \r\n   公共类库\r\n       受保护的子M()\r\n       结束子\r\n   结束类\r\n   \r\n   派生的公共类：继承基\r\n       子测试(b为基础)\r\n           B.M()'错误-无法访问受保护的成员。\r\n           我想。M()\r\n       结束子\r\n   结束类\r\n \r\n 另一种类型实例的受保护成员只有在已知该实例时才可访问\r\n 为\"this\"实例（如\"MyBase\"关键字所示）。\r\n \r\n","\r\n            ```(?<!expr)``` node.\r\n            ":"\r\n            ``（？<！expr）``''node。\r\n            \r\n","A named or numbered backreference.\r\n            \r\n            'name' is the name of a capturing group defined in the regular expression pattern.":"指定或编号的反向。\r\n            \r\n            “名称”是正则表达模式中定义的捕获组的名称。\r\n","notnull generic type constraint":"notnull通用类型约束\r\n","\r\n            Functionally doesn't change the type symbol, but moves it to it's own\r\n            namespace declaration scope. \r\n            ":"\r\n            在功能上不会更改类型符号，而是将其移至\r\n            名称空间声明范围。\r\n            \r\n","\r\n  Looks up a localized string similar to Loop control variable cannot include an 'Await'..\r\n":"\r\n  查找类似于循环控制变量的本地化字符串不能包括“等待”。\r\n\r\n","\r\n A collection of local variables that are written inside the region.\r\n ":"\r\n 该区域内写的本地变量的集合。\r\n \r\n","\r\n             Looks for patterns of the form:\r\n             ":"寻找形式的模式：\r\n             \r\n","\r\n            Looks for code of the form \"x == null ? y : x\" and offers to convert it to \"x ?? y\";\r\n            ":"\r\n            寻找“ x == null？y：x”的代码，并提出将其转换为“ x ?? y”；\r\n            \r\n","All lowercase":"所有小写\r\n","\r\n            Add strings represent complex types (i.e. \"\" for non-array types and \"[]\" for array types) to the receiver type, \r\n            so we would include in the filter info about extension methods with complex receiver type.\r\n            ":"\r\n            添加字符串代表复杂类型（即对于非阵列类型的“”和“数组类型”的“ []），接收器类型，\r\n            因此，我们将在有关带有复杂接收器类型的扩展方法的过滤信息中包括。\r\n            \r\n","\r\n Returns a copy of this with the EndClassStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中EndClassStatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            The text that is displayed to the user.\r\n            ":"\r\n            向用户显示的文本。\r\n            \r\n","\r\n Represents a custom event declaration: A declaration that has a beginning event\r\n declaration, some accessor blocks and an end statement.\r\n ":"\r\n 代表自定义事件声明：具有开始事件的声明\r\n 声明，一些登录块和一个结束声明。\r\n \r\n","\r\n The system assembly, which provides primitive types like Object, String, etc., e.g. mscorlib.dll. \r\n The value is a MissingAssemblySymbol if none of the referenced assemblies can be used as a source for the \r\n primitive types and the owning assembly cannot be used as the source too. Otherwise, it is one of \r\n the referenced assemblies returned by GetReferencedAssemblySymbols() method or the owning assembly.\r\n ":"\r\n 系统组件，提供原始类型，例如对象，字符串等，例如mscorlib.dll。\r\n 如果没有参考的组件可以用作源\r\n 原始类型和所有组件也不能用作源。否则，它是\r\n GetRefercrededAssemblysymbols（）方法或所有组件返回的引用组件。\r\n \r\n","\r\n The \":\" token of the label statement.\r\n ":"\r\n 标签语句的“：”令牌。\r\n \r\n","\r\n Creates an AttributeSemanticModel that allows asking semantic questions about an attribute node.\r\n ":"\r\n 创建一个属性emanticmodel，允许询问有关属性节点的语义问题。\r\n \r\n",".\r\n            \r\n            A document state can only change from ":"。\r\n            \r\n            文档状态只能从\r\n","\r\n The value for the EndIfStatement property.\r\n ":"\r\n Endiftatement属性的值。\r\n \r\n","\r\n            CS1503: Argument 1: cannot convert from 'x' to 'y'\r\n            ":"\r\n            CS1503：参数1：无法从'x'转换为'y'\r\n            \r\n","\r\n            The identity of bucket group. \r\n            ":"\r\n            遗愿组的身份。\r\n            \r\n"," open until disposed.\r\n            ":" 打开直到处置。\r\n            \r\n","True if Option Explicit On, False if Option Explicit Off.":"true如果选项开启，则为false，如果选项明确关闭。\r\n",").\r\n            If the position doesn't correspond to any statement uses the start of the ":"）。\r\n            如果该位置不对任何语句，请使用\r\n","\r\n The optional Custom keyword for custom event declarations.\r\n ":"\r\n 自定义事件声明的可选自定义关键字。\r\n \r\n","\r\n The incremental binder is used when binding statements. Whenever a statement\r\n is bound, it checks the bound node cache to see if that statement was bound, \r\n and returns it instead of rebinding it. \r\n \r\n FOr example, we might have:\r\n    While x > foo()\r\n      y = y * x\r\n      z = z + y\r\n    End While\r\n \r\n We might first get semantic info about \"z\", and thus bind just the statement\r\n \"z = z + y\". Later, we might bind the entire While block. While binding the while\r\n block, we can reuse the binding we did of \"z = z + y\".\r\n ":"\r\n 绑定语句时使用增量粘合剂。每当语句\r\n 是绑定的，它检查绑定的节点缓存以查看该语句是否已绑定，\r\n 并返回它而不是重新定位。\r\n \r\n 例如，我们可能有：\r\n    x> foo（）\r\n      y = y * x\r\n      z = z + y\r\n    结束\r\n \r\n 我们可能首先获得有关“ Z”的语义信息，因此仅绑定语句\r\n “ z = z + y”。稍后，我们可能会绑定整个块。在绑定时\r\n 块，我们可以重复使用“ z = z + y”的绑定。\r\n \r\n","\r\n Special slot for tracking whether code is reachable\r\n ":"\r\n 用于跟踪代码是否可以达到的特殊插槽\r\n \r\n","\r\n The \"As\" keyword.\r\n ":"\r\n “ AS”关键字。\r\n \r\n","\r\n            The service to locate all positions where inline hints should be placed.\r\n            ":"该服务以找到应放置内联提示的所有位置。\r\n            \r\n"," Given bound conversion node and the type the conversion is being done to initializes \r\n bound conversion node with the reference to parameterless value type constructor and returns \r\n modified bound node.\r\n In case the constructor is not accessible from current context, or there is no parameterless\r\n constructor found in the type (which should never happen, because in such cases a synthesized \r\n constructor is supposed to be generated)\r\n ":" 给定绑定的转换节点和正在进行转换以初始化的类型 \r\n 绑定转换节点，引用无参值类型构造函数并返回 \r\n 修改的绑定节点。\r\n 如果构造函数无法从当前上下文访问，或者没有无参数\r\n 类型中找到的构造函数（这应该永远不会发生，因为在这种情况下是合成的 \r\n 构造函数应该生成）\r\n \r\n","\r\n  Looks up a localized string similar to '{' expected..\r\n":"\r\n  查找类似于“ {”预期的局部字符串。\r\n\r\n","Install '{0} {1}'":"安装'{0} {1}'\r\n","\r\n Returns a copy of this with the Members property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此的副本，成员属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","The last token in the name":"名称的最后一个令牌\r\n","Full path to an assembly manifest module file or a standalone module file.":"汇编清单模块文件或独立模块文件的完整路径。\r\n","\r\n  Looks up a localized string similar to Nested sub does not have a signature that is compatible with delegate '{0}'..\r\n":"\r\n  查找与嵌套子类似的本地化字符串，没有与代表'{0}'..兼容的签名。\r\n\r\n","\r\n Return the number of special constraints ('Class', 'Structure',\r\n and 'New') associated with the type parameter.\r\n ":"\r\n 返回特殊约束的数量（'class'，'结构'，\r\n 与类型参数关联的'new'）。\r\n \r\n","\r\n            Gets a cancellation token that argument providers may observe.\r\n            ":"\r\n            获取取消代币，论点提供者可能会观察到。\r\n            \r\n","\r\n Optional. The format string clause ':formatString' of the embedded expression.\r\n ":"\r\n 可选的。嵌入式表达式的格式字符串子句'：FEMATSTRING'。\r\n \r\n","A bound sequence for the object creation expression containing the invocation expressions, or a \r\n bound statement list if no temporary should be used.":"包含调用表达式的对象创建表达式的绑定序列，或\r\n 如果不使用临时性，则有限的语句列表。\r\n","\r\n This class represents a base class for compiler generated constructors\r\n ":"\r\n 该类代表编译器生成的构造函数的基类\r\n \r\n","\r\n Provides context for binding top-level statements in a script. \r\n ":"\r\n 提供了脚本中绑定顶级语句的上下文。\r\n \r\n","\r\n Returns True for one of the types from a set of Structure types if\r\n that set represents a cycle. This property is intended for flow\r\n analysis only since it is only implemented for source types,\r\n and only returns True for one of the types within a cycle, not all.\r\n ":"\r\n 如果从一组结构类型中的一种类型中的一种类型返回\r\n 该集合代表一个周期。此属性旨在流动\r\n 分析仅由于仅针对来源类型实施\r\n 并且仅返回一个周期内的类型之一，而不是全部。\r\n \r\n","Localizable message for the diagnostic.":"诊断的可本质消息。\r\n","\r\n Appends diagnostics from useSiteDiagnostics into diagnostics and returns True if there were any errors.\r\n ":"\r\n 将诊断诊断的诊断添加到诊断中，如果有任何错误，则返回真实。\r\n \r\n","\r\n  Looks up a localized string similar to Declaration expected..\r\n":"\r\n  查找类似于预期声明的本地字符串。\r\n\r\n","See description in TryScanXmlDocComment(...)":"请参阅tryscanxmldoccomment中的描述（...）\r\n","The argument context.":"参数上下文。\r\n","punctuation, initial quote":"标点符号，初始报价\r\n","\r\n            To avoid accessing metadata/symbol readers that have been disposed,\r\n            read lock is acquired before every operation that may access a baseline module/symbol reader \r\n            and write lock when the baseline readers are being disposed.\r\n            ":"\r\n            为了避免访问已处理的元数据/符号读者，\r\n            读取锁定是在访问基线模块/符号读取器的每个操作之前获取的\r\n            并在处置基线读取器时写锁。\r\n            \r\n","\r\n  Looks up a localized string similar to Command-line syntax error: Invalid Guid format '{0}' for option '{1}'.\r\n":"\r\n  查找类似于命令行语法错误的本地化字符串：无效的GUID格式'{0}'for Option'{1}'。\r\n\r\n","\r\n            Helpers related to ":"\r\n            与之相关的帮助者\r\n","\r\n The field of the generated iterator class that underlies the Current property.\r\n ":"生成的迭代仪类的字段是当前属性的基础。\r\n \r\n","\r\n            Project ID for the document or project for which diagnostics need to be computed.\r\n            ":"\r\n            用于计算诊断的文档或项目的项目ID。\r\n            \r\n","An ImmutableArray containing all the type members of this symbol. If this symbol has no type members,\r\n returns an empty ImmutableArray. Never returns null.":"一个包含此符号的所有类型成员的immutablearray。如果此符号没有类型成员，\r\n 返回一个空的Immutablearray。永远不会返回零。\r\n",".\r\n            Once a document state is ":"。\r\n            一旦文件状态为\r\n","Separate nibbles":"单独的小点心\r\n","\r\n This symbol is used as the return type of a LambdaSymbol when we failed to \r\n infer lambda's return type, but still want to interpret its body.\r\n ":"\r\n 当我们失败时，此符号用作lambdasymbol的返回类型\r\n 推断Lambda的返回类型，但仍然想解释其身体。\r\n \r\n","\r\n Traverse a tree of bound nodes, and update the following maps inside the SemanticModel:\r\n \r\n     guardedNodeMap  - a map from syntax node to bound nodes. Bound nodes are added in the order they are bound\r\n                       traversing the tree, so they will be in order from upper to lower node.\r\n \r\n     guardedQueryBindersMap - a map from query-specific syntax node to an array of binders used to\r\n                              bind various children of the node.\r\n \r\n     guardedAnonymousTypeBinderMap - a map from Anonymous Type initializer's FieldInitializerSyntax to\r\n                                     Binder.AnonymousTypeFieldInitializerBinder used to bind its expression.\r\n":"\r\n 遍历绑定节点的树，并更新semanticmodel中的以下映射：\r\n \r\n     GuardedNodeMap-从语法节点到绑定节点的地图。按限制的顺序添加绑定的节点\r\n                       遍历树，因此它们将从上部到下节点顺序排列。\r\n \r\n     GuardedQueryBindersMap-从查询特异性语法节点到一个固定器数组的地图\r\n                              结合节点的各个孩子。\r\n \r\n     GuardedAnonymousTypebIndermap-匿名类型初始化器的fientInitializerSyntax的地图\r\n                                     Binder.AnonymoustypefieldInitializerBinder用于绑定其表达。\r\n\r\n","\r\n Precedence level for an extension method.\r\n ":"\r\n 扩展方法的优先级。\r\n \r\n","\r\n  Looks up a localized string similar to 'Await' can only be used within an Async method. Consider marking this method with the 'Async' modifier and changing its return type to 'Task(Of {0})'..\r\n":"\r\n  查找类似于“等待”的本地化字符串只能在异步方法中使用。考虑使用“ async”修饰符标记此方法，然后将其返回类型更改为“（{0}）任务”。\r\n\r\n","\r\n The shift count for a left-shift or right-shift operator needs to be masked according to the type \r\n of the left hand side, unless the shift count is an in-range constant. This is similar to what is \r\n done in code gen.\r\n ":"\r\n 需要根据类型掩盖左移或右移操作员的换档计数\r\n 左侧，除非移位计数是范围内常数。这类似于什么\r\n 在代码gen中完成。\r\n \r\n","\r\n  Looks up a localized string similar to Default values cannot be supplied for parameters that are not declared 'Optional'..\r\n":"查找类似于默认值的本地化字符串无法为未声明为“可选”的参数提供。\r\n\r\n","\r\n Get all diagnostics for the entire compilation. This includes diagnostics from parsing, declarations, and\r\n the bodies of methods. Getting all the diagnostics is potentially a length operations, as it requires parsing and\r\n compiling all the code. The set of diagnostics is not caches, so each call to this method will recompile all\r\n methods.\r\n ":"获取整个汇编的所有诊断。这包括解析，声明和\r\n 方法的身体。获取所有诊断可能是一个长度操作，因为它需要解析和\r\n 编译所有代码。一组诊断不是缓存，因此每个调用此方法都会重新编译所有\r\n 方法。\r\n \r\n","\r\n            Top-level edit script does not contain edits for a member if only trivia changed in its body.\r\n            It also does not reflect changes in line mapping directives.\r\n            Members that are unchanged but their location in the file changes are not considered updated.\r\n            This method calculates line and trivia edits for all these cases.\r\n            \r\n            The resulting line edits are grouped by mapped document path and sorted by ":"\r\n            如果只有琐事在其体内更改，顶级编辑脚本将不包含成员的编辑。\r\n            它也不反映线映射指令中的变化。\r\n            不变但他们在文件更改中的位置的成员不被考虑更新。\r\n            此方法计算所有这些情况的线和琐事编辑。\r\n            \r\n            结果线编辑通过映射文档路径进行分组，并通过\r\n","\r\n Represents a left-hand side of a MidAssignment statement.\r\n ":"\r\n 代表中型陈述的左侧。\r\n \r\n","\r\n            Indicates that the code style diagnostic can be enforced on build and is part of the recommended group for build enforcement.\r\n            ":"\r\n            表示可以在构建中执行代码样式诊断，并且是推荐的构建执行组的一部分。\r\n            \r\n","group options":"组选项\r\n","all anonymous types in container":"容器中的所有匿名类型\r\n","\r\n Represents a \"Continue (block)\" statement. THe kind of block referenced can be\r\n determined by examining the Kind.\r\n ":"\r\n 表示“继续（块）”语句。引用的块可以是\r\n 通过检查类型来确定。\r\n \r\n","\r\n Check that the given symbol is a type. If it is a namespace, report an error into the diagnostic bag\r\n and return an error symbol.\r\n ":"\r\n 检查给定符号是一种类型。如果是名称空间，请向诊断袋报告错误\r\n 并返回错误符号。\r\n \r\n","Use block body for operators":"将块主体用于操作员\r\n","InterpolatedStringHandlerArgument has no effect when applied to lambda parameters and will be ignored at the call site.":"当应用于lambda参数时，InterpolatedStringHandlerArgument无效，并且在呼叫站点将被忽略。\r\n","\r\n This instance is used to compare potential WinRT fake properties in type projection.\r\n \r\n FIXME(angocke): This is almost certainly wrong. The semantics of WinRT conflict \r\n comparison should probably match overload resolution (i.e., we should not add a member\r\n  to lookup that would result in ambiguity), but this is closer to what Dev12 does.\r\n \r\n The real fix here is to establish a spec for how WinRT conflict comparison should be\r\n performed. Once this is done we should remove these comments.\r\n ":"\r\n 此实例用于比较类型投影中的潜在winrt假属性。\r\n \r\n FixMe（Angocke）：这几乎可以肯定是错误的。 Winrt冲突的语义\r\n 比较可能应匹配超载分辨率（即，我们不应添加成员\r\n  查找会导致歧义），但这更接近Dev12的作用。\r\n \r\n 这里的真正解决方案是建立一个规范Winrt冲突应该如何比较\r\n 执行。完成此操作后，我们应该删除这些评论。\r\n \r\n","\r\n Create a missing integer literal.\r\n ":"\r\n 创建一个缺失的整数字面意思。\r\n \r\n","\r\n Returns a copy of this with the HandlesClause property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 将其返回此副本，而Handlesclause属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","The replacement node.":"替换节点。\r\n","\r\n  Looks up a localized string similar to Leading '.' or '!' can only appear inside a 'With' statement..\r\n":"\r\n  查找类似于领导'的局部字符串。或者 '！'只能出现在“ with”语句中。\r\n\r\n","\r\n            such as 'record Student(int Id) : Person($$\"first\", \"last\");`.\r\n            ":"\r\n            例如'记录学生（int id）：人（$$“ first”，“ last”）;`。\r\n            \r\n","\r\n Returns a copy of this with the PropertyKeyword property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中属性关键字属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n The \"Erase\" keyword.\r\n ":"\r\n “擦除”关键字。\r\n \r\n"," \r\n The SyntaxTree that is bound\r\n ":" \r\n 绑定的语法\r\n \r\n"," is not null, it gets diagnostics only for this given ":" 不是null，它仅用于此给定的诊断\r\n","\r\n Represents the part of a variable or constant declaration statement that\r\n associated one or more variable names with a type.\r\n ":"\r\n 代表变量或常数声明的一部分，\r\n 与一个类型相关联的一个或多个变量名称。\r\n \r\n","\r\n            Get appropriate completion items for all the visible top level types from given PE reference.\r\n            ":"从给定的PE参考中获取所有可见的顶级类型的适当完成项。\r\n            \r\n","\r\n Gets type information about an expression.\r\n ":"\r\n 获取有关表达式的类型信息。\r\n \r\n","number, letter":"号码，信件\r\n","\r\n The value for the EndClassStatement property.\r\n ":"\r\n EndClassStatement属性的值。\r\n \r\n","Private member '{0}' can be removed as the value assigned to it is never read":"私人成员'{0}'可以删除，因为分配给它的值永远不会读取\r\n"," method to determine which fields and\r\n            properties were combined to form a hash code for this type.\r\n            ":" 确定哪些字段和\r\n            将属性组合在一起以形成这种类型的哈希代码。\r\n            \r\n"," metadata reference, this \r\n            is the ":" 元数据参考，这个\r\n            是个\r\n","\r\n Creates a trivia with kind EndOfLineTrivia containing the specified text. Elastic trivia are used to\r\n denote trivia that was Not produced by parsing source text, And are usually Not preserved during formatting.\r\n ":"\r\n 用包含指定文本的善良内传式创建一个琐事。弹性琐事习惯\r\n 表示未通过解析源文本产生的琐事，通常在格式期间没有保留。\r\n \r\n","True if the shadow-copy policy applies to the specified path.":"如果影子拷贝策略适用于指定的路径，则为正确。\r\n"," \r\n Helper for implementing DeclaringSyntaxNodes for derived classes that store a location but not a  SyntaxNode or SyntaxReference. \r\n ":" \r\n 用于实现派生类别的declaringsyntaxnodes的助手，该类别存储一个位置，而不是语法或语法rreference。\r\n \r\n","Autoselect disabled due to potential pattern variable declaration.":"由于潜在的模式变量声明，自动选择禁用。\r\n","\r\n The ':' token.\r\n ":"\r\n '：'令牌。\r\n \r\n","\r\n            Given a document and syntax node, returns a collection of locations where the located node is referenced.\r\n            ":"\r\n            给定的文档和语法节点，返回引用定位节点的位置集合。\r\n            \r\n","\r\n Gets the available named symbols in the context of the specified location and optional\r\n container. Only symbols that are accessible and visible from the given location are\r\n returned.\r\n ":"\r\n 获取指定位置和可选的上下文中的可用命名符号\r\n 容器。 只有从给定位置可访问和可见的符号是\r\n 回来了。\r\n \r\n","\r\n Create a NamespaceExtent that represents a given ModuleSymbol.\r\n ":"\r\n 创建一个代表给定模块符号的命名续文。\r\n \r\n","Convert to 'for'":"转换为“ for”\r\n","\r\n            Invalid return type in XML comment cref attribute\r\n            ":"\r\n            XML评论CREF属性中无效的返回类型\r\n            \r\n","\r\n The \"End Class\" statement that ends the block.\r\n ":"\r\n 结束块的“最终类”语句。\r\n \r\n","\r\n            Creates a copy of the this ":"\r\n            创建一个副本\r\n","\r\n The value for the ErrorKeyword property.\r\n ":"\r\n 错误关键字属性的值。\r\n \r\n","\r\n            Register new IDiagnosticUpdateSource\r\n            \r\n            Currently, it doesn't support unregister since our event is asynchronous and unregistering source that deal with asynchronous event is not straight forward.\r\n            ":"\r\n            注册新的IDIANGNOSTICUPDATESOURCE\r\n            \r\n            目前，由于我们的活动是异步和未注册的来源，因此处理异步事件并不直接。\r\n            \r\n","\r\n 0 - not a surrogate, 2 - is valid surrogate \r\n 1 is an error\r\n ":"\r\n 0-不是代理，2-是有效的代理\r\n 1是一个错误\r\n \r\n","\r\n A SourceFileBinder provides the context associated with a give source file, not including the\r\n Imports statements (which have their own binders). It primarily provides the services of getting\r\n locations of node, since it holds onto a SyntaxTree.\r\n ":"\r\n SourceFileBinder提供了与给出源文件相关的上下文，而不包括\r\n 进口语句（具有自己的粘合剂）。它主要提供获取的服务\r\n 节点的位置，因为它保存在语法上。\r\n \r\n","\r\n            this regex is used to extract the text between the\r\n            brackets and save the contents in a MatchCollection\r\n            ":"\r\n            此正则是用来提取文本\r\n            括号并将内容保存在匹配项中\r\n            \r\n","\r\n The value for the AccessorKeyword property.\r\n ":"\r\n 登录键属性的值。\r\n \r\n","Type of the delegate.":"代表的类型。\r\n","\r\n Returns True for \"regular\" properties (those that are not WithEvents.\r\n Typically used for OHI diagnostics where WithEvents properties are treated as variables.\r\n ":"\r\n 对于“常规”属性（不符合事件的属性），返回为true。\r\n 通常用于OHI诊断，其中有事件属性被视为变量。\r\n \r\n","The symbol for the accessibility check.":"可访问性检查的符号。\r\n","Missing control character":"缺少控制字符\r\n","\r\n            Information about a symbol's reference that can be used for display and \r\n            navigation in an editor.\r\n            ":"\r\n            有关可用于显示和的符号引用的信息\r\n            在编辑器中导航。\r\n            \r\n","The actual text to be displayed.":"要显示的实际文本。\r\n","Move file to project root folder":"将文件移至项目根文件夹\r\n","You can use the navigation bar to switch contexts.":"您可以使用导航栏切换上下文。\r\n","\r\n            Operates on runtime metadata artifacts.\r\n            ":"\r\n            在运行时元数据工件上操作。\r\n            \r\n","Record member '{0}' must be protected.":"记录成员'{0}'必须受到保护。\r\n","deprecated":"弃用\r\n","\r\n            if (cond)\r\n            {\r\n            }\r\n            \r\n            NextStatement();\r\n            ":"\r\n            if（cond）\r\n            {\r\n            }\r\n            \r\n            NextStatement（）;\r\n            \r\n","\r\n            Specialized finder for the \"Color Color\" case.  Used when we have \"Color.Black\" and \"Color\"\r\n            bound to a Field/Property, but not a type.  In this case, we want to look for namespaces\r\n            containing 'Color' as if we import them it can resolve this issue.\r\n            ":"“颜色”案例的专门查找器。当我们有“ color.black”和“ color”时使用\r\n            绑定到字段/属性，而不是类型。在这种情况下，我们想寻找名称空间\r\n            包含“颜色”，就好像我们导入它们一样可以解决此问题。\r\n            \r\n","\r\n            Returns adjusted active statements in the specified mapped ":"\r\n            返回指定映射的调整后的活动语句\r\n","\r\n A list of all attribute lists on this parameter. If no attributes were\r\n specified, Nothing is returned.\r\n ":"\r\n 此参数上的所有属性列表的列表。如果没有属性\r\n 指定，什么都没有返回。\r\n \r\n","\r\n The \"Sub\" keyword.\r\n ":"\r\n “子”关键字。\r\n \r\n","\r\n Return True if the character is a colon, and not part of \":=\".\r\n ":"\r\n 如果角色是结肠，而不是“：=”的一部分，则返回true。\r\n \r\n","\r\n            Report errors blocking the document analysis.\r\n            ":"\r\n            报告错误阻止文档分析的错误。\r\n            \r\n","\r\n Produce all implemented interfaces in topologically sorted order. We use\r\n TypeSymbol.Interfaces as the source of edge data, which has had cycles and infinitely\r\n long dependency cycles removed. Consequently, it is possible (and we do) use the\r\n simplest version of Tarjan's topological sorting algorithm.\r\n":"\r\n 以拓扑排序的顺序生产所有实现的接口。我们用\r\n typesymbol.interfaces作为边缘数据的来源，它具有循环和无限\r\n 长时间的依赖周期已删除。因此，有可能（我们确实）使用\r\n Tarjan拓扑排序算法的最简单版本。\r\n\r\n","\r\n            Implmenting member for member in interface. Shown as I↓\r\n            ":"\r\n            接口中的成员隐含成员。显示在我↓\r\n            \r\n"," to allow a decompiler or other technology to show a\r\n            representation of the original sources; otherwise ":" 允许分解器或其他技术显示\r\n            原始资源的代表；否则\r\n","\r\n            This factory method is only valid when ":"\r\n            这种工厂方法仅在\r\n","\r\n            The current document content does not match the content the module was compiled with.\r\n            This document state may change to ":"\r\n            当前的文档内容与该模块所编译的内容不匹配。\r\n            该文件状态可能会更改为\r\n","\r\n             Method converts typeof(...).Name to nameof(...)\r\n            ":"\r\n             方法转换typeof（...）。名称为namef（...）\r\n            \r\n","\r\n            Add imports for the namespace specified by ":"\r\n            为指定的名称空间添加导入\r\n","Type to get":"类型要获得\r\n","\r\n Gets the root node of the syntax tree if it is already available.\r\n ":"\r\n 如果已经可用，则获取语法树的根节点。\r\n \r\n"," we'd like to add a reference to.\r\n            ":" 我们想添加参考。\r\n            \r\n","\r\n            Instance of ":"\r\n            实例\r\n","\r\n The \"Namespace\" keyword.\r\n ":"\r\n “名称空间”关键字。\r\n \r\n","\r\n  Looks up a localized string similar to 'By' expected..\r\n":"\r\n  查找类似于“预期”的局部字符串。\r\n\r\n","\r\n Gets symbol information about an cref reference syntax node. This is the worker\r\n function that is overridden in various derived kinds of Semantic Models. \r\n ":"\r\n 获取有关CREF参考语法节点的符号信息。这是工人\r\n 在各种派生的语义模型中被覆盖的函数。\r\n \r\n","\r\n Handle expression reclassification, if any applicable.\r\n \r\n If function returns True, the \"argument\" parameter has been replaced\r\n with result of reclassification (possibly an error node) and appropriate\r\n diagnostic, if any, has been reported.\r\n \r\n If function returns false, the \"argument\" parameter must be unchanged and no \r\n diagnostic should be reported. \r\n \r\n conversionSemantics can be one of these: \r\n       SyntaxKind.CTypeKeyword, SyntaxKind.DirectCastKeyword, SyntaxKind.TryCastKeyword\r\n ":"\r\n 处理表达重新分类，如果有任何适用。\r\n \r\n 如果函数返回true，则已更换“参数”参数\r\n 由于重新分类（可能是错误节点）和适当的结果\r\n 诊断（如果有的话）已有报道。\r\n \r\n 如果函数返回false，则“参数”参数必须不变，否\r\n 应报告诊断。\r\n \r\n 转化器主义可能是其中之一：\r\n       stytaxkind.ctypekeyword，syntaxkind.directcastkeyword，syntaxkind.trycastkeyword\r\n \r\n","The inferred element type":"推断的元素类型\r\n","Fix all occurrences":"修复所有发生\r\n","'using' directive preferences":"\"使用\"指令首选项\r\n","The 'new()' constraint cannot be used with the 'unmanaged' constraint":"“ new（）”约束不能与“不受管理的”约束一起使用\r\n","Changing pseudo-custom attribute '{0}' of {1} requires restarting the application":"更改{1}的伪custom属性'{0}'需要重新启动应用程序\r\n","\r\n The value for the TryKeyword property.\r\n ":"\r\n TryKeyword属性的值。\r\n \r\n","\r\n Returns the string representation of this node, not including its leading and trailing trivia.\r\n ":"\r\n 返回该节点的字符串表示形式，而不包括其领先和尾随的琐事。\r\n \r\n","Bound type after the As. Can be nothing if no type was supplied.":"AS之后的绑定类型。如果没有提供类型，则无能为力。\r\n","\r\n When binding a name X that was declared with a \"using X=OtherTypeOrNamespace\", return the alias symbol X.\r\n ":"\r\n 当绑定用“使用x = earthtypeornamespace”声明的名称x时，返回别名符号X。\r\n \r\n","\r\n Creates a binder for a source file. This includes the following binders:\r\n    BackstopBinder\r\n    SourceModuleBinder\r\n    TypesOfImportedNamespacesMembersBinder (for modules of project-level imported namespaces)\r\n    ImportedTypesAndNamespacesMembersBinder (for project-level imported namespaces and types)\r\n    ImportAliasesBinder (for project-level import aliases)\r\n    SourceFileBinder\r\n    TypesOfImportedNamespacesMembersBinder (for modules of file-level imported namespaces)\r\n    ImportedTypesAndNamespacesMembersBinder (for file-level imported namespaces and types)\r\n    ImportAliasesBinder (for file-level import aliases)\r\n ":"\r\n 为源文件创建活页夹。这包括以下粘合剂：\r\n    后脚手\r\n    Sourcemodulebinder\r\n    typesofimportednamespacespacesmembersbinder（用于项目级导入名称空间的模块）\r\n    importedtypesandnamespacessmembersbinder（用于项目级导入的名称空间和类型）\r\n    ExtimaliasesBinder（用于项目级的进口别名）\r\n    SourceFileBinder\r\n    typesofimportednamespacespacesmembersbinder（用于文件级导入名称空间的模块）\r\n    importedtypesandnamespacesmembersbinder（用于文件级导入的名称空间和类型）\r\n    Exufertaliasesbinder（用于文件级导入别名）\r\n \r\n","The symbols modified identifier is there is one":"符号修改的标识符是一个\r\n","Changing the declaration scope of a captured variable '{0}' requires restarting the application.":"更改捕获变量'{0}'的声明范围需要重新启动应用程序。\r\n","\r\n The value for the Implements property.\r\n ":"\r\n 实施属性的值。\r\n \r\n","\r\n Returns True if memberList(memberIndex) is an operator.\r\n Also performs operator overloading validation and reports appropriate errors.\r\n ":"\r\n 如果会员列表（MemberIndex）是运营商，则返回true。\r\n 还执行操作员超载验证并报告适当的错误。\r\n \r\n","\r\n Parses a collection of strings representing imports to create collection of GlobalImports.\r\n ":"\r\n 解析代表进口的字符串集合，以创建GlobalImports的集合。\r\n \r\n"," (see DevDiv bug #16434).\r\n ":" （请参阅Devdiv错误＃16434）。\r\n \r\n"," representing the specific kind of\r\n AddRemoveHandlerStatementSyntax. One of AddHandlerStatement,\r\n RemoveHandlerStatement.\r\n ":" 代表特定种类\r\n AddRemoveHandLerstatementsyntax。 Addhandhellerstatement，\r\n 删除手术。\r\n \r\n","This function should only be called for a type of a using variable.":"仅应调用此函数的一种使用变量的类型。\r\n","\r\n This function is used to determine the best name of a type or namespace when there are multiple declarations that\r\n have the same name but with different spellings.\r\n If this declaration is part of the rootnamespace (specified by /rootnamespace:<nsname> this is considered the best name.\r\n Otherwise the best name of a type or namespace is the one that String.Compare considers to be less using a Ordinal.\r\n In practice this prefers uppercased or camelcased identifiers.\r\n ":"\r\n 此功能用于确定类型或名称空间的最佳名称，当时有多个声明\r\n 具有相同的名称，但拼写不同。\r\n 如果此声明是rootnamespace的一部分（ /rootnamespace指定：<nsname>这被认为是最佳名称。\r\n 否则，类型或名称空间的最佳名称是String.compare认为使用序列的较少名称。\r\n 在实践中，这更喜欢加能或骆驼的标识符。\r\n \r\n"," to corresponding body node\r\n            of ":" 到相应的身体节点\r\n            的\r\n","Parameter '{0}' is an argument to the interpolated string handler conversion on parameter '{1}', but the corresponding argument is specified after the interpolated string expression. Reorder the arguments to move '{0}' before '{1}'.":"参数'{​​0}'是对参数'{1}'的插值字符串处理程序转换的参数，但是在插值字符串表达式之后指定了相应的参数。将参数重新排序以在'{1}'之前移动'{0}'。\r\n"," are contained in the exception region represented by the ":" 包含在例外区域中\r\n","If specified, the namespace of original reference will be replaced with given \r\n            namespace in the replacement node.":"如果指定，原始参考的名称空间将被给定的\r\n            替换节点中的名称空间。\r\n","\r\n            Defines the set of possible non-identifier trigger characters for this completion provider.\r\n            Used by the LSP server to determine the trigger character set for completion.\r\n            ":"\r\n            为本完成提供商定义了一组可能的非标识触发器字符。\r\n            由LSP服务器使用以确定触发字符集用于完成。\r\n            \r\n","\r\n Returns the lookup result if at least one found symbol matches the requirements that are verified\r\n by using the given symbolChecker. Extension methods will be considered in this check.\r\n ":"\r\n 如果至少一个找到的符号与已验证的要求匹配，则返回查找结果\r\n 通过使用给定的符号检查器。在此检查中将考虑扩展方法。\r\n \r\n","\r\n Returns a copy of this with the EndWithStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中endWithStatement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Delegates don't have user-defined members, so it makes more sense to treat\r\n them like methods.\r\n ":"\r\n 代表没有用户定义的成员，因此治疗更有意义\r\n 他们喜欢方法。\r\n \r\n","//":"//\r\n","\r\n A collection of the local variables for which a value is always assigned inside the region.\r\n ":"\r\n 始终在区域内分配值的本地变量集合。\r\n \r\n","\r\n  Looks up a localized string similar to 'End Using' must be preceded by a matching 'Using'..\r\n":"\r\n  查找类似于“使用”的本地化字符串必须先于匹配的“使用”。\r\n\r\n","\r\n Given a namespace block, get the corresponding type symbol.\r\n ":"\r\n 给定一个名称空间块，获取相应的类型符号。\r\n \r\n","\r\n Create TypeSubstitution that can be used to substitute method's type parameters\r\n in types involved in method's signature. \r\n \r\n Unlike for other construction methods in this class, targetMethod doesn't have to be \r\n original definition, it is allowed to be specialized unconstructed generic method.\r\n \r\n An item in typeArguments can be an alpha-renamed type parameter, but it must belong\r\n to the targetMethod and can only appear at its ordinal position to represent the lack\r\n of substitution for it.\r\n ":"\r\n 创建可用于替代方法的类型参数\r\n 在方法签名中涉及的类型中。\r\n \r\n 与此类其他施工方法不同，TargetMethod不必是\r\n 原始定义，允许它是专门的非建设通用方法。\r\n \r\n TypeArguments中的一个项目可以是alpha命名的类型参数，但必须属于\r\n 到目标方法，只能出现在其序地位置以表示缺乏\r\n 替代。\r\n \r\n","\r\n            Finds a statement at given span and a declaration body.\r\n            Also returns the corresponding partner statement in ":"\r\n            在给定的跨度和声明机构中找到一个陈述。\r\n            还返回相应的合作伙伴声明\r\n","Capture group numbers must be less than or equal to Int32.MaxValue":"捕获组编号必须小于或等于int32222.maxvalue\r\n","Generate for '{0}'":"生成'{0}'\r\n","\r\n            Create a diagnostic that adds properties specifying a tag for a set of locations.\r\n            ":"\r\n            创建一个诊断，该诊断添加属性为一组位置指定标签。\r\n            \r\n","The index of the first non-whitespace char after index \r\n start in the string up to, but not including the end index":"索引之后的第一个非Whitespace char的索引\r\n 从字符串开始，但不包括结束索引\r\n","await expression":"等待表达\r\n","\r\n Represents an \"Until ...\" clause of a \"Do\" or \"Loop\" statement.\r\n ":"\r\n 表示“ do”或“ loop”语句的“直到...”条款。\r\n \r\n","Indentation preferences":"压痕偏见\r\n","\r\n The value for the InterfaceStatement property.\r\n ":"\r\n 交流属性的值。\r\n \r\n","\r\n            Null node is always considered underselected.\r\n            ":"\r\n            null节点始终被视为未经选择。\r\n            \r\n",") each of which addresses / fixes the same set of supplied ":"）每个都解决 /修复了相同的提供的相同集合\r\n","\r\n A potentially empty collection of locations that correspond to this instance.\r\n ":"\r\n 与此实例相对应的可能空的位置集合。\r\n \r\n","\r\n The \"(\" token.\r\n ":"\r\n “（”令牌。\r\n \r\n","\r\n Validate and parse the root namespace. If the root namespace string is a valid namespace name, the parsed\r\n version is returned. Otherwise Nothing is returned.\r\n ":"\r\n 验证和解析根名称空间。如果根名称空间字符串是有效的名称空间名称，则解析\r\n 返回版本。否则什么都不会返回。\r\n \r\n","\r\n            Populate each call site with an available variable of a matching types.\r\n            If no matching variable is found, this falls back to the \r\n            ":"\r\n            用匹配类型的可用变量填充每个呼叫站点。\r\n            如果找不到匹配变量，那么这将落后于\r\n            \r\n","Encapsulate field: '{0}' (and use property)":"封装字段：'{0}'（并使用属性）\r\n","Generate delegating constructor '{0}({1})'":"生成委派构造函数'{0}（{1}）'\r\n","\r\n Returns a copy of this with the NamespaceStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中命名属性将其更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n Returns a copy of this with the OpenParenToken property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此的副本，带有OpenParentken属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","Adding {0} into a generic type requires restarting the application.":"将{0}添加到通用类型中需要重新启动应用程序。\r\n","\r\n The mapping of type parameters for the current lambda body\r\n ":"\r\n 当前Lambda主体的类型参数的映射\r\n \r\n","\r\n            Get specific diagnostics currently stored in the source. returned diagnostic might be out-of-date if solution has changed but analyzer hasn't run for the new solution.\r\n            ":"\r\n            获取当前存储在源中的特定诊断。如果解决方案已更改，则返回的诊断可能会过时，但是分析仪尚未为新解决方案运行。\r\n            \r\n","\r\n Lookup a member name in a type without considering inheritance, returning a LookupResult that\r\n summarizes the results of the lookup. See LookupResult structure for a detailed\r\n discussing of the meaning of the results.\r\n ":"\r\n 查找类型中的成员名称而不考虑继承，返回一个查找\r\n 总结查找的结果。有关详细信息，请参见查找结构\r\n 讨论结果的含义。\r\n \r\n","\r\n If the current token is a newline statement terminator, then consume the token.\r\n ":"\r\n 如果当前令牌是newline语句终结者，则消耗令牌。\r\n \r\n","\r\n Get declarations diagnostics for the entire compilation. This includes diagnostics from declarations, BUT NOT\r\n the bodies of methods or initializers. The set of declaration diagnostics is cached, so calling this method a second time\r\n should be fast.\r\n ":"\r\n 获取整个汇编的声明诊断。这包括声明中的诊断，但不包括\r\n 方法或初始化器的身体。声明诊断集已被缓存，因此第二次将此方法称为\r\n 应该很快。\r\n \r\n","\r\n Make sure we retarget methods when underlying namespace checks their viability.\r\n ":"\r\n 确保我们在底层命名空间检查方法的可行性时重新定位方法。\r\n \r\n","\r\n Create a local symbol associated with an identifier token and a different name.\r\n Used for WinRT event handler return value variable).\r\n ":"\r\n 创建与标识符令牌和其他名称关联的本地符号。\r\n 用于WinRT事件处理程序返回值变量）。\r\n \r\n","\r\n Represents a parameter of a method or property.\r\n ":"\r\n 表示方法或属性的参数。\r\n \r\n","The local symbol that was declared by the Catch statement or Nothing if statement does not declare a local variable.":"如果语句不声明本地变量，则由捕获语句声明的本地符号或什么都没有。\r\n","\r\n page's buffer\r\n ":"\r\n 页面的缓冲区\r\n \r\n","Parentheses are required around the switch governing expression.":"括号是围绕表达式的开关需要的。\r\n","Member of the special type.":"特殊类型的成员。\r\n","\r\n Represents a member variable (field) that has undergone type substitution.\r\n ":"\r\n 代表经过类型替代的成员变量（字段）。\r\n \r\n","\r\n  Infer the type of a for-each control variable.\r\n ":"\r\n  推断出访问控制变量的类型。\r\n \r\n","\r\n Represents the start tag of an XML element of the form <element>.\r\n ":"\r\n 表示<元素>的XML元素的开始标签。\r\n \r\n","\r\n            True if the instruction is located within an exception region, false if it is not, null if the instruction isn't an active statement in a changed method \r\n            or the exception regions can't be determined.\r\n            ":"\r\n            true如果指令位于异常区域内，则为false，如果不是，则null如果指令不是更改的方法中的活动语句\r\n            或不能确定异常区域。\r\n            \r\n"," if it does not contain an anonymous\r\n            type and binds to the same type at the given ":" 如果不包含匿名\r\n            在给定的\r\n","Avoid multiple blank lines":"避免多个空白行\r\n","\r\n            Error tolerance case for\r\n                \"new String()?[$$]\"\r\n            which is parsed as a BracketedArgumentListSyntax parented by an ElementBindingExpressionSyntax parented by a ConditionalAccessExpressionSyntax\r\n        ":"\r\n            误差案例\r\n                “ new String（）？[$$]”\r\n            它被解析为括号内列表nntax，由porditionalAccessexpressyntax fularded funder funder funder funder fulent funlted funch\r\n        \r\n","\r\n  Looks up a localized string similar to Property accessors cannot be declared '{0}'..\r\n":"\r\n  查找类似于属性访问者的本地化字符串，无法声明“ {0}”。\r\n\r\n","\r\n The container of the event.\r\n ":"\r\n 事件的容器。\r\n \r\n","\r\n If this is an extension method that can be applied to a instance of the given type,\r\n returns the reduced method symbol thus formed. Otherwise, returns Nothing.\r\n \r\n Name lookup should use this method in order to capture proximity, which affects \r\n overload resolution. \r\n ":"\r\n 如果这是一种扩展方法，可以应用于给定类型的实例，\r\n 返回如此形成的还原方法符号。否则，什么都没有。\r\n \r\n 名称查找应该使用此方法来捕获接近性，这会影响\r\n 超负荷分辨率。\r\n \r\n","\r\n            \r\n            Inline == true:\r\n            ":"\r\n            \r\n            inline == true：\r\n            \r\n"," if this Wrapper cannot wrap this node.\r\n            ":" 如果此包装器无法包装此节点。\r\n            \r\n","\r\n  Looks up a localized string similar to Instance members and 'Me' cannot be used within query expressions in structures..\r\n":"\r\n  查找类似于实例成员的本地化字符串，“ me”不能在结构中的查询表达式中使用。\r\n\r\n","\r\n Determines if Unicode character represents a XML whitespace.\r\n ":"\r\n 确定Unicode字符是否代表XML Whitespace。\r\n \r\n","\r\n Get the conversion helper for converting between special types in an expression tree. \r\n These are often different than the ones used in regular code.\r\n ":"\r\n 获取转换辅助器，以在表达树中的特殊类型之间转换。\r\n 这些通常与常规代码中使用的不同。\r\n \r\n","\r\n Returns the arity of this type, or the number of type parameters it takes.\r\n A non-generic type has zero arity.\r\n ":"\r\n 返回此类型的ARITY或它采用的类型参数数量。\r\n 非传播类型的Arity为零。\r\n \r\n","\r\n As an optimization, viability checking in the lookup code should use this property instead\r\n of CanBeReferencedByName.\r\n ":"作为优化，查找代码中的可行性检查应改用此属性\r\n canberedendedbyname。\r\n \r\n","\r\n Current Option Strict mode.\r\n ":"当前选项严格模式。\r\n \r\n","User-defined conversion in an interface must convert to or from a type parameter on the enclosing type constrained to the enclosing type":"接口中的用户定义转换必须转换为封闭类型上的类型参数，这些参数约束至封闭类型\r\n","\r\n Returns a copy of this ":"\r\n 返回此副本\r\n"," Tells whether we are analyzing the position before, during, or after the region ":" 告诉我们是否正在分析该地区之前，之中或之后的位置\r\n"," representing the specific kind of\r\n OnErrorGoToStatementSyntax. One of OnErrorGoToZeroStatement,\r\n OnErrorGoToMinusOneStatement, OnErrorGoToLabelStatement.\r\n ":" 代表特定种类\r\n OnErrorgotostatementsyntax。 OnErrorgotozerostatement之一，\r\n OnErrorgotominusonestatement，OnErrorgotolabelStatement。\r\n \r\n","\r\n            Additional information attached to a document span by it creator.\r\n            ":"\r\n            IT创建者附带到文档跨度附带的其他信息。\r\n            \r\n","\r\n  Looks up a localized string similar to '{0}' is not valid on an interface method declaration..\r\n":"\r\n  在接口方法声明上查找类似于“ {0}”的本地化字符串。\r\n\r\n","\r\n fake local that represents the eval stack. when we need to ensure that eval\r\n stack is not blocked by stack Locals, we record an access to empty.\r\n ":"\r\n 代表评估堆栈的伪造本地。当我们需要确保评估时\r\n 堆栈不会被堆栈当地人阻止，我们记录了对空的访问。\r\n \r\n","\r\n Get all implicitly declared variables that were declared in this method body. The binder\r\n must be frozen before this can be obtained.\r\n ":"\r\n 获取该方法主体中声明的所有隐式声明变量。活页夹\r\n 必须在获得此之前冷冻。\r\n \r\n","\r\n            Underselection is defined as omitting whole nodes from either the beginning or the end. It can be used e.g. to detect that\r\n            following selection `1 + [|2 + 3|]` is underselecting the whole expression node tree.\r\n            ":"\r\n            登录定义为从开始或结束时省略整个节点。它可以使用，例如检测到这一点\r\n            以下选择`1 + [| 2 + 3 |]`是在整个表达节点树中脱落。\r\n            \r\n","\r\n The value for the ModuleKeyword property.\r\n ":"\r\n ModuleKeyWord属性的值。\r\n \r\n","The ?? quantifier matches the preceding element zero or one time, but as few times as possible. It is the lazy counterpart of the greedy quantifier ?":"这 ？？量词匹配前面的元素零或一次，但尽可能少。这是贪婪量化器的懒惰对应物吗？\r\n"," if 'Deselect All' was chosen.\r\n            ":" 如果选择了“取消选择”。\r\n            \r\n","\r\n  Looks up a localized string similar to '#ExternalSource' statement must end with a matching '#End ExternalSource'..\r\n":"\r\n  查找类似于“ #ExternalSource”语句的本地化字符串必须以匹配的“ #end externalsource”结尾。\r\n\r\n","Find and install latest version":"查找并安装最新版本\r\n","\r\n Returns a copy of this with the EventStatement property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中事件statement属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","Encapsulate field: '{0}' (but still use field)":"封装字段：'{0}'（但仍使用字段）\r\n","\r\n            Looks for code of the forms:\r\n            \r\n                var x = o as Type;\r\n                if (!(x is Y y)) ...\r\n            \r\n            and converts it to:\r\n            \r\n                if (x is not Y y) ...\r\n                \r\n            ":"\r\n            寻找表格代码：\r\n            \r\n                var x = o作为类型;\r\n                如果（！（x是y））...\r\n            \r\n            并将其转换为：\r\n            \r\n                如果（x不是y）...\r\n                \r\n            \r\n","\r\n The value for the EventKeyword property.\r\n ":"\r\n EventKeyword属性的值。\r\n \r\n","\r\n Some nodes have special binder's for their contents\r\n ":"\r\n 有些节点有特殊的粘合剂的内容\r\n \r\n","Type '{0}' must be public to be used as a calling convention.":"键入'{0}'必须公开用作呼叫约定。\r\n","\r\n A draft version of initializers which will be used in this With statement. \r\n Initializers are expressions which are used to capture expression in the current\r\n With statement; they can be empty in some cases like if the expression is a local \r\n variable of value type.\r\n \r\n Note, the initializers returned by this property are 'draft' because they are \r\n generated based on initial bound tree, the real initializers will be generated \r\n in lowering based on lowered expression form.\r\n ":"\r\n 初始化器的草稿版本，将在此使用语句中使用。\r\n 初始化器是用于捕获电流表达式的表达式\r\n 带有陈述；在某些情况下，它们可能是空的，例如表达是局部的\r\n 价值类型的变量。\r\n \r\n 注意，该属性返回的初始化器是“草稿”，因为它们是\r\n 基于初始绑定树生成，将生成真实的初始化器\r\n 基于降低表达形式的降低。\r\n \r\n","Make method async (stay void)":"使方法异步（保持无效）\r\n","\r\n The value for the AttributeModifier property.\r\n ":"\r\n attributemodifier属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to 'Is' operand of type '{0}' can be compared only to 'Nothing' because '{0}' is a nullable type..\r\n":"\r\n  查找类似于“ IS”类型'{0}'的局部字符串，只能将其比较为'Nothing'，因为'{0}'是一个无效的类型。\r\n\r\n",".\r\n            \r\n            Returns default if the declaration does not have any breakpoint spans.\r\n            ":"。\r\n            \r\n            如果声明没有任何断点跨度，则返回默认值。\r\n            \r\n","\r\n            Ignore Formatting\r\n        ":"\r\n            忽略格式\r\n        \r\n","Modifiers are not ordered":"未订购修饰符\r\n","\r\n Displays a symbol in the Visual Basic style, based on a ":"\r\n 基于一个\r\n","\r\n Represents a NameOf expression.\r\n ":"\r\n 代表一个名称表达式。\r\n \r\n","   \r\n            represents a general trivia between two tokens. slightly more expensive than others since it\r\n            needs to calculate stuff unlike other cases\r\n            ":"   \r\n            代表两个令牌之间的一般琐事。比其他人贵一些\r\n            与其他情况不同，需要计算内容\r\n            \r\n","A token of the expected kind.  This node may be an empty token with an error attached to it":"预期的象征。该节点可能是一个空的令牌，并附加了错误\r\n","\r\n            Continues script execution from the state represented by this instance by running the specified code snippet.\r\n            ":"\r\n            通过运行指定的代码段来继续从本实例表示的状态执行脚本。\r\n            \r\n","\r\n Returns a copy of this with the TypeArgumentList property changed to the\r\n specified value. Returns this instance if the specified value is the same as\r\n the current value.\r\n ":"\r\n 返回此副本，其中typeargumentlist属性更改为\r\n 指定值。如果指定值与\r\n 当前值。\r\n \r\n","\r\n            Resolves assembly identities in Global Assembly Cache.\r\n            ":"\r\n            解决全球组装缓存中的组装身份。\r\n            \r\n","\r\n  Looks up a localized string similar to Members in a Module cannot implement interface members..\r\n":"\r\n  查找类似于模块中成员的本地化字符串无法实现接口成员。\r\n\r\n","\r\n The modifier token (Static, Dim or Const) that introduces this local variable\r\n declaration.\r\n ":"\r\n 引入此局部变量的修饰符令牌（静态，DIM或const）\r\n 宣言。\r\n \r\n"," \r\n Property declaration syntax node. \r\n It is either PropertyStatement for normal properties or ModifiedIdentifier for WithEvents ones.\r\n ":" \r\n 属性声明语法节点。\r\n 它要么是普通属性的属性陈述，要么是对事件的属性属性。\r\n \r\n","Dim x = 1":"昏暗x = 1\r\n","\r\n Return an array of assemblies involved in canonical type resolution of\r\n NoPia local types defined within this assembly. In other words, all \r\n references used by previous compilation referencing this assembly.\r\n ":"\r\n 返回一系列参与规范类型分辨率的组件\r\n NOPIA在此组件中定义的本地类型。换句话说，所有人\r\n 先前汇编所用的参考引用了此组件。\r\n \r\n"," in the display layer.  Should\r\n            be short as it will show up in the UI.  Display will present this in a way to distinguish\r\n            this from the normal text (for example, by fading out and right-aligning).\r\n            ":" 在显示层中。应该\r\n            要短，因为它将出现在UI中。显示将以区分的方式呈现\r\n            这是从普通文本（例如，淡出和右对齐）。\r\n            \r\n","\r\n An index of the target constructor signature in signatures array,\r\n -1 if this is not the target attribute.\r\n ":"\r\n 签名阵列中目标构造函数的索引，\r\n -1如果这不是目标属性。\r\n \r\n",". \r\n            This will never create new ":"。\r\n            这永远不会创造新的\r\n","\r\n  Returns the cached ResourceManager instance used by this class.\r\n":"\r\n  返回此类使用的缓存ResourceManager实例。\r\n\r\n","\r\n Represents an XML name of the form 'name' or 'namespace:name' appearing in\r\n source as part of an XML literal or member access expression or an XML\r\n namespace import clause.\r\n ":"\r\n 表示形式“名称”或“名称空间：名称”的XML名称出现在\r\n 源作为XML文字或成员访问表达式或XML的一部分\r\n 名称空间导入子句。\r\n \r\n","\r\n            The existing text of the argument value, if the argument is already in code; otherwise,\r\n            ":"\r\n            如果参数已经在代码中，则参数值的现有文本；否则，\r\n            \r\n","\r\n            ```(?=expr)``` node.\r\n            ":"\r\n            ``（？= expr）````node''。\r\n            \r\n","\r\n The value for the CatchBlocks property.\r\n ":"\r\n Catchblocks属性的值。\r\n \r\n","\r\n If the method or property group is not Nothing, bind as an invocation expression.\r\n Otherwise return a BoundBadExpression containing the arguments.\r\n ":"\r\n 如果方法或属性组并非一无所有，请绑定为调用表达式。\r\n 否则，返回包含参数的boundbadexpression。\r\n \r\n","\r\n            DeterminesCheck if we're in an interesting situation like this:\r\n            ":"\r\n            确定我们是否处于这样的有趣情况：\r\n            \r\n"," is part of a lambda body. \r\n Returns the node (":" 是Lambda身体的一部分。\r\n 返回节点（\r\n","The GetEnumerator method.":"GetEnumerator方法。\r\n","\r\n Returns a copy of this with the EndCDataToken property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中endCdatatoken属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Represents the parameter list in a method declaration.\r\n ":"\r\n 表示方法声明中的参数列表。\r\n \r\n","\r\n            Incremental solution edits that correlate to code operations\r\n            ":"\r\n            与代码操作相关的增量解决方案编辑\r\n            \r\n","\r\n The compilation in which the analysis is taking place.  This is needed to determine which\r\n conditional methods will be compiled and which will be omitted.\r\n ":"\r\n 进行分析的汇编。这需要确定哪个\r\n 有条件的方法将被编译并省略。\r\n \r\n","\r\n            Tries to find an if-statement that looks like it is checking the provided parameter\r\n            in some way.  If we find a match, we'll place our new null-check statement before/after\r\n            this statement as appropriate.\r\n            ":"\r\n            试图找到看起来像是在检查提供的参数\r\n            某种程度上来说。如果我们找到比赛，我们将在/之后放置新的Null-Check语句\r\n            此声明适当。\r\n            \r\n","\r\n Parses a collection of strings representing imports to create a collection of GlobalImport instance and diagnostics\r\n ":"\r\n 解析代表导入的字符串集合，以创建GlobalImport实例和诊断的集合\r\n \r\n","\r\n Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax \r\n within ":"\r\n 返回什么“添加”方法符号（如果有）对应于给定的表达语法\r\n 内\r\n","An expression of type '{0}' can never match the provided pattern.":"类型“ {0}”的表达式永远无法匹配所提供的模式。\r\n","\r\n  Looks up a localized string similar to Cannot infer a common type because more than one type is possible..\r\n":"\r\n  查找类似于不能推断常见类型的局部字符串，因为可能多种类型。\r\n\r\n","\r\n Validate attribute usage target and duplicate attributes.\r\n ":"\r\n 验证属性使用目标和重复属性。\r\n \r\n"," to also fetch those.\r\n            ":" 也可以获取那些。\r\n            \r\n","\r\n            Return true if solution crawler is in progress.\r\n            ":"\r\n            如果解决方案搜寻器正在进行中，则返回true。\r\n            \r\n","\r\n            operation has failed but can provide some best effort result\r\n            ":"\r\n            操作失败了，但可以提供一些最佳努力结果\r\n            \r\n","\r\n  Looks up a localized string similar to Statement cannot appear within a property body. End of property assumed..\r\n":"\r\n  查找类似于语句的本地化字符串，无法在属性主体中出现。假定财产的尽头..\r\n\r\n","\r\n Represents a With...End With block, include the With statement, the body of the\r\n block and the End With statement.\r\n ":"\r\n 代表...结尾为block，包括with with语句，主体\r\n 块和陈述结尾。\r\n \r\n","\r\n            Similar to SuggestedActionWithNestedActions, but in a location that can be used by\r\n            both local Roslyn and LSP.\r\n            ":"\r\n            类似于建议的操作，但是在可以使用的位置\r\n            当地的罗斯林和LSP。\r\n            \r\n","\r\n Allows asking semantic questions about a TypeSyntax or RangeArgumentSyntax node within a member, that did not appear in the original source code.\r\n Typically, an instance is obtained by a call to SemanticModel.TryGetSpeculativeSemanticModel. \r\n ":"\r\n 允许在成员中询问有关型号或rangeArgumentsyntax节点的语义问题，该节点未出现在原始源代码中。\r\n 通常，通过呼叫semanticmodel.trygetspeculativesemanticmodel获得了一个实例。\r\n \r\n","\r\n            Checks whether currentToken is the opening paren of a deconstruction-declaration in var form, such as ":"\r\n            检查CurrentToken是否是以VAR形式进行解构解析的开头，例如\r\n","\r\n Declaration security information associated with this method, or null if there is none.\r\n ":"\r\n 声明安全信息与此方法关联，如果没有，则为null。\r\n \r\n","Add null checks":"添加空检查\r\n","The type of a local declared in a fixed statement cannot be a function pointer type.":"固定语句中声明的本地类型不能是函数指针类型。\r\n"," as well as try-cast expressions like ":" 以及类似的尝试表达\r\n","\r\n The value for the SecondExpression property.\r\n ":"\r\n 第二个表达属性的值。\r\n \r\n","\r\n            Presentation and behavior rules for completion.\r\n            ":"\r\n            演示和完成的行为规则。\r\n            \r\n","\r\n Decode an option \"Text\" or \"Binary\" value into true or false. The syntax is not optional.\r\n ":"\r\n 将选项“文本”或“二进制”值解码为true或false。语法不是可选的。\r\n \r\n","'s and other details to a ":"和其他细节\r\n","\r\n Given the full text of a documentation comment, strip off the comment \r\n punctuation (''') and add appropriate indentations.\r\n ":"\r\n 鉴于文档评论的全文，请发表评论\r\n 标点符号（''）并增加适当的凹痕。\r\n \r\n","\r\n Populate the collection with all constraints for the type parameter, traversing\r\n any constraints that are also type parameters. The result is a collection of type\r\n and flag constraints, with no type parameter references. This method assumes\r\n there are no constraint cycles.\r\n ":"\r\n 用所有限制类型参数填充集合，遍历\r\n 任何也是类型参数的约束。结果是类型的集合\r\n 和标志约束，没有类型的参数参考。此方法假设\r\n 没有约束周期。\r\n \r\n","parenthesized pattern":"括号的模式\r\n","\r\n Provides lookup in imported namespaces and types (not the alias kind),\r\n either at file level or project level.\r\n ":"\r\n 在导入的名称空间和类型（不是别名类型）中提供查找，\r\n 在文件级别或项目级别上。\r\n \r\n","\r\n Gets the symbol name. Returns the empty string if unnamed.\r\n ":"\r\n 获取符号名称。如果未命名，则返回空字符串。\r\n \r\n","\r\n            Resolves metadata references for scripts.\r\n            ":"\r\n            解决脚本的元数据参考。\r\n            \r\n","\r\n            A script that will run first when this script is run. \r\n            Any declarations made in the previous script can be referenced in this script.\r\n            The end state from running this script includes all declarations made by both scripts.\r\n            ":"\r\n            运行此脚本时将首先运行的脚本。\r\n            可以在此脚本中引用上一个脚本中的任何声明。\r\n            运行此脚本的最终状态包括两个脚本发表的所有声明。\r\n            \r\n","\r\n  Looks up a localized string similar to Array initializers are valid only for arrays, but the type of '{0}' is '{1}'..\r\n":"\r\n  查找类似于数组初始化器的本地化字符串仅适用于数组，但是“ {0}”是'{1}'..的类型\r\n\r\n","\r\n  Looks up a localized string similar to 'End RaiseEvent' must be preceded by a matching 'RaiseEvent' declaration..\r\n":"\r\n  查找类似于“ end raiseevent”的局部字符串必须先于匹配的“ raiseevent”声明。\r\n\r\n","\r\n  Looks up a localized string similar to '{0}' is not valid on a constant declaration..\r\n":"\r\n  查找类似于“ {0}”的本地化字符串在常数声明中无效。\r\n\r\n"," implementations\r\n            when the over type could be triggered from outside of user code (e.g. overtyping end quotes in a string).\r\n            ":" 实施\r\n            当可以从用户代码的外部触发过度类型时（例如，字符串中的末端报价）。\r\n            \r\n"," Produce a duplicate of this flow analysis state. ":" 产生该流量分析状态的重复。\r\n","\r\n            Equivalent to PredefinedSuggestedActionCategoryNames, but in a location that\r\n            can be used by both local Roslyn and LSP.\r\n            ":"\r\n            等效于预定义的QuggesteDactactActationCategoryNames，但在一个位置\r\n            可以由当地的罗斯林和LSP使用。\r\n            \r\n","\r\n            Set the title of the window that results are displayed in.\r\n            ":"\r\n            设置显示结果的标题。\r\n            \r\n","bell character":"贝尔角色\r\n","\r\n             \r\n             Then this will be wrapped such that the dots align like so:\r\n             \r\n             ":"\r\n             \r\n             然后将其包裹起来，使点像这样对齐：\r\n             \r\n             \r\n","\r\n Adds predefined preprocessor symbols VBC_VER and TARGET to given list of preprocessor symbols if not included yet.\r\n ":"\r\n 添加预定义的预处理器符号VBC_VER和目标，以给定的预处理器符号列表，如果不包括在内。\r\n \r\n","\r\n Checks if node is reusable.\r\n The reasons for it not be usable are typically that it intersects affected range.\r\n ":"\r\n 检查节点是否可重复使用。\r\n 原因不可用的原因通常是它与受影响的范围相交。\r\n \r\n"," the sets for member ":" 成员的套装\r\n","\r\n The delegate being added or removed.\r\n ":"\r\n 代表被添加或删除。\r\n \r\n","Replace '{0}' with '{1}'":"用'{1}'替换'{0}'\r\n","\r\n Resolves the method for delegate invoke with all or relaxed arguments / return types. It also determines \r\n the method conversion kind.\r\n ":"\r\n 解决与所有或放松的参数 /返回类型一起调用的委托方法。它也决定\r\n 方法转换类型。\r\n \r\n","\r\n            Removes ":"\r\n            去除\r\n","\r\n Returns true when expression is known to produce nullable NOT-NULL\r\n NOTE: unlike HasNoValue case, HasValue expressions may have side-effects.\r\n ":"\r\n 当已知表达式产生可空的NOT-NULL时，返回true\r\n 注意：与HasNoValue情况不同，HasValue表达式可能有副作用。\r\n \r\n","\r\n  Looks up a localized string similar to Constants must be of an intrinsic or enumerated type, not a class, structure, type parameter, or array type..\r\n":"\r\n  查找类似于常数的本地化字符串必须具有内在或枚举类型，而不是类，结构，类型参数或数组类型。\r\n\r\n","\r\n Creates a list of syntax nodes.\r\n ":"\r\n 创建语法节点列表。\r\n \r\n","\r\n            is true, the last parameter will be returned if it is params parameter and the index of\r\n            the specified argument is greater than the number of parameters.\r\n            ":"\r\n            是真的，如果是参数，将返回最后一个参数\r\n            指定的参数大于参数数。\r\n            \r\n","\r\n Seals the collection of referenced symbols, all *new* symbols passed \r\n to SpawnSymbolCollection(...) will cause assert and be ignored.\r\n ":"\r\n 密封引用的符号的集合，所有 *新 *符号通过\r\n 要产生symbolcollection（...）将导致断言并被忽略。\r\n \r\n","\r\n Cached \"state\" of the state machine within the MoveNext method.  We work with a copy of\r\n the state to avoid shared mutable state between threads.  (Two threads can be executing\r\n in a Task's MoveNext method because an awaited task may complete after the awaiter has\r\n tested whether the subtask is complete but before the awaiter has returned)\r\n ":"\r\n 在MoveNext方法中缓存状态机的“状态”。我们使用的副本\r\n 避免线程之间共享可变状态的状态。 （可以执行两个线程\r\n 在任务的movenext方法中，因为等待者有一个期待的任务可能完成\r\n 测试了子任务是否完成，但在等待者返回之前）\r\n \r\n","\r\n            Return true if the declaration is a constructor declaration to which field/property initializers are emitted. \r\n            ":"\r\n            如果声明是发出字段/属性初始化器的构造函数声明，则返回true。\r\n            \r\n","\r\n  Looks up a localized string similar to 'Continue For' can only appear inside a 'For' statement..\r\n":"\r\n  查找类似于“继续”的本地化字符串，只能出现在a语句中。\r\n\r\n","\r\n Gets the \"MoveNext\" method.\r\n ":"\r\n 获取“ movenext”方法。\r\n \r\n","The individual tagged parts of the section.":"该节的单个标记部分。\r\n","\r\n List of assemblies lookup has already visited (since type forwarding can introduce cycles).\r\n ":"\r\n 集会查找列表已经访问过（因为类型转发可以引入周期）。\r\n \r\n","\r\n Is this lambda method a query lambda? \r\n If it is, IsLambdaMethod == True as well.\r\n ":"\r\n 这个lambda方法是查询lambda吗？\r\n 如果是这样，islambdamethod == true也是如此。\r\n \r\n","\r\n            For example:\r\n            Base b; Derived d = [||]b;       \r\n            \"b\" is the current node with type \"Base\", and the potential conversion types list which \"b\" can be cast by\r\n            is {Derived}\r\n            ":"\r\n            例如：\r\n            b;派生的d = [||] b;\r\n            “ B”是具有“基础”类型的当前节点，并且可以通过“ B”施放的潜在转换类型列表\r\n            是{派生}\r\n            \r\n","The \"dd\" custom format string represents the day of the month as a number from 01 through 31. A single-digit day is formatted with a leading zero.":"“ DD”自定义格式字符串表示本月的一天为01至31的数字。单位数的格式为零。\r\n","\r\n            Individual assembly reference `<Reference ... />`\r\n            ":"\r\n            单个汇编引用`<参考... />'\r\n            \r\n","\r\n If the passed in type is a delegate type D, return D and set wasExpression to False\r\n If the passed in type is a System.Linq.Expressions.Expression(Of D) for a delegate type D, return D and set wasExpression to True\r\n Else return Nothing and set wasExpression to False\r\n ":"如果输入类型为D类型D，则返回D和SET表达为false\r\n 如果类型中传递的是system.linq.expressions.expressions.exexpression（d）的代表类型D，返回D和SET表达为true\r\n 否则什么也没返回，设置表达为false\r\n \r\n","\r\n The rules are that the collection type must have an accessible GetEnumerator method that takes no parameters and\r\n returns a type that has both:\r\n  - an accessible MoveNext method that takes no parameters and returns a Boolean\r\n  - an accessible Current property that takes no parameters and is not WriteOnly\r\n\r\n NOTE: this function ONLY checks for a function named \"GetEnumerator\" with the appropriate properties.\r\n In the spec $10.9 it has these conditions: a type C is a \"collection type\" if one of\r\n    (1) it satisfies MatchesForEachCollectionDesignPattern (i.e. has a method named GetEnumerator() which\r\n        returns a type with MoveNext/Current); or\r\n    (2) it implements System.Collections.Generic.IEnumerable(Of T); or\r\n    (3) it implements System.Collections.IEnumerable.\r\n\r\n This function ONLY checks for part (1). Callers are expected to check for (2)/(3) themselves. The\r\n scenario where something satisfies (2/3) but not (1) is\r\n   Class C \r\n       Implements IEnumerable\r\n       Function g1() as IEnumerator implements IEnumerable.GetEnumerator : End Function\r\n \r\n Clearly this class does not have a method _named_ GetEnumerator, but it does implement IEnumerable.\r\n ":"\r\n 规则是，集合类型必须具有无访问的getEnumerator方法，该方法不采用任何参数，并且\r\n 返回具有两者的类型：\r\n   - 一种无需参数并返回布尔值的可访问的movenext方法\r\n   - 无需参数且不写的可访问的当前属性\r\n\r\n 注意：此功能仅检查具有适当属性的名为“ getEnumerator”的函数。\r\n 在规格$ 10.9中，它具有以下条件：如果之一\r\n    （1）它满足MatchesForeachCollectionDesignPattern（即具有一个名为getEnumerator（）的方法\r\n        返回带有movenext/current）的类型;或者\r\n    （2）它实现了system.collections.generic.enumerable（t）;或者\r\n    （3）它实现了System.Collections。\r\n\r\n 此功能仅检查部分（1）。预计呼叫者将自己检查（2）/（3）。这\r\n 某些东西满足的情况（2/3），但（1）是\r\n   c\r\n       实现iEnumerable\r\n       函数g1（）作为ienumerator实现了iEnumerable.getEnumerator：end函数\r\n \r\n 显然，此类没有一种方法_named_ getEnumerator，但确实实现了Inumerable。\r\n \r\n","\r\n            Calculates the edits that transform one sequence of syntax nodes to another, disregarding trivia.\r\n            ":"\r\n            计算将一个语法节点序列转换为另一个语法节点的编辑，无视琐事。\r\n            \r\n","Binder.DelegateResolutionResult":"Binder.DelegateresolutionResult\r\n","\r\n The same value as ConcurrentDictionary.DEFAULT_CAPACITY\r\n ":"\r\n 与concurrentDictionary.default_capacity相同的值\r\n \r\n","Cannot use an extension method with a receiver as the target of a '&' operator.":"无法将扩展方法与接收器一起用作“＆”运算符的目标。\r\n","\r\n  Looks up a localized string similar to This sub-expression cannot be used inside NameOf argument..\r\n":"\r\n  查找类似于此子表达的本地化字符串无法在NAMEOF参数中使用。\r\n\r\n","\r\n            Gets the language specific trivia that should be inserted before an operator if the\r\n            user wants to wrap the operator to the next line.  For C# this is a simple newline-trivia.\r\n            For VB, this will be a line-continuation char (":"\r\n            如果是\r\n            用户想将操作员包裹到下一行。对于C＃，这是一个简单的newline-trivia。\r\n            对于VB，这将是线路接通字符（\r\n","\r\n Symbol representing open generic method directly or indirectly contained within constructed\r\n generic type.\r\n For example: A(Of Integer).B(Of ) or A(Of Integer).B.C(Of , )\r\n ":"\r\n 符号代表直接或间接包含的开放通用方法\r\n 通用类型。\r\n 例如：a（integer）.b（of）或a（integer）.b.c（of，）\r\n \r\n","\r\n Lookup a type defined in this module.\r\n This method will be called only if the type we are\r\n looking for hasn't been loaded yet. Otherwise, MetadataDecoder\r\n would have found the type in TypeDefRowIdToTypeMap based on its \r\n TypeDef row id. \r\n ":"\r\n 查找此模块中定义的类型。\r\n 仅当我们是类型时，才会调用此方法\r\n 寻找尚未加载。否则，元二核编码器\r\n 会根据其typedefrowidtotypemap在其中找到类型\r\n Typedef行ID。\r\n \r\n","\r\n  Looks up a localized string similar to 'Do' must end with a matching 'Loop'..\r\n":"\r\n  查找类似于“ do”的本地化字符串必须以匹配的“循环”结尾。\r\n\r\n","\r\n The WithStatement that begins the With...End With block.\r\n ":"\r\n 以...以块结尾开始的效力。\r\n \r\n"," with ref specific exclusions\r\n            ":" 带有参考具体排除\r\n            \r\n"," declaration expression for a variable which\r\n            needs to be removed, we need to turn it into a plain ":" 变量的声明表达式\r\n            需要删除，我们需要将其变成平原\r\n","\r\n Must remain in sync with ":"\r\n 必须保持与\r\n","\r\n Describes a single variable of the form \"[x [As Type] =] expression\" for use in\r\n query expressions.\r\n ":"\r\n 描述“ [x [as type] =]表达式”的形式的单个变量用于\r\n 查询表达式。\r\n \r\n","If set to true the error will be attached to the first skipped token of the incomplete member.":"如果设置为true，则错误将附加到不完整成员的第一个跳过令牌上。\r\n",", otherwise the exception is propagated to the caller.\r\n            ":"，否则将异常传播给呼叫者。\r\n            \r\n","Populate switch":"填充开关\r\n","\r\n The base class to represent a namespace imported from a PE/module.\r\n Namespaces that differ only by casing in name are merged.\r\n ":"\r\n 代表从PE/模块导入的名称空间的基类。\r\n 仅通过名称中的外壳而有所不同的名称空间是合并的。\r\n \r\n","\r\n            This is the top level 'Install Nuget Package' code action we show in \r\n            the lightbulb.  It will have children to 'Install Latest', \r\n            'Install Version 'X' ..., and 'Install with package manager'.\r\n            ":"\r\n            这是我们在\r\n            电灯泡。它将有孩子“安装最新”，\r\n            “安装版本” X'...和“与软件包管理器一起安装”。\r\n            \r\n","The \"F\" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.FullDateTimePattern property. For example, the custom format string for the invariant culture is \"dddd, dd MMMM yyyy HH:mm:s ...":"“ F”标准格式指定符表示由当前DateTimeFormatInfo.fulldateTimePattern属性定义的自定义日期和时间格式字符串。例如，不变文化的自定义格式字符串是“ DDDD，DD MMMM YYYY HH：MM：S ...\r\n","Module initializer method '{0}' must not be generic and must not be contained in a generic type":"模块初始化器方法'{0}'不得是通用的，不得包含在通用类型中\r\n","A hashcode representing this instance.":"表示此实例的哈希码。\r\n","Apply language/framework type preferences":"应用语言/框架类型偏好\r\n"," is e.g. ":" 是\r\n","\r\n            All symbols added in changed documents.\r\n            ":"\r\n            所有符号都在更改的文档中添加。\r\n            \r\n","\r\n            We no longer show awaitable usage text in SignatureHelp, but IntelliCode expects this\r\n            method to exist.\r\n            ":"\r\n            我们不再在SignatureHelp中显示等待的用法文本，但是Intellicode期望这一点\r\n            存在的方法。\r\n            \r\n","\r\n The \")\" token\r\n ":"\r\n “）”令牌\r\n \r\n","\r\n Given a method block syntax get the corresponding method, property or event symbol.\r\n ":"\r\n 给定方法块语法获取相应的方法，属性或事件符号。\r\n \r\n","\r\n Indicates that this binder is being used to answer SemanticModel questions (i.e. not\r\n for batch compilation).\r\n ":"\r\n 表明该粘合剂被用于回答semanticmodel问题（即\r\n 用于批处理）。\r\n \r\n","\r\n  Looks up a localized string similar to 'Option Explicit' can be followed only by 'On' or 'Off'..\r\n":"\r\n  查找类似于“选项emplicit”的本地化字符串，只能在“ on”或“ off”中。\r\n\r\n","\r\n If true, the identifier was enclosed in brackets, such as \"[End]\".\r\n ":"\r\n 如果是正确的，则标识符被封闭在括号中，例如“ [end]”。\r\n \r\n","\r\n This class represent a compiler generated method of a delegate type that is based upon source delegate or event delegate declaration.\r\n ":"\r\n 此类代表基于源代表或事件委托声明的委托类型的编译器生成的方法。\r\n \r\n","\r\n Decode a parameter list from a delegate declaration into a list of parameter symbols.\r\n ":"\r\n 将参数列表从委托声明解码为参数符号列表。\r\n \r\n","\r\n            For completion and quickinfo in linked files, we compare symbols from different documents\r\n            to determine if they are similar enough for us to suppress the platform dependence\r\n            warning icon. We consider symbols equivalent if they have the same name.\r\n            ":"\r\n            要完成和链接文件中的QuickInfo，我们比较了不同文档的符号\r\n            确定它们是否足够相似，使我们能够抑制平台依赖性\r\n            警告图标。如果符号具有相同的名称，我们认为它们等效。\r\n            \r\n","Invalid option '{0}' for /nullable; must be 'disable', 'enable', 'warnings' or 'annotations'":"无效选项'{0}'for /nullable;必须“禁用”，“启用”，“警告”或“注释”\r\n"," \r\n True to ignore any differences of nodes inside bodies of methods, operators, constructors and accessors, and field and auto-property initializers, \r\n otherwise all nodes and tokens must be equivalent. \r\n ":" \r\n 忽略方法，操作员，构造函数和访问者的体内节点的任何差异\r\n 否则，所有节点和令牌都必须等效。\r\n \r\n","\r\n Represents an Await expression.\r\n ":"\r\n 代表一个正在等待的表达。\r\n \r\n","Node to bind.":"结合节点。\r\n","\r\n Return the first Class, Structure, or Interface declaration with explicit interfaces\r\n to use for checking interface constraints. Other type declarations (Modules) are\r\n ignored since other errors will have been reported if those types include interfaces.\r\n ":"\r\n 返回带有显式接口的第一类，结构或接口声明\r\n 用于检查接口约束。其他类型的声明（模块）是\r\n 如果这些类型包括接口，则忽略了其他错误。\r\n \r\n","Builder to place exactly-matched overridden member candidates in. ":"建造者将精确匹配的覆盖成员候选人放在其中。\r\n","Adding {0} into a {1} requires restarting the application.":"将{0}添加到{1}中需要重新启动应用程序。\r\n","\r\n Determines if two trees are the same, disregarding trivia differences.\r\n ":"\r\n 确定两棵树是否相同，无视琐事差异。\r\n \r\n","\r\n The operator used in the assignment statement. One of \"=\", \"+=\", \"-=\", \"*=\",\r\n \"/=\", \"\\=\", \"^=\", \"&=\", \"<<=\" or \">>=\".\r\n ":"\r\n 分配语句中使用的操作员。一个“ =”，“”+=“，”，“  -  =”，“*=”，\r\n “/=”，“ \\ =”，“^=”，“”，“”，“ << =”或“ >> =”。\r\n \r\n","\r\n Gets the core compilation options.\r\n ":"\r\n 获取核心汇编选项。\r\n \r\n","\r\n Forces binding and decoding of attributes.\r\n NOTE: Conditional symbols on the overridden method must be inherited by the overriding method, but the native VB compiler doesn't do so. We maintain compatibility.\r\n ":"\r\n 属性结合和解码的力。\r\n 注意：覆盖方法上的条件符号必须由覆盖方法继承，但是本机VB编译器不这样做。我们保持兼容性。\r\n \r\n","Only one compilation unit can have top-level statements.":"只有一个汇编单元可以具有顶级语句。\r\n","\r\n A list of additional query operators. It may be empty.\r\n ":"\r\n 附加查询操作员的列表。它可能是空的。\r\n \r\n","\r\n Property controls Roslyn data flow analysis features which are disabled in command-line \r\n compiler mode to maintain backward compatibility (mostly diagnostics not reported by Dev11), \r\n but *enabled* in flow analysis API\r\n ":"\r\n 属性控制Roslyn数据流分析特征，这些功能被命令行禁用\r\n 编译器模式以保持向后兼容性（主要是Dev11报告的诊断），\r\n 但是 *启用 *在流分析中API中\r\n \r\n","The siblings.":"兄弟姐妹。\r\n","The best type that can be found, or and ErrorTypeSymbol if no reasonable type can be found.":"如果找不到合理的类型，则可以找到的最佳类型，也可以找到errortypesymbol。\r\n","all numbers":"所有数字\r\n","\r\n            The location in the source where the file header was expected to start.\r\n            ":"\r\n            源文件头预期开始的位置。\r\n            \r\n","\r\n  Looks up a localized string similar to Property missing 'End Property'..\r\n":"查找类似于属性缺少“最终属性”的本地化字符串。\r\n\r\n","Operator '{0}' cannot be used here due to precedence. Use parentheses to disambiguate.":"由于优先级，在这里无法使用运算符'{0}'。使用括号来消除歧义。\r\n"," will return True.\r\n ":" 将返回真。\r\n \r\n","\r\n We use this to restore the old set of pending branches and labels after visiting a construct that contains nested statements.\r\n ":"\r\n 访问包含嵌套语句的构造后，我们使用它来恢复旧的待处理分支和标签。\r\n \r\n","Make {0} return Task instead of void.":"使{0}返回任务而不是void。\r\n","\r\n Binding state used by the rewriter for XContainer derived types.\r\n ":"\r\n 重写器使用的绑定状态用于Xcontainer派生类型。\r\n \r\n","\r\n            The offset within ":"\r\n            内部的偏移\r\n","\r\n The value for the WhereKeyword property.\r\n ":"\r\n WhereKeyword属性的值。\r\n \r\n","\r\n  True if 'Shadows' is explicitly specified in method's declaration.\r\n  ":"\r\n  正确，如果在方法的声明中明确指定了“阴影”。\r\n  \r\n","\r\n A collection initializer syntax node is not always treated as a VB expression syntax node\r\n in case it's part of a CollectionInitializer (outer most or top level initializer).\r\n ":"\r\n 收集初始化器语法节点并不总是被视为VB表达语法节点\r\n 如果它是CollectionInitializer（最外部或顶级初始化器）的一部分。\r\n \r\n","\r\n  Looks up a localized string similar to 'Await' requires that the type '{0}' have a suitable GetAwaiter method..\r\n":"\r\n  查找类似于“等待”的本地化字符串，要求类型'{0}'具有合适的Getawaiter方法。\r\n\r\n","\r\n Should be kept in sync with OverloadResolution.MatchArguments, which populates \r\n data this function operates on.\r\n ":"\r\n 应与OrforloadResolution.matcharguments保持同步\r\n 数据此函数正在运行。\r\n \r\n","\r\n            Holds information required to display and navigate to individual references\r\n            ":"\r\n            保留显示和导航到单个参考所需的信息\r\n            \r\n"," returns null) opens the PDB embedded in the assembly, if present.\r\n            ":" 返回null）打开嵌入在组件中的PDB，如果存在。\r\n            \r\n","\r\n True if this symbol has a special name (metadata flag SpecialName is set).\r\n ":"\r\n 是的，如果此符号具有特殊名称（设置了元数据标志SpecialName）。\r\n \r\n","\r\n Returns True for MyTemplate automatically added by compiler.\r\n ":"\r\n 由编译器自动添加的myTemplate返回。\r\n \r\n","Using directives must be placed outside of a namespace declaration":"使用指令必须放置在命名空间声明之外\r\n","\r\n Convenience helper called by subclasses to add a synthesized attribute to a collection of attributes.\r\n ":"子类调用的便利助手将合成的属性添加到属性集合中。\r\n \r\n"," \r\n            where at least one (but not necessarily more) of the parameters should be treated as a\r\n            pattern.\r\n            ":" \r\n            其中至少一个（但不一定更多）应将参数视为\r\n            图案。\r\n            \r\n","\r\n Represents the \"Else\" statement that begins an \"Else\" block.\r\n ":"\r\n 表示开始“ else”块的“ else”语句。\r\n \r\n","\r\n Emits all initializers that match indices on the stack recursively.\r\n \r\n Example: \r\n  if array has [0..2, 0..3, 0..2] shape\r\n  and we have {1, 2} indices on the stack\r\n  initializers for \r\n              [1, 2, 0]\r\n              [1, 2, 1]\r\n              [1, 2, 2]\r\n \r\n  will be emitted and the top index will be pushed off the stack \r\n  as at that point we would be completely done with emitting initializers \r\n  corresponding to that index.\r\n ":"\r\n 排放所有匹配堆栈上索引索引的初始化器。\r\n \r\n 例子：\r\n  如果数组具有[0..2，0..3，0..2]形状\r\n  我们在堆栈上有{1，2}索引\r\n  初始化器\r\n              [1，2，0]\r\n              [1，2，1]\r\n              [1，2，2]\r\n \r\n  将发射，顶部索引将被推开\r\n  到那时，我们将完全完成发射初始化器\r\n  对应于该索引。\r\n \r\n","\r\n            The character associated with the triggering action.\r\n            ":"\r\n            与触发动作相关的角色。\r\n            \r\n"," is provided, the name in the new node might be qualified with this new namespace instead.\r\n            ":" 提供了，新节点中的名称可能会带有此新名称空间的资格。\r\n            \r\n","\r\n            Return all no location diagnostics for the given project stored in this state\r\n            ":"\r\n            返回所有存储在此状态的给定项目的位置诊断\r\n            \r\n"," if the node is of the specified kind; otherwise, ":" 如果节点是指定类型的；否则，\r\n"," will be in this set.\r\n            This is used so we can easily tell if we should try to simplify some identifier to an\r\n            alias when we encounter it.\r\n            ":" 将在此集合中。\r\n            使用此功能，因此我们可以轻松判断是否应该尝试简化某些标识符\r\n            当我们遇到时，别名。\r\n            \r\n"," Returns True if the node specified is one of Me/MyClass/MyBase ":" 如果指定的节点是我/myclass/mybase之一，则返回true\r\n","\r\n The value for the ArgumentList property.\r\n ":"\r\n 参数清单属性的值。\r\n \r\n","general short date/time":"一般短期/时间\r\n","\r\n  Looks up a localized string similar to Namespace or type '{0}' has already been imported..\r\n":"\r\n  查找类似于名称空间或类型'{0}'的本地化字符串。\r\n\r\n","True if Option Compare Text, False if Option Compare Binary.":"如果选项比较文本，则为true，如果选项比较二进制，则false。\r\n","Mixed declarations and expressions in deconstruction":"解构中的混合声明和表达\r\n","\r\n Declaration security information associated with this type, or null if there is none.\r\n ":"\r\n 与此类型关联的声明安全信息，或者如果没有，则无效。\r\n \r\n","The concatenated value text, or an empty string if there are no tokens in the list.":"如果列表中没有令牌，则串联值文本或一个空字符串。\r\n","\r\n The \"Catch\" statement that begins the \"Catch\" block.\r\n ":"\r\n 开始“捕获”块的“捕获”语句。\r\n \r\n","\r\n The value for the ExternalChecksumKeyword property.\r\n ":"\r\n 外部检查的值。\r\n \r\n","attribute target":"属性目标\r\n","\r\n The value for the TextToken property.\r\n ":"\r\n TextToken属性的价值。\r\n \r\n","\r\n Syntax references of all parts of the type declaration. \r\n Submission and script classes are represented by their containing ":"\r\n 类型声明的所有部分的语法引用。\r\n 提交和脚本类由其包含\r\n","\r\n Create symbols for nested types and initialize m_Types map.\r\n ":"为嵌套类型创建符号并初始化M_TYPES映射。\r\n \r\n",".\r\n            This will not have any side effect.\r\n            ":"。\r\n            这将没有任何副作用。\r\n            \r\n","\r\n Subclasses override this if they want to take special actions on processing a goto\r\n statement, when both the jump and the label have been located.\r\n ":"\r\n 如果他们想采取特殊措施处理goto，子类要覆盖这一点\r\n 声明，当跳跃和标签都已经找到时。\r\n \r\n","The label statement.":"标签语句。\r\n","The \"F\" custom format specifier represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value. Nothing is displayed if the digit is zero.\r\n            \r\n            If the \"F\" format specifier is used without o ...":"“ F”自定义格式指定符表示秒数中最重要的数字；也就是说，它代表日期和时间值的十分之一。如果数字为零，则什么都不会显示。\r\n            \r\n            如果“ F”格式指定符无需o ...\r\n","To cancel document operations":"取消文档操作\r\n"," if this instance is overrides; otherwise, ":" 如果此实例被覆盖；否则，\r\n","\r\n Represents a \"From\" query operator. If this is the beginning of a query, the\r\n Source will be Nothing. Otherwise, the Source will be the part of the query to\r\n the left of the From.\r\n ":"\r\n 代表“来自”查询操作员。如果这是查询的开始，\r\n 来源将一无所有。否则，源将是查询的一部分\r\n 从左开始。\r\n \r\n","\r\n Returns true if this symbol is a namespace. If its not a namespace, it must be a type.\r\n ":"\r\n 如果此符号是名称空间，则返回true。如果它不是名称空间，则必须是一种类型。\r\n \r\n","\r\n            If there is more than one constructor, the suggested actions will be split into two sub menus,\r\n            one for regular parameters and one for optional. This boolean is used by the Title property\r\n            to determine if the code action should be given the complete title or the sub menu title\r\n            ":"\r\n            如果有多个构造函数，则建议的操作将拆分为两个子菜单,\r\n            一个用于常规参数，一个用于可选参数。 此布尔值由Title属性使用\r\n            确定代码操作是否应该被赋予完整的标题或子菜单标题\r\n            \r\n","utc hour offset (1-2 digits)":"UTC小时偏移（1-2位数）\r\n","\r\n            Matches positive and negative numeric literals.\r\n            ":"\r\n            匹配正数和负数字文字。\r\n            \r\n"," Checks if the text span passed is inside the region ":" 检查文本跨度是否在区域内\r\n","\r\n  Looks up a localized string similar to Element is missing an end tag..\r\n":"\r\n  查找类似于元素的本地化字符串缺少结束标签。\r\n\r\n","\r\n Represents an XML namespace prefix of the form 'prefix:' as in xml:ns=\"\".\r\n ":"\r\n 表示'前缀：'的XML名称空间前缀为XML：ns =“”。\r\n \r\n","The namespace symbol that was declared.":"声明的名称空间符号。\r\n","The selected code is inside an unsafe context.":"所选代码在不安全的上下文中。\r\n","This construct does not capture the substring that is matched by a subexpression:\r\n            \r\n            The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.\r\n            \r\n            If a regular expres ...":"该构造不会捕获由子表达匹配的子字符串：\r\n            \r\n            当量化器应用于组时，通常使用非捕捉组构造，但是组捕获的子字符串毫无兴趣。\r\n            \r\n            如果定期出现...\r\n","\r\n            Document contains errors that block EnC analysis.\r\n            ":"\r\n            文档包含阻止ENC分析的错误。\r\n            \r\n","\r\n An abstract base class for all node classes that define expressions.\r\n ":"\r\n 所有定义表达式的节点类的抽象基类。\r\n \r\n","\r\n Symbols representing constructed generic method that is contained within constructed generic type.\r\n For example: A(Of Integer).B(Of Integer), A(Of Integer).B.C(Of Integer).\r\n ":"\r\n 代表构造的通用方法的符号包含在构造的通用类型中。\r\n 例如：a（integer）.b（integer），a（integer）.b.c（整数）。\r\n \r\n","Making a method an iterator requires restarting the application.":"制作方法迭代器需要重新启动应用程序。\r\n","\r\n            temporary symbol until we have a symbol that can hold onto both local and parameter symbol\r\n            ":"\r\n            临时符号，直到我们有一个可以保留本地和参数符号的符号\r\n            \r\n"," is specified (not default), the fix would be:\r\n                1. qualify the reference with new namespace and mark it for simplification, or\r\n                2. find and mark the qualified reference for simplification.\r\n            Otherwise, there would be no namespace replacement.\r\n            ":" 已指定（不是默认），修复程序将是：\r\n                1.使用新名称空间限定参考并标记以进行简化或\r\n                2.查找并标记合格的参考以进行简化。\r\n            否则，将不会更换名称空间。\r\n            \r\n","Could not extract interface: The type does not contain any member that can be extracted to an interface.":"无法提取接口：该类型不包含任何可以提取到接口的成员。\r\n","New identifier token":"新标识符令牌\r\n","The \"s\" custom format specifier represents the seconds as a number from 0 through 59. The result represents whole seconds that have passed since the last minute. A single-digit second is formatted without a leading zero.\r\n            \r\n            If the \"s\" format specifier is use ...":"“ S”自定义格式指定符表示秒为0到59的数字。结果表示自最后一分钟以来已经过去的整个秒。单位秒的格式不带领先的零。\r\n            \r\n            如果“ S”格式指定符使用...\r\n","\r\n Scan a quoted string\r\n ":"\r\n 扫描引用的字符串\r\n \r\n","Generate all":"生成全部\r\n","\r\n Represents a type parameter on a generic type declaration.\r\n ":"\r\n 表示通用类型声明上的类型参数。\r\n \r\n","\r\n Determines what type of conversion, if any, would be used if a given expression was converted to a given\r\n type.\r\n ":"\r\n 确定如果将给定表达式转换为给定，将使用哪种类型的转换（如果有）使用\r\n 类型。\r\n \r\n","Assign to '{0}'":"分配给'{0}'\r\n","All the accessors of the given kind implemented by this property.":"该属性实施的给定类型的所有登录器。\r\n","\r\n            If we do report cached data, we inform the user of this so they know the results may be\r\n            incomplete or inaccurate and that they can try again later if necessary.\r\n            ":"如果我们确实报告了缓存的数据，我们将向用户通知用户，因此他们知道结果可能是\r\n            不完整或不准确，并且在必要时可以再试一次。\r\n            \r\n","\r\n            Provides completion for uncommon unnamed symbols, like conversions, indexer and operators.  These completion \r\n            items will be brought up with ":"\r\n            为不命名的符号（例如转换，索引器和操作员）提供完整的完整。这些完成\r\n            物品将带来\r\n","\r\n Returns a copy of this with the [Default] property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 返回此副本，其中[默认]属性更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n Perform ComClass specific validation and prepare for metadata generation.\r\n ":"\r\n 执行特定的验证并准备元数据生成。\r\n \r\n","\r\n Given a DocumentationCommentTriviaSyntax and the symbol, return the \r\n full documentation comment text.\r\n ":"\r\n 鉴于DocumentationCommentTriviaSyntax和符号，请返回\r\n 完整的文档评论文本。\r\n \r\n"," for each Node it considers (see above).\r\n            E.g. extracts initializer expressions from declarations and assignments, Property declaration from any header node, etc.\r\n            ":" 对于每个节点，它都认为（请参见上文）。\r\n            例如。从声明和作业，任何标题节点的属性声明等提取初始化器表达式，等等。\r\n            \r\n","\r\n The generic argument list.\r\n ":"\r\n 通用参数列表。\r\n \r\n","Record member '{0}' must be private.":"记录成员'{0}'必须是私有的。\r\n","\r\n Checks for well known member and reports diagnostics if the member is Nothing or has UseSiteError.\r\n Returns True in case diagnostics was actually reported\r\n ":"\r\n 检查众所周知的成员并报告诊断是否没有成员或使用使用。\r\n 如果实际上报告了诊断，则返回为true\r\n \r\n","\r\n Should this lambda be treated as a single line lambda?\r\n ":"\r\n 这个lambda是否应该被视为单线lambda？\r\n \r\n","\r\n Requires less computation than ":"比计算要少于\r\n","The switch expression does not handle all possible values of its input type (it is not exhaustive).":"开关表达式无法处理其输入类型的所有可能值（并不详尽）。\r\n","\r\n  Looks up a localized string similar to 'Set' statement must end with a matching 'End Set'..\r\n":"\r\n  查找类似于“集合”语句的本地化字符串必须以匹配的“结束集”结尾。\r\n\r\n","\r\n The value for the Property property.\r\n ":"\r\n 财产属性的值。\r\n \r\n","\r\n  Looks up a localized string similar to XML DTDs are not supported..\r\n":"\r\n  查找类似于XML DTD的本地化字符串。\r\n\r\n","\r\n A statement that declares an operator. If this operator has a body, this\r\n statement will be the Begin of a BlockStatement with\r\n Kind=MethodDeclarationBlock, and the body of the method will be the Body of\r\n that BlockStatement.\r\n ":"\r\n 宣布操作员的声明。如果该操作员有一个身体，那么\r\n 语句将是一个封锁的开始\r\n kint = methoddeclaration block，该方法的主体将是\r\n 那个块。\r\n \r\n","sortable date/time":"可排序日期/时间\r\n","\r\n Internal helper class to replace local symbols in bound locals of a given bound tree.\r\n ":"\r\n 内部帮助器类，用于替换给定绑定树的绑定局部中的本地符号。\r\n \r\n","The first operand of an overloaded shift operator must have the same type as the containing type or its type parameter constrained to it, and the type of the second operand must be int":"超载移位操作员的第一操作数必须具有与包含类型或其类型的类型参数相同的类型，第二个操作数的类型必须为int\r\n","\r\n  Looks up a localized string similar to 'For' loop control variable cannot be of type '{0}' because the type does not support the required operators..\r\n":"\r\n  查找类似于“ for” loop控件变量的本地化字符串不能为'{0}'的类型，因为该类型不支持所需的操作员。\r\n\r\n","\r\n Returns a copy of this with the HashToken property changed to the specified\r\n value. Returns this instance if the specified value is the same as the current\r\n value.\r\n ":"\r\n 将其返回其中的副本，并将其更改为指定的\r\n 价值。如果指定的值与当前相同，则返回此实例\r\n 价值。\r\n \r\n","\r\n            the generated method node that contains the extracted code.\r\n            ":"\r\n            包含提取的代码的生成方法节点。\r\n            \r\n","The conversion from Current return type to the type of the controlVariable.":"从当前返回类型转换为控制变量的类型。\r\n","\r\n Search the declared methods of a type for one that could be an implicit implementation\r\n of a given interface method (depending on interface declarations). It is assumed that the implementing\r\n type is not a source type.\r\n ":"\r\n 搜索可能是隐式实现的一种类型的声明方法\r\n 给定的接口方法（取决于接口声明）。假定实施\r\n 类型不是源类型。\r\n \r\n","Type of global object.":"全局对象的类型。\r\n","\r\n Represents a type parameter on a source type (as opposed to a method).\r\n ":"\r\n 表示源类型上的类型参数（与方法相反）。\r\n \r\n","\r\n Determine whether there is any substitution of type parameters that will\r\n make two types identical.\r\n ":"\r\n 确定是否有任何类型参数的替代\r\n 使两种类型相同。\r\n \r\n","\r\n            in it.  If so, those names will be replaced with ":"\r\n            在里面。  如果是这样，这些名称将被替换为 \r\n","<member name> =":"<成员名称> =\r\n","\r\n This is an entry point for the Binder. Its purpose is to add names of viable extension methods declared \r\n in this type to nameSet parameter.\r\n ":"\r\n 这是粘合剂的入口点。其目的是添加声明的可行扩展方法的名称\r\n 在这种类型中，到姓名参数。\r\n \r\n","\r\n            Operations that represent Parameter has argument but the argument is not identifier or literal.\r\n            For these parameters they are considered to be put into a declaration statement after inlining.\r\n            Note: params array could maps to multiple/zero arguments.\r\n            Example:\r\n            Before:\r\n            void Caller(bool x)\r\n            {\r\n                Callee(Foo(), x ? Foo() : Bar())\r\n            }\r\n            void Callee(int a, int b)\r\n            {\r\n                DoSomething(a, b);\r\n            }\r\n            After:\r\n            void Caller(bool x)\r\n            {\r\n                int a = Foo();\r\n                int b = x ? Foo() : Bar();\r\n                DoSomething(a, b);\r\n            }\r\n            void Callee(int a, int b)\r\n            {\r\n                DoSomething(a, b);\r\n            }\r\n            ":"\r\n            代表参数的操作具有参数，但该参数不是标识符或文字。\r\n            对于这些参数，它们被认为是在内联后被认为是声明声明。\r\n            注意：参数数组可以映射到多/零参数。\r\n            例子：\r\n            前：\r\n            无效呼叫者（bool x）\r\n            {\r\n                callee（foo（），x？foo（）：bar（））\r\n            }\r\n            void callee（int a，int b）\r\n            {\r\n                dosomething（a，b）;\r\n            }\r\n            后：\r\n            无效呼叫者（bool x）\r\n            {\r\n                int a = foo（）;\r\n                int b = x？ foo（）：bar（）;\r\n                dosomething（a，b）;\r\n            }\r\n            void callee（int a，int b）\r\n            {\r\n                dosomething（a，b）;\r\n            }\r\n            \r\n","discards":"丢弃\r\n","The using directive for '{0}' appeared previously as global using":"“ {0}”的使用指令先前以全局形式出现\r\n","\r\n  Looks up a localized string similar to '{0}' is not accessible in this context because it is '{1}'..\r\n":"\r\n  在此上下文中查找类似于'{0}'的本地化字符串，因为它是'{1}'..\r\n\r\n","\r\n  Looks up a localized string similar to 'ParamArray' cannot be applied to the first parameter of an extension method. The first parameter specifies which type to extend..\r\n":"\r\n  查找类似于“ paramarray”的本地化字符串不能应用于扩展方法的第一个参数。第一个参数指定要扩展的类型。\r\n\r\n","\r\n The value for the IfOrElseIfKeyword property.\r\n ":"\r\n IforelSeifKeyWord属性的值。\r\n \r\n","After the In keyword in a For Each statement.":"在每个语句中的关键字之后。\r\n","\r\n Lookup an immediate (without descending into modules) member name in a namespace, \r\n returning a LookupResult that summarizes the results of the lookup. \r\n See LookupResult structure for a detailed discussion of the meaning of the results. \r\n The supplied binder is used for accessibility checks and base class suppression.\r\n ":"在名称空间中查找即时（不降为模块）成员名称，\r\n 返回查找查找结果的查找。\r\n 有关结果含义的详细讨论，请参见查找结构。\r\n 提供的粘合剂用于可访问性检查和基类抑制。\r\n \r\n","\r\n            Pretty-prints an object.\r\n            ":"\r\n            非常印刷一个对象。\r\n            \r\n","Starting state was incompatible with script.":"起始状态与脚本不相容。\r\n","Changing a field to an event or vice versa requires restarting the application.":"将字段更改为事件，反之亦然，需要重新启动应用程序。\r\n","\r\n            convert text span to node range for the flow analysis API\r\n            ":"\r\n            将文本跨度转换为流程分析API的节点范围\r\n            \r\n","\r\n Checks if the expression is a negative integer constant value.\r\n ":"\r\n 检查表达式是否为负整数常数值。\r\n \r\n"}