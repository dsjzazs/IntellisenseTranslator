{"Missing file attribute":"缺少文件属性\r\n","An obsolete parameter. Diagnostic options should now be passed with ":"过时的参数。现在应该通过\r\n","\r\n            A collection of well-known members for the current async method builder.\r\n            ":"\r\n            当前异步方法构建器的知名成员的集合。\r\n            \r\n","Static classes cannot contain destructors":"静态类不能包含损坏器\r\n","\r\n            Finds the GetResult method of an Awaiter type.\r\n            ":"\r\n            找到等待员类型的GetResult方法。\r\n            \r\n","\r\n            Nullable analysis data for methods, parameter default values, and attributes.\r\n            The key is a symbol for methods or parameters, and syntax for attributes.\r\n            The data is collected during testing only.\r\n            ":"\r\n            方法，参数默认值和属性的无效分析数据。\r\n            关键是方法或参数的符号，也是属性的语法。\r\n            数据仅在测试过程中收集。\r\n            \r\n","\r\n              Looks up a localized string similar to Field cannot have void type.\r\n            ":"\r\n              查找类似于字段的本地化字符串不能具有无效类型。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot embed interop type '{0}' found in both assembly '{1}' and '{2}'. Consider setting the 'Embed Interop Types' property to false..\r\n            ":"\r\n              查找类似于不能嵌入Interop类型'{0}'的本地化字符串，在两个汇编'{1}'和'{2}'中都找到。考虑将“嵌入Interop类型”属性设置为false。\r\n            \r\n","\r\n            but loading a smaller set of attributes if possible, to reduce circularity.\r\n            ":"\r\n            但是，如果可能的话，加载一组较小的属性，以减少圆形性。\r\n            \r\n","Type syntax to bind.":"键入绑定语法。\r\n","'{0}' cannot derive from special class '{1}'":"'{0}'不能从特殊类派生'{1}'\r\n","\r\n            CONSIDER: check this while building up InterfacesAndTheirBaseInterfaces (only in the SourceNamedTypeSymbol case).\r\n            ":"\r\n            考虑：在构建Interfaces和TheirbaseInterfaces（仅在SourcenamedTytyPeSymbol案例中）时检查此问题。\r\n            \r\n","'{0}' cannot implement '{1}' because '{2}' is a Windows Runtime event and '{3}' is a regular .NET event.":"'{0}'无法实现'{1}'，因为'{2}'是Windows运行时事件，'{3}'是常规.NET事件。\r\n","Constraint type '{0}' is not CLS-compliant":"约束类型'{0}'不符合CLS\r\n","\r\n            The set of synthesized delegates created by\r\n            this AnonymousTypeManager.\r\n            ":"\r\n            由\r\n            这个匿名者。\r\n            \r\n","Cannot use alias '{0}' with '::' since the alias references a type. Use '.' instead.":"由于别名引用了类型，因此无法使用'{0}'::'使用别名'{0}'::'。利用 '。'反而。\r\n",".  It operates as follows:\r\n             \r\n             First, an analysis of the whole method body is performed that determines which variables are\r\n             captured, what their scopes are, and what the nesting relationship is between scopes that\r\n             have captured variables.  The result of this analysis is left in ":"。它运行如下：\r\n             \r\n             首先，对整个方法主体进行了分析，以确定哪些变量是\r\n             被捕获，它们的范围是什么，以及在范围之间的嵌套关系是什么\r\n             捕获了变量。该分析的结果留在\r\n","The index of the first non-whitespace char after index start in the string up to, but not including the end index":"索引在字符串中开始的第一个非Whitespace Char的索引，但不包括结束索引\r\n","\r\n              Looks up a localized string similar to '{0}' is for evaluation purposes only and is subject to change or removal in future updates..\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串仅用于评估目的，并且可能会在以后的更新中进行更改或删除。\r\n            \r\n","Feature '{0}' is not available in C# 7.3. Please use language version {1} or greater.":"C＃7.3中不可用功能'{0}'。请使用语言版本{1}或更大。\r\n","\r\n            Walks the bound tree and adds all non compiler generated bound nodes whose syntax matches the given one\r\n            to the cache.\r\n            ":"\r\n            步行绑定的树并添加所有非编译器生成的绑定节点，其语法与给定的节点匹配\r\n            到缓存。\r\n            \r\n","\r\n            Locations[0] on lambda symbols covers the entire syntax, which is inconvenient but remains for compatibility.\r\n            For better diagnostics quality, use the DiagnosticLocation instead, which points to the \"delegate\" or the \"=>\".\r\n            ":"\r\n            lambda符号上的位置[0]涵盖了整个语法，这是不方便的，但仍然保持兼容性。\r\n            为了获得更好的诊断质量，请改用诊断定位，指向“委托”或“ =>”。\r\n            \r\n","Type of the expression over which to iterate.":"表达式的类型要迭代。\r\n","Gets the \"new\" keyword.":"获取“新”关键字。\r\n","\r\n            If the property has a SetMethod, return that.  Otherwise check the overridden\r\n            property, if any.  Repeat for each overridden property.\r\n            ":"\r\n            如果该属性具有setMethod，请返回。否则检查被覆盖\r\n            属性，如果有的话。重复每个覆盖属性。\r\n            \r\n","Option '{0}' must be an absolute path.":"选项'{0}'必须是绝对路径。\r\n","\r\n              Looks up a localized string similar to The first operand of an 'as' operator may not be a tuple literal without a natural type..\r\n            ":"\r\n              查找类似于“ AS”操作员的第一操作数类似的本地化字符串，如果没有天然类型，则可能不是元组。\r\n            \r\n"," instances.\r\n            Used by method type inference and best common type only.\r\n            ":" 实例。\r\n            通过方法类型推理和最佳常见类型使用。\r\n            \r\n","#warning: '{0}'":"#warning：'{0}'\r\n","Candidate instance constructors of type ":"类型的候选实例构造函数\r\n","'{0}' in explicit interface declaration is not found among members of the interface that can be implemented":"在可以实现的接口成员中找不到显式接口声明中的'{0}'\r\n","\r\n             Must be called only after ":"\r\n             必须只在\r\n"," for testing purposes,\r\n            which does not verify that the containing symbol matches the original containing symbol.\r\n            ":" 出于测试目的，\r\n            它不能验证包含符号是否匹配原始包含符号。\r\n            \r\n","\r\n            This function is only needed for SemanticModel to perform binding for erroneous cases.\r\n            ":"\r\n            SemanticModel仅需要对错误的情况进行绑定。\r\n            \r\n","\r\n              Looks up a localized string similar to Local '{0}' or its members cannot have their address taken and be used inside an anonymous method or lambda expression.\r\n            ":"\r\n              查找类似于本地'{0}'的本地化字符串，或者其成员无法在匿名方法或lambda表达式中使用其地址。\r\n            \r\n","SyntaxToken representing the name of the identifier of the generic name.":"Syntaxtoken表示通用名称标识符的名称。\r\n","Create a Range object starting from first element in the collection to the end Index.":"创建一个从集合中的第一个元素到结束索引的范围对象。\r\n","\r\n            If this is a tuple type symbol, returns the symbol for its underlying type.\r\n            Otherwise, returns null.\r\n            ":"\r\n            如果这是元组类型的符号，请返回其基础类型的符号。\r\n            否则，返回null。\r\n            \r\n","The value that the resulting string literal should have.":"由此产生的字符串文字应具有的价值。\r\n","\r\n            Null if no parameter is ref/out. Otherwise the RefKind for each parameter.\r\n            ":"\r\n            null如果没有参数为参考/输出。否则每个参数的refkind。\r\n            \r\n","A field initializer cannot reference the non-static field, method, or property '{0}'":"字段初始器不能引用非静态字段，方法或属性'{0}'\r\n","The 'l' suffix is easily confused with the digit '1' -- use 'L' for clarity":"“ l”后缀很容易与数字“ 1”相混淆 - 为了清楚地使用'l'\r\n","Cannot use a method group as an argument to a dynamically dispatched operation. Did you intend to invoke the method?":"无法将方法组用作动态调度操作的参数。您打算调用该方法吗？\r\n","\r\n            An interface representing a set of values of a specific type.  During construction of the state machine\r\n            for pattern-matching, we track the set of values of each intermediate result that can reach each state.\r\n            That permits us to determine when tests can be eliminated either because they are impossible (and can be\r\n            replaced by an always-false test) or always true with the set of values that can reach that state (and\r\n            can be replaced by an always-true test).\r\n            ":"\r\n            代表特定类型值集的接口。在建造国家机器期间\r\n            对于图案匹配，我们跟踪可以达到每个状态的每个中间结果的值集。\r\n            这使我们能够确定何时可以消除测试，因为它们是不可能的（并且可以是\r\n            由始终触及测试代替）或始终用可以达到该状态的值集（和\r\n            可以用始终真实的测试替换）。\r\n            \r\n","\r\n              Looks up a localized string similar to Array elements cannot be of type '{0}'.\r\n            ":"\r\n              查找类似于数组元素的本地化字符串不能为'{0}'类型。\r\n            \r\n","Called when the visitor visits a TypeParameterSyntax node.":"当访问者访问typeparametersyntax节点时，请致电。\r\n","SyntaxToken representing the identifier of the simple name.":"Syntaxtoken代表简单名称的标识符。\r\n","\r\n              Looks up a localized string similar to Cannot convert type '{0}' to '{1}' via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion.\r\n            ":"\r\n              通过参考转换，拳击转换，拆箱转换，包装转换或NULL类型转换，查找类似于类似于类似的本地化字符串。\r\n            \r\n","\r\n            Contains the nullable warnings and annotations context state at a given position in source,\r\n            where ":"\r\n            包含在源中给定位置处的可确定警告和注释上下文状态，\r\n            在哪里\r\n","\r\n              Looks up a localized string similar to Empty format specifier..\r\n            ":"\r\n              查找类似于空格式指示符的本地化字符串。\r\n            \r\n","\r\n            Gets the semantic information associated with a select or group clause.\r\n            ":"\r\n            获取与选择或组子句相关的语义信息。\r\n            \r\n","Represents the end of a file.":"表示文件的末尾。\r\n","\r\n            returns false then DefaultValue throws an InvalidOperationException.\r\n            ":"\r\n            返回false，然后DefaultValue抛出InvalidOperationException。\r\n            \r\n","\r\n              Looks up a localized string similar to The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly..\r\n            ":"\r\n              查找类似于两个组件的本地化字符串在发行版和/或版本号上不同。要进行统一，您必须在应用程序的.config文件中指定指令，并且必须提供适当的汇编的强名称。\r\n            \r\n","Method to search for.":"搜索方法。\r\n","\r\n            Helper class to resolve metadata tokens and signatures.\r\n            ":"\r\n            解决元数据代币和签名的帮助课。\r\n            \r\n","\r\n            The warnings for unused fields.\r\n            ":"\r\n            未使用领域的警告。\r\n            \r\n","\r\n            The most encompassed type (spec 6.4.2) from the constraints.\r\n            ":"\r\n            来自约束的最包含类型（SPEC 6.4.2）。\r\n            \r\n","\r\n            Return error code that has highest priority while calculating use site error for this symbol. \r\n            ":"\r\n            返回错误代码在计算此符号的使用站点错误时具有最高优先级。\r\n            \r\n","\r\n              Looks up a localized string similar to Wrong number of indices inside []; expected {0}.\r\n            ":"\r\n              查找类似于[]内部的错误数量索引的本地化字符串；预期{0}。\r\n            \r\n"," is\r\n            the state after visiting the method.\r\n            ":" 是\r\n            访问该方法后的状态。\r\n            \r\n","if":"如果\r\n","\r\n             Used for indexed type parameters and used locally in override/implementation checks.\r\n             When substituting a type parameter with Ignored annotation into some original type parameter\r\n             with some other annotation, the result is the annotation from the original symbol.\r\n            \r\n             T annotated + (T -> U ignored) = U annotated\r\n             T oblivious + (T -> U ignored) = U oblivious\r\n             T not-annotated + (T -> U ignored) = U not-annotated\r\n             ":"\r\n             用于索引类型参数，并在覆盖/实现检查中本地使用。\r\n             当用忽略注释替换为某个原始类型参数时\r\n             有了其他注释，结果是原始符号的注释。\r\n            \r\n             t注释 +（t-> u忽略）= u注释\r\n             t遗忘 +（t-> u忽略）= u遗忘\r\n             t不宣布 +（t-> u忽略）= u未宣布\r\n             \r\n","Type to search.":"类型要搜索。\r\n","ExpressionSyntax node representing the expression part of the invocation.":"表示调用的表达部分的表达式元素节点。\r\n","\r\n            Returns true if this symbol was declared to override a base class member; i.e., declared\r\n            with the \"override\" modifier. Still returns true if member was declared to override\r\n            something, but (erroneously) no member to override exists.\r\n            ":"\r\n            如果该符号被宣布覆盖基类成员，则返回为True；即，宣布\r\n            带有“覆盖”修饰符。如果宣布成员覆盖，仍然返回真实\r\n            但是（错误地）没有成员覆盖。\r\n            \r\n","The root of the bound tree.":"绑定树的根。\r\n","The syntax node that declares a property, indexer or an event.":"声明属性，索引器或事件的语法节点。\r\n","'{0}' defines operator == or operator != but does not override Object.Equals(object o)":"'{0}'定义operator ==或operator！=但不覆盖object.equals.equals（object o）\r\n","'{0}': virtual or abstract members cannot be private":"'{0}'：虚拟成员或抽象成员不能私有\r\n","A syntax node that represents a parsed cref syntax.\r\n            This node should not be present in the syntax tree associated with this object.":"代表解析的CREF语法的语法节点。\r\n            该节点不应存在于与此对象关联的语法树中。\r\n","The 'partial' modifier can only appear immediately before 'class', 'record', 'struct', 'interface', or a method return type.":"“部分”修饰符只能在“类”，“记录”，“ struct”，“界面”或方法返回类型之前立即出现。\r\n","Optional receiver.":"可选的接收器。\r\n","The event '{0}' is never used":"事件“ {0}”从未使用\r\n","; Override this with specific\r\n            implementation; Calling default ":";用特定的\r\n            执行;调用默认值\r\n","\r\n            The candidate method in a delegate conversion was rejected because the ref kind of its return does not match the delegate.\r\n            ":"\r\n            委托转换中的候选方法被拒绝，因为其返回的REF类型与代表不符。\r\n            \r\n","\r\n            Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.\r\n            ":"\r\n            获取语​​法列表的语法列表，即在控制传输到标签属于该部分时要执行的表示语句。\r\n            \r\n",". Essentially this is a wrapper around \r\n            another ":"。本质上，这是周围的包装纸\r\n            其他\r\n","Constructor containing the initializer.":"包含初始化器的构造函数。\r\n","\r\n             Here is the grammar being parsed:\r\n             ``` antlr\r\n             pattern\r\n             \t: declaration_pattern\r\n             \t| constant_pattern\r\n             \t| positional_pattern\r\n             \t| property_pattern\r\n             \t| discard_pattern\r\n             \t;\r\n             declaration_pattern\r\n             \t: type identifier\r\n             \t;\r\n             constant_pattern\r\n             \t: expression\r\n             \t;\r\n             positional_pattern\r\n             \t: type? '(' subpatterns? ')' property_subpattern? identifier?\r\n             \t;\r\n             subpatterns\r\n             \t: subpattern\r\n             \t| subpattern ',' subpatterns\r\n             \t;\r\n             subpattern\r\n             \t: pattern\r\n             \t| identifier ':' pattern\r\n             \t;\r\n             property_subpattern\r\n             \t: '{' subpatterns? '}'\r\n             \t;\r\n             property_pattern\r\n             \t: property_subpattern identifier?\r\n             \t;\r\n             discard_pattern\r\n             \t: '_'\r\n             \t;\r\n             ```\r\n            \r\n             Priority is the ExpressionSyntax. It might return ExpressionSyntax which might be a constant pattern such as 'case 3:' \r\n             All constant expressions are converted to the constant pattern in the switch binder if it is a match statement.\r\n             It is used for parsing patterns in the switch cases. It never returns constant pattern, because for a `case` we\r\n             need to use a pre-pattern-matching syntax node for a constant case.\r\n             ":"\r\n             下面是正在解析的语法:\r\n             \"'antlr\r\n             模式\r\n             \t：声明_pattern\r\n             \t/常量_模式\r\n             \t/位置_模式\r\n             \t/属性_模式\r\n             \t/discard_pattern\r\n             \t;\r\n             声明_模式\r\n             \t:类型标识符\r\n             \t;\r\n             常量_模式\r\n             \t：表达式\r\n             \t;\r\n             位置_模式\r\n             \t：类型？ '（'子模式？ '）'property_subpattern？ 标识符？\r\n             \t;\r\n             子模式\r\n             \t:子模式\r\n             \t/子模式','子模式\r\n             \t;\r\n             子模式\r\n             \t:图案\r\n             \t/标识符':'模式\r\n             \t;\r\n             属性_subpattern\r\n             \t：'{'子模式？ '}'\r\n             \t;\r\n             财产_模式\r\n             \t：property_subpattern标识符？\r\n             \t;\r\n             discard_pattern\r\n             \t: '_'\r\n             \t;\r\n             ```\r\n            \r\n             优先级是ExpressionSyntax。 它可能会返回ExpressionSyntax，这可能是一个常量模式，如'case3:' \r\n             如果是match语句，则所有常量表达式都将转换为switch绑定器中的常量模式。\r\n             它用于在开关情况下解析模式。 它永远不会返回常量模式，因为对于一个\"案例\"，我们\r\n             需要对常量情况使用预模式匹配语法节点。\r\n             \r\n","\r\n            Is the contained code within the syntactic span of an\r\n            iterator method?\r\n            ":"\r\n            是在一个句法跨度内包含的代码\r\n            迭代方法？\r\n            \r\n","Using of a static class":"使用静态课\r\n","Fully qualified name is too long for debug information":"完全合格的名称对于调试信息太长了\r\n","\r\n            If a method is currently being analyzed returns its parameters, returns an empty array\r\n            otherwise.\r\n            ":"\r\n            如果当前正在分析方法返回其参数，请返回一个空数组\r\n            否则。\r\n            \r\n","Field-like event '{0}' cannot be 'readonly'.":"类似现场的事件'{0}'不能'readonly'。\r\n","The position to bind at.":"绑定的位置。\r\n","\r\n            Gets the syntax node used for the in-method binder.\r\n            ":"\r\n            获取用于方法内粘合剂的语法节点。\r\n            \r\n","Type or member is obsolete":"类型或成员已过时\r\n","\r\n              Looks up a localized string similar to Asynchronous foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation.\r\n            ":"查找类似于异步的foreach语句类似的本地化字符串无法在类型的“ {0}”的变量上操作，因为它实现了'{1}'的多个实例化;尝试铸造特定的接口实例化。\r\n            \r\n","\r\n            Determine whether this assembly has been granted access to ":"\r\n            确定该议会是否已被授予访问\r\n","SyntaxToken representing the close parenthesis.":"Syntaxtkoken代表亲密的括号。\r\n","\r\n              Looks up a localized string similar to '{0}' has no applicable method named '{1}' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax..\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串，没有名为'{1}'的适用方法，但似乎具有该名称的扩展方法。扩展方法不能动态调度。考虑在没有扩展方法语法的情况下施放动态参数或调用扩展方法。\r\n            \r\n","\r\n            Switch case labels have a constant expression associated with them.\r\n            ":"\r\n            开关案例标签具有与之关联的恒定表达式。\r\n            \r\n","Assembly culture strings may not contain embedded NUL characters.":"组装文化字符串可能不包含嵌入式的nul字符。\r\n","\r\n            Check that the given variable is definitely assigned.  If not, produce an error.\r\n            ":"\r\n            检查给定变量是否已分配。如果没有，请产生错误。\r\n            \r\n","\r\n              Looks up a localized string similar to Security attribute '{0}' is not valid on this declaration type. Security attributes are only valid on assembly, type and method declarations..\r\n            ":"\r\n              在此声明类型上查找类似于安全属性'{0}'的本地化字符串。安全属性仅在汇编，类型和方法声明中有效。\r\n            \r\n","\r\n              Looks up a localized string similar to A static readonly field cannot be used as a ref or out value (except in a static constructor).\r\n            ":"\r\n              查找类似于静态可读字段的本地化字符串不能用作参考值或外出值（在静态构造函数中除外）。\r\n            \r\n","Called when the visitor visits a IndexerDeclarationSyntax node.":"当访问者访问索引删除元素nondax节点时调用。\r\n","\r\n            Synthesized namespace that contains synthesized types or subnamespaces.\r\n            All its members are stored in a table on ":"\r\n            合成的名称空间，其中包含合成类型或子名称空间。\r\n            它的所有成员都存储在桌子上\r\n"," for work to arrive.":" 工作到达。\r\n","'{0}': cannot specify both a constraint class and the 'class' or 'struct' constraint":"'{0}'：无法指定约束类别和'class'或'struct'约束\r\n","An expression tree lambda may not contain a ref, in or out parameter":"表达树lambda可能不包含REF，输入或输出参数\r\n","ArgumentListSyntax node representing the list of arguments of the invocation expression.":"grigentListsyntax节点表示调用表达式的参数列表。\r\n","Root node":"根节点\r\n"," that a break statement would branch to.\r\n            Returns null otherwise.\r\n            ":" 休息声明将分支到。\r\n            否则返回null。\r\n            \r\n","Creates a new ArrayRankSpecifierSyntax instance.":"创建一个新的arrayrankspecifiersyntax实例。\r\n","Overloaded unary operator '{0}' takes one parameter":"超载的单一操作员'{0}'采用一个参数\r\n","\r\n              Looks up a localized string similar to Unrecognized #pragma directive.\r\n            ":"\r\n              查找类似于未识别的#pragma指令的本地化字符串。\r\n            \r\n","\r\n            Lower \"using (expression) statement\" to a try-finally block.\r\n            ":"\r\n            将“使用（表达式）语句”降低到一个尝试块。\r\n            \r\n"," that can be used to retrieve analyzer config values by the generators in this driver, or ":" 可以用来通过本驱动程序中的生成器检索分析仪配置值，或\r\n","\r\n            Range is used by the C# compiler to support the range syntax.\r\n            ":"\r\n            C＃编译器使用范围来支持范围语法。\r\n            \r\n","\r\n            when adding a contextual keyword following functions must be adapted:\r\n            ":"\r\n            添加上下文关键字时，必须调整以下函数：\r\n            \r\n","\r\n              Looks up a localized string similar to Implicitly-typed local variables cannot be fixed.\r\n            ":"\r\n              查找类似于隐型本地变量类似的本地化字符串无法修复。\r\n            \r\n","(a, ...) == (b, ...)":"（a，...）==（b，...）\r\n","\r\n            The root of the scope tree for this method.\r\n            ":"\r\n            此方法的范围树的根。\r\n            \r\n","\r\n              Looks up a localized string similar to Both partial method declarations must be static or neither may be static.\r\n            ":"\r\n              查找类似于两个部分方法声明的本地化字符串必须是静态的，或者不可能是静态的。\r\n            \r\n"," on it.\r\n            This can avoid going back to syntax if we know the type definitely doesn't have an attribute\r\n            on it that could be the one specified by ":" 在上面。\r\n            如果我们知道该类型绝对没有属性，则可以避免返回语法\r\n            上面可能是\r\n","\r\n            Gets the type of this local.\r\n            ":"\r\n            获取此本地的类型。\r\n            \r\n","Creates a new ArgumentListSyntax instance.":"创建一个新的参数列表yntax实例。\r\n","\r\n            Returns true if the conversion is an implicit throw conversion.\r\n            ":"\r\n            如果转换是隐性的投掷转换，则返回true。\r\n            \r\n","Explicit interface implementation '{0}' matches more than one interface member. Which interface member is actually chosen is implementation-dependent. Consider using a non-explicit implementation instead.":"显式接口实现'{0}'匹配多个接口成员。实际选择哪个接口成员是实现依赖性的。考虑使用非明确实现。\r\n","True to treat includes as semantically meaningful (pull in contents from other files and bind crefs, etc).":"真正的治疗包括具有语义上有意义的（从其他文件中吸取内容并绑定crefs等）。\r\n","\r\n              Looks up a localized string similar to  Failed to insert some or all of included XML .\r\n            ":"\r\n              查找类似于未能插入包含的XML的本地化字符串。\r\n            \r\n","\r\n            Check if the given expression is known to *always* match, or *always* fail against the given pattern.\r\n            Return true for known match, false for known fail, and null otherwise. Used for the \"is pattern\" expression.\r\n            ":"检查给定表达式是否已知 *始终 *匹配，或 *始终 *与给定模式失败。\r\n            返回为已知匹配的归还true，false for for已知失败，否则为空。用于“ IS模式”表达式。\r\n            \r\n","Called when the visitor visits a SimpleLambdaExpressionSyntax node.":"当访问者访问SimpleLambdaexpressyntax节点时调用。\r\n","\r\n            The snapshot array should be sorted in ascending order by the position tuple element in order for the binary search algorithm to\r\n            function correctly.\r\n            ":"\r\n            快照数组应按位置元组元素的升序排序，以便二进制搜索算法\r\n            功能正确。\r\n            \r\n","Element initializer cannot be empty":"元素初始化器不能为空\r\n","Creates a new ArrowExpressionClauseSyntax instance.":"创建一个新的arrowExpressionClausesyntax实例。\r\n","\r\n            Gets a binder for a node that must be not null, and asserts\r\n            if it is not.\r\n            ":"\r\n            获取一个必须不为空的节点的粘合剂，并断言\r\n            如果不是。\r\n            \r\n","\r\n            Expression is the RHS of an assignment operation\r\n            and may be a method group.\r\n            Basically an RValue, but could be treated differently for the purpose of error reporting\r\n            ":"\r\n            表达是分配操作的RHS\r\n            并且可能是方法组。\r\n            基本上是一个rvalue，但可以以不同的目的对错误报告进行治疗\r\n            \r\n","\r\n            Optimizes local functions such that if a local function only references other local functions without closures, it itself doesn't need a closure.\r\n            ":"\r\n            优化本地功能，以便如果本地函数仅引用其他没有闭合的本地功能，则它本身不需要闭合。\r\n            \r\n","\r\n            Determine if this method requires a methodimpl table entry to inform the runtime of the override relationship.\r\n            ":"确定此方法是否需要Methodimpl表条目来告知覆盖关系的运行时。\r\n            \r\n","\r\n            Fix up a partial method by combining its defining and implementing declarations, updating the array of symbols (by name),\r\n            and returning the combined symbol.\r\n            ":"\r\n            通过组合其定义和实施声明，更新符号数组（按名称）来修复部分方法，\r\n            并返回组合符号。\r\n            \r\n","\r\n            A collection of type parameter constraints, populated when\r\n            constraints for the first type parameter is requested.\r\n            ":"\r\n            类型参数约束的集合，当\r\n            请求第一个类型参数的约束。\r\n            \r\n","\r\n            Represents a method in a RetargetingModuleSymbol. Essentially this is a wrapper around \r\n            another MethodSymbol that is responsible for retargeting symbols from one assembly to another. \r\n            It can retarget symbols for multiple assemblies at the same time.\r\n            ":"\r\n            代表retargetingModulesymbol中的一种方法。本质上，这是周围的包装纸\r\n            负责从一个组件重新定位符号到另一个组件的另一个方法符号。\r\n            它可以同时重新定位多个组件。\r\n            \r\n","\r\n            A base method symbol used as a base class for lambda method symbol and base method wrapper symbol.\r\n            ":"\r\n            基本方法符号用作Lambda方法符号和基本方法包装器符号的基类。\r\n            \r\n","\r\n            Creates a singleton separated list.\r\n            ":"\r\n            创建一个单身单独的列表。\r\n            \r\n","'{0}': a static constructor must be parameterless":"'{0}'：静态构造函数必须无参数\r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 5. Please use language version {1} or greater..\r\n            ":"\r\n              查找类似于功能'{0}'的本地化字符串。\r\n            \r\n","\r\n            We start with the current submission class and walk the submission chain back to the first submission.\r\n            The search has two phases\r\n            1) We are looking for any symbol matching the given name, arity, and options. If we don't find any the search is over.\r\n               If we find and overloadable symbol(s) (a method or an indexer) we start looking for overloads of this kind \r\n               (lookingForOverloadsOfKind) of symbol in phase 2.\r\n            2) If a visited submission contains a matching member of a kind different from lookingForOverloadsOfKind we stop \r\n               looking further. Otherwise, if we find viable overload(s) we add them into the result.\r\n               \r\n            Note that indexers are not supported in script but we deal with them here to handle errors.\r\n            ":"\r\n            我们从当前提交类开始，然后将提交链带回第一个提交。\r\n            搜索有两个阶段\r\n            1）我们正在寻找与给定名称，arity和选项匹配的任何符号。如果我们找不到任何搜索结束。\r\n               如果我们找到并超负荷符号（S）（方法或索引器），我们将开始寻找此类过载\r\n               （fookforoverloadsofkind）在第2阶段中的符号。\r\n            2）如果访问的提交包含与lookforoverloadsofkind不同的匹配成员，我们会停止\r\n               走得更远。否则，如果我们发现可行的过载，我们将它们添加到结果中。\r\n               \r\n            请注意，脚本中不支持索引器，但我们在这里处理它们以处理错误。\r\n            \r\n","\r\n             Checks whether the element name is reserved.\r\n            \r\n             For example:\r\n             \"Item3\" is reserved (at certain positions).\r\n             \"Rest\", \"ToString\" and other members of System.ValueTuple are reserved (in any position).\r\n             Names that are not reserved return false.\r\n             ":"\r\n             检查是否保留元素名称。\r\n            \r\n             例如：\r\n             “ item3”保留（在某些位置）。\r\n             “休息”，“ ToString”和System的其他成员。valuetuple被保留（任何位置）。\r\n             未保留的名称返回false。\r\n             \r\n","The extern alias '{0}' was not specified in a /reference option":"A /参考选项中未指定外部别名'{0}'\r\n","'{0}' in explicit interface declaration is not an interface":"显式接口声明中的'{0}'不是接口\r\n","\r\n              Looks up a localized string similar to ; expected.\r\n            ":"\r\n              查找类似的本地化字符串；预期的。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use an expression of type '{0}' as an argument to a dynamically dispatched operation..\r\n            ":"\r\n              查找类似于类似于“ {0}”的表达式的本地化字符串作为动态调度操作的参数。\r\n            \r\n","\r\n            This binder is for binding the initializer of an implicitly typed\r\n            local variable. While binding an implicitly typed local variable\r\n            it is illegal to refer to the variable.\r\n            ":"\r\n            该活页夹是为了绑定隐式键入的初始化器\r\n            本地变量。在绑定隐式键入本地变量的同时\r\n            引用变量是非法的。\r\n            \r\n","\r\n              Looks up a localized string similar to The abstract method '{0}' cannot be marked virtual.\r\n            ":"\r\n              查找类似于抽象方法'{0}'的本地化字符串，不能标记为虚拟。\r\n            \r\n","Member overrides obsolete member":"成员覆盖过时的成员\r\n","\r\n            Creates a token with kind XmlEntityLiteralToken.\r\n            ":"\r\n            创建一个用友善的XmlentityLiteralToken创建令牌。\r\n            \r\n","\r\n            Gets the compilation options for the C# ":"\r\n            获取C＃的汇编选项\r\n","\r\n              Looks up a localized string similar to A method with vararg cannot be generic, be in a generic type, or have a params parameter.\r\n            ":"\r\n              查找类似于带有vararg方法的局部字符串，不能是通用的，是通用类型或具有参数。\r\n            \r\n","Creates a new GroupClauseSyntax instance.":"创建一个新的groupClausesyntax实例。\r\n","\r\n            Lookup a type defined in this module.\r\n            This method will be called only if the type we are\r\n            looking for hasn't been loaded yet. Otherwise, MetadataDecoder\r\n            would have found the type in TypeDefRowIdToTypeMap based on its \r\n            TypeDef row id. \r\n            ":"\r\n            查找此模块中定义的类型。\r\n            仅当我们是类型时，才会调用此方法\r\n            寻找尚未加载。否则，元二核编码器\r\n            会根据其typedefrowidtotypemap在其中找到类型\r\n            Typedef行ID。\r\n            \r\n","Tuples":"元组\r\n","\r\n            A set of address-of expressions for which the operand is not definitely assigned.\r\n            ":"\r\n            一套不确定操作数的表达式地址。\r\n            \r\n","\r\n            Holds the information for an element-wise comparison (like ":"\r\n            持有元素比较的信息（例如\r\n","\r\n            Returns true if the local symbol was compiler generated.\r\n            ":"\r\n            如果本地符号是编译器生成的，则返回true。\r\n            \r\n","\r\n              Looks up a localized string similar to Expected disable or restore after #pragma warning.\r\n            ":"\r\n              在#Pragma警告后查找类似于预期禁用或还原的本地化字符串。\r\n            \r\n","Creates a new ConversionOperatorMemberCrefSyntax instance.":"创建一个新的ConversionOperatorMemberCrefsyntax实例。\r\n","\r\n            Produces a pessimistic list of spans that denote the regions of text in this tree that\r\n            are changed from the text of the old tree.\r\n            ":"\r\n            产生一个悲观的跨度清单，表示这棵树中文本区域\r\n            从旧树的文字改变了。\r\n            \r\n","anonymous types":"匿名类型\r\n","\r\n            Generate a switch dispatch for a contiguous sequence of dag nodes if applicable.\r\n            Returns true if it was applicable.\r\n            ":"\r\n            如果适用，则生成一个连续的dag节点序列的开关调度。\r\n            如果适用，则返回true。\r\n            \r\n","\r\n            Substitutions performed so far (or null for none).\r\n            Keys are type parameters, values are types (possibly type parameters).\r\n            Will be updated with new substitutions by the callee.\r\n            Should be ignored when false is returned.\r\n            ":"\r\n            到目前为止执行的替换（或无效）。\r\n            密钥是类型参数，值是类型（可能是类型参数）。\r\n            Callee将以新的替换更新。\r\n            返回错误时应忽略。\r\n            \r\n","\r\n              Looks up a localized string similar to A ref or out parameter cannot have a default value.\r\n            ":"\r\n              查找类似于REF或参数的本地化字符串不能具有默认值。\r\n            \r\n","\r\n             Rewrite ":"\r\n             改写\r\n","\r\n            Parse a bracketed parameter list.\r\n            ":"\r\n            解析一个包围参数列表。\r\n            \r\n","\r\n            Indexes of the parameters that will be passed to the constructor of the interpolated string handler type\r\n            when an interpolated string handler conversion occurs. These indexes are ordered in the order to be passed\r\n            to the constructor.\r\n            ":"\r\n            将传递给插值字符串处理程序类型的构造函数的参数的索引\r\n            当发生插值字符串处理程序转换时。这些索引按要通过的顺序订购\r\n            到构造函数。\r\n            \r\n","Optional parameters must appear after all required parameters":"所有必需参数后必须出现可选参数\r\n","\r\n            Gets a boolean value indicating whether there are any hidden regions in the tree.\r\n            ":"\r\n            获取布尔值，指示树上是否有任何隐藏区域。\r\n            \r\n","Explicit interface implementation '{0}' is missing accessor '{1}'":"显式接口实现'{0}'缺少登录器'{1}'\r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater..\r\n            ":"查找类似于功能“ {0}”的本地化字符串在C＃8.0中不可用。请使用语言版本{1}或更大。\r\n            \r\n"," which descends an entire ":" 下降了整个\r\n","Called when the visitor visits a InterpolatedStringExpressionSyntax node.":"当访问者访问插值sexpressynntax节点时调用。\r\n","\r\n            Uses object identity when comparing two references.\r\n            ":"\r\n            比较两个引用时使用对象身份。\r\n            \r\n","\r\n              Looks up a localized string similar to Comparison made to same variable; did you mean to compare something else?.\r\n            ":"\r\n              查找类似于与同一变量的比较类似的局部字符串；您是说要比较其他东西吗？\r\n            \r\n","\r\n            Respects the DocumentationMode at the source location.\r\n            ":"\r\n            尊重源位置的DocumentationMode。\r\n            \r\n"," false will return the same value. \r\n             - If symbol from a non-interface is returned when ":" fals会返回相同的值。\r\n              - 如果返回非接口的符号时\r\n","\r\n              Looks up a localized string similar to The EnumeratorCancellationAttribute will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable.\r\n            ":"\r\n              查找类似于EnumeratorCancellationAttribute的本地化字符串将无效。该属性仅在返回iAsyncencenumerable的异步 - 列表方法中的类型concellationToken的参数上有效。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot compile net modules when using /refout or /refonly..\r\n            ":"\r\n              查找类似于使用 /refout或 /refonly的本地化字符串，类似于无法编译网络模块。\r\n            \r\n","The syntax node that declares a member.":"声明成员的语法节点。\r\n","\r\n              Looks up a localized string similar to Single-line comment or end-of-line expected after #pragma directive.\r\n            ":"\r\n              查找类似于单线注释或#Pragma指令后预期的局部字符串。\r\n            \r\n","NOTE: Elapsed time may be less than analyzer execution time because analyzers can run concurrently.":"注意：过去的时间可能小于分析仪执行时间，因为分析仪可以同时运行。\r\n","The specified version string contains wildcards, which are not compatible with determinism. Either remove wildcards from the version string, or disable determinism for this compilation":"指定的版本字符串包含通配符，与确定性不兼容。从版本字符串中删除通配符，或禁用此汇编的确定性\r\n","\r\n            Used to decide if we need to emit call or callvirt.\r\n            It basically checks if the receiver expression cannot be null, but it is not 100% precise. \r\n            There are cases where it really can be null, but we do not care.\r\n            ":"\r\n            用于决定我们是否需要发出呼叫或通话。\r\n            它基本上检查了接收器表达式是否不能为空，但不是100％精确的。\r\n            在某些情况下，它确实可能是无效的，但我们不在乎。\r\n            \r\n","\r\n            If a namespace has Assembly or Compilation extent, it may be composed of multiple\r\n            namespaces that are merged together. If so, ConstituentNamespaces returns\r\n            all the namespaces that were merged. If this namespace was not merged, returns\r\n            an array containing only this namespace.\r\n            ":"\r\n            如果名称空间具有组装或编译范围，则可以由多个组成\r\n            合并在一起的名称空间。如果是这样，ConstituentNamespaces返回\r\n            合并的所有名称空间。如果没有合并此名称空间，请返回\r\n            仅包含此名称空间的数组。\r\n            \r\n","True if a valid XML entity was consumed.":"如果消耗了有效的XML实体，则为正确。\r\n","\r\n            Indicates that there are additional extension method candidates of the same lookup viability in cases when \r\n            none of the instance methods are applicable to the argument list.\r\n            ":"\r\n            表明在情况下还有其他相同查找可行性的候选者\r\n            实例方法都不适用于参数列表。\r\n            \r\n","\r\n              Looks up a localized string similar to Pattern missing.\r\n            ":"\r\n              查找类似于模式的本地化字符串。\r\n            \r\n","\r\n            Sets the starting state for any newly declared variables in the LocalDataFlowPass.\r\n            ":"\r\n            为LocalDataFlowPass中的任何新声明变量设置起始状态。\r\n            \r\n","Cannot return {0} '{1}' by writable reference because it is a readonly variable":"无法通过可写参考返回{0}'{1}'，因为它是一个可读的变量\r\n","\r\n            Perform IL specific optimizations (mostly reduction of local slots)\r\n            ":"\r\n            执行IL特异性优化（主要是局部插槽的减少）\r\n            \r\n","\r\n            Global imports (including those from previous submissions, if there are any).\r\n            ":"全局进口（包括先前提交的内容，如果有的话）。\r\n            \r\n","Inconsistent accessibility: parameter type '{1}' is less accessible than operator '{0}'":"不一致的可访问性：参数类型'{1}'比运算符'{0}'易于访问\r\n"," is true, set to the compilation from\r\n            which to check accessibility.":"是真的，从\r\n            要检查可访问性。\r\n","Attribute argument list syntax.":"属性参数列表语法。\r\n","Creates a new IfStatementSyntax instance.":"创建一个新的ifstatementsyntax实例。\r\n","\r\n              Looks up a localized string similar to A conditional expression cannot be used directly in a string interpolation because the ':' ends the interpolation. Parenthesize the conditional expression..\r\n            ":"\r\n              查找类似于条件表达式的本地化字符串无法直接在字符串插值中使用，因为“：”结束了插值。括号化条件表达式。\r\n            \r\n","Expression will always cause a System.NullReferenceException because the type's default value is null":"表达式将始终导致系统。NullReferenceException，因为类型的默认值为null\r\n","\r\n            Determines if this method is a valid target for UnmanagedCallersOnly, reporting an error in the given diagnostic\r\n            bag if it is not null. ":"\r\n            确定此方法是否是无管理的目标的有效目标，在给定诊断中报告错误\r\n            袋子，如果不是零。\r\n","Called when the visitor visits a ParenthesizedVariableDesignationSyntax node.":"当访客访问括号内的Variabledesignationsyntax节点时，请致电。\r\n","A store of the argument into a temp, if necessary, is added here.":"如果有必要，请在此处添加参数存储到温度。\r\n","\r\n              Looks up a localized string similar to exception filter.\r\n            ":"\r\n              查找类似于异常过滤器的局部字符串。\r\n            \r\n","Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}' (possibly because of nullability attributes).":"'{1}'的参数'{0}'类型中的参考类型的无能与隐式实现的成员'{2}'（可能是由于无效属性）。\r\n","\r\n            When binding \"C\" new C(...), return the constructor of C that was bound to, if C unambiguously\r\n            binds to a single type with at least one constructor. \r\n            ":"\r\n            当绑定“ C”新C（...）时，返回C的构造函数，如果C明确地绑定到C的构造函数\r\n            与至少一个构造函数的单一类型结合。\r\n            \r\n","\r\n              Looks up a localized string similar to Delegate '{0}' has no invoke method or an invoke method with a return type or parameter types that are not supported..\r\n            ":"\r\n              查找类似于委托'{0}'的本地化字符串，没有返回类型或不支持的参数类型的调用方法或调用方法。\r\n            \r\n","\r\n            C# language version 7.0\r\n            ":"\r\n            C＃语言版本7.0\r\n            \r\n","\r\n              Looks up a localized string similar to The switch expression does not handle some null inputs (it is not exhaustive)..\r\n            ":"\r\n              查找类似于交换机表达式的本地化字符串不会处理某些空输入（这并不详尽）。\r\n            \r\n","Called when the visitor visits a TupleElementSyntax node.":"当访客访问tupleeletementsyntax节点时，请致电。\r\n",", and then\r\n            for each such state description we decide what the test or evaluation will be at\r\n            that state, and compute the successor state descriptions.\r\n            A state description represented by a ":"， 接着\r\n            对于每个这样的状态描述，我们决定测试或评估的内容\r\n            该状态并计算后继状态描述。\r\n            由A表示的状态描述\r\n","\r\n            Returns true if position is within the given node and before the first excluded token.\r\n            ":"\r\n            如果位置在给定节点内，并且在第一个排除令牌之前，则返回true。\r\n            \r\n","\r\n            Is this a zero-based one-dimensional array, i.e. SZArray in CLR terms.\r\n            ":"\r\n            这是一个基于零的一维数组，即用CLR术语进行szarray。\r\n            \r\n","set if ":"设置如果\r\n","Invalid '{0}' value: '{1}'.":"无效的'{0}'值：'{1}'。\r\n","'{0}' does not implement '{1}'":"'{0}'不实现'{1}'\r\n","The type of one of the expressions in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.":"{0}子句中的一种表达式的类型是不正确的。键入推理在调用“ {1}'”中失败。\r\n","Gets the open bracket token.":"获取开放的托架令牌。\r\n","\r\n            Bind the constructor initializer in the context of the specified location and get semantic information\r\n            about symbols. This method is used to get semantic information about a constructor\r\n            initializer that did not actually appear in the source code.\r\n            \r\n            NOTE: This will only work in locations where there is already a constructor initializer.\r\n            ":"\r\n            在指定位置的上下文中绑定构造函数初始化器并获取语义信息\r\n            关于符号。此方法用于获取有关构造函数的语义信息\r\n            实际上并未出现在源代码中的初始化程序。\r\n            \r\n            注意：这只能在已经有构造函数初始化器的位置工作。\r\n            \r\n","a diagnostic bag for receiving the diagnostic":"用于接受诊断的诊断袋\r\n","A sequence of token to be interleaved between the nodes. The number of tokens must\r\n            be one less than the number of nodes.":"一系列代币在节点之间交织的序列。代币的数量必须\r\n            比节点的数量少一个。\r\n","\r\n              Looks up a localized string similar to Cannot infer the type of implicitly-typed discard..\r\n            ":"\r\n              查找类似于类似于隐式丢弃的类型的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}'..\r\n            ":"\r\n              查找类似于参数类型的无效类型的局部字符串，'{1}'的参数'{0}'不匹配隐式实现的成员'{2}'..\r\n            \r\n","Creates a new WhileStatementSyntax instance.":"创建一个新的whileStatementSyntax实例。\r\n","Creates a new ForEachStatementSyntax instance.":"创建一个新的foreachStattatementSyntax实例。\r\n","Will be supplemented with documentation comment diagnostics.":"将补充文档评论诊断。\r\n","\r\n              Looks up a localized string similar to Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type..\r\n            ":"\r\n              在显式接口指定中查找类似于参考类型的无效性类似的本地化字符串不匹配类型实现的接口。\r\n            \r\n","\r\n              Looks up a localized string similar to Method '{0}' with an iterator block must be 'async' to return '{1}'.\r\n            ":"\r\n              查找类似于方法'{0}'的本地化字符串，其迭代器块必须为'async'才能返回{1}'。\r\n            \r\n","\r\n            Base class for parameters can be referred to from source code.\r\n            ":"\r\n            可以从源代码中引用参数的基类。\r\n            \r\n","Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'":"不一致的可访问性：字段类型'{1}'比字段'{0}'易于访问\r\n","\r\n            Collects all the trees #load'ed by ":"\r\n            收集所有树木＃负载\r\n","\r\n            Visit all references to local functions (calls, delegate\r\n            conversions, delegate creations) and rewrite them to point\r\n            to the rewritten local function method instead of the original. \r\n            ":"\r\n            访问所有对本地功能的参考（呼叫，委托\r\n            转换，代表创作）并重写它们以指向\r\n            到重写的本地函数方法而不是原始方法。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': cannot provide arguments when creating an instance of a variable type.\r\n            ":"\r\n              在创建变量类型的实例时，查找类似于“ {0}'：类似于“ {0}”的本地化字符串。\r\n            \r\n","Whitespace is not allowed at this location.":"在此位置不允许使用空格。\r\n","Creates a new DefaultSwitchLabelSyntax instance.":"创建一个新的defaultswitchlabelsyntax实例。\r\n","\r\n            Determines if the source expression is convertible to the destination type via\r\n            any built-in or user-defined implicit conversion.\r\n            ":"\r\n            确定源表达式是否可通过\r\n            任何内置或用户定义的隐式转换。\r\n            \r\n","\r\n            Indicates if caller info is to be enabled when processing this optional parameter.\r\n            The value ":"\r\n            指示处理此可选参数时是否启用呼叫者信息。\r\n            价值\r\n","\r\n            Returns false if the specified ":"\r\n            如果指定的话返回false\r\n","/LIB option":"/lib选项\r\n","\r\n            Finds and validates the required members of an awaitable expression, as described in spec 7.7.7.1.\r\n            ":"\r\n            如规格7.7.7.1中所述，查找并验证了期待表达的所需成员。\r\n            \r\n","\r\n              Looks up a localized string similar to Filter expression is a constant.\r\n            ":"\r\n              查找类似于滤波器表达式的局部字符串是一个常数。\r\n            \r\n",").\r\n            The '!=' operator delegates to the '==' operator. It is an error if the operators are declared explicitly.\r\n             ":"）。\r\n            '！='运算符委托'=='操作员。如果明确声明操作员，这是一个错误。\r\n             \r\n","\r\n            Bound type or alias if syntax binds to a type or alias to a type in the current context and\r\n            null if syntax binds to \"var\" keyword in the current context.\r\n            ":"\r\n            如果语法在当前上下文中与类型或别名结合到类型，则绑定类型或别名\r\n            null如果语法在当前上下文中与“ var”关键字结合。\r\n            \r\n","\r\n              Looks up a localized string similar to <throw expression>.\r\n            ":"\r\n              查找类似于<throw表达式>的局部字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot return by reference a member of '{0}' because it was initialized to a value that cannot be returned by reference.\r\n            ":"\r\n              查找类似于“ {0}”成员的本地化字符串，因为它被初始化为无法通过参考返回的值。\r\n            \r\n","'{0}' is of type '{1}'. A const field of a reference type other than string can only be initialized with null.":"'{0}'是类型'{1}'的'。字符串以外的参考类型的const字段只能用null初始化。\r\n","Extern aliases for this reference.":"外部别名供此参考。\r\n","\r\n            State changes are handled by the base class. We override to find captured variables that\r\n            have been read before they were assigned and determine if the set has changed.\r\n            ":"\r\n            状态变更由基类处理。我们覆盖以找到捕获的变量\r\n            在分配之前已阅读并确定该集合是否已更改。\r\n            \r\n","\r\n            Look up the assemblies to which the given metadata type is forwarded.\r\n            ":"\r\n            查找给定的元数据类型被转发到的组件。\r\n            \r\n","\r\n            Parses the type, or pattern, right-hand operand of an is expression.\r\n            Priority is the TypeSyntax. It may return a TypeSyntax which turns out in binding to\r\n            be a constant pattern such as enum 'Days.Sunday'. We handle such cases in the binder of the is operator.\r\n            ":"\r\n            解析IS表达式的类型或模式。\r\n            优先级是型号。它可能会返回典型字符，该字符在结合到\r\n            成为诸如枚举“日子”之类的恒定模式。我们在IS操作员的活页夹中处理此类情况。\r\n            \r\n","\r\n              Looks up a localized string similar to An expression tree may not contain a tuple literal..\r\n            ":"\r\n              查找类似于表达树的局部字符串可能不包含元组文字。\r\n            \r\n","Invocation syntax node.":"调用语法节点。\r\n","\r\n            Returns true if reported an error\r\n            ":"\r\n            如果报告错误，则返回true\r\n            \r\n","The symbol for the pre-defined type or an error type if the type is not defined in the core library.":"如果在核心库中未定义该类型，则预定义类型或错误类型的符号。\r\n","\r\n            Implicit and explicit nullable conversions are described in sections 6.1.4 and 6.2.3 of the C# language specification.\r\n            ":"\r\n            在C＃语言规范的第6.1.4和6.2.3节中描述了隐式和明确的无效转换。\r\n            \r\n","Extend expression variables in initializers":"在初始化器中扩展表达变量\r\n","\r\n            Given a member declaration syntax, get the corresponding symbol.\r\n            ":"\r\n            给定一个成员声明语法，获取相应的符号。\r\n            \r\n","Parameter '{0}' must have a non-null value when exiting because parameter '{1}' is non-null.":"退出时，参数'{0}'在退出时必须具有非null值，因为参数'{1}'是非null。\r\n","A fixed buffer may only have one dimension.":"固定的缓冲区可能只有一个维度。\r\n","'{0}': cannot override; '{1}' is not an event":"'{0}'：不能覆盖； '{1}'不是事件\r\n","SearchCriteria is expected.":"预期搜索标准。\r\n","\r\n              Looks up a localized string similar to '{0}' does not implement inherited abstract member '{1}'.\r\n            ":"\r\n              查找类似于“ {0}'的本地化字符串”未实现继承的抽象成员'{1}'。\r\n            \r\n","\r\n            Variables local to current frame do not need temps when re-read multiple times\r\n            as long as there is no code that may write to locals in between accesses and they\r\n            are not captured.\r\n            \r\n            Example:\r\n                   l += foo(ref l);\r\n            \r\n            even though l is a local, we must access it via a temp since \"foo(ref l)\" may change it\r\n            on between accesses. \r\n            ":"\r\n            当重新阅读多次阅读时，本地到当前帧本地帧不需要温度\r\n            只要没有代码可以在访问之间写给当地人，他们\r\n            没有被捕获。\r\n            \r\n            例子：\r\n                   l += foo（ref l）;\r\n            \r\n            即使L是本地人，我们也必须通过温度访问它，因为“ foo（ref l）”可能会改变它\r\n            在两次访问之间。\r\n            \r\n","\r\n              Looks up a localized string similar to Error reading Win32 resources -- {0}.\r\n            ":"\r\n              查找类似于错误读取Win32资源的本地化字符串 -  {0}。\r\n            \r\n","\r\n            Whether this is an asynchronous foreach.\r\n            ":"\r\n            这是否是异步的。\r\n            \r\n","\r\n              Looks up a localized string similar to Only methods, classes, structs, or interfaces may be partial.\r\n            ":"\r\n              查找类似于方法，类，结构或接口的本地化字符串可能是部分的。\r\n            \r\n"," This is an implementation of a special symbol comparer, which is supposed to be used  for \r\n            sorting original definition symbols (explicitly or explicitly declared in source  within the same \r\n            container) in lexical order of their declarations. It will not work on  anything that uses non-source locations. \r\n            ":" 这是特殊符号比较的实现，应该用于\r\n            对原始定义符号进行排序（在同一源中明确或明确声明\r\n            集装箱）按声明的词汇顺序。它不会在使用非源地点的任何东西上使用。\r\n            \r\n","\r\n            Implicit constant expression conversions are described in section 6.1.9 of the C# language specification.\r\n            ":"\r\n            隐式恒定表达转换在C＃语言规范的第6.1.9节中描述。\r\n            \r\n"," passed as a parameter\r\n            to the constructor of this class. Usually, derived types are going to let the base (this class) to do its work first\r\n            and then operate on the result they get back.\r\n            ":" 作为参数传递\r\n            给这个班级的构造函数。通常，派生的类型会让基地（此类）首先完成工作\r\n            然后根据结果进行操作。\r\n            \r\n","\r\n            Take the set of tests and split them into two, one for when the test has succeeded, and one for when the test has failed.\r\n            ":"\r\n            进行一组测试并将其分成两，一个是在测试成功的时候，一个用于测试失败的时间。\r\n            \r\n","\r\n            Forces binding and decoding of attributes.\r\n            This property shouldn't be accessed during binding as it can lead to attribute binding cycle.\r\n            ":"\r\n            属性结合和解码的力。\r\n            在绑定过程中不应访问此属性，因为它可以导致属性结合周期。\r\n            \r\n","Return value must be non-null because parameter is non-null.":"返回值必须是非null，因为参数是非null。\r\n","\r\n              Looks up a localized string similar to Submission can only include script code..\r\n            ":"\r\n              查找类似于提交的本地化字符串只能包括脚本代码。\r\n            \r\n","\r\n            The bound expression that invokes the operation of the query clause.\r\n            ":"\r\n            调用查询子句的操作的界表达式。\r\n            \r\n","Syntax tree doesn't belong to the underlying 'Compilation'.":"语法树不属于基础“汇编”。\r\n","If a default label is found in this section, assigned that label":"如果在本节中找到默认标签，请分配该标签\r\n","The original symbol from initial binding.":"初始绑定的原始符号。\r\n","\r\n            Converts skippedSyntax node into tokens and adds these as trivia on the target token.\r\n            Also adds the first error (in depth-first preorder) found in the skipped syntax tree to the target token.\r\n            ":"\r\n            将Skippedsyntax节点转换为令牌，并将其添加为目标令牌上的琐事。\r\n            还将跳过语法树中的第一个错误（以深度优先的预订）添加到目标令牌中。\r\n            \r\n","\r\n            Returns false because module can't be declared as 'static'.\r\n            ":"\r\n            返回false，因为不能将模块声明为“静态”。\r\n            \r\n","Called when the visitor visits a NamespaceDeclarationSyntax node.":"当访问者访问命名的eClarationsyntax节点时，请致电。\r\n","\r\n            A value set factory that only supports equality and works by including or excluding specific values.\r\n            ":"\r\n            一个仅通过包括或排除特定值来支持平等并起作用的价值集工厂。\r\n            \r\n","\r\n            Analyze data-flow within an expression. \r\n            ":"\r\n            在表达式中分析数据流。\r\n            \r\n","'{0}' has no accessible constructors which use only CLS-compliant types":"'{0}'没有仅使用CLS兼容类型的可访问构造函数\r\n","\r\n            The set of indexer symbols from which this call's indexer was chosen. \r\n            Only kept in the tree if the call was an error and overload resolution\r\n            was unable to choose a best indexer.\r\n            ":"\r\n            选择此调用索引器的一组索引符号。\r\n            只有在通话是错误和超载分辨率的情况下才保存在树上\r\n            无法选择最佳索引器。\r\n            \r\n","Creates a new ParenthesizedLambdaExpressionSyntax instance.":"创建一个新的括号lambdaexpressionsyntax实例。\r\n","The trivia to be replaced; descendants of the root token.":"要替换的琐事；根令牌的后代。\r\n","Create an Index from the end at the position indicated by the value.":"在值指示的位置上从末端创建一个索引。\r\n","XML comment has a paramref tag, but there is no parameter by that name":"XML评论具有Paramref标签，但是该名称没有参数\r\n","\r\n              Looks up a localized string similar to Type does not implement the collection pattern; members are ambiguous.\r\n            ":"\r\n              查找类似于类型的本地化字符串不会实现集合模式。成员是模棱两可的。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot assign to '{0}' because it is read-only.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串，因为它是只读的。\r\n            \r\n","Cannot call an abstract base member: '{0}'":"无法调用抽象基础成员：'{0}'\r\n","Creates a new RelationalPatternSyntax instance.":"创建一个新的关系patternsyntax实例。\r\n","object initializer":"对象初始化器\r\n","Whether or not to quote string literals.":"是否引用字符串文字。\r\n"," represents a body of a lambda.\r\n            ":" 代表一个lambda的身体。\r\n            \r\n","\r\n              Looks up a localized string similar to Error signing output with public key from file '{0}' -- {1}.\r\n            ":"\r\n              从文件'{0}' -  {1}中查找类似于带有public键的错误签名输出的本地化字符串。\r\n            \r\n","\r\n            Check for a GetEnumerator method on collectionExprType.  Failing to satisfy the pattern is not an error -\r\n            it just means that we have to check for an interface instead.\r\n            ":"\r\n            检查CollectionExprType上的GetEnumerator方法。无法满足模式不是错误 - \r\n            这只是意味着我们必须检查接口。\r\n            \r\n","\r\n              Looks up a localized string similar to <switch expression>.\r\n            ":"查找类似于<switch表达式>的局部字符串。\r\n            \r\n"," which was introduced in .Net 4.5\r\n            ":" 在.NET 4.5中引入\r\n            \r\n","The CallerFilePathAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments":"应用于参数'{0}'的CallerFilePathAttribute将无效，因为它适用于不允许可选参数的上下文中使用的成员\r\n","Called when the visitor visits a ContinueStatementSyntax node.":"当访问者访问ContureStatementSyntax节点时调用。\r\n","Cannot convert method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?":"无法将方法组'{0}'转换为非贵族类型'{1}'。您打算调用该方法吗？\r\n","\r\n            Return the inferred type arguments using null\r\n            for any type arguments that were not inferred.\r\n            ":"\r\n            使用null返回推断的类型参数\r\n            对于未推断的任何类型参数。\r\n            \r\n","\r\n              Looks up a localized string similar to Constant value '{0}' cannot be converted to a '{1}' (use 'unchecked' syntax to override).\r\n            ":"\r\n              查找类似于常数值'{0}'的本地化字符串无法转换为'{1}'（使用'UNACKECT'语法替代）。\r\n            \r\n","\r\n            Cached \"this\" local, used to store the captured \"this\", which is safe to cache locally since \"this\" \r\n            is sematically immutable.\r\n            It would be hard for such caching to happen at JIT level (since JIT does not know that it never changes).\r\n            NOTE: this field is null when we are not caching \"this\" which happens when\r\n                  - not optimizing\r\n                  - method is not capturing \"this\" at all\r\n                  - containing type is a struct \r\n                  (we could cache \"this\" as a ref local for struct containers, \r\n                  but such caching would not save as much indirection and could actually \r\n                  be done at JIT level, possibly more efficiently)\r\n            ":"\r\n            缓存的“这个”本地，用于存储捕获的“此”，这是可以在本地缓存的，因为“此”\r\n            在半阶面不变。\r\n            这种缓存在JIT级别上很难发生（因为JIT不知道它永远不会改变）。\r\n            注意：当我们不缓存“此”时，此字段是无效的\r\n                   - 不优化\r\n                   - 方法根本没有捕获“这个”\r\n                   - 包含类型是结构\r\n                  （我们可以作为结构容器的REF局部缓存“此”，\r\n                  但是这种缓存不会节省太多的间接，实际上可以\r\n                  在JIT级别完成，可能更有效）\r\n            \r\n","\r\n            The children for this deconstruction node.\r\n            ":"\r\n            这个解构节点的孩子。\r\n            \r\n","\r\n            The type of the event along with its annotations.\r\n            ":"\r\n            事件的类型及其注释。\r\n            \r\n","s\r\n            have been converted to ":"s\r\n            已转换为\r\n","\r\n              Looks up a localized string similar to Type '{0}' cannot be embedded because it is a nested type. Consider setting the 'Embed Interop Types' property to false..\r\n            ":"\r\n              查找类似于“ {0}”类型的本地化字符串，因为它是嵌套类型，因此无法嵌入。考虑将“嵌入Interop类型”属性设置为false。\r\n            \r\n","\r\n              Looks up a localized string similar to Assignment made to same variable; did you mean to assign something else?.\r\n            ":"\r\n              查找类似于对同一变量的分配的本地化字符串；你是说要分配其他东西吗？\r\n            \r\n","Conditional member '{0}' cannot implement interface member '{1}' in type '{2}'":"条件成员'{0}'无法在类型'{2}'中实现接口成员'{1}'\r\n","\r\n              Looks up a localized string similar to Not a valid attribute location for this declaration.\r\n            ":"\r\n              查找类似于此声明的有效属性位置类似的本地化字符串。\r\n            \r\n","\r\n            Expression represents a location. Often referred as a \"variable\"\r\n            Examples:\r\n             local variable, parameter, field\r\n            ":"\r\n            表达式代表一个位置。通常被称为“变量”\r\n            例子：\r\n             本地变量，参数，字段\r\n            \r\n","\r\n            Lower a foreach loop that will enumerate a single-dimensional array.\r\n            \r\n            A[] a = x;\r\n            for (int p = 0; p < a.Length; p = p + 1) {\r\n                V v = (V)a[p];\r\n                // body\r\n            }\r\n            ":"\r\n            降低将枚举单维数组的foreach循环。\r\n            \r\n            A[]a=x;\r\n            对于(int p=0;p<A.长度;p=p+1){\r\n                V v=(V)a[p];\r\n                //身体\r\n            }\r\n            \r\n","\r\n            A reference-id to object map, that can share base data efficiently.\r\n            ":"\r\n            可以有效共享基本数据的对象图的引用ID。\r\n            \r\n","\r\n            A representation of a property symbol that is intended only to be used for comparison purposes\r\n            (esp in PropertySignatureComparer).\r\n            ":"\r\n            属性符号的表示，仅用于比较目的\r\n            （ESP在PropertySignatureComparer中）。\r\n            \r\n","Command-line syntax error: Missing ':<number>' for '{0}' option":"命令行语法错误：缺少'：<数字>'for'{0}'选项\r\n","Property or indexer '{0}' cannot be assigned to -- it is read only":"属性或索引器'{0}'不能分配给 - 仅读取\r\n","The old node.":"旧节点。\r\n","SyntaxToken representing the delegate keyword.":"Syntaxtoken代表代表关键字。\r\n","\r\n            TODO: use or delete isDynamic.\r\n            ":"\r\n            TODO：使用或删除ISDYNAGIC。\r\n            \r\n","\r\n            If there are no constraints, returns an empty immutable array. Otherwise, returns an immutable\r\n            array of types, indexed by the constrained type parameter in ":"\r\n            如果没有约束，则返回一个空的不变阵列。否则，返回不变的\r\n            类型数组，由约束类型参数索引\r\n"," caches local symbols and semantic\r\n            information. Thus, it is much more efficient to use a single instance of ":" caches本地符号和语义\r\n            信息。因此，使用单个实例的效率要高得多\r\n",", but in addition ignores name.\r\n            ":"，但此外，忽略了名称。\r\n            \r\n","\r\n             Take a warning and return the final disposition of the given warning,\r\n             based on both command line options and pragmas. The diagnostic options\r\n             have precedence in the following order:\r\n                 1. Warning level\r\n                 2. Command line options (/nowarn, /warnaserror)\r\n                 3. Editor config options (syntax tree level)\r\n                 4. Global analyzer config options (compilation level)\r\n                 5. Global warning level\r\n            \r\n             Pragmas are considered separately. If a diagnostic would not otherwise\r\n             be suppressed, but is suppressed by a pragma, ":"发出警告并返回给定警告的最终处置，\r\n             基于命令行选项和布拉格马斯。诊断选项\r\n             按以下顺序有优先权：\r\n                 1.警告级别\r\n                 2.命令行选项（ /nowarn， /warnaserror）\r\n                 3.编辑器配置选项（语法树级别）\r\n                 4.全局分析仪配置选项（汇编级别）\r\n                 5.全球警告水平\r\n            \r\n             布拉格斯分别考虑。如果诊断不会以其他方式\r\n             被抑制，但被布拉格抑制，\r\n","\r\n            Given the error code and the source location, get the warning state based on ":"\r\n            鉴于错误代码和源位置，请根据\r\n","  if it's not overridden\r\n            ":"  如果不被覆盖\r\n            \r\n"," is within a documentation\r\n            comment cref attribute value.\r\n            ":" 在文档中\r\n            评论CREF属性值。\r\n            \r\n","\r\n            Assuming we are in an async method, return true if we're in a context where await would be illegal.\r\n            Specifically, return true if we're in a lock, catch, or finally.\r\n            ":"\r\n            假设我们是一种异步方法，请返回True如果我们处于等待非法的情况下。\r\n            具体来说，如果我们处于锁定，捕捉或最后，请返回true。\r\n            \r\n","\r\n            Check type parameter constraints for the containing type or method symbol.\r\n            ":"\r\n            检查包含类型或方法符号的类型参数约束。\r\n            \r\n","\r\n            Generates a new ":"\r\n            生成一个新\r\n","A previous catch clause already catches all exceptions of this or of a super type ('{0}')":"先前的捕获子句已经捕获了此或超级类型的所有例外（'{0}'）\r\n","TypeSyntax node representing the type of the stackalloc array.":"代表stackalloc数组的类型的typeyntax节点。\r\n","\r\n            The largest value of ":"\r\n            最大的价值\r\n","\r\n            The type parameters, classes, and interfaces explicitly declared as\r\n            constraint types on the containing type parameter, with cycles removed.\r\n            ":"\r\n            类型参数，类和接口明确声明为\r\n            在包含类型参数上的约束类型，已删除周期。\r\n            \r\n","\r\n              Looks up a localized string similar to The fully qualified name for '{0}' is too long for debug information. Compile without '/debug' option..\r\n            ":"\r\n              查找类似于“ {0}”的完全合格名称的本地化字符串，对于调试信息而言太长了。没有“/调试”选项编译。\r\n            \r\n","Creates a new ParameterListSyntax instance.":"创建一个新的parameListyntax实例。\r\n","Creates a new InterpolationAlignmentClauseSyntax instance.":"创建一个新的InterPolationalIgnmentClausesyntax实例。\r\n","Named argument '{0}' cannot be specified multiple times":"命名参数'{0}'不能多次指定\r\n","\r\n            This method handles duplicate types in a few different ways:\r\n            - for types before C# 7, the first candidate is returned with a warning\r\n            - for types after C# 7, the type is considered missing\r\n            - in both cases, when BinderFlags.IgnoreCorLibraryDuplicatedTypes is set, any duplicate coming from corlib will be ignored (ie not count as a duplicate)\r\n            ":"\r\n            此方法以几种不同的方式处理重复类型：\r\n             - 对于c＃7之前的类型，第一个候选人将带有警告返回\r\n             - 对于c＃7之后的类型，该类型被认为丢失了\r\n             - 在这两种情况下，设置了binderflags.ignorecorlibraryduplicatytypes，corlib的任何重复都将被忽略（即不算作重复）\r\n            \r\n","\r\n              Looks up a localized string similar to generics.\r\n            ":"\r\n              查找类似于仿制药的局部字符串。\r\n            \r\n","\r\n            Indicates why the compiler accepted or rejected the member during overload resolution.\r\n            ":"\r\n            指示为什么编译器在超载分辨率期间接受或拒绝了成员。\r\n            \r\n","The managed coclass wrapper class signature '{0}' for interface '{1}' is not a valid class name signature":"托管尾coclass包装器类签名'{0}'for Interface'{1}'不是有效的类名称签名\r\n","Class which represents the syntax node for RefType expression.":"代表用于reftype表达的语法节点的类。\r\n","\r\n            Return error code that has highest priority while calculating use site error for this symbol. \r\n            Supposed to be ErrorCode, but it causes inconsistent accessibility error.\r\n            ":"\r\n            返回错误代码在计算此符号的使用站点错误时具有最高优先级。\r\n            应该是错误代码，但会导致不一致的可访问性错误。\r\n            \r\n"," has occurred and produced a true/false result,\r\n            set some flags indicating the implied status of the ":" 发生并产生了一个真/错误的结果，\r\n            设置一些指示暗示状态的标志\r\n","Unexpected token '{0}'":"意外的令牌'{0}'\r\n","Called when the visitor visits a PrimaryConstructorBaseTypeSyntax node.":"当访客访问初级构造方法时，请致电。\r\n","\r\n            Gets type information about a syntax node. This is overridden by various specializations of SemanticModel.\r\n            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named\r\n            argument nodes have been handled.\r\n            ":"\r\n            获取有关语法节点的类型信息。 Semanticmodel的各种专业都覆盖了这一点。\r\n            它可以假设checksyntaxnode和cangetSemanticinfo已经被调用，以及\r\n            论证节点已被处理。\r\n            \r\n","Called when the visitor visits a ExpressionStatementSyntax node.":"访问者访问expressionStatementsyntax节点时调用。\r\n","The property parameter doesn't have a name in metadata,\r\n            so this is the handle of a corresponding accessor parameter, if there is one,\r\n            or of the ParamInfo passed in, otherwise.":"属性参数在元数据中没有名称，\r\n            因此，这是相应的访问者参数的句柄，如果有一个，则\r\n            或paraninfo传递的内容，否则。\r\n","A list of syntax nodes that represents the content of the example element.":"表示示例元素内容的语法节点列表。\r\n","\r\n            Substitute types, and return the results without duplicates, preserving the original order.\r\n            Note, all occurrences of 'dynamic' in resulting types will be replaced with 'object'.\r\n            ":"\r\n            替换类型，并在不重复的情况下返回结果，保留原始订单。\r\n            请注意，所有类型中的“动态”的所有出现都将被“对象”替换。\r\n            \r\n","The raw text of the literal, including quotes and escape sequences.":"文字的原始文本，包括引号和逃脱序列。\r\n","Creates a new ConstructorConstraintSyntax instance.":"创建一个新的constructorConstraintsyntax实例。\r\n","\r\n            Subclasses override this if they want to take special actions on processing a goto\r\n            statement, when both the jump and the label have been located.\r\n            ":"\r\n            如果他们想采取特殊措施处理goto，子类要覆盖这一点\r\n            声明，当跳跃和标签都已经找到时。\r\n            \r\n","'{0}': member names cannot be the same as their enclosing type":"'{0}'：成员名称不能与其封闭类型相同\r\n","\r\n            Return a BoundExpression representing the invalid member.\r\n            ":"\r\n            返回代表无效成员的界表达。\r\n            \r\n","\r\n              Looks up a localized string similar to Unterminated string literal.\r\n            ":"\r\n              查找类似于未终止的字符串字面的本地化字符串。\r\n            \r\n","Creates a new GlobalStatementSyntax instance.":"创建一个新的globalstatementsyntax实例。\r\n","\r\n            The root node of the syntax tree that this binding is based on.\r\n            ":"\r\n            该绑定基于的语法树的根节点。\r\n            \r\n","An expression tree may not contain an 'is' pattern-matching operator.":"表达树可能不包含“ IS”模式匹配操作员。\r\n","\r\n            Parse a StatementSyntaxNode using grammar rule for statements.\r\n            ":"\r\n            使用语法规则对语句进行解析。\r\n            \r\n","\r\n            Returns all members of the tuple type - a combination of members from the underlying type \r\n            and synthesized fields for tuple elements.\r\n            ":"\r\n            返回元组类型的所有成员 - 基础类型的成员组合\r\n            和元组元素的合成字段。\r\n            \r\n","\r\n            This type is meant to be used in scenarios where it is OK for the analyzer\r\n            assemblies to be locked on disk for the lifetime of the host; for example,\r\n            csc.exe and vbc.exe. In scenarios where support for updating or deleting\r\n            the analyzer on disk is required a different loader should be used.\r\n            ":"\r\n            这种类型的目的是在分析仪可以的情况下使用\r\n            主机终生的组件要锁定在磁盘上；例如，\r\n            csc.exe和vbc.exe。在支持更新或删除的情况下\r\n            需要使用磁盘上的分析仪，应使用不同的装载机。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid type specified as an argument for TypeForwardedTo attribute.\r\n            ":"\r\n              查找类似于指定为typeforwardto属性参数的无效类型的本地化字符串。\r\n            \r\n","'{0}' hides inherited member '{1}'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.":"'{0}'隐藏成员'{1}'。要使当前成员覆盖该实现，请添加覆盖关键字。否则添加新关键字。\r\n","\r\n              Looks up a localized string similar to The best overloaded method match for '{0}' has wrong signature for the initializer element. The initializable Add must be an accessible instance method..\r\n            ":"\r\n              查找类似于“ {0}”的最佳超载方法匹配的本地化字符串，对于初始化器元素的签名错误。最初的添加必须是可访问的实例方法。\r\n            \r\n","\r\n              Looks up a localized string similar to Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'.\r\n            ":"\r\n              查找类似于不一致的可访问性的本地化字符串：base类'{1}'的访问范围不如class'{0}'。\r\n            \r\n","\r\n              Looks up a localized string similar to A volatile field should not normally be used as a ref or out value, since it will not be treated as volatile. There are exceptions to this, such as when calling an interlocked API..\r\n            ":"\r\n              查找类似于挥发性字段的局部字符串通常不应用作ref或外出值，因为它不会被视为挥发性。有例外，例如调用互锁的API。\r\n            \r\n","\r\n            Logical equality on anonymous types that ignores custom modifiers and/or the object/dynamic distinction.\r\n            Differs from IsSameType for arrays, pointers, and generic instantiations.\r\n            ":"\r\n            匿名类型的逻辑平等忽略自定义修饰符和/或对象/动态区别。\r\n            与阵列，指针和通用实例化的Issametype不同。\r\n            \r\n","\r\n            A collection of the local variables for which a value assigned outside the region may be used inside the region.\r\n            ":"\r\n            该区域内分配的值的局部变量集合可以在该区域内使用。\r\n            \r\n","__arglist cannot have an argument of void type":"__ Arglist不能有空白类型的论点\r\n","Creates a new UnsafeStatementSyntax instance.":"创建一个新的Unsafestatementsyntax实例。\r\n",", but is guaranteed to have HasErrors set to true.\r\n            ":"，但可以保证将Haserrors设置为真。\r\n            \r\n","\r\n            This can be used instead of Debug.Assert as it more reliably breaks to the debugger\r\n            when an assertion fails (it is unaffected by exception filters on enclosing frames).\r\n            ":"\r\n            可以用它代替调试。ASSERT，因为它更可靠地分解了调试器\r\n            当断言失败时（不受封闭帧的异常过滤的影响）。\r\n            \r\n","checked":"检查\r\n","\r\n              Looks up a localized string similar to A readonly field cannot be used as a ref or out value (except in a constructor).\r\n            ":"\r\n              查找类似于ReadOnly字段的本地化字符串不能用作REF或OUT值（在构造函数中除外）。\r\n            \r\n","\r\n            It is not suitable to call this method on a ":"\r\n            在A上调用此方法是不合适的\r\n","\r\n            Get the arity of the missing type.\r\n            ":"\r\n            获取缺失类型的敏锐度。\r\n            \r\n","\r\n              Looks up a localized string similar to The return type of operator True or False must be bool.\r\n            ":"\r\n              查找类似于运算符的返回类型的本地化字符串必须是bool。\r\n            \r\n","One or more namespaces to merged. If just one, then it\r\n            is returned. The merged namespace symbol may hold onto the array.":"合并的一个或多个名称空间。如果只是一个，那就\r\n            退回。合并的名称空间符号可以包含在数组上。\r\n","\r\n            True if the symbol has a use-site diagnostic with error severity.\r\n            ":"\r\n            如果符号具有错误严重性的用途点诊断，则为true。\r\n            \r\n","Each linked resource and module must have a unique filename. Filename '{0}' is specified more than once in this assembly":"每个链接的资源和模块必须具有唯一的文件名。在此汇编中，多次指定了一个不止一次的文件名'{0}'\r\n","It is not legal to use the type 'dynamic' in a pattern.":"在模式中使用“动态”类型是不合法的。\r\n","\r\n              Looks up a localized string similar to 'extern alias' is not valid in this context.\r\n            ":"\r\n              在这种情况下，查找类似于“外部别名”的本地化字符串是无效的。\r\n            \r\n","\r\n            Get the name of the method so that it can be looked up in the containing type.\r\n            ":"\r\n            获取该方法的名称，以便可以在包含类型中查找。\r\n            \r\n","The state of compilation of the enclosing type":"封闭类型的汇编状态\r\n","Method invoked as extension method.":"称为扩展方法。\r\n","\r\n            It seems that every failure path reports the same diagnostics, so that is left to the caller.\r\n            ":"\r\n            似乎每个故障路径都报告了相同的诊断，因此将其留给呼叫者。\r\n            \r\n","Preprocessing symbol identifier node.":"预处理符号标识符节点。\r\n","\r\n            Represents a type other than an array, a pointer, a type parameter, and dynamic.\r\n            ":"\r\n            代表数组，指针，类型参数和动态的类型。\r\n            \r\n","The syntax node that declares an accessor.":"声明登录器的语法节点。\r\n","'await' cannot be used as an identifier within an async method or lambda expression":"“等待”不能用作异步方法或lambda表达式中的标识符\r\n","Embedded texts are only supported when emitting a PDB.":"仅在发出PDB时支持嵌入式文本。\r\n","Called when the visitor visits a ExplicitInterfaceSpecifierSyntax node.":"当访问者访问explacitInterfaceSpefierSyntax节点时调用。\r\n","Cref that will be bound.":"将被绑定的cref。\r\n","Class which represents the syntax node for implicit element access expression.":"代表隐元元素访问表达式的语法节点的类。\r\n","The type or namespace name '{0}' does not exist in the namespace '{1}' (are you missing an assembly reference?)":"命名空间'{1}'中不存在类型或名称空间名称'{0}'（您是否缺少汇编引用？）\r\n","\r\n              Looks up a localized string similar to Class '{0}' cannot have multiple base classes: '{1}' and '{2}'.\r\n            ":"\r\n              查找类似于类'{0}'类的本地化字符串，不能具有多个基类：'{1}'和'{2}'。\r\n            \r\n","\r\n              Looks up a localized string similar to An out parameter cannot have the In attribute.\r\n            ":"\r\n              查找类似于OUT参数的本地化字符串不能具有In属性。\r\n            \r\n","private protected":"私人保护\r\n"," that can be used to retrieve analyzer config values by the generators in this driver.":" 该驱动程序中的生成器可用于检索分析仪配置值。\r\n","Called when the visitor visits a EventDeclarationSyntax node.":"当访问者访问事件删除速度nntax节点时，请致电。\r\n","\r\n            This portion of the binder converts deconstruction-assignment syntax (AssignmentExpressionSyntax nodes with the left\r\n            being a tuple expression or declaration expression) into a BoundDeconstructionAssignmentOperator (or bad node).\r\n            The BoundDeconstructionAssignmentOperator will have:\r\n            - a BoundTupleLiteral as its Left,\r\n            - a BoundConversion as its Right, holding:\r\n                - a tree of Conversion objects with Kind=Deconstruction, information about a Deconstruct method (optional) and\r\n                    an array of nested Conversions (like a tuple conversion),\r\n                - a BoundExpression as its Operand.\r\n            ":"\r\n            活页夹的这一部分转换解构 - 分配语法（sistizment expressionsyntax nodes with左\r\n            作为元组表达式或声明表达式）到界限构造Assignmentmentoperator（或不良节点）中。\r\n            边界构造设施操作员将有：\r\n             - 左边的界限，\r\n             - 绑定反转换为其权利，保留：\r\n                 - 具有kint =解构的转换对象的树，有关解构方法（可选）的信息和\r\n                    一系列嵌套转换（例如元组转换），\r\n                 - 作为其操作数的界表达。\r\n            \r\n","\r\n              Looks up a localized string similar to Embedding the interop type '{0}' from assembly '{1}' causes a name clash in the current assembly. Consider setting the 'Embed Interop Types' property to false..\r\n            ":"\r\n              查找类似于嵌入Interop类型的'{0}'的本地化字符串，从汇编'{1}'导致当前汇编中的名称冲突。考虑将“嵌入Interop类型”属性设置为false。\r\n            \r\n","XML comment on '{1}' has a paramref tag for '{0}', but there is no parameter by that name":"XML对'{1}'的注释具有'{0}'的参数标签，但没有该名称的参数\r\n","\r\n            Returns true if the method has a [AsyncMethodBuilder(typeof(B))] attribute. If so it returns type B.\r\n            Validation of builder type B is left for elsewhere. This method returns B without validation of any kind.\r\n            ":"\r\n            如果该方法具有[asyncmethodbuilder（typeOf（b））]属性，则返回true。如果是这样，它将返回类型B。\r\n            B型B型的验证留在其他地方。此方法返回b，没有任何形式的验证。\r\n            \r\n","\r\n            If the Kind is ExtendKind.Compilation, returns the compilation symbol that this\r\n            namespace encompasses. Otherwise throws InvalidOperationException.\r\n            ":"\r\n            如果类型是ExtendKind.com，请返回汇编符号\r\n            名称空间包括。否则会引发无效的exception。\r\n            \r\n",")\r\n            by computing a description of the initial state in a ":"）\r\n            通过计算对初始状态的描述\r\n","Parameter '{0}' must be a symbol from this compilation or some referenced assembly.":"参数'{​​0}'必须是本汇编或某些引用组件的符号。\r\n","Invalid number":"无效号码\r\n","\r\n            This class stores several source parsing related options and offers access to their values.\r\n            ":"\r\n            该课程存储了几种相关的源解析选项，并提供对其值的访问。\r\n            \r\n","Creates a new DestructorDeclarationSyntax instance.":"创建一个新的DestructorDeclarationsyntax实例。\r\n","\r\n            Returns PEModuleSymbol containing the namespace.\r\n            ":"\r\n            返回包含名称空间的Pemodulesymbol。\r\n            \r\n","\r\n            Determine a better location for diagnostic squiggles.  Squiggle the interface rather than the class.\r\n            ":"\r\n            确定诊断症状的更好位置。弯曲界面而不是类。\r\n            \r\n","\r\n              Looks up a localized string similar to XML comment has a duplicate param tag for '{0}'.\r\n            ":"\r\n              查找类似于XML注释的本地化字符串具有“ {0}”的重复参数标签。\r\n            \r\n","\r\n            Represents a field initializer, a property initializer, or a global statement in script code.\r\n            ":"\r\n            代表字段初始化器，属性初始化器或脚本代码中的全局语句。\r\n            \r\n",".\r\n            At the moment, all variables declared in the same scope\r\n            always get assigned to the same environment.\r\n            ":"。\r\n            目前，所有变量在同一范围内声明\r\n            始终被分配到相同的环境。\r\n            \r\n","\r\n            Visit a partial list of statements that possibly contain using declarations\r\n            ":"\r\n            访问可能包含声明的部分陈述列表\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use fixed local '{0}' inside an anonymous method, lambda expression, or query expression.\r\n            ":"\r\n              在匿名方法，lambda表达式或查询表达式中查找类似于使用固定的本地'{0}'的本地化字符串。\r\n            \r\n","The text contents of the format specifier for an interpolation.":"插值格式指定符的文本内容。\r\n","\r\n            Returns true if this symbol has external implementation; i.e., declared with the \r\n            ":"\r\n            如果此符号具有外部实现，则返回true；即，用\r\n            \r\n","tryDequeue":"Trydequeue\r\n","Arguments to '/keepalive' option below -1 are invalid.":"-1以下的“/keepalive”选项的论点无效。\r\n","\r\n            If a method is currently being analyzed returns its 'this' parameter, returns null\r\n            otherwise.\r\n            ":"\r\n            如果当前正在分析方法将返回其“ this”参数，请返回null\r\n            否则。\r\n            \r\n","\r\n            Return true if there is a source declaration symbol name that matches the provided name.\r\n            This will be faster than ":"如果有一个与提供名称匹配的源声明符号名称，则返回true。\r\n            这将比\r\n","tuple.Item1 == 1 && tuple.Item2 == 2":"tuple.item1 == 1 && tuple.item2 == 2\r\n","The text of the bracketed argument list.":"包围参数列表的文本。\r\n","\r\n            For tuple literals, we just return the element.\r\n            For expressions with tuple type, we access `Item{i}`.\r\n            ":"\r\n            对于元素文字，我们只是返回元素。\r\n            对于带有元组类型的表达式，我们访问`iquie {i}`。\r\n            \r\n","\r\n            are optional syntax and symbol for the member containing ":"\r\n            是可选的语法和包含成员的符号\r\n","\r\n            Given a DocumentationCommentTriviaSyntax, return the full text, but with\r\n            documentation comment IDs substituted into crefs.\r\n            ":"\r\n            给出了DocumentationCommentTriviaSyntax，返回全文，但是\r\n            文档评论ID代替Crefs。\r\n            \r\n","\r\n             Produce an element-wise comparison and logic to ensure the result is a bool type.\r\n            \r\n             If an element-wise comparison doesn't return bool, then:\r\n             - if it is dynamic, we'll do `!(comparisonResult.false)` or `comparisonResult.true`\r\n             - if it implicitly converts to bool, we'll just do the conversion\r\n             - otherwise, we'll do `!(comparisonResult.false)` or `comparisonResult.true` (as we'd do for `if` or `while`)\r\n             ":"\r\n             产生元素的比较和逻辑，以确保结果是BOOL类型。\r\n            \r\n             如果元素的比较无法返回bool，则：\r\n              - 如果是动态的，我们将做``！\r\n              - 如果它隐含地转换为布尔，我们将进行转换\r\n              - 否则，我们将做``！\r\n             \r\n","\r\n            Bind the given attribute speculatively at the given position, and return back\r\n            the resulting bound node. May return null in some error cases.\r\n            ":"\r\n            在给定位置绑定给定属性，然后返回\r\n            结果结合节点。在某些错误情况下可能会返回null。\r\n            \r\n","Creates a new ForEachVariableStatementSyntax instance.":"创建一个新的foreachvariablestatementsyntax实例。\r\n","Creates a new CatchClauseSyntax instance.":"创建一个新的catchclausesyntax实例。\r\n"," static members that are only available in .NET 5.\r\n            ":" 仅在.NET 5中可用的静态成员。\r\n            \r\n","Single-line comment or end-of-line expected after #pragma directive":"#pragma指令后预期的单线评论或期望\r\n","True to put (single) quotes around the character literal.":"真实地将（单个）引号围绕着字符字面。\r\n","The variable '{0}' is assigned but its value is never used":"分配了变量'{0}'，但其值永远不会使用\r\n","\r\n              Looks up a localized string similar to Type cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type.\r\n            ":"\r\n              查找类似于类型的本地化字符串不能标记为CLS兼容，因为它是非CLS兼容类型的成员。\r\n            \r\n","SyntaxToken representing the RefTypeKeyword.":"Syntaxtoken代表reftypekeyword。\r\n","The 'await' operator may only be used in a query expression within the first collection expression of the initial 'from' clause or within the collection expression of a 'join' clause":"“等待”运算符只能在“初始”第一个集合表达式中的查询表达式中使用，或在“ join”子句的集合表达式中\r\n","\r\n            True if this is a rewriter for a switch statement. This affects \r\n            - sequence points\r\n              When clause gets a sequence point in a switch statement, but not in a switch expression.\r\n            - synthesized local variable kind\r\n              The temp variables must be long lived in a switch statement since their lifetime spans across sequence points.\r\n            ":"\r\n            thy如果这是转换语句的重写器。这会影响\r\n             - 序列点\r\n              当子句在开关语句中获得序列点时，而在开关表达式中不在。\r\n             - 合成的本地变量类型\r\n              温度变量必须长期存在于开关语句中，因为它们的寿命跨越序列点。\r\n            \r\n","Cannot use local variable '{0}' before it is declared":"在声明之前不能使用局部变量'{0}'\r\n","\r\n              Looks up a localized string similar to '{0}' does not implement the '{1}' pattern. '{2}' is either static or not public..\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串不会实现'{1}'模式。 '{2}'是静态的。\r\n            \r\n","\r\n            Which element names were inferred and therefore cannot be used.\r\n            If none of the element names were inferred, or inferred names can be used (no tracking necessary), leave as default.\r\n            This information is ignored in type equality and comparison.\r\n            ":"\r\n            推断出哪些元素名称，因此无法使用。\r\n            如果没有推断出元素名称，或者可以使用推断名称（无需跟踪），请留下默认值。\r\n            该信息在类型平等和比较中被忽略。\r\n            \r\n"," if available. \r\n            Since the compiler does only need to know the marshalling type of symbols that aren't emitted \r\n            PE symbols just decode the type from metadata and don't provide full marshalling information.\r\n            ":" 如果可供使用的话。\r\n            由于编译器确实只需要知道没有发出的符号的编组类型\r\n            PE符号只是从元数据中解码类型，并且不提供完整的编组信息。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid option '{0}' for /langversion; must be ISO-1, ISO-2, Default or an integer in range 1 to 6..\r\n            ":"\r\n              查找类似于 /langversion的无效选项'{0}'的本地化字符串；必须是ISO-1，ISO-2，默认值或范围1至6中的整数。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid option '{0}' for /platform; must be anycpu, x86, Itanium, arm, arm64 or x64.\r\n            ":"\r\n              查找类似于 /平台的无效选项'{0}'的本地化字符串；必须是Anycpu，X86，Itanium，Arm，Arm64或X64。\r\n            \r\n","ExpressionSyntax node representing the expression on the right of the assignment operator.":"表示分配运算符右侧的表达式的表达式节点。\r\n","\r\n              Looks up a localized string similar to object initializer.\r\n            ":"\r\n              查找类似于Object Initializer的本地化字符串。\r\n            \r\n"," for attributes applied on the symbol and has stored the decoded data in the\r\n            lazyCustomAttributesBag on the symbol. Bound attributes haven't been stored on the bag yet.\r\n            \r\n            Post-validation for attributes that is dependent on other attributes can be done here.\r\n            \r\n            This method should not have any side effects on the symbol, i.e. it SHOULD NOT change the symbol state.\r\n            ":" 对于符号上应用的属性，并将解码数据存储在\r\n            符号上的lazycustomattributesbag。绑定属性尚未存储在包上。\r\n            \r\n            依赖其他属性的属性的验证后可以在此处完成。\r\n            \r\n            此方法不应对符号产生任何副作用，即它不应更改符号状态。\r\n            \r\n","Argument to '/keepalive' option is not a 32-bit integer.":"与“/keetalive”选项的论点不是32位整数。\r\n","Returns a Conversion object that summarizes whether the conversion was\r\n            possible, and if so, what kind of conversion it was. If no conversion was possible, a\r\n            Conversion object with a false \"Exists\" property is returned.":"返回一个转换对象，该对象总结了转换是否为\r\n            可能，如果是这样，那是什么样的转换。如果无法进行转换，一个\r\n            返回具有错误“存在”属性的转换对象。\r\n","\r\n            Contains the code for determining C# accessibility rules.\r\n            ":"\r\n            包含用于确定C＃可访问性规则的代码。\r\n            \r\n","Cannot use ref, out, or in parameter '{0}' inside an anonymous method, lambda expression, query expression, or local function":"在匿名方法，lambda表达式，查询表达式或本地函数中，无法使用参考，out，out或parameter'{0}'\r\n","\r\n              Looks up a localized string similar to Overloaded method differing only by unnamed array types is not CLS-compliant.\r\n            ":"\r\n              查找与仅由未命名数组类型不同的过载方法类似的本地化字符串不符合CLS。\r\n            \r\n","\r\n            Should only be called during construction.\r\n            ":"\r\n            只能在施工期间调用。\r\n            \r\n","Invalid severity in analyzer config file.":"分析仪配置文件中的严重性无效。\r\n","\r\n            Initial state for a MethodBodySemanticModel. Shared between here and the ":"\r\n            方法Bodysemanticmodel的初始状态。在这里和这里共享\r\n","\r\n            Returns true if one or more of the members in the group are applicable. (Note that\r\n            Succeeded implies IsApplicable but IsApplicable does not imply Succeeded.  It is possible\r\n            that no applicable member was better than all others.)\r\n            ":"\r\n            如果小组中的一个或多个成员适用，则返回为true。 （注意\r\n            成功的暗示意味着不适用，但不适用并不意味着成功。有可能的\r\n            没有适用会员比其他成员更好。）\r\n            \r\n","s in a chain,\r\n            allowing each of them to apply specific instrumentations in particular order.\r\n            \r\n            Default implementation of all APIs delegates to the \"previous\" ":"在链中，\r\n            允许他们每个人都采用特定的仪器。\r\n            \r\n            默认实施所有API委托\r\n","\r\n              Looks up a localized string similar to A goto case is only valid inside a switch statement.\r\n            ":"\r\n              查找类似于goto case的本地化字符串仅在开关语句中有效。\r\n            \r\n","Delay signing was specified and requires a public key, but no public key was specified":"指定了延迟签名，需要一个公钥，但没有指定公共密钥\r\n","\r\n            Builds a list of all the struct-based closure environments that will\r\n            need to be passed as arguments to the method.\r\n            ":"\r\n            构建所有基于结构的封闭环境的列表\r\n            需要作为参数传递给该方法。\r\n            \r\n","\r\n            Produce a string for testing purposes that is likely to be the same independent of platform and locale.\r\n            ":"\r\n            生产一个用于测试目的的字符串，可能与平台和语言环境无关。\r\n            \r\n","\r\n            We're in a <param> or <paramref> element, so we want a binder that can see\r\n            the parameters of the associated member and nothing else.\r\n            ":"\r\n            我们处于<param>或<paramref>元素中，因此我们想要一个可以看到的粘合剂\r\n            关联成员的参数，什么也没有。\r\n            \r\n","True for \"base.\", false for \"this.\".":"对于“基础”，为“ this”。\r\n"," for derived classes that store a location but not a \r\n            ":" 对于存储位置但不存储位置的派生类\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability of reference types in return type doesn't match implicitly implemented member..\r\n            ":"\r\n              查找类似于返回类型中参考类型的无效性类似的本地化字符串与隐式实现的成员不匹配。\r\n            \r\n","contravariantly":"违反\r\n","The possible values of test.Input when ":"测试的可能值。输入何时\r\n","\r\n              Looks up a localized string similar to Cannot take the address of a read-only local variable.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法获取仅读取的本地变量的地址。\r\n            \r\n","Base class for type declaration syntax (class, struct, interface).":"类型声明语法的基类（类，结构，接口）。\r\n","\r\n              Looks up a localized string similar to '{0}' defines operator == or operator != but does not override Object.Equals(object o).\r\n            ":"\r\n              查找类似于'{0}'定义operator ==或operator！=的本地化字符串，但不覆盖对象。equals（object o）。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use fields of '{0}' as a ref or out value because it is a '{1}'.\r\n            ":"\r\n              查找类似于类似的本地化字符串，因为它是'{1}'。\r\n            \r\n","\r\n            A map of types immediately contained within this type \r\n            grouped by their name (case-sensitively).\r\n            ":"\r\n            此类型中立即包含的类型地图\r\n            按其名称分组（案例敏感）。\r\n            \r\n","Not a valid warning number":"没有有效的警告号码\r\n","\r\n            Accumulate diagnostics related to the variance safety of an interface event.\r\n            ":"\r\n            积累与接口事件的方差安全有关的诊断。\r\n            \r\n","\r\n              Looks up a localized string similar to Member does not hide an inherited member; new keyword is not required.\r\n            ":"\r\n              查找类似于成员的本地化字符串不会隐藏继承的成员；不需要新的关键字。\r\n            \r\n","\r\n            Represents a compiler generated field of given type and name.\r\n            ":"\r\n            代表给定类型和名称的编译器生成的字段。\r\n            \r\n","Called when the visitor visits a LineDirectivePositionSyntax node.":"当访问者访问LinedirectiveStosionsysnax节点时称呼。\r\n","A readonly field cannot be used as a ref or out value (except in a constructor)":"可读字段不能用作ref或淘汰价值（在构造函数中除外）\r\n","\r\n            Associate the method with a particular event. Returns\r\n            false if the method is already associated with a property or event.\r\n            ":"\r\n            将方法与特定事件相关联。返回\r\n            false如果该方法已经与属性或事件关联。\r\n            \r\n","\r\n            Returns true if this symbol requires an instance reference as the implicit receiver. This is false if the symbol is static.\r\n            ":"\r\n            如果此符号需要实例参考作为隐式接收器，则返回true。如果符号是静态的，这是错误的。\r\n            \r\n"," from metadata and checks if ":" 来自元数据，检查是否存在\r\n"," that corresponds to the particular type \r\n            ":" 对应于特定类型\r\n            \r\n","\r\n              Looks up a localized string similar to Element names are not permitted when pattern-matching via 'System.Runtime.CompilerServices.ITuple'..\r\n            ":"\r\n              查找通过'system.runtime.compilerservices.ituple'的图案匹配时，不允许使用类似于元素名称的本地化字符串。\r\n            \r\n","Creates a new QualifiedCrefSyntax instance.":"创建一个新的合格crefsyntax实例。\r\n","\r\n            If the best match was based on the custom modifier count, rather than the custom modifiers themselves \r\n            (because the overriding member is in the current compilation), then we should use the count when determining\r\n            whether the override is ambiguous.\r\n            ":"\r\n            如果最佳匹配是基于自定义修饰符计数，而不是自定义修饰符本身\r\n            （因为重叠成员在当前汇编中），因此我们在确定时应使用计数\r\n            替代是否模棱两可。\r\n            \r\n","\r\n            Type of right operand is dynamic and is used.\r\n            ":"\r\n            正确操作数的类型是动态的，并且已被使用。\r\n            \r\n","\r\n            The least overridden member that is accessible from the call site that performed overload resolution. \r\n            Typically a virtual or abstract method (but not necessarily).\r\n            ":"\r\n            从执行过载分辨率的呼叫站点可访问的最低覆盖成员。\r\n            通常是虚拟或抽象方法（但不一定是）。\r\n            \r\n","\r\n            Create a possibly merged namespace symbol. If only a single namespace is passed it, it\r\n            is just returned directly. If two or more namespaces are passed in, then a new merged\r\n            namespace is created with the given extent and container.\r\n            ":"\r\n            创建可能合并的名称空间符号。如果仅通过一个名称空间，则\r\n            只是直接返回。如果传递了两个或更多名称空间，则新合并\r\n            名称空间是在给定范围和容器中创建的。\r\n            \r\n","original string":"原始字符串\r\n","\r\n            key = interface method/property/event compared using ":"\r\n            key =接口方法/属性/事件使用\r\n","Assignment made to same variable; did you mean to assign something else?":"分配给同一变量；你是说要分配其他东西吗？\r\n","\r\n            Computes the widest scope depth to which the given expression can escape by reference.\r\n            \r\n            NOTE: in a case if expression cannot be passed by an alias (RValue and similar), the ref-escape is scopeOfTheContainingExpression\r\n                  There are few cases where RValues are permitted to be passed by reference which implies that a temporary local proxy is passed instead.\r\n                  We reflect such behavior by constraining the escape value to the narrowest scope possible. \r\n            ":"\r\n            计算给定表达式可以通过参考逸出的最宽度深度。\r\n            \r\n            注意：如果无法通过别名传递表达式（rvalue和类似），则参考文献是范围内的表达\r\n                  在很少有情况下，允许通过引用传递RVALUE，这意味着通过临时的本地代理。\r\n                  我们通过将逃逸值限制为可能的最狭窄范围来反映这种行为。\r\n            \r\n","Creates a new CheckedExpressionSyntax instance.":"创建一个新的checkeDexpressionsyntax实例。\r\n","\r\n              Looks up a localized string similar to Properties which return by reference cannot have set accessors.\r\n            ":"\r\n              查找类似于属性的本地化字符串，该属性逐渐返回，该属性无法设置访问者。\r\n            \r\n","Creates a new PositionalPatternClauseSyntax instance.":"创建一个新的位置alpatternclausesyntax实例。\r\n","Type to validated":"输入验证\r\n","\r\n            Method, property, event, or null.\r\n            A virtual property on Binder (i.e. our usual pattern) would be more robust, but the applicability\r\n            of this property is so narrow that it doesn't seem worthwhile.\r\n            ":"\r\n            方法，属性，事件或null。\r\n            粘合剂上的虚拟属性（即我们通常的模式）将更加健壮，但是适用性\r\n            这个属性是如此狭窄，似乎不值得。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': accessibility modifiers may not be used on accessors in an interface.\r\n            ":"\r\n              查找类似于“ {0}'：可访问性修饰符的本地化字符串，不得在接口中的访问器上使用。\r\n            \r\n","Cannot use a member of result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope":"在此上下文中无法使用“ {0}”结果的成员，因为它可能会在其声明范围外面揭示参数'{1}'引用的变量\r\n","Invalid public key.":"无效的公钥。\r\n"," array at the same index.\r\n            ":" 数组处于相同的索引。\r\n            \r\n","\r\n             This method is used in deeply recursive parts of the compiler. Specifically this and\r\n             ":"\r\n             该方法用于编译器的深层递归部分。具体而言\r\n             \r\n","\r\n            An ArrayTypeSymbol represents an array type, such as int[] or object[,].\r\n            ":"\r\n            ArrayTypesymbol表示数组类型，例如INT []或Object [，]。\r\n            \r\n","\r\n              Looks up a localized string similar to XML comment has cref attribute '{0}' that could not be resolved.\r\n            ":"\r\n              查找类似于XML注释的本地化字符串具有无法解决的cref属性'{0}'。\r\n            \r\n","\r\n            Get parent trivia.\r\n            ":"\r\n            获取父母琐事。\r\n            \r\n","The params parameter cannot be declared as {0}":"参数不能声明为{0}\r\n","\r\n            Check that the given name designates a tuple element at the given index, and return that element.\r\n            ":"\r\n            检查给定名称是否在给定索引处指定元组元素，然后返回该元素。\r\n            \r\n","\r\n            True if the property itself is excluded from code coverage instrumentation.\r\n            True for source properties marked with ":"\r\n            如果将属性本身排除在代码覆盖仪器中，则是正确的。\r\n            对于标记的源属性为true\r\n","\r\n            The base class for all symbols (namespaces, classes, method, parameters, etc.) that are \r\n            exposed by the compiler.\r\n            ":"\r\n            所有符号（名称空间，类，方法，参数等）的基类是\r\n            由编译器暴露。\r\n            \r\n","\r\n            Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.\r\n            ":"\r\n            获取SwitchSectionsyntax的语法列表，该语法代表开关语句的开关部分。\r\n            \r\n","\r\n            Returns true if the conversion is a conversion to or from IntPtr or UIntPtr.\r\n            This includes:\r\n              IntPtr to/from int\r\n              IntPtr to/from long\r\n              IntPtr to/from void*\r\n              UIntPtr to/from int\r\n              UIntPtr to/from long\r\n              UIntPtr to/from void*\r\n            ":"\r\n            如果转换是往返INTPTR或UINTPTR的转换，则返回true。\r\n            这包括：\r\n              int tor in int int int int\r\n              intptr到/远。\r\n              intptr到/从void*\r\n              uintptr到int/int\r\n              uintptr到/远。\r\n              uintptr到/从void*\r\n            \r\n","\r\n            If this is a lazy nullable type pending resolution, forces this to be resolved.\r\n            ":"\r\n            如果这是一种懒惰的型号待解决的分辨率，请迫使这要解决。\r\n            \r\n","One of the parameters of a binary operator must be the containing type":"二进制操作员的参数之一必须是包含类型\r\n","\r\n            CONSIDER: Can we share some code will call rewriting in the local rewriter?\r\n            ":"\r\n            考虑：我们可以共享一些代码会在本地重写中调用重写吗？\r\n            \r\n","\r\n            Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax \r\n            within ":"\r\n            返回什么“添加”方法符号（如果有）对应于给定的表达语法\r\n            内\r\n","Cannot modify members of '{0}' because it is a '{1}'":"无法修改“ {0}”的成员，因为它是'{1}'\r\n","\r\n            Represents SZARRAY - zero-based one-dimensional array \r\n            ":"\r\n            代表szarray-基于零的一维数组\r\n            \r\n","\r\n              Looks up a localized string similar to covariant.\r\n            ":"查找类似于协变量的局部字符串。\r\n            \r\n","The yield statement cannot be used inside an anonymous method or lambda expression":"收益语句不能在匿名方法或lambda表达式中使用\r\n","\r\n              Looks up a localized string similar to The command line switch '{0}' is not yet implemented and was ignored..\r\n            ":"\r\n              查找类似于命令行开关'{0}'的本地化字符串尚未实现和被忽略。\r\n            \r\n","\r\n            All fields should have already been added as synthesized members on the\r\n            ":"\r\n            所有字段都应在综合成员中添加\r\n            \r\n","Creates a new DoStatementSyntax instance.":"创建一个新的dostatementsyntax实例。\r\n","A fixed size buffer field must have the array size specifier after the field name":"固定的大小缓冲区字段必须具有字段名称之后的数组大小指示符\r\n","\r\n              Looks up a localized string similar to pattern matching.\r\n            ":"\r\n              查找类似于模式匹配的本地化字符串。\r\n            \r\n","\r\n            Since this formula is rather opaque, a demonstration of its correctness is\r\n            provided in Roslyn.Compilers.CSharp.UnitTests.CompletionTests.TestHasAtMostOneBitSet.\r\n            ":"\r\n            由于此公式相当不透明，因此证明其正确性是\r\n            在Roslyn.com.pilers.csharp.unittests.completiontests.testhasatmostonebitset中提供。\r\n            \r\n","\r\n            Keep in sync with Binder.BindCrefParameterOrReturnType.\r\n            ":"\r\n            与binder保持同步。\r\n            \r\n","\r\n            Given an initializer expression infer the name of anonymous property or tuple element.\r\n            Returns null if unsuccessful\r\n            ":"\r\n            给定一个初始器表达式推断匿名属性或元组元素的名称。\r\n            返回零如果不成功\r\n            \r\n","Called when the visitor visits a DoStatementSyntax node.":"访问者访问dostatementsyntax节点时调用。\r\n","\r\n              Looks up a localized string similar to Cannot use #load after first token in file.\r\n            ":"\r\n              查找类似于文件后的局部字符串，类似于文件中的#load。\r\n            \r\n","\r\n            Is the pattern fully matched and ready for the when clause to be evaluated (if any)?\r\n            ":"\r\n            该模式是否完全匹配并准备好评估WHER子句（如果有）？\r\n            \r\n","\r\n            Synthesizes an expression that evaluates to the current module's MVID.\r\n            ":"合成评估当前模块MVID的表达式。\r\n            \r\n","Gets the parameter list.":"获取参数列表。\r\n","\r\n              Looks up a localized string similar to Members of readonly field '{0}' cannot be passed ref or out (except in a constructor).\r\n            ":"\r\n              查找类似于Readonly字段'{0}'成员的本地化字符串，无法传递或输出（在构造函数中除外）。\r\n            \r\n","\r\n            The following are rvalues: values, variables, null literals, properties\r\n            and indexers with getters, events. The following are not rvalues:\r\n            namespaces, types, method groups, anonymous functions.\r\n            ":"\r\n            以下是RVALUE：值，变量，无效文字，属性\r\n            以及带有Getters，Events的索引器。以下不是RVALUE：\r\n            名称空间，类型，方法组，匿名函数。\r\n            \r\n"," \r\n            Features: dynamic.\r\n            ":" \r\n            功能：动态。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot convert null to '{0}' because it is a non-nullable value type.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法将null转换为'{0}'，因为它是不可删除的值类型。\r\n            \r\n","A list of syntax nodes that represents the content of the xml multi line element.":"表示XML多行元素内容的语法节点列表。\r\n","IdentifierNameSyntax node representing the name of the alias":"dissinifierNamesyntax节点表示别名的名称\r\n","The __arglist construct is valid only within a variable argument method":"__arglist构造仅在变量参数方法中有效\r\n","\r\n            A tuple of TypeParameterSymbol and DiagnosticInfo, created for errors\r\n            reported from ConstraintsHelper rather than creating Diagnostics directly.\r\n            This decouples constraints checking from syntax and Locations, and supports\r\n            callers that may want to create Location instances lazily or not at all.\r\n            ":"\r\n            为错误而创建的Typeparametersymbol和Diagnosticinfo的元组\r\n            从Constraintshelper报告，而不是直接创建诊断。\r\n            这将分解从语法和位置检查的约束，并支持\r\n            可能想要懒惰或根本不创建位置实例的呼叫者。\r\n            \r\n","Native sized integers":"本地大小的整数\r\n","#r is only allowed in scripts":"#r仅在脚本中允许\r\n","\r\n            A collection of the non-constant local variables and parameters that have been referenced in anonymous functions\r\n            and therefore must be moved to a field of a frame class.\r\n            ":"\r\n            在匿名函数中已引用的非恒定本地变量和参数的集合\r\n            因此，必须移至框架类的字段。\r\n            \r\n","You can only take the address of an unfixed expression inside of a fixed statement initializer":"您只能在固定语句初始化器内的未固定表达式的地址取\r\n","\r\n            Substitutes references from old type arguments to new type arguments\r\n            in the lowered methods.\r\n            ":"\r\n            从旧类型参数替代引用到新类型参数\r\n            在降低的方法中。\r\n            \r\n","\r\n            Is it possible that the given symbol can be accessed somewhere in the given assembly?\r\n            For the purposes of this test, we assume that code in the given assembly might derive from\r\n            any type. So protected members are considered potentially accessible.\r\n            ":"\r\n            是否可以在给定的组件中的某个地方访问给定符号？\r\n            出于该测试的目的，我们假设给定的组件中的代码可能来自\r\n            随便哪种。因此，受保护的成员被认为是可以访问的。\r\n            \r\n","\r\n              Looks up a localized string similar to The DllImport attribute cannot be applied to a method that is generic or contained in a generic type..\r\n            ":"\r\n              查找类似于dllimport属性的本地化字符串不能应用于通用类型中的通用方法或包含的方法。\r\n            \r\n","Called when the visitor visits a SwitchExpressionArmSyntax node.":"当访问者访问switchexpressionarmsyntax节点时调用。\r\n","Unexpected use of a generic name":"通用名称的意外使用\r\n","\r\n            A symbol to be used as a placeholder for an instance being constructed by\r\n            ":"\r\n            一个被用作实例的占位符的符号\r\n            \r\n","\r\n            This instance is the same as RuntimeSignatureComparer.\r\n            CONSIDER: just use RuntimeSignatureComparer?\r\n            ":"\r\n            此实例与RunTimesIgnatureComparer相同。\r\n            考虑：只需使用RuntimesIgnatureComparer？\r\n            \r\n","Incorrect syntax was used in a comment.":"评论中使用了错误的语法。\r\n","\r\n            This overload exists for callers who\r\n              a) Already have a node in hand and don't want to search through the tree\r\n              b) May want to search from an indirect container (e.g. node containing node\r\n                 containing position).\r\n            ":"\r\n            对于呼叫者而存在此超负荷\r\n              a）已经有一个节点，不想在树上搜索\r\n              b）可能要从间接容器中搜索（例如，包含节点的节点\r\n                 包含位置）。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid version {0} for /subsystemversion. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise.\r\n            ":"\r\n              查找类似于 /subsystemverion的无效版本{0}的本地化字符串。 ARM或AppContainerexe的版本必须为6.02或更高，否则为4.00或更高。\r\n            \r\n"," that represents\r\n            a module that is not missing, i.e. the \"real\" thing.\r\n            ":" 代表\r\n            一个不丢失的模块，即“真实”的东西。\r\n            \r\n","\r\n            Gets the language version.\r\n            ":"获取语​​言版本。\r\n            \r\n","The metadata name of the (potentially) forwarded type, including the arity (if non-zero).":"（潜在）转发类型的元数据名称，包括Arity（如果非零）。\r\n","\r\n            Unconditionally visits an expression.\r\n            If the expression has \"state when not null\" after visiting,\r\n            the method returns 'true' and writes the state to ":"\r\n            无条件访问表达。\r\n            如果该表达在访问后具有“状态”，则\r\n            该方法返回“ true”，并将状态写入\r\n","\r\n            Bind the implicit constructor initializer of a constructor symbol.\r\n            ":"\r\n            绑定构造函数符号的隐式构造函数。\r\n            \r\n","\r\n              Looks up a localized string similar to Member implements interface member with multiple matches at run-time.\r\n            ":"\r\n              在运行时查找类似于具有多个匹配的成员Internface成员的本地化字符串。\r\n            \r\n","Returns true if the list contains a token which matches ":"如果列表包含一个匹配的令牌，则返回true\r\n","\r\n            Creates a new anonymous type descriptor based on 'this' one, \r\n            but having field types passed as an argument.\r\n            ":"\r\n            创建一个基于“ this”的新匿名类型描述符，\r\n            但是让字段类型作为参数传递。\r\n            \r\n","\r\n              Looks up a localized string similar to Fields of static readonly field '{0}' cannot be used as a ref or out value (except in a static constructor).\r\n            ":"\r\n              查找类似于静态读取字段'{0}'字段类似的本地化字符串，不能用作ref或out值（在静态构造函数中除外）。\r\n            \r\n","Called when the visitor visits a SingleVariableDesignationSyntax node.":"当访客访问单个符号符号元素节点时，请致电。\r\n","\r\n            Gets the type of this field along with its annotations.\r\n            ":"\r\n            获取此字段的类型及其注释。\r\n            \r\n","MetadataReference '{0}' not found to remove.":"找不到删除的元数据'{0}'。\r\n"," if there were no characters \r\n            remaining.\r\n            ":" 如果没有字符\r\n            其余的。\r\n            \r\n","Target label":"目标标签\r\n","\r\n              Looks up a localized string similar to '{0}': a class cannot be both static and sealed.\r\n            ":"\r\n              查找类似于“ {0}”的局部字符串：类不能既静态又密封。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': array elements cannot be of static type.\r\n            ":"\r\n              查找类似于'{0}'：数组元素的本地化字符串不能为静态类型。\r\n            \r\n","\r\n              Looks up a localized string similar to The {1} '{0}' cannot be used with type arguments.\r\n            ":"\r\n              查找类似于{1}'{0}'的本地化字符串，不能与类型参数一起使用。\r\n            \r\n","\r\n            A source parameter, potentially with a default value, attributes, etc.\r\n            ":"\r\n            源参数，可能具有默认值，属性等。\r\n            \r\n","\r\n            Subclasses may override EnterRegion to perform any actions at the entry to the region.\r\n            ":"\r\n            子类可以覆盖EnterRegion以在该地区的入口处执行任何操作。\r\n            \r\n","'{0}' cannot implement both '{1}' and '{2}' because they may unify for some type parameter substitutions":"'{0}'不能同时实现'{1}'和'{2}'，因为它们可以统一某种类型的参数替换\r\n","\r\n            Parse a single variable designation (e.g. `x`) or a wildcard designation (e.g. `_`)\r\n            ":"\r\n            解析单个变量名称（例如`x`）或通配符名称（例如`_`）\r\n            \r\n","null propagating operator":"零繁殖操作员\r\n","\r\n              Looks up a localized string similar to No defining declaration found for implementing declaration of partial method '{0}'.\r\n            ":"\r\n              查找一个本地化字符串，类似于未找到用于实现部分方法声明'{0}'声明的定义声明。\r\n            \r\n","The xml text new line value.":"XML文本新线路值。\r\n","\r\n            Get this accessibility that was declared on this symbol. For symbols that do not have\r\n            accessibility declared on them, returns ":"\r\n            获取此符号上声明的可访问性。对于没有的符号\r\n            在他们上声明的可访问性，退货\r\n","Creates a new ExternAliasDirectiveSyntax instance.":"创建一个新的externaliasDirectiveSyntax实例。\r\n","Parse options.":"解析选项。\r\n","\r\n              Looks up a localized string similar to A new expression requires (), [], or {} after type.\r\n            ":"\r\n              在type之后查找类似于新表达式（），[]或{}的本地化字符串。\r\n            \r\n","\r\n            are possible: both true when the set is nonempty and all values satisfy the relation; both false when the set is nonempty and none of\r\n            the values satisfy the relation; all but not any when the set is empty; any but not all when the set is nonempty and some values satisfy\r\n            the relation and some do not.\r\n            ":"\r\n            可能是可能的：当该集合是非空的，并且所有价值都满足关系时，既正确;两者是非空置的，都不是\r\n            值满足关系；当该集合为空时，但不是所有；当该集合是非空的，并且某些价值观满足时，但不是全部\r\n            关系和有些没有。\r\n            \r\n","'{0}' does not implement the '{1}' pattern. '{2}' is not a public instance or extension method.":"'{0}'不会实现'{1}'模式。 '{2}'不是公共实例或扩展方法。\r\n","\r\n              Looks up a localized string similar to '{0}': a field cannot be both volatile and readonly.\r\n            ":"\r\n              查找类似于“ {0}”的局部字符串：一个字段不能既挥发又可以阅读。\r\n            \r\n","\r\n            A symbol reference to a type or non-type member that is qualified by an enclosing type or namespace.\r\n            For example, cref=\"System.String.ToString()\".\r\n            NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax\r\n            will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol\r\n            might be a non-type member.\r\n            ":"\r\n            符号引用由封闭类型或名称空间资格的类型或非类型成员的引用。\r\n            例如，cref =“ system.string.tostring（）”。\r\n            注意：typecrefsyntax，合格crefsyntax和成员crefsyntax重叠。 typecrefsyntax中的语法\r\n            始终将被绑定为类型，因此使用合格的crefsyntax或成员crefsyntax是更安全的\r\n            可能是非型成员。\r\n            \r\n","\r\n            The AssemblySymbol that represents the assembly being created.\r\n            ":"\r\n            代表正在创建的组件的汇编符号。\r\n            \r\n","\r\n            True if the current token could be the beginning of a cref parameter.\r\n            ":"\r\n            如果电流令牌可能是CREF参数的开始，则是正确的。\r\n            \r\n"," reads a field; ":" 读一个字段；\r\n","\r\n            Represents a named type that is based on another named type.\r\n            When inheriting from this class, one shouldn't assume that \r\n            the default behavior it has is appropriate for every case.\r\n            That behavior should be carefully reviewed and derived type\r\n            should override behavior as appropriate.\r\n            ":"\r\n            代表基于另一种命名类型的命名类型。\r\n            从这个课程继承时，不应该假设\r\n            它具有的默认行为适用于每种情况。\r\n            该行为应仔细审查和派生类型\r\n            应适当地覆盖行为。\r\n            \r\n","\r\n            Apply type substitution to a generic method to create an method symbol with the given type parameters supplied.\r\n            ":"\r\n            将类型替换应用于通用方法，以创建使用给定类型参数的方法符号。\r\n            \r\n","'{0}': return type must be '{2}' to match overridden member '{1}'":"'{0}'：返回类型必须为'{2}'才能匹配覆盖成员'{1}'\r\n","The namespace alias qualifier '::' always resolves to a type or namespace so is illegal here. Consider using '.' instead.":"名称空间别名预选赛::'总是解决类型或名称空间，因此在这里是非法的。考虑使用“。”。反而。\r\n"," that represents its eventual completion. The task will\r\n            always end in the ":" 这代表其最终的完成。任务将\r\n            总是以\r\n","\r\n            The placeholders that are used for ":"\r\n            用来的占位符\r\n","\r\n            BlockSyntax node representing the body of the lambda.\r\n            Only one of Block or ExpressionBody will be non-null.\r\n            ":"\r\n            代表Lambda主体的blocksyntax节点。\r\n            只有一个块或表达机构将是非零的。\r\n            \r\n","\r\n            This will cause the bound node cache to be populated if nullable semantic analysis is enabled.\r\n            ":"\r\n            如果启用了可确定的语义分析，这将导致绑定的节点缓存填充。\r\n            \r\n","Represents the base class for all statements syntax classes.":"代表所有语句语法类的基类。\r\n","\r\n            Match local declarations to names to generate a map from\r\n            declaration to local slot. The names are indexed by slot and the\r\n            assumption is that declarations are in the same order as slots.\r\n            ":"\r\n            将本地声明与名称匹配，以生成地图\r\n            声明本地插槽。名称由插槽和\r\n            假设声明与插槽的顺序相同。\r\n            \r\n","The generators that will run as part of this driver.":"将作为此驱动程序的一部分运行的发电机。\r\n","\r\n              Looks up a localized string similar to A readonly field cannot be returned by reference.\r\n            ":"\r\n              查找类似于ReadOnly字段的本地化字符串无法通过参考返回。\r\n            \r\n","'{0}': cannot override inherited member '{1}' because it is sealed":"'{0}'：不能覆盖继承的成员'{1}'，因为它已密封\r\n","\r\n            Creates a binder with given import computation function.\r\n            ":"\r\n            创建具有给定的导入计算功能的粘合剂。\r\n            \r\n","\r\n            Null for implicit, \r\n            BaseConstructorInitializerSyntax.ArgumentList, or \r\n            ThisConstructorInitializerSyntax.ArgumentList, or \r\n            BaseClassWithArgumentsSyntax.ArgumentList for explicit.":"\r\n            null以隐式，\r\n            baseconstructorinitializersyntax.argumentList，或\r\n            thisconstructorinitializersyntax.argumentList，或\r\n            baseclasswithargumentssyntax.argumentList用于显式。\r\n","\r\n              Looks up a localized string similar to To cast a negative value, you must enclose the value in parentheses..\r\n            ":"\r\n              查找类似于施放负值的局部字符串，您必须将值包装在括号中。\r\n            \r\n"," is negative (not valid) until it is adjusted.\r\n            This tends to happen when we need to merge an old change deletion into a new change near the beginning of the text. (see TextChangeTests.Fuzz_4)\r\n            ":" 在调整之前为负（无效）。\r\n            当我们需要将旧更改删除合并为文本开头附近的新更改时，这往往会发生。 （请参阅textchangetests.fuzz_4）\r\n            \r\n","\r\n            The flow analysis pass.  This pass reports required diagnostics for unreachable\r\n            statements and uninitialized variables (through the call to FlowAnalysisWalker.Analyze),\r\n            and inserts a final return statement if the end of a void-returning method is reachable.\r\n            ":"\r\n            流量分析通过。该通行证报告需要诊断无法达到无法达到的诊断\r\n            陈述和非初始化的变量（通过呼叫流纳分析行 - 分析），Analyze），\r\n            如果可以达到空隙回归方法的终结，则插入最终返回语句。\r\n            \r\n","Anonymous type field location":"匿名类型字段位置\r\n","Creates a new AnonymousObjectCreationExpressionSyntax instance.":"创建一个新的AnonymoBjectCreationExpressyntax实例。\r\n","Called when the visitor visits a XmlElementSyntax node.":"当访问者访问xmlelementsyntax节点时调用。\r\n","\r\n            A member with the same signature if currTypeHasExactMatch is true,\r\n            a member with (a minimal number of) different custom modifiers if there is one,\r\n            and null otherwise.":"\r\n            具有相同签名的成员如果currtypehasexactmatch为真，\r\n            具有（最少数量）不同自定义修饰符的成员，如果有一个，则\r\n            否则为无效。\r\n","\r\n            Returns true if the conversion is explicit.\r\n            ":"\r\n            如果转换是明确的，则返回true。\r\n            \r\n","The input expression, cast to the required type if needed":"输入表达式，如果需要的话，将其施放为所需的类型\r\n","\r\n              Looks up a localized string similar to Combined length of user strings used by the program exceeds allowed limit. Try to decrease use of string literals..\r\n            ":"\r\n              查找类似于程序使用的用户字符串的组合长度超过允许限制的局部字符串。尝试减少字符串文字的使用。\r\n            \r\n","Creates a new GotoStatementSyntax instance.":"创建一个新的gotostatementsyntax实例。\r\n","Nullability of reference types in type of parameter doesn't match implicitly implemented member.":"参数类型中参考类型的无性性不匹配隐式实现的成员。\r\n"," but strongly typed to ":" 但强烈打字到\r\n","Conflicting options specified: Win32 resource file; Win32 manifest":"指定的相互冲突选项：WIN32资源文件； Win32清单\r\n","\r\n            Compare two symbol objects to see if they refer to the same symbol. You should always\r\n            use == and !=, or the Equals method, to compare two symbols for equality.\r\n            ":"\r\n            比较两个符号对象，以查看它们是否指的是相同的符号。你应该永远\r\n            使用== and！=，或等于方法，以比较两个符号以进行平等。\r\n            \r\n"," true. A subsequent call with\r\n               ":" 真的。随后的电话\r\n               \r\n","\r\n              Looks up a localized string similar to Preprocessor directive expected.\r\n            ":"\r\n              查找类似于预期预处理指令的本地化字符串。\r\n            \r\n","Invalid value for argument to '{0}' attribute":"参数的无效值为“ {0}'属性\r\n","\r\n            Returns an appropriate error code if scanning this verbatim literal ran into an error.\r\n            ":"\r\n            如果扫描此逐字字面的文字遇到错误，则返回适当的错误代码。\r\n            \r\n",".  The output is defined as the input\r\n            narrowed according to the pattern's *narrowed type*; see https://github.com/dotnet/csharplang/issues/2850.\r\n            ":"。输出定义为输入\r\n            根据模式的 *狭窄类型 *缩小；请参阅https://github.com/dotnet/csharplang/issues/2850。\r\n            \r\n","\r\n              Looks up a localized string similar to The local function '{0}' is declared but never used.\r\n            ":"\r\n              查找类似于本地函数'{0}'的本地化字符串，但从未使用过。\r\n            \r\n","s, and returns true if the original pattern is a\r\n            negated form of the inner pattern.\r\n            ":"s，如果原始图案是一个\r\n            内部模式的否定形式。\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability of reference types in value of type '{0}' doesn't match target type '{1}'..\r\n            ":"\r\n              查找类型类型为“ {0}”中的参考类型的无效类型的本地化字符串，不匹配目标类型'{1}'..\r\n            \r\n","PEModuleSymbol containing the namespace.":"包含名称空间的pemodulesymbol。\r\n"," behave as \r\n                  local variables declared at the scope of the invocation.\r\n            ":" 表现为\r\n                  在调用范围内声明的本地变量。\r\n            \r\n","\r\n            We revise the returned label for a leaf so that all leaves in the same switch section are given the same label.\r\n            This enables the switch emitter to produce better code.\r\n            ":"\r\n            我们修改了叶片的返回标签，以便给出同一开关部分中的所有叶子都具有相同的标签。\r\n            这使开关发射极能够产生更好的代码。\r\n            \r\n","\r\n            NOTE: Dev10 doesn't seem to treat attributes as being within the unsafe region.\r\n            Fortunately, not following this behavior should not be a breaking change since\r\n            attribute arguments have to be constants and there are no constants of unsafe\r\n            types.\r\n            ":"\r\n            注意：dev10似乎并没有将属性视为不安全的区域内。\r\n            幸运的是，不遵循这种行为不应该是打破的变化，因为\r\n            属性论点必须是常数，没有不安全的常数\r\n            类型。\r\n            \r\n","Missing argument for '/keepalive' option.":"缺少“/keepalive”选项的参数。\r\n",".  Therefore type parameters typically cannot be ":"。因此，键入参数通常不能是\r\n",", which is either a nullable reference type OR \r\n            is a constructed type with a nullable reference type present in its type argument tree,\r\n            returns a synthesized NullableAttribute with encoded nullable transforms array.\r\n            ":"，它是无效的参考类型或\r\n            是一种构造类型，具有其类型参数树中存在的无效参考类型，\r\n            返回带有编码的无效转换数组的合成的nulleableattribute。\r\n            \r\n","\r\n              Looks up a localized string similar to The name '{0}' does not match the corresponding 'Deconstruct' parameter '{1}'..\r\n            ":"\r\n              查找类似于名称'{0}'的本地化字符串不匹配相应的“解构”参数'{1}'..\r\n            \r\n","\r\n            Perform additional checks after the member has been\r\n            added to the member list of the containing type.\r\n            ":"\r\n            成员已完成后执行其他检查\r\n            添加到包含类型的成员列表中。\r\n            \r\n","\r\n            Represents __value field of an enum.\r\n            ":"\r\n            代表枚举的__值字段。\r\n            \r\n","\r\n              Looks up a localized string similar to Type is not CLS-compliant.\r\n            ":"\r\n              查找类似于类型的本地化字符串不符合CLS。\r\n            \r\n","\r\n              Looks up a localized string similar to items: must be non-empty.\r\n            ":"\r\n              查找类似于项目的局部字符串：必须是非空的。\r\n            \r\n",") pairs for additional methods that the lambda rewriter produced.\r\n            These additional methods contain the bodies of the lambdas moved into ordinary methods of their\r\n            respective frame classes, and the caller is responsible for processing them just as it does with\r\n            the returned bound node.  For example, the caller will typically perform iterator method and\r\n            asynchronous method transformations, and emit IL instructions into an assembly.\r\n            ":"）对Lambda重写者产生的其他方法的配对。\r\n            这些附加方法包含兰巴斯的尸体，进入了其普通方法\r\n            各自的帧类，呼叫者负责处理它们\r\n            返回的绑定节点。例如，呼叫者通常会执行迭代器方法和\r\n            异步方法转换，并将IL指令发射到一个组件中。\r\n            \r\n","\r\n             Checks whether the field name is reserved and tells us which position it's reserved for.\r\n            \r\n             For example:\r\n             Returns 3 for \"Item3\".\r\n             Returns 0 for \"Rest\", \"ToString\" and other members of System.ValueTuple.\r\n             Returns -1 for names that aren't reserved.\r\n             ":"\r\n             检查字段名称是否保留，并告诉我们它保留的位置。\r\n            \r\n             例如：\r\n             返回“ item3”的3。\r\n             返回0的“休息”，“ Tostring”和System.Valuetuple的其他成员。\r\n             返回-1对于不保留的名称。\r\n             \r\n","\r\n            Test if all of the value in the set satisfy the given relation with the given value. Note that the empty set trivially satisfies this.\r\n            Because of that all four combinations of results from ":"\r\n            测试集合中的所有值是否满足给定值的给定关系。请注意，空套在琐碎的地方满足了这一点。\r\n            因此，所有四个结果的组合\r\n","\r\n            Create the optimized plan for the location of lambda methods and whether scopes need access to parent scopes\r\n             ":"\r\n            为lambda方法的位置创建优化的计划，以及范围是否需要访问父范围\r\n             \r\n","Creates a new QueryBodySyntax instance.":"创建一个新的querybodysyntax实例。\r\n","\r\n            The class to represent all generic type parameters imported from a PE/module.\r\n            ":"\r\n            代表从PE/模块导入的所有通用类型参数的类。\r\n            \r\n","Bound expression builder.":"结合表达构建器。\r\n","The syntax node of the switch label.":"开关标签的语法节点。\r\n","\r\n            Returns true if the local variable is declared in resource-acquisition of a 'using statement';\r\n            otherwise false\r\n            ":"\r\n            返回如果在“使用语句”的资源获得中声明本地变量；\r\n            否则错误\r\n            \r\n","NameColonSyntax node representing the optional name arguments.":"代表可选名称参数的namecolonsyntax节点。\r\n","\r\n            Checks if 'symbol' is accessible from within type 'within', with\r\n            an optional qualifier of type \"throughTypeOpt\".\r\n            ":"\r\n            检查是否可以从类型“内部”中访问“符号”，\r\n            类型“ Printypeopt”的可选资格赛。\r\n            \r\n","\r\n            Used to construct a pattern index offset expression, of the form\r\n                `unloweredExpr.GetOffset(lengthAccess)`\r\n            where unloweredExpr is an expression of type System.Index and the\r\n            lengthAccess retrieves the length of the indexing target.\r\n            ":"\r\n            用于构建形式的模式索引偏移表达式\r\n                `unloweredexpr.getOffset（lengthAccess）``\r\n            funloweredexpr是类型system.index和\r\n            LengthAccess检索索引目标的长度。\r\n            \r\n","\r\n            A map of members immediately contained within this type \r\n            grouped by their name (case-sensitively).\r\n            ":"\r\n            此类型中立即包含的成员地图\r\n            按其名称分组（案例敏感）。\r\n            \r\n","Method overload resolution improvements when arguments differ by 'in'":"当参数因“ in”不同时，方法过载分辨率改进\r\n","Microsoft (R) Visual C# Compiler":"Microsoft（R）Visual C＃编译器\r\n","'{0}' cannot be sealed because it is not an override":"'{0}'不能密封，因为它不是覆盖\r\n","Set to false if the caller has already checked that\r\n            ":"设置为false，如果呼叫者已经检查了\r\n            \r\n","\r\n            Perform control flow analysis, reporting all necessary diagnostics.  Returns true if the end of\r\n            the body might be reachable...\r\n            ":"\r\n            执行控制流分析，报告所有必要的诊断。如果结束\r\n            身体可能是可以达到的...\r\n            \r\n","'{0}' cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute":"'{0}'不能将其标记为CLS兼容，因为组件没有CLSCompliant属性\r\n","\r\n            For \"receiver.event += expr\", produce \"receiver.add_event(expr)\".\r\n            For \"receiver.event -= expr\", produce \"receiver.remove_event(expr)\".\r\n            ":"\r\n            为\"接收器。事件+=expr\"，产生\"接收器。add_event(expr)\"。\r\n            为\"接收器。事件-=expr\"，产生\"接收器。remove_event(expr)\"。\r\n            \r\n","A symbol for the special member.":"特别成员的符号。\r\n"," delegate and associated state to be executed immediately on\r\n            another thread, and returns a ":" 将立即执行的委托和相关状态\r\n            另一个线程，然后返回\r\n","\r\n            If the Kind is ExtendKind.Module, returns the module symbol that this namespace\r\n            encompasses. Otherwise throws InvalidOperationException.\r\n            ":"\r\n            如果类型是ExtendKind.module，请返回此名称空间的模块符号\r\n            包含。否则会引发无效的exception。\r\n            \r\n","You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking":"您必须在组件上指定CLSCompliant属性，而不是模块，以启用CLS合规性检查\r\n","\r\n              Looks up a localized string similar to Cannot convert to static type '{0}'.\r\n            ":"查找类似于不能转换为静态类型'{0}'的本地化字符串。\r\n            \r\n","\r\n            Adds C# specific parts to the line directive map.\r\n            ":"将C＃特定零件添加到行指令地图。\r\n            \r\n","\r\n              Looks up a localized string similar to The annotation for nullable reference types should only be used in code within a '#nullable' annotations context..\r\n            ":"\r\n              查找类似于无效的参考类型注释的本地化字符串，仅在“ #nullable”注释上下文中的代码中使用。\r\n            \r\n","\r\n            Introduce a frame around the translation of the given node.\r\n            ":"\r\n            引入围绕给定节点的翻译框架。\r\n            \r\n","Array of bound initializer expressions.":"绑定初始化器表达式数组。\r\n","\r\n            The underlying FieldSymbol.\r\n            ":"\r\n            底层符号。\r\n            \r\n","\r\n            Substitute types, and return the results without duplicates, preserving the original order.\r\n            ":"\r\n            替换类型，并在不重复的情况下返回结果，保留原始订单。\r\n            \r\n","\r\n            The closure that this scope is nested inside. Null if this scope is not nested\r\n            inside a closure.\r\n            ":"\r\n            该范围嵌套在里面的闭合。无效，如果此范围不嵌套\r\n            在封闭中。\r\n            \r\n","\r\n            A type name with alias prefix (Alias::Name)\r\n            ":"\r\n            带有别名前缀的类型名称（别名::名称）\r\n            \r\n","\r\n            Conversion kind must not be a user defined conversion, use the other overload which takes a 'Conversion' parameter for generating synthesized user defined conversions.\r\n            ":"\r\n            转换类型不得是用户定义的转换，使用其他过载，该过载采用“转换”参数来生成合成的用户定义的转换。\r\n            \r\n","Resource stream ended at {0} bytes, expected {1} bytes.":"资源流以{0}字节结束，预期{1}字节。\r\n","\r\n            Synthesize a call `expression.Method()`, but with some extra smarts to handle extension methods, and to fill-in optional and params parameters. This call expects that the\r\n            receiver parameter has already been visited.\r\n            ":"\r\n            合成一个呼叫`expression.Method（）`，但具有一些额外的智能来处理扩展方法，并填充可选和参数。这个电话期望\r\n            接收器参数已经访问。\r\n            \r\n","The source/destination pairs for the assignments":"作业的源/目标对\r\n","Called when the visitor visits a VarPatternSyntax node.":"当访问者访问varpatternsyntax节点时调用。\r\n","The second operand of an 'is' or 'as' operator may not be a static type":"AN“ IS”或“ AS”操作员的第二个操作数可能不是静态类型\r\n","\r\n            Determines if a bound node, or any child, grandchild, etc has an error (not warning)\r\n            diagnostic associated with it. The HasError bit is initially set for a node by providing it\r\n            to the node constructor. If any child nodes of a node have\r\n            the HasErrors bit set, then it is automatically set to true on the parent bound node.\r\n            \r\n            HasErrors indicates that the tree is not emittable and used to short-circuit lowering/emit stages.\r\n            NOTE: not having HasErrors does not guarantee that we do not have any diagnostic associated\r\n                  with corresponding syntax or type.\r\n            ":"\r\n            确定绑定的节点或任何孩子，孙子等是否有错误（不警告）\r\n            与之相关的诊断。 Haserror位最初是为节点设置的\r\n            到节点构造函数。如果有一个节点的子节点\r\n            haserrors位设置，然后在父绑定节点上自动设置为true。\r\n            \r\n            haserrors表明该树是不可报明的，并且用于降低/发射阶段。\r\n            注意：没有haserrors不能保证我们没有任何诊断相关的\r\n                  带有相应的语法或类型。\r\n            \r\n"," being false means ":" 是错误的手段\r\n","\r\n            Force the inference of the ResultType from LValueResultType.\r\n            ":"\r\n            迫使LVALUERESULTTYPE的结果类型推断。\r\n            \r\n","Fields of static readonly field '{0}' cannot be assigned to (except in a static constructor or a variable initializer)":"静态读取字段'{0}'的字段不能分配给（在静态构造函数或可变初始器中除外）\r\n","The node of interest.":"感兴趣的节点。\r\n","\r\n            A type must be known to be a (non-nullable)\r\n            type in order to be ":"\r\n            一种类型必须已知是（不可用）\r\n            输入为了\r\n","Called when the visitor visits a OperatorDeclarationSyntax node.":"当访问者访问operatoDeclarationsyntax节点时，请致电。\r\n","\r\n            Expression is the RHS of an assignment operation\r\n            and may be a method group.\r\n            ":"\r\n            表达是分配操作的RHS\r\n            并且可能是方法组。\r\n            \r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 7.1. Please use language version {1} or greater..\r\n            ":"\r\n              查找类似于功能“ {0}”的本地化字符串在C＃7.1中不可用。请使用语言版本{1}或更大。\r\n            \r\n","\r\n            Implicit method group conversions are described in section 6.6 of the C# language specification.\r\n            ":"\r\n            隐式方法组转换在C＃语言规范的第6.6节中描述。\r\n            \r\n","\r\n            Synthesize a call `expression.Method()`, but with some extra smarts to handle extension methods, and to fill-in optional and params parameters.\r\n            ":"\r\n            合成一个呼叫`expression.Method（）`，但具有一些额外的智能来处理扩展方法，并填充可选和参数。\r\n            \r\n","Indexing an array with a negative index":"索引带有负索引的数组\r\n","A string literal with the given value.":"带有给定值的字符串文字。\r\n",", but without custom modifiers.\r\n            May differ in object/dynamic, tuple element names, or other differences ignored by the runtime.":"，但没有自定义修饰符。\r\n            可能在对象/动态，元组元素名称或运行时忽略的其他差异上有所不同。\r\n","(this, ...) == (..., this.Mutate())":"（this，...）==（...，this.mutate（））\r\n","\r\n              Looks up a localized string similar to Cannot use a result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope.\r\n            ":"\r\n              在此上下文中查找类似于“ {0}”的结果，因为它可能会在其声明范围之外通过参数'{1}'引用的变量。\r\n            \r\n","Only report diagnostics from this syntax tree, if non-null.":"仅报告该语法树的诊断，如果没有null。\r\n","Combined length of user strings used by the program exceeds allowed limit. Try to decrease use of string literals.":"程序使用的用户字符串的组合长度超过了允许的限制。尝试减少字符串文字的使用。\r\n","\r\n            Unfortunately, when determining overriding/hiding/implementation relationships, we don't \r\n            have the \"current\" compilation available.  We could, but that would clutter up the API \r\n            without providing much benefit.  As a compromise, we consider all compilations \"current\".\r\n            ":"\r\n            不幸的是，在确定覆盖/隐藏/实施关系时，我们不\r\n            具有可用的“当前”汇编。我们可以，但这会使API混乱\r\n            没有提供很多好处。作为妥协，我们认为所有汇编“当前”。\r\n            \r\n","Gets the identifier.":"获取标识符。\r\n","Async lambda expressions cannot be converted to expression trees":"异步lambda表达式不能转换为表达树\r\n","Called when the visitor visits a DefaultExpressionSyntax node.":"当访问者访问DefaultExpressyntax节点时调用。\r\n","XML comment has badly formed XML":"XML评论的XML形成不佳\r\n","\r\n            Rewrite an iterator method into a state machine class.\r\n            ":"\r\n            将迭代方法重写为状态计算机类。\r\n            \r\n","Deserialization reader for '{0}' read incorrect number of values.":"“ {0}”读取不正确数量的值读取器。\r\n","\r\n            Gets the root namespace that contains all namespaces and types defined in source code or in\r\n            referenced metadata, merged into a single namespace hierarchy.\r\n            ":"\r\n            获取包含所有名称空间和源代码中定义的类型的根名称空间\r\n            引用元数据，合并为单个名称空间层次结构。\r\n            \r\n","Enhancement of interpolated verbatim strings":"增强插值的逐字串\r\n","The matching method symbol, or null if the inputs do not correspond to a valid method.":"匹配方法符号或null如果输入不对应于有效方法。\r\n","How specific diagnostics should be reported":"应如何报告特定的诊断\r\n",". During override resolution,\r\n            if we find two methods that match except for ":"。在覆盖分辨率期间，\r\n            如果我们找到两种匹配的方法\r\n","\r\n            Represents a small change from the enclosing/next binder.\r\n            Can specify a BindingLocation and a ContainingMemberOrLambda.\r\n            ":"\r\n            代表与封闭/下一个活页夹相比的小变化。\r\n            可以指定bindinglocation和一个包含的成员lambda。\r\n            \r\n"," as we resolve TypeRefs from the module.\r\n            ":" 当我们从模块解析键入时。\r\n            \r\n","Both partial method declarations must be static or neither may be static":"两种部分方法声明必须是静态的，或者都不是静态的\r\n","'{0}' hides inherited abstract member '{1}'":"'{0}'隐藏的抽象成员'{1}'\r\n","\r\n            A utility class for making a decision dag (directed acyclic graph) for a pattern-matching construct.\r\n            A decision dag is represented by\r\n            the class ":"\r\n            用于制作模式匹配构建体的决策DAG（定向无环图）的实用程序类。\r\n            决策DAG由\r\n            班上\r\n","\r\n            The latest major supported version.\r\n            ":"\r\n            最新的主要支持版本。\r\n            \r\n","\r\n            Report a given variable as not definitely assigned.  Once a variable has been so\r\n            reported, we suppress further reports of that variable.\r\n            ":"\r\n            报告给定变量不确定。一旦变量如此\r\n            报告，我们抑制了该变量的进一步报告。\r\n            \r\n","Fields of static readonly field '{0}' cannot be used as a ref or out value (except in a static constructor)":"静态读取字段'{0}'的字段不能用作ref或输出值（静态构造函数除外）\r\n","\r\n            Pointer, nullable, or array types are only allowed if ":"\r\n            仅当指针，无效或数组类型才允许\r\n","\r\n            Report an error if a member (other than a method) exists with the same name\r\n            as the property accessor, or if a method exists with the same name and signature.\r\n            ":"\r\n            报告错误（方法除外）具有相同名称的错误\r\n            作为属性登录器，或者如果存在具有相同名称和签名的方法。\r\n            \r\n","\r\n            True if this symbol has a runtime-special name (metadata flag RuntimeSpecialName is set).\r\n            ":"\r\n            是的，如果此符号具有特定于运行时的名称（设置了Metadata flag runtimespecialname）。\r\n            \r\n"," map, inserting arguments for optional parameters, etc.\r\n            ":" 地图，插入可选参数的参数，等等。\r\n            \r\n","]]>":"]]>\r\n","\r\n            True if the parameter has a default argument syntax, \r\n            or the parameter is from source and ":"\r\n            true如果参数具有默认参数语法，则\r\n            或参数来自源和\r\n","\r\n              Looks up a localized string similar to A readonly field cannot be passed ref or out (except in a constructor).\r\n            ":"\r\n              查找类似于可读字段的本地化字符串无法传递或输出（在构造函数中除外）。\r\n            \r\n","\r\n            Symbol for a deconstruction local that might require type inference.\r\n            For instance, local `x` in `var (x, y) = ...` or `(var x, int y) = ...`.\r\n            ":"解构本地的符号可能需要类型推理。\r\n            例如，在`var（x，y）= ...`or`（var x，int y）= ...`in`var（x，y）中的local`X`''。\r\n            \r\n","The parameter name '{0}' conflicts with an automatically-generated parameter name":"参数名称'{0}'与自动生成的参数名称冲突\r\n","\r\n            Get the next binder in which to look up a name, if not found by this binder.\r\n            ":"\r\n            获取下一个可以查找名称的活页夹，即使该粘合剂找不到的话。\r\n            \r\n","\r\n            The returned assemblies may also forward the type.\r\n            ":"\r\n            返回的组件也可以转发类型。\r\n            \r\n","\r\n            Owning RetargetingModuleSymbol.\r\n            ":"\r\n            拥有retargetingModulesymbol。\r\n            \r\n","\r\n            Returns true if the conversion is an implicit enumeration conversion or explicit enumeration conversion.\r\n            ":"\r\n            如果转换是隐式枚举转换或明确的枚举转换，则返回true。\r\n            \r\n","Asynchronous disposable":"异步一次性\r\n","\r\n              Looks up a localized string similar to CLS-compliant field '{0}' cannot be volatile.\r\n            ":"\r\n              查找类似于符合CLS的字段'{0}'的本地化字符串，这不可能是波动的。\r\n            \r\n","Creates a new SkippedTokensTriviaSyntax instance.":"创建一个新的跳过tokenstriviaSyntax实例。\r\n","\r\n            (3) The \"this\" symbol for the current method in ":"\r\n            （3）当前方法中的“此”符号\r\n","=>":"=>\r\n","\r\n            Only non-null for sealed properties without both accessors.\r\n            ":"\r\n            仅用于没有两个登记器的密封特性的非挂钩。\r\n            \r\n"," \r\n            C# language version 6.0.\r\n            ":" \r\n            C＃语言版本6.0。\r\n            \r\n","\r\n              Looks up a localized string similar to 'MethodImplOptions.Synchronized' cannot be applied to an async method.\r\n            ":"\r\n              查找类似于“ methodimploptions.synchronized”的局部字符串不能应用于异步方法。\r\n            \r\n","\r\n            Is this System.Nullable`1 type, or its substitution.\r\n            \r\n            To check whether a type is System.Nullable`1 or is a type parameter constrained to System.Nullable`1\r\n            use ":"\r\n            是该系统.nullable'1类型还是替换。\r\n            \r\n            检查一个类型是system.nullable`1还是是限制在system.nullable'1的类型参数\r\n            利用\r\n","\r\n            If the call represents an extension method invocation with an explicit receiver, return the original\r\n            methods as ReducedExtensionMethodSymbols. Otherwise, return the original methods unchanged.\r\n            ":"\r\n            如果呼叫代表具有显式接收器的扩展方法调用，请返回原始\r\n            方法作为还原远程符号。否则，返回原始方法不变。\r\n            \r\n","\r\n              Looks up a localized string similar to async function.\r\n            ":"\r\n              查找类似于异步函数的局部字符串。\r\n            \r\n","Called when the visitor visits a XmlCrefAttributeSyntax node.":"当访问者访问XMLCRefattributesyntax节点时，请致电。\r\n","\r\n            A RangeVariableSymbol represents an identifier introduced in a query expression as the\r\n            identifier of a \"from\" clause, an \"into\" query continuation, a \"let\" clause, or a \"join\" clause.\r\n            ":"\r\n            rangevariablesymbol表示在查询表达式中引入的标识符作为标识符\r\n            “来自”子句的标识符，“查询连续”，“ let”子句或“ join”子句。\r\n            \r\n","Creates a new PragmaChecksumDirectiveTriviaSyntax instance.":"创建一个新的pragmachecksumdirectivetriviasyntax实例。\r\n","\r\n            Bind an expression as a method invocation.\r\n            ":"\r\n            将表达式绑定为方法调用。\r\n            \r\n","\r\n            This portion of the binder converts StatementSyntax nodes into BoundStatements\r\n            ":"\r\n            活页夹的这一部分将语句yntax节点转换为边界施加\r\n            \r\n","\r\n            Absent parameter types to bind the arguments, we simply use the arguments provided for error recovery.\r\n            ":"\r\n            缺乏参数类型来绑定参数，我们只是使用提供的参数进行错误恢复。\r\n            \r\n","\r\n              Looks up a localized string similar to Expected ; or = (cannot specify constructor arguments in declaration).\r\n            ":"\r\n              查找类似于预期的局部字符串；或=（无法在声明中指定构造函数）。\r\n            \r\n","\r\n            Represents a compiler generated and embedded attribute type.\r\n            This type has the following properties:\r\n            1) It is non-generic, sealed, internal, non-static class.\r\n            2) It derives from System.Attribute\r\n            3) It has Microsoft.CodeAnalysis.EmbeddedAttribute\r\n            4) It has System.Runtime.CompilerServices.CompilerGeneratedAttribute\r\n            ":"\r\n            代表编译器生成和嵌入式属性类型。\r\n            此类型具有以下属性：\r\n            1）它是非生成的，密封的，内部的，非静态类的。\r\n            2）它源自system.tribute\r\n            3）它具有Microsoft.sodeanalysis.embeddedattribute\r\n            4）它具有system.runtime.compilerServices.com pilergeneratedAttribute\r\n            \r\n","\r\n            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte signed integer value.\r\n            ":"\r\n            从文本和相应的4字节签名的整数值中创建一个具有属性数字的令牌。\r\n            \r\n","\r\n            Tracks variables for which we have already reported a definite assignment error.  This\r\n            allows us to report at most one such error per variable.\r\n            ":"\r\n            跟踪我们已经报告了确定分配错误的变量。这个\r\n            允许我们最多报告每个变量的错误。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot await in the body of a lock statement.\r\n            ":"\r\n              在锁定语句的正文中查找类似于等待的局部字符串。\r\n            \r\n","Modifiers cannot be placed on event accessor declarations":"修饰符不能放在事件访问声明上\r\n"," property.\r\n            If called on an instance of ":" 财产。\r\n            如果在一个实例中调用\r\n","Creates a new FieldDeclarationSyntax instance.":"创建一个新的fieldDeclarationsyntax实例。\r\n","Missing path attribute":"缺少路径属性\r\n","Converts the value of the current Index object to its equivalent string representation.":"将当前索引对象的值转换为其等效字符串表示。\r\n","(..., GetTuple()) == (..., (..., ...))":"（...，getTuple（））==（...，（...，...））\r\n"," for the kind of synthesized variable.\r\n            ":" 对于合成变量的种类。\r\n            \r\n","\r\n            or null if the signature could not be inferred.\r\n            ":"\r\n            或null如果无法推断签名。\r\n            \r\n","Key file '{0}' is missing the private key needed for signing":"密钥文件'{0}'缺少签名所需的私钥\r\n","\r\n            A type name with alias prefix (Alias::Name).  Note that Alias::Name.X would not fall under this.  This\r\n            only is returned for exactly Alias::Name.\r\n            ":"\r\n            带有别名前缀的类型名称（Alias ::名称）。请注意，别名:: name.x不会属于此。这个\r\n            仅返回以完全拒绝别名::名称。\r\n            \r\n","\r\n              Looks up a localized string similar to Evaluation of the decimal constant expression failed.\r\n            ":"\r\n              查找类似于评估小数常数表达式失败的局部字符串。\r\n            \r\n","Class which represents a placeholder in the type argument list of an unbound generic type.":"类别代表无限通用类型的类型参数列表中的占位符。\r\n","Called when the visitor visits a NullableDirectiveTriviaSyntax node.":"当访问者访问nullabledirectiviviasyntax节点时，请致电。\r\n","\r\n            Returns a value indicating which embedded attributes should be generated during emit phase.\r\n            The value is set during binding the symbols that need those attributes, and is frozen on first trial to get it.\r\n            Freezing is needed to make sure that nothing tries to modify the value after the value is read.\r\n            ":"\r\n            返回一个值，指示在EMIT阶段生成哪些嵌入属性。\r\n            该值是在绑定需要这些属性的符号期间设置的，并在第一次试验中被冻结以获取它。\r\n            需要冻结以确保在读取值后没有试图修改值。\r\n            \r\n","Called when the visitor visits a YieldStatementSyntax node.":"当访问者访问yarverStatementsyntax节点时，请致电。\r\n","\r\n              Looks up a localized string similar to lambda expression.\r\n            ":"\r\n              查找类似于lambda表达式的局部字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Element initializer cannot be empty.\r\n            ":"\r\n              查找类似于Element Initializer的本地化字符串不能为空。\r\n            \r\n","\r\n            C# language version 6\r\n            ":"\r\n            C＃语言版本6\r\n            \r\n","\r\n            A NoPiaMissingCanonicalTypeSymbol is a special kind of ErrorSymbol that represents a NoPia\r\n            embedded type symbol that was attempted to be substituted with canonical type, but the\r\n            canonical type couldn't be found.\r\n            ":"\r\n            nopiamissingcanonicaltypesymbol是一种特殊的错误符号，代表NOPIA\r\n            试图用规范类型代替的嵌入式类型符号，但\r\n            找不到规范类型。\r\n            \r\n","\r\n              Looks up a localized string similar to Possible unintended reference comparison; right hand side needs cast.\r\n            ":"\r\n              查找类似于可能意外参考比较的局部字符串；右手需要铸造。\r\n            \r\n","SymbolInfo options.":"符号选项。\r\n"," passed in.  If ":" 传递。如果\r\n","\r\n             Returns the nested type at a certain depth.\r\n            \r\n             For depth=0, just return the tuple type as-is.\r\n             For depth=1, returns the nested tuple type at position 8.\r\n             ":"\r\n             返回一定深度的嵌套类型。\r\n            \r\n             对于深度= 0，只需返回元组类型。\r\n             对于深度= 1，在位置8返回嵌套元组类型。\r\n             \r\n","\r\n            The label in the code for the beginning of code for each node of the dag.\r\n            ":"\r\n            代码的标签，用于DAG的每个节点的代码开头。\r\n            \r\n","Unmanaged type '{0}' not valid for fields.":"非托管类型'{0}'对字段无效。\r\n","Missing XML comment for publicly visible type or member":"缺少公开可见类型或成员的XML评论\r\n","\r\n            Return the flow analysis state associated with a label.\r\n            ":"\r\n            返回与标签相关的流分析状态。\r\n            \r\n","\r\n              Looks up a localized string similar to 'in' expected.\r\n            ":"\r\n              查找类似于“预期”的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to The parameter name '{0}' conflicts with an automatically-generated parameter name.\r\n            ":"\r\n              查找类似于参数名称'{0}'与自动生成的参数名称相似的本地化字符串。\r\n            \r\n","\r\n            Utility class for substituting actual type arguments for formal generic type parameters.\r\n            ":"\r\n            用于将实际类型参数替换为正式通用类型参数的实用程序类。\r\n            \r\n","Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create numeric literal tokens.":"使用Microsoft.codeanalysis.csharp.syntaxfactory.literal创建数字文字令牌。\r\n","\r\n            Construct a body for an auto-property accessor (updating or returning the backing field).\r\n            ":"\r\n            为自动陶艺登录器（更新或返回衬板）​​构建车身。\r\n            \r\n","ConfigureAwait(bool)":"配置（bool）\r\n","The text for the full string literal, including the quotes and contents":"完整字符串文字的文字，包括引号和内容\r\n","\r\n              Looks up a localized string similar to Do not use '_' for a case constant..\r\n            ":"\r\n              查找类似于不使用'_'的局部字符串作为情况常数。\r\n            \r\n","{0} must either be 'default' or have the same length as {1}.":"{0}必须是'默认值'或具有与{1}相同的长度。\r\n","Both partial method declarations, '{0}' and '{1}', must use the same tuple element names.":"两种部分方法声明'{0}'和'{1}'必须使用相同的元组元素名称。\r\n","Implicitly-typed local variables cannot be fixed":"隐式型的本地变量无法修复\r\n","\r\n              Looks up a localized string similar to Syntax node is not within syntax tree.\r\n            ":"\r\n              查找类似于语法节点的本地化字符串不在语法树中。\r\n            \r\n","\r\n            The candidate member was rejected because another member further down in the inheritance hierarchy was\r\n            present.\r\n            ":"\r\n            候选人成员被拒绝，因为继承等级的另一名成员是\r\n            当下。\r\n            \r\n"," as its parent.":" 作为父母。\r\n","The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. Nullability of type argument '{3}' doesn't match constraint type '{1}'.":"类型'{3}'在通用类型或方法'{0}'中不能用作类型参数'{2}'。类型参数'{3}'的无效性不匹配约束类型'{1}'。\r\n","\r\n            This method should be kept consistent with MethodBodySynthesizer.ConstructStringSwitchHashFunctionBody\r\n            The control flow in this method mimics lowered \"for\" loop. It is exactly what we want to emit\r\n            to ensure that JIT can do range check hoisting.\r\n            ":"\r\n            该方法应与MethodbodySynthesizer.constructStringsWitchHashFunction Body保持一致\r\n            此方法中的控制流模拟降低“为”循环。这正是我们想要发出的\r\n            为了确保JIT可以进行范围检查提升。\r\n            \r\n","\r\n            Symbol representing a using alias appearing in a compilation unit or within a namespace\r\n            declaration. Generally speaking, these symbols do not appear in the set of symbols reachable\r\n            from the unnamed namespace declaration.  In other words, when a using alias is used in a\r\n            program, it acts as a transparent alias, and the symbol to which it is an alias is used in\r\n            the symbol table.  For example, in the source code\r\n            ":"\r\n            代表符号出现在汇编单元或命名空间中的符号\r\n            宣言。一般来说，这些符号在可触时的符号集中没有出现\r\n            从未命名的名称空间声明中。换句话说，当使用使用别名\r\n            程序，它充当透明别名，并且它是一个别名的符号\r\n            符号表。例如，在源代码中\r\n            \r\n","covariantly":"协变\r\n","\r\n            The underlying ModuleSymbol for retargetingModule.\r\n            ":"\r\n            retargetingModule的基础模块。\r\n            \r\n","\r\n            Gets the associated attribute usage info for an attribute type.\r\n            ":"\r\n            获取属性类型的关联属性使用信息。\r\n            \r\n","The syntax node that declares one or more fields or events.":"声明一个或多个字段或事件的语法节点。\r\n","Called when the visitor visits a IdentifierNameSyntax node.":"当访问者访问标识Namesyntax节点时调用。\r\n","\r\n            Type symbol being compiled, or null if we compile a synthesized type that doesn't have a symbol (e.g. PrivateImplementationDetails).\r\n            ":"\r\n            类型的符号将被编译，或者如果我们编译没有符号的合成类型（例如privateImplementationDetails），则为null。\r\n            \r\n","First argument to a security attribute must be a valid SecurityAction":"对安全属性的第一个参数必须是有效的安全性。\r\n","Gets the constraint keyword (\"class\" or \"struct\").":"获取约束关键字（“类”或“ struct”）。\r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 4. Please use language version {1} or greater..\r\n            ":"\r\n              查找类似于功能'{0}'的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to A readonly field cannot be assigned to (except in a constructor or a variable initializer).\r\n            ":"查找类似于ReadOnly字段的本地化字符串无法分配给（在构造函数或变量初始器中除外）。\r\n            \r\n","True if extra tokens in the input following a declaration should be treated as an error":"如果应将声明后的输入中的额外令牌视为错误\r\n","\r\n            Returns true if the Unicode character is a decimal digit.\r\n            ":"\r\n            如果Unicode字符是十进制数字，则返回true。\r\n            \r\n","Called when the visitor visits a ThrowExpressionSyntax node.":"当访问者访问throw expressionsyntax节点时，请致电。\r\n","The 'class', 'struct', 'unmanaged', 'notnull', and 'default' constraints cannot be combined or duplicated, and must be specified first in the constraints list.":"不能合并或重复“类”，“ struct”，“ struct”，“ notnull”和“ notnull”和“默认”约束，必须首先在约束列表中指定。\r\n","\r\n              Looks up a localized string similar to Tuple with {0} elements cannot be converted to type '{1}'..\r\n            ":"\r\n              查找类似于带有{0}元素的元组的本地化字符串，无法转换为type'{1}'..\r\n            \r\n","The values are not affected by line mapping directives (":"这些值不受行映射指令的影响（\r\n","\r\n              Looks up a localized string similar to Named attribute argument expected.\r\n            ":"\r\n              查找类似于预期命名属性参数的本地化字符串。\r\n            \r\n","Creates a new TupleTypeSyntax instance.":"创建一个新的TupleTypesyntax实例。\r\n","\r\n              Looks up a localized string similar to The class type constraint '{0}' must come before any other constraints.\r\n            ":"\r\n              查找类似于类类型约束'{0}'的本地化字符串必须在任何其他约束之前。\r\n            \r\n","\r\n            A NoPiaAmbiguousCanonicalTypeSymbol is a special kind of ErrorSymbol that represents a NoPia\r\n            embedded type symbol that was attempted to be substituted with canonical type, but the\r\n            canonical type was ambiguous.\r\n            ":"\r\n            nopiabiguulcanonicaltypesymbol是一种特殊的错误符号，代表NOPIA\r\n            试图用规范类型代替的嵌入式类型符号，但\r\n            规范类型是模棱两可的。\r\n            \r\n","\r\n            True when the \"peverify-compat\" feature flag is set or the language version is below C# 7.2.\r\n            With this flag we will avoid certain patterns known not be compatible with PEVerify.\r\n            The code may be less efficient and may deviate from spec in corner cases.\r\n            The flag is only to be used if PEVerify pass is extremely important.\r\n            ":"\r\n            当设置“ Peverify-compat”功能标志或语言版本低于C＃7.2时，则正确。\r\n            使用此标志，我们将避免某些已知的模式与Peverify不兼容。\r\n            该代码的效率可能较低，并且在角案例中可能会偏离规格。\r\n            只有在Peverify Pass极为重要的情况下，才能使用标志。\r\n            \r\n","Called when the visitor visits a RefValueExpressionSyntax node.":"当访问者访问refvalueExpressyntax节点时调用。\r\n","\r\n              Looks up a localized string similar to Type '{1}' already reserves a member called '{0}' with the same parameter types.\r\n            ":"\r\n              查找类似于类型的'{1}'类型的本地化字符串已经保留了一个名为“ {0}”的成员，具有相同的参数类型。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' cannot derive from special class '{1}'.\r\n            ":"\r\n              查找类似于“ {0}'不能从特殊类'{1}'派生的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to tree must have a root node with SyntaxKind.CompilationUnit.\r\n            ":"\r\n              查找类似于树类似的本地化字符串，必须带有语法上的root节点。\r\n            \r\n","A new decision dag that does not reference the input directly":"不直接引用输入的新决策DAG\r\n","SimpleNameSyntax node representing the name that is being alias qualified.":"SimpleNamesyntax节点表示为别名合格的名称。\r\n","Constraints are not allowed on non-generic declarations":"在非生成声明中不允许限制\r\n","\r\n              Looks up a localized string similar to A nested array initializer is expected.\r\n            ":"\r\n              可以预期查找类似于嵌套阵列初始化器的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Filter expression is a constant 'false', consider removing the try-catch block.\r\n            ":"\r\n              查找类似于过滤器表达式的本地化字符串是常数“ false”，请考虑删除try-catch块。\r\n            \r\n","\r\n              Looks up a localized string similar to The result of the expression is always 'null'.\r\n            ":"\r\n              查找类似于表达式结果的局部字符串总是“ null”。\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability of reference types in return type doesn't match implemented member '{0}'..\r\n            ":"查找类似于返回类型中参考类型的无效性类似的本地化字符串与实现的成员'{0}'..\r\n            \r\n","\r\n            Does not respect DocumentationMode, so use a temporary bag if diagnostics are not desired.\r\n            ":"\r\n            不尊重文档模式，因此，如果不需要诊断，请使用临时袋。\r\n            \r\n","\r\n            Begins running the builder with the associated state machine.\r\n            ":"\r\n            开始使用关联的状态计算机运行构建器。\r\n            \r\n","\r\n            The implementation of a value set for an numeric type ":"\r\n            用于数字类型的值集的实现\r\n","\r\n            to allow types and function signatures to be treated similarly in ":"\r\n            允许类型和功能签名在\r\n","\r\n              Looks up a localized string similar to variable.\r\n            ":"\r\n              查找类似于变量的本地化字符串。\r\n            \r\n","\r\n            If class represents fixed buffer, this property returns the FixedElementField\r\n            ":"\r\n            如果类代表固定的缓冲区，则此属性返回filexelementField\r\n            \r\n","The new() constraint must be the last constraint specified":"新（）约束必须是指定的最后一个约束\r\n"," might return a symbol, but that symbol guaranteed to be from an interface.\r\n             - If the first request is done with ":" 可能会返回一个符号，但是该符号保证来自接口。\r\n              - 如果第一个请求已完成\r\n","\r\n              Looks up a localized string similar to '{0}': not all code paths return a value.\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串：并非所有代码路径返回值。\r\n            \r\n","\r\n              Looks up a localized string similar to Explicit interface implementation '{0}' matches more than one interface member. Which interface member is actually chosen is implementation-dependent. Consider using a non-explicit implementation instead..\r\n            ":"\r\n              查找类似于显式接口实现的本地化字符串'{0}'匹配多个接口成员。实际选择哪个接口成员是实现依赖性的。考虑使用非明确实施。\r\n            \r\n","local functions":"本地功能\r\n","Called when the visitor visits a DeclarationPatternSyntax node.":"当访问者访问dectarationpatternsyntax节点时，请致电。\r\n","Keyword 'this' or 'base' expected":"关键字“ this”或“基础”期望\r\n","\r\n            The bag in which semantic analysis should deposit its diagnostics.\r\n            ":"\r\n            语义分析应沉积其诊断的袋子。\r\n            \r\n","\r\n            A symbol is accessible for referencing in a cref if it is in the same assembly as the reference\r\n            or the symbols's effective visibility is not private.\r\n            ":"\r\n            如果符号与引用位于同一程序集中，则可以在cref中进行引用\r\n            或者符号的有效可见性不是私有的。\r\n            \r\n","\r\n              Looks up a localized string similar to Elements defined in a namespace cannot be explicitly declared as private, protected, or protected internal.\r\n            ":"\r\n              查找类似于名称空间中定义的元素的本地化字符串，不能明确声明为私人，受保护或受保护的内部。\r\n            \r\n","\r\n              Looks up a localized string similar to params is not valid in this context.\r\n            ":"\r\n              在此上下文中查找类似于参数的本地化字符串是无效的。\r\n            \r\n","params is not valid in this context":"在这种情况下，参数无效\r\n","The type '{0}' may not be used as a type argument":"类型'{0}'不可用作类型参数\r\n","Creates a new XmlElementStartTagSyntax instance.":"创建一个新的XmlelementStartTagSyntax实例。\r\n","; Override this with specific\r\n            implementation; Calling ":";用特定的\r\n            执行;打电话\r\n","\r\n            for the kinds of decisions that can appear in a decision tree.\r\n            \r\n            The strategy for building the decision tree is: the top node is a ByType if the input\r\n            could possibly be null. Otherwise it is a ByValue. Then, based on the type of switch\r\n            label, we navigate to the appropriate node of the existing decision tree and insert\r\n            a new decision tree node representing the condition associated with the new switch case.\r\n            ":"\r\n            对于可能出现在决策树中的决策。\r\n            \r\n            构建决策树的策略是：如果输入，顶点是bytype\r\n            可能是无效的。否则，这是一个小字节。然后，基于开关的类型\r\n            标签，我们导航到现有决策树的适当节点并插入\r\n            一个新的决策树节点，代表与新开关情况相关的条件。\r\n            \r\n","\r\n              Looks up a localized string similar to Inconsistent accessibility: constraint type '{1}' is less accessible than '{0}'.\r\n            ":"\r\n              查找类似于不一致的可访问性的本地化字符串：约束类型'{1}''不如'{0}'易于访问。\r\n            \r\n","Type parameter has the same name as the type parameter from outer type":"类型参数具有与外部类型的类型参数相同的名称\r\n","\r\n              Looks up a localized string similar to '{0}' does not implement interface member '{1}'. '{2}' is not public..\r\n            ":"\r\n              查找类似于“ {0}'的本地化字符串”不实现接口成员'{1}'。 '{2}'不是公开..\r\n            \r\n","\r\n             Optionally apply a conversion to the receiver.\r\n            \r\n             If the receiver is of struct type and the method is an interface method, then skip the conversion.\r\n             When we call the interface method directly - the code generator will detect it and generate a\r\n             constrained virtual call.\r\n             ":"\r\n             可选地将转换应用于接收器。\r\n            \r\n             如果接收器为struct类型，该方法是接口方法，请跳过转换。\r\n             当我们直接调用接口方法时 - 代码生成器将检测并生成一个\r\n             约束虚拟呼叫。\r\n             \r\n","\r\n              Looks up a localized string similar to Type does not implement the collection pattern; member has the wrong signature.\r\n            ":"\r\n              查找类似于类型的本地化字符串不会实现集合模式。成员的签名错误。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot specify 'readonly' modifiers on both accessors of property or indexer '{0}'. Instead, put a 'readonly' modifier on the property itself..\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法在属性或索引器'{0}'的登录器上指定“ ReadOnly”修饰符。相反，在属性本身上放置一个“读取”修饰符。\r\n            \r\n","(int x1, (long x2, long x3)) = deconstructable1":"（int x1，（长x2，long x3））=解构1\r\n","\r\n            Identity conversions are described in section 6.1.1 of the C# language specification.\r\n            ":"\r\n            身份转换在C＃语言规范的第6.1.1节中描述。\r\n            \r\n","\r\n            Merges given diagnostic to the existing result diagnostic.\r\n            ":"\r\n            合并对现有结果诊断的诊断。\r\n            \r\n","\r\n            Map from when clause's syntax to the lowered code for the matched pattern. The code for a section\r\n            includes the code to assign to the pattern variables and evaluate the when clause. Since a\r\n            when clause can yield a false value, it can jump back to a label in the lowered decision dag.\r\n            ":"\r\n            从子句的语法到匹配模式的降低代码的映射。部分的代码\r\n            包括将代码分配给模式变量并评估何时子句。自从\r\n            当子句产生一个错误的值时，它可以跳回降低的决策DAG中的标签。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use a member of result of '{0}' in this context because it may expose variables referenced by parameter '{1}' outside of their declaration scope.\r\n            ":"\r\n              在此上下文中查找类似于“ {0}”结果的本地化字符串，因为它可能会在其声明范围外通过参数'{1}'引用的变量。\r\n            \r\n","\r\n             Bind the syntax into a namespace, type or alias symbol. \r\n             ":"\r\n             将语法绑定到名称空间，类型或别名符号中。\r\n             \r\n","Unexpected preprocessor directive":"意外的预处理器指令\r\n","Cannot use local variable '{0}' before it is declared. The declaration of the local variable hides the field '{1}'.":"在声明之前不能使用局部变量'{0}'。本地变量的声明隐藏了“ {1}”字段。\r\n","\r\n            This pass doesn't rewrite the local function calls themselves\r\n            because we may encounter a call to a local function that has yet\r\n            to be lowered. Here we just want to make sure we lower the\r\n            arguments as they may contain references to captured variables.\r\n            The final lowering of the call will be in the\r\n            ":"\r\n            此通行证不会重写本地函数自己调用\r\n            因为我们可能会遇到对尚未有的本地函数的电话\r\n            降低。在这里，我们只想确保我们降低\r\n            参数可能包含对捕获变量的引用。\r\n            通话的最后降低将在\r\n            \r\n","Receiver of method call.":"方法调用的接收器。\r\n","\r\n            A list of all the nodes reachable from the root node, in a topologically sorted order.\r\n            ":"\r\n            以拓扑排序的顺序从根节点获取的所有节点的列表。\r\n            \r\n","\r\n              Looks up a localized string similar to Error reading debug information for '{0}'.\r\n            ":"\r\n              查找类似于“ {0}”的错误读取调试信息的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to #endregion directive expected.\r\n            ":"\r\n              查找类似于#endregion指令预期的本地化字符串。\r\n            \r\n","\r\n            Get a source type symbol of given name, arity and kind.  If a tree and syntax are provided, restrict the results\r\n            to those that are declared within the given syntax.\r\n            ":"\r\n            获取给定名称，Arity和and and的源类型符号。如果提供了树和语法，请限制结果\r\n            对于在给定语法中声明的人。\r\n            \r\n","The other declaration":"另一个声明\r\n","Gets the interface keyword token.":"获取接口关键字令牌。\r\n","Gets the modifier list.":"获取修饰符列表。\r\n","\r\n            Returns true if the lookahead tokens compose extern alias directive.\r\n            ":"\r\n            如果LookAhead代币构成外部别名指令，则返回真实。\r\n            \r\n","Throws this exception if ":"抛出此例外\r\n","\r\n            Associates the builder with the specified state machine.\r\n            ":"\r\n            将构建器与指定的状态机相关联。\r\n            \r\n","\r\n            Helper that will use Array.Empty if available and elements have 0 length\r\n            NOTE: it is valid only if we know that the API that is being called will not \r\n                  retain or use the array argument for any purpose (like locking or key in a hash table)\r\n                  Typical example of valid use is Linq.Expressions factories - they do not make any \r\n                  assumptions about array arguments and do not keep them or rely on their identity.\r\n            ":"\r\n            将使用阵列的助手，如果可用，empty且元素具有0长度的长度\r\n            注意：仅当我们知道被称为的API不会\r\n                  保留或为任何目的保留数组参数（例如锁定或在哈希表中锁定）\r\n                  有效使用的典型示例是Linq.Expressions工厂 - 它们不做任何\r\n                  关于数组论点的假设，不保留它们或依靠它们的身份。\r\n            \r\n","\r\n            Tests whether a list contains a token of a particular kind.\r\n            ":"\r\n            测试列表是否包含特定类型的令牌。\r\n            \r\n","\r\n              Looks up a localized string similar to Auto-implemented properties must override all accessors of the overridden property..\r\n            ":"\r\n              查找类似于自动实施属性的本地化字符串必须覆盖被覆盖属性的所有访问者。\r\n            \r\n","\r\n              Looks up a localized string similar to readonly automatically implemented properties.\r\n            ":"\r\n              查找类似于自动实现的属性类似的本地化字符串。\r\n            \r\n","The first operand of an 'is' or 'as' operator may not be a lambda expression, anonymous method, or method group.":"AN“ IS”或“ AS”操作员的第一操作数可能不是Lambda表达式，匿名方法或方法组。\r\n","Called when the visitor visits a XmlProcessingInstructionSyntax node.":"访问者访问XMLProcessingInstructionsyntax节点时调用。\r\n","The non-generic {1} '{0}' cannot be used with type arguments":"非生成{1}'{0}'不能与类型参数一起使用\r\n","'{0}': property or indexer cannot have void type":"'{0}'：属性或索引器不能具有void类型\r\n","ExpressionSyntax representing the value the member is initialized with.":"表示成员初始化的值。\r\n","\r\n            Rewrites arguments of an invocation according to the receiving method or indexer.\r\n            It is assumed that each argument has already been lowered, but we may need\r\n            additional rewriting for the arguments, such as generating a params array, re-ordering\r\n            arguments based on ":"\r\n            根据接收方法或索引器重写调用的参数。\r\n            假定每个参数已经降低，但我们可能需要\r\n            参数的其他重写，例如生成参数数组，重新排序\r\n            基于参数\r\n","\r\n            Type of right operand is used and nullable left operand is converted\r\n            to underlying type before converting to right operand type.\r\n            ":"\r\n            使用右操作数的类型，可转换为无效的左操作数\r\n            在转换为正确操作数类型之前，要进行基础类型。\r\n            \r\n","\r\n            Called when overload resolution has failed.  Figures out the best way to describe what went wrong.\r\n            ":"\r\n            当过载分辨率失败时调用。描述了描述出了什么问题的最佳方法。\r\n            \r\n","\r\n            The spec describes an algorithm for finding the following types:\r\n              1) Collection type\r\n              2) Enumerator type\r\n              3) Element type\r\n              \r\n            The implementation details are a bit different.  If we're iterating over a string or an array, then we don't need to record anything\r\n            but the inferredType (in case the iteration variable is implicitly typed).  If we're iterating over anything else, then we want the \r\n            inferred type plus a ForEachEnumeratorInfo.Builder with:\r\n              1) Collection type\r\n              2) Element type\r\n              3) GetEnumerator (or GetAsyncEnumerator) method of the collection type (return type will be the enumerator type from the spec)\r\n              4) Current property and MoveNext (or MoveNextAsync) method of the enumerator type\r\n              \r\n            The caller will have to do some extra conversion checks before creating a ForEachEnumeratorInfo for the BoundForEachStatement.\r\n            ":"\r\n            该规范描述了用于查找以下类型的算法：\r\n              1）收集类型\r\n              2）枚​​举类型\r\n              3）元素类型\r\n              \r\n            实现细节有些不同。如果我们在字符串或数组中迭代，那么我们就不需要记录任何内容\r\n            但是推论型（如果迭代变量被隐式键入）。如果我们要迭代其他任何东西，那么我们想要\r\n            推断类型加上foreachEnumeratorInfo.builder with：\r\n              1）收集类型\r\n              2）元素类型\r\n              3）集合类型的getEnumerator（或getAsyncenumerator）方法（返回类型将是Spec的枚举类型）\r\n              4）枚举类型的当前属性和movenext（或moveNextAsync）方法\r\n              \r\n            呼叫者将必须进行一些额外的转换检查，然后为BONDEREACHSTATETEMT创建ForeachEnumeratorInfo。\r\n            \r\n","A value of an integral type expected":"预期的积分类型的值\r\n","The type forwarder for type '{0}' in assembly '{1}' causes a cycle":"类型'{0}'在汇编'{1}'的类型转发器导致一个周期\r\n","\r\n            Holds onto data related to reference binding.\r\n            The manager is shared among multiple compilations that we expect to have the same result of reference binding.\r\n            In most cases this can be determined without performing the binding. If the compilation however contains a circular\r\n            metadata reference (a metadata reference that refers back to the compilation) we need to avoid sharing of the binding results.\r\n            We do so by creating a new reference manager for such compilation.\r\n            ":"\r\n            保留与参考绑定有关的数据。\r\n            经理在多个汇编中共享，我们期望具有参考绑定的结果相同。\r\n            在大多数情况下，这可以在不执行结合的情况下确定。但是，如果汇编包含一个圆形\r\n            元数据参考（元数据引用回编译），我们需要避免共享结合结果。\r\n            我们通过为这种编译创建新的参考经理来做到这一点。\r\n            \r\n","\r\n            The `bool PrintMembers(StringBuilder)` method is responsible for printing members declared\r\n            in the containing type that are \"printable\" (public fields and properties),\r\n            and delegating to the base to print inherited printable members. Base members get printed first.\r\n            It returns true if the record contains some printable members.\r\n            The method is used to implement `ToString()`.\r\n            ":"\r\n            `bool printmembers（StringBuilder）`方法负责打印成员\r\n            在“可打印”的包含类型中（公共字段和属性），\r\n            并委派给基地以打印继承的可打印成员。基础成员首先打印。\r\n            如果记录包含一些可打印的成员，它将返回true。\r\n            该方法用于实现`toString（）`。\r\n            \r\n","\r\n              Looks up a localized string similar to Conditional member '{0}' cannot implement interface member '{1}' in type '{2}'.\r\n            ":"\r\n              在类型'{2}'中查找类似于条件成员'{0}'的本地化字符串。\r\n            \r\n","Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type":"两个索引器具有不同的名称；索引属性必须在类型中的每个索引器上与相同名称一起使用\r\n","||":"||\r\n","\r\n              Looks up a localized string similar to ref structs.\r\n            ":"\r\n              查找类似于REF结构的本地化字符串。\r\n            \r\n","\r\n            with the required syntax and optional precalculated starting state for the model.\r\n            ":"\r\n            使用所需的语法和可选的预定型起始状态。\r\n            \r\n","\r\n            Initialize the ObsoleteAttributeData by fetching attributes and decoding ObsoleteAttributeData. This can be \r\n            done for Metadata symbol easily whereas trying to do this for source symbols could result in cycles.\r\n            ":"\r\n            通过获取属性和解码OmpoleTeatTribedata来初始化闭合构成的ata。这可以\r\n            为元数据符号完成，而试图为源符号执行此操作可能会导致周期。\r\n            \r\n","Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match the target delegate '{2}' (possibly because of nullability attributes).":"'{1}'的参数'{0}'类型中的参考类型的无能与目标委托'{2}'（可能是由于无效属性）不匹配。\r\n","\r\n            The list of custom modifiers, if any, associated with the pointer type.\r\n            ":"\r\n            与指针类型关联的自定义修饰符列表。\r\n            \r\n","The value that the resulting character literal should have.":"由此产生的角色本应具有的价值。\r\n","There is no defined ordering between fields in multiple declarations of partial struct '{0}'. To specify an ordering, all instance fields must be in the same declaration.":"在部分结构'{0}'的多个声明中，字段之间没有定义的排序。要指定订购，所有实例字段必须在同一声明中。\r\n","\r\n            Returns the assembly containing this symbol. If this symbol is shared across multiple\r\n            assemblies, or doesn't belong to an assembly, returns null.\r\n            ":"\r\n            返回包含此符号的组件。如果此符号在多个\r\n            组件，或不属于组件，将返回空。\r\n            \r\n","\r\n              Looks up a localized string similar to Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'.\r\n            ":"\r\n              查找类似于不一致的可访问性的本地化字符串：基本接口'{1}'的访问不如接口'{0}'。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot define a class or member that utilizes tuples because the compiler required type '{0}' cannot be found. Are you missing a reference?.\r\n            ":"\r\n              查找类似于类似的本地化字符串无法定义使用元组的类或成员，因为找不到编译器类型的“ {0}”。您是否缺少参考？\r\n            \r\n","The parameter of a unary operator must be the containing type":"单一操作员的参数必须是包含类型\r\n","\r\n              Looks up a localized string similar to Syntax tree already present.\r\n            ":"\r\n              查找类似于已经存在的语法树的本地化字符串。\r\n            \r\n","\r\n            Whenever assigning a variable, and that variable is not declared at the point the state is being set,\r\n            and the new state might be ":"\r\n            每当分配变量，并且在状态设置的点未声明该变量时，\r\n            新状态可能是\r\n","\r\n            Gets the attributes applied on the return value of this method symbol.\r\n            Returns an empty array if there are no attributes.\r\n            ":"\r\n            获取该方法符号的返回值上应用的属性。\r\n            如果没有属性，则返回一个空数组。\r\n            \r\n","\r\n              Looks up a localized string similar to Argument type '{0}' is not CLS-compliant.\r\n            ":"\r\n              查找类似于参数类型的本地化字符串“ {0}”不符合CLS。\r\n            \r\n"," and frees it if only nulls remain.\r\n            ":" 如果仅保留零，则可以释放它。\r\n            \r\n","A list of syntax nodes that represents the content of the placeholder element.":"表示占位符元素内容的语法节点列表。\r\n","Implicitly-typed variables cannot have multiple declarators":"隐式型变量不能具有多个声明器\r\n","\r\n            Keys are GenericNameSyntax nodes representing unbound generic types.\r\n            Values are false if the node should result in an error and true otherwise.\r\n            ":"\r\n            键是代表无限通用类型的genericNamesyntax节点。\r\n            值如果节点应导致错误，则值为false。\r\n            \r\n",") and is used for semantic analysis and lowering.\r\n            ":"），用于语义分析和降低。\r\n            \r\n","\r\n            This is the \"top\" state of the data flow lattice. Generally, it is considered the state\r\n            which is reachable, but no information is yet available. This is the state used at the\r\n            start of method bodies.\r\n            ":"\r\n            这是数据流晶格的“顶部”状态。通常，它被认为是国家\r\n            这是可以达到的，但尚无信息。这是在\r\n            方法的开始。\r\n            \r\n",". This\r\n            conversion is applied after the operator is applied, before the result is assigned to ":"。这个\r\n            在将操作员应用后，在将结果分配给运算符后应用转换\r\n","\r\n            Returns true and a string from the first GuidAttribute on the type, \r\n            the string might be null or an invalid guid representation. False, \r\n            if there is no GuidAttribute with string argument.\r\n            ":"\r\n            从类型上的第一个指南返回true和一个字符串，\r\n            字符串可能为null或无效的GUID表示。错误的，\r\n            如果没有字符串参数的指南。\r\n            \r\n","\r\n              Looks up a localized string similar to An expression tree may not contain '{0}'.\r\n            ":"\r\n              查找类似于表达树的本地化字符串可能不包含“ {0}”。\r\n            \r\n","Called when the visitor visits a PropertyPatternClauseSyntax node.":"当访问者访问propertypatternclausesyntax节点时调用。\r\n","\r\n            Will not always agree with ExplicitInterfaceImplementations.Any()\r\n            (e.g. if binding of the type part of the name fails).\r\n            ":"\r\n            并不总是同意explicitInterfaceimplement.any（）（）\r\n            （例如，如果名称的类型部分的绑定失败）。\r\n            \r\n","\r\n              Looks up a localized string similar to fixed size buffers.\r\n            ":"\r\n              查找类似于固定尺寸缓冲区的局部字符串。\r\n            \r\n","\r\n            NOTE: The spec fails to impose the restriction that the receiver must be classified\r\n            as a variable (unlike for properties - 7.17.1).  This seems like a bug, but we have\r\n            production code that won't build with the restriction in place (see DevDiv #15674).\r\n            ":"\r\n            注意：规格未能强加必须对接收器进行分类的限制\r\n            作为变量（与属性不同-7.17.1）。这似乎是一个错误，但我们有\r\n            生产代码不会在适当的限制下构建（请参阅Devdiv＃15674）。\r\n            \r\n","\r\n            Count the custom modifiers within the specified TypeSymbol.\r\n            Potentially non-zero for arrays, pointers, and generic instantiations.\r\n            ":"\r\n            计算指定类型符号内的自定义修饰符。\r\n            对于阵列，指针和通用实例化的可能非零。\r\n            \r\n","\r\n            Indicates whether this accessor itself has a 'readonly' modifier.\r\n            ":"\r\n            指示此登录器本身是否具有“读取”修饰符。\r\n            \r\n","\r\n            to get all attribute declarations.\r\n            ":"\r\n            获取所有属性声明。\r\n            \r\n"," referenced by the underlying module,\r\n            value is the corresponding ":" 由基础模块引用，\r\n            值是相应的\r\n","Badly formed XML in included comments file":"在包含的注释文件中形成不良的XML\r\n","Function pointer parameter list syntax.":"功能指针参数列表语法。\r\n","Creates a new AttributeListSyntax instance.":"创建一个新的属性元素ntrax实例。\r\n","\r\n            Perform lookup and overload resolution on methods defined directly on the class and any\r\n            extension methods in scope. Lookup will occur for extension methods in all nested scopes\r\n            as necessary until an appropriate method is found. If analyzedArguments is null, the first\r\n            method group is returned, without overload resolution being performed. That method group\r\n            will either be the methods defined on the receiver class directly (no extension methods)\r\n            or the first set of extension methods.\r\n            ":"\r\n            在直接在类和任何的方法上定义的方法上执行查找和过载分辨率\r\n            范围中的扩展方法。在所有嵌套范围中的扩展方法都将发生查找\r\n            必要时，直到找到适当的方法为止。如果分析量为null，则第一个\r\n            返回方法组，而无需执行超载分辨率。该方法组\r\n            要么是直接在接收器类上定义的方法（无扩展方法）\r\n            或第一组扩展方法。\r\n            \r\n","\r\n              Looks up a localized string similar to Interface is already listed in the interface list with different nullability of reference types..\r\n            ":"\r\n              在接口列表中列出了类似于接口的本地化字符串，并具有不同的参考类型的无效性。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot specify accessibility modifiers for both accessors of the property or indexer '{0}'.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法指定属性或索引器'{0}'的访问者的可访问性修饰符。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid output name: {0}.\r\n            ":"\r\n              查找类似于无效输出名称的本地化字符串：{0}。\r\n            \r\n","Cannot create delegate from method '{0}' because it is a partial method without an implementing declaration":"无法从方法'{0}'创建委派，因为它是未实现声明的部分方法\r\n","\r\n            A type class providing the primitive operations needed to support a value set.\r\n            ":"\r\n            提供支持值集所需的原始操作的类型类。\r\n            \r\n","Field or property cannot be of type '{0}'":"字段或属性不能为'{0}'类型\r\n","\r\n              Looks up a localized string similar to The type name '{0}' could not be found in the global namespace. This type has been forwarded to assembly '{1}' Consider adding a reference to that assembly..\r\n            ":"\r\n              查找类似于类型名称'{0}'的本地化字符串在全局名称空间中找不到。这种类型已转发到汇编'{1}'考虑对该汇编的引用。\r\n            \r\n","\r\n              Looks up a localized string similar to Both partial method declarations must be extension methods or neither may be an extension method.\r\n            ":"\r\n              查找类似于两个部分方法声明的本地化字符串必须是扩展方法，或者不可能是扩展方法。\r\n            \r\n"," equality should be checked separately!!!\r\n            ":" 应分开检查平等！！！\r\n            \r\n","\r\n            A collection of statements outside the region that jump into the region.\r\n            ":"\r\n            该地区跳入该地区的陈述集合。\r\n            \r\n","The CallerFilePathAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.":"应用于参数'{0}'的CallerFilePathAttribute将无效。它被CallerlineNumberattribute覆盖。\r\n","Class which represents the syntax node for SizeOf expression.":"代表用于sizeof表达式的语法节点的类。\r\n","Called when the visitor visits a BlockSyntax node.":"当访问者访问blocksyntax节点时，请致电。\r\n","\r\n            C# language version 3\r\n            ":"\r\n            C＃语言版本3\r\n            \r\n","\r\n              Looks up a localized string similar to Type of '{0}' cannot be inferred since its initializer directly or indirectly refers to the definition..\r\n            ":"\r\n              查找类似于“ {0}”类型的本地化字符串，因为它的初始器直接或间接地指定义。\r\n            \r\n","\r\n            Finds a token according to the following rules:\r\n            1) If position matches the End of the node/s FullSpan and the node is CompilationUnit,\r\n               then EoF is returned. \r\n            \r\n             2) If node.FullSpan.Contains(position) then the token that contains given position is\r\n                returned.\r\n            \r\n             3) Otherwise an ArgumentOutOfRangeException is thrown\r\n            ":"\r\n            根据以下规则找到令牌：\r\n            1）如果位置匹配节点/s fullspan的末端，并且节点为compilationunit，则\r\n               然后返回EOF。\r\n            \r\n             2）如果node.fullspan.contains（位置），则包含给定位置的令牌为\r\n                回来。\r\n            \r\n             3）否则会抛出参数outofrangeException\r\n            \r\n","Gets the base type references.":"获取基本类型引用。\r\n","Digit separators":"数字分离器\r\n","\r\n            A position is inside an accessor body if it is inside the block or expression\r\n            body. \r\n            ":"\r\n            如果登录机在块内或表达式内\r\n            身体。\r\n            \r\n","Expression syntax node":"表达语法节点\r\n","\r\n            A region analysis walker that records jumps out of the region.\r\n            ":"\r\n            记录的区域分析步行者跳出了该地区。\r\n            \r\n","\r\n            Get a source type symbol for the given declaration syntax.\r\n            ":"\r\n            获取给定声明语法的源类型符号。\r\n            \r\n","\r\n            Describes how the field is marshalled when passed to native code.\r\n            Null if no specific marshalling information is available for the field.\r\n            ":"\r\n            描述将字段传递给本机代码时如何编辑字段。\r\n            null如果没有特定的编组信息可用于该领域。\r\n            \r\n","\r\n              Looks up a localized string similar to The type of a local declared in a fixed statement must be a pointer type.\r\n            ":"\r\n              查找类似于固定语句中声明的本地类型的本地化字符串，必须是指针类型。\r\n            \r\n","The event '{0}' can only appear on the left hand side of += or -= (except when used from within the type '{1}')":"事件'{0}'只能出现在 +=或 -  =的左侧（除非从类型'{1}'中使用时）\r\n","\r\n            Add document entries for all debug documents that do not yet have an entry.\r\n            ":"\r\n            为所有尚未输入的调试文档添加文档条目。\r\n            \r\n","generics":"仿制药\r\n","Called when the visitor visits a AccessorListSyntax node.":"当访问者访问登录列表节点时，请致电。\r\n","\r\n            Adds diagnostics from useSiteDiagnostics into diagnostics and returns True if there were any errors.\r\n            ":"\r\n            将useItedIngnostics的诊断添加到诊断中，如果有任何错误，则返回真实。\r\n            \r\n","\r\n            The candidate member was rejected because an required parameter had no corresponding argument.\r\n            ":"\r\n            候选人成员被拒绝，因为所需的参数没有相应的参数。\r\n            \r\n","\r\n              Looks up a localized string similar to throw expression.\r\n            ":"\r\n              查找类似于投掷表达的本地化字符串。\r\n            \r\n","Creates a new EnumDeclarationSyntax instance.":"创建一个新的EnumDeclarationsyntax实例。\r\n","Position is not within syntax tree with full span {0}":"位置不在全跨度{0}的语法树中\r\n","\r\n              Looks up a localized string similar to stackalloc in nested expressions.\r\n            ":"\r\n              在嵌套表达式中查找类似于Stackalloc的本地化字符串。\r\n            \r\n","\r\n            The underlying EventSymbol, cannot be another RetargetingEventSymbol.\r\n            ":"\r\n            基础事件符号不能是另一个retargetingeventsymbol。\r\n            \r\n","\r\n            Deserialize a syntax node from the byte stream.\r\n            ":"\r\n            从字节流进行启用语法节点。\r\n            \r\n","'{0}': instance event in interface cannot have initializer":"'{0}'：接口中的实例事件不能具有初始器\r\n","\r\n            Returns #r directives specified in the compilation.\r\n            ":"\r\n            返回汇编中指定的#R指令。\r\n            \r\n","\r\n            C# language version 9.0\r\n            ":"\r\n            C＃语言版本9.0\r\n            \r\n","\r\n             Merges the new change ranges into the old change ranges, adjusting the new ranges to be with respect to the original text\r\n             (with neither old or new changes applied) instead of with respect to the original text after \"old changes\" are applied.\r\n            \r\n             This may require splitting, concatenation, etc. of individual change ranges.\r\n             ":"\r\n             合并新更改范围为旧变化范围，调整新范围以相对于原始文本\r\n             （在应用“旧更改”之后，既不应用旧更改或新更改）而不是相对于原始文本。\r\n            \r\n             这可能需要单个变更范围的分裂，串联等。\r\n             \r\n","Inconsistent accessibility: indexer return type '{1}' is less accessible than indexer '{0}'":"不一致的可访问性：索引器返回类型'{1}'比indexer'{0}'易于访问\r\n","\r\n            True if this symbol has a special name (metadata flag SpecialName is set).\r\n            ":"\r\n            是的，如果此符号具有特殊名称（设置了元数据标志SpecialName）。\r\n            \r\n","Type parameter has no matching typeparam tag in the XML comment (but other type parameters do)":"type参数在XML注释中没有匹配的Typeparam标签（但是其他类型参数确实）\r\n","\r\n              Looks up a localized string similar to The typeof operator cannot be used on a nullable reference type.\r\n            ":"\r\n              查找类似于类型运算符的本地化字符串不能在可根据可确定的参考类型上使用。\r\n            \r\n","\r\n            Returns whether this method is async and returns a task.\r\n            ":"\r\n            返回该方法是否为异步并返回任务。\r\n            \r\n","\r\n            A region analysis walker that computes whether or not the region completes normally.  It does this by determining\r\n            if the point at which the region ends is reachable.\r\n            ":"\r\n            一个区域分析步行器计算该区域是否正常完成。它通过确定\r\n            如果该区域结束的点是可以达到的。\r\n            \r\n","\r\n              Looks up a localized string similar to foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance definition for '{1}'.\r\n            ":"\r\n              查找类似于foreach语句的本地化字符串无法在类型'{0}'的变量上操作，因为'{0}'不包含'{1}'的公共实例定义。\r\n            \r\n","Invalid base type":"无效的基本类型\r\n","Optional offset into text.":"可选偏移到文本中。\r\n","\r\n            Helper method for wrapping a string in a SourceText.\r\n            ":"辅助方法将字符串包裹在Sourcetext中。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid filename specified for preprocessor directive. Filename is too long or not a valid filename..\r\n            ":"\r\n              查找类似于预处理指令指定的无效文件名的本地化字符串。文件名太长或没有有效的文件名。\r\n            \r\n","\r\n            Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.\r\n            ":"\r\n            给定一个声明属性，索引器或事件的语法节点，获取相应的声明为符号。\r\n            \r\n","An array initializer of length '{0}' is expected":"期望长度'{0}'的数组初始化器\r\n","\r\n            A field of a frame class that represents a variable that has been captured in a lambda.\r\n            ":"\r\n            框架类的字段，代表在lambda中捕获的变量。\r\n            \r\n","The abstract {0} '{1}' cannot be marked virtual":"摘要{0}'{1}'不能标记虚拟\r\n","\r\n            Since each language construct must be handled according to the rules of the language specification,\r\n            the default visitor reports that the construct for the node is not implemented in the compiler.\r\n            ":"\r\n            由于必须根据语言规范的规则来处理每个语言构造，因此\r\n            默认访问者报告说，该节点的构造未在编译器中实现。\r\n            \r\n","ExpressionSyntax node representing the constant expression.":"表示恒定表达式的表达式元素节点。\r\n","\r\n              Looks up a localized string similar to The type '{2}' must be a non-nullable value type, along with all fields at any level of nesting, in order to use it as parameter '{1}' in the generic type or method '{0}'.\r\n            ":"\r\n              查找类似于“ {2}”类型的本地化字符串，必须是不可删除的值类型，以及任何嵌套级别的所有字段，以便在通用类型或方法'{0}'。\r\n            \r\n","Called when the visitor visits a OrderByClauseSyntax node.":"当访问者访问订单Byclausesyntax节点时，请致电。\r\n","true if we generated code for the test":"如果我们为测试生成代码，则是真的\r\n","\r\n            Merges given diagnostic and dependencies to the existing result.\r\n            ":"合并给定诊断和依赖性现有结果。\r\n            \r\n","\r\n            When deciding what struct fields to drop on the floor, the native compiler looks\r\n            through arrays, and does not ignore value types or type parameters.\r\n            ":"\r\n            当决定要在地板上掉落哪些结构字段时，本机编译器看起来\r\n            通过数组，不忽略价值类型或类型参数。\r\n            \r\n","\r\n            The set of cases that may still match, and for each of them the set of tests that remain to be tested.\r\n            ":"\r\n            一组可能仍然匹配的案例，对于每个案例，每一个案例仍有待测试的测试集。\r\n            \r\n"," corresponding to\r\n            the given ":" 对应于\r\n            给定\r\n"," elements. No impact on non-source documentation comments.":" 元素。对非源文档评论没有影响。\r\n","\r\n              Looks up a localized string similar to Call System.IDisposable.Dispose() on allocated instance before all references to it are out of scope.\r\n            ":"\r\n              在分配的实例上查找类似于call system.idisposable.dispose（）的本地化字符串，然后所有引用的所有引用都超出了范围。\r\n            \r\n","\r\n              Looks up a localized string similar to Member '{0}' was not found on type '{1}' from assembly '{2}'..\r\n            ":"\r\n              从汇编'{2}'..上查找类似于成员'{0}'的局部字符串。\r\n            \r\n","System.Void cannot be used from C# -- use typeof(void) to get the void type object":"system.void不能从c＃ - 使用typeof（void）获取void type对象\r\n","\r\n            A delegate field associated with a ":"与\r\n","\r\n            PERF: The framework specializes EqualityComparer for enums, but only if the underlying type is System.Int32\r\n            Since SyntaxKind's underlying type is System.UInt16, ObjectEqualityComparer will be chosen instead.\r\n            ":"\r\n            perf：该框架专门为枚举提供EqualityComparer，但前提是系统类型是System.int32\r\n            由于SyntaxKind的基本类型是System.Uint16，因此将选择ObjectEqualityComparer。\r\n            \r\n","A variable set to the first variable declaration found in the left":"在左侧发现的第一个变量声明的变量集\r\n","\r\n              Looks up a localized string similar to '{0}': cannot declare indexers in a static class.\r\n            ":"\r\n              查找类似于'{0}'：无法在静态类中声明索引器的局部字符串。\r\n            \r\n","Static member '{0}' cannot be marked 'readonly'.":"静态成员'{0}'不能标记为'ReadOnly'。\r\n","\r\n            Keep check and error in sync with ConstructBoundMethodGroupAndReportOmittedTypeArguments.\r\n            ":"\r\n            与constructboundmethodgroupandreportomittytypearguments保持检查和错误。\r\n            \r\n","\r\n            If this field represents a tuple element with index X\r\n             2X      if this field represents Default-named element\r\n             2X + 1  if this field represents Friendly-named element\r\n            Otherwise, (-1 - [index in members array]);\r\n            ":"\r\n            如果此字段代表带有索引x的元组元素\r\n             2x如果此字段表示默认为命名元素\r\n             2x + 1如果该字段表示为友好的元素\r\n            否则（-1- [成员数组中的索引]）;\r\n            \r\n","The CallerMemberNameAttribute will have no effect; it is overridden by the CallerFilePathAttribute":"Callermemberneateatribute无效；它被callerfilepathattribute覆盖\r\n","\r\n            Returns the referenced Compilation.\r\n            ":"\r\n            返回引用的汇编。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': explicit interface declaration can only be declared in a class, struct or interface.\r\n            ":"\r\n              查找类似于“ {0}'：显式接口声明的本地化字符串，只能在类，结构或接口中声明。\r\n            \r\n","\r\n              Looks up a localized string similar to Extension method groups are not allowed as an argument to 'nameof'..\r\n            ":"\r\n              查找类似于扩展方法组的本地化字符串作为“名称”的参数。\r\n            \r\n","An optional name to give the resulting namespace.":"可选的名称以给出结果名称空间。\r\n","\r\n            Verify the default value matches the default value from any earlier attribute\r\n            (DefaultParameterValueAttribute, DateTimeConstantAttribute or DecimalConstantAttribute).\r\n            If not, report ERR_ParamDefaultValueDiffersFromAttribute.\r\n            ":"\r\n            验证默认值从任何早期属性中匹配默认值\r\n            （DefaultParameTervAlueatTribute，dateTimeConstantAttribute或DecimalConstantAttribute）。\r\n            如果不是，请报告ERR_PARAMDEFAULTVALUEDIFFERSFROMPTRIBUTE。\r\n            \r\n","\r\n              Looks up a localized string similar to Assembly and module '{0}' cannot target different processors..\r\n            ":"\r\n              查找类似于汇编和模块'{0}'的本地化字符串不能瞄准不同的处理器。\r\n            \r\n",".\r\n             Also supports the != operator, nullable and nested tuples.\r\n            \r\n             Note that all the side-effects for visible expressions are evaluated first and from left to right. The initialization phase\r\n             contains side-effects for:\r\n             - single elements in tuple literals, like ":"。\r\n             还支持！=操作员，无效和嵌套的元组。\r\n            \r\n             请注意，所有可见表达式的副作用将首先和从左到右评估。初始化阶段\r\n             包含：\r\n              - 元组文字中的单个元素，\r\n","\r\n            This is used for emitting.  It does not reflect the language semantics\r\n            (i.e. even non-optional parameters can have default values).\r\n            ":"\r\n            这用于发射。它没有反映语言语义\r\n            （即，即使是非选项参数也可以具有默认值）。\r\n            \r\n","SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.":"extressionsyntax的分离列表表示初始化器表达式中表达式列表。\r\n","\r\n            A sequence of bindings to be assigned before evaluation of the guard or jump to the label.\r\n            Each one contains the source of the assignment and the destination of the assignment, in that order.\r\n            ":"\r\n            在评估后卫或跳到标签之前要分配的一系列绑定。\r\n            每个人都包含分配的来源和分配的目的地，按照顺序。\r\n            \r\n","Invalid variance: The type parameter '{1}' must be {3} valid on '{0}'. '{1}' is {2}.":"无效方差：类型参数'{1}'必须在'{0}'上有效{3}。 '{1}'是{2}。\r\n","\r\n            Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or\r\n            associated with the token and its related trivia. \r\n            ":"\r\n            在将指定节点作为root或\r\n            与令牌及其相关的琐事相关。\r\n            \r\n","\r\n            DiagnosticAnalyzer for C# compiler's syntax/semantic/compilation diagnostics.\r\n            ":"\r\n            C＃编译器语法/语义/编译诊断的诊断仪。\r\n            \r\n","\r\n            Internal helper for ":"\r\n            内部帮手\r\n","\r\n            Given a base field declaration syntax, get the corresponding symbols.\r\n            ":"\r\n            给定基本字段声明语法，获取相应的符号。\r\n            \r\n","\r\n            Returns diagnostic info that should be reported at the use site of the symbol, or null if there is none.\r\n            ":"\r\n            返回诊断信息，应在符号的使用站点上报告，如果没有，则应在符号的使用站点上报告。\r\n            \r\n","\r\n            \r\n             will be encoded using an attribute on the return type as follows\r\n             \r\n             ":"\r\n            \r\n             将使用返回类型上的属性编码如下\r\n             \r\n             \r\n","\r\n            Lookup member declaration in predefined CorLib type used by this Assembly.\r\n            ":"\r\n            查找成员声明此组件使用的预定义的Corlib类型。\r\n            \r\n","\r\n            Bind the attribute in the context of the specified location and get semantic information\r\n            such as type, symbols and diagnostics. This method is used to get semantic information about an attribute\r\n            that did not actually appear in the source code.\r\n            ":"\r\n            在指定位置的上下文中绑定属性并获取语义信息\r\n            例如类型，符号和诊断。此方法用于获取有关属性的语义信息\r\n            实际上并未出现在源代码中。\r\n            \r\n","\r\n              Looks up a localized string similar to Auto-implemented instance properties in readonly structs must be readonly..\r\n            ":"\r\n              查找类似于ReadOnly结构中的自动实例实例属性类似的本地化字符串。\r\n            \r\n","'experimental'":"“实验”\r\n","TypeSyntax node representing the type of the element of the array.":"代表数组元素的类型的型号节点。\r\n","\r\n            Lower a foreach loop that will enumerate a collection via indexing.\r\n            \r\n            ":"\r\n            降低通过索引列举集合的foreach循环。\r\n            \r\n            \r\n","The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.":"应用于参数'{0}'的callermembernameattribute将无效。它被CallerlineNumberattribute覆盖。\r\n","Called when the visitor visits a NameColonSyntax node.":"当访客访问namecolonsyntax节点时称呼。\r\n","Cannot assign {0} to a range variable":"无法分配{0}到范围变量\r\n","\r\n            Analyze the body, reporting all necessary diagnostics.\r\n            ":"\r\n            分析身体，报告所有必要的诊断。\r\n            \r\n","\r\n            Gets the next character if there are any characters in the \r\n            SourceText. May advance the window if we are at the end.\r\n            ":"\r\n            如果有任何字符\r\n            SourceText。如果我们在最后，可以推进窗口。\r\n            \r\n","\r\n            Produces a Try/Finally if frame has a handler (otherwise a regular block).\r\n            Handler goes into the Finally.\r\n            If there are nested frames, they are emitted into the try block.\r\n            This way the handler for the current frame is guaranteed to run even if \r\n            nested handlers throw exceptions.\r\n            \r\n            {\r\n                switch(state)\r\n                {\r\n                    case state1:\r\n                    case state2:\r\n                    case state3:\r\n                    case state4:\r\n                        try\r\n                        {\r\n                            switch(state)\r\n                            {\r\n                                case state3:\r\n                                case state4:\r\n                                    try\r\n                                    {\r\n                                        ... more nested state dispatches if any ....\r\n                                    }\r\n                                    finally\r\n                                    {\r\n                                        // handler for a try where state3 and state4 can be observed\r\n                                        handler_3_4()\r\n                                    }\r\n                                    break;\r\n                             }\r\n                        }\r\n                        finally\r\n                        {\r\n                            // handler for a try where state1 and state2 can be observed\r\n                            handler_1_2()\r\n                        }\r\n                        break;\r\n                        \r\n                    case state5:\r\n                        ... another dispatch of nested states to their finally blocks ...\r\n                        break;\r\n                }\r\n            }\r\n            \r\n            ":"\r\n            如果框架具有处理程序（否则是常规块），则会产生尝试/。\r\n            处理程序终于进入了。\r\n            如果有嵌套帧，则将它们排放到Try块中。\r\n            这样，即使\r\n            嵌套处理人员抛出异常。\r\n            \r\n            {\r\n                开关（状态）\r\n                {\r\n                    案例状态1：\r\n                    案例状态2：\r\n                    案例状态3：\r\n                    案例状态4：\r\n                        尝试\r\n                        {\r\n                            开关（状态）\r\n                            {\r\n                                案例状态3：\r\n                                案例状态4：\r\n                                    尝试\r\n                                    {\r\n                                        ...如果有的话，更多的嵌套状态调度。\r\n                                    }\r\n                                    最后\r\n                                    {\r\n                                        //尝试观察state3和state4的处理程序\r\n                                        handler_3_4（）\r\n                                    }\r\n                                    休息;\r\n                             }\r\n                        }\r\n                        最后\r\n                        {\r\n                            //尝试观察state1和state2的处理程序\r\n                            handler_1_2（）\r\n                        }\r\n                        休息;\r\n                        \r\n                    案例状态5：\r\n                        ...另一个派遣嵌套状态到他们的最后块...\r\n                        休息;\r\n                }\r\n            }\r\n            \r\n            \r\n","\r\n              Looks up a localized string similar to switch on boolean type.\r\n            ":"\r\n              查找类似于打开布尔类型的局部字符串。\r\n            \r\n","using static":"使用静态\r\n","\r\n            True if the fields are unset. Appropriate when detecting if a lazily-initialized variable has been initialized.\r\n            ":"\r\n            如果字段不设置，则为是真的。当检测是否初始化懒惰的变量时，适当。\r\n            \r\n","\r\n            The argument is BoundTryStatement (and not a BoundBlock) specifically \r\n            to support only Finally blocks where it is guaranteed to not have incoming or leaving branches.\r\n            ":"\r\n            该论点是边界的（而不是界限）\r\n            最终只能阻止它保证没有传入或离开分支机构的地方。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': new protected member declared in struct.\r\n            ":"\r\n              查找类似于“ {0}”的局部字符串：在struct中声明的新受保护成员。\r\n            \r\n","True if this is a call to a known string concat operator, false otherwise":"如果是对已知的字符串Concat运算符的调用，则为the\r\n","\r\n            Returns true if there is any applied RuntimeCompatibilityAttribute assembly attribute for this module.\r\n            ":"\r\n            如果有任何适用的runtimeCompatibilityAttribute Assembly属性，则返回true。\r\n            \r\n","\r\n            A trivia with kind WhitespaceTrivia containing a single tab character.\r\n            ":"\r\n            带有单个标签字符的善良的琐事。\r\n            \r\n","\r\n            to true if more than one method is overridden by CLI rules.\r\n            ":"\r\n            如果CLI规则覆盖了多个方法，则为真实。\r\n            \r\n","Flag indicating whether lazyCustomAttributes were stored on this thread. Caller should check for this flag and perform NotePartComplete if true.":"标志指示是否将懒惰的属性存储在该线程上。呼叫者应检查此标志，并执行NotepartComplete，如果为true。\r\n","\r\n              Looks up a localized string similar to Cannot use attribute constructor '{0}' because it is has 'in' parameters..\r\n            ":"\r\n              查找类似于使用属性构造函数'{0}'的本地化字符串，因为它具有'''参数。\r\n            \r\n","\r\n              Looks up a localized string similar to Tuple element names must be unique..\r\n            ":"\r\n              查找类似于元组元素名称的本地化字符串必须是唯一的。\r\n            \r\n","Constraint cannot be special class '{0}'":"约束不能是特殊类'{0}'\r\n","\r\n            Invalid type, used only to catch Visit methods that do not set\r\n            _result.Type. See VisitExpressionWithoutStackGuard.\r\n            ":"\r\n            无效类型，仅用于捕获未设置的访问方法\r\n            _Result.type。请参阅visitexpressionwithOutstackGuard。\r\n            \r\n","\r\n            Checks whether the expression represents a boxing conversion of a special value type.\r\n            If it does, it tries to return a string-based representation instead in order\r\n            to avoid allocations.  If it can't, the original expression is returned.\r\n            ":"\r\n            检查表达式是否表示特殊值类型的拳击转换。\r\n            如果是这样，它试图按顺序返回基于字符串的表示\r\n            避免分配。如果不能，原始表达式将返回。\r\n            \r\n","Invalid real literal.":"无效的真实文字。\r\n","'{0}': type must be '{2}' to match overridden member '{1}'":"'{0}'：类型必须为'{2}'才能匹配覆盖成员'{1}'\r\n","\r\n              Looks up a localized string similar to '{0}' must match by reference return of overridden member '{1}'.\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串必须通过覆盖成员'{1}'的参考返回匹配。\r\n            \r\n","\r\n            Add an interval to the end of the builder.\r\n            ":"\r\n            在构建器的末端添加一个间隔。\r\n            \r\n","\r\n            Set the nullability of tuple elements for tuples at the point of construction.\r\n            If ":"\r\n            在施工点设置元组元素的无效性。\r\n            如果\r\n","Stream contains invalid data":"流包含无效数据\r\n","\r\n            Find the first non-whitespace character in a given substring.\r\n            ":"\r\n            在给定的子字符串中找到第一个非Whitespace字符。\r\n            \r\n","The typeof operator cannot be used on the dynamic type":"运算符类型不能在动态类型上使用\r\n",", but without custom modifiers.  May differ in object/dynamic.":"，但没有自定义修饰符。对象/动态可能有所不同。\r\n","\r\n              Looks up a localized string similar to Unused extern alias..\r\n            ":"\r\n              查找类似于未使用的外部别名的局部字符串。\r\n            \r\n","\r\n            Create a decision dag for a switch statement.\r\n            ":"\r\n            为开关语句创建决策DAG。\r\n            \r\n","'{0}' is a {1}, which is not valid in the given context":"'{0}'是{1}，在给定上下文中无效\r\n","SyntaxToken which represents the keyword corresponding to the predefined type.":"Syntaxtoken表示与预定义类型相对应的关键字。\r\n","\r\n              Looks up a localized string similar to This method can only be used to create tokens - {0} is not a token kind..\r\n            ":"\r\n              查找类似于此方法的本地化字符串只能用于创建令牌 -  {0}不是令牌类型。\r\n            \r\n","\r\n              Looks up a localized string similar to It is not legal to use the type 'dynamic' in a pattern..\r\n            ":"\r\n              查找类似于它的本地化字符串是不合法的。\r\n            \r\n","Instance properties in interfaces cannot have initializers.":"接口中的实例属性不能具有初始化器。\r\n","\r\n              Looks up a localized string similar to Type is for evaluation purposes only and is subject to change or removal in future updates..\r\n            ":"\r\n              查找类似于类型的本地化字符串仅用于评估目的，并且可能会在以后的更新中进行更改或删除。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot call an abstract base member: '{0}'.\r\n            ":"\r\n              查找类似于无法调用抽象基础成员的本地化字符串：'{0}'。\r\n            \r\n","\r\n            Store the constant value and the corresponding diagnostics together\r\n            to avoid having the former set by one thread and the latter set by\r\n            another.\r\n            ":"\r\n            将常数值和相应诊断存储在一起\r\n            避免将前者设置为一个线程，后者设置为\r\n            其他。\r\n            \r\n","Creates a new LabeledStatementSyntax instance.":"创建一个新的LabeLedStatementSyntax实例。\r\n","\r\n              Looks up a localized string similar to Friend assembly reference '{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified..\r\n            ":"\r\n              查找类似于朋友汇编引用'{0}'的本地化字符串无效。 InternalSvisibleto声明不能具有指定的版本，文化，公钥令牌或处理器体系结构。\r\n            \r\n","\r\n             Find the constructor for a well-known ValueTuple type of a given arity.\r\n            \r\n             For example, for arity=2:\r\n             returns WellKnownMember.System_ValueTuple_T2__ctor\r\n            \r\n             For arity=12:\r\n             return System_ValueTuple_TRest__ctor\r\n             ":"\r\n             找到给定的众所周知的估值类型的构造函数。\r\n            \r\n             例如，对于Arity = 2：\r\n             返回众所周知的ember.system_valuetuple_t2__ctor\r\n            \r\n             对于Arity = 12：\r\n             返回system_valuetuple_trest__ctor\r\n             \r\n","\r\n            Parses any statement but a declaration statement. Returns null if the lookahead looks like a declaration.\r\n            ":"\r\n            解析任何声明，但声明声明。如果LookAhead看起来像声明，则返回null。\r\n            \r\n","The referenced file '{0}' is not an assembly":"引用文件'{0}'不是汇编\r\n","Error code.":"错误代码。\r\n","\r\n            Fetches the documentation comment for this element with a cancellation token.\r\n            ":"\r\n            通过取消令牌获取此元素的文档评论。\r\n            \r\n","\r\n            Lexer entry point for LexMode.XmlDocComment\r\n            ":"\r\n            lexmode.xmldoccomment的Lexer入口点\r\n            \r\n","\r\n            Used for example for event accessors. The \"remove\" method delegates attribute binding to the \"add\" method.\r\n            The bound attribute data are then applied to both accessors.\r\n            ":"\r\n            例如，用于事件访问者。 “删除”方法委托属性绑定到“添加”方法。\r\n            然后将界限数据应用于两个登录器。\r\n            \r\n","List in which to collect the trivia":"收集琐事的清单\r\n","Called when the visitor visits a ArrayTypeSyntax node.":"当访问者访问arraytypesyntax节点时，请致电。\r\n","readonly structs":"可读结构\r\n","CAVEAT: considers return types so that getters and setters will be treated the same.":"警告：考虑返回类型，以便将Getters和Setters对待相同。\r\n","\r\n              Looks up a localized string similar to An extension Add method is not supported for a collection initializer in an expression lambda..\r\n            ":"\r\n              查找类似于扩展添加方法的本地化字符串对于表达式lambda中的集合初始化器不支持。\r\n            \r\n","\r\n            If we are inside a context where a continue statement is legal,\r\n            returns the ":"\r\n            如果我们处于一个继续陈述合法的情况下，\r\n            返回\r\n","\r\n              Looks up a localized string similar to LookupOptions has an invalid combination of options.\r\n            ":"\r\n              查找类似于LookuPotions的本地化字符串具有无效的选项组合。\r\n            \r\n","\r\n            Add the case label to the subsumption tree. Return true if the label is reachable\r\n            (not subsumed) given the governing expression's type and previously added labels. \r\n            ":"\r\n            将案例标签添加到补充树中。如果标签可以返回true\r\n            （未包含）给定管理表达式的类型和先前添加的标签。\r\n            \r\n","Creates a new CaseSwitchLabelSyntax instance.":"创建一个新的casewitchlabelsyntax实例。\r\n","\r\n            A MemberCrefSyntax specified by an implicit or explicit keyword, an operator keyword, a destination type, and an optional parameter list.\r\n            For example, \"implicit operator int\" or \"explicit operator MyType(int)\".\r\n            ":"\r\n            由隐式或显式关键字，操作员关键字，目标类型和可选参数列表指定的成员crefsyntax。\r\n            例如，“隐式运算符int”或“显式操作员mytype（int）”。\r\n            \r\n","\r\n            Strangely enough there is such a thing as unary concatenation and it must be rewritten.\r\n            ":"\r\n            奇怪的是，有一件事，必须重写。\r\n            \r\n","\r\n              Looks up a localized string similar to <namespace>.\r\n            ":"\r\n              查找类似于<名称空间>的本地化字符串。\r\n            \r\n","SyntaxToken representing the open bracket.":"Syntaxtoken代表开放式括号。\r\n","\r\n              Looks up a localized string similar to leading digit separator.\r\n            ":"\r\n              查找类似于领先数字分离器的局部字符串。\r\n            \r\n","\r\n            True if the symbol is declared outside of the scope of the containing\r\n            symbol\r\n            ":"\r\n            如果在包含的范围之外声明符号\r\n            象征\r\n            \r\n","This is a debugger special punctuation and not related to string interpolation.":"这是一个调试器特殊标点符号，与字符串插值无关。\r\n","The entry point of the program is global code; ignoring entry point":"程序的切入点是全局代码；忽略入口点\r\n","\r\n            Get the symbol for the predefined type from the COR Library referenced by this compilation.\r\n            ":"\r\n            从本汇编引用的COR库中获取预定义类型的符号。\r\n            \r\n",".\r\n            Otherwise, returns ":"。\r\n            否则，返回\r\n","Creates a new PragmaWarningDirectiveTriviaSyntax instance.":"创建一个新的pragmawarningDirectivetriviaSyntax实例。\r\n","\r\n            Adds compiler version number and name.\r\n            ":"\r\n            添加编译器版本编号和名称。\r\n            \r\n","\r\n              Looks up a localized string similar to Within cref attributes, nested types of generic types should be qualified..\r\n            ":"\r\n              查找类似于CREF属性的本地化字符串，应该有资格使用嵌套的通用类型。\r\n            \r\n",",\r\n            values are distinct interfaces corresponding to the key, according to ":"，，，，\r\n            值是与密钥相对应的不同接口\r\n","Do not use 'System.Runtime.CompilerServices.ExtensionAttribute'. Use the 'this' keyword instead.":"请勿使用'system.runtime.compilerServices.extensionAttribute'。改用“此”关键字。\r\n","\r\n            Walks a DocumentationCommentTriviaSyntax, binding the semantically meaningful parts \r\n            to produce diagnostics and to replace source crefs with documentation comment IDs.\r\n            ":"\r\n            行走DocumentationCommentTriviaSyntax，绑定语义上有意义的部分\r\n            用文档注释ID产生诊断并替换源CREF。\r\n            \r\n","\r\n            An interface representing a set of values of a specific type.  Like ":"\r\n            代表特定类型值集的接口。喜欢\r\n","\r\n            Does the compilation this symbol belongs to output to a winmdobj?\r\n            ":"\r\n            该符号属于输出的汇编是否属于Winmdobj？\r\n            \r\n","\r\n            The list of custom modifiers, if any, associated with the parameter.\r\n            ":"\r\n            与参数关联的自定义修饰符列表（如果有）。\r\n            \r\n","\r\n            A lightweight check for whether this type has a possible clone method. This is less costly than GetMembers,\r\n            particularly for PE symbols, and can be used as a cheap heuristic for whether to fully search through all\r\n            members of this type for a valid clone method.\r\n            ":"\r\n            轻巧检查此类型是否具有克隆方法。这比getembers的成本少，\r\n            特别是对于PE符号，可以用作廉价的启发式方法，用于是否完全搜索所有\r\n            这种类型的成员用于有效的克隆方法。\r\n            \r\n","\r\n            Check whether \"symbol\" is accessible from this binder.\r\n            Also checks protected access via \"accessThroughType\".\r\n            ":"\r\n            检查\"符号\"是否可从此活页夹访问。\r\n            还通过\"accessThroughType\"检查受保护的访问。\r\n            \r\n","\r\n            Get locals declared immediately in scope designated by the node.\r\n            ":"\r\n            立即在节点指定的范围中声明当地人。\r\n            \r\n","\r\n            Either the ":"\r\n            要么\r\n","\r\n            A mapping from all captured vars to the scope they were declared in. This\r\n            is used when recording captured variables as we must know what the lifetime\r\n            of a captured variable is to determine the lifetime of its capture environment.\r\n            ":"\r\n            从所有捕获的vars到他们声明的范围的映射。\r\n            在录制捕获变量时使用，因为我们必须知道生命周期\r\n            捕获的变量是确定其捕获环境的寿命。\r\n            \r\n","\r\n              Looks up a localized string similar to Namespace conflicts with imported type.\r\n            ":"\r\n              查找类似于导入类型的名称空间冲突的本地化字符串。\r\n            \r\n","Member '{0}' implements interface member '{1}' in type '{2}'. There are multiple matches for the interface member at run-time. It is implementation dependent which method will be called.":"成员'{0}'在类型'{2}'中实现接口成员'{1}'。在运行时，接口成员有多个匹配项。这是实现依赖性的，将调用哪种方法。\r\n","No defining declaration found for implementing declaration of partial method '{0}'":"没有发现用于实施部分方法声明'{0}'的声明\r\n","Improved definite assignment":"改进的确定任务\r\n","The operator kind.  Nothing will happen if it is not a lifted equality operator.":"操作员的那种。  如果不是提升的平等运算符，则不会发生任何事情。\r\n","The arity of the forwarded type.":"转发类型的ARITY。\r\n"," being thrown.\r\n            ":" 被扔了。\r\n            \r\n","\r\n            It works by maintaining a dictionary of all possible simple names that might map to the given\r\n            attribute.\r\n            ":"\r\n            它通过维护所有可能映射到给定的所有可能的简单名称的字典来起作用\r\n            属性。\r\n            \r\n","Cannot use attribute constructor '{0}' because it has 'in' parameters.":"无法使用属性构造函数'{0}'，因为它具有“参数”。\r\n","Unexpected character at this location.":"在这个位置出乎意料的角色。\r\n","\r\n            because those diagnostics are only reported if no other candidates are\r\n            available.\r\n            ":"\r\n            因为这些诊断只有在没有其他候选人的情况下报告\r\n            可用的。\r\n            \r\n","\r\n            Attributes for this symbol might be retrieved from attribute list of another (owning) symbol.\r\n            In that case this property returns that owning symbol, otherwise it returns \"this\".\r\n            ":"\r\n            可以从另一个（拥有）符号的属性列表中检索此符号的属性。\r\n            在这种情况下，此属性返回拥有该符号，否则返回“此”。\r\n            \r\n","Interfaces cannot contain instance constructors":"接口不能包含实例构造函数\r\n","The name of the (potentially) forwarded type.":"（潜在）转发类型的名称。\r\n","\r\n            Returns the index of the first trivia of a specified kind in the trivia list.\r\n            ":"\r\n            返回琐事列表中指定类型的第一个琐事的索引。\r\n            \r\n","\r\n              Looks up a localized string similar to Use of default literal is not valid in this context.\r\n            ":"\r\n              在此上下文中查找类似于使用默认字体的本地化字符串是无效的。\r\n            \r\n","\r\n            Ensure that attributes are bound and the ObsoleteState of this symbol is known.\r\n            ":"\r\n            确保属性是绑定的，并且已知该符号的过遗嘱。\r\n            \r\n",", except that when completing\r\n            with a given position, we might not complete ":"，除了完成时\r\n            在给定的位置，我们可能无法完成\r\n","\r\n            Returns true if this type derives from a given type.\r\n            ":"\r\n            如果此类型派生自给定类型，则返回 true。\r\n            \r\n","Cannot use an expression of type '{0}' as an argument to a dynamically dispatched operation.":"不能将类型的“ {0}”的表达式用作动态调度操作的参数。\r\n","</":"<//\r\n","\r\n            Returns false because field can't be overridden.\r\n            ":"\r\n            返回错误，因为字段不能被覆盖。\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability of reference types in type of parameter doesn't match overridden member..\r\n            ":"\r\n              查找类似于参数类型中参考类型的无效性类似的本地化字符串与不匹配的覆盖成员。\r\n            \r\n","\r\n            Allows asking semantic questions about a tree of syntax nodes in a Compilation. Typically,\r\n            an instance is obtained by a call to ":"\r\n            允许在汇编中询问有关语法节点树的语义问题。通常，\r\n            通过呼叫获得实例\r\n","'await' cannot be used in an expression containing the type '{0}'":"“等待”不能在包含'{0}'类型的表达式中使用\r\n","\r\n            If the given node is within a preprocessing directive, gets the preprocessing symbol info for it.\r\n            ":"\r\n            如果给定的节点在预处理指令中，则获取预处理符号信息。\r\n            \r\n","The right (deconstructable) operand":"权利（可解构）操作数\r\n","Unexpected character '{0}'":"意外角色'{0}'\r\n","'{1}': cannot derive from static class '{0}'":"'{1}'：不能从静态类派生'{0}'\r\n","Auto-implemented properties must override all accessors of the overridden property.":"自动实施属性必须覆盖被覆盖属性的所有登录器。\r\n","Struct member '{0}' of type '{1}' causes a cycle in the struct layout":"type'{1}'的struct成员'{0}'在struct布局中导致一个周期\r\n","True if the symbol is okay (i.e. no warnings).":"如果符号还可以（即没有警告），则为正确。\r\n","\r\n              Looks up a localized string similar to Source file '{0}' specified multiple times.\r\n            ":"\r\n              查找类似于源文件'{0}'指定多次的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use a method group as an argument to a dynamically dispatched operation. Did you intend to invoke the method?.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法将方法组用作动态调度操作的参数。您是否打算调用该方法？\r\n            \r\n","Non-trailing named arguments":"非访问命名参数\r\n","\r\n            A list of cref parameters with surrounding punctuation.\r\n            Unlike regular parameters, cref parameters do not have names.\r\n            ":"\r\n            周围标点符号的CREF参数列表。\r\n            与常规参数不同，CREF参数没有名称。\r\n            \r\n","Program has more than one entry point defined. Compile with /main to specify the type that contains the entry point.":"程序已定义多个入口点。使用 /main编译以指定包含入口点的类型。\r\n"," data for this method, if there is any. If forceComplete\r\n            is false and the data has not yet been loaded or only early attribute binding has occurred, then either\r\n            ":" 如果有的话，此方法的数据。如果forcectey\r\n            是错误的，数据尚未加载或仅发生早期属性绑定，然后\r\n            \r\n","Called when the visitor visits a QueryExpressionSyntax node.":"当访问者访问QueryExpressionsyntax节点时调用。\r\n","A volatile field should not normally be used as a ref or out value, since it will not be treated as volatile. There are exceptions to this, such as when calling an interlocked API.":"挥发性场通常不应用作REF或输出值，因为它不会被视为挥发性。有例外，例如调用互锁的API。\r\n","\r\n            Outside of ":"\r\n            在外面\r\n","\r\n              Looks up a localized string similar to The best overloaded method match '{0}' for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters..\r\n            ":"\r\n              查找类似于最佳超载方法匹配的本地化字符串，无法使用集合初始化器元素的'{0}'。收集初始化程序“ add”方法不能具有参数或输出参数。\r\n            \r\n","\r\n              Looks up a localized string similar to namespace alias qualifier.\r\n            ":"\r\n              查找类似于名称空间别名预选赛的本地化字符串。\r\n            \r\n","\r\n            Translates anonymous type public symbol into an implementation type symbol to be used in emit.\r\n            ":"\r\n            将匿名类型的公共符号转换为要在EMIT中使用的实现类型符号。\r\n            \r\n","\r\n            Get a SemanticModel object that is associated with an expression body that did not appear in\r\n            this source code. This can be used to get detailed semantic information about sub-parts\r\n            of an expression body that did not appear in source code.\r\n            ":"\r\n            获取与未出现在\r\n            此源代码。这可以用来获取有关子部分的详细语义信息\r\n            未出现在源代码中的表达主体。\r\n            \r\n","\r\n            Create a vector of n dummy type parameters.  Always reuses the same type parameter symbol\r\n            for the same position.\r\n            ":"创建n个虚拟类型参数的向量。始终重复使用相同类型的参数符号\r\n            对于相同的位置。\r\n            \r\n","\r\n              Looks up a localized string similar to Attribute '{0}' is only valid on methods or attribute classes.\r\n            ":"\r\n              查找类似于属性'{0}'的本地化字符串仅在方法或属性类上有效。\r\n            \r\n","Feature '{0}' is not available in C# 6. Please use language version {1} or greater.":"C＃6中不可用功能'{0}'使用语言版本{1}或更大。\r\n","'{0}' has the wrong signature to be an entry point":"'{0}'的签名错误是入口点\r\n","\r\n              Looks up a localized string similar to access modifiers on properties.\r\n            ":"\r\n              查找类似于属性的访问修饰符的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Syntax error; value expected.\r\n            ":"\r\n              查找类似于语法错误的本地化字符串；预期的价值。\r\n            \r\n"," if either operand is that.\r\n            ":" 如果是操作数。\r\n            \r\n","\r\n            The list of contained PEModuleSymbol objects.\r\n            The list doesn't use type ReadOnlyCollection(Of PEModuleSymbol) so that we\r\n            can return it from Modules property as is.\r\n            ":"\r\n            包含的pemodulesymbol对象的列表。\r\n            该列表不使用type readonLyCollection（pemodulesymbol的），以便我们\r\n            可以按原样从模块属性返回。\r\n            \r\n","\r\n            A collection of value set factory instances for built-in types.\r\n            ":"\r\n            内置类型的价值设置工厂实例集合。\r\n            \r\n","\r\n            Spec 7.5.12:\r\n            For non-constant expressions (expressions that are evaluated at run-time) that are not \r\n            enclosed by any checked or unchecked operators or statements, the default overflow checking\r\n            context is unchecked unless external factors (such as compiler switches and execution \r\n            environment configuration) call for checked evaluation.\r\n            ":"\r\n            规格7.5.12：\r\n            对于非恒定表达式（在运行时间进行评估的表达式）\r\n            默认溢出检查被任何检查或未检查的操作员或语句所包含\r\n            除非外部因素（例如编译器开关和执行，否\r\n            环境配置）呼吁进行检查评估。\r\n            \r\n","\r\n            Is this a context in which a stackalloc expression could be converted to the corresponding pointer\r\n            type? The only context that permits it is the initialization of a local variable declaration (when\r\n            the declaration appears as a statement or as the first part of a for loop).\r\n            ":"\r\n            这是可以将stackalloc表达式转换为相应指针的上下文\r\n            类型？唯一允许的上下文是本地变量声明的初始化（当\r\n            该声明是作为陈述或循环的第一部分。\r\n            \r\n","\r\n              Looks up a localized string similar to Delay signing was specified and requires a public key, but no public key was specified.\r\n            ":"\r\n              指定了一个类似于延迟签名的本地化字符串，并需要一个公钥，但没有指定公共密钥。\r\n            \r\n","\r\n            Anonymous type descriptor Key \r\n            \r\n            The key is to be used to separate anonymous type templates in an anonymous type symbol cache. \r\n            The type descriptors with the same keys are supposed to map to 'the same' anonymous type \r\n            template in terms of the same generic type being used for their implementation.\r\n            ":"\r\n            匿名类型描述符键\r\n            \r\n            关键是用于在匿名类型符号缓存中分离匿名类型模板。\r\n            具有相同键的类型描述符应该映射到“相同”匿名类型\r\n            根据用于实现的相同通用类型的模板。\r\n            \r\n","\r\n            Retargeted return type custom attributes\r\n            ":"\r\n            重新定位的返回类型自定义属性\r\n            \r\n","A value to display as a string.":"作为字符串显示的值。\r\n","Has parameters.":"具有参数。\r\n","\r\n            A custom equality comparer for ":"\r\n            一个自定义平等比较\r\n","Type overrides Object.Equals(object o) but does not override Object.GetHashCode()":"键入覆盖object.equals.equals（object o），但不覆盖object.gethashcode（）\r\n","Called when the visitor visits a LabeledStatementSyntax node.":"当访问者访问标签statementsyntax节点时调用。\r\n","This label has not been referenced":"该标签尚未引用\r\n","The /moduleassemblyname option may only be specified when building a target type of 'module'":"/ipuleassemblyName选项仅在构建目标类型的“模块”时才能指定\r\n","\r\n              Looks up a localized string similar to The parameter name '{0}' is a duplicate.\r\n            ":"\r\n              查找类似于参数名称'{0}'的本地化字符串是重复的。\r\n            \r\n","\r\n              Looks up a localized string similar to Named argument '{0}' specifies a parameter for which a positional argument has already been given.\r\n            ":"\r\n              查找类似于命名参数'{0}'的本地化字符串指定了已经给出了位置参数的参数。\r\n            \r\n",".\r\n            The syntax node is used to determine the overall nullable context for the region.\r\n            ":"。\r\n            语法节点用于确定该区域的总体可确定上下文。\r\n            \r\n"," as a parameter type.":" 作为参数类型。\r\n","Returns non-negative index if the list contains a node which matches ":"如果列表包含匹配的节点，则返回非负索引\r\n","The body of an async-iterator method must contain a 'yield' statement. Consider removing 'async' from the method declaration or adding a 'yield' statement.":"异步 - 介质方法的主体必须包含“产量”陈述。考虑从方法声明中删除“异步”或添加“收益率”陈述。\r\n"," is a sufficient method for enforcing DEBUG \r\n            only invariants in our code. When it triggers that provides a nice stack trace for \r\n            investigation. Generally that is enough.\r\n            \r\n            ":" 是实施调试的足够方法\r\n            仅在我们的代码中不变。当它触发提供了一个不错的堆栈跟踪时\r\n            调查。通常，这足够了。\r\n            \r\n            \r\n","The length of the newline sequence discovered. 0 if the end of the string was reached, otherwise either 1 or 2 chars":"发现新线序列的长度。 0如果达到字符串的末端，否则要么1或2个字符\r\n","Argument type '{0}' is not CLS-compliant":"参数类型'{0}'不符合CLS\r\n","Called when the visitor visits a PositionalPatternClauseSyntax node.":"当访问者访问positalPatternClausesyntax节点时调用。\r\n","\r\n            Gets the parse options for the C# ":"\r\n            获取C＃的解析选项\r\n","\r\n              Looks up a localized string similar to Syntax node to be speculated cannot belong to a syntax tree from the current compilation..\r\n            ":"\r\n              查找类似于要推测的语法节点类似的本地化字符串，不能从当前汇编中属于语法树。\r\n            \r\n","\r\n            Push the set of equality tests down to the level of the leaves in the value dispatch tree.\r\n            ":"\r\n            将平等测试集中到值调度树中的叶子水平。\r\n            \r\n","Suppress emitting localsinit flag":"抑制发射的本地旗帜\r\n","The delegate '{0}' does not have a valid constructor":"委托'{0}'没有有效的构造函数\r\n","\r\n            See if the expression is an invocation of a method named 'var',\r\n            I.e. something like \"var(x, y)\" or \"var(x, (y, z))\" or \"var(1)\".\r\n            We report an error when such an invocation is used in a certain syntactic contexts that\r\n            will require an lvalue because we may elect to support deconstruction\r\n            in the future. We need to ensure that we do not successfully interpret this as an invocation of a\r\n            ref-returning method named var.\r\n            ":"\r\n            查看该表达式是否是称为“ var”的方法的调用，\r\n            IE。例如“ var（x，y）”或“ var（x，y，z））”或“ var（1）”。\r\n            当在某些句法上下文中使用此类调用时，我们报告了错误\r\n            将需要一个LVALUE，因为我们可以选择支持解构\r\n            在将来。我们需要确保我们不会成功将其解释为\r\n            名为var的ref-retnurn方法。\r\n            \r\n","\r\n              Looks up a localized string similar to The type '{2}' must be a non-nullable value type in order to use it as parameter '{1}' in the generic type or method '{0}'.\r\n            ":"\r\n              查找类似于“ {2}”类型的本地化字符串必须是一种不可删除的值类型，以便将其用作通用类型或方法'{0}'中的参数'{1}'。\r\n            \r\n","\r\n              Looks up a localized string similar to Fields of static readonly field '{0}' cannot be returned by reference.\r\n            ":"\r\n              查找类似于静态读取字段'{0}'字段类似的本地化字符串，无法通过引用返回。\r\n            \r\n","To stop traversing the symbol table early.":"停止尽早穿越符号表。\r\n","\r\n            In embedded statements, returns a BoundLocal when the type was explicit.\r\n            In global statements, returns a BoundFieldAccess when the type was explicit.\r\n            Otherwise returns a DeconstructionVariablePendingInference when the type is implicit.\r\n            ":"\r\n            在嵌入式语句中，当类型被显式时返回边界。\r\n            在全球语句中，当类型是明确时返回边界访问。\r\n            否则，当类型是隐式时，将返回解构variable -pendenterference。\r\n            \r\n","\r\n            Event accessor that has been synthesized for a field-like event declared in source,\r\n            or for an event re-abstraction in an interface.\r\n            ":"\r\n            事件访问者已合成为在源中声明的类似现场的事件合成的访问者，\r\n            或用于接口中的事件重新启动。\r\n            \r\n","\r\n            Not null.\r\n            ":"\r\n            不是零。\r\n            \r\n","\r\n             The rewriter for removing lambda expressions from method bodies and introducing closure classes\r\n             as containers for captured variables along the lines of the example in section 6.5.3 of the\r\n             C# language specification. A closure is the lowered form of a nested function, consisting of a\r\n             synthesized method and a set of environments containing the captured variables.\r\n             \r\n             The entry point is the public method ":"\r\n             从方法主体中删除lambda表达式并引入关闭类的重写者\r\n             作为沿该示例的捕获变量的容器，在第6.5.3节中\r\n             C＃语言规范。封闭是嵌套功能的降低形式，由\r\n             合成方法和一组包含捕获变量的环境。\r\n             \r\n             入口点是公共方法\r\n","\r\n            The bound node representing this scope. This roughly corresponds to the bound\r\n            node for the block declaring locals for this scope, although parameters of\r\n            methods/functions are introduced into their Body's scope and do not get their\r\n            own scope.\r\n            ":"\r\n            代表此范围的结合节点。这大致对应于绑定\r\n            尽管参数的参数\r\n            方法/功能被引入其身体的范围，不得到他们的\r\n            自己的范围。\r\n            \r\n","Creates a new BracketedArgumentListSyntax instance.":"创建一个新的BrackeTedArgumentListSyntax实例。\r\n","\r\n              Looks up a localized string similar to '{0}': abstract event cannot use event accessor syntax.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串：抽象事件无法使用事件访问者语法。\r\n            \r\n"," is applied, \r\n            or the parameter is from metadata and HasDefault metadata flag is set. See\r\n            ":" 被申请;被应用，\r\n            或该参数来自元数据和Hasdefault Metadata标志。看\r\n            \r\n","\r\n            Expression is assigned by reference.\r\n            ":"\r\n            表达式通过参考分配。\r\n            \r\n","\r\n              Looks up a localized string similar to No source files specified..\r\n            ":"\r\n              查找类似于未指定源文件的本地化字符串。\r\n            \r\n","A possible null value may not be used for a type marked with [NotNull] or [DisallowNull]":"可能不使用可能的空值，以标记为[notnull]或[disallownull]的类型\r\n","An expression which much occur within the syntax tree\r\n            associated with this object.":"语法树中很多发生的表达\r\n            与此对象关联。\r\n","\r\n            Used to force (source) symbols to a given state of completion when the only potential remaining \r\n            part is attributes. This does force the invariant on the caller that the implementation of \r\n            of ":"\r\n            当剩下的唯一潜力\r\n            部分是属性。这确实迫使呼叫者不间断地实施\r\n            的\r\n","\r\n            Any non-null type symbol returned is guaranteed not to be an error type.\r\n            \r\n            It is possible to pass in a constructed type and received back an \r\n            unconstructed type.  This can occur when the type passed in was\r\n            constructed from an error type - the underlying definition will be\r\n            available, but there won't be a good way to \"re-substitute\" back up\r\n            to the level of the specified type.\r\n            ":"\r\n            保证返回的任何非NULL类型符号都不是错误类型。\r\n            \r\n            可以通过构造类型并收到\r\n            非结构类型。当传递的类型是\r\n            由错误类型构建 - 基础定义将是\r\n            可用，但是没有一个很好的方法来“重新取消”备份\r\n            到指定类型的级别。\r\n            \r\n"," node.\r\n            \r\n            The location of the declarator is used to calculate ":" 节点。\r\n            \r\n            声明器的位置用于计算\r\n"," with the new scope,\r\n            or reuse the current scope if there's no change in the bound node for the nested scope.\r\n            Records the given locals as declared in the aforementioned scope.\r\n            ":" 有了新范围，\r\n            或重复使用当前范围，如果嵌套范围的绑定节点没有更改。\r\n            在上述范围中记录给定的当地人。\r\n            \r\n","A list of xml node syntax that will be the content within the returns element.":"XML节点语法的列表将是返回元素中的内容。\r\n","\r\n              Looks up a localized string similar to Type parameter '{1}' has the 'struct' constraint so '{1}' cannot be used as a constraint for '{0}'.\r\n            ":"\r\n              查找类似于类型参数'{1}'的本地化字符串具有“ struct”约束so'{1}'不能用作'{0}'的约束。\r\n            \r\n","Interop type '{0}' cannot be embedded because it is missing the required '{1}' attribute.":"Interop类型'{0}'无法嵌入，因为它缺少所需的'{1}'属性。\r\n","\r\n            \"Pair lambda\" is a synthesized lambda that creates an instance of an anonymous type representing a pair of values. \r\n            ":"\r\n            “ Pair Lambda”是一个合成的lambda，它创建代表一对值的匿名类型的实例。\r\n            \r\n","A list of xml node syntax that will be used as the link text for the referenced item.":"XML节点语法列表，将用作引用项目的链接文本。\r\n","Member '{0}' added during the current debug session can only be accessed from within its declaring assembly '{1}'.":"在当前调试会话中添加的会员'{0}'只能从其声明汇编'{1}'中访问。\r\n","\r\n            Extract type under assumption that there should be no custom modifiers or annotations.\r\n            The method asserts otherwise.\r\n            ":"\r\n            假设不应有自定义修饰符或注释的提取类型。\r\n            该方法否则断言。\r\n            \r\n","\r\n            For tuple literals, we just return the element.\r\n            For expressions with tuple type, we access ":"\r\n            对于元素文字，我们只是返回元素。\r\n            对于带有元组类型的表达式，我们访问\r\n","\r\n            Visits the binary operator tree of interpolated string additions in a depth-first pre-order visit,\r\n            meaning parent, left, then right.\r\n            ":"\r\n            访问深度优先访问中插值字符串添加的二进制操作员树，\r\n            意思是父，左，然后向右。\r\n            \r\n","\r\n            The Lookup was successful\r\n            ":"\r\n            查找成功了\r\n            \r\n","\r\n            The result type of the constructed task: T for Task<T>, void otherwise.\r\n            ":"构造任务的结果类型：t task <t>，否则。\r\n            \r\n","Gets the keyword token, or identifier if an erroneous accessor declaration.":"如果错误的访问者声明，请获取关键字令牌或标识符。\r\n","where to report a cyclic error if needed":"如果需要的话，在哪里报告周期性错误\r\n","Creates a new TupleElementSyntax instance.":"创建一个新的TupleEletementsyntax实例。\r\n","\r\n              Looks up a localized string similar to Security attribute '{0}' has an invalid SecurityAction value '{1}'.\r\n            ":"\r\n              查找类似于安全属性'{0}'的本地化字符串具有无效的安全性值'{1}'。\r\n            \r\n","\r\n            Build a dependency graph (a map from\r\n            field to dependencies).\r\n            ":"\r\n            构建依赖关系图（来自\r\n            依赖项）。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid XML include element.\r\n            ":"\r\n              查找类似于无效XML元素的本地化字符串。\r\n            \r\n"," API. The \"Body\" is the method that\r\n            implements the interface method \"Implemented\". \r\n            Some of the MethodImpl entries could require synthetic forwarding methods. In such cases,\r\n            the \"Body\" is the method that the language considers to implement the interface method,\r\n            the \"Implemented\", rather than the forwarding method. In other words, it is the method that \r\n            the forwarding method forwards to.\r\n            ":" API。 “身体”是一种方法\r\n            实现接口方法“已实现”。\r\n            某些方法IMPL条目可能需要合成转发方法。在这种情况下，\r\n            “正文”是语言认为实现接口方法的方法，\r\n            “已实施”，而不是转发方法。换句话说，这是一种方法\r\n            转发方法转发到。\r\n            \r\n","\r\n            Determine what we can learn from one successful runtime type test about another planned\r\n            runtime type test for the purpose of building the decision tree.\r\n            We accomodate a special behavior of the runtime here, which does not match the language rules.\r\n            A value of type `int[]` is an \"instanceof\" (i.e. result of the `isinst` instruction) the type\r\n            `uint[]` and vice versa.  It is similarly so for every pair of same-sized numeric types, and\r\n            arrays of enums are considered to be their underlying type.  We need the dag construction to\r\n            recognize this runtime behavior, so we pretend that matching one of them gives no information\r\n            on whether the other will be matched.  That isn't quite correct (nothing reasonable we do\r\n            could be), but it comes closest to preserving the existing C#7 behavior without undesirable\r\n            side-effects, and permits the code-gen strategy to preserve the dynamic semantic equivalence\r\n            of a switch (on the one hand) and a series of if-then-else statements (on the other).\r\n            See, for example, https://github.com/dotnet/roslyn/issues/35661\r\n            ":"\r\n            确定我们可以从一项成功的运行时类型测试中学到什么\r\n            运行时类型测试是为了构建决策树的目的。\r\n            我们在此处满足了运行时的特殊行为，该行为与语言规则不符。\r\n            类型`int []`是“实例”的值（即`iasinst'指令的结果）\r\n            `uint []`，反之亦然。同样，对于每对相同大小的数字类型，\r\n            枚举阵列被认为是其基础类型。我们需要DAG结构\r\n            识别这种运行时行为，因此我们假装匹配其中一个没有提供任何信息\r\n            关于另一个是否会匹配。那不是完全正确的（我们没什么合理的\r\n            可能是），但最接近保留现有的C＃7行为而没有不良的行为\r\n            副作用，并允许代码 - 基因策略保留动态语义等效性\r\n            开关（一方面）和一系列If-then-else语句（另一方面）。\r\n            参见，例如，https：//github.com/dotnet/roslyn/issues/35661\r\n            \r\n","\r\n            The NestedFunction type represents a lambda or local function and stores\r\n            information related to that function. After initially building the\r\n            ":"\r\n            NestedFunction类型代表Lambda或本地功能，并存储\r\n            与该功能有关的信息。最初建立\r\n            \r\n","Cannot convert lambda to an expression tree whose type argument '{0}' is not a delegate type":"不能将lambda转换为表达树的类型参数'{0}'不是委托类型\r\n","Cannot embed interop types from assembly '{0}' because it is missing the '{1}' attribute.":"无法从汇编'{0}'嵌入Interop类型，因为它缺少'{1}'属性。\r\n","\r\n            The interpolated string conversion described in section 6.1.N of the C# language specification.\r\n            ":"\r\n            C＃语言规范第6.1.N节中描述的插值字符串转换。\r\n            \r\n","\r\n            Returns true if the conversion is an implicit switch expression conversion.\r\n            ":"\r\n            如果转换是隐式开关表达式转换，则返回true。\r\n            \r\n","\r\n              Looks up a localized string similar to Members of {0} '{1}' cannot be used as a ref or out value because it is a readonly variable.\r\n            ":"\r\n              查找类似于{0}'{1}'成员的本地化字符串，因为它是一个可读变量，因此不能用作ref或out值。\r\n            \r\n","\r\n            Given a decision dag and a constant-valued input, produce a simplified decision dag that has removed all the\r\n            tests that are unnecessary due to that constant value. This simplification affects flow analysis (reachability\r\n            and definite assignment) and permits us to simplify the generated code.\r\n            ":"\r\n            鉴于决策DAG和一个恒定值的输入，产生了简化的决策DAG，该DAG已删除了所有\r\n            由于该恒定值而不必要的测试。这种简化会影响流量分析（可达性\r\n            并确定分配），并允许我们简化生成的代码。\r\n            \r\n",".\r\n             \r\n             Next, we walk and rewrite the input bound tree, keeping track of the following:\r\n             (1) The current set of active frame pointers, in ":"。\r\n             \r\n             接下来，我们步行并重写输入绑定的树，跟踪以下内容：\r\n             （1）当前的活动帧指针集\r\n","Static types cannot be used as return types":"静态类型不能用作返回类型\r\n","\r\n            A NoPiaIllegalGenericInstantiationSymbol is a special kind of ErrorSymbol that represents a\r\n            generic type instantiation that cannot cross assembly boundaries according to NoPia rules.\r\n            ":"\r\n            nopiaillgalgenericinstantiationsymbol是一种特殊的错误符号，代表\r\n            通用类型实例化无法根据NOPIA规则跨越组装边界。\r\n            \r\n","The list of changes may be different than the original changes that produced this tree.":"更改列表可能与产生该树的原始变化不同。\r\n","The member '{0}' does not hide an accessible member. The new keyword is not required.":"成员'{0}'不会隐藏可访问的成员。不需要新的关键字。\r\n","Gets the colon token.":"获取结肠令牌。\r\n","\r\n              Looks up a localized string similar to The expression must be of type '{0}' because it is being assigned by reference.\r\n            ":"\r\n              查找类似于表达式的本地化字符串必须为“ {0}”类型，因为它是通过参考分配的。\r\n            \r\n","\r\n              Looks up a localized string similar to Unable to include XML fragment.\r\n            ":"\r\n              查找类似于无法包括XML片段的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to notnull generic type constraint.\r\n            ":"\r\n              查找类似于NotNull通用类型约束的本地化字符串。\r\n            \r\n","\r\n            Maps a LookupResultKind to a CandidateReason. Should not be called on LookupResultKind.Viable!\r\n            ":"\r\n            将Lookupresultkind映射到候选人季节。不应在LookupResultKind.ctiable上调用！\r\n            \r\n","partial method":"部分方法\r\n","Cannot return '{0}' by reference because it is read-only":"无法通过引用返回'{0}'，因为它是只读的\r\n","Syntax nodes of attributes in order they are specified in source, or null if there are no attributes.":"属性的语法节点按顺序按源指定，或者如果没有属性，则在null中指定。\r\n","\r\n            Creates a token with kind XmlTextLiteralNewLineToken.\r\n            ":"\r\n            用友善的XMLTEXTLITERALNEWLILETOKEN创建一个令牌。\r\n            \r\n","\r\n            Gets a read-only list of all the modules in this assembly. (There must be at least one.) The first one is the main module\r\n            that holds the assembly manifest.\r\n            ":"\r\n            获取此组件中所有模块的仅读取列表。 （必须至少有一个。）第一个是主模块\r\n            这持有组装的清单。\r\n            \r\n","\r\n            Return a version of the baseline with all definitions mapped to this compilation.\r\n            Definitions from the initial generation, from metadata, are not mapped since\r\n            the initial generation is always included as metadata. That is, the symbols from\r\n            types, methods, ... in the TypesAdded, MethodsAdded, ... collections are replaced\r\n            by the corresponding symbols from the current compilation.\r\n            ":"\r\n            返回基线的版本，其中所有定义映射到此汇编。\r\n            最初一代的定义，来自元数据，没有映射\r\n            初始一代始终以元数据包含在内。也就是说，来自\r\n            类型，方法，...在类型added，methodsAdded中，...收集替换\r\n            通过当前汇编的相应符号。\r\n            \r\n","Compilation used to check constraints.\r\n            The latest language version is assumed if this is null.":"汇编用于检查约束。\r\n            如果这为null，则假定最新的语言版本。\r\n","\r\n              Looks up a localized string similar to recursive patterns.\r\n            ":"\r\n              查找类似于递归模式的局部字符串。\r\n            \r\n","\r\n            Gets a SyntaxToken that represents the close parenthesis succeeding the switch expression.\r\n            ":"\r\n            获取一个代表接近括号的Syntaxtkoken成功的开关表达式。\r\n            \r\n","\r\n              Looks up a localized string similar to Default parameter value for '{0}' must be a compile-time constant.\r\n            ":"\r\n              查找类似于'{0}'的默认参数值的本地化字符串必须是一个编译时常数。\r\n            \r\n","A list of xml node syntax that will be the content within the remarks element.":"XML节点语法列表，该列表将是备注元素中的内容。\r\n","The character value to be represented by the returned token.":"返回令牌要表示的字符值。\r\n","\r\n              Looks up a localized string similar to Member '{1}' overrides '{0}'. There are multiple override candidates at run-time. It is implementation dependent which method will be called..\r\n            ":"\r\n              查找类似于成员'{1}'覆盖'{0}'的本地化字符串。运行时间有多个替代候选人。这是实现依赖性的，哪种方法将被调用。\r\n            \r\n","\r\n            Expression is the LHS of a simple assignment operation.\r\n            ":"\r\n            表达是简单分配操作的LHS。\r\n            \r\n","\r\n            Look for any symbols in scope with the given name and arity.\r\n            ":"\r\n            寻找具有给定名称和arity的任何符号。\r\n            \r\n","\r\n            Analyzes method body for yields in try blocks and labels that they contain.\r\n            ":"\r\n            分析方法主体的试图块和其包含的标签中的产量。\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability of reference types in type doesn't match implemented member..\r\n            ":"\r\n              查找类似于类型中参考类型的无效性类似的本地化字符串与实现的成员不匹配。\r\n            \r\n","The switch expression must be a value; found '{0}'.":"开关表达式必须是一个值；找到'{0}'。\r\n"," (Deconstructable2.Deconstruct), no ":" （deconstructable2.deconstruct），否\r\n","Expected '>' or '/>' to close tag '{0}'.":"预期'>'或'/>'关闭标签'{0}'。\r\n","\r\n            return true if the type is constructed from a generic interface that \r\n            might be implemented by an array.\r\n            ":"\r\n            如果类型是从一个通用接口构造的，则返回true\r\n            可能由数组实现。\r\n            \r\n","Called when the visitor visits a WhereClauseSyntax node.":"当访问者访问whereclaisesyntax节点时打电话。\r\n","Called when the visitor visits a DefineDirectiveTriviaSyntax node.":"当访问者访问定义的辅导静脉节点节点时调用。\r\n","SyntaxToken representing colon colon.":"Syntaxtoken代表结肠结肠。\r\n","The type or namespace name '{0}' could not be found in the global namespace (are you missing an assembly reference?)":"在全局名称空间中找不到类型或名称名称'{0}'（您是否缺少汇编引用？）\r\n","\r\n            Evaluate side effects into a temp, if any.  Return the expression to give the value later.\r\n            ":"\r\n            如果有的话，将副作用评估为温度。返回表达式以稍后给出值。\r\n            \r\n","\r\n            A region analysis walker that computes the set of variables that are always assigned a value\r\n            in the region. A variable is \"always assigned\" in a region if an analysis of the region that\r\n            starts with the variable unassigned ends with the variable assigned.\r\n            ":"\r\n            一个始终分配值的变量集的区域分析步行器\r\n            在该区域。如果对区域的分析，则在区域中“总是分配”一个变量\r\n            从变量分配的变量末端开始，从分配的变量开始。\r\n            \r\n","PatternSyntax node representing the pattern on the right of the \"is\" operator.":"patternsyntax节点表示“”算子右侧的模式。\r\n","Compilation options '{0}' and '{1}' can't both be specified at the same time.":"编译选项'{0}'和'{1}'不能同时指定。\r\n","\r\n            Returns true if the conversion exists, either as an implicit or explicit conversion.\r\n            ":"\r\n            如果存在转换，则返回true，无论是隐式还是显式转换。\r\n            \r\n","\r\n              Looks up a localized string similar to Unexpected token '{0}'.\r\n            ":"\r\n              查找类似于意外令牌'{0}'的本地化字符串。\r\n            \r\n","\r\n            Merges nullability of all type arguments from the `typeA` and `typeB`.\r\n            The type parameters are added to `allTypeParameters`; the merged\r\n            type arguments are added to `allTypeArguments`; and the method\r\n            returns true if there were changes from the original `typeA`.\r\n            ":"\r\n            合并所有类型参数从`typea'和typeb'的无效性。\r\n            将类型参数添加到``Alltypeparameters''中;合并\r\n            类型参数被添加到``Alltypearguments''中;和方法\r\n            如果原始`typea'发生更改，则返回true。\r\n            \r\n","\r\n            Represents region analysis context attributes such as compilation, region, etc...\r\n            ":"\r\n            代表区域分析上下文属性，例如编译，区域等...\r\n            \r\n","\r\n            Adds the side effects to effects and returns temporaries to access them.\r\n            The caller is responsible for releasing the nested ArrayBuilders.\r\n            The variables should be unlowered.\r\n            ":"\r\n            将副作用添加到效果中，并返回临时性以访问它们。\r\n            呼叫者负责释放嵌套的阵列构建器。\r\n            变量应保持不变。\r\n            \r\n","\r\n            The underlying NamedTypeSymbol, cannot be another RetargetingNamedTypeSymbol.\r\n            ":"\r\n            命名为typesymbol的基础，不能是另一个retargetingNeveMedTypesymbol。\r\n            \r\n","\r\n            Also, the following are affected if container==null (and, for the latter, when arity==null\r\n            or arity==0):\r\n            ":"\r\n            另外，如果容器== null（对于后者，当arity == null时\r\n            或arity == 0）：\r\n            \r\n","\r\n             has been calculated.\r\n            \r\n             Finds the most optimal capture environment to place a closure in. \r\n             This roughly corresponds to the 'highest' Scope in the tree where all\r\n             the captured variables for this closure are in scope. This minimizes\r\n             the number of indirections we may have to traverse to access captured\r\n             variables.\r\n             ":"\r\n             已经计算出来。\r\n            \r\n             找到最佳的捕获环境，以封闭。\r\n             这大致对应于树上的“最高”范围\r\n             此关闭的捕获变量在范围内。这最小化\r\n             我们可能必须穿越才能访问捕获的间接数量\r\n             变量。\r\n             \r\n","Semicolon after method or accessor block is not valid":"方法或登录器块之后的半隆无效\r\n","\r\n            Rewrite the given node to eliminate lambda expressions.  Also returned are the method symbols and their\r\n            bound bodies for the extracted lambda bodies. These would typically be emitted by the caller such as\r\n            MethodBodyCompiler.  See this class' documentation\r\n            for a more thorough explanation of the algorithm and its use by clients.\r\n            ":"\r\n            重写给定的节点以消除lambda表达式。还返回的是方法符号及其\r\n            提取的Lambda身体的结合体。这些通常会由呼叫者散发\r\n            MethodBodyCompiler。查看此类文档\r\n            为了对算法及其使用的使用更彻底的解释。\r\n            \r\n","\r\n            This is only intended to be called when the type isn't found (i.e. not when it is found but is inaccessible, has the wrong arity, etc).\r\n            ":"\r\n            仅当找不到类型时（即，在发现它时没有发现而是无法访问，错误的Arity等）时才被调用。\r\n            \r\n",",\r\n            which will already have checked for ":",\r\n            它已经检查过了 \r\n","\r\n              Looks up a localized string similar to <text>.\r\n            ":"\r\n              查找类似于<文本>的本地化字符串。\r\n            \r\n","XML comment has a duplicate typeparam tag for '{0}'":"XML评论具有“ {0}”的重复typeparam标签\r\n","Circular constraint dependency involving '{0}' and '{1}'":"涉及'{0}'和'{1}'的循环约束依赖关系\r\n","\r\n            Given an anonymous type and new field types construct a new anonymous type symbol; \r\n            a new type symbol will reuse type descriptor from the constructed type with new type arguments.\r\n            ":"\r\n            给定一种匿名类型和新字段类型构建了新的匿名类型符号；\r\n            一个新的类型符号将重复使用带有新类型参数的构造类型的描述符。\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability of reference types in value doesn't match target type..\r\n            ":"\r\n              查找类似于值中参考类型的无效性类似的本地化字符串与目标类型不匹配。\r\n            \r\n"," is the syntax span used to determine the overall nullable context.":" 是用于确定整体可确定上下文的语法跨度。\r\n","Parameter '{0}' must be an 'INamedTypeSymbol' or an 'IAssemblySymbol'.":"参数'{​​0}'必须是“ inamedtypesymbol”或“ iassemblysymbol”。\r\n","'{0}': abstract event cannot use event accessor syntax":"'{0}'：抽象事件无法使用事件访问者语法\r\n","\r\n            Determines whether \"this\" reference is available within the current context.\r\n            ":"\r\n            确定在当前上下文中是否可用“此”参考。\r\n            \r\n","\r\n              Looks up a localized string similar to Fields of static readonly field '{0}' cannot be assigned to (except in a static constructor or a variable initializer).\r\n            ":"\r\n              查找类似于静态读取字段'{0}'字段类似的本地化字符串，无法分配给（在静态构造函数或变量初始器中除外）。\r\n            \r\n","s, so pass\r\n            ignoringInterfaceImplementationChanges: true if you need a value sooner\r\n            and aren't concerned about tweaks made to satisfy interface implementation \r\n            requirements.\r\n            NOTE: Not ignoring changes can only result in a value that is more true.\r\n            ":"S，所以通过\r\n            忽略InterfaceImplemperationChanges：如果您需要一个值，则为true\r\n            并且不担心为满足界面实现的调整\r\n            要求。\r\n            注意：不忽略更改只能导致更真实的值。\r\n            \r\n","Represents a switch label within a switch statement.":"表示开关语句中的开关标签。\r\n","\r\n            Returns true if the type can be embedded. If the type is defined in a linked (/l-ed)\r\n            assembly, but doesn't meet embeddable type requirements, this function returns false\r\n            and reports appropriate diagnostics.\r\n            ":"\r\n            如果可以嵌入类型，则返回true。如果类型是在链接（/l-ed）中定义的\r\n            汇编，但不符合可嵌入类型的要求，此功能返回false\r\n            并报告适当的诊断。\r\n            \r\n","\r\n            Gets await expression info.\r\n            ":"获得等待表达信息。\r\n            \r\n","\r\n            Creates the syntax representation of a named xml element within xml documentation comments.\r\n            ":"\r\n            在XML文档注释中创建命名XML元素的语法表示。\r\n            \r\n","\r\n            Returns false because label can't be virtual.\r\n            ":"\r\n            返回false，因为标签不能虚拟。\r\n            \r\n","Named argument '{0}' is used out-of-position but is followed by an unnamed argument":"命名参数'{0}'被使用的位置，但随后是一个未命名的参数\r\n","Creates a new DefaultExpressionSyntax instance.":"创建一个新的DefaultExpressyNntax实例。\r\n","String equality method":"字符串平等方法\r\n","\r\n              Looks up a localized string similar to The typeof operator cannot be used on the dynamic type.\r\n            ":"在动态类型上查找类似于操作员类型的本地化字符串。\r\n            \r\n","\r\n            Evaluate side effects into a temp, if necessary.  If there is an implicit user-defined\r\n            conversion operation near the top of the arg, preserve that in the returned expression to be evaluated later.\r\n            Conversions at the head of the result are unlowered, though the nested arguments within it are lowered.\r\n            That resulting expression must be passed through ":"\r\n            如有必要，将副作用评估为温度。如果有隐式用户定义\r\n            转换操作在ARG顶部附近，保留在返回的表达式中要评估的表达式。\r\n            尽管嵌套的参数降低了，但结果的转换是不辜负的。\r\n            结果表达必须通过\r\n","\r\n              Looks up a localized string similar to A static readonly field cannot be passed ref or out (except in a static constructor).\r\n            ":"\r\n              查找类似于静态可读字段的本地化字符串无法传递或输出（除了静态构造函数外）。\r\n            \r\n","\r\n            True if instructions that check overflow should be generated.\r\n            ":"\r\n            正确，如果应生成检查溢出的说明。\r\n            \r\n","Fixed size buffer type must be one of the following: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float or double":"固定尺寸缓冲区类型必须是以下之一：布尔，字节，短，int，long，char，sbyte，ushort，uint，uint，ulong，float或double\r\n","Disposable ref structs":"一次性参考结构\r\n","\r\n            Semantic information associated with a query clause in a C# query expression.\r\n            ":"\r\n            与c＃查询表达式中的查询子句相关的语义信息。\r\n            \r\n","Return type is not CLS-compliant":"返回类型不符合CLS\r\n","Creates a new CheckedStatementSyntax instance.":"创建一个新的checkedstatementsyntax实例。\r\n","\r\n            Collection of names of members declared within this type.\r\n            ":"\r\n            在此类型中声明的成员名称的集合。\r\n            \r\n","\r\n              Looks up a localized string similar to Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier or Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier to create identifier tokens..\r\n            ":"\r\n              查找类似于Microsoft.codeanalysis.csharp.syntaxfactory.distifier或Microsoft.codeanalysis.csharp.csharp.syntaxfactory.verbatimidentifier freate dissindifier freate dissinifier令牌的局部字符串。\r\n            \r\n","\r\n            The return value is not expected to be syntactically valid C#.\r\n            ":"\r\n            返回值预计不会是句法有效的c＃。\r\n            \r\n","Method '{0}' has a parameter modifier 'this' which is not on the first parameter":"方法'{0}'具有一个参数修饰符'this'，它不在第一个参数上\r\n","\r\n            Symbol that contains this set of variables. This is typically a method but may be a field\r\n            when analyzing a field initializer. The symbol may be null at the outermost scope when\r\n            analyzing an attribute argument value or a parameter default value.\r\n            ":"\r\n            包含这组变量的符号。这通常是一种方法，但可能是一个字段\r\n            分析字段初始化器时。当该符号在最外面的范围内无效\r\n            分析属性参数值或参数默认值。\r\n            \r\n","An __arglist expression may only appear inside of a call or new expression":"__arglist表达式只能出现在呼叫或新表达式中\r\n","\r\n            Test if the value set contains any values that satisfy the given relation with the given value.  Supported values for ":"\r\n            测试值集是否包含满足给定值的任何值。支持的值\r\n"," \r\n            If an assembly referenced by this module isn't exactly matching any reference given to compilation \r\n            the Assembly Manager might decide to use another reference if it matches except for version \r\n            (it unifies the version with the existing reference).  \r\n            ":" \r\n            如果该模块引用的组件不完全匹配任何对汇编的引用\r\n            汇编经理可能会决定使用另一个参考，如果匹配版本除外\r\n            （它将版本与现有引用统一）。\r\n            \r\n","\r\n            Computes the desired refkind of the argument.\r\n            Considers all the cases - where ref kinds are explicit, omitted, vararg cases.\r\n            ":"\r\n            计算该论点所需的参考文献。\r\n            考虑所有情况 - 涉及涉及种类的情况，省略了vararg案例。\r\n            \r\n","\r\n            Displays a value in the C# style.\r\n            ":"\r\n            在C＃样式中显示一个值。\r\n            \r\n","Non-null declaration syntax.":"非零声明语法。\r\n","\r\n              Looks up a localized string similar to nameof operator.\r\n            ":"\r\n              查找类似于操作员名称的本地化字符串。\r\n            \r\n","\r\n            C# language version 4.0.\r\n            ":"\r\n            C＃语言版本4.0。\r\n            \r\n","\r\n              Looks up a localized string similar to Ambiguous user defined conversions '{0}' and '{1}' when converting from '{2}' to '{3}'.\r\n            ":"\r\n              在从'{2}'转换为'{3}'时，查找类似于模棱两可的用户定义转换的局部字符串。\r\n            \r\n","\r\n             PermissionSetAttribute needs fixup when it contains an assignment to the 'File' property as a single named attribute argument.\r\n             Fixup performed is ported from SecurityAttributes::FixUpPermissionSetAttribute.\r\n             It involves following steps:\r\n              1) Verifying that the specified file name resolves to a valid path.\r\n              2) Reading the contents of the file into a byte array.\r\n              3) Convert each byte in the file content into two bytes containing hexadecimal characters.\r\n              4) Replacing the 'File = fileName' named argument with 'Hex = hexFileContent' argument, where hexFileContent is the converted output from step 3) above.\r\n            \r\n             Step 1) is performed in this method, i.e. during binding.\r\n             Remaining steps are performed during serialization as we want to avoid retaining the entire file contents throughout the binding/codegen pass.\r\n             See ":"\r\n             PermissionsetAttribute需求Fixup在将“文件”属性分配为单个命名属性参数时。\r\n             执行的FIXUP从SecurityAttributes :: FixUppermissionsetattribute移植。\r\n             它涉及以下步骤：\r\n              1）验证指定的文件名是否解析为有效路径。\r\n              2）将文件的内容读为字节数组。\r\n              3）将文件内容中的每个字节转换为包含十六进制字符的两个字节。\r\n              4）用“ hex = hexfilecontent”参数替换命名参数的“ file = filename”参数，其中hexfilecontent是上面的步骤3的转换输出。\r\n            \r\n             步骤1）在这种方法中，即在结合过程中执行。\r\n             剩余的步骤是在序列化过程中执行的，因为我们希望避免在整个绑定/代码GASE中保留整个文件内容。\r\n             看\r\n","Missing equals sign between attribute and attribute value.":"缺少属性和属性值之间的符号。\r\n","\r\n              Looks up a localized string similar to Keyword 'base' is not available in a static method.\r\n            ":"\r\n              在静态方法中查找类似于关键字“基础”的本地化字符串。\r\n            \r\n","\r\n            A value set factory for boolean values.\r\n            ":"\r\n            布尔值的价值设置工厂。\r\n            \r\n","\r\n              Looks up a localized string similar to Empty character literal.\r\n            ":"\r\n              查找类似于空字符的本地化字符串。\r\n            \r\n","\r\n            Patch refKinds for arguments that match 'In' or 'Ref' parameters to have effective RefKind.\r\n            For the purpose of further analysis we will mark the arguments as -\r\n            - In        if was originally passed as None\r\n            - StrictIn  if was originally passed as In\r\n            - Ref       if the argument is an interpolated string literal subject to an interpolated string handler conversion. No other types\r\n                        are patched here.\r\n            Here and in the layers after the lowering we only care about None/notNone differences for the arguments\r\n            Except for async stack spilling which needs to know whether arguments were originally passed as \"In\" and must obey \"no copying\" rule.\r\n            ":"\r\n            贴片refkinds用于具有有效参考的“在”或“ ref”参数中匹配的参数。\r\n            为了进一步分析，我们将这些论点标记为 - \r\n             -  if最初通过\r\n             - 严格if最初通过\r\n             - 参数如果参数是插值字符串，则由插值字符串处理程序转换。没有其他类型\r\n                        在这里修补。\r\n            在降低后的这里和层中，我们只关心任何参数的差异\r\n            除了异步堆栈溢出外，还需要知道是否最初以“在”中的“”中的“”来遵守“不复制”规则。\r\n            \r\n","\r\n            Method to early decode applied well-known attribute which can be queried by the binder.\r\n            This method is called during attribute binding after we have bound the attribute types for all attributes,\r\n            but haven't yet bound the attribute arguments/attribute constructor.\r\n            Early decoding certain well-known attributes enables the binder to use this decoded information on this symbol\r\n            when binding the attribute arguments/attribute constructor without causing attribute binding cycle.\r\n            ":"\r\n            早期解码的方法应用了众所周知的属性，该属性可以由粘合剂查询。\r\n            在我们绑定所有属性的属性类型之后，在属性绑定期间调用此方法\r\n            但是尚未绑定属性参数/属性构造函数。\r\n            早期解码某些众所周知的属性使粘合剂能够在此符号上使用此解码信息\r\n            当绑定属性参数/属性构造函数时，而不会引起属性结合周期。\r\n            \r\n","\r\n              Looks up a localized string similar to The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task<{0}>'..\r\n            ":"\r\n              查找类似于“等待”运算符的本地化字符串只能在异步方法中使用。考虑使用“ async”修饰符标记此方法，然后将其返回类型更改为“任务<{0}>'..\r\n            \r\n","\r\n            Might be a non-generic (qualified) type name or an expression.\r\n            ":"\r\n            可能是非生成（合格的）类型名称或表达式。\r\n            \r\n","\r\n            Type context for resolving generic type parameters.\r\n            ":"\r\n            解决通用类型参数的类型上下文。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot initialize a by-reference variable with a value.\r\n            ":"\r\n              查找类似于具有值的副参考变量的本地化字符串。\r\n            \r\n"," has failed.":" 失败了。\r\n","\r\n              Looks up a localized string similar to Warning is overriding an error.\r\n            ":"\r\n              查找类似于警告的本地化字符串正在覆盖错误。\r\n            \r\n","\r\n            \"Safe\" substring using start and end positions rather than start and length.\r\n            If things are out of bounds just returns the empty string. That should only\r\n            be used by clients to assist in error recovery.\r\n            ":"\r\n            使用启动和结束位置而不是开始和长度的“安全”子字符串。\r\n            如果情况超出界限，则只会返回空字符串。那应该只有\r\n            客户可以用来帮助恢复错误。\r\n            \r\n","\r\n            Variables that were initialized or written anywhere.\r\n            ":"\r\n            在任何地方初始化或编写的变量。\r\n            \r\n","\r\n              Looks up a localized string similar to Interop type '{0}' cannot be embedded because it is missing the required '{1}' attribute..\r\n            ":"\r\n              查找类似于Interop类型'{0}'的本地化字符串，因为它缺少所需的'{1}'属性。\r\n            \r\n","\r\n            Parameters of record primary constructors that were read anywhere.\r\n            ":"\r\n            记录主构造函数的参数，这些构造函数在任何地方都读取。\r\n            \r\n","True if \"this\" is not available due to the current method/property/field initializer being static.":"正确，如果“此”由于当前的方法/属性/字段初始化器是静态的，则“此”。\r\n","Duplicate user-defined conversion in type '{0}'":"在类型'{0}'中重复用户定义的转换\r\n","\r\n              Looks up a localized string similar to Async methods cannot have by-reference locals.\r\n            ":"\r\n              查找类似于异步方法的本地化字符串，无法具有重复的当地人。\r\n            \r\n",". \r\n            It is used by ":"。\r\n            它由\r\n","\r\n              Looks up a localized string similar to The name '{0}' does not exist in the current context (are you missing a reference to assembly '{1}'?).\r\n            ":"\r\n              在当前上下文中查找类似于名称“ {0}”的本地化字符串（您是否缺少对assembly'{1}'？）的引用。\r\n            \r\n","\r\n            Produce all implemented interfaces in topologically sorted order. We use\r\n            TypeSymbol.Interfaces as the source of edge data, which has had cycles and infinitely\r\n            long dependency cycles removed. Consequently, it is possible (and we do) use the\r\n            simplest version of Tarjan's topological sorting algorithm.\r\n        ":"\r\n            以拓扑排序的顺序生成所有实现的接口。我们用\r\n            TypeSymbol.Interfaces 作为边缘数据的来源，它有循环和无限\r\n            移除了长依赖周期。因此，有可能（而且我们确实）使用\r\n            Tarjan 的拓扑排序算法的最简单版本。\r\n        \r\n","Auto-implemented 'set' accessor '{0}' cannot be marked 'readonly'.":"自动实施的“集合”访问器'{0}'不能标记为“ ReadOnly”。\r\n","\r\n              Looks up a localized string similar to The FieldOffset attribute is not allowed on static or const fields.\r\n            ":"\r\n              在静态或const字段上不允许查找类似于fieldOffset属性的本地化字符串。\r\n            \r\n","\r\n            Gets the attribute class being applied.\r\n            ":"\r\n            获取要应用属性类。\r\n            \r\n","Class which represents the syntax node for Default expression.":"代表默认表达式语法节点的类。\r\n"," is not default, this is null.":" 不是默认，这是空的。\r\n","\r\n              Looks up a localized string similar to CLS-compliant field cannot be volatile.\r\n            ":"\r\n              查找类似于符合CLS的字段的本地化字符串不能挥发。\r\n            \r\n","\r\n            Checks that the Awaiter implements System.Runtime.CompilerServices.INotifyCompletion.\r\n            ":"\r\n            检查等待者是否实现了System.Runtime.compilerServices.InotifyCompletion。\r\n            \r\n","\r\n              Looks up a localized string similar to A constant value is expected.\r\n            ":"\r\n              查找与恒定值相似的本地化字符串。\r\n            \r\n","\r\n            The type to which we attempt to convert the input in order to match this pattern.\r\n            ":"\r\n            我们尝试转换输入以匹配此模式的类型。\r\n            \r\n","\r\n            Checks if 'symbol' is accessible from within 'within', which must be a NamedTypeSymbol\r\n            or an AssemblySymbol. \r\n            \r\n            Note that NamedTypeSymbol, if available, is the type that is associated with the binder \r\n            that found the 'symbol', not the inner-most type that contains the access to the\r\n            'symbol'.\r\n            \r\n            If 'symbol' is accessed off of an expression then 'throughTypeOpt' is the type of that\r\n            expression. This is needed to properly do protected access checks. Sets\r\n            \"failedThroughTypeCheck\" to true if this protected check failed.\r\n            \r\n            NOTE(cyrusn): I expect this function to be called a lot.  As such, i do not do any memory\r\n            allocations in the function itself (including not making any iterators).  This does mean\r\n            that certain helper functions that we'd like to call are inlined in this method to\r\n            prevent the overhead of returning collections or enumerators.  \r\n            ":"\r\n            检查是否可以从“内部”内部访问“符号”，这必须是名为tytypesymbol\r\n            或组件符号。\r\n            \r\n            请注意，命名为typesymbol（如果有）是与粘合剂关联的类型\r\n            找到“符号”，而不是包含对访问权限的内部类型\r\n            '象征'。\r\n            \r\n            如果从表达式中访问“符号”，则是“ prypeopt”的类型\r\n            表达。需要正确地进行受保护的访问检查。套\r\n            如果此受保护的检查失败，则“失败的typhypecheck”为true。\r\n            \r\n            注意（Cyrusn）：我希望此功能被称为很多。因此，我不做任何记忆\r\n            函数本身的分配（包括不制作任何迭代器）。这确实意味着\r\n            我们想调用的某些辅助功能是在此方法中绑架的\r\n            防止返回的收藏或枚举者的开销。\r\n            \r\n","Where to report diagnostics":"在哪里报告诊断\r\n","unchecked":"未选中\r\n","Class type declaration syntax.":"类类型声明语法。\r\n","An extern alias declaration must precede all other elements defined in the namespace":"外部别名声明必须先于名称空间中定义的所有其他元素\r\n","\r\n            Rewrite a decision dag, using a mapping function that rewrites one node at a time. That function\r\n            takes as its input the node to be rewritten and a function that returns the previously computed\r\n            rewritten node for successor nodes.\r\n            ":"\r\n            重写决策DAG，使用一次重写一个节点的映射函数。该功能\r\n            作为输入，将要重写的节点和返回先前计算的函数\r\n            重新编写后继节点的节点。\r\n            \r\n","\r\n              Looks up a localized string similar to Comparison to integral constant is useless; the constant is outside the range of type '{0}'.\r\n            ":"\r\n              查找与比较与积分常数相似的本地化字符串是没有用的。常数不在类型的“ {0}”范围之内。\r\n            \r\n","Keyword 'void' cannot be used in this context":"关键字“ void”在这种情况下不能使用\r\n","\r\n              Looks up a localized string similar to The type '{0}' has no constructors defined.\r\n            ":"\r\n              查找类似于“ {0}”类型的本地化字符串没有定义的构造函数。\r\n            \r\n","Stream is too long.":"流太长了。\r\n","\r\n              Looks up a localized string similar to Cannot declare a variable of static type '{0}'.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法声明静态类型的变量'{0}'。\r\n            \r\n","\r\n            The type is not annotated in a context where the nullable feature is not enabled.\r\n            Used for interoperation with existing pre-nullable code.\r\n            ":"\r\n            在未启用可确定功能的上下文中，该类型没有注释。\r\n            用于与现有的预购代码的互操作。\r\n            \r\n","Base class for type declaration syntax (class, struct, interface, record).":"类型声明语法的基类（类，结构，接口，记录）。\r\n","\r\n            Returns the list of custom modifiers, if any, associated with the return type.\r\n            ":"\r\n            返回与返回类型关联的自定义修饰符列表。\r\n            \r\n","\r\n            Lexer entry point for LexMode.XmlCDataSectionText\r\n            ":"\r\n            lexmode.xmlcdataSectionText的Lexer入口点\r\n            \r\n"," which was introduced in .NET Framework 4.5\r\n            ":"在.NET框架4.5中引入\r\n            \r\n","\r\n            This wrinkle is specifically not publicly exposed.\r\n            ":"\r\n            这种皱纹特别没有公开暴露。\r\n            \r\n","async streams":"异步流\r\n","\r\n              Looks up a localized string similar to Tuple element names are not permitted on the left of a deconstruction..\r\n            ":"\r\n              在解构的左侧查找类似于元组元素名称的本地化字符串。\r\n            \r\n","Creates a new EventDeclarationSyntax instance.":"创建一个新的event -declarationsyntax实例。\r\n","\r\n              Looks up a localized string similar to '{0}': static classes cannot implement interfaces.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串：静态类无法实现接口。\r\n            \r\n","Cannot specify /main if building a module or library":"如果构建模块或库，则无法指定 /主\r\n","\r\n            Returns true if the overall nullable context is enabled for constructors and initializers.\r\n            ":"\r\n            如果为构造函数和初始化器启用了整体可取消上下文，则返回true。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid value for argument to '{0}' attribute.\r\n            ":"\r\n              查找类似于“ {0}”属性的参数的本地化字符串类似于无效的值。\r\n            \r\n","Gets the constraint clause list.":"获取约束子句列表。\r\n","Optional type arguments.":"可选类型参数。\r\n","\r\n            Calculates all functions which directly or indirectly capture a scope's variables.\r\n            ":"计算直接或间接捕获示波器变量的所有功能。\r\n            \r\n","The operator '{0}' requires a matching operator '{1}' to also be defined":"运算符'{0}'需要一个匹配的操作员'{1}'才能定义\r\n","\r\n            This is the FULL namespace name (e.g., \"System.Collections.Generic\")\r\n            of the type that couldn't be found.\r\n            ":"\r\n            这是完整的名称名称（例如，“ system.collections.generic”）\r\n            找不到的类型。\r\n            \r\n","A trivia node with the whitespace text":"带有空格文本的琐事节点\r\n","Represent the exclusive end index of the range.":"代表该范围的独家端索引。\r\n","A non-null implementable member on an interface type.":"接口类型上的不可实现的成员。\r\n","\r\n              Looks up a localized string similar to Predefined type '{0}' must be a struct..\r\n            ":"\r\n              查找类似于预定义的类型“ {0}”的本地化字符串必须是一个结构。\r\n            \r\n","\r\n              Looks up a localized string similar to The Conditional attribute is not valid on interface members.\r\n            ":"\r\n              查找类似于条件属性的本地化字符串在接口成员上无效。\r\n            \r\n","\r\n            The class to represent all methods imported from a PE/module.\r\n            ":"\r\n            代表从PE/模块导入的所有方法的类。\r\n            \r\n","\r\n            For every label visited so far, this dictionary maps to a list of all scopes either visited so far, or currently being visited,\r\n            that are both after the label, and are on the same level of the scope tree as the label.\r\n            ":"\r\n            对于到目前为止访问的每个标签，此字典地图符合到目前为止访问或目前正在访问的所有范围的列表，\r\n            两者都在标签之后，并且与标签相同的范围。\r\n            \r\n","CLS-compliant interfaces must have only CLS-compliant members":"符合CLS的接口必须只有符合CLS的成员\r\n",", is to start with an empty\r\n            decision tree, and for each case we visit the decision tree to see if the case is subsumed. If it\r\n            is, we report an error. If it is not subsumed and there is no guard expression, we then add it to\r\n            the decision tree.\r\n            ":"，是从空的\r\n            决策树，对于每种情况，我们都会访问决策树，以查看该案件是否包含。如果它\r\n            是，我们报告一个错误。如果它不包含并且没有守卫表达式，我们然后将其添加到\r\n            决策树。\r\n            \r\n","\r\n            visits the bound tree and translates information from the bound tree about\r\n            variable scope, declared variables, and variable captures into the resulting\r\n            ":"\r\n            访问绑定的树，并转换有关界树的信息\r\n            可变范围，声明变量和可变捕获\r\n            \r\n","Gets the operator token.":"获取操作员令牌。\r\n","\r\n            The closure doesn't declare any variables. \r\n            Display class is a singleton and may be shared with other top-level methods.\r\n            ":"\r\n            关闭未声明任何变量。\r\n            显示类是单身人士，可以与其他顶级方法共享。\r\n            \r\n","\r\n              Looks up a localized string similar to Attribute '{0}' is ignored when public signing is specified..\r\n            ":"\r\n              指定公共签名时，查找类似于属性'{0}'的局部字符串。\r\n            \r\n","\r\n            Return true if the fully qualified name of the type's containing symbol\r\n            matches the given name. This method avoids string concatenations\r\n            in the common case where the type is a top-level type.\r\n            ":"\r\n            如果类型的包含符号的完全合格名称，请返回true\r\n            匹配给定名称。此方法避免了字符串串联\r\n            在常见的情况下，该类型是顶级类型。\r\n            \r\n","Interface '{0}' has an invalid source interface which is required to embed event '{1}'.":"接口'{0}'具有无效的源接口，该接口嵌入事件'{1}'。\r\n","True if zero width tokens should be included, false by\r\n            default.":"如果应包括零宽度令牌，则为false\r\n            默认。\r\n","Feature '{0}' is not available in C# 5. Please use language version {1} or greater.":"C＃5中不可用功能'{0}'使用。请使用语言版本{1}或更大。\r\n","\r\n            It would be more in line with our usual pattern to rewrite using to try-finally\r\n            in the ControlFlowRewriter, but if we don't do it here the BoundMultipleLocalDeclarations\r\n            will be rewritten into a form that makes them harder to separate.\r\n            ":"\r\n            它将更符合我们通常的模式，可以重写用于尝试的方式\r\n            在ControlflowRetriter中，但是如果我们不这样做\r\n            将被重写为一种使它们更难分离的形式。\r\n            \r\n","\r\n            Returns true if this type is known to be a reference type. It is never the case that\r\n            IsReferenceType and IsValueType both return true. However, for an unconstrained type\r\n            parameter, IsReferenceType and IsValueType will both return false.\r\n            ":"\r\n            如果已知该类型是参考类型，则返回true。从来没有这样\r\n            ISREFERENCETYPE和ISVALUETYPE都返回true。但是，对于不受约束的类型\r\n            参数，IsReferenceType和ISVALUETYPE都将返回false。\r\n            \r\n","\r\n            Return the extension method in reduced form if the extension method\r\n            is applicable, and satisfies type parameter constraints, based on the\r\n            \"this\" argument type. Otherwise, returns null.\r\n            ":"\r\n            如果扩展方法，以简化形式返回扩展方法\r\n            适用，并根据\r\n            “此”参数类型。否则，返回null。\r\n            \r\n","A 'using namespace' directive can only be applied to namespaces; '{0}' is a type not a namespace. Consider a 'using static' directive instead":"“使用名称空间”指令只能应用于名称空间； '{0}'是类型而不是名称空间。考虑一个“使用静态”指令\r\n","\r\n            A list of modules the assembly consists of. \r\n            The first (index=0) module is a SourceModuleSymbol, which is a primary module, the rest are net-modules.\r\n            ":"\r\n            组件包含的模块列表。\r\n            第一个（索引= 0）模块是一个sourcemodulesymbol，它是主模块，其余的是净模块。\r\n            \r\n","Creates a new ElseDirectiveTriviaSyntax instance.":"创建一个新的ELSEDIRECTIVIVIASYNTAX实例。\r\n","\r\n            Returns a C# string literal with the given value.\r\n            ":"\r\n            返回带有给定值的C＃字符串文字。\r\n            \r\n","\r\n            An analysis that computes all cases where the address is taken of a variable that has not yet been assigned\r\n            ":"\r\n            计算地址取自尚未分配的变量的所有情况的分析\r\n            \r\n","Expression does not have a name.":"表达没有名字。\r\n","\r\n            A helper method for ReferenceManager to set the system assembly, which provides primitive \r\n            types like Object, String, etc., e.g. mscorlib.dll. \r\n            ":"\r\n            引用meanager设置系统组件的辅助方法，该组件提供原始\r\n            诸如对象，字符串等的类型，例如mscorlib.dll。\r\n            \r\n",".  Each frame is given a single field for each captured\r\n            variable in the corresponding scope.  These are maintained in ":"。为每个捕获的每个帧都有一个字段\r\n            相应范围中的变量。这些被维持在\r\n","\r\n              Looks up a localized string similar to SyntaxTreeSemanticModel must be provided in order to provide minimal type qualification..\r\n            ":"\r\n              必须提供类似于语法的本地化字符串，以提供最小的类型资格。\r\n            \r\n","\r\n            Keep in sync with CSharpSemanticModel.GetSpeculativelyBoundExpression.\r\n            ":"\r\n            与csharpsemanticmodel保持同步。\r\n            \r\n","\r\n            Does not imply that this compilation allows unsafe regions (could be in an error recovery scenario).\r\n            To determine that, check this.Compilation.Options.AllowUnsafe.\r\n            ":"\r\n            并不意味着此汇编允许不安全的区域（可能处于错误恢复方案）。\r\n            要确定这一点，请检查this.compilation.options.allowunsafe。\r\n            \r\n","Cannot convert {0} to type '{1}' because the return type does not match the delegate return type":"无法将{0}转换为type'{1}'，因为返回类型与委托返回类型不匹配\r\n","Creates a new XmlCrefAttributeSyntax instance.":"创建一个新的XMLCRefattributesyntax实例。\r\n","\r\n            Generate implementation-specific state machine initialization for the kickoff method body.\r\n            ":"\r\n            生成针对开球方法主体的特定实现状态机初始化。\r\n            \r\n"," doesn't contain a wildcard.\r\n            \r\n            For example, \r\n              AssemblyVersion(\"1.2.*\") is represented as 1.2.65535.65535,\r\n              AssemblyVersion(\"1.2.3.*\") is represented as 1.2.3.65535.\r\n            ":" 不包含通配符。\r\n            \r\n            例如，\r\n              汇编（“ 1.2。*”）表示为1.2.65535.65535，\r\n              汇编（“ 1.2.3。*”）表示为1.2.3.65535。\r\n            \r\n","\r\n            A collection of the local variables for which a value assigned inside the region may be used outside the region.\r\n            Note that every reachable assignment to a ref or out variable will be included in the results.\r\n            ":"\r\n            可以在该区域外使用的局部变量集合。\r\n            请注意，结果将包含在REF或OUT变量的每个可触及分配。\r\n            \r\n",". We assume that the dependencies of the baseline metadata are \r\n            the same as the dependencies of the current compilation. This is not exactly true when the dependencies use \r\n            time-based versioning pattern, e.g. AssemblyVersion(\"1.0.*\"). In that case we assume only the version\r\n            changed and nothing else.\r\n            \r\n            Each AssemblyRef is matched against the assembly identities using an exact equality comparison modulo version. \r\n            AssemblyRef with lower version in metadata is matched to a PE assembly symbol with the higher version \r\n            (provided that the assembly name, culture, PKT and flags are the same) if there is no symbol with the exactly matching version. \r\n            If there are multiple symbols with higher versions selects the one with the minimal version among them.\r\n            \r\n            Matching to a higher version is necessary to support EnC for projects whose P2P dependencies use time-based versioning pattern. \r\n            The versions of the dependent projects seen from the IDE will be higher than \r\n            the one written in the metadata at the time their respective baselines are built.\r\n            \r\n            No other unification or further resolution is performed.\r\n            ":"。我们假设基线元数据的依赖关系是\r\n            与当前汇编的依赖关系相同。当依赖项使用时，这并不完全正确\r\n            基于时间的版本控制模式，例如汇编（“ 1.0。*”）。在这种情况下，我们仅假设版本\r\n            改变了，别无其他。\r\n            \r\n            使用精确的平等比较模量版本，将每个汇编Ref与汇编身份匹配。\r\n            元数据中具有较低版本的issablyRef匹配具有更高版本的PE组装符号\r\n            （前提是汇编名称，文化，PKT和标志是相同的），如果没有精确匹配的版本的符号。\r\n            如果有较高版本的多个符号，则选择其中一个具有最小版本的符号。\r\n            \r\n            与更高版本的匹配是为了支持P2P依赖性使用基于时间的版本模式的项目的ENC。\r\n            从IDE看到的依赖项目的版本将高于\r\n            它们各自的基线建造时用元数据写的那本。\r\n            \r\n            没有执行其他统一或进一步解决。\r\n            \r\n","\r\n            A convenience method that determines a position from a node.  If the node is missing,\r\n            then its position will be adjusted using CheckAndAdjustPosition.\r\n            ":"\r\n            一种便利方法，可以从节点确定位置。如果缺少节点，\r\n            然后，将使用CheckAndJustPosition调整其位置。\r\n            \r\n","An expression is too long or complex to compile":"表达式太长或复杂而无法编译\r\n","\r\n            Add the type to the builder and then recurse on its interfaces.\r\n            ":"\r\n            将类型添加到构建器中，然后在其界面上重复。\r\n            \r\n","\r\n            Binder that owns the scope for the local, the one that returns it in its ":"\r\n            拥有本地范围的活页夹，将其返回其范围\r\n","\r\n              Looks up a localized string similar to The 'await' operator cannot be used in a static script variable initializer..\r\n            ":"\r\n              查找类似于“等待”运算符的本地化字符串，不能在静态脚本变量初始化器中使用。\r\n            \r\n","\r\n              Looks up a localized string similar to The return expression must be of type '{0}' because this method returns by reference.\r\n            ":"\r\n              查找类似于返回表达式的本地化字符串必须为“ {0}”类型，因为此方法通过参考返回。\r\n            \r\n","\r\n            Adjust unresolved instances of ":"\r\n            调整未解决的实例\r\n","\r\n            This overload exists for callers who already have a node in hand \r\n            and don't want to search through the tree.\r\n            ":"\r\n            对于已经有一个节点的呼叫者而存在此超负荷\r\n            并且不想搜索树。\r\n            \r\n","\r\n              Looks up a localized string similar to XML comment has a paramref tag, but there is no parameter by that name.\r\n            ":"\r\n              查找类似于XML注释的本地化字符串具有Paramref标签，但是该名称没有参数。\r\n            \r\n","\r\n            Within ":"\r\n            内\r\n","\r\n             The LocalBinderFactory is used to build up the map of all Binders within a method body, and the associated\r\n             CSharpSyntaxNode. To do so it traverses all the statements, handling blocks and other\r\n             statements that create scopes. For efficiency reasons, it does not traverse into all\r\n             expressions. This means that blocks within lambdas and queries are not created. \r\n             Blocks within lambdas are bound by their own LocalBinderFactory when they are \r\n             analyzed.\r\n            \r\n             For reasons of lifetime management, this type is distinct from the BinderFactory \r\n             which also creates a map from CSharpSyntaxNode to Binder. That type owns it's binders\r\n             and that type's lifetime is that of the compilation. Therefore we do not store\r\n             binders local to method bodies in that type's cache. \r\n             ":"\r\n             LocalBinderFactory用于建立方法主体中所有粘合剂的地图，并相关\r\n             csharpsyntaxnode。为此，它遍历了所有陈述，处理块和其他陈述\r\n             创建范围的语句。出于效率原因，它并没有遍历所有\r\n             表达。这意味着未创建lambdas和查询中的块。\r\n             Lambdas中的块被他们自己的LocalbinderFactory约束\r\n             分析。\r\n            \r\n             出于终生管理的原因，这种类型与绑定性不同\r\n             它还创建了从csharpsyntaxnode到粘合剂的地图。该类型拥有它的粘合剂\r\n             而这种类型的寿命就是汇编。因此我们不存储\r\n             该类型的缓存中的方法物体本地的BINDERS。\r\n             \r\n","Called when the visitor visits a AnonymousObjectCreationExpressionSyntax node.":"当访问者访问AnonymobjectCreationexpressyntax节点时，请致电。\r\n","\r\n            true if the current token can be the first token of a typed identifier (a type name followed by an identifier),\r\n            false if it definitely can't be,\r\n            null if we need to scan further to find out.\r\n            ":"\r\n            是的，如果当前令牌可以是打字标识符的第一个令牌（类型名称后跟标识符），则\r\n            假，如果绝对不能，\r\n            无效，如果我们需要进一步扫描以找出答案。\r\n            \r\n","The text of the compilation unit.":"汇编单元的文本。\r\n","Field-targeted attributes on auto-properties are not supported in this version of the language.":"此版本的语言中不支持自动专业的现场定位属性。\r\n","The closing quote of the interpolated string.":"插值字符串的关闭报价。\r\n","Type byte, sbyte, short, ushort, int, uint, long, or ulong expected":"类型字节，sbyte，short，ushort，int，uint，long或ulong预期\r\n","\r\n            Creates a new token with the specified old trivia replaced with computed new trivia.\r\n            ":"\r\n            创建一个新的令牌，指定的旧琐事被计算出的新琐事代替。\r\n            \r\n","The default value specified will have no effect because it applies to a member that is used in contexts that do not allow optional arguments":"指定的默认值无效，因为它适用于不允许可选参数的上下文中使用的成员\r\n","\r\n            A region analysis walker that records declared variables.\r\n            ":"\r\n            记录变量的区域分析步行者。\r\n            \r\n","Type of '{0}' is not CLS-compliant":"'{0}'类型不符合Cls\r\n","\r\n            True if the property itself is excluded from code covarage instrumentation.\r\n            True for source properties marked with ":"\r\n            如果将属性本身排除在CORAVARAGE仪器中，则为是真的。\r\n            对于标记的源属性为true\r\n","\r\n            A synthesized Finally method containing finalization code for a resumable try statement.\r\n            Finalization code for such try may run when:\r\n            1) control flow goes out of try scope by dropping through\r\n            2) control flow goes out of try scope by conditionally or unconditionally branching outside of one ore more try/finally frames.\r\n            3) enumerator is disposed by the owner.\r\n            4) enumerator is being disposed after an exception.\r\n            \r\n            It is easier to manage partial or complete finalization when every finally is factored out as a separate method. \r\n            \r\n            NOTE: Finally is a private void nonvirtual instance method with no parameters. \r\n                  It is a valid JIT inlining target as long as JIT may consider inlining profitable.\r\n            ":"\r\n            合成的最终方法，其中包含可重新启用的尝试语句的终点代码。\r\n            当以下方式时，可能会运行此类尝试的最终化代码。\r\n            1）控制流程通过掉落而脱离尝试范围\r\n            2）控制流程通过有条件或无条件在一个矿石外部进行更多的尝试/最后框架，从而摆脱了试验范围。\r\n            3）枚举者由所有者处置。\r\n            4）例外后正在处置枚举者。\r\n            \r\n            当每个方法最终都被视为一种单独的方法时，管理部分或完整的最终确定更容易。\r\n            \r\n            注意：最后是一个没有参数的私有void非虚拟实例方法。\r\n                  只要JIT可能会考虑将盈利性融为一体，这是一个有效的JIT，将目标夹住。\r\n            \r\n","An expression tree may not contain a discard.":"表达树可能不包含丢弃。\r\n","\r\n            Lower \"using [await] (ResourceType resource = expression) statement\" to a try-finally block.\r\n            ":"\r\n            较低的“使用[等待]（ResourceType Resource =表达式）语句”到一个尝试块。\r\n            \r\n","Evaluation of the decimal constant expression failed":"小数恒定表达式的评估失败\r\n","\r\n              Looks up a localized string similar to Constraints are not allowed on non-generic declarations.\r\n            ":"\r\n              在非类别声明中不允许查找类似于约束的本地化字符串。\r\n            \r\n","\r\n            This method is essentially the same as ScanIdentifier_SlowPath,\r\n            except that it can handle XML entities.  Since ScanIdentifier\r\n            is hot code and since this method does extra work, it seem\r\n            worthwhile to separate it from the common case.\r\n            ":"\r\n            此方法与ScanIdentifier_slowpath基本相同，\r\n            除了它可以处理XML实体。自扫描仪以来\r\n            是热代码，由于此方法确实有效，因此似乎\r\n            值得将其与常见情况分开。\r\n            \r\n","#warning directive":"#Warning指令\r\n","Parameter must have a non-null value when exiting in some condition.":"在某种情况下退出时，参数必须具有非零值。\r\n","\r\n            Gets the attribute class being applied as an ":"\r\n            将属性类应用于\r\n","\r\n            Certain members from the underlying types are not exposed from the native integer types:\r\n              constructors other than the default parameterless constructor are not supported;\r\n              operators are handled explicitly as built-in operators and conversions;\r\n              0 should be used instead of Zero;\r\n              sizeof() should be used instead of Size;\r\n              + and - should be used instead of Add() and Subtract();\r\n              ToInt32(), ToInt64(), ToPointer() should be used from underlying types only.\r\n            The remaining members are exposed on the native integer types with appropriate\r\n            substitution of underlying types in the signatures.\r\n            Specifically, we expose public, non-generic instance and static methods and properties\r\n            other than those named above.\r\n            ":"\r\n            来自基础类型的某些成员并未暴露于本机整数类型：\r\n              不支持默认无参数构造函数以外的构造函数；\r\n              操作员被明确处理为内置操作员和转换；\r\n              0应该使用代替零；\r\n              应该使用sizeof（）代替大小；\r\n              +和 - 应用代替add（）和subtract（）;\r\n              toint32（），toint64（），topointer（）应仅来自基础类型。\r\n            其余成员以适当的方式暴露在本机整数类型上\r\n            在签名中替换基础类型。\r\n            具体而言，我们公开公共，非传播实例和静态方法和属性\r\n            除了上面命名的那些。\r\n            \r\n","\r\n            Generates the `ValueTask IAsyncDisposable.DisposeAsync()` method.\r\n            The DisposeAsync method should not be called from states -1 (running) or 0-and-up (awaits).\r\n            ":"\r\n            生成`valueTask iasyncdisposable.dispoesync（）`方法。\r\n            不应从状态-1（运行）或0及以上（等待）调用disposeasync方法。\r\n            \r\n","Node to search in the subtree rooted at root node":"节点要在根节点的子树中搜索\r\n","Member must have a non-null value when exiting in some condition.":"在某种情况下退出时，成员必须具有非零值。\r\n"," \r\n            If true then the nodes are equivalent if the contained nodes and tokens declaring\r\n            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\r\n            or initializer expressions, otherwise all nodes and tokens must be equivalent. \r\n            ":" \r\n            如果为true，则节点是等效的，如果包含的节点和代币声明\r\n            元数据可见的符号信息是等效的，忽略了方法内部节点的任何差异\r\n            或初始器表达式，否则所有节点和令牌都必须等效。\r\n            \r\n"," that contains path, line and column information.":" 其中包含路径，行和列信息。\r\n","Invalid option '{0}'; Resource visibility must be either 'public' or 'private'":"无效选项'{0}';资源可见性必须是“公共”或“私人”\r\n","XML comment has a typeparam tag, but there is no type parameter by that name":"XML评论具有Typeparam标签，但没有该名称的类型参数\r\n","\r\n             The CLR will only look for an implementation of an interface method in a type that\r\n               1) declares that it implements that interface; or\r\n               2) is a base class of a type that declares that it implements the interface but not\r\n                    a subtype of a class that declares that it implements the interface.\r\n            \r\n             For example,\r\n            \r\n               interface I\r\n               class A\r\n               class B : A, I\r\n               class C : B\r\n               class D : C, I\r\n            \r\n             Suppose the runtime is looking for D's implementation of a member of I.  It will look in\r\n             D because of (1), will not look in C, will look in B because of (1), and will look in A\r\n             because of (2).\r\n            \r\n             The key point is that it does not look in C, which C# *does*.\r\n             ":"\r\n             CLR只会在类型中寻找接口方法的实现\r\n               1）声明它实现了该接口；或者\r\n               2）是一种声明其实现接口但未实现的类型的基类\r\n                    宣布其实现接口的类的子类型。\r\n            \r\n             例如，\r\n            \r\n               接口i\r\n               A类\r\n               B级：A，我\r\n               C级：B\r\n               D级：C，我\r\n            \r\n             假设运行时正在寻找I的成员的D\r\n             d由于（1），不会在C中看，因为（1）会在B中看，并且会在A中看\r\n             因为（2）。\r\n            \r\n             关键点是它不在c中，c＃ *do do *。\r\n             \r\n","\r\n            Returns a new PointerTypeSymbol representing a pointer type tied to a type in this Compilation.\r\n            ":"\r\n            返回一个新的pointertypesymbol，代表与此汇编中类型相关的指针类型。\r\n            \r\n","The text of the whitespace. Any text can be specified here, however only specific\r\n            whitespace characters are recognized by the parser.":"空格的文字。任何文本都可以在此处指定，但是只有特定的\r\n            空格字符被解析器认可。\r\n","\r\n              Looks up a localized string similar to Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Consider explicitly specifying the type of the range variable '{2}'..\r\n            ":"查找类似于类似的本地化字符串，无法找到源类型“ {0}”的查询模式的实现。 '{1}'找不到。考虑明确指定范围变量的类型'{2}'..\r\n            \r\n","XML comment has a param tag, but there is no parameter by that name":"XML评论具有param标签，但没有该名称的参数\r\n","Creates a new StackAllocArrayCreationExpressionSyntax instance.":"创建一个新的stackallocarrowocarayCreationexpressynntax实例。\r\n","\r\n              Looks up a localized string similar to Type and identifier are both required in a foreach statement.\r\n            ":"\r\n              在foreach语句中查找类似于类型的本地化字符串和标识符。\r\n            \r\n",") that moves upward through the ":"）向上移动\r\n","Cannot use local '{0}' in this context because it may expose referenced variables outside of their declaration scope":"在此上下文中不能使用本地'{0}'，因为它可能会在其声明范围之外暴露引用变量\r\n","Cannot specify 'readonly' modifiers on both accessors of property or indexer '{0}'. Instead, put a 'readonly' modifier on the property itself.":"无法在属性或索引器'{0}'的登录器上指定“读取”修饰符。相反，请在属性本身上放置一个“读取”修饰符。\r\n","A readonly field cannot be returned by writable reference":"可读字段不能通过可写的参考返回\r\n","The suppression operator is not allowed in this context":"在这种情况下不允许抑制操作员\r\n","\r\n            The list of all interfaces of which this type is a declared subtype, excluding this type\r\n            itself. This includes all declared base interfaces, all declared base interfaces of base\r\n            types, and all declared base interfaces of those results (recursively).  Each result\r\n            appears exactly once in the list. This list is topologically sorted by the inheritance\r\n            relationship: if interface type A extends interface type B, then A precedes B in the\r\n            list. This is not quite the same as \"all interfaces of which this type is a proper\r\n            subtype\" because it does not take into account variance: AllInterfaces for\r\n            IEnumerable<string> will not include IEnumerable<object>\r\n            ":"\r\n            此类型为已声明子类型的所有接口的列表，不包括此类型\r\n            本身。这包括所有声明的基接口，所有声明的基基接口\r\n            类型，以及这些结果的所有声明的基接口（递归）。每个结果\r\n            在列表中只出现一次。此列表按继承拓扑排序\r\n            关系：如果接口类型 A 扩展接口类型 B，则 A 在 B 之前\r\n            列表。这与“此类型为正确的所有接口”并不完全相同\r\n            子类型”，因为它没有考虑方差：AllInterfaces for\r\n            IEnumerable<string> 将不包括 IEnumerable<object>\r\n            \r\n"," Containing symbol if available, null otherwise ":" 包含符号如果可用，则否则为空\r\n","\r\n              Looks up a localized string similar to 'await' cannot be used in an expression containing a ref conditional operator.\r\n            ":"\r\n              查找类似于“等待”的局部字符串，不能在包含REF条件操作员的表达式中使用。\r\n            \r\n","\r\n            SZArray is an array type encoded in metadata with ELEMENT_TYPE_SZARRAY (always single-dim array with 0 lower bound).\r\n            Non-SZArray type is ecoded in metadata with ELEMENT_TYPE_ARRAY and with optional sizes and lower bounds. Even though \r\n            non-SZArray can also be a single-dim array with 0 lower bound, the encoding of these types in metadata is distinct.\r\n            ":"\r\n            szarray是一种数组类型，用element_type_szarray在元数据中编码（始终具有单个dim数组，带有0下限）。\r\n            非szarray类型用element_type_array在元数据中生态编码，并具有可选的大小和下限。虽然\r\n            非szarray也可以是具有0下限的单DIM阵列，元数据中这些类型的编码是不同的。\r\n            \r\n","\r\n              Looks up a localized string similar to Argument of type '{0}' cannot be used as an output of type '{1}' for parameter '{2}' in '{3}' due to differences in the nullability of reference types..\r\n            ":"查找类似于类型'{0}'参数的本地化字符串，不能用作'{3}'in'{3}'的类型'{1}'的输出，因为参考类型的无效性差异..\r\n            \r\n","\r\n              Looks up a localized string similar to Unable to include XML fragment '{1}' of file '{0}' -- {2}.\r\n            ":"\r\n              查找类似于无法包含XML片段'{1}'的局部字符串'{0}' -  {2}。\r\n            \r\n","Copyright (C) Microsoft Corporation. All rights reserved.":"版权（C）Microsoft Corporation。版权所有。\r\n"," that represents\r\n            the inferred signature of a lambda expression or method group.\r\n            The actual signature is calculated on demand in ":" 代表\r\n            Lambda表达式或方法组的推断签名。\r\n            按需计算实际签名\r\n"," for nullable expressions that are neither always null or never null, and functionally equivalent parts for other cases.\r\n            ":" 对于既不始终为null或永不零的无效的表达式，并且在功能上等于其他情况。\r\n            \r\n","\r\n              Looks up a localized string similar to Inconsistent accessibility: parameter type '{1}' is less accessible than operator '{0}'.\r\n            ":"\r\n              查找类似于不一致的可访问性的本地化字符串：参数类型'{1}''不如操作符'{0}'易于访问。\r\n            \r\n","\r\n              Looks up a localized string similar to Missing partial modifier on declaration of type '{0}'; another partial declaration of this type exists.\r\n            ":"\r\n              查找类似于“ {0}'”类型声明时缺少部分修饰符的本地化字符串;存在此类类型的另一部分声明。\r\n            \r\n","'{0}' is not a valid warning number":"'{0}'不是有效的警告号码\r\n","\r\n              Looks up a localized string similar to '{0}' has no base class and cannot call a base constructor.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串，没有基类，也无法调用基本构造函数。\r\n            \r\n","\r\n            A binder that knows no symbols and will not delegate further.\r\n            ":"\r\n            一个不知道符号并且不会进一步委派的活页夹。\r\n            \r\n","\r\n            For source symbols may be called while calculating\r\n            ":"\r\n            对于源符号，可以在计算时调用\r\n            \r\n","\r\n            For scenarios such as overriding with differing ref kinds (such as out vs in or ref)\r\n            we need to compare function pointer parameters assuming that Ref matches RefReadonly/In\r\n            and Out. For that reason, we must also ensure that GetHashCode returns equal hashcodes\r\n            for types that only differ by the type of ref they have.\r\n            ":"\r\n            对于诸如不同涉及的裁判类型（例如Out vs in cor in cor in of或ref）之类的场景\r\n            我们需要比较函数指针参数，假设参考匹配refreadonly/in\r\n            和出去。因此，我们还必须确保gethashcode返回相等的哈希尺\r\n            对于仅与裁判类型不同的类型。\r\n            \r\n","\r\n            An elastic trivia with kind WhitespaceTrivia containing a single space character. Elastic trivia are used to\r\n            denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.\r\n            ":"\r\n            具有单个空间特征的弹性琐事。弹性琐事习惯\r\n            表示未通过解析源文本产生的琐事，通常在格式期间没有保留。\r\n            \r\n","Constructor '{0}' cannot call itself through another constructor":"构造函数'{0}'无法通过另一个构造函数自称\r\n","\r\n            [NullableContext(1)]\r\n            ":"\r\n            [nullableContext（1）]\r\n            \r\n","A new list with the tokens inserted.":"带有令牌的新列表。\r\n","\r\n            The member considered during overload resolution.\r\n            ":"\r\n            成员在超负荷分辨率期间考虑。\r\n            \r\n","\r\n            Specifies the syntactic construct that a user defined variable comes from.\r\n            ":"\r\n            指定用户定义变量来自的句法结构。\r\n            \r\n","Member '{0}' overrides obsolete member '{1}'. Add the Obsolete attribute to '{0}'.":"成员'{0}'覆盖过时的成员'{1}'。将过时的属性添加到'{0}'中。\r\n","One of the two declarations":"两个声明之一\r\n","\r\n            Checks if the method has an entry point compatible signature, i.e.\r\n            - the return type is either void, int, or returns a ":"\r\n            检查该方法是否具有入口点兼容签名，即\r\n             - 返回类型是无效，int或返回的\r\n","Fixed size buffer fields may only be members of structs":"固定尺寸缓冲区字段可能仅是结构的成员\r\n","\r\n            TypeSymbolExtensions.GetNonErrorGuess is a more discoverable version of this functionality.\r\n            However, the real definition is in this class so that it can access the private field \r\n            nonErrorGuessType.\r\n            ":"\r\n            typeymbolextensions.getNonerRorguess是此功能的更可发现的版本。\r\n            但是，真正的定义是在此类中，以便它可以访问私有字段\r\n            nonErrorguessType。\r\n            \r\n","\r\n              Looks up a localized string similar to Do not use '_' to refer to the type in an is-type expression..\r\n            ":"\r\n              查找类似于不使用'_'的本地化字符串来参考IS-Type表达式中的类型。\r\n            \r\n","Options to control behavior.":"控制行为的选项。\r\n","Method name expected":"预期的方法名称\r\n","Creates a new RecursivePatternSyntax instance.":"创建一个新的recursivePatternsyntax实例。\r\n","A syntax kind value for a token. These have the suffix Token or Keyword.":"令牌的语法类值。这些具有后缀令牌或关键字。\r\n","Class which represents the syntax node for member access expression.":"代表成员访问表达式语法节点的类。\r\n","\r\n              Looks up a localized string similar to Invalid search path '{0}' specified in '{1}' -- '{2}'.\r\n            ":"\r\n              查找类似于“ {1}”  - '{2}'中指定的无效搜索路径'{0}'的本地化字符串。\r\n            \r\n","The type with type parameters replaced with the type arguments.":"带有类型参数的类型替换为类型参数。\r\n","A diagnostic updated to reflect the options, or null if it has been filtered out":"诊断更新以反映选项，或者如果已被过滤出来的null\r\n","\r\n            Symbol for the type, or MissingMetadataSymbol if the type isn't found.\r\n            ":"\r\n            如果找不到类型，则类型或丢失的构成符号。\r\n            \r\n","Method '{0}' lacks `[DoesNotReturn]` annotation to match implemented or overridden member.":"方法'{0}'缺乏`[do notreturn]`符合实现或覆盖成员的注释。\r\n","\r\n              Looks up a localized string similar to The type or namespace name '{0}' does not exist in the namespace '{1}' (are you missing an assembly reference?).\r\n            ":"\r\n              查找类似于类型或名称空间名称'{0}'的本地化字符串，在命名空间'{1}'中不存在（您是否缺少汇编引用？）。\r\n            \r\n","The value of the xml text attribute.":"XML文本属性的值。\r\n","\r\n              Looks up a localized string similar to The RequiredAttribute attribute is not permitted on C# types.\r\n            ":"\r\n              在C＃类型上不允许查找类似于必需的属性属性的本地化字符串。\r\n            \r\n","\r\n            This type is responsible for adding debugging sequence points for the executable code.\r\n            It can be combined with other ":"\r\n            此类型负责为可执行代码添加调试序列点。\r\n            它可以与其他\r\n","Class which represents the syntax node for the list of arguments.":"代表参数列表的语法节点的类。\r\n","\r\n            If the nullable expression always has a value, returns the value, otherwise null.\r\n            If this method is updated to recognize more complex patterns, callers should be reviewed.\r\n            ":"\r\n            如果可通用的表达式始终具有一个值，请返回值，否则为null。\r\n            如果更新此方法以识别更复杂的模式，则应审查呼叫者。\r\n            \r\n",", -1 otherwise.":"，-1否则。\r\n","\r\n              Looks up a localized string similar to Keyword 'this' or 'base' expected.\r\n            ":"\r\n              查找类似于关键字“ this”或“ base”预期的局部字符串。\r\n            \r\n","Possible null reference return.":"可能的零参考返回。\r\n","\r\n              Looks up a localized string similar to '{0}' does not have a suitable static 'Main' method.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串没有合适的静态“主”方法。\r\n            \r\n","\r\n            a bound node rewriter that rewrites types properly (which in some cases the automatically-generated\r\n            base class does not).  This is used in the lambda rewriter, the iterator rewriter, and the async rewriter.\r\n            ":"\r\n            正确重写类型的绑定节点重写器（在某些情况下是自动生成的\r\n            基类没有）。这用于Lambda重写器，迭代器重写器和异步重写器中。\r\n            \r\n","\r\n            Returns the nearest lexically enclosing type, or null if there is none.\r\n            ":"\r\n            返回最近的词汇封闭类型，如果没有，则返回空。\r\n            \r\n","'{0}' does not implement the '{1}' pattern. '{2}' has the wrong signature.":"'{0}'不会实现'{1}'模式。 '{2}'签名错误。\r\n","\r\n            Called when this thread loaded the method's attributes. For method symbols with completion state.\r\n            ":"\r\n            当该线程加载方法的属性时调用。对于具有完成状态的方法符号。\r\n            \r\n","\r\n              Looks up a localized string similar to The modifier '{0}' is not valid for this item.\r\n            ":"\r\n              查找类似于修饰符'{0}'的本地化字符串对此项目无效。\r\n            \r\n","\r\n            Binder that should be used to bind type syntax for the local.\r\n            ":"\r\n            应用于绑定本地的类型语法的粘合剂。\r\n            \r\n","'{0}': property or indexer must have at least one accessor":"'{0}'：属性或索引器必须至少具有一个访问者\r\n","\r\n            Summary of the reason why the type is bad.\r\n            ":"\r\n            总结类型不好的原因。\r\n            \r\n","Set to true if a cycle was found in the type forwarders.":"如果在类型转发器中找到一个周期，则设置为True。\r\n","\r\n            When compiling in metadata-only mode, ":"\r\n            在以元数据模式进行编译时，\r\n","Gets the \"operator\" token.":"获取“操作员”令牌。\r\n","\r\n            If this.IsFixed is true, returns the underlying implementation type for the\r\n            fixed-size buffer when emitted.  Otherwise returns null.\r\n            ":"\r\n            如果此符号为true，请返回的基础实现类型\r\n            固定大小的缓冲区发射时。否则返回null。\r\n            \r\n","\r\n            Returns a C# character literal with the given value.\r\n            ":"\r\n            返回带有给定值的C＃字符文字。\r\n            \r\n","\r\n            Any generated methods that don't suppress debug info will use this\r\n            list of debug imports.\r\n            ":"任何不抑制调试信息的生成的方法都将使用此\r\n            调试导入列表。\r\n            \r\n","\r\n            Visit a general expression, where we will only need to determine if variables are\r\n            assigned (or not). That is, we will not be needing AssignedWhenTrue and\r\n            AssignedWhenFalse.\r\n            ":"\r\n            访问一般表达式，我们只需要确定变量是否为\r\n            分配（或未）。也就是说，我们将不需要分配的Whentrue和\r\n            分配的Whenfalse。\r\n            \r\n","A member on currType that could have been an attempt to implement the interface, or null.":"Currtype上的成员本来可以尝试实现接口或null。\r\n","\r\n            Gets the list of custom modifiers associated with the array.\r\n            Returns an empty list if there are no custom modifiers.\r\n            ":"\r\n            获取与数组关联的自定义修饰符列表。\r\n            如果没有自定义修饰符，则返回一个空列表。\r\n            \r\n","\r\n            Determine if the given type is an empty struct type,. \"typesWithMembersOfThisType\" contains\r\n            a list of types that have members (directly or indirectly) of this type.\r\n            to remove circularity.\r\n            ":"\r\n            确定给定类型是否为空结构类型。 “ typewithMembersofthistype”包含\r\n            具有这种类型的成员（直接或间接）的类型列表。\r\n            去除圆形。\r\n            \r\n"," that can be used to quickly\r\n            check for certain attribute applications in context of this binder.\r\n            ":" 可以用来快速\r\n            在此粘合剂的上下文中检查某些属性应用程序。\r\n            \r\n","\r\n            Create a decision dag for a switch expression.\r\n            ":"\r\n            为开关表达式创建决策DAG。\r\n            \r\n","\r\n              Looks up a localized string similar to Type is not CLS-compliant because base interface is not CLS-compliant.\r\n            ":"\r\n              查找类似于类型的本地化字符串不合同符合CLS，因为基本接口不符合CLS。\r\n            \r\n","Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.":"静态类'{0}'不能从类型'{1}'派生。静态类必须从对象派生。\r\n"," objects corresponding to assemblies directly referenced by this module.\r\n            ":" 对应于该模块直接引用的组件的对象。\r\n            \r\n","\r\n            Given a string, find the index of the first non-whitespace char.\r\n            ":"\r\n            给定一个字符串，找到第一个非Whitespace char的索引。\r\n            \r\n","Field '{0}' is never assigned to, and will always have its default value {1}":"字段'{0}'从未分配给，并且将始终具有其默认值{1}\r\n","await in catch blocks and finally blocks":"等待捕获块，最后块\r\n","\r\n              Looks up a localized string similar to The line number specified for #line directive is missing or invalid.\r\n            ":"\r\n              查找类似于为#line指令指定的行号类似的本地化字符串，丢失或无效。\r\n            \r\n","\r\n            To handle array initialization of arbitrary rank it is convenient to \r\n            approach multidimensional initialization as a recursively nested.\r\n            \r\n            ForAll{i, j, k} Init(i, j, k) ===> \r\n            ForAll{i} ForAll{j, k} Init(i, j, k) ===>\r\n            ForAll{i} ForAll{j} ForAll{k} Init(i, j, k)\r\n            \r\n            This structure is used for capturing initializers of a given index and \r\n            the index value itself.\r\n            ":"\r\n            处理任意等级的数组初始化，很方便\r\n            接近多维初始化作为递归嵌套的方法。\r\n            \r\n            forall {i，j，k} init（i，j，k）===>\r\n            forall {i} forall {j，k} init（i，j，k）===>\r\n            forall {i} forall {j} forall {k} init（i，j，k）\r\n            \r\n            该结构用于捕获给定索引的初始化器和\r\n            索引值本身。\r\n            \r\n","\r\n            The current source assembly.\r\n            ":"\r\n            当前的源组件。\r\n            \r\n","The tuple expression node.":"元组表达节点。\r\n","unmanaged constructed types":"不受管理的构造类型\r\n","\r\n            Currently allowAnyTarget flag is only set to true by ":"\r\n            当前允许hanytarget标志仅设置为true\r\n","\r\n              Looks up a localized string similar to CLS compliance checking will not be performed on '{0}' because it is not visible from outside this assembly.\r\n            ":"\r\n              查找类似于CLS合规性检查的本地化字符串将不会在“ {0}”上执行，因为它在此组件外部看不到。\r\n            \r\n","\r\n            True if this decision tree fully handles all possible values of its input.\r\n            ":"\r\n            如果该决策树完全处理其输入的所有可能值，则为正确。\r\n            \r\n","The SyntaxToken representing the well-known tag or attribute or null if it's not well-known.":"如果不是众所周知的，则表示众所周知的标签或属性或null的语法。\r\n","\r\n            Creates a binder with given imports.\r\n            ":"\r\n            用给定的导入创建活页夹。\r\n            \r\n","\r\n            As a performance optimization, cache parameter types and refkinds - overload resolution uses them a lot.\r\n            ":"\r\n            作为性能优化，缓存参数类型和refkinds-超载分辨率经常使用它们。\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability of reference types in type doesn't match implemented member '{0}'..\r\n            ":"\r\n              查找类似于类型中参考类型的无效性类似的本地化字符串与实现的成员'{0}'..\r\n            \r\n"," type with dynamic type.\r\n            If no ":" 具有动态类型的类型。\r\n            如果不\r\n"," set - the caller will add it.\r\n            ":" 设置 - 呼叫者将添加它。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' is inaccessible due to its protection level.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串由于其保护级别而无法访问。\r\n            \r\n","The best overloaded Add method '{0}' for the collection initializer has some invalid arguments":"最佳的超载添加方法'{0}'用于集合初始化器具有一些无效的参数\r\n","The using directive for '{0}' appeared previously in this namespace":"以前出现在此名称空间中的“ {0}”的使用指令\r\n","\r\n            The same value as ConcurrentDictionary.DEFAULT_CAPACITY\r\n            ":"\r\n            与concurrentDictionary.default_capacity相同的值\r\n            \r\n","\r\n            If the specified node represents a lambda returns a node (or nodes) that represent its body (bodies).\r\n            ":"\r\n            如果指定的节点代表lambda返回代表其身体（身体）的节点（或节点）。\r\n            \r\n","\r\n              Looks up a localized string similar to An expression tree lambda may not contain a coalescing operator with a null literal left-hand side.\r\n            ":"\r\n              查找类似于表达树的局部字符串，可能不包含具有无效左侧的合并操作员。\r\n            \r\n","Gets the type syntax.":"获取类型语法。\r\n","A character literal with the given value.":"具有给定值的字符字面字符。\r\n","\r\n            When binding a name X that was declared with a \"using X=OtherTypeOrNamespace\", return OtherTypeOrNamespace.\r\n            ":"\r\n            在用“使用x = earthtypeornamespace”声明的名称x绑定x时，请返回其他typeornamespace。\r\n            \r\n","\r\n              Looks up a localized string similar to Unsafe code may only appear if compiling with /unsafe.\r\n            ":"\r\n              查找类似于不安全代码的本地化字符串只有在使用 /不安全的情况下才会出现。\r\n            \r\n","The provided operation must not be part of a Control Flow Graph.":"提供的操作不得是控制流程图的一部分。\r\n","'await' cannot be used in an expression containing a call to '{0}' because it returns by reference":"“等待”不能在包含“ {0}”调用的表达式中使用，因为它通过引用返回\r\n","\r\n            Get a SemanticModel object that is associated with a method body that did not appear in this source code.\r\n            Given ":"\r\n            获取与该源代码中未出现的方法主体关联的SemanticModel对象。\r\n            给出\r\n","Called when the visitor visits a MethodDeclarationSyntax node.":"当访问者访问MethodDeclarationsyntax节点时调用。\r\n","\r\n              Looks up a localized string similar to '{0}': instance event in interface cannot have initializer.\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串：接口中的实例事件不能具有初始化器。\r\n            \r\n","\r\n              Looks up a localized string similar to A format specifier may not contain trailing whitespace..\r\n            ":"\r\n              查找类似于格式指定符的本地化字符串可能不包含尾随的空格。\r\n            \r\n","Field '{0}' must be fully assigned before control is returned to the caller":"在将控件返回到呼叫者之前，必须完全分配字段'{0}'\r\n","The deconstruction operation":"解构操作\r\n","\r\n              Looks up a localized string similar to Possible mistaken empty statement.\r\n            ":"\r\n              查找类似于可能错误的空语句的本地化字符串。\r\n            \r\n","Called when the visitor visits a XmlEmptyElementSyntax node.":"当访问者访问XMLEMPTYELEMENTSYNTAX节点时，请致电。\r\n","The type to attempt conversion to.":"尝试转换为的类型。\r\n","\r\n            If we have a WinRT type event, we need to encapsulate the adder call\r\n            (which returns an EventRegistrationToken) with a call to \r\n            WindowsRuntimeMarshal.AddEventHandler or RemoveEventHandler, but these\r\n            require us to create a new Func representing the adder and another\r\n            Action representing the Remover.\r\n            \r\n            The rewritten call looks something like:\r\n            \r\n            WindowsRuntimeMarshal.AddEventHandler<EventHandler>\r\n                (new Func<EventHandler, EventRegistrationToken>(@object.add), \r\n                 new Action<EventRegistrationToken>(@object.remove), handler);\r\n            \r\n            Where @object is a compiler-generated local temp if needed.\r\n            ":"\r\n            如果我们有WinRT类型事件，我们需要封装加法器调用\r\n            （返回EventRegistrationToken）的电话\r\n            Windowsruntimemarshal.addeventhandler或RemoveEventHandler，但是这些\r\n            要求我们创建一个代表加法器的新功能\r\n            代表去除剂的动作。\r\n            \r\n            重写的电话看起来像：\r\n            \r\n            Windowsruntimemarshal.addeventhandler <eventHandler>\r\n                （新func <EventHandler，EventRegistrationToken>（@Object.Add），\r\n                 新操作<eventRegistrationToken>（@object.remove），处理程序）;\r\n            \r\n            如果需要， @object是编译器生成的本地温度。\r\n            \r\n","\r\n              Looks up a localized string similar to File name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long.\r\n            ":"\r\n              查找类似于文件名“ {0}”的本地化字符串是空的，包含无效的字符，具有无绝对路径的驱动器规范，或者太长。\r\n            \r\n"," variable\r\n            the declarator is the ":" 多变的\r\n            声明者是\r\n","Type parameter that is not variance safe.":"类型参数不是差异安全的。\r\n","Called when the visitor visits a NameMemberCrefSyntax node.":"当访问者访问NamememberCrefsyntax节点时，请致电。\r\n","Cannot open '{0}' for writing -- '{1}'":"无法打开“ {0}”写作 - '{1}'\r\n","\r\n            Represents a parameter of a method or indexer.\r\n            ":"\r\n            表示方法或索引器的参数。\r\n            \r\n","The 8-byte floating point value to be represented by the returned token.":"返回令牌将要表示的8字节浮点值。\r\n","Class which represents the syntax node for name colon syntax.":"代表名称结肠语法的语法节点的类。\r\n","\r\n            Describes anonymous type field in terms of its name, type and other attributes\r\n            ":"\r\n            用名称，类型和其他属性来描述匿名类型字段\r\n            \r\n","The assembly name '{0}' is reserved and cannot be used as a reference in an interactive session":"汇编名称'{0}'已保留，不能在交互式会话中用作参考\r\n","\r\n             Bind the syntax into a namespace, type or alias symbol.\r\n             ":"\r\n             将语法绑定到名称空间，类型或别名符号中。\r\n             \r\n","ref structs":"裁判结构\r\n","Represents the end of a triple-slash documentation comment.":"代表三重斜线文档评论的结尾。\r\n","\r\n            A sequence of tests that must be performed, any of which must succeed.\r\n            The sequence is deemed to succeed if some element succeeds.\r\n            ":"\r\n            必须执行的一系列测试，任何测试都必须成功。\r\n            如果某些元素成功，则该序列被认为是成功的。\r\n            \r\n","\r\n            Helper class for rewriting a pattern switch statement by lowering it to a decision tree and\r\n            then lowering the decision tree to a sequence of bound statements. We inherit ":"\r\n            用于重写模式开关语句的助手类，通过将其降低到决策树和\r\n            然后将决策树降低到一系列结合语句。我们继承\r\n","\r\n              Looks up a localized string similar to A ref or out value must be an assignable variable.\r\n            ":"\r\n              查找类似于REF或OUT值的本地化字符串必须是可分配的变量。\r\n            \r\n","Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}' (possibly because of nullability attributes).":"参数类型中的参考类型的无效性'{0}'不匹配实现的成员'{1}'（可能是由于无效属性）。\r\n","\r\n            This method is equivalent to Microsoft.CodeAnalysis.BuildTasks.GenerateMSBuildEditorConfig.NormalizeWithForwardSlash\r\n            Both methods should be kept in sync.\r\n            ":"\r\n            此方法相当于Microsoft.codeanalysis.buildtasks.generatemsbuildeditorconfig.normalizewithforwardslashlash\r\n            两种方法都应同步。\r\n            \r\n","\r\n            Traverse the symbol table and call Module.AddSynthesizedDefinition for each\r\n            synthesized explicit implementation stub that has been generated (e.g. when the real\r\n            implementation doesn't have the appropriate custom modifiers).\r\n            ":"\r\n            遍历符号表并调用模块。\r\n            综合已生成的显式实现存根（例如\r\n            实现没有适当的自定义修饰符）。\r\n            \r\n","The unqualified (right-most) part of a qualified or alias-qualified name, or the name itself if already unqualified.\r\n            If called on an instance of ":"合格或别名资格的名称的未合格（正确）部分，或名称本身（如果已经不合格）。\r\n            如果在一个实例中调用\r\n","Trivia list.":"琐事列表。\r\n","\r\n            True if the initial values of locals in the rewritten method and the initial thread ID need to be preserved. (e.g. enumerable iterator methods and async-enumerable iterator methods)\r\n            ":"\r\n            如果需要保留重写方法和初始线程ID中当地人的初始值，则需要保留。 （例如，枚举的迭代器方法和异步 - 启用迭代器方法）\r\n            \r\n","\r\n            Given an initializer expression infer the name of anonymous property or tuple element.\r\n            Returns default if unsuccessful\r\n            ":"\r\n            给定一个初始器表达式推断匿名属性或元组元素的名称。\r\n            返回默认值如果不成功\r\n            \r\n","\r\n              Looks up a localized string similar to Auto-implemented properties cannot return by reference.\r\n            ":"\r\n              查找类似于自动实现属性的本地化字符串无法通过参考返回。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use a nullable reference type in object creation..\r\n            ":"\r\n              查找类似于对象创建中的无效参考类型的本地化字符串。\r\n            \r\n","The field '{0}' is assigned but its value is never used":"分配了字段'{0}'，但其值永远不会使用\r\n","\r\n              Looks up a localized string similar to A value of type 'void' may not be assigned..\r\n            ":"\r\n              查找类似于类型“ void”值的本地化字符串可能不会分配。\r\n            \r\n","The syntax node that declares a event.":"声明事件的语法节点。\r\n","\r\n            A specific location for binding.\r\n            ":"\r\n            绑定的特定位置。\r\n            \r\n","\r\n            A collection of return (or yield break) statements found within the region that return from the enclosing method or lambda.\r\n            ":"\r\n            从封闭方法或lambda返回的区域内发现的退货（或收益率中断）的集合。\r\n            \r\n","\r\n            Is this a field of a tuple type?\r\n            ":"\r\n            这是元组类型的领域吗？\r\n            \r\n","\r\n            Return top-level nullability for the expression. This method should be called on a limited\r\n            set of expressions only. It should not be called on expressions tracked by flow analysis\r\n            other than ":"\r\n            返回表达式的顶级无效性。该方法应在有限的\r\n            仅表达式。不应通过流量分析跟踪的表达式来调用它\r\n            以外\r\n","When the method returns, contains a boolean value indicating whether this span is considered hidden or not.":"当该方法返回时，包含一个布尔值，指示该跨度是否被视为隐藏。\r\n","\r\n            Gets type information about an attribute.\r\n            ":"\r\n            获取有关属性的类型信息。\r\n            \r\n","\r\n              Looks up a localized string similar to More than one protection modifier.\r\n            ":"\r\n              查找类似于多个保护修饰符的局部字符串。\r\n            \r\n","\r\n            if all of the type argument lists in its fully qualified name are empty.\r\n            Note that the type arguments of an unbound generic type will be returned as error\r\n            types because they do not really have type arguments.  An unbound generic type\r\n            yields null for its BaseType and an empty result for its Interfaces.\r\n            ":"\r\n            如果所有类型的参数列出了其完全合格的名称，则为空。\r\n            请注意，无限通用类型的类型参数将作为错误返回\r\n            类型是因为它们实际上没有类型的参数。无限通用类型\r\n            为其底层类型而产生无效的界面，并为其接口提供了空的结果。\r\n            \r\n","\r\n            Is the contained code within a member method body?\r\n            ":"\r\n            成员方法主体中是否包含代码？\r\n            \r\n","Symbol part to which the attribute has been applied.":"已应用该属性的符号部分。\r\n","\r\n              Looks up a localized string similar to Parameter has no matching param tag in the XML comment (but other parameters do).\r\n            ":"\r\n              在XML注释中查找类似于参数的本地化字符串（但是其他参数确实）。\r\n            \r\n","\r\n              Looks up a localized string similar to XML comment has a duplicate typeparam tag.\r\n            ":"\r\n              查找类似于XML注释的本地化字符串具有重复的Typeparam标签。\r\n            \r\n","\r\n            string s = null;\r\n            var list = new[] { s }.ToList();\r\n            list.Add(null);\r\n            ":"\r\n            字符串s = null;\r\n            var list = new [] {s} .tolist（）;\r\n            list.Add（null）;\r\n            \r\n","\r\n            A Module object providing metadata.\r\n            ":"\r\n            提供元数据的模块对象。\r\n            \r\n","A property or indexer may not be passed as an out or ref parameter":"属性或索引器不得以输出或参数为\r\n","Async methods are not allowed in an Interface, Class, or Structure which has the 'SecurityCritical' or 'SecuritySafeCritical' attribute.":"异步方法在具有“安全性”或“ SecuritySafecritical”属性的接口，类或结构中不允许使用。\r\n","\r\n            The possible places that we are processing when there is a region.\r\n            ":"\r\n            有一个区域时我们正在处理的可能位置。\r\n            \r\n","Fixed size buffers can only be accessed through locals or fields":"固定尺寸的缓冲区只能通过当地人或字段访问\r\n",").\r\n            The extracted block will have been wrapped as a ":"）。\r\n            提取的块将被包裹为\r\n","\r\n            Creates the syntax representation of a para element within xml documentation comments.\r\n            ":"\r\n            在XML文档注释中创建PARA元素的语法表示。\r\n            \r\n","\r\n            The accessors are associated with ":"\r\n            配件与\r\n","Constraint type is not CLS-compliant":"约束类型不符合CLS\r\n","\r\n            Given a string which may contain newline sequences, get the index of the first newline\r\n            sequence beginning at the given starting index.\r\n            ":"\r\n            给定一个可能包含newline序列的字符串，获取第一个newline的索引\r\n            序列从给定的启动索引开始。\r\n            \r\n","Called when the visitor visits a ReturnStatementSyntax node.":"访问者访问returnstatementsyntax节点时调用。\r\n"," but strongly\r\n            typed to ":" 但强烈\r\n            输入\r\n","void M((int a, int b))":"void m（（int a，int b））\r\n","\r\n            Returns true if given try or any of its nested try blocks contain yields\r\n            ":"\r\n            如果给出尝试或其任何嵌套的尝试块包含收率，则返回true\r\n            \r\n","\r\n            Converts a generic name expression into one without the generic arguments.\r\n            ":"\r\n            将通用名称表达式转换为无通用参数。\r\n            \r\n","\r\n            Advance the current position by n. No guarantee that this position\r\n            is valid.\r\n            ":"\r\n            将当前位置提高到n。不能保证这个职位\r\n            已验证。\r\n            \r\n","The length of the collection that the Index will be used with. length has to be a positive value":"索引的藏品长度将与。长度必须是正值\r\n","Expression cannot be used in this context because it may indirectly expose variables outside of their declaration scope":"表达在这种情况下不能使用，因为它可能间接地暴露于声明范围之外的变量\r\n","Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.":"提供代表实例表达语法节点的类的基类。这是一个抽象类。\r\n","Possible null reference assignment.":"可能的零参考分配。\r\n","\r\n              Looks up a localized string similar to Cannot return by reference a result of '{0}' because the argument passed to parameter '{1}' cannot be returned by reference.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法通过引用“ {0}”的结果返回，因为传递给参数'{1}'的参数无法通过参考返回。\r\n            \r\n","\r\n            Represents a generic method of a generic type instantiation, closed over type parameters.\r\n            e.g. \r\n            A{T}.M{S}()\r\n            A.B{T}.C.M{S}()\r\n            ":"\r\n            代表通用类型实例化的通用方法，封闭了类型参数。\r\n            例如\r\n            a {t} .m {s}（）\r\n            a.b {t} .c.m {s}（）（）\r\n            \r\n","Creates a new ThrowExpressionSyntax instance.":"创建一个新的throw expressionsyntax实例。\r\n"," is the\r\n            return value from ":" 是个\r\n            返回值\r\n","\r\n              Looks up a localized string similar to dictionary initializer.\r\n            ":"\r\n              查找类似于字典初始化器的本地化字符串。\r\n            \r\n","\r\n            This class groups together all of the functionality needed to check for error CS1961, ERR_UnexpectedVariance.\r\n            Its functionality is accessible through the NamedTypeSymbol extension method CheckInterfaceVarianceSafety and\r\n            the MethodSymbol extension method CheckMethodVarianceSafety (for checking delegate Invoke).\r\n            ":"\r\n            此类别将检查错误CS1961（ERR_UNExpectedVariance）的所有功能组合在一起。\r\n            可以通过命名TypeSymbol扩展方法CheckInterfaceVarianCesafety和\r\n            方法符号扩展方法checkmethodvariancesafety（用于检查委托调用）。\r\n            \r\n","\r\n              Looks up a localized string similar to Obsolete member overrides non-obsolete member.\r\n            ":"\r\n              查找类似于过时的构件类似的局部字符串，覆盖了非观察成员。\r\n            \r\n","\r\n            Uninitialized state\r\n            ":"\r\n            非生机化状态\r\n            \r\n","Cannot return fields of '{0}' by reference because it is a '{1}'":"无法通过引用返回'{0}'的字段，因为它是'{1}'\r\n","\r\n              Looks up a localized string similar to Constraint type is not CLS-compliant.\r\n            ":"\r\n              查找类似于约束类型的本地化字符串不符合CLS。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' has the wrong signature to be an entry point.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串的错误签名是入口点。\r\n            \r\n","\r\n            Returns if the method is implicit constructor (normal and static)\r\n            ":"\r\n            如果该方法是隐式构造函数（正常和静态），则返回\r\n            \r\n","The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'":"'{0}'在'{2}'中与类型'{3}'冲突的命名空间'{1}'在\r\n","Feature '{0}' is not available in C# 3. Please use language version {1} or greater.":"C＃3中不可用功能'{0}'使用。请使用语言版本{1}或更大。\r\n","\r\n              Looks up a localized string similar to Copyright (C) Microsoft Corporation. All rights reserved..\r\n            ":"\r\n              查找类似于版权（C）Microsoft Corporation的本地化字符串。版权所有..\r\n            \r\n","Security attribute '{0}' has an invalid SecurityAction value '{1}'":"安全属性'{0}'具有无效的安全性值'{1}'\r\n","\r\n            \"C.D\" matches C.D, C{T}.D, C{S,T}.D{U}, etc.\r\n            ":"\r\n            “ C.D”匹配C.D，C {T} .D，C {S，T} .D {U}，等等。\r\n            \r\n","To cancel the computation.":"取消计算。\r\n","\r\n            Return binder for binding at node.\r\n            ":"\r\n            返回粘合剂以在节点处绑定。\r\n            \r\n","\r\n              Looks up a localized string similar to The second operand of an 'is' or 'as' operator may not be static type '{0}'.\r\n            ":"\r\n              查找类似于“ is”或“ octer”的第二操作数类似的局部字符串，“操作员可能不是静态类型'{0}'。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot read config file '{0}' -- '{1}'.\r\n            ":"\r\n              查找类似于读取配置文件'{0}' - '{1}'的本地化字符串。\r\n            \r\n","\r\n            Binds a simple name or the simple name portion of a qualified name.\r\n            ":"\r\n            绑定一个简单的名称或合格名称的简单名称部分。\r\n            \r\n","\r\n              Looks up a localized string similar to Error reading ruleset file {0} - {1}.\r\n            ":"\r\n              查找类似于错误阅读规则集文件{0}  -  {1}的本地化字符串。\r\n            \r\n","\r\n            Emits address as in & \r\n            \r\n            May introduce a temp which it will return. (otherwise returns null)\r\n            ":"\r\n            发出的地址如＆\r\n            \r\n            可能会引入将返回的温度。 （否则返回null）\r\n            \r\n","A static readonly field cannot be used as a ref or out value (except in a static constructor)":"静态可读字段不能用作ref或淘汰值（在静态构造函数中除外）\r\n","Overloaded method differing only in ref or out, or in array rank, is not CLS-compliant":"超载的方法仅在REF或OUT或ARRAY等级中不同，不符合CLS\r\n","\r\n              Looks up a localized string similar to The call is ambiguous between the following methods or properties: '{0}' and '{1}'.\r\n            ":"\r\n              在以下方法或属性之间查找类似于调用的本地化字符串：'{0}'和'{1}'。\r\n            \r\n","\r\n              Looks up a localized string similar to coalescing assignment.\r\n            ":"\r\n              查找类似于合并作业的本地弦。\r\n            \r\n","No value for RuntimeMetadataVersion found":"找不到RuntimetAdataversion的价值\r\n","\r\n            Returns a tuple of the assemblies this module forwards the given type to.\r\n            ":"\r\n            返回组件的元组，该模块将给定类型转发为。\r\n            \r\n","Calculate the offset from the start using the giving collection length.":"使用给定收集长度从开始时从开始计算偏移。\r\n","Error reading resource '{0}' -- '{1}'":"错误读取资源'{0}' - '{1}'\r\n","\r\n            The CLI spec says that custom modifiers must precede the ByRef type code in the encoding of a parameter.\r\n            Unfortunately, the managed C++ compiler emits them in the reverse order.  In order to avoid breaking\r\n            interop scenarios, we need to support such signatures.\r\n            Should be 0 for non-ref parameters.\r\n            ":"\r\n            CLI规格说，自定义修饰符必须先于参数编码中的BYREF类型代码。\r\n            不幸的是，托管的C ++编译器以相反的顺序排放它们。为了避免破裂\r\n            互动场景，我们需要支持此类签名。\r\n            对于非REF参数，应为0。\r\n            \r\n","\r\n             The record type includes synthesized '==' and '!=' operators equivalent to operators declared as follows:\r\n            \r\n             For record class:\r\n             public static bool operator==(R? left, R? right)\r\n                  => (object) left == right || ((object)left != null && left.Equals(right));\r\n             public static bool operator !=(R? left, R? right)\r\n                  => !(left == right);\r\n            \r\n             For record struct:\r\n             public static bool operator==(R left, R right)\r\n                  => left.Equals(right);\r\n             public static bool operator !=(R left, R right)\r\n                  => !(left == right);\r\n            \r\n            The 'Equals' method called by the '==' operator is the 'Equals(R? other)' (":"\r\n             记录类型包括合成的'=='和'！='运算符等效于运算符，如下所示：\r\n            \r\n             对于记录类：\r\n             公共静态bool操作员==（r？左，r？右）\r\n                  =>（对象）左==右|| （（对象）左！= null && left.equals（右））;\r\n             公共静态bool运算符！=（r？左，r？右）\r\n                  =>！（左==右）;\r\n            \r\n             用于记录结构：\r\n             公共静态布尔操作员==（r左，r右）\r\n                  => left.Equals（右）;\r\n             公共静态布尔操作员！=（r左，r右）\r\n                  =>！（左==右）;\r\n            \r\n            '=='运算符调用的'equals'方法是'equals（r？other）'（\r\n"," to construct an instantiation.\r\n            ":" 构建实例化。\r\n            \r\n","\r\n              Looks up a localized string similar to The given expression always matches the provided constant..\r\n            ":"\r\n              查找类似于给定表达式的局部字符串始终与提供的常数匹配。\r\n            \r\n","Called when the visitor visits a TupleTypeSyntax node.":"当访客访问TupleTypesyntax节点时，请致电。\r\n","\r\n            The candidate member was accepted in its normal (non-expanded) form.\r\n            ":"候选人以正常（非扩展）形式接受。\r\n            \r\n","A delegate to return the translation of the body of this statement":"返回本陈述身体翻译的代表\r\n","Called when the visitor visits a CatchFilterClauseSyntax node.":"当访问者访问catchfilterClausesyntax节点时，请致电。\r\n","An IEnumerable containing all the namespaces that are members of this symbol.\r\n            If this symbol has no namespace members, returns an empty IEnumerable. Never returns\r\n            null.":"一个包含该符号成员的所有名称空间的IEnumerer。\r\n            如果此符号没有名称空间成员，请返回一个空的iEnumerable。永远不会回来\r\n            无效的。\r\n","Called when the visitor visits a EndRegionDirectiveTriviaSyntax node.":"当访客访问End RegionDirectiviviaSynyntax节点时调用。\r\n","\r\n            Displays a symbol in the C# style.\r\n            ":"\r\n            在C＃样式中显示一个符号。\r\n            \r\n","\r\n            Parse an indexer member, with optional parameters.\r\n            ":"\r\n            解析具有可选参数的索引成员。\r\n            \r\n","The modifier '{0}' is not valid for this item":"修饰符'{0}'对此项目无效\r\n","\r\n            Compute the ":"\r\n            计算\r\n","The last statement to be included in the analysis.":"分析中包含的最后一个陈述。\r\n","\r\n            The label to jump to if the guard is true (or there is no guard).\r\n            ":"\r\n            如果警卫为真（或没有后卫），则可以跳到标签。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use a lambda expression as an argument to a dynamically dispatched operation without first casting it to a delegate or expression tree type..\r\n            ":"\r\n              查找类似于类似的本地化字符串，不能将lambda表达式用作动态调度操作的参数，而无需首先将其施放给委托或表达树类型。\r\n            \r\n","Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}' (possibly because of nullability attributes).":"“ {0}”返回类型中参考类型的无性性不匹配隐式实现的成员'{1}'（可能是由于无效属性）。\r\n"," directives.\r\n            ":" 指令。\r\n            \r\n","The text of all the tokens.":"所有令牌的文字。\r\n","\r\n             Represents an element field of a tuple type that is not backed by a real field\r\n             with the same name within the tuple type.\r\n            \r\n             Examples\r\n                 // alias to Item1 with a different name\r\n                 (int a, byte b).a\r\n            \r\n                 // not backed directly by the type\r\n                 (int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8).i8\r\n            \r\n                 // Item8, which is also not backed directly by the type\r\n                 (int, int, int, int, int, int, int, int).Item8\r\n            \r\n             NOTE: For any virtual element, there is a nonvirtual way to access the same underlying field.\r\n                   In scenarios where we need to enumerate actual fields of a struct,\r\n                   virtual fields should be ignored.\r\n             ":"\r\n             代表元素类型的元素字段，该字段未由真实字段支持\r\n             在元组类型中具有相同的名称。\r\n            \r\n             例子\r\n                 //别名与其他名称不同\r\n                 （int a，byte b）.a\r\n            \r\n                 //不直接支持该类型\r\n                 （int i1，int i2，int i3，int i4，int i5，int i6，int i7，int i8）.i8\r\n            \r\n                 // item8，也不直接由类型备份\r\n                 （int，int，int，int，int，int，int，int，int）.Item8\r\n            \r\n             注意：对于任何虚拟元素，都有一种非虚拟访问相同基础字段的方式。\r\n                   在我们需要枚举结构的实际字段的情况下，\r\n                   虚拟字段应被忽略。\r\n             \r\n"," is converted\r\n            before being converted to the iteration variable type.\r\n            ":" 被转换\r\n            在转换为迭代变量类型之前。\r\n            \r\n","The top-level method that will contain the code":"包含代码的顶级方法\r\n","Keyword 'this' is not valid in a static property, static method, or static field initializer":"关键字“ this”在静态属性，静态方法或静态字段初始器中无效\r\n","True if the diagnostic has error severity.":"如果诊断严重程度有误差，则为是真的。\r\n","You cannot use the fixed statement to take the address of an already fixed expression":"您不能使用固定语句来获取已经固定的表达式的地址\r\n","\r\n            A LookupResult summarizes the result of a name lookup within a scope It also allows\r\n            combining name lookups from different scopes in an easy way.\r\n            \r\n            A LookupResult can be ONE OF:\r\n               empty - nothing found.\r\n               a viable result - this kind of result prevents lookup into further scopes of lower priority.\r\n                                 Viable results should be without error; ambiguity is handled in the caller.\r\n                                 (Note that handling multiple \"viable\" results is not the same as in the VB compiler)\r\n               a non-accessible result - this kind of result means that search continues into further scopes of lower priority for\r\n                                 a viable result. An error is attached with the inaccessibility errors. Non-accessible results take priority over\r\n                                 non-viable results.\r\n               a non-viable result - a result that means that the search continues into further scopes of lower priority for\r\n                                     a viable or non-accessible result. An error is attached with the error that indicates\r\n                                     why the result is non-viable.  A typical reason would be that it is the wrong kind of symbol.\r\n            \r\n            Note that the class is poolable so its instances can be obtained from a pool via GetInstance.\r\n            Also it is a good idea to call Free on instances after they no longer needed.\r\n            \r\n            The typical pattern is \"caller allocates / caller frees\" -\r\n               \r\n               var result = LookupResult.GetInstance();\r\n             \r\n               scope.Lookup(result, \"goo\");\r\n               ... use result ...\r\n                    \r\n               result.Clear();\r\n               anotherScope.Lookup(result, \"moo\");\r\n               ... use result ...\r\n            \r\n               result.Free();   //result and its content is invalid after this\r\n               \r\n            \r\n            \r\n            ":"\r\n            查找概述了范围内的名称查找的结果，也允许\r\n            以一种简单的方式将不同范围的名称查找组合在一起。\r\n            \r\n            查找可以是：\r\n               空 - 找不到。\r\n               一个可行的结果 - 这种结果阻止查找进一步的优先级范围。\r\n                                 可行的结果应该没有错误；呼叫者中处理了歧义。\r\n                                 （请注意，处理多个“可行”结果与VB编译器中的情况不同）\r\n               一个不可访问的结果 - 这种结果意味着搜索将继续进入较低优先级的进一步范围\r\n                                 可行的结果。错误的错误错误附加了错误。不可访问的结果优先\r\n                                 不可行的结果。\r\n               一个不可行的结果 - 结果意味着搜索将继续进入较低优先级的进一步范围\r\n                                     可行或不可访问的结果。带有指示的错误附加了错误\r\n                                     为什么结果是不可行的。典型的原因是这是错误的符号。\r\n            \r\n            请注意，该类是可池的，因此可以通过getInstance从池中获得其实例。\r\n            同样，最好在不再需要的情况下在实例上免费致电。\r\n            \r\n            典型的模式是“呼叫者分配 /呼叫者释放”  - \r\n               \r\n               var result = lookupresult.getInstance（）;\r\n             \r\n               范围。\r\n               ...使用结果...\r\n                    \r\n               result.clear（）;\r\n               anotherscope.lookup（结果，“ moo”）;\r\n               ...使用结果...\r\n            \r\n               result.free（）; //结果及其内容之后无效\r\n               \r\n            \r\n            \r\n            \r\n","Called when the visitor visits a InterpolationAlignmentClauseSyntax node.":"当访问者访问InterPolationalIgnmentClausesyntax节点时调用。\r\n","\r\n            Is the test, produced as a result of a pattern-matching operation, always true?\r\n            Knowing that enables us to construct slightly more efficient code.\r\n            ":"\r\n            该测试是由于模式匹配操作而产生的，始终是正确的吗？\r\n            知道这使我们能够构建更有效的代码。\r\n            \r\n","Local '{0}' or its members cannot have their address taken and be used inside an anonymous method or lambda expression":"本地'{0}'或其成员无法在匿名方法或lambda表达式中使用其地址\r\n","\r\n              Looks up a localized string similar to A ref or out argument must be an assignable variable.\r\n            ":"\r\n              查找类似于参考的本地化字符串或参数必须是可分配的变量。\r\n            \r\n","Cannot return the range variable '{0}' by reference":"无法通过参考返回范围变量'{0}'\r\n","\r\n            Returns the index of the first token of a specified kind in the token list.\r\n            ":"\r\n            返回令牌列表中指定类型的第一个令牌的索引。\r\n            \r\n","A '{0}' character must be escaped (by doubling) in an interpolated string.":"必须在插值字符串中（通过加倍）逃脱一个'{0}'字符。\r\n","\r\n            If we are in a COM PIA with embedInteropTypes enabled we should turn properties and methods \r\n            that have the type and return type of object, respectively, into type dynamic. If the requisite conditions \r\n            are fulfilled, this method returns a dynamic type. If not, it returns the original type.\r\n            ":"\r\n            如果我们在启用了嵌入插图的COM PIA中，我们应该转动属性和方法\r\n            将对象的类型和返回类型分别为类型动态。如果必要条件\r\n            要实现，此方法返回动态类型。如果没有，它将返回原始类型。\r\n            \r\n","Result type":"结果类型\r\n","\r\n            The \"exact\" effective base type. \r\n            In the definition of effective base type we abstract some concrete types to their base classes:\r\n             * For each constraint of T that is a struct-type, R contains System.ValueType.\r\n             * For each constraint of T that is an enumeration type, R contains System.Enum.\r\n             * For each constraint of T that is a delegate type, R contains System.Delegate.\r\n             * For each constraint of T that is an array type, R contains System.Array.\r\n             * For each constraint of T that is a class-type C, R contains type C' which is constructed \r\n               from C by replacing all occurrences of dynamic with object.\r\n            The reason is that the CLR doesn't support operations on generic parameters that would be needed \r\n            to work with these types. For example, ldelem instruction requires the receiver to be a specific array, \r\n            not a type parameter constrained to be an array.\r\n            \r\n            When computing the deduced type we don't perform this abstraction. We keep the original constraint T.\r\n            Deduced base type is used to check that consistency rules are satisfied.\r\n            ":"\r\n            “精确”有效的基本类型。\r\n            在有效基础类型的定义中，我们将一些具体类型抽象成其基础类别：\r\n             *对于t的每个约束，即结构类型，R包含system.Valuetype。\r\n             *对于t类型的t的每个约束，r都包含system.enum。\r\n             *对于t的每个约束，是委托类型，R包含system.delegate。\r\n             *对于t类型的t的每个约束，R包含System.Array。\r\n             *对于t的每个约束，即类型C，R包含构造的类型C'\r\n               通过用对象替换所有动态的出现，从C中。\r\n            原因是CLR不支持对需要的通用参数操作\r\n            使用这些类型。例如，LDELEM指令要求接收器为特定数组，\r\n            并非被限制为数组的类型参数。\r\n            \r\n            计算推导类型时，我们不执行此抽象。我们保留原始约束。\r\n            推导的基本类型用于检查是否满足一致性规则。\r\n            \r\n","\r\n            Pending escapes generated in the current scope (or more deeply nested scopes). When jump\r\n            statements (goto, break, continue, return) are processed, they are placed in the\r\n            pendingBranches buffer to be processed later by the code handling the destination\r\n            statement. As a special case, the processing of try-finally statements might modify the\r\n            contents of the pendingBranches buffer to take into account the behavior of\r\n            \"intervening\" finally clauses.\r\n            ":"\r\n            在当前范围（或更深层嵌套的范围）中产生的悬挂逃逸。跳跃时\r\n            对语句（Goto，Break，Consine，Record）进行处理，将其放置在\r\n            待处理的缓冲区将在以后通过处理目的地的代码处理\r\n            陈述。作为一种特殊情况，试用语句的处理可能会修改\r\n            悬而未决缓冲区的内容要考虑到的行为\r\n            “干预”最终条款。\r\n            \r\n","\r\n            Returns a value indicating whether this builder has a symbol that needs IsByRefLikeAttribute to be generated during emit phase.\r\n            ":"\r\n            返回一个值，指示该构建器是否具有需要在EMIT阶段生成的isbyReflikeAttribute的符号。\r\n            \r\n","'{0}' is ambiguous between '{1}' and '{2}'. Either use '@{0}' or explicitly include the 'Attribute' suffix.":"'{0}'在'{1}'和'{2}'之间是模棱两可的。要么使用'@{0}'，要么明确包含“属性”后缀。\r\n","\r\n            Binds a simple name or the simple name portion of a qualified name. \r\n            ":"\r\n            绑定一个简单的名称或合格名称的简单名称部分。\r\n            \r\n","Creates a new XmlCommentSyntax instance.":"创建一个新的XMLCommentsyntax实例。\r\n","\r\n              Looks up a localized string similar to Assignment made to same variable.\r\n            ":"\r\n              查找类似于对同一变量的分配类似的本地化字符串。\r\n            \r\n","{ or ; expected":"{ 或者 ;预期的\r\n"," directly since it has simpler\r\n            requirements than ":" 直接因为它更简单\r\n            要求比 \r\n","\r\n            Report an error if a member (other than a method) exists with the same name\r\n            as the event accessor, or if a method exists with the same name and signature.\r\n            ":"\r\n            报告错误（方法除外）具有相同名称的错误\r\n            作为事件访问者，或者如果存在具有相同名称和签名的方法。\r\n            \r\n","\r\n              Looks up a localized string similar to Program has more than one entry point defined. Compile with /main to specify the type that contains the entry point..\r\n            ":"\r\n              查找类似于程序的本地化字符串已定义多个入口点。使用 /main编译以指定包含入口点的类型。\r\n            \r\n","(int x, int y) M()":"（int x，int y）m（）\r\n","\r\n            All type members in a flat array\r\n            ":"\r\n            所有类型的成员在平面阵列中\r\n            \r\n","The CallerFilePathAttribute may only be applied to parameters with default values":"CallerFilePathAttribute只能应用于具有默认值的参数\r\n","\r\n              Looks up a localized string similar to Overloadable unary operator expected.\r\n            ":"\r\n              查找类似于预期的超载单元运算符的本地化字符串。\r\n            \r\n","\r\n            The default decision if no value matches, or the matched value's decision doesn't handle all inputs.\r\n            ":"\r\n            如果没有值匹配或匹配值的决定不能处理所有输入，则默认决定。\r\n            \r\n","Accessing a member on a field of a marshal-by-reference class may cause a runtime exception":"访问会员在逐个参考类的领域上的成员可能会导致运行时例外\r\n","\r\n            Represents a constant field of an enum.\r\n            ":"\r\n            表示枚举的恒定场。\r\n            \r\n","s, so we do not have to \r\n            visit them.\r\n            ":"S，所以我们不必\r\n            拜访他们。\r\n            \r\n","\r\n            Used by callers before calling CSharpCompilation.EnsureNullableAttributeExists().\r\n            ":"\r\n            在调用csharpcompilation.senurenullableabeattributeexists（）之前，由呼叫者使用。\r\n            \r\n","\r\n              Looks up a localized string similar to The specified version string does not conform to the recommended format - major.minor.build.revision.\r\n            ":"\r\n              查找类似于指定版本字符串的本地化字符串不符合推荐格式-Major.minor.build.revision。\r\n            \r\n","\r\n            Validates the awaited expression, returning true if no errors are found.\r\n            ":"\r\n            验证所期待的表达式，如果找不到错误，则返回真实。\r\n            \r\n","Unable to determine specific cause of the failure.":"无法确定失败的特定原因。\r\n","The namespace extent to use, IF a merged namespace is created.":"如果创建了合并的名称空间，则使用的名称空间范围。\r\n","\r\n            Variables instances for each lambda or local function defined within the analyzed region.\r\n            ":"\r\n            分析区域内定义的每个lambda或局部函数的变量实例。\r\n            \r\n","Pattern matching enhancements (switch expressions, property patterns, tuple patterns, and positional patterns)":"图案匹配增强功能（开关表达式，属性模式，元组模式和位置​​模式）\r\n","No suitable 'Deconstruct' instance or extension method was found for type '{0}', with {1} out parameters and a void return type.":"对于类型'{0}'，没有找到合适的“解构”实例或扩展方法，{1} out参数和void返回类型。\r\n","\r\n              Looks up a localized string similar to Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object..\r\n            ":"\r\n              查找类似于静态类'{0}'的本地化字符串，不能从类型'{1}'派生。静态类必须从对象中得出。\r\n            \r\n","\r\n            An elastic trivia with kind EndOfLineTrivia containing a single carriage return character. Elastic trivia\r\n            are used to denote trivia that was not produced by parsing source text, and are usually not preserved during\r\n            formatting.\r\n            ":"\r\n            带有单个马车返回特征的弹性琐事。弹性琐事\r\n            用于表示未通过解析源文本产生的琐事，通常在\r\n            格式化。\r\n            \r\n","\r\n            Common base for ordinary methods overriding methods from object synthesized by compiler for records.\r\n            ":"普通方法的共同基础是由编译器合成的记录合成对象的覆盖方法。\r\n            \r\n","Called when the visitor visits a FunctionPointerCallingConventionSyntax node.":"当访问者访问fintunPoInterCallingConventionsyntax节点时调用。\r\n","\r\n              Looks up a localized string similar to Unexpected use of an unbound generic name.\r\n            ":"\r\n              查找类似于未结合通用名称的意外使用的本地化字符串。\r\n            \r\n","Analyzes a node in a \"one-off\" context, such as for attributes or parameter default values.":"分析“一次性”上下文中的节点，例如属性或参数默认值。\r\n","\r\n              Looks up a localized string similar to /LIB option.\r\n            ":"\r\n              查找类似于 /lib选项的本地化字符串。\r\n            \r\n","Cannot await in the body of a lock statement":"无法等待锁定声明的身体\r\n","\r\n              Looks up a localized string similar to An expression of type '{0}' is not allowed in a subsequent from clause in a query expression with source type '{1}'.  Type inference failed in the call to '{2}'..\r\n            ":"\r\n              查找类似于“ {0}”类型的表达式的本地化字符串，在以后的子句中不允许使用源类型'{1}'在查询表达式中的子句中。键入推理在调用'{2}'..的呼叫中失败。\r\n            \r\n",", in which some number of the tests have already been performed\r\n            for each case.\r\n            When we have computed ":"，其中已经执行了一些测试\r\n            对于每种情况。\r\n            当我们计算\r\n"," that represents this conversion.":" 这代表了这种转换。\r\n","\r\n              Looks up a localized string similar to Not all code paths return a value in {0} of type '{1}'.\r\n            ":"\r\n              查找类似于所有代码路径类似的本地化字符串，返回类型'{1}'的{0}中的值。\r\n            \r\n","\r\n            Explicitly indicates result is void\r\n            ":"\r\n            明确表示结果是无效的\r\n            \r\n","The 'l' suffix is easily confused with the digit '1'":"“ L”后缀很容易与数字“ 1”混淆\r\n","\r\n              Looks up a localized string similar to Instance fields of readonly structs must be readonly..\r\n            ":"\r\n              查找与ReadOnly结构的实例字段相似的本地化字符串，必须阅读。\r\n            \r\n","\r\n            Represents an assembly built by compiler.\r\n            ":"\r\n            代表由编译器构建的组件。\r\n            \r\n"," Anonymous type manager owning this template ":" 拥有此模板的匿名类型管理器\r\n","\r\n              Looks up a localized string similar to Attributes are not valid in this context..\r\n            ":"\r\n              在此上下文中查找类似于属性的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Attributes are not allowed on local function parameters or type parameters.\r\n            ":"\r\n              在本地函数参数或类型参数上查找类似于属性的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Ambiguous reference in cref attribute.\r\n            ":"\r\n              查找类似于CREF属性中模棱两可的参考的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Iterators cannot have by reference locals.\r\n            ":"\r\n              查找类似于迭代器的本地化字符串，无法通过参考当地人使用。\r\n            \r\n"," imports in the corresponding namespace, or\r\n            ":" 在相应的名称空间中导入，或\r\n            \r\n","\r\n            Returns true if all type parameter references within the given\r\n            type belong to containingSymbol or its containing types.\r\n            ":"\r\n            如果给定的所有类型参数引用，则返回true\r\n            类型属于ContiningSymbol或其包含类型。\r\n            \r\n","\r\n            Returns true if the conversion is an interpolated string builder conversion.\r\n            ":"\r\n            如果转换是插值的字符串构建器转换，则返回true。\r\n            \r\n","\r\n              Looks up a localized string similar to namespace.\r\n            ":"\r\n              查找类似于名称空间的本地化字符串。\r\n            \r\n","\r\n            An elastic trivia with kind WhitespaceTrivia containing no characters. Elastic marker trivia are included\r\n            automatically by factory methods when trivia is not specified. Syntax formatting will replace elastic\r\n            markers with appropriate trivia.\r\n            ":"\r\n            带有善良的弹性琐事，没有字符。包括弹性标记琐事\r\n            当未指定琐事时，会自动通过出厂方法。语法格式将取代弹性\r\n            具有适当琐事的标记。\r\n            \r\n","\r\n            The declarations corresponding to the source files of this module.\r\n            ":"\r\n            与此模块的源文件相对应的声明。\r\n            \r\n","\r\n            Analyzes a set of bound nodes, recording updated nullability information, and returns an\r\n            updated BoundNode with the information populated.\r\n            ":"\r\n            分析一组绑定的节点，记录更新的无效信息，并返回\r\n            更新的边界案例和填充的信息。\r\n            \r\n","\r\n             If C# picks a different implementation than the CLR (see IsPossibleImplementationUnderClrRules), then we might\r\n             still be okay, but dynamic dispatch might result in C#'s choice getting called anyway.\r\n             ":"\r\n             如果C＃选择了与CLR不同的实现（请参见IspossibleImplementationunderclrules），那么我们可能会\r\n             仍然可以，但是动态调度可能会导致C＃的选择无论如何都会被调用。\r\n             \r\n","\r\n            A singleton object that performs only one type of instrumentation - addition of debugging sequence points. \r\n            ":"\r\n            仅执行一种仪器类型的单例对象 - 添加调试序列点。\r\n            \r\n","\r\n            Determines what type of conversion, if any, would be used if a given expression was\r\n            converted to a given type.  If isExplicitInSource is true, the conversion produced is\r\n            that which would be used if the conversion were done for a cast expression.\r\n            ":"\r\n            确定如果给定的表达式为\r\n            转换为给定类型。如果IsexplicitInsource为真，则产生的转换为\r\n            如果转换是用于铸造表达式的，则将使用的方法。\r\n            \r\n","\r\n            For cases where the RHS of a deconstruction-declaration is a tuple literal, we merge type information from both the LHS and RHS.\r\n            For cases where the RHS of a deconstruction-assignment is a tuple literal, the type information from the LHS determines the merged type, since all variables have a type.\r\n            Returns null if a merged tuple type could not be fabricated.\r\n            ":"\r\n            对于解构解析的RHS是元组文字的情况，我们合并了来自LHS和RHS的类型信息。\r\n            对于解构分配的RHS是元组文字的情况，来自LHS的类型信息决定了合并的类型，因为所有变量都有类型。\r\n            如果无法制造合并的元组类型，则返回空。\r\n            \r\n","\r\n            Prepares most of the parts for MoveNextAsync() and DisposeAsync() methods.\r\n            ":"\r\n            为movenextAsync（）和disposeasync（）方法准备大多数零件。\r\n            \r\n","  | yes | no  | different |\r\n             ":"  |是|否|不同的|\r\n             \r\n","The best overload for '{0}' does not have a parameter named '{1}'":"“ {0}”的最佳过载没有名为'{1}'的参数\r\n",", rather than trying to construct a corresponding closed\r\n            type (which may not be difficult/possible in the case of nested types or mismatched arities).\r\n            \r\n            NOTE: Any non-null type symbol returned is guaranteed not to be an error type.\r\n            ":"，而不是试图构建相应的封闭\r\n            类型（在嵌套类型或不匹配的ARITY的情况下，这可能并不困难/可能）。\r\n            \r\n            注意：保证返回的任何非NULL类型符号都不是错误类型。\r\n            \r\n","\r\n            THe cursor represents a location in the tree that we can move around to indicate where\r\n            we are in the original tree as we're incrementally parsing.  When it is at a node or\r\n            token, it can either move forward to that entity's next sibling.  It can also move down\r\n            to a node's first child or first token.\r\n            \r\n            Once the cursor hits the end of file, it's done.  Note: the cursor will skip any other\r\n            zero length nodes in the tree.\r\n            ":"\r\n            光标代表树上的位置，我们可以四处走动以指示位置\r\n            当我们逐步解析时，我们在原始树中。当它在节点或\r\n            令牌，它可以向前发展到该实体的下一个兄弟姐妹。它也可以向下移动\r\n            到节点的第一个孩子或第一个令牌。\r\n            \r\n            光标击中文件的末尾，就完成了。注意：光标将跳过其他任何人\r\n            树中的零长度节点。\r\n            \r\n"," a (":" 一个 （\r\n","\r\n              Looks up a localized string similar to CallerMemberNameAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'.\r\n            ":"\r\n              查找类似于Callermembemneattribute类似的本地化字符串，因为从类型'{0}'type'{1}'类型中没有标准转换。\r\n            \r\n","SyntaxToken representing the stackalloc keyword.":"Syntaxtoken代表stackalloc关键字。\r\n","\r\n            The lexer can run away consuming the rest of the input when delimiters are mismatched. This is a test\r\n            for when we are attempting to recover from that situation.  Note that just running into new lines will\r\n            not make us think we're in runaway lexing.\r\n            ":"\r\n            当定界符不匹配时，Lexer可能会消耗其余的输入。这是一个测验\r\n            因为当我们试图从这种情况中恢复时。请注意，仅跑入新线条将\r\n            不要让我们认为我们处于失控的链路上。\r\n            \r\n","\r\n            Produces a serialized blob of all constant initializers.\r\n            Non-constant initializers are matched with a zero of corresponding size.\r\n            ":"\r\n            产生所有恒定初始化器的串行斑点。\r\n            非恒定初始化器与相应大小的零匹配。\r\n            \r\n","\r\n            Create a diagnostic for the given symbol. This could be an error or a warning based on\r\n            the ObsoleteAttribute's arguments.\r\n            ":"\r\n            为给定符号创建诊断。这可能是基于错误的错误或警告\r\n            过时的论点。\r\n            \r\n","Creates a new FinallyClauseSyntax instance.":"创建一个新的最后Clausesyntax实例。\r\n","A System.String that represents the current TypedConstant.":"一个代表当前打字的系统。\r\n","The 'goto case' value is not implicitly convertible to type '{0}'":"“ goto case”值并非隐式转换为type'{0}'\r\n","\r\n            Finds the GetAwaiter method of an awaitable expression.\r\n            ":"\r\n            找到了正在等待表达的Getawaiter方法。\r\n            \r\n","\r\n            Rewrite an async method into a state machine type.\r\n            ":"\r\n            将异步方法重写为状态计算机类型。\r\n            \r\n","\r\n            Get the semantic info of a named argument in an invocation-like expression (e.g. `x` in `M(x: 3)`)\r\n            or the name in a Subpattern (e.g. either `Name` in `e is (Name: 3){Name: 3}`).\r\n            ":"\r\n            在类似调用的表达式中获取命名参数的语义信息（例如`x` x` in m（x：3）`）\r\n            或子图中的名称（例如，``n n n'e e（name：3）{name：3}`）。\r\n            \r\n",".\r\n            It should be the ":"。\r\n            应该是\r\n"," to instrument\r\n            specific portions of the code. These APIs have at least two parameters:\r\n                - original bound node produced by the ":" 仪器\r\n            代码的特定部分。这些API至少有两个参数：\r\n                 - 由\r\n","\r\n              Looks up a localized string similar to name shadowing in nested functions.\r\n            ":"\r\n              查找类似于嵌套功能中的名称阴影的本地化字符串。\r\n            \r\n","If we already have the bound node for the initial value, pass it in to avoid recomputing it.":"如果我们已经具有初始值的绑定节点，请传递给它以避免重新计算它。\r\n","Construct an Index using a value and indicating if the index is from the start or from the end.":"使用一个值构建索引并指示该索引是从开始还是从末端开始。\r\n","\r\n            The SyntaxTree that this object is associated with.\r\n            ":"\r\n            该对象与之关联的语法。\r\n            \r\n","\r\n            Returns true if the specified node is of a kind that could represent a closure scope -- that\r\n            is, a scope of a captured variable.\r\n            Doesn't check whether or not the node actually declares any captured variable.\r\n            ":"\r\n            如果指定的节点是可以代表闭合范围的一种，则返回true  - \r\n            IS，捕获变量的范围。\r\n            不会检查节点是否实际声明任何捕获的变量。\r\n            \r\n","\r\n            Resolves ":"\r\n            解决\r\n","An __arglist parameter must be the last parameter in a formal parameter list":"__arglist参数必须是正式参数列表中的最后一个参数\r\n"," \r\n            Add a 'regular' synthesized method.\r\n            ":" \r\n            添加“常规”合成方法。\r\n            \r\n","\r\n            Return whether the symbol is either the original definition\r\n            or distinct from the original. Intended for use in Debug.Assert\r\n            only since it may include a deep comparison.\r\n            ":"\r\n            返回符号是否是原始定义\r\n            或与原始不同。旨在用于debug.assert\r\n            仅因为它可能包括深入比较。\r\n            \r\n","Assignment in conditional expression is always constant; did you mean to use == instead of = ?":"条件表达中的分配始终是恒定的。您的意思是使用==而不是=吗？\r\n","\r\n              Looks up a localized string similar to An expression tree lambda may not contain a ref, in or out parameter.\r\n            ":"\r\n              查找类似于表达树lambda的本地化字符串可能不包含参数或外部参数。\r\n            \r\n"," means the context is 'disable',\r\n            and ":" 意味着上下文是“禁用”，\r\n            和\r\n","Windows PDB writer doesn't support SourceLink feature: '{0}'":"Windows PDB Writer不支持Sourcelink功能：'{0}'\r\n","\r\n            NOTE: Dev11 behavior - First, it ignores arity,\r\n            which seems like a good way to disambiguate symbols (in particular,\r\n            CLS Rule 43 says that the name includes backtick-arity).  Second, it\r\n            does not consider two members with identical names (i.e. not differing\r\n            in case) to collide.\r\n            ":"\r\n            注意：dev11行为 - 首先，它忽略了Arity，\r\n            这似乎是消除符号的好方法（尤其是\r\n            CLS规则43说该名称包括Backtick-Arity）。第二，它\r\n            不考虑两个具有相同名称的成员（即没有不同\r\n            如果）碰撞。\r\n            \r\n","\r\n              Looks up a localized string similar to The body of an async-iterator method must contain a 'yield' statement..\r\n            ":"\r\n              查找类似于异步 - 列表方法的主体的局部字符串必须包含“收益率”语句。\r\n            \r\n",") that can be directly compared for equality \r\n            using ":"）可以直接比较平等\r\n            使用\r\n","\r\n            Returns true if the conversion is an implicit dynamic conversion. \r\n            ":"\r\n            如果转换是隐式动态转换，则返回true。\r\n            \r\n","\r\n            If the event has a AddMethod, return that.  Otherwise check the overridden\r\n            event, if any.  Repeat for each overridden event.\r\n            ":"\r\n            如果事件有ADDMETHOD，请返回。否则检查被覆盖\r\n            事件，如果有的话。重复每个覆盖事件。\r\n            \r\n","\r\n            The operation, when present is implemented via ":"\r\n            操作，当存在时通过\r\n","\r\n              Looks up a localized string similar to Invalid target type for /target: must specify 'exe', 'winexe', 'library', or 'module'.\r\n            ":"\r\n              查找类似于 /目标的无效目标类型类似的本地化字符串：必须指定“ EXE”，“ WINEXE”，“库”或“模块”。\r\n            \r\n","\r\n            Creates a singleton list of trivia.\r\n            ":"\r\n            创建一个琐事的单身清单。\r\n            \r\n","\r\n            Enclosing binder for the location where the local is declared.\r\n            It should be used to bind something at that location.\r\n            ":"\r\n            封闭活页夹，以供声明本地的位置。\r\n            它应用于在该位置绑定某些东西。\r\n            \r\n","\r\n              Looks up a localized string similar to Quoted file name expected.\r\n            ":"\r\n              查找类似于引用的文件名的本地化字符串。\r\n            \r\n","\r\n            For the Task types themselves, this method might return true or false depending on mscorlib.\r\n            The definition of \"custom task-like type\" is one that has an [AsyncMethodBuilder(typeof(B))] attribute,\r\n            no more, no less. Validation of builder type B is left for elsewhere. This method returns B\r\n            without validation of any kind.\r\n            ":"\r\n            对于任务类型本身，此方法可能会根据MSCORLIB返回真或错误。\r\n            “自定义任务式类型”的定义是具有[asyncmethodbuilder（typeof（b））]属性的定义\r\n            不再，也没有。 B型B型的验证留在其他地方。此方法返回b\r\n            没有任何形式的验证。\r\n            \r\n","Embedded interop method '{0}' contains a body.":"嵌入式Interop方法'{0}'包含一个主体。\r\n","\r\n            Given an parameter declaration syntax node, get the corresponding symbol.\r\n            ":"\r\n            给定参数声明语法节点，获取相应的符号。\r\n            \r\n","\r\n              Looks up a localized string similar to This combination of arguments to '{0}' is disallowed because it may expose variables referenced by parameter '{1}' outside of their declaration scope.\r\n            ":"\r\n              查找与“ {0}”的参数组合类似的本地化字符串，因为它可能会在其声明范围外通过参数'{1}'引用的变量。\r\n            \r\n","\r\n              Looks up a localized string similar to A partial method cannot have access modifiers or the virtual, abstract, override, new, sealed, or extern modifiers.\r\n            ":"\r\n              查找类似于部分方法的本地化字符串，无法具有访问修饰符或虚拟，抽象，覆盖，新，密封或外部修饰符。\r\n            \r\n","The node associated with the method group":"与方法组关联的节点\r\n",".\r\n            Unlike ":"。\r\n            与众不同\r\n","The 4-byte unsigned integer value to be represented by the returned token.":"返回令牌代表的4字节未签名整数值。\r\n","Type and identifier are both required in a foreach statement":"类型和标识符都在foreach语句中都需要\r\n","\r\n            True if the parameterless constructor constraint was specified for the type parameter.\r\n            ":"\r\n            正确，如果为类型参数指定了无参数构造函数约束。\r\n            \r\n","\r\n            Map for storing effectively private or effectively internal fields declared in this assembly but never initialized nor assigned.\r\n            Each {symbol, bool} key-value pair in this map indicates the following:\r\n             (a) Key: Unassigned field symbol.\r\n             (b) Value: True if the unassigned field is effectively internal, false otherwise.\r\n            ":"\r\n            在此组件中声明但从未初始化或分配的有效私有或有效内部字段的映射。\r\n            该地图中的每个{符号，bool}键值对表示以下内容：\r\n             （a）键：未分配的字段符号。\r\n             （b）值：true如果未分配的字段实际上是内部的，则为否则。\r\n            \r\n","Deconstruct assignment requires an expression with a type on the right-hand-side.":"解构分配需要具有右侧类型的表达式。\r\n","Cannot declare a variable of static type '{0}'":"无法声明静态类型的变量'{0}'\r\n","\r\n            Add a diagnostic if the type of a captured variable is a restricted type\r\n            ":"\r\n            如果捕获变量的类型为限制类型，请添加诊断\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot create constructed generic type from non-generic type..\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法从非类型类型创建构造的通用类型。\r\n            \r\n","Called when the visitor visits a TupleExpressionSyntax node.":"当访问者访问tuplexpressyntax节点时调用。\r\n","\r\n              Looks up a localized string similar to Cannot modify the result of an unboxing conversion.\r\n            ":"\r\n              查找类似于类似的本地化字符串无法修改拆箱转换的结果。\r\n            \r\n","A list of syntax nodes that represents the content of the xml element.":"表示XML元素内容的语法节点列表。\r\n","\r\n              Looks up a localized string similar to Only auto-implemented properties can have initializers..\r\n            ":"\r\n              查找类似于自动实现属性的本地化字符串可以具有初始化器。\r\n            \r\n","\r\n            Describes whether this represents a modifiable variable. Note that\r\n            this refers to the variable, not the underlying value, so if this\r\n            variable is a ref-local, the writability refers to ref-assignment,\r\n            not assignment to the underlying storage.\r\n            ":"\r\n            描述这是否代表可修改变量。注意\r\n            这是指变量，而不是基本值，因此\r\n            变量是ref-local，撰写性是指参考，\r\n            不分配给基础存储。\r\n            \r\n","\r\n            If we're converting a default parameter value to the parameter type, then the conversion can actually fail\r\n            (e.g. if the default value was specified by an attribute and was, therefore, not checked by the compiler).\r\n            Set acceptFailingConversion if you want to see default(rewrittenType) in such cases.\r\n            The error will be suppressed only for conversions from ":"\r\n            如果我们将默认参数值转换为参数类型，则转换实际上可能会失败\r\n            （例如，如果默认值是由属性指定的，因此未由编译器检查）。\r\n            如果您想在这种情况下查看默认值（rewrittentype），请设置AcceptFailingConversion。\r\n            该错误将仅用于转换\r\n","\r\n            The \"position\" is used to determine what variables are visible and accessible. Even if\r\n            \"container\" is specified, the \"position\" location is significant for determining which\r\n            members of \"containing\" are accessible. \r\n            ":"\r\n            “位置”用于确定哪些变量可见和可访问。即使\r\n            指定“容器”，“位置”位置对于确定哪个\r\n            可以访问“包含”的成员。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid assembly name: {0}.\r\n            ":"\r\n              查找类似于无效汇编名称的本地化字符串：{0}。\r\n            \r\n","\r\n              Looks up a localized string similar to Type arguments are not allowed in the nameof operator..\r\n            ":"\r\n              查找类似于类型参数的本地化字符串在“命名操作员”中不允许。\r\n            \r\n","Member cannot be used in this attribute.":"成员不能在此属性中使用。\r\n","Called when the visitor visits a RecursivePatternSyntax node.":"当访问者访问递归patternsyntax节点时称呼。\r\n","\r\n            For each captured variable, identifies the scope in which it will be moved to a frame class. This is\r\n            normally the node where the variable is introduced, but method parameters are moved\r\n            to a frame class within the body of the method.\r\n            ":"\r\n            对于每个捕获的变量，标识将其移动到帧类的范围。这是\r\n            通常是引入变量的节点，但是移动方法参数\r\n            到该方法主体内的框架类。\r\n            \r\n"," during emit.\r\n            ":" 在发射期间。\r\n            \r\n","Cannot use fields of '{0}' as a ref or out value because it is a '{1}'":"不能将'{0}'的字段用作ref或输出值，因为它是'{1}'\r\n","Class which represents the syntax node for conditional expression.":"代表条件表达式的语法节点的类。\r\n",", and two ":"，两个\r\n","SyntaxToken representing the kind of the operator of the prefix unary expression.":"语法代表前缀Unary表达式的运算符。\r\n","\r\n            The member that we consider to be hidden (must have exactly the same custom modifiers as the hiding member).\r\n            Assumed to already be in hiddenBuilder.\r\n            ":"\r\n            我们认为隐藏的成员（必须具有与藏匿成员完全相同的自定义修饰符）。\r\n            假定已经在隐藏构建器中。\r\n            \r\n","\r\n            Owning RetargetingMethodSymbol.\r\n            ":"\r\n            拥有retargetingmethodsymbol。\r\n            \r\n","\r\n            Gets whether the type of an argument used in string concatenation can\r\n            be optimized by first calling ToString on it before passing the argument\r\n            to the String.Concat function.\r\n            ":"\r\n            得到字符串串联中使用的参数的类型是否可以\r\n            通过先在传递论点之前首先调用tostring来优化\r\n            到string.concat函数。\r\n            \r\n","\r\n            Returns true if the conversion is an implicit conditional expression conversion.\r\n            ":"\r\n            如果转换是隐式条件表达转换，则返回true。\r\n            \r\n","\r\n              Looks up a localized string similar to Type conflicts with imported type.\r\n            ":"\r\n              查找类似于导入类型的类型冲突的本地化字符串。\r\n            \r\n","\r\n            The field of the generated async class used to store the async method builder: an instance of\r\n            ":"\r\n            生成的异步类的字段用于存储异步方法构建器：\r\n            \r\n","\r\n            Creates a new syntax trivia list with all whitespace and end of line trivia replaced with\r\n            regularly formatted trivia.\r\n            ":"\r\n            创建一个新的语法琐事列表，并用所有空格和线路的结尾替换为\r\n            定期格式化的琐事。\r\n            \r\n","\r\n            The label containing a return from the method when the async method has not completed.\r\n            ":"\r\n            当异步方法尚未完成时，包含该方法返回的标签。\r\n            \r\n"," tree.\r\n            \r\n            At the same time it sets ":"树。\r\n            \r\n            同时设置\r\n"," is provided\r\n            the attribute lists will only be returned if there is reasonable belief that \r\n            the type has one of the attributes specified by ":" 提供\r\n            仅当有合理的信念，即\r\n            该类型具有由\r\n"," in script code,\r\n            or ":" 在脚本代码中，\r\n            或者\r\n","\r\n              Looks up a localized string similar to A base class is required for a 'base' reference.\r\n            ":"\r\n              查找类似于基类的本地化字符串需要“基本”参考。\r\n            \r\n","\r\n            Null for implicit, \r\n            ":"\r\n            null以隐式，\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot return by reference a member of parameter '{0}' because it is not a ref or out parameter.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法通过引用参数'{0}'的成员返回，因为它不是ref或out参数。\r\n            \r\n","\r\n            Given the full text of a documentation comment, strip off the comment punctuation (///, /**, etc)\r\n            and add appropriate indentations.\r\n            ":"\r\n            鉴于文档评论的全文，请删除评论标点符号（///，/**等）\r\n            并增加适当的凹痕。\r\n            \r\n","\r\n              Looks up a localized string similar to Tuple element name '{0}' is inferred. Please use language version {1} or greater to access an element by its inferred name..\r\n            ":"\r\n              查找类似于元组元素名称'{0}'的本地化字符串。请使用语言版本{1}或更大的内容，以通过其推断名称访问元素。\r\n            \r\n","\r\n            Used to create a decision dag for a switch expression.\r\n            ":"\r\n            用于为开关表达式创建决策DAG。\r\n            \r\n","SyntaxToken representing the extern keyword.":"Syntaxtoken代表外部关键字。\r\n","The syntax node that declares a namespace.":"声明名称空间的语法节点。\r\n","\r\n              Looks up a localized string similar to Unexpected preprocessor directive.\r\n            ":"\r\n              查找类似于意外的预处理器指令类似的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to An expression tree may not contain a call or invocation that uses optional arguments.\r\n            ":"\r\n              查找类似于表达树的本地化字符串可能不包含使用可选参数的调用或调用。\r\n            \r\n","\r\n            Gets the name of a symbol as it appears in metadata. Most of the time, this\r\n            is the same as the Name property, with the following exceptions:\r\n            1) The metadata name of generic types includes the \"`1\", \"`2\" etc. suffix that\r\n            indicates the number of type parameters (it does not include, however, names of\r\n            containing types or namespaces).\r\n            2) The metadata name of explicit interface names have spaces removed, compared to\r\n            the name property.\r\n            ":"\r\n            获取出现在元数据中的符号的名称。大多数时候，这个\r\n            与名称属性相同，但有以下例外：\r\n            1）通用类型的元数据名称包括“ 1”，'2“等。后缀\r\n            指示类型参数的数量（不包括\r\n            包含类型或名称空间）。\r\n            2）与之相比\r\n            名称属性。\r\n            \r\n","\r\n            Maps an immutable array through a function that returns ValueTask, returning the new ImmutableArray.\r\n            ":"\r\n            通过返回valueTask的函数映射一个不变的数组，从而返回新的ImmutableArray。\r\n            \r\n","\r\n            Manages anonymous types created on module level. All requests for anonymous type symbols \r\n            go via the instance of this class, the symbol will be either created or returned from cache.\r\n            ":"\r\n            管理在模块级别创建的匿名类型。所有匿名类型符号的请求\r\n            通过此类的实例进行，该符号将是从缓存创建或返回的。\r\n            \r\n","Static anonymous functions":"静态匿名函数\r\n","\r\n            Emit code for a conditional (aka ternary) operator.\r\n            ":"\r\n            发射有条件的（又名三元）操作员的代码。\r\n            \r\n","\r\n            A local rewriter for lowering an is-pattern expression.  This handles the general case by lowering\r\n            the decision dag, and returning a \"true\" or \"false\" value as the result at the end.\r\n            ":"\r\n            用于降低IS-Pattern表达式的本地重写者。这通过降低了一般案例\r\n            决策DAG，并返回“真”或“ false”值，作为结束的结果。\r\n            \r\n","\r\n              Looks up a localized string similar to ref foreach iteration variables.\r\n            ":"\r\n              查找类似于Ref Foreach迭代变量的本地化字符串。\r\n            \r\n","\r\n            Gets the names of defined preprocessor symbols.\r\n            ":"\r\n            获取定义的预处理器符号的名称。\r\n            \r\n","Syntax error, '{0}' expected":"语法错误，'{0}'预期\r\n"," constructed\r\n            from a generic type ":" 建\r\n            来自通用类型\r\n","A position within the ":"在\r\n","\r\n              Looks up a localized string similar to 'else' cannot start a statement..\r\n            ":"\r\n              查找类似于“ else”的本地化字符串无法启动语句。\r\n            \r\n","\r\n              Looks up a localized string similar to Conflicting options specified: Win32 resource file; Win32 icon.\r\n            ":"\r\n              查找类似于指定的相互冲突选项的本地化字符串：WIN32资源文件； Win32图标。\r\n            \r\n","readonly members":"Readonly成员\r\n","\r\n              Looks up a localized string similar to An entry point cannot be generic or in a generic type.\r\n            ":"\r\n              查找类似于入口点的本地化字符串不能是通用的或在通用类型中。\r\n            \r\n","\r\n            C# language version 7.2\r\n            ":"\r\n            C＃语言版本7.2\r\n            \r\n","A list of tokens used for the value of the xml text attribute.":"用于XML文本属性值的令牌列表。\r\n","The expression being assigned to '{0}' must be constant":"分配给'{0}'的表达式必须是恒定的\r\n","\r\n             The \"Join\" operation is used when two separate control flow paths converge at a single\r\n             statement. This operation is used to combine the if/else paths of a conditional, or two\r\n             \"goto\" statements to the same label, for example.\r\n             \r\n             According to convention, Join moves \"up\" the lattice, so the following equations must hold:\r\n             1. Join(Unreachable(), X) = X\r\n             2. Join(Top, X) = Top\r\n            \r\n             ":"\r\n             当两个单独的控制流路径在一个单一收敛时，使用“联接”操作\r\n             陈述。此操作用于组合条件的IF/else路径，或两个\r\n             例如，“ goto”语句给同一标签。\r\n             \r\n             根据大会，加入“向上”晶格，因此必须保持以下方程式：\r\n             1.加入（Unteach（），x）= x\r\n             2.加入（顶部，x）=顶部\r\n            \r\n             \r\n","\r\n            Inherited from AnonymousFunctionExpressionSyntax, but not used for\r\n            AnonymousMethodExpressionSyntax.  This will always be null.\r\n            ":"\r\n            从anonymousFunction expressionsyntax继承，但不使用\r\n            Anonymousmethodexpressionsyntax。这将永远是无效的。\r\n            \r\n","\r\n            The type of the return value this visitor's Visit method.\r\n            ":"\r\n            此访问者的访问方法的返回值类型。\r\n            \r\n","\r\n            Index into the array of bound initializer expressions to fetch the next bound expression.\r\n            ":"\r\n            索引到绑定的初始化器表达式数组，以获取下一个绑定的表达式。\r\n            \r\n","Creates a new FileScopedNamespaceDeclarationSyntax instance.":"创建一个新的filescopednamespacedeclarationsyntax实例。\r\n","\r\n              Looks up a localized string similar to The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'..\r\n            ":"\r\n              查找类似于'{0}'中的名称空间'{1}'的本地化字符串与导入的类型'{3}'在'{2}'中冲突。使用“ {0}”中定义的名称空间。\r\n            \r\n","Fixed size buffer of length {0} and type '{1}' is too big":"固定尺寸的缓冲区长度{0}和type' {1}'太大\r\n","\r\n              Looks up a localized string similar to 'await' requires that the type {0} have a suitable 'GetAwaiter' method.\r\n            ":"查找类似于“等待”的本地化字符串，要求类型{0}具有合适的“ getawaiter”方法。\r\n            \r\n","Gets the < token.":"获取<token。\r\n","ExpressionSyntax node representing the expression to be executed when the condition is true.":"表达式元素节点表示条件为真时要执行的表达式。\r\n","\r\n            WasConverted flag is used for debugging purposes only (not to direct the behavior of semantic analysis).\r\n            It is used on BoundLocal and BoundParameter to check that every such rvalue that has not been converted to\r\n            some type has been converted to its natural type.\r\n            ":"\r\n            使用的标志仅用于调试目的（不指导语义分析的行为）。\r\n            它用于界限和边界参数，以检查是否是否尚未转换为\r\n            某种类型已转换为自然类型。\r\n            \r\n","\r\n              Looks up a localized string similar to Compilation options '{0}' and '{1}' can't both be specified at the same time..\r\n            ":"\r\n              查找类似于编译选项'{0}'和'{1}'的本地化字符串，不能同时指定。\r\n            \r\n","\r\n            For DEBUG builds, we treat nullable analysis as enabled for all methods\r\n            unless explicitly disabled, so that analysis is run, even though results may\r\n            be ignored, to increase the chance of catching nullable regressions\r\n            (e.g. https://github.com/dotnet/roslyn/issues/40136).\r\n            ":"\r\n            对于调试构建，我们将无效的分析视为所有方法的启用\r\n            除非明确禁用，以便进行分析，即使结果可能\r\n            被忽略，增加捕获无效回归的机会\r\n            （例如https://github.com/dotnet/roslyn/issues/40136）。\r\n            \r\n","\r\n            A list of all closures (all lambdas and local functions) declared in this scope.\r\n            ":"\r\n            此范围中声明的所有关闭（所有lambdas和local功能）的清单。\r\n            \r\n","\r\n            Produces a MoveNext() method for an async method.\r\n            ":"\r\n            为异步方法产生movenext（）方法。\r\n            \r\n","\r\n            Are we binding for the purpose of an Expression Evaluator\r\n            ":"\r\n            我们是否为表达评估者的目的结合\r\n            \r\n","Called when the visitor visits a XmlNameSyntax node.":"当访问者访问XMLNamesyntax节点时，请致电。\r\n","Creates a new FunctionPointerUnmanagedCallingConventionSyntax instance.":"创建一个新的forcormpoInterunManagedCallingConventionsyntax实例。\r\n","\r\n              Looks up a localized string similar to Embedded interop method '{0}' contains a body..\r\n            ":"\r\n              查找类似于嵌入式Interop方法'{0}'的局部字符串包含一个主体。\r\n            \r\n","The SourceText with hintName '{0}' must have an explicit encoding set.":"带有Hintname'{0}'的SourceText必须具有显式编码集。\r\n","Creates a new LoadDirectiveTriviaSyntax instance.":"创建一个新的loadDirectivetriviaSyntax实例。\r\n","\r\n            If this is a field representing a tuple element,\r\n            returns the index of the element (zero-based).\r\n            Otherwise returns -1\r\n            ":"\r\n            如果这是代表元组元素的字段，\r\n            返回元素的索引（基于零）。\r\n            否则返回-1\r\n            \r\n","\r\n            Bind the ForEachStatementSyntax at the root of this binder.\r\n            ":"\r\n            在此粘合剂的根部绑定foreachstattatementsyntax。\r\n            \r\n","Member implements interface member with multiple matches at run-time":"成员在运行时实现多个匹配的接口成员\r\n",", but has two ":"，但有两个\r\n","'{0}': cannot declare indexers in a static class":"'{0}'：无法在静态类中声明索引器\r\n","\r\n            Returns a constructed method symbol if 'method' is generic, otherwise just returns 'method'\r\n            ":"\r\n            如果“方法”是通用的，则返回构造的方法符号，否则只返回“方法”\r\n            \r\n","\r\n            Bind a declaration variable where it isn't permitted. The caller is expected to produce a diagnostic.\r\n            ":"\r\n            在不允许的情况下绑定声明变量。预计呼叫者将产生诊断。\r\n            \r\n","\r\n            A collection of the non-constant local variables and parameters that have had their address (or the address of one\r\n            of their fields) taken using the '&' operator.\r\n            ":"\r\n            具有其地址的非恒定本地变量和参数的集合（或一个地址\r\n            使用'＆'操作员拍摄的字段）。\r\n            \r\n","\r\n            This class represents an event accessor declared in source \r\n            (i.e. not one synthesized for a field-like event).\r\n            ":"\r\n            该类代表源中声明的事件访问者\r\n            （即，没有一个用于野外事件的合成）。\r\n            \r\n",", and\r\n            (4) The symbol that is used to access the innermost frame pointer (it could be a local variable or \"this\" parameter)\r\n            \r\n            There are a few key transformations done in the rewriting.\r\n            (1) Lambda expressions are turned into delegate creation expressions, and the body of the lambda is\r\n                moved into a new, compiler-generated method of a selected frame class.\r\n            (2) On entry to a scope with captured variables, we create a frame object and store it in a local variable.\r\n            (3) References to captured variables are transformed into references to fields of a frame class.\r\n            \r\n            In addition, the rewriting deposits into ":"， 和\r\n            （4）用于访问最终帧指针的符号（可能是本地变量或“此参数”）\r\n            \r\n            重写中有一些关键的转换。\r\n            （1）lambda表达式变成代表创造表达式，而lambda的正文是\r\n                移至选定框架类的新编译器生成的方法。\r\n            （2）进入具有捕获变量的范围时，我们创建一个帧对象并将其存储在本地变量中。\r\n            （3）对捕获变量的引用转换为对帧类字段的引用。\r\n            \r\n            此外，将存款重写为\r\n","Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Are you missing required assembly references or a using directive for 'System.Linq'?":"找不到源类型的查询模式的实现。{0}'。 '{1}'找不到。您是否缺少所需的汇编引用或使用“ System.linq”的指令？\r\n","Creates a new MemberAccessExpressionSyntax instance.":"创建一个新的MemberAccessexpressynntax实例。\r\n","\r\n            Creates a trivia from a StructuredTriviaSyntax node.\r\n            ":"\r\n            从结构性曲霉节点产生琐事。\r\n            \r\n","\r\n            Guess the non-error type that the given type was intended to represent.\r\n            If the type itself is not an error type, then it will be returned.\r\n            Otherwise, the underlying type (if any) of the error type will be\r\n            returned.\r\n            ":"\r\n            猜猜给定类型旨在表示的非错误类型。\r\n            如果类型本身不是错误类型，则将返回。\r\n            否则，错误类型的基本类型（如果有）将是\r\n            回来。\r\n            \r\n","'{0}': a reference to a volatile field will not be treated as volatile":"'{0}'：对挥发性领域的引用将不会被视为挥发性\r\n","\r\n              Looks up a localized string similar to index operator.\r\n            ":"\r\n              查找类似于索引运算符的本地化字符串。\r\n            \r\n","Returns non-negative index if the list contains a token which matches ":"如果列表包含匹配的令牌，则返回非负索引\r\n","Friend access was granted by '{0}', but the strong name signing state of the output assembly does not match that of the granting assembly.":"朋友访问是由“ {0}”授予的，但是输出组件的强名称签名状态与授予程序集的签名不匹配。\r\n","'{0}' is inaccessible due to its protection level":"'{0}'由于其保护级别而无法访问\r\n"," is true when the set is considered\r\n            to contain all values less than ":" 当考虑集合时是真的\r\n            包含所有值小于\r\n","\r\n            The closure doesn't declare any variables, and is converted to a delegate at least once.\r\n            Display class is a singleton and may be shared with other top-level methods.\r\n            ":"\r\n            封闭不会声明任何变量，并且至少转换为委托。\r\n            显示类是单身人士，可以与其他顶级方法共享。\r\n            \r\n","'{0}' defines operator == or operator != but does not override Object.GetHashCode()":"'{0}'定义operator ==或operator！=但不覆盖object.gethashcode（）\r\n"," with no known type, given lookup resultKind and the given bound child.\r\n            ":" 没有已知的类型，给定查找结果和给定的孩子。\r\n            \r\n","\r\n              Looks up a localized string similar to 'experimental'.\r\n            ":"\r\n              查找类似于“实验”的局部字符串。\r\n            \r\n","\r\n            Checks if 'symbol' is accessible from within type 'within', with\r\n            an qualifier of type \"throughTypeOpt\". Sets \"failedThroughTypeCheck\" to true\r\n            if it failed the \"through type\" check.\r\n            ":"\r\n            检查是否可以从类型“内部”中访问“符号”，\r\n            类型为“ Printypeopt”的预选赛。设置“失败的typecheck”\r\n            如果失败了“通过类型”检查。\r\n            \r\n"," containing this\r\n            set of nodes becomes part of the bound nodes (e.g. in ":" 包含这个\r\n            一组节点成为结合节点的一部分（例如\r\n","\r\n            Applies a method similar to ":"\r\n            应用类似于\r\n","\r\n              Looks up a localized string similar to An expression tree may not contain a tuple == or != operator.\r\n            ":"\r\n              查找类似于表达树的本地化字符串可能不包含元组==或！=操作员。\r\n            \r\n","\r\n              Looks up a localized string similar to A value of type '{0}' cannot be used as a default parameter because there are no standard conversions to type '{1}'.\r\n            ":"\r\n              查找类似于类型的“ {0}”值的本地化字符串不能用作默认参数，因为没有标准转换type'{1}'。\r\n            \r\n","\r\n            are ":"\r\n            是\r\n","\r\n            internal for testing purpose\r\n            ":"\r\n            内部测试目的\r\n            \r\n","\r\n            Returns true if any of the NullableContexts in this map enable annotations, warnings, or both.\r\n            This does not include any restore directives.\r\n            ":"\r\n            如果此地图中的任何nulabablecontexts启用注释，警告或两者兼而有之，则返回true。\r\n            这不包括任何还原指令。\r\n            \r\n","\r\n            Binds the expression in the context of the specified location and gets symbol information.\r\n            This method is used to get symbol information about an expression that did not actually\r\n            appear in the source code.\r\n            ":"\r\n            在指定位置的上下文中绑定表达式，并获取符号信息。\r\n            此方法用于获取有关表达式的符号信息\r\n            出现在源代码中。\r\n            \r\n","A value of type '{0}' cannot be used as a default parameter because there are no standard conversions to type '{1}'":"类型'{0}'的值不能用作默认参数，因为没有标准转换来'{1}'\r\n","\r\n            A CSharpSyntaxNode derived from StructuredTriviaSyntax, with the structured view of this trivia node. \r\n            If this trivia node does not have structure, returns null.\r\n            ":"\r\n            csharpsyntaxnode源自结构的曲杆菌字母，并具有该琐事节点的结构化视图。\r\n            如果此琐事节点没有结构，请返回null。\r\n            \r\n","Async methods cannot have unsafe parameters or return types":"异步方法不能具有不安全的参数或返回类型\r\n","\r\n            Returns all methods in the group that are applicable, ":"\r\n            返回组中适用的所有方法，\r\n","\r\n            The QuickAttributeChecker applies a simple fast heuristic for determining probable\r\n            attributes of certain kinds without binding attribute types, just by looking at the final syntax of an\r\n            attribute usage.\r\n            ":"\r\n            QuickAttributeChecker适用一个简单的快速启发式方法来确定可能\r\n            仅通过查看一个最终语法，而没有绑定属性类型的某些类型的属性\r\n            属性用法。\r\n            \r\n"," method for creating a syntax tree.":" 创建语法树的方法。\r\n","\r\n            The CrefSyntax does not actually have to be within the documentation comment on the member - it\r\n            could be included from another file.\r\n            ":"\r\n            Crefsyntax实际上不必在对成员的文档评论中 - \r\n            可以从另一个文件中包括。\r\n            \r\n","\r\n            Produce a fresh discard symbol for testing.\r\n            ":"\r\n            产生一个新的丢弃符号进行测试。\r\n            \r\n","A partial method may not have multiple defining declarations":"部分方法可能没有多个定义声明\r\n","ParameterListSyntax node representing the list of parameters for the lambda expression.":"参数列表元素节点代表lambda表达式的参数列表。\r\n","\r\n            Create an instance of the method builder.\r\n            ":"\r\n            创建方法构建器的实例。\r\n            \r\n","Tuple element name cannot be an empty string.":"元组元素名称不能是一个空字符串。\r\n","\r\n            If there are any of these in the region, then a method should not be extracted.\r\n            ":"\r\n            如果该区域中有任何一个，则不应提取一种方法。\r\n            \r\n","Attribute '{0}' from module '{1}' will be ignored in favor of the instance appearing in source":"来自模块'{1}'的属性'{0}'将被忽略，而有利于出现在源中的实例\r\n","\r\n            Backing field for automatically implemented property, or\r\n            for a property with an initializer.\r\n            ":"\r\n            自动实现属性的备份字段，或\r\n            对于具有初始化器的属性。\r\n            \r\n","), and contains a representation of the meaning of the state. Because we always make\r\n            forward progress when a test is evaluated (the state description is monotonically smaller at each edge), the\r\n            graph of states is acyclic, which is why we call it a dag (directed acyclic graph).\r\n            ":"），并包含国家含义的表示。因为我们总是做\r\n            评估测试时的正向进度（状态描述在每个边缘的单调较小），\r\n            状态图是无环，这就是为什么我们将其称为DAG（有向无环图）的原因。\r\n            \r\n","The text of the token including leading and trailing trivia.":"代币的文字在内，包括领导和尾随的琐事。\r\n","\r\n              Looks up a localized string similar to Source interface '{0}' is missing method '{1}' which is required to embed event '{2}'..\r\n            ":"\r\n              查找类似于源界面'{0}'的本地化字符串丢失方法'{1}'，这是嵌入事件'{2}'..所必需的\r\n            \r\n","\r\n            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.\r\n            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.\r\n            ":"\r\n            如果没有过时的属性，则返回从过时属性或null解码的数据。\r\n            该属性返回OmpoleTeatTribedata.Nitialized如果属性参数尚未解码。\r\n            \r\n","Cannot use a lambda expression as an argument to a dynamically dispatched operation without first casting it to a delegate or expression tree type.":"如果不先将其施放给委托或表达树类型，就不能将lambda表达式作为动态调度操作的参数。\r\n","\r\n              Looks up a localized string similar to An expression tree may not contain a null coalescing assignment.\r\n            ":"\r\n              查找类似于表达树的局部字符串可能不包含空合分配。\r\n            \r\n","The variable to be checked":"要检查的变量\r\n","\r\n             is true but the diagnostic is not reported as suppressed.\r\n             ":"\r\n             是真的，但诊断未报告为抑制。\r\n             \r\n","The Conditional attribute is not valid on '{0}' because its return type is not void":"条件属性在“ {0}”上无效，因为其返回类型不是无效的\r\n","An expression tree lambda may not contain a COM call with ref omitted on arguments":"表达树lambda可能不包含com调用，而参数省略了参考\r\n","\r\n            For error recovery, we allow a mismatch between the number of arguments and parameters\r\n            during type inference. This sometimes enables inferring the type for a lambda parameter.\r\n            ":"\r\n            对于错误恢复，我们允许参数数量和参数之间的不匹配\r\n            在类型推理期间。这有时可以推断lambda参数的类型。\r\n            \r\n","\r\n            Add the case label to the subsumption tree. Return true if the label is reachable\r\n            given the expression and previously added labels. `valueMatched` is set to true\r\n            if and only if the label is a reachable unconditional (no when clause) constant pattern\r\n            whose value is the same as the input expression's constant value, and false otherwise.\r\n            ":"\r\n            将案例标签添加到补充树中。如果标签可以返回true\r\n            给定表达式和先前添加的标签。 `valueMatched'设置为true\r\n            当且仅当标签是可触及的无条件（否时）常数模式时\r\n            其值与输入表达式的常数值相同，否则为错误。\r\n            \r\n","\r\n              Looks up a localized string similar to The discard pattern is not permitted as a case label in a switch statement. Use 'case var _:' for a discard pattern, or 'case @_:' for a constant named '_'..\r\n            ":"\r\n              查找类似于丢弃模式的本地化字符串，不允许作为开关语句中的案例标签。使用'case var _：'用于丢弃模式，或“ case @_：”对于一个命名'_'..的常数。\r\n            \r\n","Called when the visitor visits a WarningDirectiveTriviaSyntax node.":"当访客访问警告介维氏节点时，请致电。\r\n","\r\n            Helper method to generate a lowered conversion.\r\n            ":"\r\n            辅助方法生成降低的转化率。\r\n            \r\n","\r\n              Looks up a localized string similar to Type defines operator == or operator != but does not override Object.Equals(object o).\r\n            ":"\r\n              查找类似于类型的局部字符串定义operator ==或operator！= =但不覆盖object.quals.equals（object o）。\r\n            \r\n","\r\n            Check the next token to see if it is valid as the first token of a subpattern element.\r\n            Used to assist in error recovery for subpattern lists (e.g. determining which tokens to skip)\r\n            to ensure we make forward progress during recovery.\r\n            ":"\r\n            检查下一个令牌以查看它是否有效作为Subpattern元素的第一个令牌。\r\n            用于协助subpattern列表的错误恢复（例如，确定要跳过哪个令牌）\r\n            为了确保我们在康复过程中取得进步。\r\n            \r\n","Local name '{0}' is too long for PDB.  Consider shortening or compiling without /debug.":"对于PDB而言，本地名称'{0}'太长了。考虑缩短或编译无 /调试。\r\n","\r\n            Bind a deconstruction assignment.\r\n            ":"\r\n            绑定解构分配。\r\n            \r\n","'{0}' is a binary file instead of a text file":"'{0}'是一个二进制文件，而不是文本文件\r\n","\r\n              Looks up a localized string similar to Since this is an async method, the return expression must be of type '{0}' rather than 'Task<{0}>'.\r\n            ":"\r\n              查找与类似的本地化字符串，因为这是一个异步方法，返回表达式必须是类型为'{0}'而不是'task <{0}>'。\r\n            \r\n","\r\n            We represent the set of query variables in scope at a particular point by a RangeVariableMap.\r\n            Each query variable in scope has a key in this map.  If the corresponding value is empty, then\r\n            that query variable is represented directly by a lambda parameter.  If it is non-empty, then\r\n            to get the value of that query variable one starts with the first parameter of the current\r\n            lambda (the first parameter is always the transparent one), and dot through its members using\r\n            the names in the value list, in reverse order.  So, for example, if the query variable \"x\" has\r\n            a value in this map of [\"Item2\", \"Item1\", \"Item1\"], then the way to compute the value of that\r\n            query variable is starting with the current lambda's first parameter P, compute \"P.Item1.Item1.Item2\".\r\n            See also WithQueryLambdaParametersBinder.\r\n            ":"\r\n            我们通过rangevariablemap在特定点表示范围中的一组查询变量。\r\n            范围中的每个查询变量都有此地图中的键。如果相应的值为空，则\r\n            该查询变量直接由lambda参数表示。如果是非空的，那么\r\n            要获取该查询变量的值，一个从当前的第一个参数开始\r\n            lambda（第一个参数始终是透明的参数），并使用其成员点点\r\n            值列表中的名称，以相反的顺序。因此，例如，如果查询变量“ x”具有\r\n            [“ item2”，“ item1”，“ item1”]的图中的一个值，然后计算其值的方法\r\n            查询变量是从当前Lambda的第一个参数P开始，计算“ P.Item1.item1.item2”。\r\n            另请参见WithQuerylambdaparametersbinder。\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability of reference types in type of parameter doesn't match partial method declaration..\r\n            ":"\r\n              在参数类型中查找类似于参考类型的无效性类似的本地化字符串不匹配部分方法声明。\r\n            \r\n","Feature '{0}' is not available in C# 7.0. Please use language version {1} or greater.":"C＃7.0中不可用功能'{0}'。请使用语言版本{1}或更大。\r\n","\r\n            Given a switch label syntax, get the corresponding label symbol.\r\n            ":"\r\n            给定一个开关标签语法，获取相应的标签符号。\r\n            \r\n","\r\n            If 'symbol' is accessed off of an expression then 'throughTypeOpt' is the type of that\r\n            expression. This is needed to properly do protected access checks. Sets\r\n            \"failedThroughTypeCheck\" to true if this protected check failed.\r\n            ":"\r\n            如果从表达式中访问“符号”，则是“ prypeopt”的类型\r\n            表达。需要正确地进行受保护的访问检查。套\r\n            如果此受保护的检查失败，则“失败的typhypecheck”为true。\r\n            \r\n","\r\n            Creates a token with kind BadToken.\r\n            ":"\r\n            用善良的坏处创建一个令牌。\r\n            \r\n","Attributes on local functions":"本地功能上的属性\r\n"," or any\r\n            nested types of those types.\r\n            ":" 或任何\r\n            这些类型的嵌套类型。\r\n            \r\n","\r\n            The original definition of this symbol. If this symbol is constructed from another\r\n            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in\r\n            source or metadata.\r\n            ":"\r\n            此符号的原始定义。如果此符号是从另一个符号构造的\r\n            符号按类型替换，然后原始定义获得了原始符号的定义\r\n            来源或元数据。\r\n            \r\n","\r\n            Helper for implementing ":"\r\n            用于实施的助手\r\n","\r\n            Allows asking semantic questions about a TypeSyntax (or its descendants) within a member, that did not appear in the original source code.\r\n            Typically, an instance is obtained by a call to SemanticModel.TryGetSpeculativeSemanticModel. \r\n            ":"\r\n            允许在成员中询问有关型典型字母（或其后代）的语义问题，该词性未出现在原始源代码中。\r\n            通常，通过呼叫semanticmodel.trygetspeculativesemanticmodel获得了一个实例。\r\n            \r\n","Tuple type element.":"元组类型元素。\r\n","\r\n              Looks up a localized string similar to The as operator must be used with a reference type or nullable type ('{0}' is a non-nullable value type).\r\n            ":"\r\n              查找类似于AS运算符的本地化字符串必须与参考类型或可确定类型一起使用（'{0}'是不可删除的值类型）。\r\n            \r\n","\r\n            Represents a single item or many items (including none).\r\n            ":"\r\n            代表一个或许多项目（包括无）。\r\n            \r\n","\r\n            If this is an event of a tuple type, return corresponding underlying event from the\r\n            tuple underlying type. Otherwise, null. \r\n            ":"\r\n            如果这是元组类型的事件，请从\r\n            元组基础类型。否则，null。\r\n            \r\n","\r\n              Looks up a localized string similar to optional parameter.\r\n            ":"\r\n              查找类似于可选参数的局部字符串。\r\n            \r\n","\r\n             A mapping from the local variable slot to the symbol for the local variable itself.  This\r\n             is used in the implementation of region analysis (support for extract method) to compute\r\n             the set of variables \"always assigned\" in a region of code.\r\n            \r\n             The first slot, slot 0, is reserved for indicating reachability, so the first tracked variable will\r\n             be given slot 1. When referring to VariableIdentifier.ContainingSlot, slot 0 indicates\r\n             that the variable in VariableIdentifier.Symbol is a root, i.e. not nested within another\r\n             tracked variable. Slots less than 0 are illegal.\r\n             ":"\r\n             从局部变量插槽到局部变量本身的符号的映射。这个\r\n             用于实施区域分析（支持提取方法）以计算\r\n             一组变量在代码区域中“总是分配”。\r\n            \r\n             第一个插槽插槽0保留用于指示可及性，因此第一个跟踪变量将\r\n             给出插槽1.指参考变量识别器。ContainingsLot，插槽0指示\r\n             可变识别符中的变量是词根，即不嵌套在另一个\r\n             跟踪变量。小于0的老虎机是非法的。\r\n             \r\n","\r\n            Represents implicit, script and submission classes.\r\n            ":"\r\n            代表隐式，脚本和提交类。\r\n            \r\n","\r\n            True if the parameter has default argument syntax.\r\n            ":"\r\n            如果参数具有默认参数语法，则为true。\r\n            \r\n","Compilation":"汇编\r\n","No best type found for implicitly-typed array":"没有最佳类型用于隐式型阵列\r\n","Readonly members":"Readonly成员\r\n","\r\n            Simple type name, possibly with generic name mangling.\r\n            ":"简单的类型名称，可能带有通用名称。\r\n            \r\n","\r\n            Gets an ExpressionSyntax representing the expression of the switch statement.\r\n            ":"\r\n            获取代表开关语句的表达式的表达式字母。\r\n            \r\n","Type '{0}' cannot be used in this context because it cannot be represented in metadata.":"在此上下文中不能使用'{0}'，因为它不能在元数据中表示。\r\n","\r\n            Gets the syntax list of custom attributes that declares attributes for return type of this method.\r\n            ":"\r\n            获取自定义属性的语法列表，该属性声明此方法的返回类型的属性。\r\n            \r\n","\r\n            \r\n            The native compiler interprets this in the same way as it would interpret A{T1, T2}.M(T2) and unambiguously\r\n            (i.e. without a warning) binds to A{T, U}.M(U).  Since Roslyn does not distinguish between the T's, Roslyn\r\n            reports an ambiguity warning and picks the first method.  Furthermore, renaming one 'T' will rename all of\r\n            them.\r\n            \r\n            This class represents such an implicitly declared type parameter.  The declaring syntax is expected to be\r\n            an IdentifierNameSyntax in the type argument list of a QualifiedNameSyntax.\r\n        ":"\r\n            \r\n            本地编译器以与解释{t1，t2} .m（t2）和明确的方式解释这一点\r\n            （即没有警告）与{t，u} .m（u）结合。由于罗斯林没有区分T，Roslyn\r\n            报告歧义警告并选择第一种方法。此外，重命名一个“ T”将重命名所有\r\n            他们。\r\n            \r\n            该类代表这种隐式声明的类型参数。宣布的语法预计为\r\n            合格名称列表的类型参数列表中的标识名称列表。\r\n        \r\n",", returns that tree.\r\n            Otherwise, if this node has a non-null parent, then returns the parent's ":"，返回那棵树。\r\n            否则，如果此节点具有非肺父母，则返回父\r\n","A syntax node that represents a parsed attribute. This attribute should not be\r\n            present in the syntax tree associated with this object.":"表示解析属性的语法节点。这个属性不应该是\r\n            存在与此对象关联的语法树中。\r\n","Gets the optional expression body.":"获取可选的表达式主体。\r\n","\r\n            Though there is a method that C# considers to be an implementation of the interface method, that\r\n            method may not be considered an implementation by the CLR.  In particular, implicit implementation\r\n            methods that are non-virtual or that have different (usually fewer) custom modifiers than the\r\n            interface method, will not be considered CLR overrides.  To address this problem, we either make\r\n            them virtual (in metadata, not in C#), or we introduce an explicit interface implementation that\r\n            delegates to the implicit implementation.\r\n            ":"\r\n            尽管有一种方法C＃认为是接口方法的实现，但\r\n            方法不可能被CLR视为实现。特别是隐性实施\r\n            非虚拟或具有不同（通常更少）自定义修饰符的方法\r\n            接口方法将不被视为CLR替代。为了解决这个问题，我们要么\r\n            它们是虚拟的（在元数据中，而不是在C＃中），或者我们引入了一个明确的接口实现\r\n            代表隐式实施。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot return '{0}' by reference because it is read-only.\r\n            ":"查找类似于不能返回'{0}'的本地化字符串，因为它是只读的。\r\n            \r\n","\r\n            Reports all use site errors in special or well known symbols required for anonymous types\r\n            ":"\r\n            报告全部使用匿名类型所需的特殊或已知符号中的站点错误\r\n            \r\n","\r\n            Diagnostic is enabled.\r\n            NOTE: this may be removed as part of https://github.com/dotnet/roslyn/issues/36550\r\n            ":"\r\n            诊断已启用。\r\n            注意：这可以作为https://github.com/dotnet/roslyn/issues/36550的一部分删除\r\n            \r\n"," method, to compare two symbols for equality.\r\n            ":" 方法，比较两个符号的平等符号。\r\n            \r\n","\r\n            This override is essential - it's a base case of the recursive definition.\r\n            ":"\r\n            该覆盖是必不可少的 - 它是递归定义的基本案例。\r\n            \r\n","\r\n            Add an ERR_UnexpectedVariance diagnostic to the diagnostic bag.\r\n            ":"\r\n            在诊断袋中添加ERR_UNExpedVariance诊断。\r\n            \r\n","The contextual keyword 'var' cannot be used in a range variable declaration":"上下文关键字“ var”不能在范围变量声明中使用\r\n","'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have the matching return type of '{3}'.":"'{0}'不实现接口成员'{1}'。 '{2}'无法实现'{1}'，因为它没有'{3}'的匹配返回类型。\r\n","\r\n              Looks up a localized string similar to Cannot apply attribute class '{0}' because it is generic.\r\n            ":"\r\n              查找类似于应用属性类'{0}'的本地化字符串，因为它是通用的。\r\n            \r\n","Identifier '{0}' differing only in case is not CLS-compliant":"标识符'{0}'仅在情况下不符合CLS\r\n","\r\n            C# language version 1.0.\r\n            ":"\r\n            C＃语言版本1.0。\r\n            \r\n","\r\n            Additional types injected by the Expression Evaluator.\r\n            ":"\r\n            表达式评估器注射的其他类型。\r\n            \r\n","'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}'.":"'{0}'不实现接口成员'{1}'。 '{2}'无法实现'{1}'。\r\n","\r\n              Looks up a localized string similar to Generic parameter is definition when expected to be reference {0}.\r\n            ":"\r\n              查找类似于通用参数的本地化字符串，当期望为引用{0}时，是定义。\r\n            \r\n","True to put (double) quotes around the string literal.":"真实地围绕字符串的字样列出（双重）引号。\r\n","\r\n              Looks up a localized string similar to '{0}' is of type '{1}'. A const field of a reference type other than string can only be initialized with null..\r\n            ":"\r\n              查找类似于'{1}'的本地化字符串。字符串以外的参考类型的const字段只能用null初始化。\r\n            \r\n","\r\n            Creates a token with kind NumericLiteralToken from a 4-byte floating point value.\r\n            ":"\r\n            从4字节浮点值创建具有属性数字的令牌。\r\n            \r\n","\r\n              Looks up a localized string similar to Indexing an array with a negative index.\r\n            ":"\r\n              查找类似于索引带有负索引的数组的本地化字符串。\r\n            \r\n","\r\n            Creates a threadsafety element within an xml documentation comment.\r\n            ":"\r\n            在XML文档注释中创建线程安全元素。\r\n            \r\n","Method, operator, or accessor is marked external and has no attributes on it":"方法，操作员或登录器被标记为外部，并且没有属性\r\n","Represents that nothing was specified as a type argument.":"表示没有指定任何类型参数。\r\n","\r\n              Looks up a localized string similar to Type '{0}' from assembly '{1}' cannot be used across assembly boundaries because it has a generic type argument that is an embedded interop type..\r\n            ":"\r\n              在汇编边界上查找类似于“汇编” {1}'类型的局部字符串，因为它具有嵌入式Interop类型。\r\n            \r\n","Called when the visitor visits a SimpleBaseTypeSyntax node.":"当访问者访问一个简单的型号节点时，请致电。\r\n","\r\n            This overload is intended for callers that rely on symbols rather than syntax. The overload\r\n            uses the cached value calculated during binding (from potentially several spans)\r\n            from ":"\r\n            此过载旨在用于依靠符号而不是语法的呼叫者。超负荷\r\n            使用在结合过程中计算出的缓存值（从潜在的几个跨度）\r\n            从\r\n","\r\n            Used to detect circular references like:\r\n            var x = y;\r\n            var y = x;\r\n            ":"\r\n            用于检测圆形引用，例如：\r\n            var x = y;\r\n            var y = x;\r\n            \r\n","\r\n              Looks up a localized string similar to The 'async' modifier can only be used in methods that have a body..\r\n            ":"\r\n              查找类似于“ async”修饰符的局部字符串，只能在具有身体的方法中使用。\r\n            \r\n","\r\n            Based on OutputContext::IsNonAgileField.\r\n            ":"\r\n            基于OutputContext :: Isnonagilefield。\r\n            \r\n","\r\n              Looks up a localized string similar to A field initializer cannot reference the non-static field, method, or property '{0}'.\r\n            ":"\r\n              查找类似于字段初始化器类似的本地化字符串，无法引用非静态字段，方法或属性'{0}'。\r\n            \r\n","The name '{0}' is not in scope on the left side of 'equals'.  Consider swapping the expressions on either side of 'equals'.":"名称“ {0}”不在'equals'的左侧。考虑将表达式交换在“平等”的两侧。\r\n","Use of keyword 'base' is not valid in this context":"在这种情况下，关键字“基础”的使用无效\r\n","Ref extensions":"参考扩展\r\n","\r\n              Looks up a localized string similar to Operator '{0}' cannot be applied to operand '{1}'.\r\n            ":"\r\n              查找类似于操作员'{0}'的本地化字符串，不能应用于操作数'{1}'。\r\n            \r\n","\r\n              Looks up a localized string similar to Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'.\r\n            ":"\r\n              查找类似于不一致的可访问性的本地化字符串：字段类型'{1}'比field'{0}'易于访问。\r\n            \r\n","\r\n              Looks up a localized string similar to Tuple must contain at least two elements..\r\n            ":"\r\n              查找类似于元组的局部字符串必须至少包含两个元素。\r\n            \r\n","Nullability of reference types in type of '{0}' doesn't match implicitly implemented member '{1}'.":"“ {0}”类型中的参考类型的无性性不匹配隐式实现的成员'{1}'。\r\n","Class which represents the syntax node for implicit array creation expression.":"代表隐式数组创建表达式的语法节点的类。\r\n","The array data.":"数组数据。\r\n","Creates a new ElementBindingExpressionSyntax instance.":"创建一个新的元素bindingexpressionsyntax实例。\r\n","\r\n              Looks up a localized string similar to Converting null literal or possible null value to non-nullable type..\r\n            ":"\r\n              查找类似于将null文字或可能的空值转换为不可删除类型的局部字符串。\r\n            \r\n","\r\n            Conversions with nullability and unknown matching any.\r\n            ":"\r\n            转换具有无效性和未知的匹配。\r\n            \r\n","The original top of the binary operations.":"二进制操作的原始顶部。\r\n","\r\n              Looks up a localized string similar to An __arglist parameter must be the last parameter in a formal parameter list.\r\n            ":"\r\n              查找类似于__arglist参数的本地化字符串必须是正式参数列表中的最后一个参数。\r\n            \r\n","'{0}' is already listed in the interface list on type '{2}' as '{1}'.":"'{0}'已经在类型'{2}'as'{1}'的接口列表中列出。\r\n","The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.":"应用于参数'{0}'的callermembernameattribute将无效。它被callerfilepathatribute覆盖。\r\n","\r\n            Additional data or behavior beyond the core TypeWithAnnotations.\r\n            ":"\r\n            核心打字量拨动超出的其他数据或行为。\r\n            \r\n","\r\n            Creates the syntax representation of a placeholder element within xml documentation comments.\r\n            ":"\r\n            在XML文档注释中创建占位符元素的语法表示。\r\n            \r\n","\r\n            Lexer entry point for LexerMode.XmlCrefQuote, LexerMode.XmlCrefDoubleQuote, \r\n            LexerMode.XmlNameQuote, and LexerMode.XmlNameDoubleQuote.\r\n            ":"\r\n            lexermode.xmlcrefquote，lexermode.xmlcrefdoublequote，lexermode.xmlcrefquote，\r\n            lexermode.xmlnamequote和lexermode.xmlnameDoublequote。\r\n            \r\n","Security attribute '{0}' cannot be applied to an Async method.":"安全属性'{0}'不能应用于异步方法。\r\n","\r\n            Given a syntax node that declares an expression body, get the corresponding symbol.\r\n            ":"\r\n            给定一个声明表达式的语法节点，获取相应的符号。\r\n            \r\n","The text of the statement.":"语句的文字。\r\n","\r\n              Looks up a localized string similar to Sub-expression cannot be used in an argument to nameof..\r\n            ":"\r\n              查找类似于子表达的本地化字符串在参数中不能使用。\r\n            \r\n","If specified, only load attributes that match this predicate, and any diagnostics produced will be dropped.":"如果指定，仅将匹配该谓词的负载属性和所产生的任何诊断属性删除。\r\n","Revision":"修订\r\n","\r\n              Looks up a localized string similar to Parameter {0} should not be declared with the '{1}' keyword.\r\n            ":"\r\n              查找类似于参数{0}的本地化字符串，不应使用'{1}'关键字声明。\r\n            \r\n","\r\n            Get the warnings for unused fields.  This should only be fetched when all method bodies have been compiled.\r\n            ":"\r\n            获取未使用领域的警告。只有在所有方法的汇编时，才能提取这一点。\r\n            \r\n","Different #pragma checksum values given":"给定的不同#pragma校验和值\r\n","The assembly containing the signature referring to the destination type.":"包含签名类型的签名的组件。\r\n","\r\n            Creates the syntax representation of an xml text that contains a newline token with a documentation comment \r\n            exterior trivia at the end (continued documentation comment).\r\n            ":"\r\n            创建XML文本的语法表示，该文本包含带有文档注释的newline令牌\r\n            最后的琐事（持续文档评论）。\r\n            \r\n","Elements cannot be null.":"元素不能无效。\r\n","Syntax error; value expected":"语法错误；预期的价值\r\n","\r\n            Returns true if the node is in a tree location that is expected to be a type\r\n            ":"\r\n            如果节点位于树的位置，则返回true\r\n            \r\n","path is too long or invalid":"路径太长或无效\r\n"," modifier. Still returns true if member was declared to override\r\n            something, but (erroneously) no member to override exists.\r\n            ":" 修饰符。如果宣布成员覆盖，仍然返回真实\r\n            但是（错误地）没有成员覆盖。\r\n            \r\n","A switch expression or case label must be a bool, char, string, integral, enum, or corresponding nullable type in C# 6 and earlier.":"开关表达式或案例标签必须是C＃6和更早的Bool，Char，String，积分，枚举或相应的无效类型。\r\n","\r\n            Offset assigned to the field when the containing type is laid out by the VM.\r\n            Null if unspecified.\r\n            ":"\r\n            当VM布置包含类型时，分配给字段的偏移量。\r\n            null如果未指定。\r\n            \r\n","\r\n            Creates a returns element within an xml documentation comment.\r\n            ":"\r\n            在XML文档注释中创建返回元素。\r\n            \r\n","\r\n            Symbol for the canonical type or an ErrorTypeSymbol. Never returns null.\r\n            ":"\r\n            规范类型或错误型符号的符号。永远不会返回零。\r\n            \r\n","\r\n            Gets the name of the local variable.\r\n            ":"\r\n            获取本地变量的名称。\r\n            \r\n","Invalid variance: The type parameter '{1}' must be {3} valid on '{0}' unless language version '{4}' or greater is used. '{1}' is {2}.":"无效的方差：类型参数'{1}'必须在'{0}'上有效{3}'，除非使用语言版本'{4}'或更大的使用。 '{1}'是{2}。\r\n","\r\n              Looks up a localized string similar to Parameters or locals of type '{0}' cannot be declared in async methods or lambda expressions..\r\n            ":"\r\n              查找类似于“ {0}”类型的参数或当地人的本地化字符串，在异步方法或lambda表达式中无法声明。\r\n            \r\n","\r\n            Check for custom modifiers within the specified TypeSymbol.\r\n            Potentially true for arrays, pointers, and generic instantiations.\r\n            ":"\r\n            在指定的Typesymbol中检查自定义修饰符。\r\n            对于阵列，指针和通用实例，可能是正确的。\r\n            \r\n","\r\n            Determines if the given type is a valid attribute parameter type.\r\n            ":"\r\n            确定给定类型是否是有效的属性参数类型。\r\n            \r\n","\r\n            Represents an ExternAlias directive syntax, e.g. \"extern alias MyAlias;\" with specifying \"/r:MyAlias=SomeAssembly.dll \" on the compiler command line.\r\n            ":"\r\n            代表外部词指令语法，例如“外部别名Myalias；”在编译器命令行上指定“ /r：myalias = someassembly.dll”。\r\n            \r\n","\r\n            The expressions returned from a lambda are not converted though, so we'll have to classify fresh conversions.\r\n            Note: even if some conversions fail, we'll proceed to infer top-level nullability. That is reasonable in common cases.\r\n            ":"\r\n            但是，从lambda返回的表达式并未转换，因此我们必须对新的转换进行分类。\r\n            注意：即使某些转换失败，我们也会继续推断顶级无效性。在常见情况下这是合理的。\r\n            \r\n","Assembly and module attributes are not allowed in this context":"在此上下文中不允许组装和模块属性\r\n","Lambda discard parameters":"lambda丢弃参数\r\n","\r\n            This instance checks whether two signatures match including tuples names, in both return type and parameters.\r\n            It is used to detect tuple-name-only differences.\r\n            ":"\r\n            此实例在返回类型和参数中检查两个签名是否匹配，包括元组名称。\r\n            它用于检测仅元组名称的差异。\r\n            \r\n","\r\n              Looks up a localized string similar to ref conditional expression.\r\n            ":"\r\n              查找类似于参考条件表达式的局部字符串。\r\n            \r\n","\r\n            Creates a new compilation without any syntax trees. Preserves metadata info\r\n            from this compilation for use with trees added later. \r\n            ":"\r\n            创建一个没有任何语法树的新汇编。保留元数据信息\r\n            从此汇编中，以与树一起添加。\r\n            \r\n","\r\n            The purpose of this function is to assert that the ":"\r\n            此功能的目的是断言\r\n","SeparatedSyntaxList of ParameterSyntaxes representing the list of parameters and return type.":"分隔的参数字符列表表示参数列表和返回类型。\r\n","\r\n            Implement C# definite assignment.\r\n            ":"\r\n            实施C＃确定分配。\r\n            \r\n","\r\n            A common base class for lowering constructs that use pattern-matching.\r\n            ":"\r\n            用于降低使用图案匹配的构造的通用基类。\r\n            \r\n","The expression over which to iterate.":"迭代的表达。\r\n","\r\n            Returns true if this type is equal or derives from a given type.\r\n            ":"\r\n            如果此类型相等或派生自给定类型，则返回 true。\r\n            \r\n","\r\n            Given an member declaration syntax, get the corresponding symbol.\r\n            ":"\r\n            给定一个成员声明语法，获取相应的符号。\r\n            \r\n","\r\n             Rewrite `GetTuple() == (1, 2)` to `tuple.Item1 == 1 && tuple.Item2 == 2`.\r\n             Also supports the != operator, nullable and nested tuples.\r\n            \r\n             Note that all the side-effects for visible expressions are evaluated first and from left to right. The initialization phase\r\n             contains side-effects for:\r\n             - single elements in tuple literals, like `a` in `(a, ...) == (...)` for example\r\n             - nested expressions that aren't tuple literals, like `GetTuple()` in `(..., GetTuple()) == (..., (..., ...))`\r\n             On the other hand, `Item1` and `Item2` of `GetTuple()` are not saved as part of the initialization phase of `GetTuple() == (..., ...)`\r\n            \r\n             Element-wise conversions occur late, together with the element-wise comparisons. They might not be evaluated.\r\n             ":"\r\n             重写`getTuple（）==（1，2）`to` tuple.item1 == 1 && tuple.item2 == 2`。\r\n             还支持！=操作员，无效和嵌套的元组。\r\n            \r\n             请注意，所有可见表达式的副作用将首先和从左到右评估。初始化阶段\r\n             包含：\r\n              - 元组文字中的单个元素，例如'a` in'（a，...）==（...）`例如\r\n              - 不是元组文字的嵌套表达式，例如`getTuple（）\r\n             另一方面，``getTuple（）``item1`和'item2`没有作为`getTuple（）==（...，...）的初始化阶段的一部分保存。\r\n            \r\n             元素转化率与元素的比较一起迟到。他们可能无法评估。\r\n             \r\n","'{0}' is not a valid named attribute argument because it is not a valid attribute parameter type":"'{0}'不是有效的命名属性参数，因为它不是有效的属性参数类型\r\n","BoundCall or error expression representing the invocation.":"代表调用的BoundCall或错误表达式。\r\n","The type '{2}' must be a non-nullable value type in order to use it as parameter '{1}' in the generic type or method '{0}'":"类型的'{2}'必须是不可删除的值类型，以便将其用作parameter'{1}'\r\n","The semantic information for the topmost node of the constructor initializer.":"构造函数初始化器最高节点的语义信息。\r\n","SyntaxToken representing colon.":"Syntaxtoken代表Colon。\r\n","\r\n            Gets the syntax list of custom attributes applied on the symbol.\r\n            ":"\r\n            获取在符号上应用自定义属性的语法列表。\r\n            \r\n","\r\n            An enumerator for diagnostic lists.\r\n            ":"\r\n            用于诊断列表的枚举器。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor.\r\n            ":"\r\n              查找类似于'{0}'：访问者的局部字符串，只有在属性或索引器具有GET和SET登录器时才能使用访问者。\r\n            \r\n","The desired well-known member":"所需的著名成员\r\n","\r\n            Gets the enclosing binder associated with the node\r\n            ":"\r\n            获取与节点关联的封闭粘合剂\r\n            \r\n","Predefined type '{0}' must be a struct.":"预定义的类型“ {0}”必须是结构。\r\n","\r\n            Gets the kind of this type.\r\n            ":"\r\n            得到这种类型的类型。\r\n            \r\n","The binder that was used to bind the given syntax.":"用于结合给定语法的粘合剂。\r\n","\r\n            The returned assembly may also forward the type.\r\n            ":"\r\n            返回的组件也可以转发类型。\r\n            \r\n","ExpressionSyntax node representing the expression on the left of the \"is\" operator.":"表达式元素节点表示“” ocerator的左侧的表达式。\r\n",". Fortunately, logic in it allows us to ignore the presence of\r\n            implementations in interfaces and we use that.\r\n            When the value of this parameter is true and the result that takes presence of implementations in interfaces into account is not\r\n            available from the cache, the lookup will be performed ignoring the presence of implementations in interfaces. Otherwise, result from\r\n            the cache is returned.\r\n            When the value of the parameter is false, the result from the cache is returned, or calculated, taking presence of implementations\r\n            in interfaces into account and then cached.\r\n            This means that:\r\n             - A symbol from an interface can still be returned even when ":"。幸运的是，其中的逻辑使我们能够忽略\r\n            在接口中的实现，我们使用它。\r\n            当此参数的价值为真，并且在接口中存在实现的结果不是\r\n            可从缓存中获得，查找将忽略接口中实现的存在。否则，由\r\n            缓存返回。\r\n            当参数的值为false时，返回或计算得出的缓存结果，取决于实现\r\n            在接口中考虑，然后缓存。\r\n            这意味着：\r\n              - 即使在\r\n","\r\n               Looks up a localized string similar to This warning can be generated when two interface methods are differentiated only by whether a particular parameter is marked with ref or with out. It is best to change your code to avoid this warning because it is not obvious or guaranteed which method is called at runtime.\r\n            \r\n            Although C# distinguishes between out and ref, the CLR sees them as the same. When deciding which method implements the interface, the CLR just picks one.\r\n            \r\n            Give the compiler some way to differentiate the methods. For example, you ca [rest of string was truncated]\";.\r\n             ":"\r\n               查找与此警告相似的本地化字符串，只有通过用REF标记还是用OUND来区分两个接口方法时，才能生成类似的警告。最好更改代码以避免此警告，因为它在运行时不明显或保证哪种方法被调用。\r\n            \r\n            尽管c＃区分了淘汰和参考，但CLR认为它们是相同的。当决定哪种方法实现接口时，CLR只是选择一个。\r\n            \r\n            给编译器一些方法以区分方法。例如，您的ca [弦的其余部分被截断了];。\r\n             \r\n","This async method lacks 'await' operators and will run synchronously. Consider using the 'await' operator to await non-blocking API calls, or 'await Task.Run(...)' to do CPU-bound work on a background thread.":"这种异步方法缺乏“等待”操作员，并且会同步运行。考虑使用“等待”运算符等待非阻止API调用，或“等待任务。\r\n","\r\n            Some preprocessor keywords are only keywords when they appear after a\r\n            hash sign (#).  For these keywords, the lexer will produce tokens with\r\n            Kind = SyntaxKind.IdentifierToken and ContextualKind set to the keyword\r\n            SyntaxKind.\r\n            ":"\r\n            一些预处理器关键字仅是关键字，当它们出现在\r\n            哈希符号（＃）。对于这些关键字，Lexer将与\r\n            kint = syntaxkind.Identifiertoken和ContextionualKind设置为关键字\r\n            语法金。\r\n            \r\n","An object of a type convertible to '{0}' is required":"需要转换为'{0}'的对象\r\n","\r\n              Looks up a localized string similar to constraints for override and explicit interface implementation methods.\r\n            ":"\r\n              查找类似于覆盖和显式接口实现方法的约束的本地化字符串。\r\n            \r\n","\r\n            Given a variable designation syntax, get the corresponding symbol.\r\n            ":"\r\n            给定可变名称语法，获取相应的符号。\r\n            \r\n","\r\n             Produces a clone of a ":"\r\n             产生一个克隆\r\n","\r\n            Register COR types declared in this namespace, if any, in the COR types cache.\r\n            ":"\r\n            在此名称空间中声明的注册COR类型（如果有）在COR类型缓存中。\r\n            \r\n","\r\n            After reading ":"\r\n            看完之后\r\n","\r\n              Looks up a localized string similar to '{0}' is not a reference type as required by the lock statement.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串不是锁定语句要求的参考类型。\r\n            \r\n","\r\n            so that we do not have to go back to source to compute this data.\r\n            ":"\r\n            因此，我们不必返回来源来计算此数据。\r\n            \r\n","\r\n            A parameter to get the default value for.\r\n            ":"\r\n            获取默认值的参数。\r\n            \r\n","Changing the version of an assembly reference is not allowed during debugging: '{0}' changed version to '{1}'.":"在调试过程中不允许更改汇编引用的版本：'{0}'将版本更改为'{1}'。\r\n","Cannot deconstruct a tuple of '{0}' elements into '{1}' variables.":"不能将“ {0}”元素的元组解析为“ {1}”变量。\r\n","\r\n            Find the first parameter named \"argumentName\".\r\n            ":"\r\n            找到名为“参数名称”的第一个参数。\r\n            \r\n","Division by constant zero":"量\r\n","Possible unintended reference comparison; to get a value comparison, cast the left hand side to type '{0}'":"可能的意外参考比较；要获得值比较，请将左侧施放到键入'{0}'\r\n","Return value must be non-null because parameter '{0}' is non-null.":"返回值必须是非编号的，因为参数'{0}'是非null。\r\n","\r\n              Looks up a localized string similar to '{0}' adds an accessor not found in interface member '{1}'.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串，添加了接口成员'{1}'中未找到的登录器。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot return fields of '{0}' by reference because it is a '{1}'.\r\n            ":"\r\n              查找类似于类似的本地化字符串，因为它是'{1}'，因此无法返回“ {0}”的字段。\r\n            \r\n","Called when the visitor visits a ShebangDirectiveTriviaSyntax node.":"当访客访问ShebangdirectiviviaSynyntax节点时，请致电。\r\n","\r\n              Looks up a localized string similar to named argument.\r\n            ":"\r\n              查找类似于命名参数的本地化字符串。\r\n            \r\n","\r\n            If this is a partial method with a body, returns the corresponding\r\n            definition part (without a body).  Otherwise null.\r\n            ":"\r\n            如果这是带有身体的部分方法，请返回相应的\r\n            定义零件（没有身体）。否则为空。\r\n            \r\n","\r\n              Looks up a localized string similar to A local or parameter named '{0}' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter.\r\n            ":"\r\n              在此范围中查找类似于名为“ {0}”本地或参数的本地化字符串，因为该名称在封闭的本地范围中使用以定义本地或参数。\r\n            \r\n","Called when the visitor visits a DestructorDeclarationSyntax node.":"当访问者访问destructordeclarationsyntax节点时打电话。\r\n","\r\n            Creates a function pointer method symbol from individual parts. This method should only be used when diagnostics are not needed.\r\n            This should only be used from testing code.\r\n            ":"\r\n            从各个部分创建功能指针方法符号。仅在不需要诊断时才能使用此方法。\r\n            这仅应从测试代码中使用。\r\n            \r\n","\r\n              Looks up a localized string similar to This error occurs when a predefined system type such as System.Int32 is found in two assemblies. One way this can happen is if you are referencing mscorlib or System.Runtime.dll from two different places, such as trying to run two versions of the .NET Framework side-by-side..\r\n            ":"\r\n              当在两个组件中找到INT32等预定义的系统类型时，请查找类似于此错误的本地化字符串。这可能发生的一种方法是，如果您是从两个不同的位置引用mscorlib或system.runtime.dll，例如尝试并排运行.NET Framework的两个版本。\r\n            \r\n","Syntax tree already present":"语法树已经存在\r\n","Changes must be within bounds of SourceText":"更改必须在Sourcetext的范围内\r\n","\r\n            If a methodimpl record indicates a unique overridden method, that method. Otherwise null.\r\n            ":"\r\n            如果methodimpl记录指示了一种唯一的覆盖方法，则该方法。否则为空。\r\n            \r\n","\r\n            Returns true if this local variable is declared as iteration variable\r\n            ":"\r\n            如果将此本地变量声明为迭代变量，则返回true\r\n            \r\n","\r\n            Return the bound expression if the lambda has an expression body and can be reused easily.\r\n            This is an optimization only. Implementations can return null to skip reuse.\r\n            ":"\r\n            如果lambda具有表达式主体，并且可以轻松重复使用，则返回绑定的表达式。\r\n            这仅是优化。实现可以返回NULL以跳过重复使用。\r\n            \r\n","Create a Range object starting from start index to the end of the collection.":"创建一个从启动索引到集合末尾开始的范围对象。\r\n","\r\n            WARN: Must not check method.MethodKind - PEMethodSymbol.ComputeMethodKind uses this method.\r\n            NOTE: Does not check whether the given method will be marked \"newslot\" in metadata (which\r\n            would indicate that it does not override anything).\r\n            WARN: If the method may override a source method and declaration diagnostics have yet to\r\n            be computed, then it is important to pass ignoreInterfaceImplementationChanges: true\r\n            (see MethodSymbol.IsMetadataVirtual for details).\r\n            ":"警告：不得检查方法。Methodkind-pemethodsymbol.computemethodkind使用此方法。\r\n            注意：不要检查给定方法是否会在元数据中标记为“ newslot”（哪个\r\n            会表明它不会覆盖任何东西）。\r\n            警告：如果该方法可以覆盖源方法，声明诊断尚未\r\n            被计算，然后通过忽略InterinterfaceImplementationChanges：true很重要\r\n            （有关详细信息，请参见Methodsymbol.ismetadatavirual）。\r\n            \r\n","Quoted file name, single-line comment or end-of-line expected":"引用文件名，单线评论或预期的终结\r\n","'{0}': a class with the ComImport attribute cannot specify a base class":"'{0}'：带有comimport属性的类无法指定基类\r\n"," Bound node, not null ":" 绑定节点，而不是null\r\n","\r\n            See SymbolPreparer::checkIfaceHiding.\r\n            ":"\r\n            请参阅SymbolPreparer :: CheckIfaceHiding。\r\n            \r\n","Cannot convert type '{0}' to '{1}'":"不能将类型的'{0}'转换为'{1}'\r\n","__arglist is not allowed in the parameter list of async methods":"__ Arglist不允许在异步方法的参数列表中\r\n","You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement.":"您不能使用未固定表达式中包含的固定尺寸缓冲区。尝试使用固定语句。\r\n","\r\n              Looks up a localized string similar to XML comment has a typeparam tag, but there is no type parameter by that name.\r\n            ":"查找类似于XML注释的本地化字符串具有Typeparam标签，但是该名称没有类型的参数。\r\n            \r\n","\r\n            Returns true if the Unicode character can be the starting character of a C# identifier.\r\n            ":"如果Unicode字符可以是C＃标识符的启动字符，则返回true。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': containing type does not implement interface '{1}'.\r\n            ":"\r\n              查找类似于'{0}'：包含类型的本地化字符串不会实现接口'{1}'。\r\n            \r\n","Called when the visitor visits a TypeParameterListSyntax node.":"当访问者访问TypeparameterListsyntax节点时，请致电。\r\n","Creates a new PrefixUnaryExpressionSyntax instance.":"创建一个新的prefixunary expressionsyntax实例。\r\n","\r\n            Parse a C# language token.\r\n            ":"\r\n            解析C＃语言令牌。\r\n            \r\n","\r\n              Looks up a localized string similar to Since '{1}' has the ComImport attribute, '{0}' must be extern or abstract.\r\n            ":"\r\n              查找类似于“ {1}'具有comimport属性”的本地化字符串，{0}'必须是外部或抽象。\r\n            \r\n","\r\n              Looks up a localized string similar to Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect.\r\n            ":"\r\n              查找类似于源文件的本地化字符串超过了PDB中可表示的16,707,565行的限制。调试信息将是不正确的。\r\n            \r\n","An object to compare with this object":"与此对象进行比较的对象\r\n","\r\n            Helper method to create a synthesized constructor invocation.\r\n            ":"\r\n            创建合成的构造函数调用的帮助方法。\r\n            \r\n","\r\n            Visit the tree with the given root and run the ":"\r\n            访问给定的根并运行\r\n","Creates a new OperatorDeclarationSyntax instance.":"创建一个新的OperatoDeclarationsyntax实例。\r\n","\r\n            REMOVAL OR CHANGES TO EXISTING VALUES IS CONSIDERED A BREAKING CHANGE FOR PDB FORMAT\r\n            ":"\r\n            删除或对现有值的更改被认为是PDB格式的破坏变化\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static, or const, or read-write properties which are public and not static..\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串不是有效的命名属性参数。命名属性参数必须是不读取，静态或const或读取属性的字段，这些属性是公共而不是静态的。\r\n            \r\n","\r\n            Get a SemanticModel object that is associated with an attribute that did not appear in\r\n            this source code. This can be used to get detailed semantic information about sub-parts\r\n            of an attribute that did not appear in source code.\r\n            ":"\r\n            获取与未出现在\r\n            此源代码。这可以用来获取有关子部分的详细语义信息\r\n            未出现在源代码中的属性。\r\n            \r\n","\r\n            True if we need to generate the code to do the bookkeeping so we can \"finalize\" the state machine\r\n            by executing code from its current state through the enclosing finally blocks.  This is true for\r\n            iterators and false for async.\r\n            ":"\r\n            如果我们需要生成代码进行簿记，则是真的，我们可以“最终确定”状态机器\r\n            通过从其当前状态执行代码，通过封闭方式最终阻止。这是正确的\r\n            迭代器和false insync。\r\n            \r\n","\r\n            Generate ":"\r\n            产生\r\n","\r\n            Nullability flow analysis.\r\n            ":"\r\n            无效流分析。\r\n            \r\n","'{0}' is not a reference type as required by the lock statement":"'{0}'不是锁定语句要求的参考类型\r\n","\r\n              Looks up a localized string similar to Alignment value {0} has a magnitude greater than {1} and may result in a large formatted string..\r\n            ":"\r\n              查找类似于对齐值{0}的局部字符串大于{1}，可能会导致一个大格式的字符串。\r\n            \r\n"," is known to be valid, or it will throw.\r\n            ":" 已知有效，否则会抛出。\r\n            \r\n","\r\n            Return the constant value dependencies. Compute the dependencies\r\n            if necessary by evaluating the constant value but only persist the\r\n            constant value if there were no dependencies. (If there are dependencies,\r\n            the constant value will be re-evaluated after evaluating dependencies.)\r\n            ":"\r\n            返回恒定值依赖性。计算依赖项\r\n            如有必要，通过评估恒定值，但仅持续\r\n            如果没有依赖性，则恒定值。 （如果有依赖性，\r\n            评估依赖性后，将重新评估恒定值。）\r\n            \r\n","\r\n            The current context is an expression tree\r\n            ":"\r\n            当前的上下文是一个表达树\r\n            \r\n","The children of this node must already be lowered.":"该节点的孩子必须已经降低。\r\n","\r\n            Ensure that ":"\r\n            确保这件事\r\n","The token kind to be assigned to the resulting token":"将代币分配给由此产生的令牌\r\n","Information on lambdas defined in ":"有关lambdas定义的信息\r\n","Type that we'll try to find member in.":"输入我们将尝试在其中找到成员。\r\n","Deconstruction":"解构\r\n","A character position used to identify a declaration scope and accessibility. This\r\n            character position must be within the FullSpan of the Root syntax node in this SemanticModel.":"用于标识声明范围和可访问性的角色位置。这个\r\n            字符位置必须在此semanticmodel中的root语法节点的成面内。\r\n","\r\n            Indicates if this particular attribute application should be considered optional.\r\n            ":"\r\n            指示该特定属性应用程序是否应视为可选的。\r\n            \r\n","\r\n            In the presence of non-C# types, the meaning of \"same signature\" is rather\r\n            complicated.  If this member isn't from source, then it refers to the runtime's\r\n            notion of signature (i.e. including return type, custom modifiers, etc).\r\n            If this member is from source, then the process is (conceptually) as follows.\r\n            \r\n            1) Walk up the type hierarchy, recording all matching members with the same\r\n               signature, ignoring custom modifiers and return type.  Stop if a hidden\r\n               member is encountered.\r\n            2) Apply the following \"tie-breaker\" rules until you have at most one member,\r\n               a) Prefer members in more derived types.\r\n               b) Prefer an exact custom modifier match (i.e. none, for a source member).\r\n               c) Prefer fewer custom modifiers (values/positions don't matter, just count).\r\n               d) Prefer earlier in GetMembers order (within the same type).\r\n            3) If a member remains, search its containing type for other members that\r\n               have the same C# signature (overridden members) or runtime signature\r\n               (runtime overridden members).\r\n            \r\n            In metadata, properties participate in overriding only through their accessors.\r\n            That is, property/event accessors may implicitly or explicitly override other methods\r\n            and a property/event can be considered to override another property/event if its accessors\r\n            override those of the other property/event.\r\n            This implementation (like Dev10) will not follow that approach.  Instead, it is\r\n            based on spec section 10.7.5, which treats properties as entities in their own\r\n            right.  If all property/event accessors have conventional names in metadata and nothing\r\n            \"unusual\" is done with explicit overriding, this approach should produce the same\r\n            results as an implementation based on accessor overriding.\r\n            ":"\r\n            在存在非C＃类型的情况下，“相同签名”的含义是\r\n            复杂。如果此成员不是来自源的，则指运行时的\r\n            签名概念（即包括返回类型，自定义修饰符等）。\r\n            如果此成员来自源，则该过程（概念上）如下。\r\n            \r\n            1）走上类型层次结构，记录所有匹配成员\r\n               签名，忽略自定义修饰符和返回类型。如果隐藏\r\n               会员遇到。\r\n            2）应用以下“打破打决”规则，直到您最多有一个成员为止\r\n               a）更喜欢更派生类型的成员。\r\n               b）更喜欢精确的自定义修饰符匹配（即无，对于源成员）。\r\n               c）更喜欢更少的自定义修饰符（值/位置无关紧要，只需计数）。\r\n               d）在GetMembers Order（在同一类型中）中更早。\r\n            3）如果剩下成员，请搜索其包含类型的其他成员\r\n               具有相同的C＃签名（覆盖成员）或运行时签名\r\n               （运行时覆盖成员）。\r\n            \r\n            在元数据中，物业仅通过其登录器参与覆盖。\r\n            也就是说，属性/事件访问者可以隐式或明确覆盖其他方法\r\n            并且可以考虑属性/事件，以覆盖另一个属性/事件，如果其访问者\r\n            覆盖其他物业/事件的内容。\r\n            此实现（例如DEV10）将不遵循该方法。相反，是\r\n            基于规格第10.7.5节，该节将属性视为实体\r\n            正确的。如果所有属性/事件访问者在元数据中都有常规名称，而无需\r\n            “不寻常”是通过明确的覆盖来完成的，这种方法应产生相同的\r\n            结果作为基于登录器覆盖的实现。\r\n            \r\n","\r\n            is state information for the local function that was just visited. ":"\r\n            是刚刚访问的本地功能的状态信息。\r\n","True if the return type has suitable members.":"如果返回类型具有合适的成员，则为是。\r\n","\r\n              Looks up a localized string similar to Interfaces cannot contain fields.\r\n            ":"\r\n              查找类似于接口的本地化字符串不能包含字段。\r\n            \r\n","\r\n              Looks up a localized string similar to Unsafe code may not appear in iterators.\r\n            ":"\r\n              查找类似于不安全代码的本地化字符串可能不会出现在迭代器中。\r\n            \r\n","Named argument specifications must appear after all fixed arguments have been specified in a dynamic invocation.":"在动态调用中指定了所有固定参数后，必须出现命名参数规范。\r\n","c == f":"c == f\r\n","'{0}' cannot define an overloaded {1} that differs only on parameter modifiers '{2}' and '{3}'":"'{0}'无法定义仅在参数修饰符'{2}'和'{3}''和'{3}'上的超载{1}'\r\n","\r\n            A symbol reference that definitely refers to a type.\r\n            For example, \"int\", \"A::B\", \"A.B\", \"A<T>\", but not \"M()\" (has parameter list) or \"this\" (indexer).\r\n            NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax\r\n            will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol\r\n            might be a non-type member.\r\n            ":"\r\n            绝对是指类型的符号引用。\r\n            例如，“ int”，“ a :: b”，“ a.b”，“ a <t>”，而不是“ m（）”（具有参数列表）或“ this”（indexer）。\r\n            注意：typecrefsyntax，合格crefsyntax和成员crefsyntax重叠。 typecrefsyntax中的语法\r\n            始终将被绑定为类型，因此使用合格的crefsyntax或成员crefsyntax是更安全的\r\n            可能是非型成员。\r\n            \r\n","\r\n              Looks up a localized string similar to A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a System.Runtime.CompilerServices.RuntimeWrappedException..\r\n            ":"\r\n              查找类似于以前的捕获子句的本地化字符串已经捕获所有异常。所有不删除的抛出都将包裹在系统中。runtime.compilerServices.RuntimeWrappedException..\r\n            \r\n","\r\n            This is a clone of the Dev10 logic for reporting query errors.\r\n            ":"这是用于报告查询错误的DEV10逻辑的克隆。\r\n            \r\n","\r\n            Loop over the DocumentationCommentTriviaSyntaxes.  Gather\r\n              1) concatenated XML, as a string;\r\n              2) whether or not the XML is valid;\r\n              3) set of type parameters covered by <typeparam> elements;\r\n              4) set of parameters covered by <param> elements;\r\n              5) list of <include> elements, as SyntaxNodes.\r\n            ":"\r\n            循环浏览DocumentationCommentTriviaSysynaxes。收集\r\n              1）串联XML，作为字符串；\r\n              2）XML是否有效；\r\n              3）<typeparam>元素覆盖的类型参数集；\r\n              4）<param>元素覆盖的一组参数；\r\n              5）<clud是否>元素的列表，作为语法。\r\n            \r\n","\r\n            Field specific to a non-speculative MemberSemanticModel that must have a containing semantic model.\r\n            ":"\r\n            特定于必须具有包含语义模型的非规范成员的字段。\r\n            \r\n","#load is only allowed in scripts":"#load仅在脚本中允许\r\n","\r\n              Looks up a localized string similar to iterators.\r\n            ":"\r\n              查找类似于迭代器的本地化字符串。\r\n            \r\n","\r\n            Pre-order depth-first search.\r\n            ":"\r\n            预购深度优先搜索。\r\n            \r\n","\r\n              Looks up a localized string similar to Argument {0} may not be passed with the '{1}' keyword.\r\n            ":"\r\n              查找类似于参数{0}的本地化字符串可能不会使用'{1}'关键字传递。\r\n            \r\n","\r\n              Looks up a localized string similar to Bitwise-or operator used on a sign-extended operand.\r\n            ":"\r\n              查找类似于签名操作数上使用的位置或操作员的本地化字符串。\r\n            \r\n","\r\n            Requires less computation than ":"\r\n            比计算要少于\r\n","\r\n            The underlying FieldSymbol, cannot be another RetargetingFieldSymbol.\r\n            ":"\r\n            基础野外符号不能是另一个retargetingfieldsymbol。\r\n            \r\n","\r\n            Scan a single cref attribute token.  Assumes that leading trivia has already\r\n            been consumed.\r\n            ":"\r\n            扫描单个CREF属性令牌。假设领导琐事已经\r\n            被消耗了。\r\n            \r\n","Code page '{0}' is invalid or not installed":"代码页'{0}'是无效或未安装的\r\n","\r\n            This is where we calculate ":"\r\n            这是我们计算的地方\r\n","Steps into trivia if this is not null.  Only trivia for which this delegate returns\r\n            true are included.":"如果这不是零，则进入琐事。只有这个代表返回的琐事\r\n            包括正确。\r\n","Cannot modify the result of an unboxing conversion":"无法修改拆箱转换的结果\r\n","\r\n              Looks up a localized string similar to Introducing a 'Finalize' method can interfere with destructor invocation.\r\n            ":"\r\n              查找类似于引入“最终确定”方法的本地化字符串可能会干扰Destructor调用。\r\n            \r\n","Accumulates errors (e.g. access \"this\" in constructor initializer).":"累积错误（例如，在构造函数初始化器中访问“此”）。\r\n","\r\n             The interesting part in the following method is the support for exception filters. \r\n             === Example:\r\n            \r\n             try\r\n             {\r\n                TryBlock\r\n             }\r\n             catch (ExceptionType ex) when (Condition)\r\n             {\r\n                Handler\r\n             }\r\n            \r\n             gets emitted as something like ===>\r\n            \r\n             Try\r\n                 TryBlock\r\n             Filter \r\n                 var tmp = Pop() as {ExceptionType}\r\n                 if (tmp == null)\r\n                 {\r\n                     Push 0\r\n                 }\r\n                 else\r\n                 {\r\n                     ex = tmp\r\n                     Push Condition ? 1 : 0\r\n                 }\r\n             End Filter // leaves 1 or 0 on the stack\r\n             Catch      // gets called after finalization of nested exception frames if condition above produced 1\r\n                 Pop    // CLR pushes the exception object again\r\n                 variable ex can be used here\r\n                 Handler\r\n             EndCatch\r\n             \r\n             When evaluating `Condition` requires additional statements be executed first, those\r\n             statements are stored in `catchBlock.ExceptionFilterPrologueOpt` and emitted before the condition.\r\n             ":"以下方法中有趣的部分是支持异常过滤器。\r\n             ===示例：\r\n            \r\n             尝试\r\n             {\r\n                tryblock\r\n             }\r\n             当（条件）时捕获（异常）\r\n             {\r\n                处理程序\r\n             }\r\n            \r\n             被排放为===>\r\n            \r\n             尝试\r\n                 tryblock\r\n             筛选\r\n                 var tmp = pop（）as {exceptionType}\r\n                 if（tmp == null）\r\n                 {\r\n                     推0\r\n                 }\r\n                 别的\r\n                 {\r\n                     ex = tmp\r\n                     推送条件？ 1：0\r\n                 }\r\n             结束滤镜//堆栈上的1或0留在1或0\r\n             捕获//在最终确定嵌套异常框架后被调用，如果以上产生的条件1\r\n                 pop // clr再次推动异常对象\r\n                 可变EX可以在此处使用\r\n                 处理程序\r\n             端捕\r\n             \r\n             评估“条件”需要首先执行其他语句\r\n             语句存储在`catchblock.exceptionfilterprologueopt`中，并在情况前发出。\r\n             \r\n","ref dynamic":"ref动态\r\n","\r\n              Looks up a localized string similar to Literal of type double cannot be implicitly converted to type '{1}'; use an '{0}' suffix to create a literal of this type.\r\n            ":"\r\n              查找类似于类型Double的本地化字符串，不能隐式转换为'{1}';使用“ {0}”后缀创建这种类型的文字。\r\n            \r\n","\r\n            Represents a field that is based on another field.\r\n            When inheriting from this class, one shouldn't assume that \r\n            the default behavior it has is appropriate for every case.\r\n            That behavior should be carefully reviewed and derived type\r\n            should override behavior as appropriate.\r\n            ":"\r\n            表示基于另一个字段的字段。\r\n            从这个课程继承时，不应该假设\r\n            它具有的默认行为适用于每种情况。\r\n            该行为应仔细审查和派生类型\r\n            应适当地覆盖行为。\r\n            \r\n","\r\n            Since branches cannot branch into constructs, only out, we save the pending branches\r\n            when visiting more nested constructs.  When tracking exceptions, we store the current\r\n            state as the exception state for the following code.\r\n            ":"\r\n            由于分支不能只分支到构造中，因此我们保存了待处理的分支机构\r\n            访问更多嵌套构造时。跟踪异常时，我们存储电流\r\n            状态为以下代码的例外状态。\r\n            \r\n","'{0}' is not supported by the language":"语言不支持'{0}'\r\n","\r\n            The base class to represent a namespace imported from a PE/module. Namespaces that differ\r\n            only by casing in name are not merged.\r\n            ":"\r\n            代表从PE/模块导入的名称空间的基类。不同的名称空间\r\n            只有通过名称套管才能合并。\r\n            \r\n","\r\n            A type parameter for a synthesized class or method.\r\n            ":"\r\n            合成类或方法的类型参数。\r\n            \r\n","Creates a new XmlPrefixSyntax instance.":"创建一个新的XMLPRefixSyntax实例。\r\n","Class which represents the syntax node for qualified name.":"代表合格名称的语法节点的类。\r\n","ExpressionSyntax representing the operand of the prefix unary expression.":"表达式元素代表前缀Unary表达的操作数。\r\n","\r\n            on attributes with valid attribute usage.\r\n            This method is called by the binder when it is finished binding a set of attributes on the symbol so that\r\n            the symbol can extract data from the attribute arguments and potentially perform validation specific to\r\n            some well known attributes.\r\n            ":"\r\n            在具有有效属性用法的属性上。\r\n            当粘合剂完成绑定符号上的一组属性时，该方法是调用的\r\n            该符号可以从属性参数中提取数据，并可能执行特定于\r\n            一些众所周知的属性。\r\n            \r\n","\r\n            Only used when this is a speculative semantic model.\r\n            ":"\r\n            仅当这是一个投机语义模型时使用。\r\n            \r\n","The uri of the referenced item.":"引用项目的URI。\r\n","The frame for the translated node":"翻译节点的框架\r\n","\r\n              Looks up a localized string similar to A switch expression or case label must be a bool, char, string, integral, enum, or corresponding nullable type.\r\n            ":"\r\n              查找类似于开关表达式或案例标签的本地化字符串必须是布尔，char，string，积分，枚举或相应的无效类型。\r\n            \r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 6.  Please use language version {1} or greater..\r\n            ":"\r\n              查找类似于功能'{0}'的本地化字符串。\r\n            \r\n","Interface type declaration syntax.":"接口类型声明语法。\r\n","\r\n            If the type reference has an associated NullableAttribute, this method\r\n            returns the type transformed to have IsNullable set to true or false\r\n            (but not null) for each reference type in the type.\r\n            ":"\r\n            如果类型参考具有关联的nulleableatTribute，则此方法\r\n            返回转换为具有true或false的类型\r\n            （但不是null）对于类型中的每个参考类型。\r\n            \r\n","\r\n            Type of right operand is used.\r\n            ":"\r\n            使用正确操作数的类型。\r\n            \r\n","The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)":"FieldOffset属性只能放置在标记为structlayout的类型的成员上（layoutkind.spplitic）\r\n","\r\n            Gets the first token of the tree rooted by this node.\r\n            ":"\r\n            获取由该节点扎根的树的第一个令牌。\r\n            \r\n","\r\n            In the CLI, accessors are just regular methods and their overriding/hiding rules are the same as for\r\n            regular methods.  In C#, however, accessors are intimately connected with their corresponding properties.\r\n            Rather than walking up the type hierarchy from the containing type of this accessor, looking for members\r\n            with the same name, MakePropertyAccessorOverriddenOrHiddenMembers delegates to the associated property.\r\n            For an accessor to hide a member, the hidden member must be a corresponding accessor on a property hidden\r\n            by the associated property.  For an accessor to override a member, the overridden member must be a\r\n            corresponding accessor on a property (directly or indirectly) overridden by the associated property.\r\n            \r\n            Example 1:\r\n            \r\n            public class A { public virtual int P { get; set; } }\r\n            public class B : A { public override int P { get { return 1; } } } //get only\r\n            public class C : B { public override int P { set { } } } // set only\r\n            \r\n            C.P.set overrides A.P.set because C.P.set is the setter of C.P, which overrides B.P,\r\n            which overrides A.P, which has A.P.set as a setter.\r\n            \r\n            Example 2:\r\n            \r\n            public class A { public virtual int P { get; set; } }\r\n            public class B : A { public new virtual int P { get { return 1; } } } //get only\r\n            public class C : B { public override int P { set { } } } // set only\r\n            \r\n            C.P.set does not override any method because C.P overrides B.P, which has no setter\r\n            and does not override a property.\r\n            ":"\r\n            在CLI中，访问者只是常规方法，其压倒/隐藏规则与\r\n            常规方法。但是，在C＃中，登录器与其相应属性密切相关。\r\n            而不是走上包含此登录类型的类型层次结构，而是寻找成员\r\n            MakePropertyAccessoroverridendorhiddenMembers以相同的名字代表了相关属性。\r\n            要使登录器隐藏成员，隐藏的成员必须是隐藏属性上的相应访问者\r\n            通过关联属性。对于替补成员的登记器，覆盖成员必须是\r\n            相关属性（直接或间接）属性上的对应访问者被关联属性覆盖。\r\n            \r\n            示例1：\r\n            \r\n            公共类A {public Virtual Int P {get;放; }}}\r\n            公共类B：a {公共覆盖int p {get {return 1; }}} //仅获取\r\n            公共类C：b {public Override int p {set {}}} //仅设置\r\n            \r\n            C.P.集合替代A.P.SET，因为C.P.SET是C.P的设置，它覆盖了B.P，\r\n            覆盖A.P的A.P.设置为设置器。\r\n            \r\n            示例2：\r\n            \r\n            公共类A {public Virtual Int P {get;放; }}}\r\n            公共类B：a {public new new virtual int p {get {return 1; }}} //仅获取\r\n            公共类C：b {public Override int p {set {}}} //仅设置\r\n            \r\n            c.p.set不会覆盖任何方法\r\n            并且不会覆盖财产。\r\n            \r\n","\r\n            The effective interface set and any base interfaces of those\r\n            interfaces. This is AllInterfaces excluding interfaces that are\r\n            only implemented by the effective base type.\r\n            ":"\r\n            有效的接口集和这些的任何基本接口\r\n            接口。这是Allinterfaces，不包括\r\n            仅由有效的基本类型实施。\r\n            \r\n","\r\n            Updates the given SimpleNameSyntax node with the given identifier token.\r\n            This function is a wrapper that calls WithIdentifier on derived syntax nodes.\r\n            ":"\r\n            使用给定标识符令牌更新给定的SimpleNamesyntax节点。\r\n            此功能是一个包装器，可在派生的语法节点上调用WithIdentifier。\r\n            \r\n","The diagnostic '{0}' was given an invalid severity '{1}' in the analyzer config file at '{2}'.":"诊断'{0}'在'{2}'的分析仪配置文件中给出了无效的严重性'{1}'。\r\n","Using 'is' to test compatibility with 'dynamic' is essentially identical to testing compatibility with 'Object'":"使用“ IS”测试与“动态”的兼容性与测试与“对象”的兼容性基本相同\r\n","Static types cannot be used as parameters":"静态类型不能用作参数\r\n","\r\n            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.\r\n            ":"\r\n            如果没有应用属性，则从应用于符号或null的众所周知的属性解码的返回数据。\r\n            \r\n","\r\n            Given a using declaration get the corresponding symbol for the using alias that was introduced.\r\n            ":"\r\n            给定使用声明获取引入的使用别名的相应符号。\r\n            \r\n","\r\n            Does ":"\r\n            做\r\n","'{0}' is a new virtual member in sealed type '{1}'":"'{0}'是密封类型'{1}'中的新虚拟成员\r\n","\r\n            A source method that can have attributes, including a member method, accessor, or local function.\r\n            ":"\r\n            可以具有属性的源方法，包括成员方法，访问者或本地函数。\r\n            \r\n","\r\n            A binder that places the members of a submission class and aliases in scope.\r\n            ":"将提交类和别名的成员放在范围中的活页夹。\r\n            \r\n","\r\n            The method whose body is being analyzed, or the field whose initializer is being analyzed.\r\n            May be a top-level member or a lambda or local function. It is used for\r\n            references to method parameters. Thus, '_symbol' should not be used directly, but\r\n            'MethodParameters', 'MethodThisParameter' and 'AnalyzeOutParameters(...)' should be used\r\n            instead.\r\n            ":"\r\n            正在分析其身体的方法或正在分析初始化器的领域。\r\n            可以是顶级成员，或Lambda或本地功能。它用于\r\n            参考参数。因此，“ _symbol”不应直接使用，而应\r\n            应使用“方法参数”，“方法thisparameter”和“ AnalyzeOutParameters（...）”\r\n            反而。\r\n            \r\n","\r\n              Looks up a localized string similar to Attribute will be ignored in favor of the instance appearing in source.\r\n            ":"\r\n              查找类似于属性的本地化字符串将被忽略，而有利于出现在源中的实例。\r\n            \r\n","\r\n              Looks up a localized string similar to A fixed size buffer field must have the array size specifier after the field name.\r\n            ":"\r\n              查找类似于固定尺寸缓冲区字段的本地化字符串必须具有字段名称之后的数组大小指示符。\r\n            \r\n","\r\n              Looks up a localized string similar to Indexed property '{0}' must have all arguments optional.\r\n            ":"\r\n              查找类似于索引属性'{0}'的本地化字符串必须具有所有参数。\r\n            \r\n","\r\n              Looks up a localized string similar to Expected 'warnings', 'annotations', or end of directive.\r\n            ":"\r\n              查找类似于预期的“警告”，“注释”或指令结束的局部字符串。\r\n            \r\n","\r\n            Compute a hash code for the constructed type. The return value will be\r\n            non-zero so callers can used zero to represent an uninitialized value.\r\n            ":"\r\n            计算构造类型的哈希代码。返回值将是\r\n            非零，因此呼叫者可以使用零来表示非初始化的值。\r\n            \r\n","Unable to load Analyzer assembly":"无法加载分析仪组件\r\n","\r\n            The field being initialized (possibly a backing field of a property), or null if this is a top-level statement in script code.\r\n            ":"\r\n            该字段是初始化的（可能是属性的备份字段），如果是脚本代码中的顶级语句，则该字段为null。\r\n            \r\n","\r\n            Takes a list of pairs of well-known members and constants. The constants\r\n            will be passed to the field/property referenced by the well-known member.\r\n            If the well-known member does not exist in the compilation then no attribute\r\n            will be synthesized.\r\n            ":"\r\n            列出一对知名成员和常数。常数\r\n            将传递给著名成员引用的现场/财产。\r\n            如果汇编中不存在知名成员，则不存在属性\r\n            将合成。\r\n            \r\n","\r\n            Represents a type parameter in a RetargetingModuleSymbol. Essentially this is a wrapper around \r\n            another TypeParameterSymbol that is responsible for retargeting symbols from one assembly to another. \r\n            It can retarget symbols for multiple assemblies at the same time.\r\n            ":"\r\n            表示retargetingModulesymbol中的类型参数。本质上，这是周围的包装纸\r\n            另一个负责从一个组件重新定位符号到另一个组件的typeparametersymbol。\r\n            它可以同时重新定位多个组件。\r\n            \r\n","\r\n              Looks up a localized string similar to The name '{0}' is not in scope on the left side of 'equals'.  Consider swapping the expressions on either side of 'equals'..\r\n            ":"\r\n              查找类似于“ {0}”名称的本地化字符串在“等价”的左侧不在范围内。考虑将表达式交换在“平等”的两侧。\r\n            \r\n","\r\n            If the node is an expression, return the nearest parent node\r\n            with semantic meaning. Otherwise return null.\r\n            ":"\r\n            如果节点是表达式，请返回最近的父节点\r\n            具有语义含义。否则返回null。\r\n            \r\n","\r\n                 (int x, int y) M() { ... }\r\n             ":"\r\n                 （int x，int y）m（）{...}\r\n             \r\n","\r\n              Looks up a localized string similar to Invalid option '{0}' for /debug; must be full or pdbonly.\r\n            ":"\r\n              查找类似于无效选项'{0}'的本地化字符串for /debug;必须是满或pdbonly。\r\n            \r\n","\r\n            Checks whether given expression can escape from the current scope to the `escapeTo`\r\n            In a case if it cannot a bad expression is returned and diagnostics is produced.\r\n            ":"\r\n            检查给定的表达是否可以从当前范围逸出到`eScapeto'\r\n            在情况下，如果无法返回不良表达并产生诊断。\r\n            \r\n","\r\n              Looks up a localized string similar to The switch expression does not handle some null inputs..\r\n            ":"\r\n              查找类似于交换机表达式类似的本地化字符串不会处理某些空输入。\r\n            \r\n","The desired method or null.":"所需的方法或无效。\r\n","\r\n            Returns an instance of a symbol that represents a native integer\r\n            if this underlying symbol represents System.IntPtr or System.UIntPtr.\r\n            For other symbols, throws ":"\r\n            返回代表本机整数的符号的实例\r\n            如果此基础符号代表system.intptr或system.uintptr。\r\n            对于其他符号，投掷\r\n","\r\n            Is the result viable with one or more symbols?\r\n            ":"\r\n            结果有一个或多个符号可行吗？\r\n            \r\n","\r\n            The diagnostic code to be reported when an inferred variable is used\r\n            in its forbidden zone.\r\n            ":"\r\n            使用推断变量时要报告的诊断代码\r\n            在其禁区。\r\n            \r\n","\r\n            Returns false because field can't be virtual.\r\n            ":"\r\n            返回错误，因为字段不能虚拟。\r\n            \r\n","\r\n            Return the slot for a variable, or -1 if it is not tracked (because, for example, it is an empty struct).\r\n            ":"\r\n            返回插槽的变量，如果未跟踪-1，则返回-1（例如，它是一个空结构）。\r\n            \r\n","Ignoring /win32manifest for module because it only applies to assemblies":"忽略 /win32manifest用于模块，因为它仅适用于汇编\r\n","SyntaxToken representing the less than token.":"Syntaxtoken代表少于令牌。\r\n"," \r\n            Comparator being used for stable ordering in anonymous type indices.\r\n            ":" \r\n            比较器用于匿名类型索引稳定订购。\r\n            \r\n"," is not run. This is problematic because \r\n            ":" 不运行。这是有问题的，因为\r\n            \r\n","CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead.":"当应用于返回类型时，CLSCompliant属性没有含义。尝试将其放在方法上。\r\n","\r\n            checks for modifiers whose feature is not available\r\n            ":"\r\n            检查其功能不可用的修饰符\r\n            \r\n","\r\n            Indexes greater than or equal to 0 are references to parameters defined on the containing method or indexer.\r\n            Indexes less than 0 are constants defined on ":"\r\n            索引大于或等于0是对包含方法或索引器定义的参数的引用。\r\n            小于0的索引是定义的常数\r\n","The 4-byte signed integer value to be represented by the returned token.":"4字节签名的整数值将由返回令牌表示。\r\n","\r\n            This method combines final validation (section 7.6.5.1) and delegate compatibility (section 15.2).\r\n            ":"\r\n            此方法结合了最终验证（第7.6.5.1节）和委托兼容性（第15.2节）。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is static..\r\n            ":"\r\n              查找类似于“ {0}'的本地化字符串”不实现接口成员'{1}'。 '{2}'无法实现接口成员，因为它是静态的。\r\n            \r\n","Minor version":"次要版本\r\n","\r\n            Lower any conversions appearing near the top of the bound expression, assuming non-conversions\r\n            appearing below them have already been lowered.\r\n            ":"\r\n            假设不转换，降低出现在绑定表达式顶部附近\r\n            在它们下方出现的已经降低了。\r\n            \r\n","\r\n              Looks up a localized string similar to Expected a script (.csx file) but none specified.\r\n            ":"\r\n              查找类似于预期脚本（.csx文件）的本地化字符串，但没有指定。\r\n            \r\n","The syntax node that declares an expression body.":"声明表达式的语法节点。\r\n","\r\n            Produce a bound block for the expression returned from GetLambdaExpressionBody.\r\n            ":"\r\n            为从getlambdaexpressionbody返回的表达式产生一个绑定块。\r\n            \r\n","\r\n              Looks up a localized string similar to ref for-loop variables.\r\n            ":"查找类似于Ref For-loop变量的本地化字符串。\r\n            \r\n","\r\n            Hit once, before looping begins.\r\n            ":"\r\n            点击一次，在循环开始之前。\r\n            \r\n","\r\n              Looks up a localized string similar to An expression tree may not contain an 'is' pattern-matching operator..\r\n            ":"\r\n              查找类似于表达树的本地化字符串可能不包含“ IS”模式匹配操作员。\r\n            \r\n","\r\n            Marshalling information for return value (FieldMarshal in metadata).\r\n            ":"\r\n            编组信息以获取返回价值（元数据中的fieldmarshal）。\r\n            \r\n","\r\n            Forces binding and decoding of attributes.\r\n            TODO: We should replace methods GetSourceDecodedWellKnownAttributeData and GetNetModuleDecodedWellKnownAttributeData with\r\n            a single method GetDecodedWellKnownAttributeData, which merges DecodedWellKnownAttributeData from source and netmodule attributes.\r\n            ":"\r\n            属性结合和解码的力。\r\n            TODO：我们应该替换方法getercedecodedwellnonningattribedata和getNetModuledecodedeDwellnoningattribitedata\r\n            单个方法getDecodedwellnoningattribedata，该方法从源和NetModule属性合并了解码器noningattribedata。\r\n            \r\n","Invalid return type in XML comment cref attribute":"XML评论CREF属性中无效的返回类型\r\n","Cannot apply attribute class '{0}' because it is abstract":"不能应用属性类'{0}'，因为它是抽象的\r\n"," is valid for the return type of an override method when the overridden method's return type is ":"当覆盖方法的返回类型为时，对于覆盖方法的返回类型有效\r\n","\r\n            Cache the symbol for well-known type System.Type because we use it frequently\r\n            (for attributes).\r\n            ":"\r\n            缓存众所周知类型system.type的符号，因为我们经常使用它\r\n            （对于属性）。\r\n            \r\n","\r\n              Looks up a localized string similar to Do not use 'System.Runtime.CompilerServices.DynamicAttribute'. Use the 'dynamic' keyword instead..\r\n            ":"\r\n              查找类似于不使用“ system.runtime.compilerservices.dynamicattribute”的本地化字符串。改用“动态”关键字。\r\n            \r\n","\r\n            Rewrites nodes in ":"\r\n            重写节点\r\n"," \r\n            Features: LINQ.\r\n            ":" \r\n            功能：linq。\r\n            \r\n","\r\n              Looks up a localized string similar to nullable reference types.\r\n            ":"\r\n              查找类似于无效参考类型的本地化字符串。\r\n            \r\n","Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?":"引入“最终确定”方法会干扰驱动器调用。您是否打算宣布灾难？\r\n","|":"|\r\n","\r\n            Creates a new syntax based off this tree using a new source text.\r\n            ":"\r\n            使用新的源文本在基于该树的基于此树的基础上创建新的语法。\r\n            \r\n","\r\n              Looks up a localized string similar to Friend assembly reference '{0}' is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations..\r\n            ":"\r\n              查找类似于朋友汇编引用'{0}'的本地化字符串无效。坚固的签名组件必须在其InternalSvisibleto声明中指定公共密钥。\r\n            \r\n","Gets the type keyword token (\"class\", \"struct\", \"interface\").":"获取类型关键字令牌（“类”，“ struct”，“ interface”）。\r\n","\r\n            Lookup attribute name in the given binder. By default two name lookups are performed:\r\n                (1) With the provided name\r\n                (2) With an Attribute suffix added to the provided name\r\n            Lookup with Attribute suffix is performed only if LookupOptions.VerbatimAttributeName is not set.\r\n            \r\n            If either lookup is ambiguous, we return the corresponding result with ambiguous symbols.\r\n            Else if exactly one result is single viable attribute type, we return that result.\r\n            Otherwise, we return a non-viable result with LookupResult.NotAnAttributeType or an empty result.\r\n            ":"\r\n            在给定的粘合剂中查找属性名称。默认情况下，执行了两个名称查找：\r\n                （1）提供的名称\r\n                （2）带有属性后缀添加到提供的名称\r\n            只有在未设置lookupoptions.verbatimattributename时，才能执行具有属性后缀的查找。\r\n            \r\n            如果两个查找都是模棱两可的，我们将带有模棱两可的符号返回相应的结果。\r\n            否则，如果一个结果是单个可行属性类型，我们将返回结果。\r\n            否则，我们将返回使用LookupResult.notanattributetype或空的结果返回不可行的结果。\r\n            \r\n","\r\n              Looks up a localized string similar to The operation in question is undefined on void pointers.\r\n            ":"\r\n              在空隙指针上查找类似于所讨论操作的局部字符串。\r\n            \r\n",".\r\n            Returns immediately in the first case,\r\n            Replaces ":"。\r\n            在第一种情况下立即返回\r\n            替换\r\n","\r\n            Gets the location in terms of path, line and column after applying source line mapping directives (":"\r\n            应用源线映射指令后，请在路径，线路和列中获取位置（\r\n","Invalid initializer member declarator":"无效的初始化器成员声明器\r\n","??=":"?? =\r\n"," being true would permit ":" 真实将允许\r\n","XML comment has a typeparam tag for '{0}', but there is no type parameter by that name":"XML评论具有“ {0}”的Typeparam标签，但没有该名称的类型参数\r\n","\r\n            Allocates a temp without identity.\r\n            ":"\r\n            分配一个没有身份的温度。\r\n            \r\n","The prefix":"前缀\r\n","\r\n            This instance is used to check whether one property or event overrides another, according to the C# definition.\r\n            ":"\r\n            根据C＃定义，该实例用于检查一个属性还是事件是否覆盖另一个属性。\r\n            \r\n","s for which we already retrieved\r\n            diagnostics. We shouldn't return from ForceComplete (i.e. indicate that diagnostics are\r\n            available) until this is equal to ":"我们已经检索的s\r\n            诊断。我们不应该从forcectlete返回（即表明诊断是\r\n            可用），直到等于\r\n","\r\n              Looks up a localized string similar to '{0}': interface members cannot have a definition.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串：接口成员不能具有定义。\r\n            \r\n","\r\n            Helps create a TupleTypeSymbol from source.\r\n            ":"\r\n            有助于从源创建tupletypesymbol。\r\n            \r\n","\r\n            Contains the nullable warnings and annotations context state at a given position in source.\r\n            ":"\r\n            包含在源中给定位置处的可确定警告和注释上下文状态。\r\n            \r\n","\r\n            Assembly's identity.\r\n            ":"\r\n            集会的身份。\r\n            \r\n","The compilation unit that declares the entry point member.":"宣布入口点成员的汇编单元。\r\n","The right (deconstrucible) operand":"右（可解释）操作数\r\n","\r\n            Determines if the source type is convertible to the destination type via\r\n            any built-in or user-defined implicit conversion.\r\n            ":"\r\n            确定源类型是否可通过\r\n            任何内置或用户定义的隐式转换。\r\n            \r\n","\r\n            Used to enumerate the instance fields of a struct.\r\n            ":"\r\n            用于枚举结构的实例字段。\r\n            \r\n","\r\n            Method that is called from the CachingLookup to lookup the children of a given name.\r\n            Looks in all the constituent namespaces.\r\n            ":"\r\n            从缓存lookup调用的方法来查找给定名称的孩子。\r\n            在所有组成命名空间中看起来。\r\n            \r\n","Filter expression is a constant 'true', consider removing the filter":"滤波器表达式是常数“ true”，请考虑删除过滤器\r\n","\r\n            Returns true if this symbol was automatically created by the compiler, and does not\r\n            have an explicit corresponding source code declaration.  \r\n            \r\n            This is intended for symbols that are ordinary symbols in the language sense,\r\n            and may be used by code, but that are simply declared implicitly rather than\r\n            with explicit language syntax.\r\n            \r\n            Examples include (this list is not exhaustive):\r\n              the default constructor for a class or struct that is created if one is not provided,\r\n              the BeginInvoke/Invoke/EndInvoke methods for a delegate,\r\n              the generated backing field for an auto property or a field-like event,\r\n              the \"this\" parameter for non-static methods,\r\n              the \"value\" parameter for a property setter,\r\n              the parameters on indexer accessor methods (not on the indexer itself),\r\n              methods in anonymous types,\r\n              anonymous functions\r\n            ":"\r\n            如果此符号是由编译器自动创建的，则返回true，而不是\r\n            具有明确的相应源代码声明。\r\n            \r\n            这是针对语言意义上的普通符号的符号\r\n            并且可以由代码使用，但只是隐式声明而不是\r\n            带有明确的语言语法。\r\n            \r\n            示例包括（此列表并不详尽）：\r\n              如果不提供一个类别的类或结构的默认构造函数，则\r\n              委托人的开头/调用/endinvoke方法，\r\n              自动属性或类似现场的事件的生成的背面字段，\r\n              非静态方法的“此”参数，\r\n              属性设置器的“值”参数，\r\n              索引器访问者方法上的参数（不在索引本身上）​​，\r\n              匿名类型的方法，\r\n              匿名函数\r\n            \r\n","\r\n            The underlying NamedTypeSymbol.\r\n            ":"\r\n            命名为typesymbol。\r\n            \r\n","Invalid target type for /target: must specify 'exe', 'winexe', 'library', or 'module'":"/目标的无效目标类型：必须指定“ exe”，“ winexe”，“ library”或“模块”\r\n","\r\n            Compare two symbol objects to see if they refer to the same symbol. You should always\r\n            use ":"\r\n            比较两个符号对象，以查看它们是否指的是相同的符号。你应该永远\r\n            利用\r\n","\r\n              Looks up a localized string similar to Nullability of reference types in type of parameter '{0}' doesn't match overridden member..\r\n            ":"\r\n              在参数类型'{0}'类型中查找类似于参考类型的无效性类似的本地化字符串与不匹配的成员。\r\n            \r\n","Permit the use of \"null\" paths on tests which check for null.":"允许在检查NULL的测试中使用“空”路径。\r\n","\r\n            Get all modules in this compilation, including the source module, added modules, and all\r\n            modules of referenced assemblies that do not come from an assembly with an extern alias.\r\n            Metadata imported from aliased assemblies is not visible at the source level except through \r\n            the use of an extern alias directive. So exclude them from this list which is used to construct\r\n            the global namespace.\r\n            ":"\r\n            获取此编辑中的所有模块，包括源模块，添加的模块以及所有模块\r\n            参考组件的模块不是来自带有外部别名的组件。\r\n            从源级别上不可见从混叠组件中导入的元数据，除非通过\r\n            使用外部别名指令。因此，将它们从用于构建的列表中排除\r\n            全局名称空间。\r\n            \r\n","\r\n            Represents a parameter of a RetargetingMethodSymbol. Essentially this is a wrapper around \r\n            another ParameterSymbol that is responsible for retargeting symbols from one assembly to another. \r\n            It can retarget symbols for multiple assemblies at the same time.\r\n            ":"\r\n            代表retargetingMethodSymbol的参数。本质上，这是周围的包装纸\r\n            另一个参数符号是负责从一个组件重新定位符号到另一个组件的另一个参数。\r\n            它可以同时重新定位多个组件。\r\n            \r\n","Allocated instance of {0} is not disposed along all exception paths.  Call System.IDisposable.Dispose() before all references to it are out of scope.":"{0}的分配实例并未沿所有异常路径处置。在所有引用之前，请致电System.Idisposable.dispose（）。\r\n","\r\n            Emit an element store instruction for a single dimensional array.\r\n            ":"\r\n            发出单个维数组的元素存储指令。\r\n            \r\n"," Smallest location of the template, actually contains the smallest location \r\n            of all the anonymous type instances created using this template during EMIT ":" 模板的最小位置，实际上包含最小的位置\r\n            在EMIT期间使用此模板创建的所有匿名类型实例中\r\n","The set of nodes in topological order.":"拓扑顺序的节点集。\r\n","Invalid name for a preprocessing symbol; '{0}' is not a valid identifier":"预处理符号的无效名称； '{0}'不是有效的标识符\r\n","\r\n            Emits all initializers that match indices on the stack recursively.\r\n            \r\n            Example: \r\n             if array has [0..2, 0..3, 0..2] shape\r\n             and we have {1, 2} indices on the stack\r\n             initializers for \r\n                         [1, 2, 0]\r\n                         [1, 2, 1]\r\n                         [1, 2, 2]\r\n            \r\n             will be emitted and the top index will be pushed off the stack \r\n             as at that point we would be completely done with emitting initializers \r\n             corresponding to that index.\r\n            ":"\r\n            排放所有匹配堆栈上索引索引的初始化器。\r\n            \r\n            例子：\r\n             如果数组具有[0..2，0..3，0..2]形状\r\n             我们在堆栈上有{1，2}索引\r\n             初始化器\r\n                         [1，2，0]\r\n                         [1，2，1]\r\n                         [1，2，2]\r\n            \r\n             将发射，顶部索引将被推开\r\n             到那时，我们将完全完成发射初始化器\r\n             对应于该索引。\r\n            \r\n","The event associated with this accessor.":"与此登录器相关的事件。\r\n","\r\n              Looks up a localized string similar to The switch expression does not handle all possible inputs (it is not exhaustive)..\r\n            ":"查找类似于交换机表达式的本地化字符串并不能处理所有可能的输入（这并不详尽）。\r\n            \r\n","Class which represents the syntax node for cast expression.":"代表铸造表达式的语法节点的类。\r\n","global using X = System.Runtime.CompilerServices.TypeForwardedToAttribute":"全局使用x = system.runtime.compilerservices.typeforwarddoattribute\r\n","Pattern-matching with generics":"使用仿制药匹配\r\n","\r\n              Looks up a localized string similar to The switch expression must be a value; found '{0}'..\r\n            ":"\r\n              查找类似于开关表达式的本地化字符串必须是一个值。找到'{0}'..\r\n            \r\n","\r\n            Bind a pattern switch label in order to force inference of the type of pattern variables.\r\n            ":"\r\n            绑定图案开关标签，以强迫模式变量类型的推断。\r\n            \r\n","\r\n            Returns what symbol(s), if any, the given attribute syntax bound to in the program.\r\n            ":"\r\n            返回程序中绑定到的给定属性语法的符号（如果有）。\r\n            \r\n","\r\n            Returns attributes with up-to four filters applied. For each filter, the last application of the\r\n            attribute will be tracked and returned.\r\n            ":"\r\n            返回属性具有最新的四个过滤器。对于每个过滤器，最后一个应用\r\n            属性将被跟踪并返回。\r\n            \r\n","\r\n            A comparer that treats dynamic and object as \"the same\" types, and also ignores tuple element names differences.\r\n            ":"\r\n            将动态和对象视为“相同”类型的比较，也忽略了元组元素名称差异。\r\n            \r\n","Indexed property '{0}' must have all arguments optional":"索引属性'{0}'必须具有所有参数可选\r\n","Called when the visitor visits a BinaryExpressionSyntax node.":"访问者访问二进制expressionsyntax节点时调用。\r\n","\r\n            Implemented by symbols that can be targeted by an attribute declaration (i.e. source symbols).\r\n            ":"\r\n            由可以通过属性声明（即源符号）来靶向的符号实现。\r\n            \r\n","\r\n            Given a SynthesizedExplicitImplementationMethod (effectively a tuple (interface method, implementing method, implementing type)),\r\n            construct a BoundBlock body.  Consider the tuple (Interface.Goo, Base.Goo, Derived).  The generated method will look like:\r\n            \r\n            R Interface.Goo<T1, T2, ...>(A1 a1, A2 a2, ...)\r\n            {\r\n                //don't return the output if the return type is void\r\n                return this.Goo<T1, T2, ...>(a1, a2, ...);\r\n            }\r\n            ":"\r\n            给定一个合成的explitiremplementationmethod（有效的元组（接口方法，实现方法，实现类型）），\r\n            构建一个边界的身体。考虑元组（interface.goo，base.goo，派生）。生成的方法看起来像：\r\n            \r\n            r接口。goo<t1，t2，...>（a1 a1，a2 a2，...）\r\n            {\r\n                //如果返回类型为无效，请勿返回输出\r\n                返回this.goo <t1，t2，...>（a1，a2，...）;\r\n            }\r\n            \r\n","\r\n            Some error messages are particularly confusing if multiple placeholders are substituted\r\n            with the same string.  For example, \"cannot convert from 'Goo' to 'Goo'\".  Usually, this\r\n            occurs because there are two types in different contexts with the same qualified name.\r\n            The solution is to provide additional qualification on each symbol - either a source\r\n            location, an assembly path, or an assembly identity.\r\n            ":"\r\n            如果多个占位符被替换，一些错误消息特别令人困惑\r\n            使用相同的字符串。例如，“不能从'咕咕'转换为'咕'”。通常，这个\r\n            之所以发生，是因为不同的上下文中有两种类型，具有相同的合格名称。\r\n            解决方案是在每个符号上提供额外的资格 - 要么是源\r\n            位置，装配路径或装配身份。\r\n            \r\n","\r\n            Captures the fact that the node was either converted to some type, or converted to its natural\r\n            type.  This is used to check the fact that every rvalue must pass through one of the two,\r\n            so that expressions like tuple literals and switch expressions can reliably be rewritten once\r\n            the target type is known.\r\n            ":"\r\n            捕获节点转换为某种类型或转换为自然的事实\r\n            类型。这用于检查一个事实，即每个RVALUE都必须通过两者之一，\r\n            因此，可以可靠地重写元素文字和开关表达式之类的表达式\r\n            目标类型已知。\r\n            \r\n","The best overloaded Add method '{0}' for the collection initializer element is obsolete.":"对于集合初始化器元素而言，最佳的超载添加方法'{0}'已过时。\r\n"," and non-null type.\r\n            Otherwise, a new ":" 和非无效类型。\r\n            否则，一个新的\r\n","Whether or not to display integral literals in hexadecimal.":"是否在十六进制中展示不可或缺的文字。\r\n","\r\n            Returns if the compilation has all of the members necessary to emit metadata about\r\n            dynamic types.\r\n            ":"\r\n            申报表，如果汇编具有发射元数据所需的所有成员\r\n            动态类型。\r\n            \r\n","The index value from the end.":"索引值从最后。\r\n","\r\n              Looks up a localized string similar to An error occurred while writing the output file: {0}..\r\n            ":"\r\n              在编写输出文件时查找类似于错误的本地化字符串：{0} ..\r\n            \r\n","If tuple element locations are specified, the number of locations must match the cardinality of the tuple.":"如果指定了元组元素位置，则位置的数量必须匹配元组的基数。\r\n","Unused extern alias.":"未使用的外部别名。\r\n","\r\n              Looks up a localized string similar to You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement..\r\n            ":"\r\n              查找类似于您的本地化字符串，无法使用未固定表达式中包含的固定尺寸缓冲区。尝试使用固定语句。\r\n            \r\n","\r\n              Looks up a localized string similar to Name of destructor must match name of class.\r\n            ":"\r\n              查找类似于Destructor名称的本地化字符串必须匹配类的名称。\r\n            \r\n","\r\n            The next character, ":"\r\n            下一个角色，\r\n","ref reassignment":"ref Reasemignment\r\n","\r\n            Bind the pattern switch section.\r\n            ":"\r\n            绑定图案开关部分。\r\n            \r\n","\r\n            Gets the \"after initializers state\" which should be used at the beginning of nullable analysis\r\n            of certain constructors. Only used for semantic model and debug verification.\r\n            ":"\r\n            获取“初始化状态之后”，该状态应在无效分析开始时使用\r\n            某些构造函数。仅用于语义模型和调试验证。\r\n            \r\n","\r\n            If true, the return type and nullability from _delegateInvokeMethod is used.\r\n            If false, the signature of CurrentSymbol is used instead.\r\n            ":"\r\n            如果为true，则使用_delegateInvokeMethod的返回类型和无效性。\r\n            如果是错误的，则使用Currentsymbol的签名。\r\n            \r\n","\r\n              Looks up a localized string similar to Type parameter '{1}' has the 'unmanaged' constraint so '{1}' cannot be used as a constraint for '{0}'.\r\n            ":"\r\n              查找类似于类型参数'{1}'的本地化字符串具有“未管理”约束，因此不能用作'{0}'的约束。\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability of reference types in return type doesn't match overridden member..\r\n            ":"\r\n              查找类似于返回类型的参考类型的无效性类似的本地化字符串与不匹配的成员。\r\n            \r\n","\r\n            We ignore custom modifiers, and the distinction between dynamic and object, when computing a type's hash code.\r\n            ":"\r\n            在计算类型的哈希码时，我们忽略了自定义修饰符以及动态和对象之间的区别。\r\n            \r\n","\r\n            This method is used to keep the code that generates binders in sync\r\n            with the code that searches for binders.  We don't want the searcher\r\n            to skip over any nodes that could have associated binders, especially\r\n            if changes are made later.\r\n            \r\n            \"Local binder\" is a vague term that refers to binders that represent\r\n            scopes for names (e.g. BlockBinders) rather than binders that tweak\r\n            default behaviors (e.g. FieldInitializerBinders).  Local binders are\r\n            created by LocalBinderFactory.\r\n            ":"此方法用于保留生成粘合剂同步的代码\r\n            使用搜索Binders的代码。我们不想要搜索者\r\n            跳过任何可能具有关联粘合剂的节点，尤其是\r\n            如果以后进行更改。\r\n            \r\n            “本地活页夹”是一个模糊的术语，是指代表的粘合剂\r\n            名称的范围（例如，框架）而不是调整绑定器\r\n            默认行为（例如FieldInitializerBinders）。本地粘合剂是\r\n            由LocalBinderFactory创建。\r\n            \r\n","\r\n            Preview of the next language version.\r\n            ":"\r\n            下一个语言版本的预览。\r\n            \r\n","\r\n            Gets the semantic information associated with a query clause.\r\n            ":"\r\n            获取与查询子句相关的语义信息。\r\n            \r\n","Inconsistent accessibility: property type '{1}' is less accessible than property '{0}'":"不一致的可访问性：属性类型'{1}'比属性'{0}'不太访问\r\n","\r\n              Looks up a localized string similar to A params parameter must be the last parameter in a formal parameter list.\r\n            ":"\r\n              查找类似于参数参数的本地化字符串必须是正式参数列表中的最后一个参数。\r\n            \r\n","\r\n              Looks up a localized string similar to An array initializer of length '{0}' is expected.\r\n            ":"\r\n              在预期的长度'{0}'的数组初始化器类似的情况下查找局部字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'.\r\n            ":"\r\n              查找类似于“ coclassAttribute”标记的“ {0}”接口类似的本地化字符串，未标记为“ ComimPortAttribute”。\r\n            \r\n","\r\n              Looks up a localized string similar to Inconsistent lambda parameter usage; parameter types must be all explicit or all implicit.\r\n            ":"\r\n              查找类似于不一致的lambda参数用法的局部字符串；参数类型必须全部显式或全部隐式。\r\n            \r\n"," expression/block.\r\n            ":" 表达式/块。\r\n            \r\n","\r\n              Looks up a localized string similar to A /reference option that declares an extern alias can only have one filename. To specify multiple aliases or filenames, use multiple /reference options..\r\n            ":"\r\n              查找类似于A /参考选项的本地化字符串，该字符串声明外部别名只能具有一个文件名。要指定多个别名或文件名，请使用多个 /参考选项。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot convert lambda to an expression tree whose type argument '{0}' is not a delegate type.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法将lambda转换为表达树，其类型为“ {0}”不是委托类型。\r\n            \r\n","\r\n            If we ever decide to support by-ref returns, don't just make this a non-error\r\n            type.  For consistency with parameters and locals, we should have a bit on the\r\n            signature (i.e. on the MethodSymbol).\r\n            ":"\r\n            如果我们决定支持BY-REF返回，不要仅仅使其成为非错误\r\n            类型。为了与参数和当地人保持一致，我们应该在\r\n            签名（即在方法符号上）。\r\n            \r\n","A parameter array cannot be used with 'this' modifier on an extension method":"参数阵列不能与扩展方法上的“此”修饰符一起使用\r\n"," for all supported types, and for numeric types we also support\r\n            ":" 对于所有受支持类型，对于数字类型，我们还支持\r\n            \r\n","\r\n            Returns the original virtual or abstract method which a given method symbol overrides,\r\n            ignoring any other overriding methods in base classes.\r\n            Also, if the given method symbol is generic then the resulting virtual or abstract method is constructed with the\r\n            same type arguments as the given method.\r\n            ":"\r\n            返回给定方法符号覆盖的原始虚拟或抽象方法，\r\n            忽略基础类中的任何其他重要方法。\r\n            另外，如果给定的方法符号是通用的，则将结果的虚拟方法或抽象方法与\r\n            与给定方法相同的类型参数。\r\n            \r\n","Property accessor already defined":"属性登录机已经定义\r\n","\r\n            Gets a list of indexer symbols for a syntax node. This is overridden by various specializations of SemanticModel.\r\n            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named\r\n            argument nodes have been handled.\r\n            ":"\r\n            获取语​​法节点的索引符号列表。 Semanticmodel的各种专业都覆盖了这一点。\r\n            它可以假设checksyntaxnode和cangetSemanticinfo已经被调用，以及\r\n            论证节点已被处理。\r\n            \r\n","\r\n              Looks up a localized string similar to The managed coclass wrapper class signature '{0}' for interface '{1}' is not a valid class name signature.\r\n            ":"\r\n              查找类似于托管的Coclass包装器类签名'{0}'for Interface'{1}'的本地化字符串不是有效的类名称签名。\r\n            \r\n","This warning indicates that an attribute, such as InternalsVisibleToAttribute, was not specified correctly.":"此警告表明，未正确指定属性，例如InternalSvisibletoatibute。\r\n","\r\n              Looks up a localized string similar to Argument missing.\r\n            ":"\r\n              查找类似于缺少参数的本地化字符串。\r\n            \r\n"," (ImplicitNumeric, from int to long).\r\n             ":" （隐式数，从int到长）。\r\n             \r\n","\r\n              Looks up a localized string similar to The first parameter of the 'in' extension method '{0}' must be a concrete (non-generic) value type..\r\n            ":"\r\n              查找类似于“扩展方法” {0}'的第一个参数类似的本地化字符串，必须是混凝土（非生成）值类型。\r\n            \r\n","Invalid XML include element":"无效XML包括元素\r\n","\r\n            Returns the value of a decimal Unicode character.\r\n            ":"\r\n            返回十进制Unicode字符的值。\r\n            \r\n","Creates a new ThisExpressionSyntax instance.":"创建一个新的thisexpressionsyntax实例。\r\n","attribute-list* ('async' | 'static')* type? ('(' | identifier) ...":"attribute-list*（'async'|'static'）*类型？ （'（'|标识符）...\r\n","\r\n             The representation of a deconstruction as a tree of Deconstruct methods and conversions.\r\n             Methods only appear in non-terminal nodes. All terminal nodes have a Conversion.\r\n            \r\n             Here's an example:\r\n             A deconstruction like `(int x1, (long x2, long x3)) = deconstructable1` with\r\n             `Deconstructable1.Deconstruct(out int y1, out Deconstructable2 y2)` and\r\n             `Deconstructable2.Deconstruct(out int z1, out int z2)` is represented as 5 DeconstructionInfo nodes.\r\n            \r\n             The top-level node has a ":"\r\n             解构为解构方法和转换的树的表示。\r\n             方法仅出现在非末端节点中。所有端子节点均具有转换。\r\n            \r\n             这是一个例子：\r\n             像`（int x1，（长x2，long x3））这样的解构\r\n             `deconstructable1.deconstruct（out int y1，out doconstructable2 y2）\r\n             `deconstructable2.deconstruct（out int z1，out int z2）`表示为5个deconstructionInfo节点。\r\n            \r\n             顶级节点有一个\r\n","\r\n            The rewriter for removing lambda expressions from method bodies and introducing closure classes\r\n            as containers for captured variables along the lines of the example in section 6.5.3 of the\r\n            C# language specification.\r\n            \r\n            The entry point is the public method ":"\r\n            从方法主体中删除lambda表达式并引入关闭类的重写者\r\n            作为沿该示例的捕获变量的容器，在第6.5.3节中\r\n            C＃语言规范。\r\n            \r\n            入口点是公共方法\r\n","\r\n            Get the ObsoleteAttributeData by fetching attributes and decoding ObsoleteAttributeData. This can be \r\n            done for Metadata symbol easily whereas trying to do this for source symbols could result in cycles.\r\n            ":"\r\n            通过获取属性和解码OmboteTeatTribedata来获取过时的tributedata。这可以\r\n            为元数据符号完成，而试图为源符号执行此操作可能会导致周期。\r\n            \r\n","Possible unintended reference comparison; left hand side needs cast":"可能的意外参考比较；左手需要铸造\r\n","\r\n              Looks up a localized string similar to Unnecessary using directive.\r\n            ":"\r\n              查找类似于使用指令的不必要的本地化字符串。\r\n            \r\n","Anonymous function converted to a void returning delegate cannot return a value":"匿名函数转换为void返回委托无法返回值\r\n","\r\n            The parsed representation of a C# source document.\r\n            ":"\r\n            C＃源文档的解析表示形式。\r\n            \r\n","\r\n            A loop binder that (1) knows how to bind foreach loops and (2) has the foreach iteration variable in scope.\r\n            ":"\r\n            （1）知道如何绑定foreach循环，（2）具有范围中的foreach迭代变量。\r\n            \r\n","Expected identifier or numeric literal.":"预期标识符或数字字面。\r\n","\r\n            Type is annotated with '?' - string?, T? where T : class; and for int?, T? where T : struct.\r\n            ":"\r\n            类型带有“？”的注释 - 字符串？，t？其中t：class;和int？，t？其中t：结构。\r\n            \r\n","Parameter has no matching param tag in the XML comment (but other parameters do)":"参数在XML注释中没有匹配的参数标签（但其他参数确实）\r\n","Could not find file.":"找不到文件。\r\n","Location must be provided in order to provide minimal type qualification.":"必须提供位置才能提供最小的类型资格。\r\n","\r\n            A graph of method->method references for this(...) constructor initializers.\r\n            Used to detect and report initializer cycles.\r\n            ":"\r\n            （...）构造函数初始化器的方法 - >方法参考图。\r\n            用于检测和报告初始化循环。\r\n            \r\n","Invalid XML include element -- {0}":"无效XML包括元素 -  {0}\r\n","\r\n              Looks up a localized string similar to Cannot specify the Out attribute on a ref parameter without also specifying the In attribute..\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法在不指定in属性的情况下指定REF参数上的OUT属性。\r\n            \r\n","\r\n            Represents a reference to an instantiation of a generic type nested in an instantiation of another generic type.\r\n            e.g. \r\n            A{int}.B{string}\r\n            A.B{int}.C.D{string}\r\n            ":"\r\n            表示嵌套在另一种通用类型的实例化中的通用类型的实例化。\r\n            例如\r\n            a {int} .b {string}\r\n            a.b {int} .c.d {string}\r\n            \r\n","The class type of frame to be returned":"要返回的框架类型\r\n",">>":">>\r\n","Cannot await in a catch clause":"无法在捕获条款中等待\r\n","Command-line syntax error: Missing '{0}' for '{1}' option":"命令行语法错误：缺少'{0}'for' {1}'选项\r\n","\r\n              Looks up a localized string similar to Inconsistent accessibility: return type '{1}' is less accessible than method '{0}'.\r\n            ":"\r\n              查找类似于不一致的可访问性的本地化字符串：返回类型'{1}'比方法'{0}'易于访问。\r\n            \r\n","\r\n            Return true if the type contains any dynamic type reference.\r\n            ":"\r\n            如果类型包含任何动态类型参考，则返回true。\r\n            \r\n","\r\n            In some circumstances (e.g. implicit implementation of an interface method by a non-virtual method in a \r\n            base type from another assembly) it is necessary for the compiler to generate explicit implementations for\r\n            some interface methods.  They don't go in the symbol table, but if we are emitting, then we should\r\n            generate code for them.\r\n            ":"\r\n            在某些情况下（例如，通过在\r\n            来自另一个组件的基本类型）必须使编译器生成明确的实现\r\n            一些接口方法。他们不在符号表中，但是如果我们发出，那么我们应该\r\n            为他们生成代码。\r\n            \r\n","*=":"*=\r\n","Fully lowered node.":"完全降低的节点。\r\n","\r\n            These parameters can potentially be targeted by an attribute specified in source code. \r\n            As an optimization we distinguish simple parameters (no attributes, no modifiers, etc.) and complex parameters.\r\n            ":"\r\n            这些参数可能是通过源代码中指定的属性来定位的。\r\n            作为优化，我们区分简单参数（无属性，无修饰符等）和复杂参数。\r\n            \r\n","\r\n              Looks up a localized string similar to Type '{0}' in interface list is not an interface.\r\n            ":"\r\n              在接口列表中查找类似于“ {0}”类型的本地化字符串不是接口。\r\n            \r\n","\r\n            Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.\r\n            ":"\r\n            返回可以用给定表达式作为接收器调用的可访问的，非隐藏索引的列表。\r\n            \r\n","Both conditional operator values must be ref values or neither may be a ref value":"两个条件运算符值必须是参考值，或者不可能是参考值\r\n","\r\n            Return one member from one cycle in the graph.\r\n            (There must be at least one cycle. In fact, there\r\n            shouldn't be any fields without dependencies.)\r\n            ":"\r\n            从图中的一个周期中返回一个成员。\r\n            （必须至少有一个周期。实际上，\r\n            没有依赖性，不应该是任何领域。）\r\n            \r\n","\r\n            Returns true if this local variable was declared as \"const\" (i.e. is a constant declaration).\r\n            ":"\r\n            如果该局部变量被声明为“ const”（即是恒定声明），则返回为true。\r\n            \r\n","'{0}': instance field in types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute":"'{0}'：用structlayout标记的类型中的实例字段（layoutkind.explitic）必须具有fieldoffset属性\r\n"," (the first one) or add a new one.\r\n            ":" （第一个）或添加新的。\r\n            \r\n","The 'await' operator can only be used when contained within a method or lambda expression marked with the 'async' modifier":"只有在用“ async”修饰符标记的方法或lambda表达式中包含时，才能使用“等待”操作员\r\n","\r\n              Looks up a localized string similar to The __arglist construct is valid only within a variable argument method.\r\n            ":"\r\n              查找类似于__arglist构造的本地化字符串仅在变量参数方法中有效。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' is already listed in interface list.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串已在接口列表中列出。\r\n            \r\n",".\r\n            To access the type, when this is non-null use ":"。\r\n            要访问该类型，当这是非无效的时候\r\n","Creates a new RangeExpressionSyntax instance.":"创建一个新的grange expressionsyntax实例。\r\n","Possible unintended reference comparison; right hand side needs cast":"可能的意外参考比较；右手需要演员\r\n","\r\n              Looks up a localized string similar to Assuming assembly reference matches identity.\r\n            ":"\r\n              查找类似于汇编参考匹配身份的本地化字符串。\r\n            \r\n","The 'await' operator can only be used within an async {0}. Consider marking this {0} with the 'async' modifier.":"“等待”运算符只能在异步{0}中使用。考虑使用'async'修饰符标记此{0}。\r\n","Attribute '{0}' is not valid on this declaration type. It is only valid on '{1}' declarations.":"属性'{0}'在此声明类型上无效。它仅在“ {1}”声明上有效。\r\n","InitializerExpressionSyntax representing the initializer expression for the with expression.":"initializerexpressionsyntax代表带有表达式的初始化器表达式。\r\n","Creates a new ConversionOperatorDeclarationSyntax instance.":"创建一个新的conversionoperatorteClarationsyntax实例。\r\n","\r\n            PEParameterSymbol reserves all completion part bits and uses them to track the completion state and\r\n            presence of well known attributes.\r\n            ":"\r\n            peparametersymbol保留所有完成零件位，并使用它们来跟踪完成状态和\r\n            存在众所周知的属性。\r\n            \r\n","\r\n            Assembly's custom attributes\r\n            ":"\r\n            大会的自定义属性\r\n            \r\n","\r\n            Substitute for a type declaration.  May use alpha renaming if the container is substituted.\r\n            ":"\r\n            代替类型声明。如果容器被替换，可以使用alpha重命名。\r\n            \r\n"," are used\r\n            to indicate that the lazy values have been computed and, if ":" 被使用\r\n            表明已经计算了懒惰的值，如果\r\n","\r\n            If an element-wise binary operator returns a non-bool type, we will either:\r\n            - prepare a conversion to bool if one exists\r\n            - prepare a truth operator: op_false in the case of an equality (":"\r\n            如果元素的二进制操作员返回了非流动类型，我们将要么：\r\n             - 准备转换为布尔（如果存在）\r\n             - 准备真相操作员：在平等情况下OP_FALSE（OP_FALSE）（\r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 1. Please use language version {1} or greater..\r\n            ":"\r\n              查找类似于功能'{0}'的本地化字符串。\r\n            \r\n","\r\n            Return the name used in syntax for the attribute. This is typically the class\r\n            name without the \"Attribute\" suffix. (For certain diagnostics, the native\r\n            compiler uses the attribute name from syntax rather than the class name.)\r\n            ":"\r\n            返回语法中使用的属性的名称。这通常是班级\r\n            没有“属性”后缀的名称。 （对于某些诊断，本地人\r\n            编译器使用语法中的属性名称，而不是类名称。）\r\n            \r\n","Creates a new RefValueExpressionSyntax instance.":"创建一个新的RefValueExpressionsyntax实例。\r\n","The parameter has multiple distinct default values.":"该参数具有多个不同的默认值。\r\n","Gets the default keyword token.":"获取默认关键字令牌。\r\n"," parameter is used to identify the size of a restricted\r\n            domain.  If the domain is finite (for example the numeric types), then\r\n            ":" 参数用于识别受限的大小\r\n            领域。如果域是有限的（例如数字类型），则\r\n            \r\n","The namespace '{1}' already contains a definition for '{0}'":"名称空间'{1}'已经包含了'{0}'的定义\r\n","\r\n            A map from the constant value to the decision that should be taken when the input has that value.\r\n            ":"\r\n            从恒定值到输入具有该值时应采取的决策的地图。\r\n            \r\n","The right-hand operand of the operation (possibly wrapped in a conversion).":"操作的右手操作数（可能包装在转换中）。\r\n","\r\n            before the start of the scope, but after the start of ":"\r\n            在范围开始之前，但是在开始之后\r\n","Gets the type constraint list.":"获取类型约束列表。\r\n"," branch\r\n            is ":" 分支\r\n            是\r\n","\r\n              Looks up a localized string similar to The namespace '{1}' already contains a definition for '{0}'.\r\n            ":"\r\n              查找类似于名称空间'{1}'的本地化字符串已经包含了'{0}'的定义。\r\n            \r\n","\r\n              Looks up a localized string similar to The * or -> operator must be applied to a pointer.\r\n            ":"\r\n              查找类似于 *或 - >运算符的本地化字符串必须应用于指针。\r\n            \r\n"," performs one of the binary tests;\r\n            ":" 执行其中一项二进制测试；\r\n            \r\n","\r\n            Get the query range variable declared in a query continuation clause.\r\n            ":"\r\n            获取查询范围变量在查询连续句中声明。\r\n            \r\n","\r\n            This method implements the checks in spec section 15.2.\r\n            ":"\r\n            此方法在规格第15.2节中实现了检查。\r\n            \r\n","\r\n            The result type represents the state of the last visited expression.\r\n            ":"\r\n            结果类型代表了最后一个访问的表达式的状态。\r\n            \r\n","\r\n            Bound type if syntax binds to a type in the current context and\r\n            null if syntax binds to \"unmanaged\" keyword in the current context.\r\n            ":"\r\n            如果语法在当前上下文中与类型结合，则绑定类型\r\n            null如果语法在当前上下文中与“未管理”的关键字结合。\r\n            \r\n","NOTE: C# ignores accessor member names.":"注意：C＃忽略访问者成员名称。\r\n","Method declaration syntax.":"方法声明语法。\r\n","\r\n              Looks up a localized string similar to Members of property '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type.\r\n            ":"查找类似于属性'{1}'的属性'{0}'成员的本地化字符串，因为它是一个值类型，因此无法分配使用对象初始化器。\r\n            \r\n","\r\n              Looks up a localized string similar to out variable declaration.\r\n            ":"\r\n              查找类似于变量声明的本地化字符串。\r\n            \r\n"," is infinite (for example, a string type),\r\n            the ":" 是无限的（例如，字符串类型），\r\n            这\r\n","\r\n            Represents the method by which this type implements a given interface type\r\n            and/or the corresponding diagnostics.\r\n            ":"\r\n            表示这种类型实现给定接口类型的方法\r\n            和/或相应的诊断。\r\n            \r\n","\r\n            Returns all templates owned by this type manager\r\n            ":"\r\n            返回此类型管理器拥有的所有模板\r\n            \r\n"," (e.g. fails for static methods).\r\n            ":" （例如，静态方法失败）。\r\n            \r\n"," attributes. It ignores the name, because the candidates were all found by lookup.\r\n            ":" 属性。它忽略了名字，因为候选人都是通过查找找到的。\r\n            \r\n","\r\n            Returns value 'Method' of the ":"\r\n            返回价值的“方法”\r\n","\r\n            C# language version 2.0.\r\n            ":"\r\n            C＃语言版本2.0。\r\n            \r\n"," type symbol to find the method that matches a particular\r\n            signature.\r\n            ":" 键入符号以找到与特定的方法匹配的方法\r\n            签名。\r\n            \r\n","\r\n            The candidate member was rejected because a named argument was used out-of-position and followed by unnamed arguments.\r\n            ":"\r\n            候选人成员被拒绝，因为使用了一个指定的论点，随后是未命名的论点。\r\n            \r\n","SyntaxTreeSemanticModel must be provided in order to provide minimal type qualification.":"必须提供语法emanticmanticmodel，以提供最少的类型资格。\r\n","'{0}': static constructor cannot have an explicit 'this' or 'base' constructor call":"'{0}'：静态构造函数不能具有显式'this'或'base'构造函数调用\r\n","\r\n            Returns a new compilation with the given compilation set as the previous submission.\r\n            ":"\r\n            返回以给定汇编集作为上一提的提交的新汇编。\r\n            \r\n","\r\n            Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an\r\n            expected token is not found. A missing token has no text and normally has associated diagnostics.\r\n            ":"\r\n            创建与语法类型相对应的缺失令牌。当解析器会产生缺失的令牌\r\n            没有发现预期的令牌。缺失的令牌没有文本，通常具有关联的诊断。\r\n            \r\n","\r\n            Is this zero-based one-dimensional array, i.e. SZArray in CLR terms.\r\n            ":"\r\n            这是基于零的一维数组，即用CLR术语进行szarray。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot convert null to type parameter '{0}' because it could be a non-nullable value type. Consider using 'default({0})' instead..\r\n            ":"\r\n              查找类似于null的本地化字符串，因为它可能是不可删除的值类型，因此无法将null转换为类型'{0}'。考虑使用“默认（{0}）”而不是。\r\n            \r\n","\r\n            Does the top level type containing this symbol have 'Microsoft.CodeAnalysis.Embedded' attribute?\r\n            ":"\r\n            包含此符号的顶级类型是否具有“ microsoft.sodeanalysis.embedded”属性？\r\n            \r\n","\r\n            Cached \"state\" of the state machine within the MoveNext method.  We work with a copy of\r\n            the state to avoid shared mutable state between threads.  (Two threads can be executing\r\n            in a Task's MoveNext method because an awaited task may complete after the awaiter has\r\n            tested whether the subtask is complete but before the awaiter has returned)\r\n            ":"\r\n            在MoveNext方法中缓存状态机的“状态”。我们使用的副本\r\n            避免线程之间共享可变状态的状态。 （可以执行两个线程\r\n            在任务的movenext方法中，因为等待者有一个期待的任务可能完成\r\n            测试了子任务是否完成，但在等待者返回之前）\r\n            \r\n","\r\n              Looks up a localized string similar to Defining an alias named 'global' is ill-advised since 'global::' always references the global namespace and not an alias.\r\n            ":"\r\n              从“ global ::'始终引用全局名称空间，而不是别名”以来，请查找类似于定义名为“ Global”的别名类似的本地化字符串。\r\n            \r\n","\r\n            folds two concat operands into one expression if possible\r\n            otherwise returns null\r\n            ":"如果可能\r\n            否则返回null\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot make reference to variable of type '{0}'.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法引用“ {0}”类型的变量。\r\n            \r\n","\r\n            If we're doing nullable analysis, we need to fully bind this member, and then run\r\n            nullable analysis on the resulting nodes before putting them in the map. Nullable\r\n            analysis does not run a subset of code, so we need to fully bind the entire member\r\n            first\r\n            ":"\r\n            如果我们进行无效的分析，我们需要完全绑定该成员，然后运行\r\n            在将它们放入地图之前，对产生的节点进行无效分析。无效\r\n            分析不运行代码的子集，因此我们需要完全绑定整个成员\r\n            第一的\r\n            \r\n","\r\n            This class contains a variety of helper methods for determining whether a\r\n            position is within the scope (and not just the span) of a node.  In general,\r\n            general, the scope extends from the first token up to, but not including,\r\n            the last token. For example, the open brace of a block is within the scope\r\n            of the block, but the close brace is not.\r\n            ":"\r\n            该类包含多种用于确定是否是否的帮助方法\r\n            位置在节点的范围内（而不仅仅是跨度）。一般来说，\r\n            一般，范围从第一个令牌延伸到但不包括，\r\n            最后一个令牌。例如，块的开放支架在范围内\r\n            块，但近距离的支架不是。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': property or indexer cannot have void type.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串：属性或索引器不能具有void类型。\r\n            \r\n","InterpolatedStringHandlerArgumentAttribute":"InterpolatedStringHandlerArgumentAttribute\r\n","True to ignore the distinction between object and dynamic, false by default.":"True 忽略对象和动态之间的区别，默认为 false。\r\n","User-defined conversion must convert to or from the enclosing type":"用户定义的转换必须转换为封闭类型\r\n","Element type of the current iterator, or an error type.":"当前迭代器的元素类型或错误类型。\r\n","\r\n              Looks up a localized string similar to Cannot use anonymous type in a constant expression.\r\n            ":"\r\n              查找类似于常数表达式中无法使用匿名类型的本地化字符串。\r\n            \r\n","Argument missing":"缺少参数\r\n","Class which represents the syntax node for object creation expression.":"代表对象创建表达式的语法节点的类。\r\n","It is not legal to use nullable reference type '{0}?' in an as expression; use the underlying type '{0}' instead.":"使用无效的参考类型“ {0}？”是不合法的。在AS表达中；代替使用基础类型'{0}'。\r\n","'{0}' is abstract but it is contained in non-abstract type '{1}'":"'{0}'是抽象的\r\n","\r\n            Returns false for ":"\r\n            返回false\r\n","\r\n              Looks up a localized string similar to Target runtime doesn't support default interface implementation..\r\n            ":"查找类似于目标运行时的本地化字符串不支持默认接口实现。\r\n            \r\n","\r\n            Returns the original virtual or abstract method which a given method symbol overrides,\r\n            ignoring any other overriding methods in base classes.\r\n            ":"\r\n            返回给定方法符号覆盖的原始虚拟或抽象方法，\r\n            忽略基础类中的任何其他重要方法。\r\n            \r\n","\r\n            Creates a speculative SemanticModel for an expression body that did not appear in the original source code.\r\n            ":"\r\n            为未出现在原始源代码中的表达主体创建一个投机性词素模型。\r\n            \r\n"," tests a value for null; ":" 测试零值的值；\r\n","An expression of type '{0}' is not allowed in a subsequent from clause in a query expression with source type '{1}'.  Type inference failed in the call to '{2}'.":"在源类型'{1}'中，不允许在从子句中从子句中的子句中的子句中的子句中的子句中的类型表示“ {0}”的表达式。键入推理在调用“ {2}'”的调用中失败。\r\n","\r\n             The list of all interfaces of which this type is a declared subtype, excluding this type\r\n             itself. This includes all declared base interfaces, all declared base interfaces of base\r\n             types, and all declared base interfaces of those results (recursively).  Each result\r\n             appears exactly once in the list. This list is topologically sorted by the inheritance\r\n             relationship: if interface type A extends interface type B, then A precedes B in the\r\n             list. This is not quite the same as \"all interfaces of which this type is a proper\r\n             subtype\" because it does not take into account variance: AllInterfaces for\r\n             IEnumerable<string> will not include IEnumerable<object>\r\n            \r\n             Note: When interfaces specified on the same inheritance level differ by tuple names only,\r\n             only the last one will be listed here.\r\n             ":"\r\n             此类型的所有接口的列表是声明的亚型，不包括此类型\r\n             本身。这包括所有声明的基本接口，所有声明为基础的基本接口\r\n             类型，所有这些结果的基本接口（递归）。每个结果\r\n             完全出现在列表中。此列表在拓扑上被继承分类\r\n             关系：如果接口类型A扩展了接口类型B，则A在BE中的B之前\r\n             列表。这与“这种类型的所有接口”不完全相同\r\n             子类型“因为它不考虑差异：\r\n             iEnumerable <string>将不包括iEnumerable <obsoce>\r\n            \r\n             注意：当在同一继承级别指定的接口仅因元组名称而异，\r\n             只有最后一个将在这里列出。\r\n             \r\n","Creates a new MethodDeclarationSyntax instance.":"创建一个新的methoddeclarationsyntax实例。\r\n","\r\n            Get local functions declared immediately in scope designated by the node.\r\n            ":"\r\n            在节点指定的范围中立即声明本地功能。\r\n            \r\n","\r\n            User defined local variable declared by ":"\r\n            用户定义的本地变量声明\r\n","Class which represents the syntax node for a literal expression.":"代表文字表达式的语法节点的类。\r\n",") or op_true in the case of inequality,\r\n                with the conversion being used for its input.\r\n            ":"）或op_true在不等式的情况下\r\n                转换用于输入。\r\n            \r\n","No source files specified.":"未指定源文件。\r\n","'MethodImplOptions.Synchronized' cannot be applied to an async method":"“ methodimploptions.syngronized”不能应用于异步方法\r\n","\r\n              Looks up a localized string similar to automatically implemented properties.\r\n            ":"\r\n              查找类似于自动实现属性的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute on a property.\r\n            ":"\r\n              查找类似于不使用'system.runtime.compilerservices.fixedbuffer'属性的本地化字符串。\r\n            \r\n","\r\n            Matches symbols from an assembly in one compilation to\r\n            the corresponding assembly in another. Assumes that only\r\n            one assembly has changed between the two compilations.\r\n            ":"\r\n            匹配一个汇编中的组件的符号\r\n            另一个相应的组件。假设只有\r\n            两次汇编之间发生了一个组件。\r\n            \r\n","\r\n            Lexer entry point for LexerMode.XmlCharacter.\r\n            ":"\r\n            Lexermode.xmlcharacter的Lexer入口点。\r\n            \r\n","A static readonly field cannot be assigned to (except in a static constructor or a variable initializer)":"静态可读字段不能分配给（在静态构造函数或可变初始器中除外）\r\n","Simple assembly name.":"简单的汇编名称。\r\n","\r\n              Looks up a localized string similar to Division by constant zero.\r\n            ":"\r\n              查找类似于Constant Zero的局部字符串。\r\n            \r\n","\r\n            Returns true if this symbols is a type. Equivalent to !IsNamespace.\r\n            ":"\r\n            如果此符号是一种类型，则返回true。等效于！isnamespace。\r\n            \r\n","Called when the visitor visits a LiteralExpressionSyntax node.":"当访问者访问LiteraleXpressionsyntax节点时，请致电。\r\n","\r\n            Creates a new compilation from scratch. Methods such as AddSyntaxTrees or AddReferences\r\n            on the returned object will allow to continue building up the Compilation incrementally.\r\n            ":"\r\n            从头开始创建新的汇编。诸如addsyntaxtrees或addreference之类的方法\r\n            在返回的对象上，将允许继续逐步构建汇编。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': static types cannot be used as parameters.\r\n            ":"\r\n              查找类似于“ {0}'：静态类型的本地化字符串，不能用作参数。\r\n            \r\n","\r\n              Looks up a localized string similar to The name '_' refers to the type '{0}', not the discard pattern. Use '@_' for the type, or 'var _' to discard..\r\n            ":"\r\n              查找类似于名称“ _”的本地化字符串是指类型'{0}'，而不是丢弃模式。使用'@_'进行类型或'var _'丢弃。\r\n            \r\n","Called when the visitor visits a BreakStatementSyntax node.":"当访问者访问BreakStatementSyntax节点时，请致电。\r\n","\r\n            As you might hope, for an array, it is the element type of the array.\r\n            ":"\r\n            您可能希望，对于一个数组，它是数组的元素类型。\r\n            \r\n","A string literal was expected, but no opening quotation mark was found.":"预计会有一个字符串的文字，但没有发现开头的引号。\r\n","\r\n            Returns the value of a hexadecimal Unicode character.\r\n            ":"\r\n            返回十六进制Unicode字符的值。\r\n            \r\n","\r\n            A binding for a field initializer, property initializer, constructor\r\n            initializer, or a parameter default value.\r\n            Represents the result of binding a value expression rather than a\r\n            block (for that, use a ":"\r\n            现场初始化器，属性初始化器，构造函数的绑定\r\n            初始化器或参数默认值。\r\n            代表绑定值表达而不是绑定的结果\r\n            块（为此，使用\r\n","\r\n            Displays a symbol in the C# style, based on a ":"\r\n            基于c＃样式显示一个符号\r\n","\r\n              Looks up a localized string similar to Both partial method declarations must use a params parameter or neither may use a params parameter.\r\n            ":"\r\n              查找类似于两个部分方法声明的本地化字符串必须使用参数参数，或者都不可以使用参数参数。\r\n            \r\n","\r\n            A region analysis walker that computes the set of variables that are definitely assigned\r\n            when a region is entered or exited.\r\n            ":"\r\n            一个肯定分配的变量集的区域分析步行器\r\n            当进入或退出区域时。\r\n            \r\n","\r\n              Looks up a localized string similar to Attribute '{0}' is not valid on this declaration type. It is only valid on '{1}' declarations..\r\n            ":"\r\n              在此声明类型上查找类似于属性'{0}'的本地化字符串。它仅在“ {1}”声明上有效。\r\n            \r\n","\r\n              Looks up a localized string similar to A const field requires a value to be provided.\r\n            ":"\r\n              查找类似于const字段的本地化字符串需要提供一个值。\r\n            \r\n","\r\n            Returns true if this symbol is \"virtual\", has an implementation, and does not override a\r\n            base class member; i.e., declared with the ":"\r\n            如果此符号为“虚拟”，具有实现，并且不会覆盖A，则返回true\r\n            基类成员；即，用\r\n","\r\n            The underlying error.\r\n            ":"\r\n            基础错误。\r\n            \r\n","Called when the visitor visits a ElementAccessExpressionSyntax node.":"当访问者访问元素cessexpressyntax节点时调用。\r\n","\r\n              Looks up a localized string similar to A possible null value may not be passed to a target marked with the [DisallowNull] attribute.\r\n            ":"\r\n              查找类似于可能的空值的本地化字符串可能不会传递给标记为[disallownull]属性的目标。\r\n            \r\n","Called when the visitor visits a MemberBindingExpressionSyntax node.":"当访问者访问成员的expressexpressyntax节点时调用。\r\n","\r\n            The closest method/lambda that this frame is originally from. Null if nongeneric static closure.\r\n            Useful because this frame's type parameters are constructed from this method and all methods containing this method.\r\n            ":"该框架最初来自的最接近的方法/lambda。无效，如果静态闭合。\r\n            有用，因为此帧的类型参数是根据此方法构建的，以及包含此方法的所有方法。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' is ambiguous between '{1}' and '{2}'; use either '@{0}' or '{0}Attribute'.\r\n            ":"\r\n              查找类似于'{1}'和'{2}'之间的“ {0}”类似的局部字符串;使用'@{0}'或'{0}属性'。\r\n            \r\n","\r\n              Looks up a localized string similar to The field '{0}' is assigned but its value is never used.\r\n            ":"\r\n              查找类似于“ {0}”字段的本地化字符串，但从未使用其值。\r\n            \r\n","\r\n              Looks up a localized string similar to Name '{0}' exceeds the maximum length allowed in metadata..\r\n            ":"\r\n              查找类似于名称'{0}'的本地化字符串超过元数据中允许的最大长度。\r\n            \r\n","Wrong number of type arguments":"类型参数的错误数量\r\n","\r\n            An Assembly object providing metadata for the assembly.\r\n            ":"\r\n            为组件提供元数据的组件对象。\r\n            \r\n"," is applied or the decoded dynamic transforms attribute argument is erroneous,\r\n            returns the unchanged ":" 被应用或解码的动态变换属性参数是错误的，\r\n            返回不变的\r\n","Unexpected error writing debug information -- '{0}'":"意外错误编写调试信息 - '{0}'\r\n","\r\n            Returns false because label can't be sealed.\r\n            ":"\r\n            返回错误，因为标签无法密封。\r\n            \r\n","Properties which return by reference cannot have set accessors":"通过参考返回的属性无法设置访问者\r\n","\r\n              Looks up a localized string similar to '{0}' does not implement interface member '{1}'.\r\n            ":"\r\n              查找类似于“ {0}'的本地化字符串”不实现接口成员'{1}'。\r\n            \r\n","nameof operator":"运算符的名称\r\n","An expression tree may not contain a tuple == or != operator":"表达树可能不包含元组==或！=操作员\r\n","True if it's safe to use block initialization for enum arrays.":"如果安全使用块初始化作为枚举阵列，则为true。\r\n","\r\n              Looks up a localized string similar to Compilation cancelled by user.\r\n            ":"\r\n              查找类似于用户取消的汇编的本地化字符串。\r\n            \r\n","Default parameter value for '{0}' must be a compile-time constant":"'{0}'的默认参数值必须是编译时常数\r\n","Information on closures defined in ":"有关关闭的信息\r\n","fixed variable":"固定变量\r\n","Cannot convert async {0} to delegate type '{1}'. An async {0} may return void, Task or Task<T>, none of which are convertible to '{1}'.":"不能将异步{0}转换为委派'{1}'。异步{0}可以返回void，task或任务<t>，它们都不可转换为'{1}'。\r\n","\r\n              Looks up a localized string similar to Invalid preprocessor expression.\r\n            ":"\r\n              查找类似于无效预处理器表达式的局部字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to An object reference is required for the non-static field, method, or property '{0}'.\r\n            ":"\r\n              查找类似于对象引用的本地化字符串是非静态字段，方法或属性'{0}'所需的。\r\n            \r\n","True if failures should result in warnings; false if they should result in errors.":"如果失败应导致警告，则为真实；错误，如果他们应该导致错误。\r\n","\r\n            Implementers should assume that a lock has been taken on MethodChecksLockObject.\r\n            In particular, it should not (generally) be necessary to use CompareExchange to\r\n            protect assignments to fields.\r\n            ":"\r\n            实施者应假定已对MethodCheckSlockObject进行了锁定。\r\n            特别是，（通常）不需要使用compareexchange\r\n            保护对字段的任务。\r\n            \r\n"," to the replacement text if the\r\n            character is replaced with text other than the Unicode escape sequence.\r\n            ":" 如果是\r\n            字符被除非Unicode Escape序列以外的其他文本代替。\r\n            \r\n","\r\n            Given that the next character is an ampersand ('&'), attempt to interpret the\r\n            following characters as an XML entity.  On success, populate the out parameters\r\n            with the low and high UTF-16 surrogates for the character represented by the\r\n            entity.\r\n            ":"\r\n            鉴于下一个字符是一个andand（'＆'），试图解释\r\n            将字符作为XML实体。关于成功，填充OUT参数\r\n            具有低和高的UTF-16代理\r\n            实体。\r\n            \r\n","\r\n            Represents a state machine MoveNext method.\r\n            Handles special behavior around inheriting some attributes from the original async/iterator method.\r\n            ":"\r\n            代表状态机Movenext方法。\r\n            处理特殊行为，围绕从原始异步/迭代方法继承某些属性。\r\n            \r\n","BracketedArgumentListSyntax node representing the list of arguments of the element access expression.":"表示元素访问表达式参数列表的bracketedArgumentListSyntax节点。\r\n","Ignore 'throughType' in accessibility checking. \r\n            Used in checking accessibility of symbols accessed via 'MyBase' or 'base'.":"在可访问性检查中忽略“渐进性”。\r\n            用于检查通过“ mybase”或“ base”访问的符号的可访问性。\r\n","\r\n            This function searches for the given location node within the subtree rooted at root node. \r\n            If it finds it, the function computes the offset span of that child node within the root and returns true, \r\n            otherwise it returns false.\r\n            ":"\r\n            此功能搜索扎根于根节点的子树内的给定位置节点。\r\n            如果找到它，该函数将计算该子节点在根部内的偏移跨度并返回true，\r\n            否则它将返回false。\r\n            \r\n","\r\n              Looks up a localized string similar to expression body constructor and destructor.\r\n            ":"\r\n              查找类似于表达主体构造函数和驱动器的局部字符串。\r\n            \r\n","\r\n            This represents what the user claimed in source through the AssemblyFlagsAttribute.\r\n            It may be modified as emitted due to presence or absence of the public key.\r\n            ":"\r\n            这代表用户通过汇编FlagSattribute在源中声称的内容。\r\n            由于存在或不存在公共密钥，因此可以将其修改为发射。\r\n            \r\n","\r\n              Looks up a localized string similar to The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'notnull' constraint..\r\n            ":"\r\n              在通用类型或方法中查找类似于类型的本地化字符串。类型参数的无效性不匹配“ notnull”约束。\r\n            \r\n","Creates a new ElseClauseSyntax instance.":"创建一个新的elseclausesyntax实例。\r\n","\r\n            Check whether \"symbol\" is accessible from this binder.\r\n            Also checks protected access via \"accessThroughType\", and sets \"failedThroughTypeCheck\" if fails\r\n            the protected access check.\r\n            ":"\r\n            检查\"符号\"是否可从此活页夹访问。\r\n            还通过\"accessThroughType\"检查受保护的访问，如果失败，则设置\"failedThroughTypeCheck\"\r\n            受保护的访问检查。\r\n            \r\n","\r\n            Sequence of names for nested child namespaces.\r\n            ":"\r\n            嵌套子名称空间的名称序列。\r\n            \r\n","Creates a new BaseListSyntax instance.":"创建一个新的基本词法实例。\r\n","disposable":"一次性的\r\n","Cannot use a nullable reference type in object creation.":"无法在对象创建中使用无效的参考类型。\r\n","\r\n            Checks if 'symbol' is accessible from within assembly 'within'.  \r\n            ":"\r\n            检查“符号”是否可以从汇编内“内部”内部访问。\r\n            \r\n","\r\n            Figure out if the target runtime supports default interface implementation.\r\n            ":"\r\n            找出目标运行时是否支持默认接口实现。\r\n            \r\n","\r\n            Creates a trivia with kind DisabledTextTrivia. Disabled text corresponds to any text between directives that\r\n            is not considered active.\r\n            ":"\r\n            创建一个具有善良的残疾texttrivia的琐事。残疾文本对应于指令之间的任何文本\r\n            不被视为活动。\r\n            \r\n","\r\n            Compute and translate the decision dag, given a description of its initial state and a default\r\n            decision when no decision appears to match. This implementation is nonrecursive to avoid\r\n            overflowing the compiler's evaluation stack when compiling a large switch statement.\r\n            ":"\r\n            鉴于其初始状态和默认状态的描述，计算和翻译决策DAG\r\n            当似乎没有决定匹配的时候决定。此实现是非捕获的\r\n            编译大型开关语句时，溢出编译器的评估堆栈。\r\n            \r\n","Invalid option '{0}' for /platform; must be anycpu, x86, Itanium, arm, arm64 or x64":"无效选项'{0}'for /platform;必须是anycpu，x86，itanium，臂，臂64或x64\r\n","\r\n            A diagnostic, along with the location where it occurred.\r\n            ":"\r\n            诊断，以及发生的位置。\r\n            \r\n","\r\n            Contains methods related to synthesizing bound nodes in initial binding \r\n            form that needs lowering, primarily method bodies for compiler-generated methods.\r\n            ":"\r\n            包含与最初结合中合成结合节点有关的方法\r\n            需要降低的形式，主要是用于编译器生成方法的方法。\r\n            \r\n","\r\n            Returns true if the Unicode character is a binary (0-1) digit.\r\n            ":"\r\n            如果Unicode字符是二进制（0-1）数字，则返回true。\r\n            \r\n","\r\n              Looks up a localized string similar to Field-targeted attributes on auto-properties are not supported in this version of the language..\r\n            ":"\r\n              在此版本的语言中不支持类似于自动生产的字段定位属性的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Conditional access may produce a null value when '{0}' is a non-nullable reference type..\r\n            ":"\r\n              查找类似于条件访问的本地化字符串可能会在“ {0}”是不可删除的参考类型时产生零值。\r\n            \r\n","\r\n            The purpose of this rewriter is to replace await-containing catch and finally handlers\r\n            with surrogate replacements that keep actual handler code in regular code blocks.\r\n            That allows these constructs to be further lowered at the async lowering pass.\r\n            ":"\r\n            此重写者的目的是替换等待等待的捕获器，最后是处理程序\r\n            替代替代品将实际处理程序代码保持在常规代码块中。\r\n            这允许在异步降低通道下进一步降低这些构建体。\r\n            \r\n","\r\n            Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.\r\n            ":"获取SwitchLabelsyntax的语法清单，表示控制可以传输到部分内的可能标签。\r\n            \r\n"," \"match\" a pattern that looks for\r\n            type ":" “匹配”一个寻找的模式\r\n            类型\r\n","\r\n            (2) The current method being processed (this changes within a lambda's body), in ":"\r\n            （2）当前正在处理的方法（这在兰伯达的身体内发生了变化），\r\n","\r\n            An error type, used to represent the type of a type binding\r\n            operation when binding fails.\r\n            ":"\r\n            错误类型，用于表示类型绑定的类型\r\n            绑定失败时操作。\r\n            \r\n","Creates a new SwitchExpressionSyntax instance.":"创建一个新的switchexpressionsyntax实例。\r\n","\r\n              Looks up a localized string similar to property.\r\n            ":"\r\n              查找类似于属性的本地化字符串。\r\n            \r\n","Variable is assigned but its value is never used":"分配了变量，但其值永远不会使用\r\n","\r\n            The rewrites are as follows: suppose the operand x is a variable of type X. The\r\n            chosen increment/decrement operator is modelled as a static method on a type T,\r\n            which takes a value of type T and returns the result of incrementing or decrementing\r\n            that value.\r\n            \r\n            x++\r\n                X temp = x\r\n                x = (X)(T.Increment((T)temp))\r\n                return temp\r\n            x--\r\n                X temp = x\r\n                x = (X)(T.Decrement((T)temp))\r\n                return temp\r\n            ++x\r\n                X temp = (X)(T.Increment((T)x))\r\n                x = temp\r\n                return temp\r\n            --x\r\n                X temp = (X)(T.Decrement((T)x))\r\n                x = temp\r\n                return temp\r\n            \r\n            Note: \r\n            Dev11 implements dynamic prefix operators incorrectly.\r\n            \r\n              result = ++x.P  is emitted as  result = SetMember{\"P\"}(t, UnaryOperation{Inc}(GetMember{\"P\"}(x)))\r\n            \r\n            The difference is that Dev11 relies on SetMember returning the same value as it was given as an argument.\r\n            Failing to do so changes the semantics of ++/-- operator which is undesirable. We emit the same pattern for\r\n            both dynamic and static operators.\r\n               \r\n            For example, we might have a class X with user-defined implicit conversions\r\n            to and from short, but no user-defined increment or decrement operators. We\r\n            would bind x++ as \"X temp = x; x = (X)(short)((int)(short)temp + 1); return temp;\"\r\n            ":"\r\n            重写如下：假设操作数X是类型X的变量。\r\n            选择的增量/减少操作员被建模为T型上的静态方法，\r\n            它具有T型的值，并返回增加或减少的结果\r\n            那个价值。\r\n            \r\n            X ++\r\n                x temp = x\r\n                x =（x）（t.increment（（t）temp））\r\n                返回温度\r\n            X - \r\n                x temp = x\r\n                x =（x）（t.decrement（（t）temp））\r\n                返回温度\r\n            ++ x\r\n                x temp =（x）（t.increment（（t）x））\r\n                x =温度\r\n                返回温度\r\n             - X\r\n                x temp =（x）（t.decrement（（（t）x）））\r\n                x =温度\r\n                返回温度\r\n            \r\n            笔记：\r\n            DEV11错误地实现了动态前缀操作员。\r\n            \r\n              结果= ++ x.p作为结果= setMember {“ p”}（t，Unaryoperation {inc}（getMember {“ p”}（x）））\r\n            \r\n            区别在于，dev11依赖于setMember返回与参数相同的值。\r\n            不这样做会改变++/ - 运算符的语义，这是不受欢迎的。我们发出相同的模式\r\n            动态和静态操作员。\r\n               \r\n            例如，我们可能有一个带有用户定义的隐式转换的X类\r\n            从简称，但没有用户定义的增量或减少操作员。我们\r\n            将x ++绑定为“ x temp = x; x =（x）（短）（（int）（short）temp+ 1）; return temp;''\r\n            \r\n","\r\n              Looks up a localized string similar to The argument to the '{0}' attribute must be a valid identifier.\r\n            ":"查找类似于“ {0}”属性参数的本地化字符串必须是有效的标识符。\r\n            \r\n","\r\n            Create a new syntax tree from a syntax node.\r\n            ":"\r\n            从语法节点创建一个新的语法树。\r\n            \r\n","A throw statement with no arguments is not allowed in a finally clause that is nested inside the nearest enclosing catch clause":"在嵌套在最近的封闭捕获子句中的最后条款中，不允许没有参数的投掷语句\r\n","Tuples support == and !=":"元组支持==和！=\r\n","\r\n              Looks up a localized string similar to An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type.\r\n            ":"\r\n              查找类似于属性参数的本地化字符串必须是属性参数类型的恒定表达式，类型表达式或数组创建表达式。\r\n            \r\n","An error occurred while writing the output file: {0}.":"编写输出文件时发生错误：{0}。\r\n","#pragma warning":"#pragma警告\r\n","Returns the Assembly to which the type is forwarded, or null if none is found.":"返回将类型转发到的组件，或者如果没有找到的组件。\r\n","Called when the visitor visits a XmlTextSyntax node.":"访问者访问XMLTEXTSYNTAX节点时调用。\r\n","\r\n              Looks up a localized string similar to Type '{0}' cannot be embedded because it has a non-abstract member. Consider setting the 'Embed Interop Types' property to false..\r\n            ":"\r\n              查找类似于“ {0}”类型的本地化字符串，因为它具有非吸收成员。考虑将“嵌入Interop类型”属性设置为false。\r\n            \r\n","XML comment has cref attribute that could not be resolved":"XML评论具有无法解决的CREF属性\r\n","Called when the visitor visits a RefTypeExpressionSyntax node.":"访问者访问reftypeexpressyntax节点时调用。\r\n","\r\n            Guess the non-error type kind that the given type was intended to represent,\r\n            if possible. If not, return TypeKind.Error.\r\n            ":"\r\n            猜测给定类型的非错误类型是要代表的，\r\n            如果可能的话。如果没有，请返回typekind.error。\r\n            \r\n","\r\n              Looks up a localized string similar to A value of an integral type expected.\r\n            ":"\r\n              查找类似于预期的积分类型的局部字符串。\r\n            \r\n","Target-typed conditional expressions":"目标型条件表达式\r\n","\r\n              Looks up a localized string similar to Microsoft (R) Visual C# Compiler.\r\n            ":"\r\n              查找类似于Microsoft（R）Visual C＃编译器的本地化字符串。\r\n            \r\n","\r\n            Is the current token one that could be in an expression?\r\n            ":"\r\n            当前令牌是否可以在表达式中？\r\n            \r\n","location to be used":"要使用的位置\r\n","\r\n            The variable(s) of the loop. In correct code this is a tuple\r\n            literal, declaration expression with a tuple designator, or\r\n            a wildcard syntax in the form of a simple identifier. In broken\r\n            code it could be something else.\r\n            ":"\r\n            循环的变量。在正确的代码中，这是一个元组\r\n            具有元组指定者的字面宣言表达方式，或\r\n            简单标识符形式的通配符语法。在破碎中\r\n            代码可能是其他的。\r\n            \r\n","\r\n            True if and only if an exception was thrown during a call to ":"\r\n            当且只有在打电话期间抛出异常时，才是正确的\r\n","Cannot deconstruct dynamic objects.":"不能解构动态对象。\r\n","\r\n              Looks up a localized string similar to Overloaded unary operator '{0}' takes one parameter.\r\n            ":"\r\n              查找类似于过载的Unary操作员'{0}'的本地化字符串，请使用一个参数。\r\n            \r\n","SyntaxToken representing the keyword corresponding to the kind of the literal expression.":"语法代表与文字表达式相对应的关键字。\r\n","The result of the expression is always 'null'":"表达的结果始终是“ null”\r\n","\r\n            Returns the common value if all bytes are the same value.\r\n            Otherwise returns null.\r\n            ":"\r\n            如果所有字节都是相同的值，则返回共同值。\r\n            否则返回null。\r\n            \r\n","\r\n            A node representing a final destination that requires no further dispatch.\r\n            ":"\r\n            代表最终目的地的节点不需要进一步调度。\r\n            \r\n","\r\n            Parse a subexpression of the enclosing operator of the given precedence.\r\n            ":"\r\n            解析给定优先级的封闭操作员的子表达。\r\n            \r\n","\r\n            Returns true if the binder is binding top-level script code.\r\n            ":"\r\n            如果粘合剂绑定顶级脚本代码，则返回true。\r\n            \r\n","\r\n            NOTE: Always advances, even on failure.\r\n            ":"\r\n            注意：即使在失败时也总是会进步。\r\n            \r\n","Called when the visitor visits a DiscardDesignationSyntax node.":"当访客访问doverdesignationsyntax节点时，请致电。\r\n","True if the nodes are all valid XML.":"如果节点都是有效的XML，则为true。\r\n","\r\n            Symbol for the most nested namespace, if found. Nothing \r\n            if namespace or any part of it can not be found.\r\n            ":"\r\n            如果找到了最嵌套的名称空间的符号。没有什么\r\n            如果找不到名称空间或任何部分。\r\n            \r\n","\r\n              Looks up a localized string similar to Arguments with 'in' modifier cannot be used in dynamically dispatched expressions..\r\n            ":"\r\n              查找类似于“ in”修饰符的参数类似的本地化字符串，无法在动态调度表达式中使用。\r\n            \r\n","Called when the visitor visits a ImplicitObjectCreationExpressionSyntax node.":"当访问者访问隐式creationexpressyntax节点时调用。\r\n","Called when the visitor visits a ParenthesizedExpressionSyntax node.":"当访问者访问括号expresepressyntax节点时调用。\r\n","Creates a new EqualsValueClauseSyntax instance.":"创建一个新的equalsValueClausesyntax实例。\r\n","\r\n              Looks up a localized string similar to Cannot initialize a by-value variable with a reference.\r\n            ":"\r\n              查找类似于引用的概要变量的本地化字符串。\r\n            \r\n","\r\n            Since dev11 didn't expose a symbol API, it had the luxury of being able to accept a base class's claim that \r\n            it implements an interface.  Roslyn, on the other hand, needs to be able to point to an implementing symbol\r\n            for each interface member.\r\n            \r\n            DevDiv #718115 was triggered by some unusual metadata in a Microsoft reference assembly (Silverlight System.Windows.dll).\r\n            The issue was that a type explicitly implemented the accessors of an interface event, but did not tie them together with\r\n            an event declaration.  To make matters worse, it declared its own protected event with the same name as the interface\r\n            event (presumably to back the explicit implementation).  As a result, when Roslyn was asked to find the implementing member\r\n            for the interface event, it found the protected event and reported an appropriate diagnostic.  What it should have done\r\n            (and does do now) is recognize that no event associated with the accessors explicitly implementing the interface accessors\r\n            and returned null.\r\n            \r\n            We resolved this issue by introducing a new step into the interface mapping algorithm: after failing to find an explicit\r\n            implementation in a type, but before searching for an implicit implementation in that type, check for an explicit implementation\r\n            of an associated accessor.  If there is such an implementation, then immediately return the associated property or event,\r\n            even if it is null.  That is, never attempt to find an implicit implementation for an interface property or event with an\r\n            explicitly implemented accessor.\r\n            ":"\r\n            由于DEV11没有暴露符号API，因此它具有能够接受基类声称的奢侈品\r\n            它实现了接口。另一方面，罗斯林需要能够指向实现符号\r\n            对于每个接口成员。\r\n            \r\n            DevDiv＃718115是由Microsoft参考组件（Silverlight System.windows.dll）中的一些异常元数据触发的。\r\n            问题是一种类型明确实现了接口事件的登录器，但没有将它们与\r\n            事件声明。更糟糕的是，它宣布其自己的受保护事件，名称与接口相同\r\n            事件（大概是为了支持明确的实施）。结果，当罗斯林被要求找到实施成员时\r\n            对于接口事件，它找到了受保护的事件并报告了适当的诊断。它应该做什么\r\n            （并且现在确实这样做）认识到，与登录器没有明确实现接口访问者的事件\r\n            并返回null。\r\n            \r\n            我们通过在接口映射算法中引入新步骤来解决此问题：未能找到明确的\r\n            类型中的实现，但在搜索该类型中的隐式实现之前，请检查明确的实现\r\n            相关的登录器。如果有这样的实施，请立即返回关联的属性或事件，\r\n            即使是空的。也就是说，切勿尝试找到与一个接口属性或事件的隐式实现\r\n            明确实现的登录器。\r\n            \r\n","\r\n            Represents an anonymous type 'public' symbol which is used in binding and lowering.\r\n            In emit phase it is being substituted with implementation symbol.\r\n            ":"\r\n            代表一种匿名类型的“公共”符号，用于绑定和降低。\r\n            在发射阶段，它被实现符号代替。\r\n            \r\n","'{0}': cannot override inherited member '{1}' because it is not marked virtual, abstract, or override":"'{0}'：不能覆盖继承的成员'{1}'，因为它没有标记为虚拟，抽象或覆盖\r\n","'{0}': event property must have both add and remove accessors":"'{0}'：事件属性必须同时具有添加和删除登录器\r\n","Time (s)":"时间\r\n","\r\n            Variables declared in a using statement are always considered used, so this is just an assert.\r\n            ":"\r\n            始终考虑使用在使用语句中声明的变量，因此这只是一个断言。\r\n            \r\n","\r\n              Looks up a localized string similar to Metadata file '{0}' could not be opened -- {1}.\r\n            ":"\r\n              无法打开类似于元数据文件'{0}'的本地化字符串 -  {1}。\r\n            \r\n","\r\n            Retrieves anonymous type properties types\r\n            ":"\r\n            检索匿名类型属性类型\r\n            \r\n","\r\n            How many Cor types have we cached so far.\r\n            ":"\r\n            到目前为止，我们已经缓存了多少种COR类型。\r\n            \r\n","\r\n              Looks up a localized string similar to LIB environment variable.\r\n            ":"\r\n              查找类似于LIB环境变量的局部字符串。\r\n            \r\n","\r\n            State of awaitable expressions, for substitution in placeholders within GetAwaiter calls.\r\n            ":"在Getawaiter呼叫中替代占位符的状态。\r\n            \r\n","Called when the visitor visits a IncompleteMemberSyntax node.":"当访问者访问不完整的元纳克斯节点时，请致电。\r\n","\r\n            Return the complement of this value set.\r\n            ":"\r\n            返回此值集的补充。\r\n            \r\n","Callback to provide location.":"回调以提供位置。\r\n","\r\n            The default charset used for type marshalling. \r\n            Can be changed via ":"\r\n            用于类型编组的默认字符集。\r\n            可以通过\r\n",", but each have a ":"，但是每个人都有一个\r\n","Stores all the information from binding for calling a Deconstruct method.":"将所有信息存储在绑定中以调用解构方法。\r\n","Method '{0}' with an iterator block must be 'async' to return '{1}'":"用迭代块的方法'{0}'必须为'async'才能返回{1}'\r\n","Overloaded binary operator '{0}' takes two parameters":"超载二进制运算符'{0}'采用两个参数\r\n","\r\n            Gets constant value to be stored in metadata Constant table.\r\n            ":"\r\n            获取恒定值以存储在元数据常数表中。\r\n            \r\n"," is allowed to analyze in parallel.\r\n            ":" 允许并行分析。\r\n            \r\n","Unsafe type '{0}' cannot be used in object creation":"不安全的类型'{0}'不能在对象创建中使用\r\n","\r\n            Join state from other try block, potentially in a nested method.\r\n            ":"\r\n            从其他尝试块中加入状态，有可能采用嵌套方法。\r\n            \r\n","      | yes | no  | different |\r\n             ":"      |是|否|不同的|\r\n             \r\n","\r\n              Looks up a localized string similar to tuples.\r\n            ":"\r\n              查找类似于元组的局部字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Overloadable operator expected.\r\n            ":"\r\n              查找类似于预期的可超载运算符的本地化字符串。\r\n            \r\n","ExpressionSyntax representing the operand of the \"await\" operator.":"表示“等待”操作员操作数的表达方式。\r\n","\r\n            This method is called by the binder when it is finished binding a set of attributes on the symbol so that\r\n            the symbol can extract data from the attribute arguments and potentially perform validation specific to\r\n            some well known attributes.\r\n            ":"\r\n            当粘合剂完成绑定符号上的一组属性时，该方法是调用的\r\n            该符号可以从属性参数中提取数据，并可能执行特定于\r\n            一些众所周知的属性。\r\n            \r\n","'{0}' is not an attribute class":"'{0}'不是属性类\r\n","It is not legal to use nullable reference type '{0}?' in an is-type expression; use the underlying type '{0}' instead.":"使用无效的参考类型“ {0}？”是不合法的。在IS型表达中；代替使用基础类型'{0}'。\r\n","\r\n            Returns information about each method that was considered during overload resolution,\r\n            and what the results of overload resolution were for that method.\r\n            ":"返回有关在超载分辨率期间考虑的每种方法的信息，\r\n            以及该方法的超载分辨率结果是什么。\r\n            \r\n","\r\n            We're going to synthesize some well-known attributes for this assembly symbol.  However, at synthesis time, it is\r\n            too late to report diagnostics or cancel the emit.  Instead, we check for use site errors on the types and members\r\n            we know we'll need at synthesis time.\r\n            ":"\r\n            我们将为此汇编符号合成一些众所周知的属性。但是，在合成时，它是\r\n            为了报告诊断或取消EMIT的时间太晚。相反，我们在类型和成员的类型上检查使用网站错误\r\n            我们知道我们需要在合成时间。\r\n            \r\n","\r\n            Parse a ParameterListSyntax node.\r\n            ":"\r\n            解析一个参数名单的nondax节点。\r\n            \r\n"," directive that precedes it and that\r\n            either specifies an explicit file path or is ":" 先于它之前的指示\r\n            要么指定明确的文件路径或\r\n","Tuple with {0} elements cannot be converted to type '{1}'.":"用{0}元素的元组不能转换为类型'{1}'。\r\n","A static member cannot be marked as '{0}'":"静态成员不能标记为'{0}'\r\n","\r\n            3) T is an interface, class, struct, enum, or delegate type ":"\r\n            3）T是接口，类，结构，枚举或委托类型\r\n","The left-hand side of an assignment must be a variable, property or indexer":"分配的左侧必须是变量，属性或索引器\r\n","\r\n              Looks up a localized string similar to Cannot use more than one type in a for, using, fixed, or declaration statement.\r\n            ":"\r\n              查找类似于使用，使用，固定或声明语句的本地化字符串不能使用多种类型。\r\n            \r\n","\r\n              Looks up a localized string similar to Unable to read debug information of method '{0}' (token 0x{1:X8}) from assembly '{2}'.\r\n            ":"\r\n              查找一个本地化的字符串，类似于无法读取方法'{0}'（token 0x {1：x8}）的调试信息，汇编'{2}'。\r\n            \r\n","\r\n            Calculates a syntax offset of a syntax position that is contained in a property or field initializer (if it is in fact contained in one).\r\n            ":"计算包含在属性或字段初始化器中的语法位置的语法偏移（如果实际上包含在一个中）。\r\n            \r\n","ref conditional expression":"参考条件表达\r\n","True if a diagnostic was reported.":"如果报告了诊断，则为是真的。\r\n","Missing file specification for '{0}' option":"缺少“ {0}”选项的文件规范\r\n","\r\n              Looks up a localized string similar to Invalid option '{0}' for /langversion; must be ISO-1, ISO-2, Default, Latest or a valid version in range 1 to 7.1..\r\n            ":"\r\n              查找类似于 /langversion的无效选项'{0}'的本地化字符串；必须是ISO-1，ISO-2，默认，最新或有效版本1至7.1中的有效版本。\r\n            \r\n","\r\n            Consumers must provide implementation for ":"\r\n            消费者必须提供实施\r\n","Member declaration syntax.":"会员声明语法。\r\n","\r\n            Continue looking for declaration of predefined CorLib type in this Assembly\r\n            while symbols for new type declarations are constructed.\r\n            ":"\r\n            继续在此组件中寻找预定义的corlib类型的声明\r\n            而构建了新类型声明的符号。\r\n            \r\n","\r\n            Is the current token one that could start an expression?\r\n            ":"\r\n            当前令牌是否可以启动表达式？\r\n            \r\n","'{0}': an attribute type argument cannot use type parameters":"'{0}'：属性类型参数不能使用类型参数\r\n","\r\n              Looks up a localized string similar to Syntax tree should be created from a submission..\r\n            ":"\r\n              查找类似于语法树的本地化字符串应从提交中创建。\r\n            \r\n","\r\n            Explicit unboxing conversions as described in section 6.2.5 of the C# language specification.\r\n            ":"\r\n            如C＃语言规范第6.2.5节所述，显式拆箱转换。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid option '{0}' for /nullable; must be 'disable', 'enable', 'warnings' or 'annotations'.\r\n            ":"\r\n              查找类似于无效选项'{0}'的本地化字符串for /nullable;必须“禁用”，“启用”，“警告”或“注释”。\r\n            \r\n","\r\n            Returns the marshalling type of this field, or 0 if marshalling information isn't available.\r\n            ":"\r\n            返回此字段的编组类型，或者如果没有编组信息，则返回0。\r\n            \r\n","\r\n            Gets a list of all the diagnostics associated with the trivia.\r\n            ":"\r\n            获取与琐事相关的所有诊断列表。\r\n            \r\n","Nullability of reference types in type doesn't match implemented member '{0}'.":"类型中参考类型的无效性不匹配实现的成员'{0}'。\r\n","\r\n              Looks up a localized string similar to '{0}': cannot override '{1}' because it is not supported by the language.\r\n            ":"\r\n              查找类似于'{0}'：无法覆盖'{1}'的本地化字符串，因为该语言不支持它。\r\n            \r\n","\r\n            Override this property to return the child bound nodes if the IOperation API corresponding to this bound node is not yet designed or implemented.\r\n            ":"\r\n            如果尚未设计或实现与此界节点相对应的ioperation API，则覆盖此属性以返回子界节点。\r\n            \r\n","Creates a new IsPatternExpressionSyntax instance.":"创建一个新的isPatterNexpressionsyntax实例。\r\n","\r\n             An async-iterator state machine has a flag indicating \"dispose mode\".\r\n             We enter dispose mode by calling DisposeAsync() when the state machine is paused on a `yield return`.\r\n             DisposeAsync() will resume execution of the state machine from that state (using existing dispatch mechanism\r\n             to restore execution from a given state, without executing other code to get there).\r\n            \r\n             From there, we don't want normal code flow:\r\n             - from `yield return`, we'll jump to the enclosing `finally` (or method exit)\r\n             - after finishing a `finally`, we'll jump to the next enclosing `finally` (or method exit)\r\n            \r\n             Some `finally` clauses may have already been rewritten and extracted to a plain block (":"\r\n             异步 - 列表状态机具有指示“处置模式”的标志。\r\n             当状态机在“收益率返回”上暂停时，我们通过调用disposeasync（）进入处置模式。\r\n             disposeasync（）将恢复该状态的状态计算机执行（使用现有的调度机制\r\n             从给定状态恢复执行，而无需执行其他代码到达那里）。\r\n            \r\n             从那里，我们不需要普通代码流：\r\n              - 从“收益率返回”，我们将跳到封闭式``最后'（或方法退出）\r\n              - 完成``最后''之后，我们将跳到下一个封闭式``最后''（或方法退出）\r\n            \r\n             一些最终的条款可能已经重写并提取到一个普通的块（\r\n","\r\n            Get the default fields for the tuple's elements (in order and cached).\r\n            ":"\r\n            获取元组元素的默认字段（按顺序和缓存）。\r\n            \r\n","\r\n            Fields allocated for temporary variables are given unique names distinguished by a number at the end.\r\n            This counter ensures they are unique within a given translated method.\r\n            ":"\r\n            为临时变量分配的字段给出了唯一的名称，该名称在末尾以数字区分。\r\n            该计数器确保它们在给定的翻译方法中是独一无二的。\r\n            \r\n","\r\n            Some method kinds do not participate in overriding/hiding (e.g. constructors).\r\n            ":"\r\n            某些方法不参与覆盖/隐藏（例如构造函数）。\r\n            \r\n","Creates a new ConditionalAccessExpressionSyntax instance.":"创建一个新的条件cassexpressionsyntax实例。\r\n","\r\n              Looks up a localized string similar to Expression does not have a name..\r\n            ":"\r\n              查找类似于表达式的本地化字符串没有名称。\r\n            \r\n","\r\n            Return the nearest type parameter with the given name in\r\n            this symbol or any enclosing symbol.\r\n            ":"\r\n            返回带有给定名称的最近类型参数\r\n            此符号或任何封闭符号。\r\n            \r\n","\r\n            A lazily calculated instance of ":"一个懒惰的实例\r\n","The argument to typeof.":"typeof的论点。\r\n"," - that is left to the caller.\r\n            ":" -这是留给来电者。\r\n            \r\n","#endregion directive expected":"#Endregion指令期望\r\n","\r\n              Looks up a localized string similar to Expected identifier or numeric literal.\r\n            ":"\r\n              查找类似于预期标识符或数字文字的本地化字符串。\r\n            \r\n","\r\n            If this.IsFixedSizeBuffer is true, returns the underlying implementation type for the\r\n            fixed-size buffer when emitted.  Otherwise returns null.\r\n            ":"如果this.isfixedSizeBuffer为真，则返回的基础实现类型\r\n            固定大小的缓冲区发射时。否则返回null。\r\n            \r\n","\r\n            We're going through the containing module, rather than the containing assembly,\r\n            because of /addmodule (symbols in such modules should return null).\r\n            \r\n            Remarks, not \"ContainingCompilation\" because it isn't transitive.\r\n            ":"我们正在通过包含的模块，而不是包含的组件，\r\n            由于 /addModule（此类模块中的符号应返回null）。\r\n            \r\n            备注，而不是“包含综合”，因为它不是传递的。\r\n            \r\n","\r\n            We initialize the base's ScopeBinder with a ForEachLoopBinder, so it is safe\r\n            to cast it to that type here.\r\n            ":"\r\n            我们使用foreachloopbinder初始化基地的scopebinder，因此很安全\r\n            将其投入到此处。\r\n            \r\n","\r\n            Returns imported symbols for the given declaration.\r\n            ":"\r\n            返回给定声明的导入符号。\r\n            \r\n","Cannot return local '{0}' by reference because it is not a ref local":"无法通过引用返回本地'{0}'，因为它不是Ref Local\r\n",").\r\n            Presently, rationalizing this behavior is not worthwhile.\r\n            ":"）。\r\n            目前，合理化这种行为是不值得的。\r\n            \r\n","Possibly incorrect assignment to local '{0}' which is the argument to a using or lock statement. The Dispose call or unlocking will happen on the original value of the local.":"可能是对本地'{0}'的分配，这是对使用或锁定语句的参数。处置呼叫或解锁将发生在本地的原始价值上。\r\n","\r\n            The type syntax, if any, from source. Optional for patterns that can omit an explicit type.\r\n            ":"\r\n            来自源的类型语法（如果有）。可选的模式可以忽略显式类型。\r\n            \r\n","The expression must be of type '{0}' because it is being assigned by reference":"该表达式必须为“ {0}”类型，因为它是通过参考分配的\r\n","\r\n            Look for names of members\r\n            ":"\r\n            查找会员姓名\r\n            \r\n","\r\n            When the allowed output of a property/indexer is not-null but the allowed input is maybe-null, we store a not-null value instead.\r\n            This way, assignment of a legal input value results in a legal output value.\r\n            This adjustment doesn't apply to oblivious properties/indexers.\r\n            ":"\r\n            当属性/索引器的允许输出不是无效的，但允许的输入也许是null时，我们将存储一个非null值。\r\n            这样，法律输入价值的分配会导致法律产出价值。\r\n            此调整不适用于遗忘属性/索引器。\r\n            \r\n","\r\n            Lookup a type defined in a module of a multi-module assembly.\r\n            ":"\r\n            查找在多模块组件的模块中定义的类型。\r\n            \r\n","\r\n            Returns true if the conversion is an implicit null or default literal conversion.\r\n            ":"\r\n            如果转换是隐式null或默认文字转换，则返回true。\r\n            \r\n","If true, the method may return null for a missing member without an exception":"如果为true，则该方法可能会返回缺失成员的null，而无需例外\r\n","\r\n            This instance is used for performing approximate overload resolution of documentation\r\n            comment ":"\r\n            此实例用于执行文档的近似过载分辨率\r\n            评论\r\n","\r\n            Binds the type for the syntax taking into account possibility of \"unmanaged\" type.\r\n            ":"\r\n            考虑到“不受管理”类型的可能性，将语法类型绑定。\r\n            \r\n","\r\n             During early attribute decoding, we consider a safe subset of all members that will not\r\n             cause cyclic dependencies.  Get all such members for this symbol that have a particular name.\r\n            \r\n             In particular, this method will return nested types and fields (other than auto-property\r\n             backing fields).\r\n             ":"\r\n             在早期属性解码期间，我们考虑所有成员的安全子集\r\n             导致循环依赖性。获取具有特定名称的此符号的所有此类成员。\r\n            \r\n             特别是，此方法将返回嵌套类型和字段（自动范围除外\r\n             支持字段）。\r\n             \r\n","\r\n            Creates a function pointer from individual parts. This method should only be used when diagnostics are not needed.\r\n            ":"\r\n            从各个部分创建功能指针。仅在不需要诊断时才能使用此方法。\r\n            \r\n","\r\n            Gets the name and id of the local that are going to be generated into the debug metadata.\r\n            ":"\r\n            获取将生成Debug Metadata的本地的名称和ID。\r\n            \r\n","\r\n              Looks up a localized string similar to The first operand of an overloaded shift operator must have the same type as the containing type, and the type of the second operand must be int.\r\n            ":"\r\n              查找类似于超载移位操作员的第一操作数的本地化字符串必须具有与包含类型相同的类型，并且第二操作数的类型必须为int。\r\n            \r\n","\r\n            Visits all the ArrayRankSpecifiers of a typeSyntax, invoking an action on each one in turn.\r\n            ":"\r\n            访问型号的所有arrayrankspecifier，依次援引每个动作。\r\n            \r\n","\r\n              Looks up a localized string similar to Asynchronous foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNextAsync' method and public 'Current' property.\r\n            ":"\r\n              查找类似于异步的本地化字符串，要求“ {1}”的返回类型'{0}'必须具有合适的公共'moveNextAsync'方法和公共'当前'属性。\r\n            \r\n","\r\n            This helper is used by both LocalRewriter and IOperation. \r\n              - For lowering, 'localRewriter' must be passed in as an argument, and set 'binder' and 'diagnostics' to null.\r\n              - For deriving argument expression for IArgument operation, 'localRewriter' must be null, and 'compilation', 'diagnostics' \r\n                must be passed in, where 'callerMemberName' must not be null if 'parameter.IsCallerMemberName' is 'true'.\r\n            ":"\r\n            该助手均由localrewriter和ioperation使用。\r\n               - 为了降低，必须将“ localrewriter”作为参数传递，并将“粘合剂”和“诊断”设置为null。\r\n               - 为了得出IARGUMEMENT操作的参数表达式，“ localrewriter”必须为null和“汇编”，“诊断”\r\n                必须传递，如果“ callermembername”不得为'parameter.iscallermembername'为“ true”。\r\n            \r\n","Item2":"项目2\r\n","\r\n              Looks up a localized string similar to async streams.\r\n            ":"\r\n              查找类似于异步流的本地化字符串。\r\n            \r\n","\r\n            Raw assembly version as specified in the AssemblyVersionAttribute, or null if none specified.\r\n            If the string passed to AssemblyVersionAttribute contains * the version build and/or revision numbers are set to ":"\r\n            原始汇编版本如“汇编”中指定的，如果未指定，则为null。\r\n            如果字符串传递给assemblyVersionAttribute *\r\n","\r\n            https://github.com/dotnet/roslyn/issues/30067 Should\r\n            UnassignedFieldsWalker inherit from ":"\r\n            https://github.com/dotnet/roslyn/issues/30067 应该\r\n            UnassignedFieldsWalker继承自 \r\n","Gets the arguments syntax list.":"获取参数语法列表。\r\n","\r\n            Creates a speculative SemanticModel for a method body that did not appear in the original source code.\r\n            ":"\r\n            为未出现在原始源代码中的方法主体创建一个投机词素模型。\r\n            \r\n","The semantic information for the topmost node of the cref.":"CREF最高节点的语义信息。\r\n","\r\n              Looks up a localized string similar to 'new' cannot be used with tuple type. Use a tuple literal expression instead..\r\n            ":"查找类似于“新”的本地化字符串不能与元组类型一起使用。改用元组文字表达式。\r\n            \r\n","Class which represents the syntax node for the array type.":"代表数组类型的语法节点的类。\r\n","Using the generic {1} '{0}' requires {2} type arguments":"使用通用{1}'{0}'需要{2}类型参数\r\n","\r\n            This subclass of MetadataDecoder is specifically for finding\r\n            method symbols corresponding to method MemberRefs.  The parent \r\n            implementation is unsuitable because it requires a PEMethodSymbol\r\n            for context when decoding method type parameters and no such\r\n            context is available because it is precisely what we are trying\r\n            to find.  Since we know in advance that there will be no context\r\n            and that signatures decoded with this class will only be used\r\n            for comparison (when searching through the methods of a known\r\n            TypeSymbol), we can return indexed type parameters instead.\r\n            ":"\r\n            元二核编码器的这个子类专门用于查找\r\n            方法对应于方法成员RERFS的方法符号。父母\r\n            实施不合适，因为它需要pemethodsymbol\r\n            对于解码方法类型参数时的上下文，没有此类\r\n            可以使用上下文，因为它正是我们正在尝试的\r\n            找到。由于我们事先知道不会有上下文\r\n            并且该课程解码的签名只会使用\r\n            进行比较（搜索已知的方法\r\n            typesymbol），我们可以返回索引类型参数。\r\n            \r\n","\r\n            Prefer symbols from source module, then from added modules, then from referenced assemblies.\r\n            ":"\r\n            喜欢来自源模块的符号，然后是从添加的模块，然后是引用的组件中的符号。\r\n            \r\n","Cannot restore warning 'CS{0}' because it was disabled globally":"无法恢复警告“ CS {0}”，因为它在全球范围内被禁用\r\n","Init only setters":"只有初始化的设定器\r\n"," being thrown\r\n            containing an appropriate diagnostic for the caller to report.\r\n            ":" 被扔了\r\n            包含适当的诊断供呼叫者报告。\r\n            \r\n","\r\n            The type that declared this type parameter, or null.\r\n            ":"\r\n            声明此类型参数或null的类型。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': return type must be '{2}' to match overridden member '{1}'.\r\n            ":"\r\n              查找类似于'{0}'：返回类型必须为'{2}'的本地化字符串，才能匹配覆盖成员'{1}'。\r\n            \r\n","\r\n            True if new variables introduced in ":"\r\n            如果引入了新变量，则为真实\r\n"," with no known type, given lookup resultKind and the given bound children.\r\n            ":" 没有已知的类型，给定的resultionkind和给定的孩子。\r\n            \r\n","\r\n            Add IEnumerator<elementType> IEnumerable<elementType>.GetEnumerator()\r\n            ":"\r\n            添加ienumerator <ementhtype> iEnumerable <ementhtype> .getEnumerator（）\r\n            \r\n","\r\n            A structure used to lexically order symbols. For performance, it's important that this be \r\n            a STRUCTURE, and be able to be returned from a symbol without doing any additional allocations (even\r\n            if nothing is cached yet.)\r\n            ":"\r\n            用于词汇订购符号的结构。为了表现，重要的是\r\n            结构，并且能够从符号中返回而无需进行任何其他分配（甚至\r\n            如果什么都没有缓存。）\r\n            \r\n","'{0}' must match by init-only of overridden member '{1}'":"'{0}'必须匹配仅由覆盖成员'{1}'匹配\r\n","Creates a new DiscardPatternSyntax instance.":"创建一个新的DossardPatternsyntax实例。\r\n","IdentifierNameSyntax representing the identifier name.":"代表标识符名称的标识名称。\r\n","Base type for property declaration syntax.":"属性声明语法的基本类型。\r\n","switch on boolean type":"打开布尔类型\r\n","\r\n              Looks up a localized string similar to Filter expression is a constant 'true'.\r\n            ":"\r\n              查找类似于滤波器表达式的本地化字符串是常数的“ true”。\r\n            \r\n"," corresponding to each ":" 对应于每个\r\n","method group":"方法组\r\n","\r\n            Returns true if the conversion is an implicit boxing conversion.\r\n            ":"\r\n            如果转换是隐式拳击转换，则返回true。\r\n            \r\n","'{0}' cannot be extern and have a constructor initializer":"'{0}'不能外部并具有构造函数初始化器\r\n","\r\n            The inferred type at the point of declaration of var locals and parameters.\r\n            ":"\r\n            在VAR局部和参数声明点处的推断类型。\r\n            \r\n","{0} version {1}":"{0}版本{1}\r\n"," if the tree was not compiled as an interactive submission.\r\n            ":" 如果树未作为交互式提交编译。\r\n            \r\n","TypeSyntax representing the type of the object being created.":"代表正在创建的对象的类型的型号。\r\n","\r\n            Instrument a switch case when clause, which is translated to a conditional branch to the body of the case block.\r\n            ":"\r\n            仪器一个开关案例当子句转换为案例块正文的条件分支。\r\n            \r\n","Nullability of reference types in type doesn't match implemented member.":"类型中参考类型的无效性不匹配实现的成员。\r\n","\r\n            Gets the specified language version, which is the value that was specified in\r\n            the call to the constructor, or modified using the ":"\r\n            获取指定的语言版本，这是在\r\n            调用构造函数，或使用\r\n","\r\n            Verify the constant value matches the default value from any earlier attribute\r\n            (DateTimeConstantAttribute or DecimalConstantAttribute).\r\n            If not, report ERR_FieldHasMultipleDistinctConstantValues.\r\n            ":"\r\n            验证从任何早期属性的常数值匹配默认值\r\n            （DateTimeConstantAttribute或DecimalConstantAttribute）。\r\n            如果不是，请报告err_fieldhasmultipledistincconstantvalues。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid rank specifier: expected ',' or ']'.\r\n            ":"\r\n              查找类似于无效等级规范的本地化字符串：预期'，''或']'。\r\n            \r\n","\r\n              Looks up a localized string similar to The out parameter '{0}' must be assigned to before control leaves the current method.\r\n            ":"\r\n              查找类似于OUT参数'{0}'的本地化字符串，必须分配给控件离开当前方法。\r\n            \r\n","\r\n              Looks up a localized string similar to Argument cannot be used as an output for parameter due to differences in the nullability of reference types..\r\n            ":"\r\n              查找类似于参数的本地化字符串由于参考类型的无效性的差异而无法用作参数的输出。\r\n            \r\n",".\r\n            \r\n            NOTE: dev11 also calls this on string initializers in fixed statements,\r\n            but never accomplishes anything since string is a reference type.  This\r\n            is probably a bug, but fixing it would be a breaking change.\r\n            ":"。\r\n            \r\n            注意：dev11还在固定语句中的字符串初始化器上调用此，\r\n            但是，由于字符串是参考类型，因此永远不会完成任何事情。这个\r\n            可能是一个错误，但是修复它将是一个破坏的变化。\r\n            \r\n","Gets the expression.":"获取表达。\r\n","\r\n            Returns false because local variable can't be sealed.\r\n            ":"\r\n            返回错误，因为无法密封本地变量。\r\n            \r\n","'{0}' adds an accessor not found in interface member '{1}'":"'{0}'添加接口成员中未找到的访问者'{1}'\r\n","\r\n            BlockSyntax node representing the body of the anonymous function.\r\n            This will never be null.\r\n            ":"\r\n            blocksyntax节点代表匿名函数的主体。\r\n            这永远不会为空。\r\n            \r\n","\r\n            Descends through Rest fields of a tuple if \"symbol\" is an extended field\r\n            As a result the \"symbol\" will be adjusted to be the field of the innermost tuple\r\n            and a corresponding containingSlot is returned.\r\n            Return value -1 indicates a failure which could happen for the following reasons\r\n            a) Rest field does not exist, which could happen in rare error scenarios involving broken ValueTuple types\r\n            b) Rest is not tracked already and forceSlotsToExist is false (otherwise we create slots on demand)\r\n            ":"\r\n            如果“符号”是扩展字段，则通过元组的休息场降下\r\n            结果，“符号”将被调整为最内心的田野\r\n            并返回了相应的遏制点。\r\n            返回值-1表示由于以下原因而发生的故障\r\n            a）不存在休息场，这可能在涉及损坏的估值类型的罕见错误场景中发生\r\n            b）尚未跟踪休息，而leserslotstoexist是错误的（否则我们可以按需创建插槽）\r\n            \r\n","True means that the last name should not be consumed\r\n            if it is followed by a parameter list.":"正确意味着不应消耗姓氏\r\n            如果后面是参数列表。\r\n","The type of the expression in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.":"{0}子句中的表达式类型不正确。键入推理在调用“ {1}'”中失败。\r\n","\r\n            Gets corresponding special TypeId of this type.\r\n            ":"\r\n            获取该类型对应的特殊TypeId。\r\n            \r\n","\r\n            The set containing all values of the type.\r\n            ":"\r\n            包含类型的所有值的集合。\r\n            \r\n","\r\n            Will be false in a lambda in an iterator.\r\n            ":"在迭代器中的lambda中将是错误的。\r\n            \r\n","interpolated strings":"插值字符串\r\n","\r\n            When set, do not perform aggressive optimizations that degrade debugging experience.\r\n            In particular we do not do the following:\r\n            \r\n            1) Do not elide any user defined locals, even if never read from. \r\n               Example:\r\n                 {\r\n                   var dummy = Foo();    // should not become just \"Foo\"\r\n                 }\r\n                   \r\n               User might want to examine dummy in the debugger.\r\n            \r\n            2) Do not carry values on the stack between statements\r\n               Example:\r\n                 {\r\n                   var temp = Foo();\r\n                   temp.ToString();       // should not become   Foo().ToString();\r\n                 }\r\n                  \r\n               User might want to examine temp in the debugger.\r\n                   \r\n            ":"\r\n            设置时，请勿执行激进的优化，以降低调试经验。\r\n            特别是我们不执行以下操作：\r\n            \r\n            1）即使从未阅读，也不要列出任何用户定义的当地人。\r\n               例子：\r\n                 {\r\n                   var dummy = foo（）; //不应该只是“ foo”\r\n                 }\r\n                   \r\n               用户可能想检查调试器中的假人。\r\n            \r\n            2）不要在语句之间的堆栈上携带值\r\n               例子：\r\n                 {\r\n                   var temp = foo（）;\r\n                   temp.tostring（）; //不应成为foo（）。toString（）;\r\n                 }\r\n                  \r\n               用户可能想检查调试器中的临时工。\r\n                   \r\n            \r\n","\r\n            Common base for ordinary methods synthesized by compiler for records.\r\n            ":"\r\n            编译器合成的记录的普通方法的共同基础。\r\n            \r\n","The type '{0}' already contains a definition for '{1}'":"类型'{0}'已经包含了'{1}'的定义\r\n","A namespace symbol representing the merged namespace.":"代表合并名称空间的名称空间符号。\r\n","'await' requires that the type '{0}' have a suitable 'GetAwaiter' method. Are you missing a using directive for 'System'?":"“等待”要求类型'{0}'具有合适的“ getawaiter”方法。您是否缺少使用“系统”的指令？\r\n","\r\n              Looks up a localized string similar to Expected contextual keyword 'on'.\r\n            ":"\r\n              查找类似于预期上下文关键字“ ON”的本地化字符串。\r\n            \r\n","\r\n            Returns true if this compilation contains the specified tree.  False otherwise.\r\n            ":"\r\n            如果此汇编包含指定的树，则返回true。否则为错误。\r\n            \r\n","\r\n            Flags applied to the top-level binder created for each syntax tree in the compilation \r\n            as well as for the binder of global imports.\r\n            ":"\r\n            在编译中为每个语法树创建的顶级粘合剂的标志\r\n            以及全球进口的活页夹。\r\n            \r\n","\r\n            Gets a syntax token\r\n            ":"\r\n            获取语​​法令牌\r\n            \r\n","\r\n            True if the given token is not really some contextual keyword.\r\n            This method is for use in executable code, as it treats `partial` as an identifier.\r\n            ":"\r\n            如果给定的令牌不是真正的上下文关键字，则是的。\r\n            此方法用于可执行代码，因为它将“部分”视为标识符。\r\n            \r\n"," as part of ":" 作为...的一部分\r\n","\r\n              Looks up a localized string similar to { or ; expected.\r\n            ":"\r\n              查找类似于{或;预期的。\r\n            \r\n","\r\n            Merge (already ordered) non-type, non-indexer members with (already ordered) indexer members.\r\n            ":"\r\n            合并（已经订购的）非类型，非索引成员与（已经订购的）索引成员。\r\n            \r\n","\r\n              Looks up a localized string similar to Command line switch is not yet implemented.\r\n            ":"\r\n              查找类似于命令行开关的本地化字符串尚未实现。\r\n            \r\n","\r\n            Placeholder locals, e.g. for objects being constructed.\r\n            ":"\r\n            占位当地人，例如用于构造对象。\r\n            \r\n","\r\n             The LocalBinderFactory is used to build up the map of all Binders within a method body, and the associated\r\n             CSharpSyntaxNode. To do so it traverses all the statements, handling blocks and other\r\n             statements that create scopes. For efficiency reasons, it does not traverse into\r\n             expressions. This means that blocks within lambdas and queries are not created. \r\n             Blocks within lambdas are bound by their own LocalBinderFactory when they are \r\n             analyzed.\r\n            \r\n             For reasons of lifetime management, this type is distinct from the BinderFactory \r\n             which also creates a map from CSharpSyntaxNode to Binder. That type owns it's binders\r\n             and that type's lifetime is that of the compilation. Therefore we do not store\r\n             binders local to method bodies in that type's cache. \r\n             ":"\r\n             LocalBinderFactory用于建立方法主体中所有粘合剂的地图，并相关\r\n             csharpsyntaxnode。为此，它遍历了所有陈述，处理块和其他陈述\r\n             创建范围的语句。出于效率原因，它不会穿越\r\n             表达。这意味着未创建lambdas和查询中的块。\r\n             Lambdas中的块被他们自己的LocalbinderFactory约束\r\n             分析。\r\n            \r\n             出于终生管理的原因，这种类型与绑定性不同\r\n             它还创建了从csharpsyntaxnode到粘合剂的地图。该类型拥有它的粘合剂\r\n             而这种类型的寿命就是汇编。因此我们不存储\r\n             该类型的缓存中的方法物体本地的BINDERS。\r\n             \r\n","The evaluation of the constant value for '{0}' involves a circular definition":"对“ {0}”恒定值的评估涉及一个圆形定义\r\n","\r\n            Perf impact: If we find a field with the same name, we will eagerly evaluate its type.\r\n            ":"\r\n            PURF IMPACT：如果我们找到具有相同名称的字段，我们将热切地评估其类型。\r\n            \r\n","\r\n            True if the method signature can be rewritten to contain ref/out parameters.\r\n            ":"\r\n            正确，如果可以重写方法签名以包含参数。\r\n            \r\n","\r\n            Rewriter for the BoundInterpolatedString or BoundUnconvertedInterpolatedString parts of the binary operator. Passed the callback\r\n            parameter, the original interpolated string, and the index of the interpolated string in the tree.\r\n            ":"\r\n            重写二进制运算符的BONDINTERPOLATYSTRING或BONDUNCONVETTERTERTEDSTRING零件。通过了回调\r\n            参数，原始的插值字符串和树中插值字符串的索引。\r\n            \r\n","\r\n            Determine if the given string starts with the given prefix if whitespace\r\n            is first trimmed from the beginning.\r\n            ":"\r\n            确定给定的字符串是否以给定前缀开始\r\n            首先从头开始修剪。\r\n            \r\n","\r\n            A side-effect-free expression representing the LHS.\r\n            The returned node needs to be lowered but its children are already lowered.\r\n            ":"\r\n            代表LHS的无副作用表达。\r\n            返回的节点需要降低，但其孩子已经降低。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': an entry point cannot be marked with the 'async' modifier.\r\n            ":"查找类似于“ {0}'的局部字符串：不能用'async'修饰符标记入口点。\r\n            \r\n","\r\n              Looks up a localized string similar to A 'using static' directive can only be applied to types; '{0}' is a namespace not a type. Consider a 'using namespace' directive instead.\r\n            ":"\r\n              查找类似于“使用静态”指令的本地化字符串只能应用于类型。 '{0}'是名称空间而不是类型。改用“使用名称空间”指令。\r\n            \r\n","Command-line syntax error: Invalid Guid format '{0}' for option '{1}'":"命令行语法错误：无效GUID格式'{0}'for Option'{1}'\r\n","By-reference returns may only be used in methods that return by reference":"征收回报只能用于通过参考返回的方法\r\n","\r\n              Looks up a localized string similar to Inconsistent accessibility: event type '{1}' is less accessible than event '{0}'.\r\n            ":"\r\n              查找类似于不一致的可访问性的本地化字符串：事件类型'{1}'比事件'{0}'易于访问。\r\n            \r\n","\r\n            Generates the GetAsyncEnumerator method.\r\n            ":"\r\n            生成getAsyncenumerator方法。\r\n            \r\n","Name conflict for name {0}":"名称的名称冲突{0}\r\n","\r\n            Affected range of a change is the range within which nodes can be affected by a change\r\n            and cannot be reused. Because of lookahead effective range of a change is larger than\r\n            the change itself.\r\n            ":"\r\n            受影响的变化范围是节点可以受到更改影响的范围\r\n            并且不能重复使用。由于lookahead的有效范围，变化大于\r\n            变化本身。\r\n            \r\n","\r\n              Looks up a localized string similar to An out variable cannot be declared as a ref local.\r\n            ":"\r\n              查找类似于OUT变量的本地化字符串不能被声明为REF Local。\r\n            \r\n","The containing method of the node to be rewritten":"要重写节点的包含方法\r\n","\r\n            Binds the type for the syntax taking into account possibility of \"var\" type.\r\n            ":"\r\n            考虑到“ var”类型的可能性，将语法类型绑定。\r\n            \r\n","If tuple element nullable annotations are specified, the number of annotations must match the cardinality of the tuple.":"如果指定了元组元素无效的注释，则注释的数量必须与元组的基数匹配。\r\n"," (state machine) starting with the given set of cases in the root node,\r\n            and return the node for the root.\r\n            ":"（状态机）从根节点中的给定情况开始，\r\n            并返回根的节点。\r\n            \r\n","\r\n              Looks up a localized string similar to The name '{0}' is not in scope on the right side of 'equals'.  Consider swapping the expressions on either side of 'equals'..\r\n            ":"\r\n              查找类似于“ {0}”名称的本地化字符串在“ equals”的右侧不在范围内。考虑将表达式交换在“平等”的两侧。\r\n            \r\n","\r\n            Represents a non-terminal node in the syntax tree.\r\n            ":"\r\n            代表语法树中的非末端节点。\r\n            \r\n","\r\n              Looks up a localized string similar to An in parameter cannot have the Out attribute..\r\n            ":"\r\n              查找类似于In参数类似的本地化字符串不能具有OUT属性。\r\n            \r\n","A floating-point type.":"浮点类型。\r\n",". By the language rules, the\r\n            result is either that same scope (if the type is a ref struct type) or ":"。根据语言规则，\r\n            结果要么是相同的范围（如果类型为REF结构类型）或\r\n","\r\n            Naive thread pool focused on reducing the latency to execution of chunky work items as much as possible.\r\n            If a thread is ready to process a work item the moment a work item is queued, it's used, otherwise\r\n            a new thread is created. This is meant as a stop-gap measure for workloads that would otherwise be\r\n            creating a new thread for every work item.\r\n            ":"\r\n            幼稚的线池专注于减少尽可能多的矮小工作项目的延迟。\r\n            如果一个线程准备处理工作项目，则使用工作项，则使用，否则\r\n            创建了一个新线程。这是作为工作负载的一项定格间隙措施，否则\r\n            为每个工作项目创建一个新线程。\r\n            \r\n","\r\n            Given a enum member declaration, get the corresponding field symbol.\r\n            ":"\r\n            给定枚举成员声明，​​获取相应的字段符号。\r\n            \r\n","\r\n            This is the state from the local function which makes the\r\n            current state less specific. For example, in nullable analysis\r\n            this would be captured variables that may be nullable after\r\n            calling the local function. When a local function is called,\r\n            this state is ":"这是本地函数的状态\r\n            当前状态不太具体。例如，在无效分析中\r\n            这将是捕获的变量，在\r\n            调用本地功能。当调用本地函数时，\r\n            这个状态是\r\n","\r\n            Returns the value of a binary Unicode character.\r\n            ":"\r\n            返回二进制Unicode字符的值。\r\n            \r\n","\r\n            If an expression node that declares synthesized short-lived locals (currently only sequence) contains an await, these locals become long-lived since their \r\n            values may be read by code that follows the await. We promote these variables to long-lived of kind ":"\r\n            如果声明合成的短寿命当地人（目前仅序列）的表达节点包含一个等待\r\n            值可以通过遵循等待的代码读取。我们将这些变量推广到长寿\r\n","\r\n            Compares calling conventions, ignoring calling convention attributes.\r\n            ":"\r\n            比较呼叫约定，忽略呼叫惯例属性。\r\n            \r\n","Cannot return 'this' by reference.":"无法通过参考返回“此”。\r\n","\r\n            You may assume that this would share code and logic with PEMethodSymbol.OverridesRuntimeFinalizer,\r\n            but FUNCBRECCS::bindDestructor has its own loop that performs these checks (differently).\r\n            ":"您可以假设这将与pemethodsymbol.overridesruntimefinalizer共享代码和逻辑，\r\n            但是funcbreccs :: binddestructor具有自己的循环，可以执行这些检查（以不同的方式）。\r\n            \r\n"," for details).\r\n            ":" 有关详细信息）。\r\n            \r\n","'{0}' cannot implement '{1}' because it is not supported by the language":"'{0}'无法实现'{1}'，因为语言不支持它\r\n","\r\n            Collects whitespace and new line trivia for XML doc comments. Does not see XML doc comment exterior trivia, and is a no op unless we are in the interior.\r\n            ":"\r\n            为XML Doc评论收集Whitespace和新线条琐事。看不到XML Doc评论外部琐事，除非我们在内部，否则是没有OP。\r\n            \r\n","\r\n            Owning RetargetingPropertySymbol.\r\n            ":"\r\n            拥有retargetingpropertysymbol。\r\n            \r\n","Invalid assembly name: {0}":"无效的汇编名称：{0}\r\n","\r\n            Gets a SyntaxToken that represents the open parenthesis preceding the switch expression.\r\n            ":"\r\n            获取一个代表开关表达式之前的开放括号的语法。\r\n            \r\n","'{0}': static classes cannot contain protected members":"'{0}'：静态类不能包含受保护的成员\r\n","\r\n            Gets the identity of this assembly.\r\n            ":"\r\n            获得此组件的身份。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot await in the body of a finally clause.\r\n            ":"\r\n              查找类似于最终子句的主体中类似的局部字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Lambda expressions that return by reference cannot be converted to expression trees.\r\n            ":"\r\n              查找类似于lambda表达式的局部字符串，该字符串无法通过引用返回，无法转换为表达式树。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串，不能将其标记为CLS兼容，因为汇编没有CLSCompliant属性。\r\n            \r\n","Filter expression is a constant 'true'":"滤波器表达是一个常数的“ true”\r\n","\r\n            Synthesize the final signature for all closures.\r\n            ":"\r\n            合成所有关闭的最终签名。\r\n            \r\n","expression body constructor and destructor":"表达车身构造函数和破坏者\r\n","\r\n            If search within assembly fails, lookup in assemblies referenced by the primary module.\r\n            For source assembly, this is equivalent to all assembly references given to compilation.\r\n            ":"\r\n            如果在组件中搜索失败，则在主模块引用的汇编中查找。\r\n            对于源组件，这等同于所有汇编的所有组件参考。\r\n            \r\n","\r\n            No pointer, nullable, or array types.\r\n            Leaves a dot and a name unconsumed if the name is not followed by another dot\r\n            and checkForMember is true.\r\n            ":"\r\n            没有指针，无效或数组类型。\r\n            如果没有跟随另一个点，请留下一个点和一个名字\r\n            和CheckFormember是正确的。\r\n            \r\n","\r\n            Returns a constructed named type symbol if 'type' is generic, otherwise just returns 'type'\r\n            ":"\r\n            如果“类型”是通用的，则返回一个构造的命名类型符号，否则只返回“类型”\r\n            \r\n","The raw text of the literal.":"文字的原始文本。\r\n","\r\n              Looks up a localized string similar to Invalid variance: The type parameter '{1}' must be {3} valid on '{0}'. '{1}' is {2}..\r\n            ":"\r\n              查找类似于无效方差的本地化字符串：类型参数'{1}'必须在'{0}'上有效{3}。 '{1}'是{2} ..\r\n            \r\n","Expected an end tag for element '{0}'.":"期望元素'{0}'的结束标签。\r\n","Omitting the type argument is not allowed in the current context":"在当前上下文中不允许省略类型参数\r\n","\r\n              Looks up a localized string similar to XML comment has a param tag, but there is no parameter by that name.\r\n            ":"\r\n              查找类似于XML注释的本地化字符串具有参数标签，但是该名称没有参数。\r\n            \r\n","\r\n            Track fields of classes in addition to structs.\r\n            ":"\r\n            除结构外，类的田径场。\r\n            \r\n","\r\n            A method that results from the translation of a single lambda expression.\r\n            ":"由单个lambda表达式翻译产生的方法。\r\n            \r\n","\r\n            Parse a parenthesized parameter list.\r\n            ":"\r\n            解析括号的参数列表。\r\n            \r\n","\r\n            This method is intended to return values consistent with the definition of C#, which\r\n            may differ from the actual meaning at runtime.\r\n            \r\n            Note: we don't need a different path for interfaces - Property.OverriddenOrHiddenMembers handles that.\r\n            ":"\r\n            此方法旨在返回与C＃的定义一致的值\r\n            可能与运行时的实际含义有所不同。\r\n            \r\n            注意：我们不需要接口的路径 -  property.overridendorhiddenmbers处理了这一点。\r\n            \r\n"," are not saved as part of the initialization phase of ":" 作为作为初始化阶段的一部分保存\r\n","Constant value '{0}' cannot be converted to a '{1}' (use 'unchecked' syntax to override)":"常数值'{0}'不能转换为'{1}'（使用'未选中的'语法替代）\r\n","Gets the base type list.":"获取基本类型列表。\r\n","\r\n            A mapping from the local variable slot to the symbol for the local variable itself.  This\r\n            is used in the implementation of region analysis (support for extract method) to compute\r\n            the set of variables \"always assigned\" in a region of code.\r\n            ":"\r\n            从局部变量插槽到局部变量本身的符号的映射。这个\r\n            用于实施区域分析（支持提取方法）以计算\r\n            一组变量在代码区域中“总是分配”。\r\n            \r\n","\r\n            Returns first or a modified version of first with common tuple names from both types.\r\n            ":"\r\n            首先返回或修改后的第一个版本，带有两种类型的常见元组名称。\r\n            \r\n","\r\n              Looks up a localized string similar to You must provide an initializer in a fixed or using statement declaration.\r\n            ":"\r\n              查找类似于您的本地化字符串必须在固定或使用语句声明中提供初始化器。\r\n            \r\n","'{0}': no suitable method found to override":"'{0}'：找不到合适的方法\r\n","\r\n            Need to import them for an enum from a linked assembly, when we are embedding it. These symbols are not included into lazyMembersInDeclarationOrder.  \r\n            ":"\r\n            当我们嵌入时，需要从链接组件中导入枚举。这些符号不包含在lazymembersindeclarationdorder中。\r\n            \r\n","\r\n            Creates an empty list of trivia.\r\n            ":"\r\n            创建一个空的琐事列表。\r\n            \r\n","\r\n            By default this information is extracted from ":"\r\n            默认情况下，此信息是从中提取的\r\n","\r\n            A binder suitable for performing overload resolution to synthesize a call to a helper method.\r\n            ":"\r\n            适合执行过载分辨率的粘合剂，以合成对助手方法的调用。\r\n            \r\n","\r\n            Gets a SyntaxToken that represents the open parenthesis preceding the switch governing expression.\r\n            ":"\r\n            获取表示switch管理表达式前面的左括号的SyntaxToken。\r\n            \r\n","The CallerMemberNameAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments":"CallermemberneateTribute将无效，因为它适用于不允许可选参数的上下文中使用的成员\r\n","Creates a new TypeParameterListSyntax instance.":"创建一个新的TypeparameterListsyntax实例。\r\n","\r\n              Looks up a localized string similar to Attribute parameter '{0}' must be specified..\r\n            ":"\r\n              必须指定类似于属性参数'{0}'的本地化字符串。\r\n            \r\n","\r\n            It's not interesting to report diagnostics on implementation of interface accessors\r\n            if the corresponding events or properties are not implemented (i.e. we want to suppress\r\n            cascading diagnostics).\r\n            Caveat: Indexed property accessors are always interesting.\r\n            Caveat: It's also uninteresting if a WinRT event is implemented by a non-WinRT event,\r\n            or vice versa.\r\n            ":"\r\n            报告有关实现接口登录器的诊断毫不有趣\r\n            如果未实现相应的事件或属性（即，我们要压制\r\n            级联诊断）。\r\n            警告：索引的物业访问者总是很有趣。\r\n            警告：如果通过非获胜事件实施WinRT事件，也无趣\r\n            或相反亦然。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid XML include element -- {0}.\r\n            ":"\r\n              查找类似于无效XML的本地化字符串，包括元素 -  {0}。\r\n            \r\n","The Conditional attribute is not valid on '{0}' because it is a constructor, destructor, operator, lambda expression, or explicit interface implementation":"条件属性在“ {0}”上无效，因为它是构造函数，驱动器，操作员，lambda表达式或显式接口实现\r\n","\r\n            Type layout information (ClassLayout metadata and layout kind flags).\r\n            ":"\r\n            键入布局信息（classLayout元数据和布局类似标志）。\r\n            \r\n","\r\n            Convenience helper called by subclasses to add a synthesized attribute to a collection of attributes.\r\n            ":"\r\n            子类调用的便利助手将合成的属性添加到属性集合中。\r\n            \r\n","The raw text of the bad token.":"不良令牌的原始文本。\r\n","\r\n            Sets the analyzed nullability of the expression to be the given result.\r\n            ":"\r\n            将分析表达式的无效性设置为给定的结果。\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability of reference types in return type of '{0}' doesn't match the target delegate '{1}'..\r\n            ":"\r\n              查找类似于“ {0}'的返回类型中的参考类型的无效性类似的本地化”字符串，与目标委托'{1}'..不匹配。\r\n            \r\n","\r\n              Looks up a localized string similar to A static local function cannot contain a reference to 'this' or 'base'..\r\n            ":"\r\n              查找类似于静态本地函数的本地化字符串不能包含对“ this”或“ base”的引用。\r\n            \r\n","\r\n            Returns true if the type cannot be used as an explicit base class.\r\n            ":"\r\n            如果不能将类型用作显式基类，则返回true。\r\n            \r\n","Called when the visitor visits a EnumMemberDeclarationSyntax node.":"当访问者访问EnummemberDeclarationsyntax节点时打电话。\r\n","\r\n            Expression can be the operand of an address-of operation (&).\r\n            Same as ReadonlyRef. The difference is just for error reporting.\r\n            ":"\r\n            表达可以是地址操作（＆）的操作数。\r\n            与Readonlyref相同。区别仅用于错误报告。\r\n            \r\n","Array initializers can only be used in a variable or field initializer. Try using a new expression instead.":"数组初始化器只能在变量或字段初始化器中使用。尝试使用新表达式。\r\n","\r\n            A bag in which diagnostics that should be reported after code gen can be deposited.\r\n            ":"\r\n            在代码生成后应报告诊断的袋子。\r\n            \r\n","\r\n            Returns true if the members of superType are accessible from subType due to inheritance.\r\n            ":"\r\n            如果由于继承而可以从子类型访问超类型的成员，则返回为true。\r\n            \r\n","Called when the visitor visits a WithExpressionSyntax node.":"当访问者访问带有expardionsyntax节点的访问时调用。\r\n","\r\n              Looks up a localized string similar to The EnumeratorCancellationAttribute applied to parameter '{0}' will have no effect. The attribute is only effective on a parameter of type CancellationToken in an async-iterator method returning IAsyncEnumerable.\r\n            ":"\r\n              查找类似于应用于参数'{0}'的EnumeratorCancellationAttribute类似的本地化字符串将没有效果。该属性仅在返回iAsyncencenumerable的异步 - 列表方法中的类型concellationToken的参数上有效。\r\n            \r\n","\r\n            Returns false because local variable can't be overridden.\r\n            ":"\r\n            返回false，因为局部变量不能被覆盖。\r\n            \r\n","\r\n            Compare two lexical sort keys in a compilation.\r\n            ":"\r\n            比较汇编中的两个词汇排序键。\r\n            \r\n","Creates a new BreakStatementSyntax instance.":"创建一个新的Breakstatementsyntax实例。\r\n","Create a Range object starting from first element to the end.":"创建一个从第一个元素到末端开始的范围对象。\r\n","String containing the resolved file path if PermissionSetAttribute needs fixup during codegen, null otherwise.":"字符串包含已解决的文件路径的字符串如果CodeGen期间的PermissionsetAttribute需要修复，则否则为null。\r\n","Enhanced generic constraints":"增强的通用约束\r\n","\r\n            then the name will be checked both as-is as well as with the 'Attribute' suffix.\r\n            ":"\r\n            然后，将检查名称以及“属性”后缀。\r\n            \r\n","\r\n            This instance is used when trying to determine if one member implicitly implements another,\r\n            according to the C# definition.\r\n            The member names, parameters, and (return) types must match. Custom modifiers are ignored.\r\n            ":"\r\n            试图确定一个成员是否暗中实现另一个成员时使用此实例，\r\n            根据C＃定义。\r\n            成员名称，参数和（返回）类型必须匹配。自定义修饰符被忽略。\r\n            \r\n","\r\n            Returns a list of accessible, non-hidden indexers that could be invoked with the given expression\r\n            as a receiver.\r\n            ":"\r\n            返回可以用给定表达式调用的可访问的，非隐藏索引的列表\r\n            作为接收者。\r\n            \r\n","\r\n            Simple program uses await expressions. Set only in conjunction with ":"\r\n            简单程序使用等待表达式。仅与\r\n","\r\n            In many cases, e.g. PeekChar, we need the ability to indicate that there are\r\n            no characters left and we have reached the end of the stream, or some other\r\n            invalid or not present character was asked for. Due to perf concerns, things\r\n            like nullable or out variables are not viable. Instead we need to choose a\r\n            char value which can never be legal.\r\n            \r\n            In .NET, all characters are represented in 16 bits using the UTF-16 encoding.\r\n            Fortunately for us, there are a variety of different bit patterns which\r\n            are *not* legal UTF-16 characters. 0xffff (char.MaxValue) is one of these\r\n            characters -- a legal Unicode code point, but not a legal UTF-16 bit pattern.\r\n            ":"\r\n            在许多情况下，例如peekchar，我们需要表明存在的能力\r\n            没有字符剩下，我们已经到达了流的尽头，或其他一些\r\n            要求无效或不存在角色。由于人们的关注，事情\r\n            像无效的变量一样，不可行。相反，我们需要选择一个\r\n            字符价值永远是合法的。\r\n            \r\n            在.NET中，所有字符均使用UTF-16编码以16位表示。\r\n            对我们来说幸运的是，有多种不同的图案\r\n            是 *不是 *法律UTF-16字符。 0xffff（char.maxvalue）是其中之一\r\n            字符 - 合法的Unicode代码点，但不是合法的UTF-16位模式。\r\n            \r\n","\r\n            Creates a SemanticModel for a parameter default value.\r\n            ":"\r\n            为参数默认值创建semanticmodel。\r\n            \r\n","\r\n              Looks up a localized string similar to Single-line comment or end-of-line expected.\r\n            ":"\r\n              查找类似于单线注释或预期终止的本地化字符串。\r\n            \r\n","\r\n            Replace Task-like types with Task types. Returns true if there were changes.\r\n            ":"\r\n            用任务类型替换类似任务的类型。如果有变化，则返回真实。\r\n            \r\n"," for remaining fixup steps.\r\n             ":" 用于剩余的修复步骤。\r\n             \r\n","set to true if the returned path requires some when clause to evaluate to 'false'":"如果返回的路径在子句时需要一些评估为“ false”，则设置为true\r\n","\r\n            Type variables are never considered value types by the verifier.\r\n            ":"\r\n            类型变量永远不会被验证者视为价值类型。\r\n            \r\n","\r\n            The record type includes a synthesized override of object.Equals(object? obj).\r\n            It is an error if the override is declared explicitly. The synthesized override\r\n            returns Equals(other as R) where R is the record type.\r\n            ":"\r\n            记录类型包括一个合成的对象覆盖。equals（object？obj）。\r\n            如果明确声明覆盖物，则是错误。合成的替代\r\n            返回等于（其他为r），其中r是记录类型。\r\n            \r\n",",\r\n            and replaces ":"，，，，\r\n            并替换\r\n","\r\n              Looks up a localized string similar to Indexed property '{0}' has non-optional arguments which must be provided.\r\n            ":"\r\n              查找类似于索引属性'{0}'的本地化字符串，具有必须提供的非选项参数。\r\n            \r\n","\r\n              Looks up a localized string similar to The member '{0}' does not hide an inherited member. The new keyword is not required..\r\n            ":"\r\n              查找类似于成员'{0}'的本地化字符串不会隐藏继承的成员。不需要新的关键字。\r\n            \r\n","\r\n            Produce a random value for testing.\r\n            ":"\r\n            产生一个随机值进行测试。\r\n            \r\n","\r\n            Checks to see if a body is legal given the current modifiers.\r\n            If it is not, a diagnostic is added with the current type.\r\n            ":"\r\n            检查鉴于当前的修饰符，检查身体是否合法。\r\n            如果不是这样，则添加了当前类型的诊断。\r\n            \r\n","\r\n              Looks up a localized string similar to Operator '{0}' is ambiguous on an operand of type '{1}'.\r\n            ":"\r\n              在类型'{1}'的操作数上查找类似于操作员'{0}'的本地化字符串。\r\n            \r\n","Called when the visitor visits a JoinClauseSyntax node.":"当访客访问joinclausesyntax节点时打电话。\r\n"," with string argument.\r\n            ":" 使用字符串参数。\r\n            \r\n","Type parameter list syntax.":"类型参数列表语法。\r\n","\r\n            will not know which containing slot to look for.\r\n            ":"\r\n            将不知道要寻找哪个插槽。\r\n            \r\n","The single token.":"单个令牌。\r\n","\r\n             It catches putting a `null` into a `[DisallowNull]int?` for example, which cannot simply be represented as a non-nullable target type.\r\n             ":"\r\n             它抓住将`null'放入``null''[dislownull] int？\r\n             \r\n","The 'this' object cannot be used in a constructor before all of its fields have been assigned":"在分配所有字段之前，不能在构造函数中使用“此”对象\r\n","\r\n            There are three possible cases where we need disposal:\r\n            - pattern-based disposal (we have a Dispose/DisposeAsync method)\r\n            - interface-based disposal (the enumerator type converts to IDisposable/IAsyncDisposable)\r\n            - we need to do a runtime check for IDisposable\r\n            ":"\r\n            在三种可能的情况下，我们需要处置：\r\n             - 基于模式的处置（我们有一个处置/disposeasync方法）\r\n             - 基于接口的处置（枚举类型类型转换为IDISPOSABLE/IASYNCDISPOSABLE）\r\n             - 我们需要进行运行时检查以idisposable\r\n            \r\n","The expression must be of type '{0}' to match the alternative ref value":"表达式必须是类型的“ {0}”才能匹配替代参考值\r\n","\r\n              Looks up a localized string similar to Unable to load Analyzer assembly {0} : {1}.\r\n            ":"\r\n              查找类似于无法加载分析仪汇编{0}的本地化字符串：{1}。\r\n            \r\n","\r\n            A collection of variables associated with a method scope. For a particular method, the variables\r\n            may contain parameters and locals and any fields from other variables in the collection. If the method\r\n            is a nested function (a lambda or a local function), there is a reference to the variables collection at\r\n            the containing method scope. The outermost scope may also contain variables for static fields.\r\n            Each variable (parameter, local, or field of other variable) must be associated with the variables collection\r\n            for that method where the parameter or local are declared, even if the variable is used in a nested scope.\r\n            ":"\r\n            与方法范围关联的变量集合。对于特定方法，变量\r\n            可以包含集合中其他变量的参数和当地人以及任何字段。如果方法\r\n            是嵌套函数（lambda或本地功能），有一个对变量集合的引用\r\n            包含方法范围。最外面的范围也可能包含用于静态字段的变量。\r\n            每个变量（参数，本地或其他变量的字段）必须与变量集合关联\r\n            对于该方法，即使在嵌套范围中使用该变量，也要声明参数或本地。\r\n            \r\n","An expression tree may not contain a multidimensional array initializer":"表达树可能不包含多维阵列初始化器\r\n","The starting index within the string.":"字符串中的起始索引。\r\n","\r\n            Indicates that this binder is being used to answer SemanticModel questions (i.e. not\r\n            for batch compilation).\r\n            ":"\r\n            表明该粘合剂被用于回答semanticmodel问题（即\r\n            用于批处理）。\r\n            \r\n","\r\n              Looks up a localized string similar to /embed switch is only supported when emitting a PDB..\r\n            ":"\r\n              查找类似于 /嵌入开关的本地化字符串仅在排放PDB时才支持。\r\n            \r\n","the underlying primitive numeric type":"基本原始数字类型\r\n","\r\n              Looks up a localized string similar to Assembly culture strings may not contain embedded NUL characters..\r\n            ":"\r\n              查找类似于汇编文化字符串的局部字符串可能不包含嵌入式的nul字符。\r\n            \r\n","\r\n              Looks up a localized string similar to Ref mismatch between '{0}' and delegate '{1}'.\r\n            ":"\r\n              查找类似于“ {0}'和委托'{1}'之间不匹配的Ref不匹配的本地化字符串。\r\n            \r\n"," into a\r\n            proper call.\r\n            ":" 进入\r\n            适当的电话。\r\n            \r\n","\r\n            Given a list of method and/or property candidates, choose the first one (if any) with a signature\r\n            that matches the parameter list in the cref.  Return null if there isn't one.\r\n            ":"\r\n            给定方法和/或属性候选者列表，请选择具有签名的第一个（如果有）\r\n            与CREF中的参数列表匹配。返回null如果没有。\r\n            \r\n"," synthesized types to the compilation state\r\n            and creates hoisted fields for all locals captured by the environments.\r\n            ":" 合成类型的汇编状态\r\n            并为环境捕获的所有当地人创建引起的字段。\r\n            \r\n","The syntax node that declares an indexer.":"声明索引器的语法节点。\r\n","\r\n            fixed(char* ptr = stringVar){ ... }    == becomes ===>\r\n            \r\n            pinned string pinnedTemp = stringVar;    // pinning managed ref\r\n            char* ptr = (char*)pinnedTemp;           // unsafe cast to unmanaged ptr\r\n            if (pinnedTemp != null) ptr += OffsetToStringData();\r\n              . . . \r\n            ":"\r\n            固定（char* ptr = stringvar）{...} == ===>\r\n            \r\n            固定字符串PINNEDTEMP = StringVar; //固定托管参考\r\n            char* ptr =（char*）pinnedtemp; //不安全的ptr不安全\r\n            if（pinnedtemp！= null）ptr += offsetToStringData（）;\r\n              。 。 。\r\n            \r\n"," graph and\r\n            may replace or remove visited SyntaxNodes in depth-first order.\r\n            ":" 图和\r\n            可以在深度优先替换或删除访问的语法。\r\n            \r\n","\r\n            Source assembly that triggered creation of this module symbol.\r\n            For debug purposes only, this assembly symbol should not be persisted within\r\n            this module symbol because the module can be shared across multiple source \r\n            assemblies. This method will only be called for the first one.\r\n            ":"\r\n            源组件触发了此模块符号的创建。\r\n            仅出于调试目的，此组装符号不应在其中持续\r\n            此模块符号，因为可以通过多个源共享模块\r\n            集会。只有第一种方法将被调用。\r\n            \r\n","Type parameter '{0}' has the same name as the type parameter from outer type '{1}'":"类型参数'{0}'具有与外部类型'{1}'的类型参数相同的名称\r\n","Creates a new JoinClauseSyntax instance.":"创建一个新的joinclausesyntax实例。\r\n","\r\n            The class to represent all events imported from a PE/module.\r\n            ":"\r\n            代表从PE/模块导入的所有事件的类。\r\n            \r\n","\r\n            A MemberCrefSyntax specified by a this keyword and an optional parameter list.\r\n            For example, \"this\" or \"this[int]\".\r\n            ":"\r\n            由此关键字和可选参数列表指定的成员crefsyntax。\r\n            例如，“ this”或“ this [int]”。\r\n            \r\n","\r\n            Spec 7.7.7.1:\r\n            An Awaiter A has an accessible, readable instance property IsCompleted of type bool.\r\n            ":"\r\n            规格7.7.7.1：\r\n            等待者A具有bool类型的可访问，可读的实例属性。\r\n            \r\n"," will not know\r\n            which containing slot to look for.\r\n            ":" 不会知道\r\n            其中包含要寻找的插槽。\r\n            \r\n","Dictionary initializer":"字典初始化器\r\n","\r\n            When a local variable's type is inferred, it may not be used in the\r\n            expression that computes its value (and type). This property returns\r\n            the expression where a reference to an inferred variable is forbidden.\r\n            ":"\r\n            当推断本地变量的类型时，可能不会在\r\n            计算其值（和类型）的表达式。此属性返回\r\n            禁止对推断变量引用的表达式。\r\n            \r\n","\r\n            The lowered decision dag. This includes all of the code to decide which pattern\r\n            is matched, but not the code to assign to pattern variables and evaluate when clauses.\r\n            ":"\r\n            降低的决策DAG。这包括所有代码来决定哪种模式\r\n            是匹配的，但不能分配给模式变量的代码并评估条款时。\r\n            \r\n","Called when the visitor visits a RelationalPatternSyntax node.":"当访问者访问关系patternsyntax节点时，请致电。\r\n","\r\n            Creates a new compilation without any syntax trees. Preserves metadata info\r\n            from this compilation for use with trees added later.\r\n            ":"\r\n            创建一个没有任何语法树的新汇编。保留元数据信息\r\n            从此汇编中，以与树一起添加。\r\n            \r\n","The indexer access needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.":"索引器访问需要动态派遣，但不能是因为它是基本访问表达式的一部分。考虑施放动态参数或消除基本访问。\r\n","Throws this exception if this model is a speculative semantic model, i.e. ":"如果此模型是投机性语义模型，即\r\n","\r\n              Looks up a localized string similar to Cannot derive from '{0}' because it is a type parameter.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串，因为它是类型参数。\r\n            \r\n"," to begin visiting at":" 开始访问\r\n","Partial declarations of '{0}' have conflicting accessibility modifiers":"“ {0}”的部分声明具有冲突的可访问性修饰符\r\n","\r\n              Looks up a localized string similar to Constraint cannot be a dynamic type '{0}'.\r\n            ":"\r\n              查找类似于约束的本地化字符串不能是动态类型'{0}'。\r\n            \r\n","A reference was created to embedded interop assembly because of an indirect assembly reference":"由于间接组件参考\r\n","\r\n            Compares this type to another type.\r\n            ":"\r\n            将这种类型与另一种类型进行比较。\r\n            \r\n","\r\n            This function is expected to be called a lot.  As such, it avoids memory\r\n            allocations in the function itself (including not making any iterators).  This means\r\n            that certain helper functions that could otherwise be called are inlined in this method to\r\n            prevent the overhead of returning collections or enumerators.\r\n            ":"\r\n            预计此功能将被称为很多。因此，它避免了记忆\r\n            函数本身的分配（包括不制作任何迭代器）。这表示\r\n            该方法中的某些某些可以称为否则可以称为的辅助功能\r\n            防止返回的收藏或枚举者的开销。\r\n            \r\n","\r\n            True if the parameter is attributed with ":"\r\n            如果参数归因于\r\n","SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.":"ArrayRankSpecifiersyntax节点的语法列表表示数组的等级指定列表。\r\n","\r\n            Determines if two syntax tokens are the same, disregarding trivia differences.\r\n            ":"\r\n            确定两个语法令牌是否相同，无视琐事差异。\r\n            \r\n","Called when the visitor visits a IndexerMemberCrefSyntax node.":"当访问者访问indexermembercrefsyntax节点时，请致电。\r\n","\r\n              Looks up a localized string similar to foreach iteration variable.\r\n            ":"\r\n              查找类似于foreach迭代变量的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to XML comment has a duplicate typeparam tag for '{0}'.\r\n            ":"\r\n              查找类似于XML注释的本地化字符串具有“ {0}”的重复typeparam标签。\r\n            \r\n","Unused extern alias":"未使用的外部别名\r\n","ExpressionSyntax node representing the expression on the right of the binary operator.":"表示二进制运算符右侧的表达式的表达式节点。\r\n","the chained-to ctor":"链式的ctor\r\n","'{0}': static types cannot be used as parameters":"'{0}'：静态类型不能用作参数\r\n","Creates a new AnonymousObjectMemberDeclaratorSyntax instance.":"创建一个新的AnonymobjectMemberDeclaratorsyntax实例。\r\n","\r\n            Creates a binder for a container.\r\n            ":"\r\n            为容器创建活页夹。\r\n            \r\n","Source file '{0}' could not be opened -- {1}":"无法打开源文件'{0}' -  {1}\r\n","\r\n              Looks up a localized string similar to Cannot create constructed generic type from another constructed generic type..\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法从另一种构造的通用类型中创建构造的通用类型。\r\n            \r\n"," map will be empty unless the type is a\r\n            built-in type because other types do not have constant values. In that case only the\r\n            ":" 地图将是空的，除非类型为\r\n            内置类型是因为其他类型没有恒定值。在这种情况下，只有\r\n            \r\n","\r\n              Looks up a localized string similar to The new() constraint must be the last constraint specified.\r\n            ":"查找类似于新（）约束的本地化字符串必须是指定的最后一个约束。\r\n            \r\n","\r\n            A collection of type parameter constraints, populated when\r\n            constraints for the first type parameter is requested.\r\n            Initialized in two steps. Hold a copy if accessing during initialization.\r\n            ":"\r\n            类型参数约束的集合，当\r\n            请求第一个类型参数的约束。\r\n            以两个步骤初始化。如果在初始化期间访问，请持有副本。\r\n            \r\n","XML comment has cref attribute '{0}' that refers to a type parameter":"XML注释具有CREF属性'{0}'，它是指类型参数\r\n","Gets the close bracket token.":"获取紧密的括号令牌。\r\n","Reported diagnostic '{0}' has a source location '{1}' in file '{2}', which is outside of the given file.":"报告的诊断'{0}'具有源位置'{1}'在file'{2}'中，它在给定文件之外。\r\n","\r\n            Represents a net-module imported from a PE. Can be a primary module of an assembly.\r\n            ":"\r\n            表示从PE导入的净模块。可以是组件的主要模块。\r\n            \r\n","\r\n              Looks up a localized string similar to Option overrides attribute given in a source file or added module.\r\n            ":"\r\n              查找类似于源文件或添加模块中给出的选项覆盖属性的本地化字符串。\r\n            \r\n","More than one protection modifier":"多个保护修饰符\r\n","\r\n              Looks up a localized string similar to '{0}' hides inherited member '{1}'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword..\r\n            ":"\r\n              查找类似于'{0}'隐藏成员'{1}'的本地化字符串。要使当前成员覆盖该实现，请添加覆盖关键字。否则添加新关键字。\r\n            \r\n","Called when the visitor visits a InterpolatedStringTextSyntax node.":"当访问者访问插值stringTextSyntax节点时，请致电。\r\n","\r\n            A context for binding type parameter symbols of named types.\r\n            ":"\r\n            命名类型的绑定类型参数符号的上下文。\r\n            \r\n","The given expression is never of the provided ('{0}') type":"给定的表达式从不提供（'{0}'）类型\r\n","Covariant return types":"协变返回类型\r\n","\r\n            Generally ArgumentSyntax nodes do not declare symbols, except when used as aarguments of a tuple literal.\r\n            Example:  var x = (Alice: 1, Bob: 2);\r\n                      ArgumentSyntax \"Alice: 1\" declares a tuple element field \"(int Alice, int Bob).Alice\"\r\n            ":"\r\n            通常，grongumentsyntax节点不会声明符号，除非用作元组字面的aarguments。\r\n            示例：var x =（爱丽丝：1，鲍勃：2）;\r\n                      grumentsyntax“爱丽丝：1”声明了一个元组元素字段”（int alice，int bob）。\r\n            \r\n","\r\n            parameter holds the current state information for the local function being visited. To\r\n            save state information across the analysis, return an instance of ":"\r\n            参数保留了要访问的本地功能的当前状态信息。至\r\n            在分析中保存状态信息，返回一个实例\r\n","\r\n              Looks up a localized string similar to '{0}' cannot be extern and declare a body.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串不能为外部并声明身体。\r\n            \r\n","Constant value '{0}' cannot be converted to a '{1}'":"常数值'{0}'不能转换为'{1}'\r\n","\r\n            True if the list has at least one node of the specified kind.\r\n            ":"\r\n            正确，如果列表至少具有指定类型的一个节点。\r\n            \r\n","\r\n            A guarded decision tree, which simply binds a set of variables (this is used to assign to the\r\n            pattern variables of the switch case), optionally evaluates a Guard expression (which corresponds\r\n            to the ":"\r\n            一个受保护的决策树，它只是绑定一组变量（这用于分配给\r\n            开关情况的模式变量），可选地评估护罩表达式（对应\r\n            到\r\n","The namespace of the potentially forwarded type. If none is provided, will\r\n            try Usings of the current import for eligible namespaces and return the namespace of the found forwarder,\r\n            if any.":"潜在转发类型的名称空间。如果没有提供\r\n            尝试使用合格名称空间的当前导入的使用，然后返回找到的转发器的名称空间，\r\n            如果有的话。\r\n","\r\n            This property allows the search for extension methods to be narrowed quickly.\r\n            ":"\r\n            此属性允许搜索扩展方法快速缩小。\r\n            \r\n","\r\n            Full type name, possibly with generic name mangling.\r\n            ":"\r\n            完整的名称，可能带有通用名称。\r\n            \r\n","\r\n            Set to true of any lambda expressions were seen in the analyzed method body.\r\n            ":"\r\n            在分析的方法主体中可以看到任何lambda表达式的真实。\r\n            \r\n","A partial method cannot have the 'abstract' modifier":"部分方法不能具有“抽象”修饰符\r\n","\r\n            When an answer is a named symbol that is reachable by traversing from the root of the symbol\r\n            table, (that is, from an ":"\r\n            当答案是通过从符号的根部穿越的命名符号\r\n            桌子（也就是\r\n","The syntax for the expression body of an expression-bodied member.":"表达构件的表达体的语法。\r\n","Explicit interface implementation matches more than one interface member":"显式接口实现与多个接口成员匹配\r\n","\r\n            Helper class for (1) finding reachable and unreachable switch cases in binding, and (2)\r\n            building a decision tree for lowering. As switch labels are added to the decision tree\r\n            being built, a data structure (decision tree) representing the sequence of operations\r\n            required to select the applicable case branch is constructed. See ":"\r\n            （1）在绑定中查找可触及和无法到达的开关案例的助手类，（2）\r\n            构建降低决策树。随着开关标签添加到决策树\r\n            被构建，代表操作顺序的数据结构（决策树）\r\n            构建选择适用的案例分支所需。看\r\n","Syntax node":"语法节点\r\n","The operation overflows at compile time in checked mode":"该操作在编译时间以检查模式溢出\r\n","\r\n              Looks up a localized string similar to Inconsistent accessibility: indexer return type '{1}' is less accessible than indexer '{0}'.\r\n            ":"\r\n              查找类似于不一致的可访问性的本地化字符串：索引返回类型'{1}''不如indexer'{0}'访问。\r\n            \r\n","A method marked [DoesNotReturn] should not return.":"标记[do notorturn]的方法不应返回。\r\n","Alignment value has a magnitude that may result in a large formatted string":"对齐值的幅度可能会导致一个格式化的字符串\r\n","\r\n             On the other hand, ":"\r\n             另一方面，\r\n","\r\n            Gets a list of all the diagnostics in the sub tree that has the specified node as its root.\r\n            ":"\r\n            获取具有指定节点作为词根的子树中所有诊断的列表。\r\n            \r\n","\r\n            The definite assignment and/or reachability state at the point currently being analyzed.\r\n            ":"\r\n            当前正在分析的点，确定的分配和/​​或可达性状态。\r\n            \r\n","Called when the visitor visits a DocumentationCommentTriviaSyntax node.":"当访问者访问DocumentationCommentTriviaSyntax节点时致电。\r\n","\r\n              Looks up a localized string similar to Identifier expected.\r\n            ":"\r\n              查找与预期标识符类似的本地化字符串。\r\n            \r\n","Default interface methods":"默认接口方法\r\n","\r\n              Looks up a localized string similar to private protected.\r\n            ":"\r\n              查找类似于私人保护的局部字符串。\r\n            \r\n","True if multiple T's are found.":"如果找到多个T，则为thue。\r\n","\r\n              Looks up a localized string similar to foreach requires that the return type '{0}' of '{1}' must have a suitable public MoveNext method and public Current property.\r\n            ":"\r\n              查找类似于foreach的本地化字符串要求“ {1}”的返回类型'{0}'必须具有合适的公共MoveNext方法和公共当前属性。\r\n            \r\n","Inferred tuple element names":"推断的元组元素名称\r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 7.0. Please use language version {1} or greater..\r\n            ":"\r\n              查找类似于功能“ {0}”的本地化字符串在C＃7.0中不可用。请使用语言版本{1}或更大。\r\n            \r\n","Attribute syntax.":"属性语法。\r\n","Members of readonly field '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type":"无法用对象初始化器分配ReadOnly字段'{0}'的类型'{1}'的成员，因为它是一个值类型\r\n","\r\n            Track static fields, properties, events, in addition to instance members.\r\n            ":"\r\n            跟踪静态字段，属性，事件，以及实例成员。\r\n            \r\n","\r\n              Looks up a localized string similar to The namespace alias qualifier '::' always resolves to a type or namespace so is illegal here. Consider using '.' instead..\r\n            ":"\r\n              查找类似于名称空间别名预选赛的本地化字符串::'总是解决类型或名称空间，因此在这里是非法的。考虑使用“。”。反而..\r\n            \r\n","Duplicate type parameter '{0}'":"重复类型参数'{0}'\r\n","SyntaxToken representing the optional ref or out keyword.":"Syntaxtoken表示可选的参考或关键字。\r\n","Array creation must have array size or array initializer":"数组创建必须具有数组大小或数组初始化器\r\n","\r\n            This is the part of the local function transfer function which\r\n            transfers knowledge additively. For example, in definite\r\n            assignment this would be captured state which is assigned by\r\n            the local function.  When a local function is called, this\r\n            state is ":"\r\n            这是本地函数传输功能的一部分\r\n            加上知识。例如，确定\r\n            分配这将是捕获的状态，由\r\n            本地功能。当调用本地功能时，此\r\n            状态是\r\n",").\r\n             In those cases, we saved the finally-entry label in ":"）。\r\n             在这种情况下，我们保存了最后一个进入标签\r\n","Gets the optional explicit interface specifier.":"获取可选的显式接口规范。\r\n"," to\r\n            complete the lowering.\r\n            ":" 至\r\n            完成降低。\r\n            \r\n","Type constraint syntax.":"类型约束语法。\r\n","\r\n            Represents a property that is based on another property.\r\n            When inheriting from this class, one shouldn't assume that \r\n            the default behavior it has is appropriate for every case.\r\n            That behavior should be carefully reviewed and derived type\r\n            should override behavior as appropriate.\r\n            ":"\r\n            代表基于另一个属性的属性。\r\n            从这个课程继承时，不应该假设\r\n            它具有的默认行为适用于每种情况。\r\n            该行为应仔细审查和派生类型\r\n            应适当地覆盖行为。\r\n            \r\n","Inconsistent accessibility: return type '{1}' is less accessible than operator '{0}'":"不一致的可访问性：返回类型'{1}'比操作员'{0}'易于访问\r\n"," implementation for the CSharp language.\r\n            ":" CSHARP语言实施。\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability of reference types in type doesn't match implicitly implemented member..\r\n            ":"\r\n              查找类似于类型中参考类型的无效性类似的本地化字符串与隐式实现的成员不匹配。\r\n            \r\n","\r\n            Used by symbol implementations (source and metadata) to represent the value\r\n            that was mapped from, or will be mapped to a [NullableContext] attribute.\r\n            ":"\r\n            由符号实现（源和元数据）用于表示值\r\n            它是从映射的，或将映射到[nullableContext]属性。\r\n            \r\n","Called when the visitor visits a EmptyStatementSyntax node.":"当访问者访问一个空阶段的intax节点时，请致电。\r\n","@$":"@$\r\n","\r\n            Binder for one of the arms of a switch expression. For example, in the one-armed switch expression\r\n            \"e switch { p when c => v }\", this could be the binder for the arm \"p when c => v\".\r\n            ":"\r\n            粘合剂用于开关表达式的臂之一。例如，在单臂开关表达式中\r\n            “ e switch {p时c => v}”，这可能是臂“ p => v”的组合。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': no suitable method found to override.\r\n            ":"\r\n              查找类似于“ {0}'的局部字符串：找不到合适的方法可以覆盖。\r\n            \r\n","The text of the expression.":"表达的文字。\r\n"," tree.\r\n            ":" 树。\r\n            \r\n","\r\n            Expression can be an RHS of an assignment operation.\r\n            ":"表达可以是分配操作的RHS。\r\n            \r\n","\r\n            The predecessor (previous larger) value to a given value. The result is not defined\r\n            when ":"\r\n            给定值的前身（以前的较大）值。结果未定义\r\n            什么时候\r\n","\r\n            The system assembly, which provides primitive types like Object, String, etc., e.g. mscorlib.dll. \r\n            The value is MissingAssemblySymbol if none of the referenced assemblies can be used as a source for the \r\n            primitive types and the owning assembly cannot be used as the source too. Otherwise, it is one of \r\n            the referenced assemblies returned by GetReferencedAssemblySymbols() method or the owning assembly.\r\n            ":"\r\n            系统组件，提供原始类型，例如对象，字符串等，例如mscorlib.dll。\r\n            如果没有参考的组件可以用作该值\r\n            原始类型和所有组件也不能用作源。否则，它是\r\n            GetRefercrededAssemblysymbols（）方法或所有组件返回的引用组件。\r\n            \r\n","Indicates whether the current Index object is equal to another object of the same type.":"指示当前索引对象是否等于同一类型的另一个对象。\r\n","foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'":"foreach语句无法在类型'{0}'的变量上操作，因为'{0}'不包含'{1}'的公共实例或扩展定义\r\n","\r\n              Looks up a localized string similar to Feature '{0}' is experimental and unsupported; use '/features:{1}' to enable..\r\n            ":"\r\n              查找类似于功能“ {0}”的局部字符串是实验性且不受支持的。使用'/功能：{1}'启用..\r\n            \r\n","\r\n            Marshalling charset of string data fields within the type (string formatting flags in metadata).\r\n            ":"\r\n            在类型（元数据中的字符串格式化标志）中编组字符串数据字段的字符集。\r\n            \r\n","\r\n            Scope to which the local's values can \"escape\" via ordinary assignments.\r\n            Not readonly because we can only know escape values after binding the initializer.\r\n            ":"\r\n            当地值可以通过普通分配“逃脱”的范围。\r\n            不阅读，因为我们只能在绑定初始化器后才知道逃生值。\r\n            \r\n","\r\n            Creates a token with kind StringLiteralToken from a string value.\r\n            ":"\r\n            从字符串值创建具有属性的字符串LiteralToken的令牌。\r\n            \r\n","Optional type arguments syntax.":"可选类型参数语法。\r\n","\r\n            Determines if the parameter ref, out or neither.\r\n            ":"\r\n            确定参数ref，out或not。\r\n            \r\n","\r\n            The current diagnostic that the enumerator is pointing at.\r\n            ":"\r\n            枚举者指向的当前诊断。\r\n            \r\n","The parameter type for ++ or -- operator must be the containing type":"++或 - 运算符的参数类型必须是包含类型\r\n","Represent a range has start and end indexes.":"表示范围具有启动和结束索引。\r\n"," except it considers ref kinds as well.\r\n            ":" 除了它也认为裁判种类。\r\n            \r\n","Token list.":"令牌列表。\r\n","A stackalloc expression requires [] after type":"类型之后需要[stackalloc表达式]\r\n","\r\n            Get all the members of this symbol. The members may not be in a particular order, and the order\r\n            may not be stable from call-to-call.\r\n            ":"\r\n            获取此符号的所有成员。成员可能不按特定顺序和订单\r\n            通话通话可能不稳定。\r\n            \r\n","\r\n            Gets the character at the given offset to the current position if\r\n            the position is valid within the SourceText.\r\n            ":"\r\n            如果给定偏移到当前位置的角色，如果\r\n            该位置在SourceText中有效。\r\n            \r\n","\r\n              Looks up a localized string similar to Iterators cannot have ref, in or out parameters.\r\n            ":"\r\n              查找类似于迭代器的本地化字符串，无法具有参数或输入参数。\r\n            \r\n","\r\n              Looks up a localized string similar to The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}.\r\n            ":"\r\n              查找类似于收集初始化器元素的最佳过载方法'{0}'的本地化字符串已过时。 {1}。\r\n            \r\n","\r\n              Looks up a localized string similar to Array initializers can only be used in a variable or field initializer. Try using a new expression instead..\r\n            ":"\r\n              查找类似于数组初始化器的本地化字符串只能在变量或字段初始化器中使用。尝试使用新表达式。\r\n            \r\n","\r\n            Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.\r\n            ":"\r\n            从文本和相应的十进制值中创建一个具有属性数字的令牌。\r\n            \r\n","\r\n              Looks up a localized string similar to It is not legal to use nullable type '{0}' in a pattern; use the underlying type '{1}' instead..\r\n            ":"\r\n              在模式中查找类似于其的本地化字符串，不合法使用nullable类型'{0}'；代替使用基础类型的“ {1}”。\r\n            \r\n","Position must be within span of the syntax tree.":"位置必须在语法树的跨度之内。\r\n","access modifiers on properties":"访问属性的修饰符\r\n","Predefined type '{0}' is not defined or imported":"预定义的类型'{0}'未定义或导入\r\n","\r\n            Returns the marshalling type of this parameter, or 0 if marshalling information isn't available.\r\n            ":"\r\n            返回此参数的编组类型，或者如果没有编组信息，则返回0。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is not public..\r\n            ":"\r\n              查找类似于“ {0}'的本地化字符串”不实现接口成员'{1}'。 '{2}'无法实现接口成员，因为它不是公共的。\r\n            \r\n","The property associated with this accessor.":"与此登录器关联的属性。\r\n","The type to search.":"要搜索的类型。\r\n"," in this SemanticModel.":" 在这个语义模型中。\r\n","\r\n              Looks up a localized string similar to No value for RuntimeMetadataVersion found.\r\n            ":"\r\n              查找与找到的RuntimeMetAdaTaversion相似的本地化字符串。\r\n            \r\n","'{0}' does not contain a constructor that takes {1} arguments":"'{0}'不包含采用{1}参数的构造函数\r\n","Called when the visitor visits a BaseListSyntax node.":"当访客访问基本词法节点时，请致电。\r\n","\r\n            The set of fields that depend on the field.\r\n            ":"\r\n            取决于字段的字段集。\r\n            \r\n","LHS":"LHS\r\n","How long should threads wait around for additional work items before retiring themselves.":"线程在退休之前应该等待多长时间才能等待其他工作项目。\r\n","\r\n            Gets or sets a value indicating whether enumeration of a generic\r\n            ":"\r\n            获取或设置一个值，指示是否枚举通用\r\n            \r\n","\r\n            The local is not user defined nor it is a copy of a user defined local (e.g. with a substituted type).\r\n            Check the value of ":"\r\n            本地不是用户定义的，也不是用户定义的本地的副本（例如，具有替换类型）。\r\n            检查价值\r\n","The call to method '{0}' needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.":"需要动态调用方法'{0}'的调用，但不能是因为它是基本访问表达式的一部分。考虑施放动态参数或消除基本访问。\r\n","} expected":"} 预期的\r\n","\r\n              Looks up a localized string similar to Using 'is' to test compatibility with 'dynamic' is essentially identical to testing compatibility with 'Object'.\r\n            ":"\r\n              查找类似于使用“ IS”的本地化字符串来测试与“ Dynamic”的兼容性基本上与测试与“对象”的兼容性相同。\r\n            \r\n","\r\n              Looks up a localized string similar to The indexer access needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access..\r\n            ":"\r\n              查找类似于索引器访问的本地化字符串需要动态调度，但不能是因为它是基本访问表达式的一部分。考虑施放动态参数或消除基本访问。\r\n            \r\n","Create an Index from the start at the position indicated by the value.":"从开始的位置从开始的位置创建一个索引。\r\n",". The full name check will then be performed in the ":"。然后将在\r\n","\r\n              Looks up a localized string similar to No overload for '{0}' matches delegate '{1}'.\r\n            ":"\r\n              查找与“ {0}”匹配委托'{1}'的本地化字符串类似于没有过载。\r\n            \r\n","\r\n            The candidate method in a delegate conversion was rejected because its return type does not match the return type of the delegate.\r\n            ":"\r\n            委托转换中的候选方法被拒绝，因为其返回类型与代表的返回类型不匹配。\r\n            \r\n","'{0}' should not have a params parameter since '{1}' does not":"'{0}'不应有一个参数，因为'{1}'没有\r\n","Tuple element names must be unique.":"元组元素名称必须是唯一的。\r\n","Called when the visitor visits a GlobalStatementSyntax node.":"访问者访问globalstatementsyntax节点时调用。\r\n","\r\n              Looks up a localized string similar to anonymous method.\r\n            ":"\r\n              查找类似于匿名方法的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Skipping some types in analyzer assembly {0} due to a ReflectionTypeLoadException : {1}..\r\n            ":"查找一个局部字符串，类似于由于ReflectionTypeloadexception而跳过某些类型的分析仪组件{0}：{1} ..\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid expression term '{0}'.\r\n            ":"\r\n              查找类似于无效的表达式'{0}'的本地化字符串。\r\n            \r\n"," for each scope with captured variables.  The generated frames are kept\r\n            in ":" 对于带有捕获变量的每个范围。生成的帧保留\r\n            在\r\n","\r\n              Looks up a localized string similar to Nullable value type may be null..\r\n            ":"\r\n              查找类似于Nullable值类型的本地化字符串可能为null。\r\n            \r\n","Returns true if enumerator moved to the next diagnostic, false if the\r\n            enumerator was at the end of the diagnostic list.":"如果枚举者移至下一个诊断，则返回true\r\n            枚举者处于诊断列表的末尾。\r\n","\r\n            Variables that were captured by anonymous functions.\r\n            ":"\r\n            由匿名函数捕获的变量。\r\n            \r\n","\r\n            Given a syntax node that declares a property or member accessor, get the corresponding\r\n            symbol.\r\n            ":"\r\n            给定一个声明属性或成员访问者的语法节点，获取相应的\r\n            象征。\r\n            \r\n","\r\n            Creates a separated list from a sequence of nodes and tokens, starting with a node and alternating between additional nodes and separator tokens.\r\n            ":"\r\n            从节点和令牌序列中创建一个分离的列表，从节点开始，然后在其他节点和分离器令牌之间交替。\r\n            \r\n","\r\n            Creates the syntax representation of an exception element within xml documentation comments.\r\n            ":"\r\n            在XML文档注释中创建异常元素的语法表示。\r\n            \r\n","\r\n            Returns false if reported an error, true otherwise.\r\n            ":"\r\n            如果报告错误，则返回false，否则为否。\r\n            \r\n","\r\n             Represents an element field of a tuple type that is not backed by a real field \r\n             with the same name within the tuple underlying type.\r\n             \r\n             Examples\r\n                 // alias to Item1 with a different name\r\n                 (int a, byte b).a                           \r\n            \r\n                 // not backed directly by the underlying type\r\n                 (int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8).i8\r\n                 \r\n             NOTE: For any virtual element, there is a nonvirtual way to access the same underlying field.\r\n                   In scenarios where we need to enumerate actual fields of a struct, \r\n                   virtual fields should be ignored.\r\n             ":"\r\n             代表元素类型的元素字段，该字段未由真实字段支持\r\n             带有元组的基础类型中的同名。\r\n             \r\n             例子\r\n                 //别名与其他名称不同\r\n                 （int a，byte b）.a\r\n            \r\n                 //未直接由基础类型支持\r\n                 （int i1，int i2，int i3，int i4，int i5，int i6，int i7，int i8）.i8\r\n                 \r\n             注意：对于任何虚拟元素，都有一种非虚拟访问相同基础字段的方式。\r\n                   在我们需要枚举结构的实际字段的情况下，\r\n                   虚拟字段应被忽略。\r\n             \r\n","Submission can have at most one syntax tree.":"提交最多可以具有一条语法树。\r\n"," that represents\r\n            an assembly that couldn't be found.\r\n            ":" 代表\r\n            找不到的组装。\r\n            \r\n","Called when the visitor visits a AttributeSyntax node.":"当访问者访问属性元素节点时调用。\r\n","\r\n              Looks up a localized string similar to Cannot define overloaded constructor '{0}' because it differs from another constructor only on ref and out.\r\n            ":"\r\n              查找类似于类似的本地化字符串无法定义重载构造函数'{0}'，因为它仅在REF和OUT上与另一个构造函数不同。\r\n            \r\n"," that represents\r\n            a module that couldn't be found.\r\n            ":" 代表\r\n            找不到的模块。\r\n            \r\n","\r\n              Looks up a localized string similar to Fixed size buffer of length {0} and type '{1}' is too big.\r\n            ":"\r\n              查找类似于长度{0}的固定大小缓冲区的局部字符串，键入'{1}'太大。\r\n            \r\n","\r\n            Checks whether given expression can escape from the current scope to the ":"\r\n            检查给定的表达是否可以从当前范围逃脱到\r\n","\r\n            Indicates whether the accessor is marked with the 'init' modifier.\r\n            ":"\r\n            指示是否用“ init”修饰符标记登录器。\r\n            \r\n","\r\n            Compute a candidate overridden method when a method knows what method it is intended to\r\n            override. This makes a particular difference when covariant returns are used, in which\r\n            case the signature matching rules would not compute the correct overridden method.\r\n            ":"\r\n            当一种方法知道其意图的方法时，计算候选方法被覆盖的方法\r\n            覆盖。当使用协变收益时，这会带来特殊的区别\r\n            案例签名匹配规则不会计算正确的覆盖方法。\r\n            \r\n","Called when the visitor visits a GroupClauseSyntax node.":"当访问者访问groupClausesyntax节点时，请致电。\r\n","\r\n            Represents a retargeting custom attribute\r\n            ":"\r\n            代表重新定制属性\r\n            \r\n","\r\n            Some types of trivia have structure that can be accessed as additional syntax nodes.\r\n            These forms of trivia include: \r\n              directives, where the structure describes the structure of the directive.\r\n              documentation comments, where the structure describes the XML structure of the comment.\r\n              skipped tokens, where the structure describes the tokens that were skipped by the parser.\r\n            ":"\r\n            某些类型的琐事具有可以作为其他语法节点访问的结构。\r\n            这些琐事的形式包括：\r\n              指令，结构描述指令的结构。\r\n              文档注释，该结构描述了评论的XML结构。\r\n              跳过令牌，该结构描述了被解析器跳过的令牌。\r\n            \r\n","\r\n              Looks up a localized string similar to Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly, except for either a 'class', or a 'struct' constraint..\r\n            ":"\r\n              查找类似于覆盖和显式接口实现方法的约束的本地化字符串是从基本方法继承的，因此不能直接指定它们，除了“类”或“ struct”约束。\r\n            \r\n","Invalid reference alias option: '{0}=' -- missing filename":"无效的参考别名选项：'{0} =' - 缺少文件名\r\n"," for the underlying\r\n             metadata as soon as the are needed.\r\n            \r\n             The new compilation uses whatever metadata is currently being provided by the ":" 对于基础\r\n             元数据一旦需要。\r\n            \r\n             新汇编使用当前正在提供的任何元数据\r\n","\r\n              Looks up a localized string similar to No overload for method '{0}' takes {1} arguments.\r\n            ":"\r\n              查找类似于方法'{0}'take {1}参数的本地化字符串。\r\n            \r\n","\r\n            Returns the first end of line found in a ":"\r\n            返回在\r\n","True if extra tokens in the input should be treated as an error":"如果应将输入中的额外令牌视为错误，则为true\r\n","Represent the inclusive start index of the range.":"表示该范围的包容性开始索引。\r\n","\r\n            Specify ":"\r\n            指定\r\n","\r\n            Once the name part of a type (including type parameter/argument lists) is parsed,\r\n            we need to consume ?, *, and rank specifiers.\r\n            ":"\r\n            一旦类型的名称部分（包括类型参数/参数列表）被解析，\r\n            我们需要消费？， *和排名指定符。\r\n            \r\n","The raw value to test.":"测试的原始值。\r\n","The type arguments for method '{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly.":"方法'{0}'的类型参数不能从用法中推断出来。尝试明确指定类型参数。\r\n","\r\n              Looks up a localized string similar to Conditional member '{0}' cannot have an out parameter.\r\n            ":"\r\n              查找类似于条件成员'{0}'的本地化字符串不能具有OUT参数。\r\n            \r\n","\r\n            A custom awaiter that supports ":"\r\n            支持的定制等待员\r\n","\r\n            Tells us if a particular try contains yield returns\r\n            ":"告诉我们特定的尝试是否包含收益率回报\r\n            \r\n","\r\n            If this is a method of a tuple type, return corresponding underlying method from the\r\n            tuple underlying type. Otherwise, null.\r\n            ":"如果这是元组类型的方法，请从\r\n            元组基础类型。否则，null。\r\n            \r\n","Stream to which XML will be written, if specified.":"如果指定了XML的流。\r\n","Semantic information about the context in which the symbol is being displayed.":"有关显示符号的上下文的语义信息。\r\n","\r\n            Represents a small change from the enclosing/next binder.\r\n            Can specify a receiver Expression for containing conditional member access.\r\n            ":"\r\n            代表与封闭/下一个活页夹相比的小变化。\r\n            可以指定包含条件成员访问的接收器表达式。\r\n            \r\n","\r\n              Looks up a localized string similar to The yield statement cannot be used inside an anonymous method or lambda expression.\r\n            ":"\r\n              在匿名方法或lambda表达式中查找类似于收益率语句的本地化字符串。\r\n            \r\n","\r\n            The bound expression that is the query expression in \"unoptimized\" form.  Specifically, a final \".Select\"\r\n            invocation that is omitted by the specification is included here.\r\n            ":"\r\n            以“不优化”形式的查询表达式的结合表达式。具体来说，最终的“选择”\r\n            此处包括规范省略的调用。\r\n            \r\n","The best overloaded method match '{0}' for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters.":"无法使用收集初始化器元素的最佳超载方法匹配'{0}'。收集初始化程序“ add”方法不能具有参数或输出参数。\r\n","The name to use in diagnostics if overload resolution fails.":"如果过载分辨率失败，则在诊断中使用的名称。\r\n","\r\n            Used to force (source) symbols to a given state of completion.\r\n            ":"\r\n            用于将（源）符号强加给给定的完成状态。\r\n            \r\n","\r\n              Looks up a localized string similar to The type '{1}' exists in both '{0}' and '{2}'.\r\n            ":"\r\n              查找类似于“ {0}”和“ {2}'的类型“ {1}”类型的本地化字符串。\r\n            \r\n","\r\n            This overload is used for member symbols during binding, or for cases other\r\n            than symbols such as attribute arguments and parameter defaults.\r\n            ":"\r\n            此超载用于绑定期间的成员符号，或其他\r\n            诸如属性参数和参数默认值之类的符号。\r\n            \r\n",".\r\n            If provided, the ":"。\r\n            如果提供，\r\n","\r\n              Looks up a localized string similar to XML comment has a typeparamref tag, but there is no type parameter by that name.\r\n            ":"\r\n              查找类似于XML注释的本地化字符串具有Typeparamref标签，但是该名称没有类型的参数。\r\n            \r\n","\r\n            Issue an error or warning for a symbol if it is Obsolete. If there is not enough\r\n            information to report diagnostics, then store the symbols so that diagnostics\r\n            can be reported at a later stage.\r\n            ":"\r\n            如果符号已过时，就会发出错误或警告。如果没有足够的\r\n            信息以报告诊断，然后存储符号，以便诊断\r\n            可以在以后的阶段进行报告。\r\n            \r\n","Only auto-implemented properties can have initializers.":"只有自动实施属性才能具有初始化器。\r\n","\r\n              Looks up a localized string similar to Defining an alias named 'global' is ill-advised.\r\n            ":"\r\n              查找类似于定义名为“ Global”的别名类似的本地化字符串。\r\n            \r\n","\r\n            Summarizes the results of an overload resolution analysis, as described in section 7.5 of\r\n            the language specification. Describes whether overload resolution succeeded, and which\r\n            method was selected if overload resolution succeeded, as well as detailed information about\r\n            each method that was considered. \r\n            ":"\r\n            总结了超负荷分析分析的结果，如第7.5节所述\r\n            语言规范。描述超载解决方案是否成功，哪些\r\n            如果超载分辨率成功，则选择方法，以及有关的详细信息\r\n            所考虑的每种方法。\r\n            \r\n","\r\n            Verify if the given type is a tuple of a given cardinality, or can be used to back a tuple type \r\n            with the given cardinality. \r\n            ":"\r\n            验证给定类型是给定基数的元组还是可以用来备份元组类型\r\n            具有给定的基数。\r\n            \r\n","\r\n            Finds the IsCompleted property of an Awaiter type.\r\n            ":"\r\n            查找等待员类型的完整属性。\r\n            \r\n","\r\n            This method exists to mimic the behavior of GetOwnOrInheritedSetMethod, but it\r\n            should only ever look at the overridden event in error scenarios.\r\n            ":"这种方法的存在是为了模仿getownorInheritedSetMethod的行为，但是\r\n            只能在错误方案中查看覆盖事件。\r\n            \r\n","\r\n            This function provides a false sense of security, it is likely going to surprise you when the requested member is missing.\r\n            Recommendation: Do not use, use ":"\r\n            此功能提供了一种错误的安全感，当请求的成员丢失时，可能会让您感到惊讶。\r\n            建议：不要使用，使用\r\n","Elements defined in a namespace cannot be explicitly declared as private, protected, protected internal, or private protected":"在名称空间中定义的元素不能明确声明为私人，受保护，受保护或受保护的元素\r\n","Members of {0} '{1}' cannot be returned by writable reference because it is a readonly variable":"{0}'{1}'的成员无法通过可写的参考返回，因为它是一个可读变量\r\n","The syntax node that declares a tuple element.":"声明元组元素的语法节点。\r\n","\r\n            Returns whether the compilation has the Boolean type and if it's good.\r\n            ":"\r\n            返回汇编是否具有布尔类型，是否很好。\r\n            \r\n","Global using directives":"全球使用指令\r\n","\r\n              Looks up a localized string similar to Multiple assemblies with equivalent identity have been imported: '{0}' and '{1}'. Remove one of the duplicate references..\r\n            ":"\r\n              已经导入了类似于具有等效身份的多个汇编的本地化字符串：'{0}'和'{1}'。删除重复引用之一。\r\n            \r\n","\r\n            Gets a value indicating whether this type has an EmbeddedAttribute or not.\r\n            ":"\r\n            获取一个指示此类型是否具有嵌入式化的值的值。\r\n            \r\n","\r\n            Having found that we are hiding a method with exactly the same signature\r\n            (including custom modifiers), we want to find methods with the same signature\r\n            on the declaring type because they will also be hidden.\r\n            (If the declaring type is constructed, it's possible that two or more\r\n            methods have the same signature (including custom modifiers).)\r\n            (If the representative member is an indexer, it's possible that two or more\r\n            properties have the same signature (including custom modifiers, even in a\r\n            non-generic type).\r\n            ":"\r\n            发现我们正在隐藏具有完全相同的签名的方法\r\n            （包括自定义修饰符），我们想找到具有相同签名的方法\r\n            在声明类型上，因为它们也将被隐藏。\r\n            （如果构建了声明类型，则可能有两个或更多\r\n            方法具有相同的签名（包括自定义修饰符）。\r\n            （如果代表成员是索引者，则可能有两个或更多\r\n            属性具有相同的签名（包括自定义修饰符，即使在\r\n            非传播类型）。\r\n            \r\n","SyntaxToken representing the checked or unchecked keyword.":"Syntaxtkoken表示已检查或未选中的关键字。\r\n","\r\n              Looks up a localized string similar to Error reading resource '{0}' -- '{1}'.\r\n            ":"\r\n              查找类似于错误读取资源'{0}' - '{1}'的本地化字符串。\r\n            \r\n","The modifier 'abstract' is not valid on fields. Try using a property instead.":"修饰符“摘要”在字段上无效。尝试使用属性。\r\n","\r\n              Looks up a localized string similar to Partial method declarations of '{0}' have inconsistent constraints for type parameter '{1}'.\r\n            ":"\r\n              查找类似于“ {0}”的部分方法声明类似的本地化字符串，对于类型参数'{1}'的约束不一致。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' overrides Object.Equals(object o) but does not override Object.GetHashCode().\r\n            ":"\r\n              查找类似于'{0}'覆盖object.equals（Object O）的本地化字符串，但不覆盖object.gethashcode（）。\r\n            \r\n","Invalid preprocessor expression":"无效的预处理器表达\r\n","The specified version string does not conform to the required format - major[.minor[.build[.revision]]]":"指定的版本字符串不符合所需的格式-Mair [.minor [.build [.revision]]]\r\n","\r\n              Looks up a localized string similar to XML comment on '{1}' has a paramref tag for '{0}', but there is no parameter by that name.\r\n            ":"\r\n              查找类似于'{1}'上的XML注释的本地化字符串，具有'{0}'的Paramref标签，但该名称没有参数。\r\n            \r\n","\r\n              Looks up a localized string similar to Field '{0}' is never assigned to, and will always have its default value {1}.\r\n            ":"\r\n              查找类似于字段'{0}'的本地化字符串，永远不会分配给，并且始终具有其默认值{1}。\r\n            \r\n","\r\n              Looks up a localized string similar to Default values are not valid in this context..\r\n            ":"\r\n              在此上下文中查找类似于默认值的本地化字符串。\r\n            \r\n","\r\n            If a method goes from async to non-async, or vice versa, then every occurrence of \"await\"\r\n            within the method (but not within a lambda) needs to be reinterpreted, to determine whether\r\n            it is a keyword or an identifier.\r\n            ":"\r\n            如果一种方法从异步到非酶变为非酶，反之亦然，则每次出现“等待”\r\n            在该方法中（但不在lambda中）需要重新解释，以确定是否是否\r\n            它是关键字或标识符。\r\n            \r\n","Given operation has a null semantic model.":"给定的操作具有无效的语义模型。\r\n","\r\n            Whenever parsing in a `while (true)` loop and a bug could prevent the loop from making progress,\r\n            this method can prevent the parsing from hanging.\r\n            Use as:\r\n                int tokenProgress = -1;\r\n                while (IsMakingProgress(ref tokenProgress))\r\n            It should be used as a guardrail, not as a crutch, so it asserts if no progress was made.\r\n            ":"\r\n            每当（true）`循环和错误都可以防止循环取得进展时，\r\n            这种方法可以防止解析悬挂。\r\n            用于：\r\n                int tokenProgress = -1;\r\n                而（ismakingprogress（ref tokenprogress））\r\n            它应该用作护栏，而不是拐杖，因此它断言是否没有取得进展。\r\n            \r\n","\r\n            Bag of assembly's custom attributes and decoded well-known attribute data from added netmodules.\r\n            ":"\r\n            来自添加的NetModules的汇编自定义属性和解码众所周知的属性数据。\r\n            \r\n","The interface method or property that is being implemented.":"正在实现的接口方法或属性。\r\n",".\r\n            Note that the test might be a ":"。\r\n            请注意，测试可能是\r\n","Source file '{0}' specified multiple times":"源文件'{0}'指定了多次\r\n","\r\n              Looks up a localized string similar to A reference was created to embedded interop assembly '{0}' because of an indirect reference to that assembly created by assembly '{1}'. Consider changing the 'Embed Interop Types' property on either assembly..\r\n            ":"\r\n              查找类似于引用的本地化字符串是为嵌入式Interop组装'{0}'创建的，因为间接引用了由汇编'{1}'创建的汇编。考虑更改任一组件上的“嵌入Interop类型”属性。\r\n            \r\n","Gets a SyntaxToken that represents the colon succeeding the statement's label.":"获取一个代表结肠的语法，该句子成功了陈述的标签。\r\n","\r\n            Returns a string representation of this symbol, suitable for debugging purposes, or\r\n            for placing in an error message.\r\n            ":"\r\n            返回此符号的字符串表示形式，适合调试目的或\r\n            用于放置错误消息。\r\n            \r\n","\r\n            If the label is a switch case label, returns the associated constant value with\r\n            case expression, otherwise returns null.\r\n            ":"\r\n            如果标签是开关案例标签，请返回关联的常数值\r\n            案例表达，否则返回null。\r\n            \r\n","\r\n            Set if the group has a receiver but one was not specified in syntax.\r\n            ":"\r\n            设置如果组有接收器，但在语法中未指定一个。\r\n            \r\n","\r\n            Scans a new-line sequence (either a single new-line character or a CR-LF combo).\r\n            ":"\r\n            扫描新线序列（单个新字符或CR-LF组合）。\r\n            \r\n","\r\n            If this returns false, then the real override comparer (whichever one is appropriate for the scenario)\r\n            will also return false.\r\n            ":"\r\n            如果这返回false，则实际覆盖比较（无论是哪个比较）\r\n            也将返回false。\r\n            \r\n","\r\n            Null if we're not inside a closure scope, otherwise the nearest closure scope\r\n            ":"\r\n            null如果我们不在闭合范围内，否则最近的闭合范围\r\n            \r\n","\r\n              Looks up a localized string similar to Assignment in conditional expression is always constant.\r\n            ":"\r\n              在条件表达式中查找类似于分配的本地化字符串始终是恒定的。\r\n            \r\n","'{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is not public.":"'{0}'不实现接口成员'{1}'。 '{2}'无法实现接口成员，因为它不是公共的。\r\n","\r\n            Returns a sequence of preprocessor symbols specified in ":"\r\n            返回一系列预处理符号\r\n","Represents that nothing was specified as an array size.":"表示没有指定任何数组大小。\r\n","\r\n            Helper for more complicated cases of Equals like when we have generic instantiations or types nested within them.\r\n            ":"\r\n            助手对于更复杂的平等案例，例如我们在其中嵌套的通用实例化或类型。\r\n            \r\n","\r\n            Indicates whether the method should be emitted.\r\n            ":"\r\n            指示该方法是否应发射。\r\n            \r\n","\r\n            Decodes System.Runtime.CompilerServices.DynamicAttribute applied to a specified metadata symbol and\r\n            transforms the specified metadata type, using the decoded dynamic transforms attribute argument,\r\n            by replacing each occurrence of ":"\r\n            decdes system.runtime.compilerServices.dynamicattribute应用于指定的元数据符号和\r\n            使用解码的动态变换属性参数转换指定的元数据类型，\r\n            通过替换每次发生\r\n","Discards":"丢弃\r\n","\r\n            Called after it is determined that the expression being enumerated is of a type that\r\n            has a GetEnumerator (or GetAsyncEnumerator) method.  Checks to see if the return type of the GetEnumerator\r\n            method is suitable (i.e. has Current and MoveNext for regular case, \r\n            or Current and MoveNextAsync for async case).\r\n            ":"\r\n            确定被列举的表达式是一种类型\r\n            具有getEnumerator（或getAsyncenumerator）方法。检查getEnumerator的返回类型是否\r\n            方法是合适的（即具有常规情况的电流和movenext，\r\n            或用于异步情况的当前和moveNextAsync）。\r\n            \r\n","Gets the member declarations.":"获取会员声明。\r\n","\r\n              Looks up a localized string similar to Cannot create an instance of the abstract class or interface '{0}'.\r\n            ":"\r\n              查找类似于类似的本地化字符串无法创建抽象类或接口'{0}'的实例。\r\n            \r\n","Type arguments are not allowed in the nameof operator.":"类型参数在运算符的名称中不允许。\r\n","\r\n            Gets a list of method symbols for a syntax node.\r\n            ":"\r\n            获取语​​法节点的方法符号列表。\r\n            \r\n","\r\n            Replace any named type in the symbol list with its instance constructors.\r\n            Construct all candidates with the implicitly-declared CrefTypeParameterSymbols.\r\n            ":"\r\n            用其实例构造函数替换符号列表中的任何命名类型。\r\n            用隐式宣布的creftypeparametersymbols构建所有候选人。\r\n            \r\n","\r\n            with all the trees that are safe to remove (not #load'ed by any other tree).\r\n            ":"\r\n            所有可以安全去除的树（不是其他任何树的＃负载）。\r\n            \r\n","\r\n              Looks up a localized string similar to The variable '{0}' is assigned but its value is never used.\r\n            ":"\r\n              查找类似于变量'{0}'的本地化字符串，但从未使用其值。\r\n            \r\n","Represents a case label within a switch statement.":"表示开关语句中的案例标签。\r\n","Called when the visitor visits a UnaryPatternSyntax node.":"当访问者访问一个UnaryPatternsyntax节点时，请致电。\r\n","Do not use 'System.ParamArrayAttribute'. Use the 'params' keyword instead.":"请勿使用“ system.paramarrayattribute”。改用“参数”关键字。\r\n","\r\n             In C#, tuples can be represented using tuple syntax and be given\r\n             names. However, the underlying representation for tuples unifies\r\n             to a single underlying tuple type, System.ValueTuple. Since the\r\n             names aren't part of the underlying tuple type they have to be\r\n             recorded somewhere else.\r\n             \r\n             Roslyn records tuple names in an attribute: the\r\n             TupleElementNamesAttribute. The attribute contains a single string\r\n             array which records the names of the tuple elements in a pre-order\r\n             depth-first traversal. If the type contains nested parameters,\r\n             they are also recorded in a pre-order depth-first traversal.\r\n             ":"\r\n             在C＃中，可以使用元组语法表示元组并给予\r\n             名称。但是，统一的基础表示\r\n             到一个基础元组类型，system.valuetuple。自从\r\n             名称不是必须是基础元组类型的一部分\r\n             记录在其他地方。\r\n             \r\n             罗斯林在属性中记录元组名称：\r\n             TupleelementNamesAttribute。该属性包含一个字符串\r\n             在预订中记录元组元素的名称的数组\r\n             深度优先遍历。如果类型包含嵌套参数，\r\n             它们还记录在预购深度优先的遍历中。\r\n             \r\n","Error reading Win32 resources -- {0}":"错误阅读Win32资源 -  {0}\r\n",", which is known to be derived\r\n            from an expression whose escape scope is ":"，已知得出\r\n            从逃生范围的表达式\r\n","Creates a new UsingDirectiveSyntax instance.":"创建一个新的使用DirectirectiveSyntax实例。\r\n","Called when the visitor visits a ReferenceDirectiveTriviaSyntax node.":"当访问者访问引用的辅导性静脉节点节点时调用。\r\n","\r\n            Returns true if a catch contains awaits\r\n            ":"\r\n            如果渔获物包含等待\r\n            \r\n","'{0}': cannot provide arguments when creating an instance of a variable type":"'{0}'：创建变量类型的实例时无法提供参数\r\n","\r\n            Add a branch in the lowered decision tree to a label for a matched\r\n            pattern, and then produce a statement for the target of that branch\r\n            that binds the pattern variables.\r\n            ":"\r\n            在较低的决策树中添加一个分支到匹配的标签\r\n            模式，然后为该分支的目标产生声明\r\n            结合模式变量。\r\n            \r\n","The 'goto case' value is not implicitly convertible to the switch type":"“ goto case”值不可隐式转换为交换机类型\r\n","\r\n              Looks up a localized string similar to Overloaded binary operator '{0}' takes two parameters.\r\n            ":"\r\n              查找类似于过载的二进制运算符'{0}'的本地化字符串，请带两个参数。\r\n            \r\n","\r\n            A collection of the local variables for which a value is always assigned inside the region.\r\n            ":"\r\n            始终在区域内分配值的本地变量集合。\r\n            \r\n","Called when the visitor visits a QualifiedNameSyntax node.":"当访问者访问合格的Namesyntax节点时，请致电。\r\n","True if the string contents should be scanned using the rules for verbatim strings":"如果应该使用逐字字符串的规则扫描字符串内容，则为true\r\n","\r\n            Produce a ":"\r\n            产生\r\n","\r\n              Looks up a localized string similar to #endif directive expected.\r\n            ":"\r\n              查找类似于#endif指令的本地化字符串。\r\n            \r\n","Submission can only include script code.":"提交只能包括脚本代码。\r\n","A constraint clause has already been specified for type parameter '{0}'. All of the constraints for a type parameter must be specified in a single where clause.":"已经为类型参数'{0}'指定了约束子句。类型参数的所有约束必须在单个子句中指定。\r\n","\r\n              Looks up a localized string similar to Cannot embed interop types from assembly '{0}' because it is missing either the '{1}' attribute or the '{2}' attribute..\r\n            ":"\r\n              查找类似于无法嵌入Interop类型的本地化字符串，因为它缺少'{1}'属性或'{2}'属性..\r\n            \r\n","\r\n            Rewrites a reference to an unlowered local function to the newly\r\n            lowered local function.\r\n            ":"\r\n            重写对新的本地功能的引用\r\n            降低本地功能。\r\n            \r\n","?\r\n            'true' if the matched type catches all of them, 'false' if it catches none of them, and\r\n            'null' if it might catch some of them. For this test we assume the expression's value\r\n            isn't null.\r\n            ":"？\r\n            如果匹配的类型抓住了所有这些，则“ true”，“ false”，如果它没有抓住它们，并且\r\n            “ null”如果可能会抓住其中的一些。对于此测试，我们假设表达式的值\r\n            不是零。\r\n            \r\n","Conflicting options specified: Win32 resource file; Win32 icon":"指定的相互冲突选项：WIN32资源文件； Win32图标\r\n","\r\n            The underlying MethodSymbol, cannot be another RetargetingMethodSymbol.\r\n            ":"\r\n            基础方法符号不能是另一个retargetingmethodsymbol。\r\n            \r\n","\r\n              Looks up a localized string similar to Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor method '{1}'.\r\n            ":"\r\n              该语言不支持与属性，索引器或事件“ {0}”类似的本地化字符串；尝试直接调用访问者方法'{1}'。\r\n            \r\n","Called when the visitor visits a LineDirectiveTriviaSyntax node.":"当访客访问衬里的辅助性静脉节点时，请致电。\r\n","A const field requires a value to be provided":"const字段需要提供一个值\r\n","Friend assembly reference '{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified.":"朋友汇编引用'{0}'无效。 InternalSvisibleto声明不能具有指定的版本，文化，公钥令牌或处理器体系结构。\r\n","Fields of static readonly field '{0}' cannot be returned by writable reference":"静态读取字段'{0}'的字段无法通过可写的参考返回\r\n","\r\n            Check if the pattern is subsumed by the decisions in the decision tree, given that the input could\r\n            (or could not) be null based on the parameter ":"\r\n            鉴于输入可以\r\n            （或不能）根据参数为null\r\n","Non-nullable {0} '{1}' must contain a non-null value when exiting constructor. Consider declaring the {0} as nullable.":"退出构造函数时，不可用的{0}'{1}'必须包含一个非空值。考虑将{0}声明为无效。\r\n","\r\n            This portion of the binder converts a QueryExpressionSyntax into a BoundExpression\r\n            ":"\r\n            粘合剂的这一部分将QueryExpressyNntax转换为绑定表达\r\n            \r\n","\r\n            It is rare but possible for a source expression to be convertible to a destination type\r\n            by both an implicit user-defined conversion and a built-in explicit conversion.\r\n            In that circumstance, this method classifies the conversion as the built-in conversion.\r\n            \r\n            An implicit conversion exists from an expression of a dynamic type to any type.\r\n            An explicit conversion exists from a dynamic type to any type. \r\n            When casting we prefer the explicit conversion.\r\n            ":"\r\n            很少有源表达式可转换为目的地类型\r\n            通过隐式用户定义的转换和内置的显式转换。\r\n            在这种情况下，此方法将转换归类为内置转换。\r\n            \r\n            隐式转换来自动态类型的表达式到任何类型。\r\n            从动态类型到任何类型都存在明确的转换。\r\n            铸造时，我们更喜欢明确的转换。\r\n            \r\n"," vs. ":" VS.\r\n","\r\n            Writes the content to the given stream. The writer is disposed and can't be used for further writing.\r\n            ":"\r\n            将内容写入给定的流。作者被处置，不能用于进一步写作。\r\n            \r\n","Nullability of reference types in value of type '{0}' doesn't match target type '{1}'.":"类型“ {0}'值中的参考类型的无效性不匹配目标类型'{1}'。\r\n","Using '{0}' to test compatibility with '{1}' is essentially identical to testing compatibility with '{2}' and will succeed for all non-null values":"使用'{0}'测试与'{1}''的兼容性基本上与测试与'{2}'的兼容性相同，并且对于所有非零值\r\n","Creates a new ClassDeclarationSyntax instance.":"创建一个新的classDeclarationsyntax实例。\r\n","\r\n            True if the type should have its WinRT interfaces projected onto .NET types and\r\n            have missing .NET interface members added to the type.\r\n            ":"\r\n            如果类型应将其WinRT接口投影到.NET类型和\r\n            缺少.NET接口成员添加到该类型中。\r\n            \r\n","\r\n              Looks up a localized string similar to SyntaxTree '{0}' not found to remove.\r\n            ":"\r\n              查找类似于SyntaxTree'{0}'的本地化字符串，找不到要删除。\r\n            \r\n","Since '{0}' returns void, a return keyword must not be followed by an object expression":"由于'{0}'返回void，因此返回关键字不得跟随对象表达式\r\n","Auto-implemented properties cannot return by reference":"自动实施属性无法通过参考返回\r\n","\r\n              Looks up a localized string similar to Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor methods '{1}' or '{2}'.\r\n            ":"\r\n              该语言不支持与属性，索引器或事件“ {0}”类似的本地化字符串；尝试直接调用登录器方法'{1}'或'{2}'。\r\n            \r\n","Expression or declaration statement expected.":"表达或声明陈述预期。\r\n","\r\n            A bracketed list of cref parameters.\r\n            ":"\r\n            CREF参数的包围列表。\r\n            \r\n","Creates a new OmittedTypeArgumentSyntax instance.":"创建一个新的省略typeargumentsyntax实例。\r\n","\r\n            This node represents an 'out var' parameter to a Deconstruct method.\r\n            It is only used temporarily during initial binding.\r\n            ":"\r\n            该节点代表解构方法的“ out var”参数。\r\n            它仅在初始结合期间暂时使用。\r\n            \r\n","\r\n                 class C : BaseType<((int e1, int e2) e3, int e4)< { ... }\r\n             ":"\r\n                 C类：底型<（（（int e1，int e2）E3，int e4）<{...}\r\n             \r\n","The argument that is passed to the action whenever it is invoked":"每当调用该动作的论点\r\n"," could be walked to build\r\n            the proxy list.\r\n            ":" 可以步行建造\r\n            代理列表。\r\n            \r\n","\r\n            Report an error if this is an awaitable async method invocation that is not being awaited.\r\n            ":"\r\n            报告错误，如果这是未等待的等待异步方法调用。\r\n            \r\n","\r\n              Looks up a localized string similar to Static field or property '{0}' cannot be assigned in an object initializer.\r\n            ":"\r\n              查找类似于静态字段或属性'{0}'的本地化字符串，无法在对象初始化器中分配。\r\n            \r\n","\r\n            Produce a sample value contained in the set. Throws ":"\r\n            产生集合中包含的样本值。扔\r\n","Called when the visitor visits a ImplicitElementAccessSyntax node.":"当访问者访问一个隐式Accesssyntax节点时，请致电。\r\n","'is' expression's given expression is always of the provided type":"“是”表达式的表达始终是提供的类型\r\n","\r\n              Looks up a localized string similar to The best overloaded Add method for the collection initializer element is obsolete.\r\n            ":"\r\n              查找类似于收集初始化器元素的最佳超载添加方法类似的本地化字符串已过时。\r\n            \r\n","The type name '{0}' does not exist in the type '{1}'":"类型名称'{0}'在类型'{1}'中不存在\r\n","\r\n              Looks up a localized string similar to Field or auto-implemented property cannot be of type '{0}' unless it is an instance member of a ref struct..\r\n            ":"\r\n              查找类似于字段或自动实现属性的本地化字符串，除非它是REF结构的实例成员。\r\n            \r\n","Base type for class or struct constraint syntax.":"类或结构约束语法的基本类型。\r\n","Parameters or locals of type '{0}' cannot be declared in async methods or async lambda expressions.":"类型为'{0}'的参数或当地人不能在异步方法或异步lambda表达式中声明。\r\n","(a, (b, c)) == (d, (e, f))":"（a，（b，c））==（d，（e，f））\r\n","\r\n            This is the core node for a Scope tree, which stores all semantically meaningful\r\n            information about declared variables, closures, and environments in each scope.\r\n            It can be thought of as the essence of the bound tree -- stripping away many of\r\n            the unnecessary details stored in the bound tree and just leaving the pieces that\r\n            are important for closure conversion. The root scope is the method scope for the\r\n            method being analyzed and has a null ":"\r\n            这是范围树的核心节点，该节点存储所有具有语义上有意义的\r\n            有关每个范围中声明变量，关闭和环境的信息。\r\n            可以将其视为绑定树的本质 - 剥夺了许多\r\n            不必要的细节存储在绑定的树上，只是留下了\r\n            对于关闭转换很重要。根范围是\r\n            分析方法并为零\r\n","\r\n            Given a CrefSyntax and an associated member declaration syntax node,\r\n            construct an appropriate binder for binding the cref.\r\n            ":"\r\n            给定一个Crefsyntax和相关的成员声明语法节点，\r\n            构建适当的粘合剂来绑定CREF。\r\n            \r\n","\r\n            User defined local constant declared by ":"\r\n            用户定义了局部常数声明\r\n","\r\n              Looks up a localized string similar to Variable is declared but never used.\r\n            ":"\r\n              查找类似于变量的本地化字符串，但从未使用过。\r\n            \r\n","Cannot create temporary file -- {0}":"无法创建临时文件 -  {0}\r\n","\r\n            Specialized EmptyStructTypeCache that reports all structs as not empty\r\n            ":"\r\n            专门的emptrusstypecache，报告所有结构都不为空\r\n            \r\n","\r\n              Looks up a localized string similar to The compiler implicitly widened and sign-extended a variable, and then used the resulting value in a bitwise OR operation. This can result in unexpected behavior..\r\n            ":"\r\n              查找类似于编译器的局部字符串，隐式扩展并扩展了一个变量，然后在比特或操作中使用了结果值。这可能导致意外的行为。\r\n            \r\n"," instead.\r\n             ":" 反而。\r\n             \r\n","\r\n            Might the given type be, or contain, managed references?  This is used to determine which\r\n            fields allocated to temporaries should be cleared when the underlying variable goes out of scope, so\r\n            that they do not cause unnecessary object retention.\r\n            ":"\r\n            给定类型可能是或包含托管参考？这用于确定哪个\r\n            当基础变量不在范围时，应清除分配给临时性的字段，因此\r\n            它们不会引起不必要的物体保留。\r\n            \r\n"," property is allowed by the rules of the\r\n            language to be an arbitrary expression, not just a statement expression.\r\n            ":" 允许财产的规则\r\n            语言是任意表达的，而不仅仅是语句表达。\r\n            \r\n","\r\n              Looks up a localized string similar to A using variable cannot be used directly within a switch section (consider using braces). .\r\n            ":"\r\n              查找类似于使用变量的本地化字符串不能直接在开关部分中使用（请考虑使用括号）。 。\r\n            \r\n","Creates a new ArgumentSyntax instance.":"创建一个新的grumentsyntax实例。\r\n","\r\n            Rewrite a using statement into a try finally statement.  Two forms are possible:\r\n              1) using (expr) stmt\r\n              2) using (C c = expr) stmt\r\n              \r\n            The former is handled by RewriteExpressionUsingStatement and the latter is handled by\r\n            RewriteDeclarationUsingStatement (called in a loop, once for each local declared).\r\n            ":"\r\n            将使用语句重写最终语句。有两种形式：\r\n              1）使用（Expr）STMT\r\n              2）使用（c c = expr）stmt\r\n              \r\n            前者由重新表达式统计处理，后者由\r\n            重新写入以下内容（每次声明的本地一次循环中调用一次）。\r\n            \r\n","The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'":"表达式的结果始终是'{0}'，因为类型'{1}'的值永远不等于type'{2}'的'null'\r\n","\r\n            Get the semantic info of a named argument in an invocation-like expression.\r\n            ":"\r\n            在类似调用的表达式中获取命名参数的语义信息。\r\n            \r\n","Cannot specify accessibility modifiers for both accessors of the property or indexer '{0}'":"无法为属性或索引器'{0}'的配件指定可访问性修饰符\r\n","\r\n              Looks up a localized string similar to Using '{0}' to test compatibility with '{1}' is essentially identical to testing compatibility with '{2}' and will succeed for all non-null values.\r\n            ":"\r\n              查找类似于使用“ {0}”测试与'{1}'测试兼容性类似的本地化字符串基本上与测试与'{2}'的兼容性相同，并且对于所有非null值都将成功。\r\n            \r\n","\r\n            If the call represents an extension method with an explicit receiver, return a\r\n            ReducedExtensionMethodSymbol if it can be constructed. Otherwise, return the \r\n            original call method.\r\n            ":"\r\n            如果呼叫代表带有显式接收器的扩展方法，请返回\r\n            如果可以构建脱肌符号，则还原。否则，返回\r\n            原始呼叫方法。\r\n            \r\n","\r\n            Definitely a type name: either a predefined type (int, string, etc.) or an array type name (ending with a bracket).\r\n            ":"\r\n            绝对是类型名称：预定义的类型（INT，String等）或数组类型名称（以括号结尾）。\r\n            \r\n","The containing namespace to used, IF a merged\r\n            namespace is created.":"如果合并\r\n            创建名称空间。\r\n","\r\n            Represents an anonymous type 'ToString' method.\r\n            ":"\r\n            代表匿名类型的“ Tostring”方法。\r\n            \r\n","Converts the value of the current Range object to its equivalent string representation.":"将当前范围对象的值转换为其等效字符串表示。\r\n","\r\n            Gets the nearest enclosing namespace for this namespace or type. For a nested type,\r\n            returns the namespace that contains its container.\r\n            ":"\r\n            获取此名称空间或类型的最近的封闭名称空间。对于嵌套类型\r\n            返回包含其容器的名称空间。\r\n            \r\n"," GetBinderFactory will be used.":" 将使用GetBinderFactory。\r\n","\r\n            Returns true if the first set of constraint types\r\n            is a subset of the second set.\r\n            ":"\r\n            如果第一组约束类型，则返回true\r\n            是第二组的子集。\r\n            \r\n","\r\n              Looks up a localized string similar to Type parameter '{0}' has no matching typeparam tag in the XML comment on '{1}' (but other type parameters do).\r\n            ":"\r\n              查找类似于类型参数'{0}'的本地化字符串在'{1}'上的XML注释中没有匹配的Typeparam标签（但是其他类型的参数为）。\r\n            \r\n","A namespace declaration cannot have modifiers or attributes":"名称空间声明不能具有修饰符或属性\r\n"," at the end of rewriting.\r\n            ":" 在重写结束时。\r\n            \r\n","\r\n              Looks up a localized string similar to The assembly {0} does not contain any analyzers..\r\n            ":"\r\n              查找类似于汇编{0}的本地化字符串不包含任何分析仪。\r\n            \r\n","Cannot create an instance of the abstract type or interface '{0}'":"无法创建抽象类型的实例或接口'{0}'\r\n","\r\n            Contains the map of expression and original symbol to reinferred symbols, used by the optional\r\n            rewriter phase of the compiler.\r\n            ":"\r\n            包含可选符号的表达图和原始符号的重复符号\r\n            编译器的重写阶段。\r\n            \r\n","The member to which the documentation comment (logically) containing\r\n            the cref syntax applies.":"文档评论（逻辑上）包含的成员\r\n            CREF语法适用。\r\n","\r\n            Produces opcode for a jump that corresponds to given operation and sense.\r\n            Also produces a reverse opcode - opcode for the same condition with inverted sense.\r\n            ":"产生与给定的操作和感知相对应的跳跃的OPCODE。\r\n            还会产生一个反向码 - 对相同条件的倒置码，并具有倒置意义。\r\n            \r\n","Indexed property '{0}' has non-optional arguments which must be provided":"索引属性'{0}'具有必须提供的非选项参数\r\n","\r\n              Looks up a localized string similar to The operation overflows at compile time in checked mode.\r\n            ":"\r\n              查找类似于在检查模式下编译时间的操作溢出的本地化字符串。\r\n            \r\n","\r\n            Only (original) source symbols and namespaces that can be merged\r\n            need implement this function if they want to do so for efficiency.\r\n            ":"\r\n            仅（原始）源符号和可以合并的名称空间\r\n            如果他们想为效率而实现此功能，则需要实现此功能。\r\n            \r\n","\r\n              Looks up a localized string similar to Explicit interface implementation '{0}' is missing accessor '{1}'.\r\n            ":"\r\n              查找类似于显式接口实现的本地化字符串'{0}'缺少访问者'{1}'。\r\n            \r\n","\r\n            Represents the result of visiting an argument expression.\r\n            In addition to storing the ":"\r\n            代表访问参数表达式的结果。\r\n            除了存储\r\n","\r\n              Looks up a localized string similar to Base class '{0}' must come before any interfaces.\r\n            ":"\r\n              查找类似于基类'{0}'的本地化字符串必须在任何接口之前出现。\r\n            \r\n","Called when the visitor visits a BadDirectiveTriviaSyntax node.":"当访客访问BadDirectivtriviaSyntax节点时，请致电。\r\n","Cannot return a parameter by reference '{0}' because it is not a ref or out parameter":"无法通过引用'{0}'返回参数，因为它不是ref或out参数\r\n","\r\n              Looks up a localized string similar to Cannot convert anonymous method block without a parameter list to delegate type '{0}' because it has one or more out parameters.\r\n            ":"\r\n              在没有参数列表的情况下查找类似于匿名方法块的本地化字符串，因为它具有一个或多个参数，因为它具有一个或多个参数。\r\n            \r\n"," in such a way so that \r\n            all types used by Rest fields are tuples. Throughout the entire nesting chain.\r\n            ":" 以这样的方式\r\n            休息场使用的所有类型都是元组。在整个筑巢链中。\r\n            \r\n","\r\n            Is this the given type parameter?\r\n            ":"\r\n            这是给定类型参数吗？\r\n            \r\n","Creates a new InterpolationSyntax instance.":"创建一个新的Interpolationsyntax实例。\r\n","\r\n              Looks up a localized string similar to Properties cannot combine accessor lists with expression bodies..\r\n            ":"\r\n              查找类似于属性的本地化字符串无法将访问者列表与表达式结合在一起。\r\n            \r\n","\r\n            Returns null for a submission class.\r\n            This ensures that a submission class does not inherit methods such as ToString or GetHashCode.\r\n            ":"\r\n            返回提交类的null。\r\n            这样可以确保提交类不继承诸如tostring或gethashcode之类的方法。\r\n            \r\n","\r\n            Moves the enumerator to the next diagnostic instance in the diagnostic list.\r\n            ":"\r\n            将枚举器移至诊断列表中的下一个诊断实例。\r\n            \r\n","Creates a new VarPatternSyntax instance.":"创建一个新的varpatternsyntax实例。\r\n","An expression tree may not contain a call or invocation that uses optional arguments":"表达树可能不包含使用可选参数的调用或调用\r\n","A reference was created to embedded interop assembly '{0}' because of an indirect reference to that assembly created by assembly '{1}'. Consider changing the 'Embed Interop Types' property on either assembly.":"由于间接引用了由汇编'{1}'创建的该汇编，因此创建了嵌入式Interop组件'{0}'的引用。考虑更改任一组件上的“嵌入Interop类型”属性。\r\n","\r\n            Return the return type for a lifted operator, given the nullability state of its operands.\r\n            ":"\r\n            鉴于其操作数的无效状态，返回升降操作员的返回类型。\r\n            \r\n","anonymous method":"匿名方法\r\n","\r\n            Gets a SyntaxToken that represents the goto keyword.\r\n            ":"\r\n            获取代表goto关键字的语法。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use ref or out parameter '{0}' inside an anonymous method, lambda expression, or query expression.\r\n            ":"\r\n              在匿名方法，lambda表达式或查询表达式中查找类似于使用参数'{0}'的本地化字符串。\r\n            \r\n","/=":"/=\r\n","\r\n            The NamedTypeSymbol for the .NET System.Object type, which could have a TypeKind of\r\n            Error if there was no COR Library in a compilation using the assembly.\r\n            ":"\r\n            .net system.Object类型的命名typeymbol\r\n            错误，如果使用组件中没有COR库中的COR库。\r\n            \r\n","https://github.com/dotnet/roslyn/issues/53397 This method should potentially be removed.":"https://github.com/dotnet/roslyn/issues/53397该方法应有可能被删除。\r\n","\r\n              Looks up a localized string similar to Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create numeric literal tokens..\r\n            ":"\r\n              查找类似于使用Microsoft.codeanalysis.csharp.syntaxfactory.literal创建数字文字令牌的本地化字符串。\r\n            \r\n","The old list.":"旧列表。\r\n","Node list.":"节点列表。\r\n","\r\n            Names for compilation options that get embedded as debug information\r\n            in the PDB as key-value pairs.\r\n            ":"\r\n            编译选项的名称，这些选项被嵌入为调试信息\r\n            在PDB中作为键值对。\r\n            \r\n","\r\n            Returns the index of the first member of the specific kind.\r\n            Returns the number of members if not found.\r\n            ":"\r\n            返回特定类型的第一个成员的索引。\r\n            如果找不到的话，将返回会员人数。\r\n            \r\n","\r\n              Looks up a localized string similar to Extension method must be static.\r\n            ":"\r\n              查找类似于扩展方法的本地化字符串必须是静态的。\r\n            \r\n","\r\n            Returns true if one of the locations is within the syntax tree and span.\r\n            ":"\r\n            如果其中一个位置在语法树和跨度内，则返回true。\r\n            \r\n","TypeSyntax node representing the type to which the expression is being cast.":"表示表达式所施放的类型的型尺寸节点。\r\n","Bound node factory.":"绑定的节点工厂。\r\n","\r\n            Return true if the method parameters match the parameters of the\r\n            property accessor, including the value parameter for the setter.\r\n            ":"\r\n            如果方法参数匹配该参数，则返回true\r\n            属性登录器，包括设置器的值参数。\r\n            \r\n","\r\n            The sequence of groups of TypeDef row ids for types contained within the namespace, \r\n            recursively including those from nested namespaces. The row ids must be grouped by the \r\n            fully-qualified namespace name case-sensitively. There could be multiple groups \r\n            for each fully-qualified namespace name. The groups must be sorted by\r\n            their key in case-sensitive manner. Empty string must be used as namespace name for types \r\n            immediately contained within Global namespace. Therefore, all types in this namespace, if any, \r\n            must be in several first IGroupings.\r\n            ":"\r\n            命名空间中包含的类型类型的Typedef行ID组序列，\r\n            递归包括来自嵌套名称空间的。行ID必须由\r\n            完全合格的名称空间案例敏感。可能有多个组\r\n            对于每个符合条件的名称空间名称。组必须按\r\n            他们的关键以敏感的方式。空字符串必须用作类型的名称名称\r\n            立即包含在全球名称空间中。因此，此名称空间中的所有类型（如果有）\r\n            必须在几个第一个Igroupings中。\r\n            \r\n","\r\n            Look for a base type method named \"Finalize\" that is protected (or protected internal), has no parameters, \r\n            and returns void.  It doesn't need to be virtual or a destructor.\r\n            ":"\r\n            寻找一个名为“最终化”的基本类型方法，该方法受保护（或受保护的内部），没有参数，\r\n            并返回无效。它不需要虚拟或破坏者。\r\n            \r\n"," is true. A subsequent\r\n               call with ":" 是真的。后续\r\n               打电话\r\n","\r\n            Returns a metadata reference that a given #r resolves to.\r\n            ":"\r\n            返回给定#r解决的元数据参考。\r\n            \r\n","\r\n            This is the set of parameters and local variables that were used as arguments to \r\n            lock or using statements in enclosing scopes.\r\n            ":"\r\n            这是一组参数和本地变量，被用作参数\r\n            锁定或使用语句包装范围。\r\n            \r\n","The specified version string does not conform to the required format - major.minor.build.revision (without wildcards)":"指定的版本字符串不符合所需的格式-Major.minor.build.Revision（无通态）\r\n"," will set the BoundNodeAttributes.WasTopLevelNullabilityChecked\r\n            bit in the boundnode properties, which will break debugging. This allows the debugger to display the current value without setting the bit.\r\n            ":" 将设置BONDNODEATTRIBUTES.WASTOPLEVELNULLAILASECHEDECTED\r\n            在边界介绍属性中的位，将打破调试。这允许调试器显示当前值而无需设置位。\r\n            \r\n","Invalid data at offset {0}: {1}{2}*{3}{4}":"偏移{0}的无效数据：{1} {2}*{3} {4}\r\n","Gets the open paren token.":"获取开放的帕伦令牌。\r\n","\r\n            Marshalling information for return value (FieldMarshal in metadata). \r\n            ":"\r\n            编组信息以获取返回价值（元数据中的fieldmarshal）。\r\n            \r\n","\r\n            Determined based upon value specified via ":"\r\n            根据指定的价值确定\r\n","Feature '{0}' is not available in C# 7.2. Please use language version {1} or greater.":"C＃7.2中不可用功能'{0}'。请使用语言版本{1}或更大。\r\n","Cannot specify a default value for the 'this' parameter":"无法指定“ this”参数的默认值\r\n","\r\n            Additional data or behavior. Such cases should be\r\n            uncommon to minimize allocations.\r\n            ":"\r\n            其他数据或行为。这样的情况应该是\r\n            不常见的分配最小化。\r\n            \r\n","ref local variables may be reassigned":"参考本地变量可能会重新分配\r\n","\r\n              Looks up a localized string similar to method group.\r\n            ":"\r\n              查找类似于方法组的本地化字符串。\r\n            \r\n","If a case is found that would always match the input, set to true":"如果发现始终匹配输入的情况，请设置为true\r\n","\r\n            The method being rewritten.\r\n            ":"\r\n            该方法被重写。\r\n            \r\n","\r\n            True if analysis was required; false if analysis was optional and results dropped.\r\n            ":"\r\n            如果需要分析，则为真实；错误，如果分析是可选的，结果下降。\r\n            \r\n","\r\n             Rewrite a using statement into a try finally statement.  Four forms are possible:\r\n               1) using (expr) stmt\r\n               2) await using (expr) stmt\r\n               3) using (C c = expr) stmt\r\n               4) await using (C c = expr) stmt\r\n            \r\n             The first two are handled by RewriteExpressionUsingStatement and the latter two are handled by\r\n             RewriteDeclarationUsingStatement (called in a loop, once for each local declared).\r\n            \r\n             For the async variants, `IAsyncDisposable` is used instead of `IDisposable` and we produce\r\n             `... await expr.DisposeAsync() ...` instead of `... expr.Dispose() ...`.\r\n             ":"\r\n             将使用语句重写最终语句。可以使用四种形式：\r\n               1）使用（Expr）STMT\r\n               2）等待使用（expr）stmt\r\n               3）使用（c c = expr）stmt\r\n               4）等待使用（C C = Expr）STMT\r\n            \r\n             前两个由重新表达式定义处理，后两个由\r\n             重新写入以下内容（每次声明的本地一次循环中调用一次）。\r\n            \r\n             对于异步变体，使用`iasyncdisposable`而不是`iDisposable'，我们生产\r\n             `...等待expr.dispoesync（）...`而不是`... expr.dispose（）...`。\r\n             \r\n","/REFERENCEPATH option":"/参考路径选项\r\n","\r\n            ExpressionSyntax node representing the body of the anonymous function.\r\n            Only one of Block or ExpressionBody will be non-null.\r\n            ":"\r\n            表示代表匿名函数主体的expressionsyntax节点。\r\n            只有一个块或表达机构将是非零的。\r\n            \r\n","Creates a new AwaitExpressionSyntax instance.":"创建一个新的waitexpressionsyntax实例。\r\n","Creates a new NameMemberCrefSyntax instance.":"创建一个新的NamememberCrefsyntax实例。\r\n","\r\n            Create the frame types.\r\n            ":"\r\n            创建框架类型。\r\n            \r\n","\r\n            Is the expression the initializer in a fixed statement?\r\n            ":"\r\n            固定语句中的表达式是初始化器吗？\r\n            \r\n","\r\n            If specified called for every child syntax node (not token) that is visited during the comparison. \r\n            If it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.\r\n            ":"\r\n            如果指定了在比较期间访问的每个儿童语法节点（非令牌）的要求。\r\n            如果它返回正确的孩子，则将递归拜访孩子，否则孩子及其子树被忽略了。\r\n            \r\n","\r\n              Looks up a localized string similar to Possibly incorrect assignment to local which is the argument to a using or lock statement.\r\n            ":"\r\n              查找类似于对本地分配的不正确分配的本地化字符串，这是对使用或锁定语句的参数。\r\n            \r\n","\r\n            Bind an XmlNameAttributeSyntax and update the sets of documented parameters and type parameters.\r\n            ":"\r\n            绑定XMLNAGEATTRIBUTESYNTAX，并更新已记录的参数和键入参数的集合。\r\n            \r\n","Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match implicitly implemented member '{2}'.":"参数类型中的参数类型的无效性'{1}'的参数类型'{0}''不匹配隐式实现的成员'{2}'。\r\n","Expression must be implicitly convertible to Boolean or its type '{0}' must define operator '{1}'.":"表达式必须隐式转换为布尔值或其类型的“ {0}”必须定义操作符'{1}'。\r\n","\r\n            Assuming we are in an async method, return true if we're in a context where await would be illegal.\r\n            Specifically, return true if we're in a lock or catch filter.\r\n            ":"\r\n            假设我们是一种异步方法，请返回True如果我们处于等待非法的情况下。\r\n            具体来说，如果我们在锁或捕获过滤器中，请返回True。\r\n            \r\n","\r\n            C# language version 5.0.\r\n            ":"\r\n            C＃语言版本5.0。\r\n            \r\n","\r\n            A synthesized forwarding method for the implementation, or information about MethodImpl entry that should be emitted,\r\n            or default if neither needed.\r\n            ":"\r\n            用于实施的综合转发方法，或有关应发射的方法IMPL条目的信息\r\n            或默认，如果不需要。\r\n            \r\n","\r\n            The attribute (metadata) representation of ":"\r\n            属性（元数据）表示\r\n","Ref assignment or value assignment.":"参考分配或价值分配。\r\n","\r\n              Looks up a localized string similar to using static.\r\n            ":"\r\n              查找类似于使用静态的局部字符串。\r\n            \r\n","The syntax trees with the source code for the new compilation.":"具有新汇编的源代码的语法树。\r\n","\r\n            These aren't acceptable in place of ASCII quotation marks in XML, \r\n            but we want to consume them (and produce an appropriate error) if\r\n            they occur in a place where a quotation mark is legal.\r\n            ":"\r\n            这些不能代替XML中的ASCII引号，\r\n            但是我们想消耗它们（如果\r\n            它们发生在引号合法的地方。\r\n            \r\n","The old token list.":"旧的令牌列表。\r\n","\r\n              Looks up a localized string similar to The CallerFilePathAttribute will have no effect; it is overridden by the CallerLineNumberAttribute.\r\n            ":"\r\n              查找类似于CallerFilePathTribute的局部字符串将没有效果。它被CallerlineNumberattribute覆盖。\r\n            \r\n","\r\n            Executed after visiting a local function body. The ":"\r\n            访问本地功能主体后执行。这\r\n","Cannot use '{0}' as a ref or out value because it is read-only":"不能将'{0}'用作ref或淘汰价值，因为它是只读的\r\n","\r\n            Compare signatures of methods from a method group.\r\n            ":"\r\n            比较方法组的方法签名。\r\n            \r\n","\r\n              Looks up a localized string similar to The member '{0}' does not hide an accessible member. The new keyword is not required..\r\n            ":"\r\n              查找类似于成员'{0}'的本地化字符串不会隐藏可访问的成员。不需要新的关键字。\r\n            \r\n","\r\n              Looks up a localized string similar to {0} is not a valid C# conversion expression.\r\n            ":"\r\n              查找类似于{0}的本地化字符串不是有效的C＃转换表达式。\r\n            \r\n","A syntax node to attach to the synthesized bound node.":"一个语法节点以附加到合成的绑定节点。\r\n","\r\n            Represents the primary module of an assembly being built by compiler.\r\n            ":"\r\n            代表由编译器构建的组件的主要模块。\r\n            \r\n","The unlowered argument to the indexing expression":"索引表达式的无备件论点\r\n","The string literal used as the text of the xml text node.":"字符串字面用作XML文本节点的文本。\r\n","\r\n              Looks up a localized string similar to foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation.\r\n            ":"\r\n              查找类似于foreach语句的本地化字符串无法在类型的“ {0}”的变量上操作，因为它实现了'{1}'的多个实例化;尝试铸造特定的接口实例化。\r\n            \r\n","Represent the inclusive start index of the Range.":"表示该范围的包容性开始索引。\r\n","\r\n            If this method has MethodKind of MethodKind.PropertyGet or MethodKind.PropertySet,\r\n            returns the property that this method is the getter or setter for.\r\n            If this method has MethodKind of MethodKind.EventAdd or MethodKind.EventRemove,\r\n            returns the event that this method is the adder or remover for.\r\n            Note, the set of possible associated symbols might be expanded in the future to\r\n            reflect changes in the languages.\r\n            ":"\r\n            如果此方法具有MethodKind.propertyget或MethodKind.propertyset的MethodKind，则\r\n            返回此方法是Getter或setter的属性。\r\n            如果此方法具有MethodKind.eventadd或MethodKind.eventremove的MethodKind，则\r\n            返回此方法是加法器或去除剂的事件。\r\n            注意，将来可能会扩展一组可能的相关符号\r\n            反映语言的变化。\r\n            \r\n","Called when the visitor visits a QueryContinuationSyntax node.":"当访问者访问QueryContinuationSyntax节点时，请致电。\r\n","\r\n            When constructing this ErrorTypeSymbol, there may have been symbols that seemed to\r\n            be what the user intended, but were unsuitable. For example, a type might have been\r\n            inaccessible, or ambiguous. This property returns the possible symbols that the user\r\n            might have intended. It will return no symbols if no possible symbols were found.\r\n            See the CandidateReason property to understand why the symbols were unsuitable.\r\n            ":"\r\n            在构建此errortypeSymbol时，似乎有符号\r\n            是用户想要的，但不合适。例如，一种类型可能是\r\n            无法访问或模棱两可。此属性返回用户的可能符号\r\n            可能打算了。如果找不到可能的符号，它将不会返回符号。\r\n            请参阅候选季节的财产，以了解为什么这些符号不合适。\r\n            \r\n","Called when the visitor visits a ImplicitStackAllocArrayCreationExpressionSyntax node.":"当访问者访问隐式stackallocarreyCreationexpressionsyntax节点时调用。\r\n","\r\n            Determines if two lists of tokens are the same, disregarding trivia differences.\r\n            ":"\r\n            确定两个令牌列表是否相同，无视琐事差异。\r\n            \r\n","\r\n            The candidate member was rejected because a named argument was used that corresponded to a previously-given positional argument.\r\n            ":"\r\n            候选人成员被拒绝，因为使用了与以前赋予的位置论点相对应的指定参数。\r\n            \r\n","Ref returns and locals":"裁判返回和当地人\r\n","\r\n            If a property is annotated with `[MemberNotNull(...)]` attributes, returns the list of members\r\n            listed in those attributes.\r\n            Otherwise, an empty array.\r\n            ":"\r\n            如果属性用`[membernotnull（...）]注释``属性''，请返回成员列表\r\n            在这些属性中列出。\r\n            否则，一个空数组。\r\n            \r\n","SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.":"SimpleNamesyntax节点表示合格名称的点令牌右侧的名称。\r\n","The version of the compilation options schema to be written to the PDB.":"编译选项架构的版本将写入PDB。\r\n","\r\n            Called when a local represents an out variable declaration. Its syntax is of type DeclarationExpressionSyntax.\r\n            ":"\r\n            当本地代表OUT变量声明时调用。它的语法是类型的声明expressexionsyntax。\r\n            \r\n","\r\n            Returns true if the parameter is the hidden 'this' parameter.\r\n            ":"\r\n            如果参数是隐藏的“ this”参数，则返回true。\r\n            \r\n","\r\n              Looks up a localized string similar to Attribute '{0}' given in a source file conflicts with option '{1}'..\r\n            ":"\r\n              查找与源文件中给出的属性'{0}'相似的本地化字符串与选项'{1}'..\r\n            \r\n","\r\n            Copy this tuple, but modify it to use the new underlying type.\r\n            ":"\r\n            复制此元组，但将其修改为使用新的基础类型。\r\n            \r\n","\r\n              Looks up a localized string similar to A readonly field cannot be returned by writable reference.\r\n            ":"\r\n              查找类似于Readonly字段的本地化字符串无法通过Writable Reference返回。\r\n            \r\n","\r\n            The successor (next larger) value to a given value. The result is not defined\r\n            when ":"\r\n            给定值的后继（下一个较大）值。结果未定义\r\n            什么时候\r\n","True when visiting an rvalue that will actually be used as an lvalue,\r\n            for example a ref parameter when simulating a read of it, or an argument corresponding to an in parameter":"当访问实际将用作lvalue的rvalue时，\r\n            例如，在模拟它的读取时或与in参数相对应的参数时，ref参数\r\n","\r\n            A counterpart to the GetRefEscape, which validates if given escape demand can be met by the expression.\r\n            The result indicates whether the escape is possible. \r\n            Additionally, the method emits diagnostics (possibly more than one, recursively) that would help identify the cause for the failure.\r\n            ":"\r\n            与getRefescape的对应物，该表达式可以满足该验证，如果给定的逃生需求。\r\n            结果表明逃脱是否可能。\r\n            此外，该方法会发出诊断（可能是递归的），这将有助于确定失败的原因。\r\n            \r\n","\r\n            Returns true if the conversion is an explicit unboxing conversion.\r\n            ":"\r\n            如果转换是明确的拆箱转换，则返回true。\r\n            \r\n","The old tree. Cannot be ":"老树。不可能是\r\n","\r\n            Return an array of assemblies referenced by this assembly, which are linked (/l-ed) by \r\n            each compilation that is using this AssemblySymbol as a reference. \r\n            If this AssemblySymbol is linked too, it will be in this array too.\r\n            ":"\r\n            返回此组件引用的一组组件，这些组件由（/l-ed）链接\r\n            每次使用此组合符号作为参考的汇编。\r\n            如果此汇编符号也链接在一起，则它也将在此数组中。\r\n            \r\n","Accumulates errors (e.g. unable to find constructor to invoke).":"累积错误（例如无法找到要调用的构造函数）。\r\n","\r\n              Looks up a localized string similar to Could not find file..\r\n            ":"\r\n              查找类似于找不到文件的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to A throw statement with no arguments is not allowed outside of a catch clause.\r\n            ":"\r\n              在捕获子句之外不允许查找类似于没有参数的投掷语句的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Constraint cannot be the dynamic type.\r\n            ":"查找类似于约束的本地化字符串不能是动态类型。\r\n            \r\n",". One of\r\n            ":"。之一\r\n            \r\n","Called when the visitor visits a BinaryPatternSyntax node.":"当访问者访问binaryPatternsyntax节点时，请致电。\r\n"," needed for debugging.":" 调试所需的。\r\n","Inconsistent accessibility: return type '{1}' is less accessible than method '{0}'":"不一致的可访问性：返回类型'{1}'比方法'{0}'不太访问\r\n","Creates a new SizeOfExpressionSyntax instance.":"创建一个新的sizeofexpressionsyntax实例。\r\n","extern local functions":"外部本地功能\r\n","Defining an alias named 'global' is ill-advised":"定义一个名为“全球”的别名是不明智的\r\n","Identifier expected; '{1}' is a keyword":"标识符预期； '{1}'是一个关键字\r\n","\r\n            Creates a new compilation that can be used in scripting.\r\n            ":"\r\n            创建可用于脚本的新汇编。\r\n            \r\n","\r\n            Creates the syntax representation of a paramref element within xml documentation comments (e.g. for\r\n            referencing particular parameters of a method).\r\n            ":"\r\n            在XML文档注释中创建参数元素的语法表示（例如\r\n            引用方法的特定参数）。\r\n            \r\n","\r\n            Given a using declaration get the corresponding symbol for the using alias that was\r\n            introduced.\r\n            ":"\r\n            给定a用声明获取使用别名的相应符号\r\n            引入。\r\n            \r\n","TypeArgumentListSyntax node representing the list of type arguments of the generic name.":"TypeArgumentListsyntax节点表示通用名称的类型参数列表。\r\n","\r\n            A named type symbol that results from substituting a new owner for a type declaration.\r\n            ":"\r\n            由新所有者代替类型声明而导致的命名类型符号。\r\n            \r\n","\r\n            Used to implement visitor pattern.\r\n            ":"\r\n            用于实现访客模式。\r\n            \r\n","The canonical value of the token's text.":"令牌文本的规范价值。\r\n","Default constraint syntax.":"默认约束语法。\r\n","\r\n            Try setting a user-declared variable (given by its accessing expression) to be\r\n            used for a pattern-matching temporary variable. Returns true when not already\r\n            assigned. The return value of this method is typically ignored by the caller as\r\n            once we have made an assignment we can keep it (we keep the first assignment we\r\n            find), but we return a success bool to emphasize that the assignment is not unconditional.\r\n            ":"\r\n            尝试设置用户指定变量（由其访问表达式给出）为\r\n            用于模式匹配的临时变量。尚未返回true\r\n            分配。该方法的返回值通常被呼叫者忽略为\r\n            一旦我们完成了任务，我们就可以保留它（我们保留第一任作业\r\n            找到），但我们返回成功的布尔，以强调任务不是无条件的。\r\n            \r\n"," and returns its ":" 并返回它\r\n","\r\n            Generate return statements from the state machine method body.\r\n            ":"\r\n            从状态机方法主体中生成返回语句。\r\n            \r\n","The syntax node that declares a variable.":"声明变量的语法节点。\r\n","Delegate '{0}' has no invoke method or an invoke method with a return type or parameter types that are not supported.":"委托'{0}'没有返回类型或不支持的参数类型的调用方法或调用方法。\r\n","\r\n            Merges top-level and nested nullability, dynamic/object, and tuple names from an otherwise equivalent type.\r\n            ":"\r\n            合并来自原本等效类型的顶级和嵌套的无效，动态/对象和元组名称。\r\n            \r\n","\r\n              Looks up a localized string similar to A 'using namespace' directive can only be applied to namespaces; '{0}' is a type not a namespace. Consider a 'using static' directive instead.\r\n            ":"\r\n              查找类似于“使用名称空间”指令的本地化字符串只能应用于名称空间。 '{0}'是类型而不是名称空间。改用“使用静态”指令。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': type used in a using statement must be implicitly convertible to 'System.IDisposable'.\r\n            ":"\r\n              查找类似于“ {0}'：使用语句中使用的类型类型的本地化字符串，必须隐式转换为“ system.idisposable”。\r\n            \r\n","Class which represents the syntax node for bracketed argument list.":"代表包围参数列表的语法节点的类。\r\n","\r\n              Looks up a localized string similar to Target runtime doesn't support 'protected', 'protected internal', or 'private protected' accessibility for a member of an interface..\r\n            ":"\r\n              查找类似于目标运行时的本地化字符串不支持接口成员的“受保护”，“受保护的内部”或“私有保护”可访问性。\r\n            \r\n","\r\n            Gets the containing expression that is actually a language expression (or something that\r\n            GetSymbolInfo can be applied to) and not just typed\r\n            as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side\r\n            of qualified names and member access expressions are not language expressions, yet the\r\n            containing qualified names or member access expressions are indeed expressions.\r\n            Similarly, if the input node is a cref part that is not independently meaningful, then\r\n            the result will be the full cref. Besides an expression, an input that is a NameSyntax\r\n            of a SubpatternSyntax, e.g. in `name: 3` may cause this method to return the enclosing\r\n            SubpatternSyntax.\r\n            ":"\r\n            获取实际上是一种语言表达的表达（或\r\n            getSymbolinfo可以应用于），而不仅仅是键入\r\n            为了方便起见，作为表达方式。例如，右侧的nameyntax节点\r\n            合格的名称和成员访问表达式不是语言表达式\r\n            包含合格的名称或成员访问表达式确实是表达式。\r\n            同样，如果输入节点是没有独立有意义的Cref部分，则\r\n            结果将是完整的Cref。除了表达式，一个是名字列表的输入\r\n            subpaternsyntax，例如在“名称：3”中可能导致此方法返回封闭\r\n            Subpatternsnyntax。\r\n            \r\n","A syntax node that represents a parsed cref. This syntax node\r\n            need not and typically does not appear in the source code referred to SemanticModel instance.":"代表解析的cref的语法节点。此语法节点\r\n            不需要，通常不会出现在引用SemanticModel实例的源代码中。\r\n","Returns null if we can't parse anything (even partially).":"如果我们不能解析任何东西（甚至部分），则返回零。\r\n","Asynchronous streams":"异步流\r\n","\r\n            Using aliases in C# are always contained within a namespace declaration, or at the top\r\n            level within a compilation unit, within the implicit unnamed namespace declaration.  We\r\n            return that as the \"containing\" symbol, even though the alias isn't a member of the\r\n            namespace as such.\r\n            ":"\r\n            在命名空间声明中始终包含C＃中的别名，或者在顶部\r\n            汇编单元内的级别，在隐式未命名的名称空间声明中。我们\r\n            将其作为“包含”符号的归还，即使别名不是成员\r\n            名称空间。\r\n            \r\n","\r\n            If this method overrides another method (because it both had the override modifier\r\n            and there correctly was a method to override), returns the overridden method.\r\n            Note that if an overriding method D.M overrides C.M, which in turn overrides \r\n            virtual method A.M, the \"overridden method\" of D.M is C.M, not the original virtual\r\n            method A.M. Note also that constructed generic methods are not considered to \r\n            override anything.\r\n            ":"\r\n            如果此方法覆盖了另一种方法（因为它都具有覆盖修饰符\r\n            并且正确地是一种覆盖方法），返回覆盖方法。\r\n            请注意，如果覆盖方法D.M覆盖C.M，则又覆盖了\r\n            虚拟方法A.M，D.M的“覆盖方法”是C.M，而不是原始虚拟\r\n            方法A.M.还请注意，构造的通用方法不被视为\r\n            覆盖任何东西。\r\n            \r\n","\r\n            Perform overload resolution on the method group or expression (BoundMethodGroup)\r\n            and arguments and return a BoundExpression representing the invocation.\r\n            ":"\r\n            在方法组或表达式（boundmethodgroup）上执行过载分辨率\r\n            和参数并返回代表调用的界表。\r\n            \r\n","\r\n             For nested type parameters, we expand the tuple names in a pre-order\r\n             traversal:\r\n             \r\n             ":"\r\n             对于嵌套类型参数，我们在预订中展开元组名称\r\n             遍历：\r\n             \r\n             \r\n","\r\n            Optimization: in many cases, the parameter count (fast) is sufficient and we\r\n            don't need the actual parameter symbols (slow).\r\n            ":"\r\n            优化：在许多情况下，参数计数（快速）就足够了，我们\r\n            不需要实际的参数符号（慢）。\r\n            \r\n","\r\n            Adjust declared type based on inferred nullability at the point of reference.\r\n            ":"\r\n            根据参考点的推断可取性调整类型。\r\n            \r\n","\r\n            Calculates all closures which directly or indirectly capture a scopes variables.\r\n            ":"\r\n            计算直接或间接捕获范围变量的所有关闭。\r\n            \r\n","\r\n            Utility class, provides a convenient way of combining various ":"\r\n            公用事业课，提供了一种相结合的方便方式\r\n","\r\n            C# 4.0 §3.6: We implement the rules for ref/out by mapping both to ref. The caller (i.e.\r\n            checking for proper overrides or partial methods, etc) should check that ref/out are\r\n            consistent.\r\n            ":"\r\n            C＃4.0§3.6：我们通过将两者都映射到参考来实施Ref/Out的规则。呼叫者（即\r\n            检查适当的覆盖或部分方法等）应检查参考/外\r\n            持续的。\r\n            \r\n","\r\n            Used to implement ":"\r\n            用于实施\r\n","\r\n            Represents a reference to a generic type instantiation that is not nested.\r\n            e.g. MyNamespace.A{int}\r\n            ":"\r\n            表示对未嵌套的通用类型实例化的引用。\r\n            例如mynamespace.a {int}\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot return a member of local '{0}' by reference because it is not a ref local.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法通过引用返回本地“ {0}”的成员，因为它不是REF LOCAL。\r\n            \r\n","\r\n              Looks up a localized string similar to expression body property accessor.\r\n            ":"\r\n              查找类似于Expression Body属性登录器的局部字符串。\r\n            \r\n","\r\n            Look for a type forwarder for the given type in the containing assembly and any referenced assemblies.\r\n            If one is found, search again in the target assembly.  Return the last assembly in the chain.\r\n            ":"\r\n            在包含的组件和任何引用的组件中寻找给定类型的类型转发器。\r\n            如果找到一个，请在目标组件中再次搜索。返回链中的最后一个组件。\r\n            \r\n","\r\n            Gets the System.Type type symbol from targetSymbol's containing assembly.\r\n            ":"从targetsymbol的包含组件中获取system.type类型符号。\r\n            \r\n","Creates a new ExplicitInterfaceSpecifierSyntax instance.":"创建一个新的explicitInterfaceSpecifierSyntax实例。\r\n","\r\n            The underlying ModuleSymbol, cannot be another RetargetingModuleSymbol.\r\n            ":"\r\n            基础模块符号不能是另一个retargetingModulesymbol。\r\n            \r\n","\r\n              Looks up a localized string similar to A stackalloc expression requires [] after type.\r\n            ":"\r\n              查找类似于stackalloc表达式类似的局部字符串。\r\n            \r\n","(int a, int b) M()":"（int a，int b）m（）\r\n","\r\n            Base class for type and method type parameters.\r\n            ":"\r\n            类型和方法类型参数的基类。\r\n            \r\n","\r\n              Looks up a localized string similar to Position is not within syntax tree with full span {0}.\r\n            ":"\r\n              查找类似于位置的本地化字符串不在具有完整跨度{0}的语法树中。\r\n            \r\n","\r\n              Looks up a localized string similar to warning action enable.\r\n            ":"\r\n              查找类似于警告操作的局部字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Member hides inherited member; missing override keyword.\r\n            ":"\r\n              查找类似于成员隐藏成员的局部字符串；缺少覆盖关键字。\r\n            \r\n","Called when the visitor visits a ArrowExpressionClauseSyntax node.":"当访问者访问ArrowExpressionClausesyntax节点时，请致电。\r\n","An expression cannot be used in this context because it may not be passed or returned by reference":"在此上下文中不能使用表达式，因为它可能不会通过参考传递或返回\r\n","An extension Add method is not supported for a collection initializer in an expression lambda.":"对于表达lambda中的集合初始化器，不支持扩展添加方法。\r\n","True if directives should be included, false by default.":"正确，如果应包括指令，则默认情况下为错误。\r\n","\r\n            Accumulate diagnostics related to the variance safety of an interface.\r\n            ":"\r\n            积累与界面方差安全有关的诊断。\r\n            \r\n","\r\n            A node in a tree representing the form of a generated decision tree for classifying an input value.\r\n            ":"\r\n            在树上代表生成决策树的形式的节点，用于分类输入值。\r\n            \r\n","\r\n            A collection of type parameter constraint types, populated when\r\n            constraint types for the first type parameter are requested.\r\n            ":"\r\n            类型参数约束类型的集合，当\r\n            请求第一个类型参数的约束类型。\r\n            \r\n","\r\n            Returns true if all types and members we need are present and good\r\n            ":"\r\n            如果我们需要的所有类型和成员都有返回，并且良好\r\n            \r\n","\r\n             Produce a while(true) loop\r\n            \r\n             ":"\r\n             产生一段时间（真）循环\r\n            \r\n             \r\n","\r\n              Looks up a localized string similar to This warning occurs if the assembly attributes AssemblyKeyFileAttribute or AssemblyKeyNameAttribute found in source conflict with the /keyfile or /keycontainer command line option or key file name or key container specified in the Project Properties..\r\n            ":"\r\n              查找与此警告相似的本地化字符串，如果汇编属性assemblyKeykeyFileatTribute或assemblyKeyMeateAttribute在源与 /键文件或 /键file或 /keyContainer命令行选项或键文件名称或项目属性中指定的键容器中发现了。\r\n            \r\n","Unrecognized escape sequence":"无法识别的逃生序列\r\n","\r\n            Parse a NameSyntax node using the grammar rule for names.\r\n            ":"\r\n            使用名称的语法规则来解析名称nodax节点。\r\n            \r\n","\r\n              Looks up a localized string similar to The 'goto case' value is not implicitly convertible to type '{0}'.\r\n            ":"\r\n              查找类似于“ goto case”值的本地化字符串并非隐式转换为type'{0}'。\r\n            \r\n"," if we are in an explicitly unchecked context (within unchecked block or expression).\r\n            ":" 如果我们处于明确的未检查的上下文（在未检查的块或表达式中）。\r\n            \r\n","A declaration of a by-reference variable must have an initializer":"串联变量的声明必须具有初始化器\r\n","\r\n            Produce a bound expression representing a pointer to a frame of a particular frame type.\r\n            ":"\r\n            产生代表指向特定帧类型框架的指针的绑定表达式。\r\n            \r\n"," controls whether to continue the visit by returning true or false:\r\n            if true, the visit will continue. If false, the walk will be cut off.\r\n            ":" 控制是否通过返回对还是错来继续访问：\r\n            如果是真的，访问将继续。如果是错误的，则步行将被切断。\r\n            \r\n","\r\n             The interesting part in the following method is the support for exception filters. \r\n             === Example:\r\n            \r\n             try\r\n             {\r\n                TryBlock\r\n             }\r\n             catch (ExceptionType ex) when (Condition)\r\n             {\r\n                Handler\r\n             }\r\n            \r\n             gets emitted as something like ===>\r\n            \r\n             Try           \r\n                 TryBlock\r\n             Filter \r\n                 var tmp = Pop() as {ExceptionType}\r\n                 if (tmp == null)\r\n                 {\r\n                     Push 0\r\n                 }\r\n                 else\r\n                 {\r\n                     ex = tmp\r\n                     Push Condition ? 1 : 0\r\n                 }\r\n             End Filter // leaves 1 or 0 on the stack\r\n             Catch      // gets called after finalization of nested exception frames if condition above produced 1\r\n                 Pop    // CLR pushes the exception object again\r\n                 variable ex can be used here\r\n                 Handler\r\n             EndCatch\r\n             ":"\r\n             以下方法中有趣的部分是支持异常过滤器。\r\n             ===示例：\r\n            \r\n             尝试\r\n             {\r\n                tryblock\r\n             }\r\n             当（条件）时捕获（异常）\r\n             {\r\n                处理程序\r\n             }\r\n            \r\n             被排放为===>\r\n            \r\n             尝试\r\n                 tryblock\r\n             筛选\r\n                 var tmp = pop（）as {exceptionType}\r\n                 if（tmp == null）\r\n                 {\r\n                     推0\r\n                 }\r\n                 别的\r\n                 {\r\n                     ex = tmp\r\n                     推送条件？ 1：0\r\n                 }\r\n             结束滤镜//堆栈上的1或0留在1或0\r\n             捕获//在最终确定嵌套异常框架后被调用，如果以上产生的条件1\r\n                 pop // clr再次推动异常对象\r\n                 可变EX可以在此处使用\r\n                 处理程序\r\n             端捕\r\n             \r\n","\r\n              Looks up a localized string similar to Do not use 'System.ParamArrayAttribute'. Use the 'params' keyword instead..\r\n            ":"\r\n              查找类似于不使用“ system.paramarrayattribute”的本地化字符串。使用“参数”关键字。\r\n            \r\n","&=":"＆=\r\n","\r\n              Looks up a localized string similar to alternative interpolated verbatim strings.\r\n            ":"\r\n              查找类似于替代插值的逐字字符串的局部字符串。\r\n            \r\n","The assembly wanting access.":"大会想要访问。\r\n","\r\n              Looks up a localized string similar to Declaration is not valid; use '{0} operator <dest-type> (...' instead.\r\n            ":"\r\n              查找类似于声明的本地化字符串是无效的；使用'{0}运算符<dest-type>（...'而不是。\r\n            \r\n","\r\n            Represents a property of a tuple type (such as (int, byte).SomeProperty)\r\n            that is backed by a property within the tuple underlying type.\r\n            ":"\r\n            代表元组类型的属性（例如（int，byte）.someproperty）\r\n            这是由元组基础类型中的属性支持的。\r\n            \r\n"," method generated\r\n            for an element-initializer in a collection-initializer, the parameter ":" 生成的方法\r\n            对于收集器中的元素限制器，参数\r\n","\r\n            Verify if the given type can be used to back a tuple type. \r\n            ":"\r\n            验证给定类型是否可以用于备份元组类型。\r\n            \r\n","Keyword 'base' is not available in a static method":"关键字“基础”不可用静态方法可用\r\n","The language name is invalid":"语言名称无效\r\n","\r\n              Looks up a localized string similar to Only 65534 locals, including those generated by the compiler, are allowed.\r\n            ":"\r\n              允许查找一个类似于65534个本地人的本地化字符串，包括编译器生成的局部字符串。\r\n            \r\n","Second path: absolute, relative, or null.":"第二个路径：绝对，相对或空。\r\n","\r\n            Gets the ref kind of the property.\r\n            ":"\r\n            获取财产的裁判类型。\r\n            \r\n","\r\n            Get the highest bound node in the tree associated with a particular syntax node.\r\n            ":"\r\n            获取与特定语法节点关联的树中的最高界节点。\r\n            \r\n","The index of the argument":"论点的索引\r\n","\r\n            A generic named type symbol that has been constructed with type arguments distinct from its own type parameters.\r\n            ":"\r\n            一种通用类型符号，已使用与其自身类型参数不同的类型参数构建。\r\n            \r\n","Local functions":"本地功能\r\n","\r\n            Was the receiver expression compiler-generated?\r\n            ":"\r\n            接收器表达编译器生成了吗？\r\n            \r\n","\r\n            Null literal conversions are described in section 6.1.5 of the C# language specification.\r\n            ":"\r\n            无效的文字转换在C＃语言规范的第6.1.5节中描述。\r\n            \r\n","\r\n            Return the delegate type if this expression represents a delegate.\r\n            ":"如果此表达式表示委托，则返回委托类型。\r\n            \r\n","\r\n            One implementation M1 is considered more specific than another implementation M2 \r\n            if M1 is declared on interface T1, M2 is declared on interface T2, and \r\n            T1 contains T2 among its direct or indirect interfaces.\r\n            ":"\r\n            一种实施M1被认为比另一个实现更具体\r\n            如果在接口T1上声明M1，则在接口T2上声明M2，并且\r\n            T1在其直接或间接接口中包含T2。\r\n            \r\n","\r\n            Returns true if the given argument is the begining of a list of param array arguments (could be empty), otherwise returns false.\r\n            When returns true, numberOfParamArrayArguments is set to the number of param array arguments.\r\n            ":"\r\n            如果给定参数是参数参数列表的开始（可以是空），则返回true，否则返回false。\r\n            当返回true时，将numberOfParamArrayArayArguments设置为param数组参数的数量。\r\n            \r\n","Warning: Could not enable multicore JIT due to exception: {0}.":"警告：由于例外：{0}无法启用多核JIT。\r\n","\r\n            Implemented by symbols that can be targetted by an attribute declaration (i.e. source symbols).\r\n            ":"\r\n            由可以通过属性声明（即源符号）瞄准的符号实现。\r\n            \r\n","\r\n              Looks up a localized string similar to Constraint cannot be special class '{0}'.\r\n            ":"\r\n              查找类似于约束的本地化字符串不能是特殊类'{0}'。\r\n            \r\n","\r\n            Whether we are going to read the currently visited expression.\r\n            ":"\r\n            我们是否要阅读当前访问的表达。\r\n            \r\n","\r\n             Returns a byte blob that matches serialized content of single array initializer.    \r\n             returns -1 if the initializer is null or not an array of literals\r\n            ":"\r\n             返回与单个数组初始化程序的序列化内容匹配的字节斑点。\r\n             返回-1如果初始化器为null或不是文字数组\r\n            \r\n","extension method":"扩展方法\r\n","'{0}': static classes cannot implement interfaces":"'{0}'：静态类无法实现接口\r\n","\r\n            Returns a temp which is initialized with lowered-expression.GetValueOrDefault()\r\n            ":"\r\n            返回使用降低示例初始化的温度.getValueordEfault（）\r\n            \r\n","\r\n            Gets a \"in\" parameter for which there is no argument supplied, if such exists. \r\n            That indicates an optional \"in\" parameter. We treat it as an RValue passed by reference via a temporary.\r\n            The effective scope of such variable is the immediately containing scope.\r\n            ":"\r\n            获取一个“在”参数中，如果存在这种参数，则没有提供参数。\r\n            这表示可选的“”参数。我们将其视为通过临时引用通过的rvalue。\r\n            这种变量的有效范围是立即包含范围。\r\n            \r\n","\r\n            Extensible calling convention protocol. This represents either the union of calling convention modopts after the paramcount specifier\r\n            in IL, or platform default if none are present\r\n            ":"\r\n            可扩展的呼叫约定协议。这代表了在ParamCount Specifier之后调用judent judent Modopts的结合\r\n            在IL中，或平台默认如果没有\r\n            \r\n","\r\n            Return an array of assemblies involved in canonical type resolution of\r\n            NoPia local types defined within this assembly. In other words, all \r\n            references used by previous compilation referencing this assembly.\r\n            ":"\r\n            返回一系列参与规范类型分辨率的组件\r\n            NOPIA在此组件中定义的本地类型。换句话说，所有人\r\n            先前汇编所用的参考引用了此组件。\r\n            \r\n","\r\n            This pass is expected to run on partially lowered methods\r\n            previously containing one or more local functions. At this\r\n            point all local functions should have been rewritten into\r\n            proper closure classes and have frames and proxies generated\r\n            for them.\r\n            \r\n            The only thing left is to visit all \"references\" to local functions\r\n            and rewrite them to be references to the rewritten form. \r\n            ":"\r\n            预计该通行证将以部分降低的方法运行\r\n            以前包含一个或多个局部功能。在这\r\n            指点所有本地功能都应重写\r\n            适当的关闭课程，并生成框架和代理\r\n            为他们。\r\n            \r\n            剩下的唯一的是访问所有“参考”本地功能\r\n            并将它们重写为重写表格。\r\n            \r\n","The type information for the topmost node of the expression.":"表达式最高节点的类型信息。\r\n","True if there's a member with the same name and kind that is not a match.":"是的，如果有一个不匹配的成员和同类的成员。\r\n","\r\n            When converting an anonymous function to a delegate type, there are some diagnostics\r\n            that will occur regardless of the delegate type - particularly those that do not\r\n            depend on the substituted types (e.g. name uniqueness).  Even though we need to\r\n            produce a diagnostic in such cases, we do not need to abandon overload resolution -\r\n            we can choose the overload that is best without regard to such diagnostics.\r\n            ":"\r\n            将匿名函数转换为委托类型时，有一些诊断\r\n            无论代表类型如何，都会发生这种情况 - 尤其是那些\r\n            取决于取代类型（例如名称唯一性）。即使我们需要\r\n            在这种情况下产生诊断，我们无需放弃超负荷解决方案 - \r\n            我们可以选择最好的过载，而无需考虑此类诊断。\r\n            \r\n","\r\n            Synthesize closure methods for all nested functions.\r\n            ":"\r\n            所有嵌套功能的合成闭合方法。\r\n            \r\n","\r\n              Looks up a localized string similar to The type of the expression in the {0} clause is incorrect.  Type inference failed in the call to '{1}'..\r\n            ":"\r\n              查找类似于{0}子句中表达式类型的本地化字符串是不正确的。类型推理在调用'{1}'..的呼叫中失败。\r\n            \r\n","\r\n              Looks up a localized string similar to Submission can have at most one syntax tree..\r\n            ":"\r\n              查找类似于提交的本地化字符串，最多可以具有一个语法树。\r\n            \r\n","\r\n            Returns whether nullable warnings are enabled within the span.\r\n            Returns true if nullable warnings are enabled anywhere in the span;\r\n            false if nullable warnings are disabled throughout the span; and\r\n            null otherwise.\r\n            ":"\r\n            返回是否在跨度内启用了无效警告。\r\n            如果在跨越任何地方启用了无效的警告，则返回true；\r\n            如果在整个跨度上禁用了无效的警告，则为错误；和\r\n            否则为无效。\r\n            \r\n","\r\n              Looks up a localized string similar to Elements cannot be null..\r\n            ":"\r\n              查找类似于元素的本地化字符串不能为空。\r\n            \r\n","\r\n            Note, ":"\r\n            笔记，\r\n","The assembly possibly providing symbols to be accessed.":"组件可能会提供要访问的符号。\r\n","Called when the visitor visits a FromClauseSyntax node.":"当访问者访问ClrofClausesyntax节点时，请致电。\r\n","\r\n              Looks up a localized string similar to Cannot pass the range variable '{0}' as an out or ref parameter.\r\n            ":"\r\n              查找类似于类似的本地化字符串无法将范围变量'{0}'作为out或ref参数传递。\r\n            \r\n","\r\n            Represents a compiler generated synthesized method symbol\r\n            representing string switch hash function\r\n            ":"\r\n            代表编译器生成的合成方法符号\r\n            表示字符串开关哈希功能\r\n            \r\n","\r\n            Represents a reference to a generic type instantiation that is nested in a non-generic type.\r\n            e.g. A.B{int}\r\n            ":"\r\n            代表对嵌套在非类型类型中的通用类型实例化的引用。\r\n            例如a.b {int}\r\n            \r\n","\r\n            Contains the map of expressions to inferred nullabilities and types used by the optional rewriter phase of the\r\n            compiler.\r\n            ":"\r\n            包含表达式图，以推断出的无效性和类型\r\n            编译器。\r\n            \r\n","\r\n              Looks up a localized string similar to The modifier '{0}' is not valid for this item in C# {1}. Please use language version '{2}' or greater..\r\n            ":"\r\n              查找类似于修饰符'{0}'的本地化字符串对于C＃{1}中的该项目无效。请使用语言版本'{2}'或更大。\r\n            \r\n","\r\n              Looks up a localized string similar to Error opening Win32 resource file '{0}' -- '{1}'.\r\n            ":"\r\n              查找类似于错误打开Win32资源文件'{0}' - '{1}'的本地化字符串。\r\n            \r\n","Creates a new BracketedParameterListSyntax instance.":"创建一个新的BracketedParameterListsyntax实例。\r\n","An identifier was expected.":"预期标识符。\r\n","\r\n            Returns true when conversion itself (not the operand) may have side-effects\r\n            A typical side-effect of a conversion is an exception when conversion is unsuccessful.\r\n            ":"\r\n            当转换本身（不是操作数）可能具有副作用时，返回true\r\n            转换不成功时，转换的典型副作用是例外。\r\n            \r\n","Name of destructor must match name of type":"驱动器的名称必须匹配类型的名称\r\n","\r\n            Get all instance field and event members.\r\n            ":"\r\n            获取所有实例字段和事件成员。\r\n            \r\n","True if a diagnostic was reported, or would have been reported if not for\r\n            the suppress flag.":"如果报告了诊断，则是真的，如果不是\r\n            抑制标志。\r\n","\r\n            Get the ref kinds of the parameters of a member symbol.  Should be a method, property, or event.\r\n            ":"\r\n            获取成员符号的参数的参考。应该是一种方法，属性或事件。\r\n            \r\n","\r\n              Looks up a localized string similar to A public, protected, or protected internal variable must be of a type that is compliant with the Common Language Specification (CLS)..\r\n            ":"\r\n              查找类似于公共，受保护或受保护的内部变量的本地化字符串必须是符合常见语言规范（CLS）的类型。\r\n            \r\n","\r\n            Creates a token corresponding to a syntax kind. This method can be used for token syntax kinds whose text\r\n            can be inferred by the kind alone.\r\n            ":"\r\n            创建与语法类型相对应的令牌。此方法可用于代币语法类型\r\n            可以单独推断出那种。\r\n            \r\n","A resulting ":"结果\r\n","This error occurs when a predefined system type such as System.Int32 is found in two assemblies. One way this can happen is if you are referencing mscorlib or System.Runtime.dll from two different places, such as trying to run two versions of the .NET Fram ...":"当在两个组件中找到预定义的系统类型（例如System.Int32）时，就会发生此错误。这可能发生的一种方法是，如果您是从两个不同的位置引用mscorlib或system.runtime.dll，例如试图运行两个版本的.NET FRAM ...\r\n","\r\n              Looks up a localized string similar to By-reference return type 'ref {0}' is not supported..\r\n            ":"\r\n              查找类似于副参考返回类型'ref {0}'的本地化字符串。\r\n            \r\n","Type '{0}' exported from module '{1}' conflicts with type declared in primary module of this assembly.":"从模块'{1}'导出的类型'{0}'与此组件的主模块中声明的类型发生冲突。\r\n","\r\n            Given tk, the type of the current token, does this look like the type of a pattern?\r\n            ":"\r\n            给定tk，当前令牌的类型，这看起来像模式的类型吗？\r\n            \r\n","\r\n            If there are any discards in the arguments, create locals for each, updates the arguments and\r\n            returns the symbols that were created.\r\n            Returns default if no discards found.\r\n            ":"\r\n            如果参数中有任何丢弃，请为每个参数创建当地人，更新参数和\r\n            返回创建的符号。\r\n            如果找不到丢弃，则返回默认值。\r\n            \r\n","\r\n            A trivial node replacement function for use with ":"\r\n            一个琐碎的节点替换功能，可用于\r\n","<namespace>":"<名称空间>\r\n","\r\n            Does not respect DocumentationMode, so do not call unless diagnostics are desired.\r\n            ":"\r\n            不尊重文档模式，因此除非需要诊断，否则请勿致电。\r\n            \r\n","\r\n            Returns true if the compiler accepted this member as the sole correct result of overload resolution.\r\n            ":"\r\n            如果编译器接受此成员作为过载分辨率的唯一正确结果，则返回true。\r\n            \r\n","Class which represents the syntax node for type argument list.":"代表类型参数列表的语法节点的类。\r\n","Arguments bound by the caller.":"由呼叫者约束的参数。\r\n","\r\n            Is this a symbol for a Tuple.\r\n            ":"\r\n            这是元组的象征。\r\n            \r\n","Tuple element names are not permitted on the left of a deconstruction.":"解构的左侧不允许元组元素名称。\r\n","\r\n              Looks up a localized string similar to An object, string, or class type expected.\r\n            ":"\r\n              查找类似于对象，字符串或类型预期的本地化字符串。\r\n            \r\n","\r\n            Creates the syntax representation of a permission element within xml documentation comments.\r\n            ":"\r\n            在XML文档注释中创建权限元素的语法表示。\r\n            \r\n","Creates a new NullableDirectiveTriviaSyntax instance.":"创建一个新的nullabledirectivitriviasyntax实例。\r\n","\r\n            Retargeting map from underlying module to this one.\r\n            ":"\r\n            从基础模块重新定位地图。\r\n            \r\n","\r\n              Looks up a localized string similar to Member '{0}' cannot be accessed with an instance reference; qualify it with a type name instead.\r\n            ":"\r\n              查找类似于成员'{0}'的本地化字符串，无法使用实例参考访问；用类型名称限定它。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' does not implement the '{1}' pattern. '{2}' is ambiguous with '{3}'..\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串不会实现'{1}'模式。 '{2}'对'{3}'..模棱两可。\r\n            \r\n","Corresponding binder factory.":"相应的粘合剂工厂。\r\n","Cannot await '{0}'":"无法等待'{0}'\r\n","The 4-byte floating point value to be represented by the returned token.":"返回令牌将代表的4字节浮点值。\r\n","\r\n              Looks up a localized string similar to Method, operator, or accessor '{0}' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation..\r\n            ":"\r\n              查找类似于方法，运算符或登录器'{0}'的本地化字符串是外部标记的，其上没有属性。考虑添加dllimport属性以指定外部实现。\r\n            \r\n","\r\n            Determines whether this Unicode character can start a XMLName.\r\n            ":"\r\n            确定此Unicode字符是否可以启动XMLNAME。\r\n            \r\n","Represents a token that comes after the end of a directive such as ":"代表在指令结束之后出现的令牌\r\n","\r\n              Looks up a localized string similar to Out variable and pattern variable declarations are not allowed within a query clause..\r\n            ":"\r\n              查找类似于OUT变量的本地化字符串，在查询子句中不允许使用模式变量声明。\r\n            \r\n","Returns the index value.":"返回索引值。\r\n","\r\n            Modifies an input ":"\r\n            修改输入\r\n","\r\n              Looks up a localized string similar to The Conditional attribute is not valid on '{0}' because it is an override method.\r\n            ":"\r\n              在“ {0}”上查找类似于条件属性的本地化字符串在“ {0}”上无效，因为它是一种覆盖方法。\r\n            \r\n"," object; otherwise, false.":" 目的;否则，错误。\r\n","\r\n            Map of reference id's to deserialized objects.\r\n            ":"\r\n            参考ID的映射到应序列化对象。\r\n            \r\n","\r\n            Creates a token with kind CharacterLiteralToken from the text and corresponding character value.\r\n            ":"\r\n            从文本和相应的字符值中创建一个具有善良的字符的令牌。\r\n            \r\n","One or more types required to compile a dynamic expression cannot be found. Are you missing a reference?":"找不到一种或多种编译动态表达式所需的类型。您是否缺少参考？\r\n","Invalid value for named attribute argument '{0}'":"命名属性参数'{0}'的无效值\r\n","\r\n            The immediately containing namespace or named type, or null\r\n            if the containing symbol is neither a namespace or named type.\r\n            ":"\r\n            立即包含名称空间或命名类型，或NULL\r\n            如果包含的符号既不是名称空间，也不是命名类型。\r\n            \r\n","\r\n            This method is a wrapper around MethodGroupConversionHasErrors.  As a preliminary step,\r\n            it checks whether a conversion exists.\r\n            ":"\r\n            此方法是围绕MethodGroupConversionHaserrors的包装器。作为初步步骤，\r\n            它检查是否存在转换。\r\n            \r\n","A value of type '{0}' cannot be used as default parameter for nullable parameter '{1}' because '{0}' is not a simple type":"类型'{0}'的值不能用作nullable参数'{1}'的默认参数，因为'{0}不是一个简单的类型\r\n","Gets a SyntaxToken that represents the colon following the statement's label.":"获取表示语句标签后面冒号的SyntaxToken。\r\n","Target symbol.":"目标符号。\r\n","\r\n            Not preserved in types constructed from this one.\r\n            ":"\r\n            不保存在从这个构造的类型中。\r\n            \r\n","'{0}' cannot be both extern and abstract":"'{0}'不能既是外部又是抽象\r\n","\r\n              Looks up a localized string similar to An expression tree may not contain a dynamic operation.\r\n            ":"\r\n              查找类似于表达树的本地化字符串可能不包含动态操作。\r\n            \r\n"," for this compilation. Do not access directly, use Assembly property\r\n            instead. This field is lazily initialized by ReferenceManager, ReferenceManager.CacheLockObject must be locked\r\n            while ReferenceManager \"calculates\" the value and assigns it, several threads must not perform duplicate\r\n            \"calculation\" simultaneously.\r\n            ":" 为此汇编。请勿直接访问，使用汇编属性\r\n            反而。该字段是由ReferenceManager懒惰的，ReferenceManager.cachelockobject必须锁定\r\n            当ReferenceManager“计算”值并分配值时，几个线程不得执行重复\r\n            同时“计算”。\r\n            \r\n","\r\n              Looks up a localized string similar to Field '{0}' must be fully assigned before control is returned to the caller.\r\n            ":"\r\n              查找类似于字段'{0}'的本地化字符串，必须在将控件返回到呼叫者之前完全分配。\r\n            \r\n","\r\n            Creates a trivia with kind EndOfLineTrivia containing the specified text. \r\n            ":"\r\n            用包含指定文本的善良内传式创建一个琐事。\r\n            \r\n","Badly formed XML file \"{0}\" cannot be included":"不包含不良形成的XML文件“ {0}”\r\n","Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor method '{1}'":"该语言不支持属性，索引或事件“ {0}”；尝试直接调用登录器方法'{1}'\r\n"," node":" 节点\r\n","\r\n            We use this to restore the old set of pending branches after visiting a construct that contains nested statements.\r\n            ":"\r\n            我们使用它来访问包含嵌套语句的构造后恢复旧的待处理分支。\r\n            \r\n","Argument of the primary function.":"主要功能的参数。\r\n","SimpleNameSyntax node representing the member being bound to.":"SimpleNamesyntax节点表示成员所绑定。\r\n","\r\n            States for `yield return` are decreasing from -3.\r\n            ":"\r\n            “收益率回报”的状态从-3下降。\r\n            \r\n","If method returns true, contains cardinality of the compatible tuple type.":"如果方法返回true，则包含兼容元组类型的基数。\r\n","The type of a local declared in a fixed statement must be a pointer type":"固定语句中声明的本地的类型必须是指针类型\r\n","Static local functions":"静态局部功能\r\n","Exception filters":"异常过滤器\r\n","\r\n            True if this is a Windows Runtime-style event.\r\n            \r\n            A normal C# event, \"event D E\", has accessors\r\n                void add_E(D d)\r\n                void remove_E(D d)\r\n            \r\n            A Windows Runtime event, \"event D E\", has accessors\r\n                EventRegistrationToken add_E(D d)\r\n                void remove_E(EventRegistrationToken t)\r\n            ":"\r\n            如果这是Windows Runtime风格的事件，则正确。\r\n            \r\n            普通的C＃事件“事件D E”有登录器\r\n                void add_e（d d）\r\n                void remove_e（d d）\r\n            \r\n            Windows运行时事件“事件D E”有登录\r\n                EventRegistrationToken add_e（D D）\r\n                void remove_e（eventRegistrationToken t）\r\n            \r\n","\r\n              Looks up a localized string similar to anonymous methods.\r\n            ":"\r\n              查找类似于匿名方法的本地化字符串。\r\n            \r\n","\r\n            Creates a token with kind StringLiteralToken from the text and corresponding string value.\r\n            ":"\r\n            从文本和相应的字符串值中创建一个用and StringLiteralToken创建令牌。\r\n            \r\n"," visitor that visits only the single CSharpSyntaxNode\r\n            passed into its Visit method.\r\n            ":" 仅访问单个csharpsyntaxnode的访客\r\n            传递到访问方法。\r\n            \r\n","\r\n            Parse a single variable designation (e.g. ":"\r\n            解析单个变量名称（例如\r\n","\r\n            Expression is the operand of an increment\r\n            or decrement operation.\r\n            ":"\r\n            表达是增量的操作数\r\n            或减少操作。\r\n            \r\n","The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task<{0}>'.":"“等待”操作员只能在异步方法中使用。考虑使用“ async”修饰符标记此方法，然后将其返回类型更改为“任务<{0}>”。\r\n","Conversion operator declaration syntax.":"转换操作员声明语法。\r\n","\r\n            Lookup a nested namespace.\r\n            ":"\r\n            查找一个嵌套的名称空间。\r\n            \r\n"," to test for.":" 测试。\r\n","Provided language version is unsupported or invalid: '{0}'.":"提供的语言版本不支持或无效：'{0}'。\r\n","\r\n              Looks up a localized string similar to The delegate '{0}' does not have a valid constructor.\r\n            ":"\r\n              查找类似于委托'{0}'的本地化字符串没有有效的构造函数。\r\n            \r\n","Creates a new InterfaceDeclarationSyntax instance.":"创建一个新的InterfaceClarationSyntax实例。\r\n","Called when the visitor visits a OmittedTypeArgumentSyntax node.":"当访问者访问省略的peargumentsyntax节点时，请致电。\r\n","The /pdb option requires that the /debug option also be used":"/pdb选项要求也使用 /调试选项\r\n","\r\n              Looks up a localized string similar to Executables cannot be satellite assemblies; culture should always be empty.\r\n            ":"\r\n              查找类似于可执行文件的本地化字符串不能是卫星组件；文化应该永远是空的。\r\n            \r\n","Interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'":"界面标记为“ CoclassAttribute”，未标记为“ comimportattribute”\r\n"," True if the input was bad, such as no first and last nodes ":" 如果输入不好，则是真的，例如没有第一个和最后一个节点\r\n","\r\n            The passed in expression is interpreted as a stand-alone expression, as if it\r\n            appeared by itself somewhere within the scope that encloses \"position\".\r\n            \r\n            ":"\r\n            传递的表达式被解释为独立表达，好像\r\n            自行出现在包围“位置”的范围内的某个地方。\r\n            \r\n            \r\n","'{2}' must be a non-abstract type with a public parameterless constructor in order to use it as parameter '{1}' in the generic type or method '{0}'":"'{2}'必须是具有公共参数构造函数的非抽象类型\r\n","The type '{1}' exists in both '{0}' and '{2}'":"'{0}'和'{2}'中存在类型的'{1}'\r\n"," that represents\r\n            a type symbol that was attempted to be read from metadata, but couldn't be\r\n            found, because:\r\n              a) The metadata file it lives in wasn't referenced\r\n              b) The metadata file was referenced, but didn't contain the type\r\n              c) The metadata file was referenced, contained the correct outer type, but\r\n                 didn't contains a nested type in that outer type.\r\n            ":" 代表\r\n            试图从元数据读取的类型符号，但不能\r\n            发现，因为：\r\n              a）未参考它居住的元数据文件\r\n              b）引用了元数据文件，但不包含类型\r\n              c）引用了元数据文件，包含正确的外部类型，但\r\n                 没有包含该外部类型中的嵌套类型。\r\n            \r\n"," level to ":" 水平\r\n","The CallerLineNumberAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments":"应用于参数'{0}'的callerlinenumberattribute将无效，因为它适用于不允许可选参数的上下文中使用的成员\r\n","Function pointer calling convention syntax.":"函数指针调用约定语法。\r\n","Consider static constructor and fields rather than instance constructors and fields.":"考虑静态构造函数和字段，而不是实例构造函数和字段。\r\n","The returned method must have the same return type.":"返回的方法必须具有相同的返回类型。\r\n","\r\n            If this property is sealed, then we have to emit both accessors - regardless of whether\r\n            they are present in the source - so that they can be marked final. (i.e. sealed).\r\n            ":"\r\n            如果密封此属性，那么我们必须散发两个登记器 - 不管是否是否\r\n            它们存在于源头中 - 以便可以标记为最终。 （即密封）。\r\n            \r\n",", this type doesn't depend\r\n            on any specific kind of syntax node associated with it. Any syntax node is good enough\r\n            for it.\r\n            ":"，这种类型不取决于\r\n            在与之关联的任何特定类型的语法节点上。任何语法节点都足够好\r\n            为了它。\r\n            \r\n","\r\n            Returns true if the parameter was declared as a parameter array.\r\n            Note: it is possible for any parameter to have the [ParamArray] attribute (for instance, in IL),\r\n                even if it is not the last parameter. So check for that.\r\n            ":"\r\n            如果参数被声明为参数阵列，则返回true。\r\n            注意：任何参数都可以具有[paramarray]属性（例如，在IL），\r\n                即使不是最后一个参数。因此，请检查一下。\r\n            \r\n","\r\n              Looks up a localized string similar to tuple equality.\r\n            ":"\r\n              查找类似于元组平等的局部字符串。\r\n            \r\n","Cannot initialize type '{0}' with a collection initializer because it does not implement 'System.Collections.IEnumerable'":"无法使用集合初始化器初始化类型'{0}'，因为它不能实现'system.collections.ienumerable'\r\n","\r\n              Looks up a localized string similar to Error opening Win32 manifest file {0} -- {1}.\r\n            ":"\r\n              查找类似于错误打开Win32清单文件{0}  -  {1}的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Indexers must have at least one parameter.\r\n            ":"\r\n              查找类似于索引器的本地化字符串必须至少具有一个参数。\r\n            \r\n","\r\n            Applies analysis similar to ":"\r\n            应用与类似的分析\r\n","Synthesized method invocation expression.":"合成方法调用表达式。\r\n","\r\n              Looks up a localized string similar to Empty switch block.\r\n            ":"\r\n              查找类似于空开关块的局部字符串。\r\n            \r\n","\r\n            A reference to ":"\r\n            引用\r\n","\r\n             This should be a reachable state that won't affect another reachable state in a\r\n             ":"\r\n             这应该是一种可达到的状态，不会影响\r\n             \r\n","\r\n              Looks up a localized string similar to Error writing to XML documentation file: {0}.\r\n            ":"\r\n              查找类似于XML文档文件的错误写入错误的本地化字符串：{0}。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': an entry point cannot be generic or in a generic type.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串：入口点不能是通用或通用类型的。\r\n            \r\n","Partial declarations of '{0}' must have the same type parameter names and variance modifiers in the same order":"“ {0}”的部分声明必须具有相同顺序的相同类型的参数名称和差异修饰符\r\n","\r\n              Looks up a localized string similar to '{0}': Auto-implemented properties cannot be used inside a type marked with StructLayout(LayoutKind.Explicit).\r\n            ":"\r\n              查找类似于“ {0}'的局部字符串：自动实现的属性无法在标记的structlayout（layoutkind.explicit）标记的类型中使用。\r\n            \r\n","\r\n              Looks up a localized string similar to Member '{0}' implements interface member '{1}' in type '{2}'. There are multiple matches for the interface member at run-time. It is implementation dependent which method will be called..\r\n            ":"\r\n              在类型'{2}'中查找类似于成员'{0}'实现接口成员'{1}'的本地化字符串。在运行时，接口成员有多个匹配项。这是实现依赖性的，哪种方法将被调用。\r\n            \r\n","Error opening Win32 resource file '{0}' -- '{1}'":"错误打开Win32资源文件'{0}' - '{1}'\r\n","\r\n              Looks up a localized string similar to '{0}': a volatile field cannot be of the type '{1}'.\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串：挥发性字段不能是类型'{1}'。\r\n            \r\n"," expression.  A generic type is considered ":" 表达。考虑通用类型\r\n","\r\n            True if this Symbol should be completed by calling ForceComplete.\r\n            Intuitively, true for source entities (from any compilation).\r\n            ":"\r\n            如果应通过调用ForceMplete来完成此符号，则为true。\r\n            直觉，对于源实体（来自任何汇编）的真实性。\r\n            \r\n","True if the types are equivalent.":"如果类型等价，则为真。\r\n","\r\n              Looks up a localized string similar to '{0}' specified for Main method must be a non-generic class, struct, or interface.\r\n            ":"\r\n              查找类似于主方法指定的“ {0}”的本地化字符串必须是非类别类，结构或接口。\r\n            \r\n","Item{i}":"项目{i}\r\n","\r\n            The latest version of the language supported.\r\n            ":"\r\n            支持该语言的最新版本。\r\n            \r\n"," with the new scope\r\n            ":" 有了新范围\r\n            \r\n","Indicates whether the current Range object is equal to another object of the same type.":"指示当前范围对象是否等于同一类型的另一个对象。\r\n","\r\n              Looks up a localized string similar to Ignoring /win32manifest for module because it only applies to assemblies.\r\n            ":"\r\n              查找类似于忽略 /win32manifest的本地化字符串，因为它仅适用于汇编。\r\n            \r\n","\r\n            Assuming that nullable annotations are enabled:\r\n            T => true\r\n            T where T : struct => false\r\n            T where T : class => false\r\n            T where T : class? => true\r\n            T where T : IComparable => true\r\n            T where T : IComparable? => true\r\n            T where T : notnull => true\r\n            ":"\r\n            假设启用了无效的注释：\r\n            t => true\r\n            t其中t：struct => false\r\n            t其中t：class => false\r\n            t在哪里：上课？ => true\r\n            t其中t：iComable => true\r\n            t t：可观的？ => true\r\n            t其中t：notnull => true\r\n            \r\n","\r\n              Looks up a localized string similar to nullable types.\r\n            ":"\r\n              查找类似于无效类型的本地化字符串。\r\n            \r\n"," are missing.\r\n            The attribute is synthesized only if present.\r\n            ":" 缺失。\r\n            仅在存在时才合成该属性。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot find the interop type that matches the embedded interop type '{0}'. Are you missing an assembly reference?.\r\n            ":"\r\n              查找类似于类似的本地化字符串，找不到与嵌入式Interop类型'{0}'匹配的Interop类型。您是否错过了组装参考？\r\n            \r\n","\r\n            Checks if 'symbol' is accessible from within named type 'within'.  If 'symbol' is accessed off\r\n            of an expression then 'throughTypeOpt' is the type of that expression. This is needed to\r\n            properly do protected access checks.\r\n            ":"\r\n            检查“符号”是否可以从命名类型“内部”中访问。如果访问“符号”\r\n            然后“透明型”的表达是该表达式的类型。这是需要的\r\n            正确执行保护访问检查。\r\n            \r\n","\r\n              Looks up a localized string similar to Filter expression is a constant 'false'. .\r\n            ":"\r\n              查找类似于过滤器表达式的本地化字符串是常数“ false”。 。\r\n            \r\n","\r\n            NOTE: Keep this method in sync with AnalyzeImplicitUserDefinedConversion.\r\n            ":"\r\n            注意：将此方法与AnalysemeplicerDuserDefinedConversion保持同步。\r\n            \r\n","\r\n              Looks up a localized string similar to An expression of type '{0}' cannot be handled by a pattern of type '{1}'. Please use language version '{2}' or greater to match an open type with a constant pattern..\r\n            ":"\r\n              查找类似于“ {0}”类型的表达式的本地化字符串无法通过类型'{1}'的模式来处理。请使用语言版本'{2}或更高的内容与恒定模式匹配开放类型。\r\n            \r\n","\r\n            Returns true if the assembly attribute at the given index is a duplicate assembly attribute that must not be emitted.\r\n            Duplicate assembly attributes are attributes that bind to the same constructor and have identical arguments.\r\n            ":"\r\n            如果给定索引处的汇编属性是一个重复的汇编属性，则返回true。\r\n            重复的汇编属性是与同一构造函数结合并具有相同参数的属性。\r\n            \r\n","\r\n            Reports diagnostics and returns Conversion.NoConversion in case of missing runtime helpers.\r\n            ":"\r\n            报告诊断并返回转换。如果缺少运行时帮助者，则通知。\r\n            \r\n","\r\n              Looks up a localized string similar to This error occurs if you have an overloaded method that takes a jagged array and the only difference between the method signatures is the element type of the array. To avoid this error, consider using a rectangular array rather than a jagged array; use an additional parameter to disambiguate the function call; rename one or more of the overloaded methods; or, if CLS Compliance is not needed, remove the CLSCompliantAttribute attribute..\r\n            ":"\r\n              如果您有一个锯齿状数组的超载方法，则查找与此错误相似的本地化字符串，而方法签名之间的唯一区别是数组的元素类型。为避免此错误，请考虑使用矩形阵列而不是锯齿状阵列；使用附加参数来消除函数调用；重命名一个或多个超载方法；或者，如果不需要CLS合规性，请删除CLSCompliantAttribute属性。\r\n            \r\n","An out parameter cannot have the In attribute":"一个out参数不能具有in属性\r\n","\r\n              Looks up a localized string similar to Non-invocable member '{0}' cannot be used like a method..\r\n            ":"\r\n              查找类似于不可弹成员'{0}'的本地化字符串，不能像方法一样使用。\r\n            \r\n"," mismatch is detected during merging process for partial type declarations.\r\n            ":" 在合并部分声明过程中检测到不匹配。\r\n            \r\n","Type of conditional expression cannot be determined because there is no implicit conversion between '{0}' and '{1}'":"条件表达式的类型无法确定，因为“ {0}”和'{1}'之间没有隐含的转换\r\n","Async methods cannot have by-reference locals":"异步方法不能具有重复的当地人\r\n","\r\n            If this is a type parameter returns its effective base class, otherwise returns this type.\r\n            ":"\r\n            如果这是一个类型参数，则返回其有效基类，否则返回此类型。\r\n            \r\n","\r\n              Looks up a localized string similar to Overloadable binary operator expected.\r\n            ":"查找类似于预期的可超载二进制运算符的本地化字符串。\r\n            \r\n","\r\n            The candidate member was rejected because it is not supported by the language.\r\n            ":"\r\n            候选人成员被拒绝，因为该语言不支持该候选人。\r\n            \r\n","\r\n            reads a property; and ":"\r\n            阅读财产；和\r\n","Type of the receiver after applying the conversion.":"应用转换后的接收器类型。\r\n","\r\n              Looks up a localized string similar to Enums cannot contain explicit parameterless constructors.\r\n            ":"\r\n              查找类似于枚举的本地化字符串不能包含明确的无参数构造函数。\r\n            \r\n","\r\n            A structure used to lexically order symbols. For performance, it's important that this be \r\n            a STRUCTURE, and be able to be returned from a symbol without doing any additional allocations (even\r\n            if nothing is cached yet).\r\n            ":"\r\n            用于词汇订购符号的结构。为了表现，重要的是\r\n            结构，并且能够从符号中返回而无需进行任何其他分配（甚至\r\n            如果什么都没有缓存）。\r\n            \r\n","\r\n              Looks up a localized string similar to Command-line syntax error: Invalid Guid format '{0}' for option '{1}'.\r\n            ":"\r\n              查找类似于命令行语法错误的本地化字符串：无效的GUID格式'{0}'for Option'{1}'。\r\n            \r\n","\r\n            The underlying TypeParameterSymbol, cannot be another RetargetingTypeParameterSymbol.\r\n            ":"\r\n            底层甲板符号，不能是另一个retargetingtyparametersymbol。\r\n            \r\n","This method can only be used to create tokens - {0} is not a token kind.":"此方法只能用于创建令牌 -  {0}不是令牌类型。\r\n","\r\n            Return this union of this value set with another. Both must have been created with the same ":"\r\n            将此值的联合与另一个值返回。两者都必须以相同的方式创建\r\n"," was not created from CSharp code.":"不是由CSHARP代码创建的。\r\n","Attribute '{0}' is only valid on methods or attribute classes":"属性'{0}'仅在方法或属性类上有效\r\n","\r\n              Looks up a localized string similar to Since '{0}' is an async method that returns 'Task', a return keyword must not be followed by an object expression. Did you intend to return 'Task<T>'?.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串是返回“任务”的异步方法，返回关键字不得跟随对象表达式。您是否打算返回“任务<t>”？\r\n            \r\n","\r\n              Looks up a localized string similar to A member '{0}' marked as override cannot be marked as new or virtual.\r\n            ":"\r\n              查找类似于标记为替代的成员'{0}'的本地化字符串，不能标记为新的或虚拟的。\r\n            \r\n","'{0}' interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'":"'{0}'接口标记为“ coclassattribute”未标记为“ comimportattribute”\r\n","\r\n            Returns a new compilation with the given semantic model provider.\r\n            ":"\r\n            返回给定语义模型提供商的新汇编。\r\n            \r\n","\r\n              Looks up a localized string similar to Predefined type is defined in multiple assemblies in the global alias.\r\n            ":"\r\n              在全局别名的多个组件中定义了类似于预定义类型的本地化字符串。\r\n            \r\n","\r\n            All bits except those that are involved into describilng various nullability aspects.\r\n            ":"\r\n            除了描述各种无效方面的内容外，所有位。\r\n            \r\n","\r\n              Looks up a localized string similar to The managed coclass wrapper class '{0}' for interface '{1}' cannot be found (are you missing an assembly reference?).\r\n            ":"\r\n              查找类似于托管的Coclass包装器类'{0}'的本地化字符串，for Interface'{1}'找不到（您是否缺少汇编引用？）。\r\n            \r\n","This warning occurs if the assembly attributes AssemblyKeyFileAttribute or AssemblyKeyNameAttribute found in source conflict with the /keyfile or /keycontainer command line option or key file name or key container specified in the Project Properties.":"如果汇编属性assemblykeyfileattribute或source keynemeattribute在源与 /键文件或 /键file或 /键 /键命令命令行选项或键文件名称或项目属性中指定的密钥容器中发现，则会发生此警告。\r\n"," may be filtered out entirely\r\n            (by returning null).\r\n            ":" 可以完全过滤掉\r\n            （通过返回null）。\r\n            \r\n","\r\n              Looks up a localized string similar to Attribute constructor parameter '{0}' is optional, but no default parameter value was specified..\r\n            ":"\r\n              查找类似于属性constructor参数'{0}'的本地化字符串是可选的，但是未指定默认参数值。\r\n            \r\n","\r\n            Scope to which the local can \"escape\" via aliasing/ref assignment.\r\n            Not readonly because we can only know escape values after binding the initializer.\r\n            ":"\r\n            本地可以通过混叠/参考分配“逃脱”的范围。\r\n            不阅读，因为我们只能在绑定初始化器后才知道逃生值。\r\n            \r\n","Class which represents the syntax node for anonymous method expression.":"代表匿名方法表达式的语法节点的类。\r\n","SyntaxToken representing open parenthesis.":"语法代表开放括号。\r\n","\r\n              Looks up a localized string similar to Agnostic assembly cannot have a processor specific module '{0}'..\r\n            ":"\r\n              查找类似于不可知论组件的本地化字符串不能具有处理器特定模块'{0}'..\r\n            \r\n","\r\n            The command line arguments to a C# ":"命令行参数到C＃\r\n","Deconstructable2.Deconstruct(out int z1, out int z2)":"dentructable2.deconstruct（out int z1，out int z2）\r\n","\r\n            Creates the the syntax representation of an xml value element (e.g. for xml documentation comments).\r\n            ":"\r\n            创建XML值元素的语法表示（例如，用于XML文档注释）。\r\n            \r\n","Type of the syntax node.":"语法节点的类型。\r\n","\r\n              Looks up a localized string similar to /embed switch is only supported when emitting Portable PDB (/debug:portable or /debug:embedded)..\r\n            ":"\r\n              仅在发出便携式PDB时支持类似于 /嵌入开关的本地化字符串（ /debug：Portable或 /debug：嵌入式）。\r\n            \r\n","Called when the visitor visits a TypeArgumentListSyntax node.":"当访问者访问typeArgumentListsyntax节点时，请致电。\r\n","\r\n            Creates a syntax node for a cref attribute within a xml documentation comment.\r\n            ":"\r\n            在XML文档注释中为CREF属性创建语法节点。\r\n            \r\n","\r\n            Checks if 'symbol' is accessible from within assembly 'within'.\r\n            ":"\r\n            检查“符号”是否可以从汇编内“内部”内部访问。\r\n            \r\n","\r\n            Returns false because module can't be abstract.\r\n            ":"\r\n            返回错误，因为模块不能抽象。\r\n            \r\n","Creates a new FunctionPointerParameterSyntax instance.":"创建一个新的forcormpoInterParameterSyntax实例。\r\n","The container to search for symbols within. If null then the\r\n            enclosing declaration scope around position is used.":"要搜索内部符号的容器。如果无效，则\r\n            使用围绕位置的声明范围。\r\n","\r\n              Looks up a localized string similar to Parameter {0} must be declared with the '{1}' keyword.\r\n            ":"\r\n              查找类似于参数{0}的本地化字符串必须使用'{1}'关键字声明。\r\n            \r\n","\r\n            Nullable underlying type of left operand is used.\r\n            ":"\r\n            使用了无效的左操作类型的基础类型。\r\n            \r\n","\r\n            We will follow Dev10 in diverging from the C# 4 spec by ignoring string's \r\n            implementation of IEnumerable and just indexing into its characters.\r\n            \r\n            NOTE: We're assuming that sequence points have already been generated.\r\n            Otherwise, lowering to for-loops would generated spurious ones.\r\n            ":"\r\n            我们将遵循Dev10，通过忽略字符串来偏离C#4规范 \r\n            IEnumerable的实现，只是索引到它的字符。\r\n            \r\n            注意：我们假设序列点已经生成。\r\n            否则，降低到for循环会产生虚假的。\r\n            \r\n","Called when the visitor visits a ExpressionColonSyntax node.":"当访问者访问expressionColonsyntax节点时称呼。\r\n","Caller is responsible for freeing the ArrayBuilder":"呼叫者负责释放阵列布置器\r\n","\r\n            Used to determine whether it would be appropriate to use the binder for the switch section (if any).\r\n            Not used to determine whether the position is syntactically within the statement.\r\n            ":"\r\n            用于确定将粘合剂用于开关部分（如果有）是否合适。\r\n            不用于确定该位置是否在语句中句法。\r\n            \r\n","\r\n            Represents a primary module of a ":"\r\n            代表一个主要模块\r\n","\r\n            The type of the input at this branch of the decision tree.\r\n            ":"\r\n            决策树的该分支的输入类型。\r\n            \r\n","\r\n              Looks up a localized string similar to An add or remove accessor expected.\r\n            ":"\r\n              查找类似于添加或删除预期登录器的本地化字符串。\r\n            \r\n","\r\n            Returns true if this symbol represents a partial method implementation (the part that specifies both signature and body).\r\n            ":"\r\n            如果此符号代表部分方法实现（指定签名和主体的部分），则返回true。\r\n            \r\n","Cannot modify the return value of '{0}' because it is not a variable":"无法修改'{0}'的返回值，因为它不是变量\r\n","Cannot specify 'readonly' modifiers on both property or indexer '{0}' and its accessor. Remove one of them.":"无法在属性或索引器'{0}'及其登录器上指定“读取”修饰符。删除其中一个。\r\n","using variable":"使用变量\r\n","\r\n            Report an error if adding the edge (method1, method2) to the ctor-initializer\r\n            graph would add a new cycle to that graph.\r\n            ":"\r\n            如果将边缘（方法1，方法2）添加到CTOR-Initializer，报告错误\r\n            图将向该图添加一个新的周期。\r\n            \r\n"," but is not due to https://github.com/dotnet/roslyn/issues/36992 .\r\n            ":" 但不是由于https://github.com/dotnet/roslyn/issues/36992。\r\n            \r\n","\r\n            WARNING: Note that the collection class is not thread-safe and will \r\n            need to be revised if emit phase is changed to support multithreading when\r\n            translating a particular type.\r\n            ":"\r\n            警告：请注意，收集类不是线程安全的，将会\r\n            如果更改EMIT阶段以支持多线程，则需要修改\r\n            翻译特定类型。\r\n            \r\n","\r\n            The type is one of the simple types defined in Dev10 C#, see \"predeftype.h\"/simple\r\n            ":"\r\n            该类型是Dev10 C＃中定义的简单类型之一，请参见“ Predeftype.h”/Simple\r\n            \r\n","\r\n              Looks up a localized string similar to The CallerMemberNameAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments.\r\n            ":"\r\n              查找类似于应用于参数'{0}'的callermemberneattribute类似的本地化字符串将没有效果，因为它适用于不允许可选参数的上下文中使用的成员。\r\n            \r\n","\r\n            There is some similarity between this member and MemberSymbol.FindOverriddenOrHiddenMembersInType.\r\n            When making changes to this member, think about whether or not they should also be applied in MemberSymbol.\r\n            One key difference is that custom modifiers are considered when looking up overridden members, but\r\n            not when looking up implicit implementations.  We're preserving this behavior from Dev10.\r\n            ":"\r\n            该成员和成员符号之间有一些相似之处。\r\n            在更改该会员时，请考虑是否也应将其应用于会员符号。\r\n            一个关键区别是，在查找覆盖成员时会考虑自定义修饰符，但是\r\n            当查找隐式实现时而不是。我们正在从Dev10中保存这种行为。\r\n            \r\n","Called when the visitor visits a RecordDeclarationSyntax node.":"当访问者访问record -declarationsyntax节点时，请致电。\r\n","\r\n              Looks up a localized string similar to Cannot specify only Out attribute on a ref parameter. Use both In and Out attributes, or neither..\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法仅在REF参数上指定属性。使用内外属性，或者都不使用。\r\n            \r\n","The bound node.":"结合节点。\r\n","Called when the visitor visits a ErrorDirectiveTriviaSyntax node.":"当访问者访问错误的导管节点节点时调用。\r\n","\r\n              Looks up a localized string similar to Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first.\r\n            ":"\r\n              查找类似于签名操作数上使用的位置或操作员的本地化字符串；首先考虑铸造为较小的未签名类型。\r\n            \r\n","Both partial method declarations must use a params parameter or neither may use a params parameter":"两种部分方法声明必须使用参数，或者都不可以使用参数参数\r\n","\r\n            Gets an ExpressionSyntax that represents the condition of the if statement.\r\n            ":"\r\n            获取表示表示IF语句条件的表达式字母。\r\n            \r\n","Called when the visitor visits a LetClauseSyntax node.":"当访问者访问letclausesyntax节点时，请致电。\r\n","Warning level must be zero or greater":"警告水平必须为零或更高\r\n","\r\n              Looks up a localized string similar to The 'await' operator can only be used when contained within a method or lambda expression marked with the 'async' modifier.\r\n            ":"\r\n              查找类似于“等待”运算符的本地化字符串只有在用“ async”修饰符标记的方法或lambda表达式中包含时才能使用。\r\n            \r\n","Creates a new TypeParameterConstraintClauseSyntax instance.":"创建一个新的typeparameterconstraintclaisesyntax实例。\r\n","\r\n            True if the target runtime support covariant returns of methods declared in classes.\r\n            ":"\r\n            正确，如果目标运行时支持协方差返回类中声明的方法。\r\n            \r\n","\r\n            Get the earliest input of which the symbol is a member.\r\n            A BoundDagTypeEvaluation doesn't change the underlying object being pointed to.\r\n            So two evaluations act on the same input so long as they have the same original input.\r\n            We use this method to compute the original input for an evaluation.\r\n            ":"\r\n            获取最早的符号是成员的输入。\r\n            界限值不会改变所指向的基础对象。\r\n            因此，只要有相同的原始输入，两个评估就对相同的输入起作用。\r\n            我们使用此方法计算原始输入进行评估。\r\n            \r\n","Assembly reference is invalid and cannot be resolved":"组装参考无效，无法解决\r\n","Accessors '{0}' and '{1}' should both be init-only or neither":"登录器'{0}'和'{1}'既应该是初始或都不应\r\n","Method to inspect.":"检查方法。\r\n","The node to visit":"访问的节点\r\n","Diagnostic '{0}: {1}' was programmatically suppressed by a DiagnosticSuppressor with suppression ID '{2}' and justification '{3}'":"诊断'{0}：{1}'被带有抑制ID'{2}'and jusification'{3}'{3}'的Diagnosticsuppressor编程抑制\r\n","More types support the fixed statement":"更多类型支持固定语句\r\n"," we'll hold a Multiple with two elements.\r\n             The first element is a Single (describing the binary operator and conversions that are involved in ":" 我们将拥有一个具有两个元素的倍数。\r\n             第一个元素是单个元素（描述二进制操作员和所涉及的转换\r\n","\r\n            Receivers of struct methods are required to be at least RValues but can be assignable variables.\r\n            Whether the mutations from the method are propagated back to the \r\n            receiver instance is conditional on whether the receiver is a variable that can be assigned. \r\n            If not, then the invocation is performed on a copy.\r\n            \r\n            An inconvenient situation may arise when the receiver is an RValue expression (like a ternary operator),\r\n            which is trivially reduced during lowering to one of its operands and \r\n            such operand happens to be an assignable variable (like a local). That operation alone would \r\n            expose the operand to mutations while it would not be exposed otherwise.\r\n            I.E. the transformation becomes semantically observable.\r\n            \r\n            To prevent such situations, we will wrap the operand into a node whose only \r\n            purpose is to never be an assignable expression.\r\n            ":"\r\n            结构方法的接收器至少必须是rvalues，但可以是可分配的变量。\r\n            该方法的突变是否被传播回到\r\n            接收器实例是基于接收器是否是可以分配的变量。\r\n            如果不是，则调用是在副本上执行的。\r\n            \r\n            当接收器是rvalue表达式（如三元操作员）时，可能会出现不便的情况，\r\n            在降低到其操作数之一的过程中，它逐渐减少了\r\n            这样的操作数恰好是可分配的变量（例如本地）。单独的操作将\r\n            将操作数暴露于突变中，而否则不会暴露。\r\n            IE。在语义上可以观察到转换。\r\n            \r\n            为了防止这种情况，我们将操作数包装成一个节点\r\n            目的是永远不要成为可分配的表达式。\r\n            \r\n","\r\n            A region analysis walker that records jumps into the region.  Works by overriding NoteBranch, which is\r\n            invoked by a superclass when the two endpoints of a jump have been identified.\r\n            ":"\r\n            记录的区域分析步行者跳入该地区。通过覆盖笔记的作品，这是\r\n            当已经确定了跳跃的两个端点时，被超类引用。\r\n            \r\n","\r\n            True if the method calls another method containing security code (metadata flag RequiresSecurityObject is set).\r\n            ":"\r\n            正确，如果该方法调用另一个包含安全代码的方法（设置了Metadata flag sirporessecurityObject）。\r\n            \r\n","Cannot await 'void'":"不能等待“无效”\r\n","\r\n            Describes anonymous type in terms of fields\r\n            ":"\r\n            在字段中描述匿名类型\r\n            \r\n","\r\n            Represents an element-wise null/null comparison.\r\n            For instance, `(null, ...) == (null, ...)`.\r\n            ":"\r\n            表示元素的无效/空比较。\r\n            例如，`（null，...）==（null，...）`。\r\n            \r\n","Reference to undefined entity '{0}'.":"引用未定义的实体'{0}'。\r\n","Called when the visitor visits a ElementBindingExpressionSyntax node.":"当访问者访问元素bindingexpressyntax节点时调用。\r\n","\r\n            Creates an AttributeSemanticModel that allows asking semantic questions about an attribute node.\r\n            ":"\r\n            创建一个属性emanticmodel，允许询问有关属性节点的语义问题。\r\n            \r\n","\r\n              Looks up a localized string similar to The type '{2}' must be a reference type in order to use it as parameter '{1}' in the generic type or method '{0}'.\r\n            ":"\r\n              查找类似于“ {2}”类型的本地化字符串必须是参考类型，以便将其用作通用类型或方法'{0}'中的参数'{1}'。\r\n            \r\n","Gets the type of the tuple element.":"获取元组元素的类型。\r\n","async main":"异步主\r\n","Argument cannot be used for parameter due to differences in the nullability of reference types.":"由于参考类型的可取性差异，参数不能用于参数。\r\n","\r\n            Gets already declared and initialized local.\r\n            ":"\r\n            已被声明并初始化本地化。\r\n            \r\n",", but distinguishes between ":"，但区分\r\n","\r\n            Hit every iteration.\r\n            ":"\r\n            命中每一次迭代。\r\n            \r\n","\r\n            Build the decision dag, giving an error if some cases are subsumed and a warning if the switch expression is not exhaustive.\r\n            ":"\r\n            构建决策DAG，如果某些情况被包含在某些情况下，如果开关表达式并不详尽，则会出现错误。\r\n            \r\n","\r\n            Get locals declared immediately in scope represented by the node.\r\n            ":"\r\n            立即在节点代表的范围中宣布当地人。\r\n            \r\n","Class which represents the syntax node for initializer expression.":"代表初始化器表达式语法节点的类。\r\n"," will use the member symbol rather\r\n            than looking up the member in the containing type, allowing this method to be called\r\n            while calculating the member list.\r\n            ":" 将使用成员符号而不是\r\n            比在包含类型中查找成员，允许调用此方法\r\n            在计算成员列表的同时。\r\n            \r\n","\r\n              Looks up a localized string similar to Public signing was specified and requires a public key, but no public key was specified..\r\n            ":"\r\n              指定了一个与公共签名类似的本地字符串，并需要一个公钥，但没有指定公共密钥。\r\n            \r\n","\r\n            newPosition represents the position we are in the final SourceText.  As we consume and reuse\r\n            nodes from the old tree we will update our position in the new text accordingly.\r\n            Likewise, when we must lex tokens out of the new tree we will update as well.\r\n            \r\n            NOTE(cyrusn): We do not need an oldPosition because it is redundant given the\r\n            oldTreeCursor.  The oldPosition is implicitly defined by the position of the cursor.\r\n            ":"\r\n            newPosition代表我们在最终源中的位置。当我们消费和重复使用时\r\n            从旧树节点的节点我们将相应地在新文本中更新我们的位置。\r\n            同样，当我们必须从新树中删除令牌时，我们也将更新。\r\n            \r\n            注意（Cyrusn）：我们不需要旧位置，因为它是多余的\r\n            老人。旧位置是由光标的位置隐式定义的。\r\n            \r\n","SyntaxToken representing close parenthesis.":"Syntaxtkoken代表亲密的括号。\r\n","\r\n            Implicit boxing conversions are described in section 6.1.7 of the C# language specification.\r\n            ":"\r\n            隐式拳击转换在C＃语言规范的第6.1.7节中描述。\r\n            \r\n","Null-propagating operator ?.":"null传播操作员？\r\n","\r\n            Create symbols for nested types and initialize types map.\r\n            ":"为嵌套类型创建符号并初始化类型地图。\r\n            \r\n","Called when the visitor visits a GenericNameSyntax node.":"当访问者访问通用名单上的节点时调用。\r\n","Operator '{0}' is ambiguous on an operand of type '{1}'":"运算符'{0}'在类型'{1}'的操作数上模棱两可\r\n","Provided documentation mode is unsupported or invalid: '{0}'.":"提供的文档模式不支持或无效：'{0}'。\r\n","\r\n            Represents the state of compilation of one particular type.\r\n            This includes, for example, a collection of synthesized methods created during lowering. \r\n            ":"\r\n            代表一种特定类型的汇编状态。\r\n            例如，其中包括在降低过程中创建的合成方法的集合。\r\n            \r\n","Error reading file '{0}' specified for the named argument '{1}' for PermissionSet attribute: '{2}'":"错误读取文件'{0}'为命名参数'{1}'为permissionset属性：'{2}'\r\n","\r\n            Get the syntax node(s) where this symbol was declared in source. Some symbols (for\r\n            example, partial classes) may be defined in more than one location. This property should\r\n            return one or more syntax nodes only if the symbol was declared in source code and also\r\n            was not implicitly declared (see the ":"\r\n            获取在源中声明此符号的语法节点。一些符号（用于\r\n            例如，部分类）可以在多个位置定义。该属性应该\r\n            仅在源代码中声明符号以及\r\n            不是隐式宣布的（请参阅\r\n","\r\n              Looks up a localized string similar to Iterators cannot have ref or out parameters.\r\n            ":"\r\n              查找类似于迭代器的本地化字符串，无法具有参数或输出参数。\r\n            \r\n","Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead.":"请勿使用'system.runtime.compilerServices.fixedBuffer'属性。改用“固定”字段修饰符。\r\n","\r\n              Looks up a localized string similar to Interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'.\r\n            ":"\r\n              查找类似于标记为“ CoclassAttribute”的界面的本地化字符串，未标记为“ ComimportAttribute”。\r\n            \r\n","label":"标签\r\n","\r\n            The process of looking up an implementation for an accessor can involve figuring out how corresponding event/property is implemented,\r\n            ":"\r\n            查找访问者实现的过程可能涉及弄清楚如何实施相应的事件/属性，\r\n            \r\n"," \r\n            Returns a unification use-site error (if any) for a symbol contained in this module \r\n            that is referring to a specified ":" \r\n            返回本模块中包含的符号的统一用途错误（如果有）\r\n            这是指定的\r\n","\r\n              Looks up a localized string similar to The given expression cannot be used in a fixed statement.\r\n            ":"\r\n              在固定语句中查找类似于给定表达式的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to 'await' cannot be used as an identifier within an async method or lambda expression.\r\n            ":"\r\n              查找类似于“等待”的本地化字符串不能用作异步方法或lambda表达式中的标识符。\r\n            \r\n","Conversion to be applied to the receiver if not calling an interface method on a struct.":"如果不调用结构上的接口方法，则将转换应用于接收器。\r\n"," that controls the behavior of the created driver.":" 控制创建驱动程序的行为。\r\n","SecurityAction value '{0}' is invalid for security attributes applied to an assembly":"SecurityAction值'{0}'是应用于汇编的安全属性的无效\r\n","\r\n              Looks up a localized string similar to Linked netmodule metadata must provide a full PE image: '{0}'..\r\n            ":"\r\n              查找类似于链接的NetModule元数据的本地化字符串必须提供完整的PE映像：'{0}'..\r\n            \r\n","\r\n            Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.\r\n            ":"\r\n            给定匿名对象创建初始化器的语法节点，获取匿名对象属性符号。\r\n            \r\n","Inconsistent accessibility: parameter type '{1}' is less accessible than method '{0}'":"不一致的可访问性：参数类型'{1}'比方法'{0}'不太访问\r\n","\r\n              Looks up a localized string similar to In order for '{0}' to be applicable as a short circuit operator, its declaring type '{1}' must define operator true and operator false.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串作为短路运算符，其声明类型'{1}'必须定义运算符true和operator false。\r\n            \r\n","\r\n            A cache of members per type, populated when the first member for a given\r\n            type is needed. Within each type, members are indexed by name. The reason\r\n            for caching, and indexing by name, is to avoid searching sequentially\r\n            through all members of a given kind each time a member is matched.\r\n            ":"\r\n            每种类型的成员缓存，在给定的第一个成员时填充\r\n            需要类型。在每种类型中，成员按名称索引。原因\r\n            用于缓存和按名称索引，是为了避免顺序搜索\r\n            每次匹配成员时，通过给定的所有成员。\r\n            \r\n","\r\n              Looks up a localized string similar to Type or namespace definition, or end-of-file expected.\r\n            ":"\r\n              查找类似于类型或名称空间定义的本地化字符串，或预期的文件终止。\r\n            \r\n","Invalid signature public key specified in AssemblySignatureKeyAttribute.":"无效的签名公共密钥在“汇编”中指定的keyaTtribute中指定。\r\n","Asynchronous foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation":"异步语句无法在类型'{0}'的变量上操作，因为它实现了'{1}'的多个实例;尝试铸造特定的接口实例化\r\n","\r\n            Remove candidates to a delegate conversion where the method's return ref kind or return type is wrong.\r\n            ":"\r\n            将候选人删除到委托转换的情况下，其中方法的返回ref类或退货类型是错误的。\r\n            \r\n","\r\n              Looks up a localized string similar to Members of {0} '{1}' cannot be returned by writable reference because it is a readonly variable.\r\n            ":"\r\n              查找类似于{0}'{1}'成员的本地化字符串，因为它是一个可读的变量，因此无法通过Writable Reference返回。\r\n            \r\n","The syntax node to which generated code should be attributed":"应归因于生成代码的语法节点\r\n","Called when the visitor visits a SelectClauseSyntax node.":"当访问者访问SelectClausesyntax节点时，请致电。\r\n","Specified language version '{0}' cannot have leading zeroes":"指定的语言版本'{0}'不能具有引导零\r\n","\r\n              Looks up a localized string similar to Program does not contain a static 'Main' method suitable for an entry point.\r\n            ":"\r\n              查找类似于程序的本地化字符串不包含适合入口点的静态“主”方法。\r\n            \r\n","'{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context":"'{0}'没有预定义的大小，因此只能在不安全的上下文中使用大小\r\n","\r\n              Looks up a localized string similar to A static readonly field cannot be returned by reference.\r\n            ":"\r\n              查找类似于静态可读字段的本地化字符串，无法通过参考返回。\r\n            \r\n","\r\n            The absolute position of the start of the current lexeme in the given\r\n            SourceText.\r\n            ":"\r\n            当前词汇开始时的绝对位置\r\n            SourceText。\r\n            \r\n","The second operand of an 'is' or 'as' operator may not be static type '{0}'":"AN“ IS”或“ AS”操作数的第二操作数可能不是静态类型'{0}'\r\n","\r\n            Optionally escapes non-printable characters.\r\n            ":"\r\n            可选地逃脱了不可打印的字符。\r\n            \r\n","The body of '{0}' cannot be an iterator block because '{1}' is not an iterator interface type":"'{0}'的主体不能是迭代器块，因为'{1}'不是迭代器接口类型\r\n"," chain, and the ":" 链条和\r\n","Called when the visitor visits a OmittedArraySizeExpressionSyntax node.":"当访问者访问省略的artiteRaysizeexpressionsyntax节点时，请致电。\r\n","\r\n            State machine interface property implementation.\r\n            ":"\r\n            状态计算机接口属性实现。\r\n            \r\n","\r\n              Looks up a localized string similar to Anonymous function converted to a void returning delegate cannot return a value.\r\n            ":"\r\n              查找类似于匿名函数转换为void返回委托的本地化字符串无法返回值。\r\n            \r\n","A reference to a well-known member type descriptor. Note however that the type in that descriptor is ignored here.":"对知名会员类型描述符的引用。但是请注意，此处描述符中的类型在这里被忽略。\r\n","\r\n            The NamedTypeSymbol for the .NET System.Object type, which could have a TypeKind of\r\n            Error if there was no COR Library in this Compilation.\r\n            ":"\r\n            .net system.Object类型的命名typeymbol\r\n            错误，如果此汇编中没有COR库。\r\n            \r\n","Constructor '{0}' is marked external":"构造函数'{0}'被标记为外部\r\n","Cannot reference 'System.Runtime.CompilerServices.TupleElementNamesAttribute' explicitly. Use the tuple syntax to define tuple names.":"无法引用'system.runtime.compilerservices.tupleelementnamesattribute'。使用元组语法定义元组名称。\r\n","\r\n            Report the error from member access lookup. Or, if there\r\n            was no explicit error from lookup, report \"no such member\".\r\n            ":"\r\n            报告会员访问查找中的错误。或者，如果那里\r\n            查找没有明确的错误，报告“没有这样的成员”。\r\n            \r\n","\r\n              Looks up a localized string similar to The contextual keyword 'var' may only appear within a local variable declaration or in script code.\r\n            ":"\r\n              查找类似于上下文关键字“ var”的本地化字符串可能仅在本地变量声明或脚本代码中出现。\r\n            \r\n","\r\n            Given a foreach statement, get the symbol for the iteration variable\r\n            ":"给定一个foreach语句，获取迭代变量的符号\r\n            \r\n","\r\n            Definitely a type name: either a predefined type (int, string, etc.) or an array\r\n            type (ending with a [] brackets), or a pointer type (ending with *s).\r\n            ":"\r\n            绝对是类型名称：预定义的类型（INT，String等）或数组\r\n            类型（以[]括号结尾）或指针类型（以 *s结尾）。\r\n            \r\n","\r\n            SZArray is an array type encoded in metadata with ELEMENT_TYPE_SZARRAY (always single-dim array with 0 lower bound).\r\n            Non-SZArray type is encoded in metadata with ELEMENT_TYPE_ARRAY and with optional sizes and lower bounds. Even though \r\n            non-SZArray can also be a single-dim array with 0 lower bound, the encoding of these types in metadata is distinct.\r\n            ":"\r\n            szarray是一种数组类型，用element_type_szarray在元数据中编码（始终具有单个dim数组，带有0下限）。\r\n            非szarray类型用element_type_array编码在元数据中，并具有可选的大小和下限。虽然\r\n            非szarray也可以是具有0下限的单DIM阵列，元数据中这些类型的编码是不同的。\r\n            \r\n","A builder to which the label and binding assignments are added":"添加标签和绑定作业的构建器\r\n","\r\n            If this is a tuple type with element names, returns the symbol for the tuple type without names.\r\n            Otherwise, returns null.\r\n            ":"\r\n            如果这是带有元素名称的元组类型，请返回没有名称的元组类型的符号。\r\n            否则，返回null。\r\n            \r\n","\r\n            Returns the better type amongst the two, with some possible modifications (dynamic/object or tuple names).\r\n            ":"\r\n            返回两者之间的更好类型，并进行一些可能的修改（动态/对象或元组名称）。\r\n            \r\n"," type supports retrieving the this parameter\r\n            and false otherwise.  Note that a return value of true does not guarantee a non-null\r\n            ":" 类型支持检索此参数\r\n            否则为错误。请注意，true的返回值不能保证非编号\r\n            \r\n","An out parameter must be assigned to before control leaves the method":"在控制离开方法之前，必须将OUT参数分配给\r\n","\r\n            See Type::computeManagedType.\r\n            ":"\r\n            请参阅类型::computeManagedType。\r\n            \r\n","ExpressionSyntax node representing the expression on the left of the range operator.":"ExpressionSyntax节点表示范围运算符左侧的表达式。\r\n","\r\n            Emits address of a temp.\r\n            Used in cases where taking address directly is not possible \r\n            (typically because expression does not have a home)\r\n            \r\n            Introduce a temp which it will return.\r\n            ":"\r\n            发出温度的地址。\r\n            在不可能直接进行地址的情况下使用\r\n            （通常是因为表达没有家）\r\n            \r\n            引入一个将返回的温度。\r\n            \r\n","\r\n            Get a source location key for sorting. For performance, it's important that this\r\n            be able to be returned from a symbol without doing any additional allocations (even\r\n            if nothing is cached yet.)\r\n            ":"\r\n            获取用于分类的源位置密钥。为了表现，重要的是\r\n            能够从符号中返回而无需进行任何其他分配（甚至\r\n            如果什么都没有缓存。）\r\n            \r\n","Class representing one or more attributes applied to a language construct.":"代表应用于语言构造的一个或多个属性的类。\r\n","Use of possibly unassigned field":"使用可能未分配的领域\r\n","SyntaxToken representing the kind \"await\" keyword.":"Syntaxtoken代表“等待”关键字。\r\n","\r\n            Returns true if the specified local/parameter needs to be hoisted to a field.\r\n            Variable may be hoisted even if it is not captured, to improve debugging experience.\r\n            ":"\r\n            如果需要将指定的本地/参数吊到字段，则返回true。\r\n            即使没有被捕获，也可能会悬挂变量，以改善调试经验。\r\n            \r\n","\r\n              Looks up a localized string similar to static classes.\r\n            ":"\r\n              查找类似于静态类的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' cannot declare a body because it is marked abstract.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串无法声明主体，因为它被标记为抽象。\r\n            \r\n","Indicates that only early decoding should be performed.  WARNING: the resulting bag will not be sealed.":"表明仅应进行早期解码。警告：将不会密封的袋子。\r\n","Slot allocator.":"插槽分配器。\r\n","Creates a new EndIfDirectiveTriviaSyntax instance.":"创建一个新的EndifirectivetriviaSyntax实例。\r\n","\r\n              Looks up a localized string similar to Outputs without source must have the /out option specified.\r\n            ":"\r\n              查找类似于没有源的输出的本地化字符串必须具有指定 /OUT选项。\r\n            \r\n","Expected catch or finally":"预期捕获或最后\r\n","Nullability of reference types in return type doesn't match implicitly implemented member (possibly because of nullability attributes).":"返回类型中参考类型的无效性不匹配隐式实现的成员（可能是由于无效属性）。\r\n","\r\n              Looks up a localized string similar to Cannot pass fields of '{0}' as a ref or out argument because it is a '{1}'.\r\n            ":"\r\n              查找类似于'{0}'的字段作为参考或参数，因为它是'{1}'。\r\n            \r\n","Do not use refout when using refonly.":"重新使用时请勿使用refout。\r\n","Creates a new ErrorDirectiveTriviaSyntax instance.":"创建一个新的errordirectivetriviasyntax实例。\r\n","\r\n            Intended behavior: this property, P, explicitly implements an interface property, IP, \r\n            if any of the following is true:\r\n            \r\n            1) P.get explicitly implements IP.get and P.set explicitly implements IP.set\r\n            2) P.get explicitly implements IP.get and there is no IP.set\r\n            3) P.set explicitly implements IP.set and there is no IP.get\r\n            \r\n            Extra or missing accessors will not result in errors, P will simply not report that\r\n            it explicitly implements IP.\r\n            ":"\r\n            预期行为：此属性，P，明确实现接口属性，IP，\r\n            如果以下任何一个是正确的：\r\n            \r\n            1）P.GET明确实施IP。\r\n            2）P.GET明确实现IP。\r\n            3）P.SET明确实现IP.SET且没有IP。\r\n            \r\n            额外或缺失的登录器不会导致错误，P根本不会报告\r\n            它明确实现了IP。\r\n            \r\n","nullable reference types":"无效的参考类型\r\n","s \r\n            and ":"s\r\n            和\r\n"," and is a representation of a finite state automaton that performs a\r\n            sequence of binary tests. Each node is represented by a ":" 并且是执行有限状态自动机的表示\r\n            二进制测试序列。每个节点由\r\n","SimpleNameSyntax node representing the member being accessed.":"SimpleNamesyntax节点表示要访问的成员。\r\n","\r\n              Looks up a localized string similar to The contextual keyword 'var' cannot be used in a range variable declaration.\r\n            ":"\r\n              查找类似于上下文关键字“ var”的本地化字符串，不能在范围变量声明中使用。\r\n            \r\n","\r\n            Returns the expression without the top-most conversion plus the conversion.\r\n            If the expression is not a conversion, returns the original expression plus\r\n            the Identity conversion. If `includeExplicitConversions` is true, implicit and\r\n            explicit conversions are considered. If `includeExplicitConversions` is false\r\n            only implicit conversions are considered and if the expression is an explicit\r\n            conversion, the expression is returned as is, with the Identity conversion.\r\n            (Currently, the only visit method that passes `includeExplicitConversions: true`\r\n            is VisitConversion. All other callers are handling implicit conversions only.)\r\n            ":"\r\n            返回表达式，没有最高转换以及转换。\r\n            如果表达式不是转换，请返回原始表达式加上\r\n            身份转换。如果“ incressexplicricter”是真实的，则隐式和\r\n            考虑明确的转换。如果`incressexplicricerversions'是false\r\n            仅考虑隐式转换，如果表达式是明确的\r\n            转换，表达式按原样返回，具有身份转换。\r\n            （目前，唯一传递`includeexplicricerversions：true“ true”的访问方法\r\n            是visitconversion。所有其他呼叫者仅处理隐式转换。）\r\n            \r\n","\r\n              Looks up a localized string similar to An expression tree may not contain an anonymous method expression.\r\n            ":"\r\n              查找类似于表达树的本地化字符串可能不包含匿名方法表达式。\r\n            \r\n","\r\n            Creates a SemanticModel for a constructor initializer (\": base-class(...)\").\r\n            ":"\r\n            为构造函数初始化器（“：base-class（...）”创建semanticmodel。\r\n            \r\n","\r\n            Returns true if a finally of the given try contains awaits\r\n            ":"\r\n            如果给定的尝试最终包含等待\r\n            \r\n","Creates a new DocumentationCommentTriviaSyntax instance.":"创建一个新的DocumentationCommentTriviaSyntax实例。\r\n","Referenced assembly targets a different processor":"引用的组件针对不同的处理器\r\n","\r\n            Note that for namespace symbol, the declaring syntax might be declaring a nested\r\n            namespace. For example, the declaring syntax node for N1 in \"namespace N1.N2 {...}\" is\r\n            the entire ":"\r\n            请注意，对于命名空间符号，声明的语法可能正在声明嵌套\r\n            名称空间。例如，“命名空间N1.n2 {...}”中的N1的声明语法节点是\r\n            整个\r\n","\r\n            Distinguish from ":"\r\n            区别于 \r\n","The delegate '{0}' does not have a parameter named '{1}'":"委托'{0}'没有名为'{1}'的参数\r\n"," if attribute arguments haven't been decoded yet.\r\n            ":" 如果属性参数尚未解码。\r\n            \r\n","using X = System.Runtime.CompilerServices.TypeForwardedToAttribute":"使用x = system.runtime.compilerservices.typeforwarddoattrobute\r\n","\r\n            Expression is returned by an ordinary r/w reference.\r\n            Same as RefOrOut. The difference is just for error reporting.\r\n            ":"\r\n            表达式通过普通的R/W参考返回。\r\n            与翻新相同。区别仅用于错误报告。\r\n            \r\n","\r\n                using (var localVariable = new StreamReader(\"C:\\\\Temp\\\\MyFile.txt\")) { ... } \r\n            ":"\r\n                使用（var localvariable = new streamReader（“ c：\\\\ temp \\\\ myfile.txt”））{...}\r\n            \r\n","Cannot use '{0}' as a ref or out value because it is a '{1}'":"不能将'{0}'用作ref或淘汰价值，因为它是'{1}'\r\n","\r\n            The method whose body is being analyzed, or the field whose initializer is being analyzed.\r\n            It is used for\r\n            references to method parameters. Thus, 'member' should not be used directly, but\r\n            'MethodParameters', 'MethodThisParameter' and 'AnalyzeOutParameters(...)' should be used\r\n            instead.\r\n            ":"\r\n            正在分析其身体的方法或正在分析初始化器的领域。\r\n            它用于\r\n            参考参数。因此，不应直接使用“成员”，而应\r\n            应使用“方法参数”，“方法thisparameter”和“ AnalyzeOutParameters（...）”\r\n            反而。\r\n            \r\n","'{0}' explicit method implementation cannot implement '{1}' because it is an accessor":"'{0}'显式方法实现无法实现'{1}'，因为它是访问者\r\n","ref and out are not valid in this context":"在这种情况下，参考和外出无效\r\n","\r\n            A list of xml node syntax that will be the content within the xml documentation comment\r\n            (e.g. a summary element, a returns element, exception element and so on).\r\n            ":"\r\n            XML节点语法列表，该语法将是XML文档注释中的内容\r\n            （例如，摘要元素，返回元素，异常元素等）。\r\n            \r\n","Null-coalescing assignment":"零污染分配\r\n","\r\n            Locate implementation of the ":"\r\n            查找实施\r\n","\r\n            Find the parent ":"\r\n            找到父母\r\n","\r\n            This inspection is entirely syntactic.  We are not trying to find the alias corresponding to the assembly symbol\r\n            containing the explicitly implemented interface symbol - there may be more than one.  We just want to know\r\n            how the name was qualified in source so that we can make a similar qualification (for uniqueness purposes).\r\n            ":"\r\n            这种检查完全是句法。我们没有试图找到与汇编符号相对应的别名\r\n            包含明确实现的接口符号 - 可能有多个。我们只想知道\r\n            该名称的资格如何，以便我们可以制定类似的资格（出于独特目的）。\r\n            \r\n","\r\n            Data recorded for a particular analysis run.\r\n            ":"\r\n            为特定分析运行记录的数据。\r\n            \r\n","\r\n              Looks up a localized string similar to The name '{0}' does not identify tuple element '{1}'..\r\n            ":"\r\n              查找类似于名称'{0}'的本地化字符串，不识别元组元素'{1}'..\r\n            \r\n","\r\n              Looks up a localized string similar to New protected member declared in sealed class.\r\n            ":"\r\n              查找类似于密封类中声明的新受保护成员的局部字符串。\r\n            \r\n","\r\n            It is rare but possible for a source expression to be convertible to a destination type\r\n            by both an implicit user-defined conversion and a built-in explicit conversion.\r\n            In that circumstance, this method classifies the conversion as the implicit conversion or explicit depending on \"forCast\"\r\n            ":"\r\n            很少有源表达式可转换为目的地类型\r\n            通过隐式用户定义的转换和内置的显式转换。\r\n            在这种情况下，此方法将转换归类为隐式转换或明确取决于“预播”\r\n            \r\n","\r\n            A conversions object that ignores nullability.\r\n            ":"\r\n            忽略无效性的转换对象。\r\n            \r\n","\r\n              Looks up a localized string similar to /platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe.\r\n            ":"\r\n              查找类似于 /平台的局部字符串：Anycpu32bitPrefred仅适用于 /t：exe， /t：winexe和 /t：appContainerexe。\r\n            \r\n","\r\n            Declaration location for this tuple type symbol\r\n            ":"\r\n            此元组类型符号的声明位置\r\n            \r\n","\r\n            This rewriter assumes that it will be run before decimal rewriting (so that it does not have\r\n            to lower decimal constants and operations) and call rewriting (so that it does not have to\r\n            lower property accesses).\r\n            ":"\r\n            该重写者认为它将在小数重写之前运行（因此\r\n            降低小数常数和操作）并调用重写（因此不必\r\n            较低的属性访问）。\r\n            \r\n","\r\n              Looks up a localized string similar to Feature '{0}' is only available in 'experimental' language version..\r\n            ":"\r\n              查找类似于功能“ {0}”的本地化字符串仅在“实验”语言版本中可用。\r\n            \r\n","\r\n              Looks up a localized string similar to Partial methods must have a void return type.\r\n            ":"\r\n              查找类似于部分方法的本地化字符串必须具有无效返回类型。\r\n            \r\n","\r\n            Returns true if the type is constructed from a generic type named \"System.Linq.Expressions.Expression\"\r\n            with one type parameter, or if the type is a non-generic type named \"System.Linq.Expressions.Expression\"\r\n            or \"System.Linq.Expressions.LambdaExpression\".\r\n            ":"\r\n            如果类型是从名为“ System.linq.expressions.expression”的通用类型构造的，则返回true。\r\n            使用一种类型的参数，或者该类型是一种非类型类型，名为“ System.linq.expressions.expression”\r\n            或“ system.linq.expressions.lambdaexpression”。\r\n            \r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 3.  Please use language version {1} or greater..\r\n            ":"\r\n              查找类似于功能'{0}'的本地化字符串。\r\n            \r\n","\r\n            Returns one of the methods from the method group if all methods in the method group\r\n            have the same signature, ignoring parameter names and custom modifiers. The particular\r\n            method returned is not important since the caller is interested in the signature only.\r\n            ":"\r\n            如果方法组中的所有方法，则返回方法组中的一种方法\r\n            具有相同的签名，忽略参数名称和自定义修饰符。特殊\r\n            返回的方法并不重要，因为呼叫者仅对签名感兴趣。\r\n            \r\n"," = true does not imply that ":" = true并不意味着\r\n","\r\n            Takes an expression and returns the bound local expression \"temp\"\r\n            and the bound assignment expression \"temp = expr\".\r\n            ":"\r\n            采用表达式并返回绑定的局部表达式“ temp”\r\n            和绑定的分配表达式“ temp = expr”。\r\n            \r\n","An expression tree may not contain a dynamic operation":"表达树可能不包含动态操作\r\n","The type '{0}' is defined in a module that has not been added. You must add the module '{1}'.":"类型“ {0}”是在尚未添加的模块中定义的。您必须添加模块'{1}'。\r\n","\r\n            Assembly version pattern with wildcards represented by ":"\r\n            带有通配符的装配版本模式\r\n","\r\n            A set of all the names of the members in this type.\r\n            We can get names without getting members (which is a more expensive operation)\r\n            ":"\r\n            此类型中成员的所有名称的一组。\r\n            我们可以在没有成员的情况下获取名字（这是一个更昂贵的操作）\r\n            \r\n","\r\n              Looks up a localized string similar to <path list>.\r\n            ":"\r\n              查找类似于<路径列表>的本地化字符串。\r\n            \r\n","\r\n            Constructor to be used for region analysis, for which a struct type should never be considered empty.\r\n            ":"\r\n            用于区域分析的构造函数，不应将结构类型视为空。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': cannot specify both a constraint class and the 'class' or 'struct' constraint.\r\n            ":"\r\n              查找类似于“ {0}'：不能指定约束类别和“类”或“ struct”约束的本地化字符串。\r\n            \r\n","\r\n             For instance, a method returning a tuple\r\n             \r\n             ":"\r\n             例如，返回元组的方法\r\n             \r\n             \r\n","\r\n              Looks up a localized string similar to Dynamically dispatched call may fail at runtime because one or more applicable overloads are conditional methods.\r\n            ":"\r\n              查找类似于动态调用的呼叫的本地化字符串在运行时可能会失败，因为一个或多个适用的过载是条件方法。\r\n            \r\n"," are computed (for example to merge states), they must be cleared and recomputed,\r\n            as the set of possible values can affect successor states.\r\n            A ":" 计算（例如合并状态），必须清除和重新计算它们，\r\n            由于可能的值集可以影响后继状态。\r\n            一个\r\n","\r\n              Looks up a localized string similar to Invalid search path specified.\r\n            ":"\r\n              查找类似于指定的无效搜索路径的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Methods cannot combine block bodies with expression bodies..\r\n            ":"\r\n              查找类似于方法的局部字符串无法将块体与表达式结合在一起。\r\n            \r\n","\r\n            If set to true, a documentation comment exterior token will be added to the trailing trivia\r\n            of the new token.":"\r\n            如果设置为true，则文档评论外观令牌将添加到the the Trivia\r\n            新令牌。\r\n","\r\n            Given a type ":"\r\n            给定类型\r\n","Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor methods '{1}' or '{2}'":"该语言不支持属性，索引或事件“ {0}”；尝试直接调用登录器方法'{1}'或'{2}'\r\n","Creates a new SimpleLambdaExpressionSyntax instance.":"创建一个新的SimpleLambdaexpressynntax实例。\r\n","\r\n            Type parameter has no type constraints, including `struct`, `class`, `unmanaged` and is declared in a context \r\n            where nullable annotations are disabled.\r\n            Cannot be combined with ":"\r\n            类型参数没有类型的约束，包括``struct'，class`，````''''，并在上下文中声明\r\n            禁用无效注释的地方。\r\n            不能与\r\n","The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.":"'{0}'in'{2}'中的命名空间'{1}'与导入的类型'{3}'冲突。使用“ {0}”中定义的名称空间。\r\n","\r\n            Find any deconstruction locals that are still pending inference and fail their inference.\r\n            ":"\r\n            找到仍在推论并失败推理的任何解构当地人。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot return local '{0}' by reference because it is not a ref local.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法通过引用返回本地'{0}'，因为它不是ref local。\r\n            \r\n","Creates a new DiscardDesignationSyntax instance.":"创建一个新的doverdesignationsyntax实例。\r\n","\r\n            Scan past the hole inside an interpolated string literal, leaving the current character on the '}' (if any)\r\n            ":"\r\n            扫描经过插值字符串字面的孔，将当前字符留在“}”上（如果有）\r\n            \r\n","List of parts of the interpolated string, each one is either a literal part or an interpolation.":"插值字符串的一部分列表，每个弦乐是字面零件或插值。\r\n","\r\n            The member that we consider to be overridden (may have different custom modifiers from the overriding member).\r\n            Assumed to already be in the overridden and runtime overridden lists.\r\n            ":"\r\n            我们认为被覆盖的成员（可能与覆盖成员具有不同的自定义修饰符）。\r\n            假定已经在覆盖和运行时覆盖列表中。\r\n            \r\n","You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly":"您无法在模块上指定与汇编上的ClScompliant属性不同的模块上的ClScompliant属性\r\n","\r\n            Gets the set of interfaces to emit on this type. This set can be different from the set returned by Interfaces property.\r\n            ":"\r\n            获取在此类型上发射的一组接口。该集合可能与Interfaces属性返回的集合不同。\r\n            \r\n","Target-typed new expressions":"目标类型的新表达式\r\n","This error occurs if you have an overloaded method that takes a jagged array and the only difference between the method signatures is the element type of the array. To avoid this error, consider using a rectangular array rather than a jagged array; use an  ...":"如果您有一个锯齿状数组的超载方法，则会发生此错误，而方法签名之间的唯一区别是数组的元素类型。为避免此错误，请考虑使用矩形阵列而不是锯齿状阵列；使用...\r\n","\r\n            Called when visiting an ":"\r\n            拜访\r\n","\r\n              Looks up a localized string similar to Cannot return {0} '{1}' by writable reference because it is a readonly variable.\r\n            ":"\r\n              查找类似于与可读引用的本地化字符串无法返回{0}'{1}'，因为它是一个可读的变量。\r\n            \r\n","\r\n            Lower \"[await] using var x = (expression)\" to a try-finally block.\r\n            ":"较低的“ [等待]使用var x =（expression）”到一个尝试块。\r\n            \r\n","\r\n            Calls are conditionally omitted if both the following requirements are true:\r\n             (a) IsConditional == true, i.e. it has at least one applied/inherited conditional attribute AND\r\n             (b) None of conditional symbols corresponding to these conditional attributes are defined in the given syntaxTree.\r\n            ":"\r\n            如果以下两个要求正确，则有条件省略呼叫：\r\n             （a）ISCONCITIONAL == true，即它至少具有一个应用/继承的条件属性和\r\n             （b）在给定的语法中，没有任何与这些条件属性相对应的条件符号。\r\n            \r\n","\r\n            Gets the SymbolInfo for the Deconstruct method used for a deconstruction pattern clause, if any.\r\n            ":"\r\n            获取用于解构模式子句的解构方法的符号（如果有）。\r\n            \r\n","\r\n            This binder provides a context for binding within a specific compilation unit, but outside of top-level statements.\r\n            It ensures that locals are in scope, however it is not responsible\r\n            for creating the symbols. That task is actually owned by ":"\r\n            该活页夹提供了在特定汇编单元中绑定的上下文，但在顶级语句之外。\r\n            它确保当地人处于范围，但是不负责\r\n            用于创建符号。该任务实际上是由\r\n","\r\n            supports only one type for the value sets it can produce.\r\n            ":"\r\n            仅支持一种类型的值集。\r\n            \r\n","\r\n            Merges top-level and nested nullability from an otherwise identical type.\r\n            ":"\r\n            从原本相同的类型中合并顶级和嵌套的无效性。\r\n            \r\n","\r\n            Builds a tree of ":"\r\n            建造一棵树\r\n","\r\n            The \"position\" is used to determine what variables are visible and accessible. Even if \"container\" is\r\n            specified, the \"position\" location is significant for determining which members of \"containing\" are\r\n            accessible. \r\n            \r\n            Does not return NamespaceOrTypeSymbol, because there could be aliases.\r\n            ":"\r\n            “位置”用于确定哪些变量可见和可访问。即使“容器”是\r\n            指定，“位置”位置对于确定“包含”的哪个成员是重要的\r\n            无障碍。\r\n            \r\n            不返回命名paceortypesymbol，因为可能会有别名。\r\n            \r\n","The syntax node that declares a property.":"声明属性的语法节点。\r\n","A goto case is only valid inside a switch statement":"goto case仅在开关语句中有效\r\n","module as an attribute target specifier":"模块作为属性目标规范符\r\n","\r\n            If this method is a reduced extension method, gets the extension method definition that\r\n            this method was reduced from. Otherwise, returns null.\r\n            ":"\r\n            如果此方法是减少的扩展方法，请获取扩展方法定义\r\n            此方法从中降低了。否则，返回null。\r\n            \r\n","\r\n              Looks up a localized string similar to Fixed size buffers can only be accessed through locals or fields.\r\n            ":"\r\n              查找类似于固定尺寸缓冲区的本地化字符串只能通过当地人或字段访问。\r\n            \r\n"," set if the pattern in satisfied.":" 如果满足的模式设置为设置。\r\n","Cannot use #r after first token in file":"在文件中首次令牌后不能使用#r\r\n","\r\n            Determines if this type symbol represent the same type as another, according to the language\r\n            semantics.\r\n            ":"\r\n            根据语言确定此类型符号是否表示与另一个相同的类型\r\n            语义。\r\n            \r\n"," has been proven true":" 已被证明是真的\r\n","\r\n              Looks up a localized string similar to A constraint clause has already been specified for type parameter '{0}'. All of the constraints for a type parameter must be specified in a single where clause..\r\n            ":"\r\n              查找类似于约束子句的本地化字符串已被指定为类型参数'{0}'。类型参数的所有约束都必须在单个子句中指定。\r\n            \r\n","true if the out parameters of the method should be analyzed":"如果应分析该方法的OUT参数，则为true\r\n","\r\n            Get ":"\r\n            得到\r\n","\r\n              Looks up a localized string similar to For type '{0}' to be used as an AsyncMethodBuilder for type '{1}', its Task property should return type '{1}' instead of type '{2}'..\r\n            ":"\r\n              查找类似于“ {0}”类型的本地化字符串，用作type'{1}'的asyncmethodbuilder，其任务属性应返回类型'{1}'而不是类型'{2}'..\r\n            \r\n"," simply performs some computation and stores it in one or more\r\n            temporary variables for use in subsequent nodes (think of it as a node with a single successor);\r\n            ":" 只需执行一些计算，然后将其存储在一个或多个\r\n            用于后续节点中使用的临时变量（将其视为具有单个继任者的节点）；\r\n            \r\n","\r\n             This method recurses through leftTargets, right and conversion at the same time.\r\n             As it does, it collects side-effects into the proper buckets (init, deconstructions, conversions, assignments).\r\n            \r\n             The side-effects from the right initially go into the init bucket. But once we started drilling into a Deconstruct\r\n             invocation, subsequent side-effects from the right go into the deconstructions bucket (otherwise they would\r\n             be evaluated out of order).\r\n             ":"此方法通过左键递归，右和转换。\r\n             与此一样，它将副作用收集到适当的存储桶中（初始化，解构，转换，作业）。\r\n            \r\n             右侧的副作用最初进入初始化桶。但是，一旦我们开始钻入解构\r\n             调用，右侧的后续副作用进入解构桶（否则他们会\r\n             被评估出序）。\r\n             \r\n","\r\n            This method finds the best common type of a set of expressions as per section 7.5.2.14 of the specification.\r\n            NOTE: If some or all of the expressions have error types, we return error type as the inference result.\r\n            ":"\r\n            根据规范的第7.5.2.14节，该方法找到了一组表达式的最佳类型。\r\n            注意：如果某些或全部表达式具有错误类型，我们将错误类型作为推理结果返回。\r\n            \r\n"," with a matching ":" 与匹配\r\n","\r\n            Generates bound block representing method's body for methods in lowered form and adds it to\r\n            a collection of method bodies of the current module. This method is supposed to only be \r\n            called for method symbols which return SynthesizesLoweredBoundBody == true.\r\n            ":"\r\n            生成代表方法的实体的绑定块，以降低形式的方法，并将其添加到\r\n            当前模块的方法主体的集合。此方法应该只是\r\n            要求返回合成loderedBoundBody == true的方法符号。\r\n            \r\n","Creates a new CrefParameterSyntax instance.":"创建一个新的crefparametersyntax实例。\r\n","\r\n              Looks up a localized string similar to Referenced assembly does not have a strong name.\r\n            ":"\r\n              查找类似于引用组件的本地化字符串没有强烈的名称。\r\n            \r\n","Invalid module name: {0}":"无效的模块名称：{0}\r\n","\r\n            Returns a bit set of attribute locations applicable to this symbol.\r\n            ":"\r\n            返回适用于此符号的属性位置集。\r\n            \r\n","\r\n            If we learn that the operand is non-null, we can infer that certain\r\n            sub-expressions were also non-null.\r\n            Get all nested conditional slots for those sub-expressions. For example in a?.b?.c we'll set a, b, and c.\r\n            Only returns slots for tracked expressions.\r\n            ":"\r\n            如果我们得知操作数是非零的，我们可以推断出一定的\r\n            子表达也是非记器。\r\n            为这些子表达获得所有嵌套条件插槽。例如，在A？.b？.c中，我们将设置A，B和C。\r\n            仅返回跟踪表达式的插槽。\r\n            \r\n","Called when the visitor visits a VariableDeclarationSyntax node.":"当访问者访问variableclarationsyntax节点时调用。\r\n","\r\n              Looks up a localized string similar to '{0}': type used in a using statement must be implicitly convertible to 'System.IDisposable' or implement a suitable 'Dispose' method..\r\n            ":"\r\n              查找类似于“ {0}'：使用语句中使用的类型的本地化字符串，必须隐式转换为'system.idisposable'或实现合适的“ dispose”方法。\r\n            \r\n","\r\n              Looks up a localized string similar to Only class types can contain destructors.\r\n            ":"\r\n              查找类似于类类型的本地化字符串可以包含击路仪。\r\n            \r\n","Cannot initialize a by-reference variable with a value":"无法初始化具有值的补音变量\r\n","\r\n            Reflects the enclosing member or lambda at the current location (in the bound tree).\r\n            ":"\r\n            在当前位置（在绑定的树中）反映封闭的成员或lambda。\r\n            \r\n","An updated symbols array containing only one method symbol representing the two parts":"更新的符号数组，仅包含一个代表这两个部分的方法符号\r\n","Containing symbol type parameters.":"包含符号类型参数。\r\n","++":"++\r\n","\r\n            Returns true if this symbol has external implementation; i.e., declared with the \r\n            \"extern\" modifier. \r\n            ":"\r\n            如果此符号具有外部实现，则返回true；即，用\r\n            “外部”修饰符。\r\n            \r\n","Nullability of reference types in type doesn't match overridden member.":"类型中参考类型的无效性不匹配被覆盖的成员。\r\n","anonymous methods":"匿名方法\r\n","Called when the visitor visits a XmlCommentSyntax node.":"当访问者访问XMLCommentsyntax节点时致电。\r\n","Assignment made to same variable":"分配给同一变量\r\n","A new expression requires an argument list or (), [], or {} after type":"一个新的表达式需要一个参数列表或（），[]或{}之后\r\n","Argument {0} may not be passed with the '{1}' keyword":"参数{0}可能不会使用'{1}'关键字传递\r\n","Where diagnostics should be added.":"应添加诊断的位置。\r\n","\r\n            No tests to be performed; the result is true (success).\r\n            ":"\r\n            没有测试要执行；结果是真实的（成功）。\r\n            \r\n","\r\n              Looks up a localized string similar to collection.\r\n            ":"\r\n              查找类似于集合的本地化字符串。\r\n            \r\n","\r\n            Consider only symbols that are abstract.\r\n            ":"\r\n            仅考虑抽象的符号。\r\n            \r\n","\r\n            Set to false if syntax binds to a type in the current context and true if\r\n            syntax is \"unmanaged\" and it binds to \"unmanaged\" keyword in the current context.\r\n            ":"\r\n            设置为false如果语法在当前上下文中绑定到类型，则设置为true\r\n            语法是“不受管理的”，它在当前上下文中与“未管理”的关键字结合。\r\n            \r\n","\r\n            Find the well-known members to the ValueTuple type of a given arity and position.\r\n            For example, for arity=3 and position=1:\r\n            returns WellKnownMember.System_ValueTuple_T3__Item1\r\n            ":"\r\n            找到著名的成员，以达到给定的ARITY和立场的估值类型。\r\n            例如，对于Arity = 3，位置= 1：\r\n            返回众所周知的ember.system_valuetuple_t3__item1\r\n            \r\n"," is true, the constructor simply zero-inits the instance.\r\n            If the containing struct type is from metadata, the default constructor is synthesized when there\r\n            is no accessible parameterless constructor. (That synthesized constructor from metadata zero-inits\r\n            the instance.) If the containing struct type is from source, the parameterless constructor is synthesized\r\n            if there is no explicit parameterless constructor. And if the source type has no field initializers, or\r\n            the type has field initializers and at least one explicit constructor with parameters, the synthesized\r\n            parameterless constructor simply zero-inits the instance (and is not emitted).\r\n            ":" 是真的，构造函数只是零inits实例。\r\n            如果包含的struct类型来自元数据，则在此处合成默认构造函数\r\n            无访问的无参数构造函数。 （从元数据零输入中合成的构造函数\r\n            实例。）如果包含的struct类型来自源，则合成无参数构造函数\r\n            如果没有明确的无参数构造函数。如果源类型没有字段初始化器，或者\r\n            该类型具有字段初始化器和至少一个带有参数的显式构造函数，合成的\r\n            无参数构造函数简单地零inits实例（并且不发出）。\r\n            \r\n","\r\n            This is the set of parameters and local variables that were used as arguments to\r\n            lock or using statements in enclosing scopes.\r\n            ":"\r\n            这是一组参数和本地变量，被用作参数\r\n            锁定或使用语句包装范围。\r\n            \r\n","Event is never used":"事件从未使用\r\n","\r\n            Lower the given pattern switch statement into a decision tree and then to a sequence of statements into the given statement builder.\r\n            ":"\r\n            将给定的模式开关语句降低到决策树，然后将一系列语句降低到给定的语句构建器中。\r\n            \r\n","Use of unassigned out parameter":"使用未分配的参数\r\n","\r\n            Set the state field and the cached state\r\n            ":"\r\n            设置状态领域和缓存状态\r\n            \r\n","InitializerExpressionSyntax representing the initializer expression of the implicit stackalloc array creation expression.":"InitializereXpressionsyntax表示隐式stackalloc阵列创建表达式的初始化器表达式。\r\n","\r\n            This rather confusing method tries to reproduce the functionality of ExpressionBinder::bindPtrAddMul and\r\n            ExpressionBinder::bindPtrMul.  The basic idea is that we have a numeric expression, x, and a pointer type, \r\n            T*, and we want to multiply x by sizeof(T).  Unfortunately, we need to stick in some conversions to make\r\n            everything work.\r\n            \r\n              1) If x is an int, then convert it to an IntPtr (i.e. a native int).  Dev10 offers no explanation (ExpressionBinder::bindPtrMul).\r\n              2) Do overload resolution based on the (possibly converted) type of X and int (the type of sizeof(T)).\r\n              3) If the result type of the chosen multiplication operator is signed, convert the product to IntPtr;\r\n                 otherwise, convert the product to UIntPtr.\r\n            ":"\r\n            这种相当令人困惑的方法试图重现ExpressionBinder :: bindptraddmul和\r\n            ExpressionBinder :: bindptrmul。基本思想是我们有一个数字表达式x和指针类型，\r\n            t*，我们要乘以x乘以sizeof（t）。不幸的是，我们需要坚持一些转换以进行\r\n            一切都起作用。\r\n            \r\n              1）如果x是int，则将其转换为intptr（即本机int）。 Dev10不提供任何解释（ExpressionBinder :: bindptrmul）。\r\n              2）根据（可能转换的）X和INT（sizeof（t）的类型）进行过载分辨率。\r\n              3）如果签署了所选乘法运算符的结果类型，请将产品转换为INTPTR；\r\n                 否则，将产品转换为UINTPTR。\r\n            \r\n","s available to generators in this driver, or ":"该驱动程序中的发电机可用，或\r\n","\r\n            True if the conversion is an explicit conversion.\r\n            ":"\r\n            如果转换是明确的转换，则为正确。\r\n            \r\n","Invalid filename specified for preprocessor directive":"为预处理器指令指定的无效文件名\r\n","\r\n            A sequence of tests that must be performed, each of which must succeed.\r\n            The sequence is deemed to succeed if no element fails.\r\n            ":"\r\n            必须执行的一系列测试，每个测试都必须成功。\r\n            如果没有元素失败，则该序列被认为是成功的。\r\n            \r\n","\r\n            Helper method to create a synthesized method invocation expression.\r\n            ":"\r\n            创建合成方法调用表达式的帮助方法。\r\n            \r\n","\r\n            Implement C# data flow analysis (definite assignment).\r\n            ":"\r\n            实施C＃数据流分析（确定分配）。\r\n            \r\n","\r\n            Indicates whether or not the property returns by reference\r\n            ":"\r\n            指示该属性是否通过参考返回\r\n            \r\n","\r\n            Gets the attributes on event's associated field, if any.\r\n            Returns an empty ":"\r\n            获取事件相关字段（如果有）上的属性。\r\n            返回空\r\n","Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first":"位于签名操作数上的钻头或操作员；考虑首先铸造到较小的未签名类型\r\n","\r\n            Get the builder for code in the given section of the switch.\r\n            For an is-pattern expression, this is a singleton.\r\n            ":"\r\n            在交换机的给定部分中获取代码的构建器。\r\n            对于IS-Pattern表达，这是单身人士。\r\n            \r\n","\r\n            Creates a new compilation with the specified name.\r\n            ":"\r\n            使用指定名称创建新的汇编。\r\n            \r\n"," doesn't match any #r directive in the compilation.":" 编译中的任何#R指令都不匹配。\r\n","An ErrorDirective or WarningDirective node.":"错误或警告节点。\r\n","\r\n            Parses the type, or pattern, right-hand operand of an is expression.\r\n            Priority is the TypeSyntax. It may return a TypeSyntax which turns out in binding to\r\n            be a constant pattern such as enum 'Days.Sunday'. We handle such cases in the binder of the is operator.\r\n            Note that the syntax `_` will be parsed as a type.\r\n            ":"\r\n            解析is表达式的类型或模式右侧操作数。\r\n            优先级是TypeSyntax。 它可能会返回一个TypeSyntax，结果是绑定到\r\n            是一个恒定的模式，如枚举的日子。星期天'。 我们在is运算符的binder中处理此类情况。\r\n            请注意，语法'_`将被解析为类型。\r\n            \r\n","Improves error message detail.":"改进错误消息详细信息。\r\n","\r\n              Looks up a localized string similar to There is no defined ordering between fields in multiple declarations of partial struct.\r\n            ":"\r\n              查找与部分结构的多个声明中的字段之间没有定义的排序局部字符串。\r\n            \r\n","\r\n            Returns whether this method is async and returns an IAsyncEnumerable`1.\r\n            ":"\r\n            返回该方法是否为异步并返回iaSyncenumerable'1。\r\n            \r\n","Nullability of type of parameter '{0}' doesn't match overridden member (possibly because of nullability attributes).":"参数类型'{0}'的无效性不匹配被覆盖的成员（可能是由于无效属性）。\r\n","Auto-implemented properties must have get accessors.":"自动实施属性必须有登录器。\r\n","SyntaxToken representing the operator of the relational pattern.":"Syntaxtoken代表关系模式的操作员。\r\n","\r\n            Returns the RefKind if the expression represents a symbol\r\n            that has a RefKind, or RefKind.None otherwise.\r\n            ":"\r\n            如果表达式表示符号\r\n            它具有reftokind或Refkind。否则。\r\n            \r\n","Lambda expressions that return by reference cannot be converted to expression trees":"lambda表达式无法转换为表达树\r\n"," branch is ":" 分支是\r\n","; Should override this method if\r\n            want to visit members of the namespace; Calling ":";如果应该覆盖此方法\r\n            想访问名称空间成员；打电话\r\n","\r\n            Synthesizes a custom attribute. \r\n            Returns null if the ":"\r\n            合成自定义属性。\r\n            如果是\r\n","\r\n            A successor function used to topologically sort the DagState set.\r\n            ":"\r\n            用于拓扑分类dagstate集的后继函数。\r\n            \r\n","\r\n            NOTE: This method should always be kept as a sealed override.\r\n            If you want to override attribute binding logic for a sub-class, then override ":"注意：该方法应始终保存为密封的覆盖。\r\n            如果要覆盖子类属性绑定逻辑，则覆盖\r\n","Called when the visitor visits a EndIfDirectiveTriviaSyntax node.":"当访客访问EndifirectivtriviaSyntax节点时调用。\r\n","\r\n            Expression can be the LHS of a ref-assign operation.\r\n            Example:\r\n             ref local, ref parameter, out parameter\r\n            ":"\r\n            表达可以是参考操作的LHS。\r\n            例子：\r\n             ref local，ref参数，输出参数\r\n            \r\n","\r\n            Unique identifier in the chain of nested VariablesSnapshot instances. The value starts at 0\r\n            for the outermost method and increases at each nested function.\r\n            ":"\r\n            嵌套variablessnapshot实例链中的唯一标识符。值从0开始\r\n            对于最外面的方法，并在每个嵌套函数上增加。\r\n            \r\n","A value of type 'void' may not be assigned.":"可以分配“ void”类型的值。\r\n","SyntaxToken representing greater than.":"Syntaxtoken代表大于。\r\n","\r\n            A type and its corresponding flow state resulting from evaluating an rvalue expression.\r\n            ":"\r\n            评估RVALUE表达式产生的类型及其相应的流量状态。\r\n            \r\n","Conversion, equality, or inequality operators declared in interfaces must be abstract":"界面中声明的转换，平等或不平等运算符必须是抽象的\r\n","\r\n            This rewriter lowers pre-/post- increment/decrement operations (initially represented as\r\n            unary operators). We use BoundSequenceExpressions because we need to capture the RHS of the\r\n            assignment in a temp variable.\r\n            ":"\r\n            此重写器降低了前/后增量/减少操作（最初表示为\r\n            单一操作员）。我们使用BONDSESECENCESTIONS，因为我们需要捕获\r\n            在温度变量中分配。\r\n            \r\n","\r\n            Walk up the scope tree looking for a variable declaration.\r\n            ":"\r\n            走上范围树，寻找可变声明。\r\n            \r\n","Class which represents the syntax node for parenthesized lambda expression.":"代表括号lambda表达的语法节点的类。\r\n","\r\n              Looks up a localized string similar to '{0}': static types cannot be used as type arguments.\r\n            ":"\r\n              查找类似于“ {0}'：静态类型的本地化字符串，不能用作类型参数。\r\n            \r\n","\r\n              Looks up a localized string similar to XML comment has a param tag for '{0}', but there is no parameter by that name.\r\n            ":"\r\n              查找类似于XML注释的本地化字符串具有“ {0}”的param标签，但是没有使用该名称的参数。\r\n            \r\n","\r\n            Returns true if the conversion is an implicit default literal conversion.\r\n            ":"\r\n            如果转换是隐式默认文字转换，则返回true。\r\n            \r\n",".\r\n            Subsequent passes are responsible for translating captured\r\n            variables into captured environments and for calculating\r\n            the rewritten signature of the method.\r\n            ":"。\r\n            随后的通行证负责翻译被捕获的\r\n            变量到捕获的环境和计算\r\n            该方法的重写签名。\r\n            \r\n","\r\n            Lazily initialized by TypeKind property.\r\n            ":"\r\n            懒惰的typekind属性初始化。\r\n            \r\n","Called when the visitor visits a ClassDeclarationSyntax node.":"当访问者访问classDeclarationsyntax节点时，请致电。\r\n","\r\n            Given a viable LookupResult, report any ambiguity errors and return either a single\r\n            non-method symbol or a method or property group. If the result set represents a\r\n            collection of methods or a collection of properties where at least one of the properties\r\n            is an indexed property, then 'methodOrPropertyGroup' is populated with the method or\r\n            property group and the method returns null. Otherwise, the method returns a single\r\n            symbol and 'methodOrPropertyGroup' is empty. (Since the result set is viable, there\r\n            must be at least one symbol.) If the result set is ambiguous - either containing multiple\r\n            members of different member types, or multiple properties but no indexed properties -\r\n            then a diagnostic is reported for the ambiguity and a single symbol is returned.\r\n            ":"给定可行的查找，报告任何歧义错误，然后返回一个单一\r\n            非方法符号或方法或属性组。如果结果集代表\r\n            收集方法或属性的集合，其中至少一个属性\r\n            是索引属性，然后用方法或\r\n            属性组和方法返回null。否则，该方法返回一个\r\n            符号和“ MedagorPropertyGroup”为空。 （由于结果集很可行，因此\r\n            必须至少一个符号。）如果结果集模棱两可 - 包含多个\r\n            不同成员类型或多个属性但没有索引属性的成员 - \r\n            然后，报告了歧义性的诊断，并返回单个符号。\r\n            \r\n","The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no implicit reference conversion from '{3}' to '{1}'.":"类型'{3}'在通用类型或方法'{0}'中不能用作类型参数'{2}'。从“ {3}”到'{1}'没有隐式参考转换。\r\n","separator is expected":"期望分离器\r\n","\r\n            True when \"peverify-compat\" is set\r\n            With this flag we will avoid certain patterns known not be compatible with PEVerify.\r\n            The code may be less efficient and may deviate from spec in corner cases.\r\n            The flag is only to be used if PEVerify pass is extremely important.\r\n            ":"\r\n            当设置“ peverify-compat”时是真的\r\n            使用此标志，我们将避免某些已知的模式与Peverify不兼容。\r\n            该代码的效率可能较低，并且在角案例中可能会偏离规格。\r\n            只有在Peverify Pass极为重要的情况下，才能使用标志。\r\n            \r\n","Constant interpolated strings":"恒定的插值字符串\r\n","\r\n            These diagnostics are for members that do implicitly implement an interface member, but do so\r\n            in an undesirable way.\r\n            ":"这些诊断适用于确实隐式实现接口成员但这样做的成员\r\n            以一种不良的方式。\r\n            \r\n","\r\n            Creates a syntax node for a priliminary element within a xml documentation comment.\r\n            ":"\r\n            在XML文档注释中为PRILIMINAL元素创建语法节点。\r\n            \r\n"," contains an absolute path, returns ":" 包含一个绝对路径，返回\r\n","Ref and readonly structs":"参考和阅读结构\r\n","\r\n              Looks up a localized string similar to Command-line syntax error: Missing '{0}' for '{1}' option.\r\n            ":"查找类似于命令行语法错误的本地化字符串：对于'{1}'选项，丢失{0}''\r\n            \r\n","Cannot read config file '{0}' -- '{1}'":"无法读取配置文件'{0}' - '{1}'\r\n","\r\n            The underlying AssemblySymbol, it leaks symbols that should be retargeted.\r\n            This cannot be an instance of RetargetingAssemblySymbol.\r\n            ":"\r\n            它的基础组合符号，它泄漏了应重新定位的符号。\r\n            这不能是retargetingAssemblysymbol的一个实例。\r\n            \r\n","\r\n              Looks up a localized string similar to A deconstruction cannot mix declarations and expressions on the left-hand-side..\r\n            ":"\r\n              查找类似于解构的本地化字符串无法混合左侧的声明和表达式。\r\n            \r\n","\r\n            When set, we ignore private reference fields of structs loaded from metadata.\r\n            ":"\r\n            设置后，我们忽略了从元数据加载的结构的私有参考字段。\r\n            \r\n","\r\n            The type of the property along with its annotations.\r\n            ":"\r\n            属性的类型及其注释。\r\n            \r\n","\r\n            Returns if the method is implicit instance constructor\r\n            ":"\r\n            如果该方法是隐式实例构造函数，则返回\r\n            \r\n","SyntaxToken representing the operator of the binary expression.":"Syntaxtkoken代表二进制表达式的操作员。\r\n","\r\n              Looks up a localized string similar to Named argument specifications must appear after all fixed arguments have been specified.\r\n            ":"\r\n              在指定所有固定参数后，必须出现类似于命名参数规范的本地化字符串。\r\n            \r\n","\r\n            This interface models the metadata representation of a pointer to a function in unmanaged memory.\r\n            ":"\r\n            该接口建模了指向非托管内存中函数的指针的元数据表示。\r\n            \r\n","Null if the symbol is missing.":"如果缺少符号，则为空。\r\n","\r\n             Take a warning and return the final disposition of the given warning,\r\n             based on both command line options and pragmas. The diagnostic options\r\n             have precedence in the following order:\r\n                 1. Warning level\r\n                 2. Syntax tree level\r\n                 3. Compilation level\r\n                 4. Global warning level\r\n            \r\n             Pragmas are considered seperately. If a diagnostic would not otherwise\r\n             be suppressed, but is suppressed by a pragma, ":"\r\n             发出警告并返回给定警告的最终处置，\r\n             基于命令行选项和布拉格马斯。诊断选项\r\n             按以下顺序有优先权：\r\n                 1.警告级别\r\n                 2.语法树级别\r\n                 3.汇编级别\r\n                 4.全球警告水平\r\n            \r\n             布拉格斯被认为是单独的。如果诊断不会以其他方式\r\n             被抑制，但被布拉格抑制，\r\n","\r\n              Looks up a localized string similar to Expression tree cannot contain value of ref struct or restricted type '{0}'..\r\n            ":"\r\n              查找类似于表达树的本地化字符串不能包含ref struct或限制类型的值'{0}'..\r\n            \r\n","A language name must be specified for this option.":"必须为此选项指定语言名称。\r\n",". This\r\n            ":"。这个\r\n            \r\n","Called when the visitor visits a ArgumentListSyntax node.":"当访问者访问grigntlistsyntax节点时打电话。\r\n"," is the method used for values of any optional parameters.\r\n            For indexers, this method must be an accessor, and for methods it must be the method\r\n            itself. ":" 是用于任何可选参数值的方法。\r\n            对于索引器，此方法必须是访问者，对于方法，必须是方法\r\n            本身。\r\n","\r\n            Gets the type of the elements stored in the array along with its annotations.\r\n            ":"\r\n            获取存储在数组中的元素及其注释的类型。\r\n            \r\n","\r\n            Associated with ":"\r\n            有关联\r\n","\r\n              Looks up a localized string similar to '{0}' is abstract but it is contained in non-abstract class '{1}'.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串是抽象的，但包含在非Abstract类'{1}'中。\r\n            \r\n","Called when the visitor visits a FunctionPointerTypeSyntax node.":"当访问者访问fintunPoInterTypesyntax节点时，请致电。\r\n","\r\n            Generate the GetEnumerator() method for iterators and GetAsyncEnumerator() for async-iterators.\r\n            ":"\r\n            为迭代器和getAsyncenumerator（）生成getEnumerator（）方法。\r\n            \r\n","\r\n             The strategy of this rewrite is to do rewrite \"locally\".\r\n             We analyze arguments of the concat in a shallow fashion assuming that \r\n             lowering and optimizations (including this one) is already done for the arguments.\r\n             Based on the arguments we select the most appropriate pattern for the current node.\r\n             \r\n             NOTE: it is not guaranteed that the node that we chose will be the most optimal since we have only \r\n                   local information - i.e. we look at the arguments, but we do not know about siblings.\r\n                   When we move to the parent, the node may be rewritten by this or some another optimization.\r\n                   \r\n             Example:\r\n                 result = ( \"abc\" + \"def\" + null ?? expr1 + \"moo\" + \"baz\" ) + expr2\r\n             \r\n             Will rewrite into:\r\n                 result = Concat(\"abcdef\", expr2)\r\n                 \r\n             However there will be transient nodes like  Concat(expr1 + \"moo\")  that will not be present in the\r\n             resulting tree.\r\n            \r\n             ":"\r\n             这种重写的策略是\"本地\"进行重写。\r\n             我们以浅薄的方式分析连接的论点，假设 \r\n             降低和优化（包括这个）已经为参数完成了。\r\n             根据参数，我们为当前节点选择最合适的模式。\r\n             \r\n             注意：不能保证我们选择的节点将是最优的，因为我们只有 \r\n                   本地信息-即我们看的论点，但我们不知道兄弟姐妹。\r\n                   当我们移动到父节点时，节点可能会被这个或另一个优化重写。\r\n                   \r\n             例子：:\r\n                 结果=（\"abc\"+\"def\"+null？? expr1+\"moo\"+\"baz\"）+expr2\r\n             \r\n             将重写成:\r\n                 结果=Concat(\"abcdef\",expr2)\r\n                 \r\n             然而，会有像Concat（expr1+\"moo\"）这样的瞬态节点不会出现在\r\n             产生的树。\r\n            \r\n             \r\n","\r\n              Looks up a localized string similar to '{0}': structs cannot call base class constructors.\r\n            ":"\r\n              查找类似于'{0}'：structs的局部字符串，无法调用基类构造函数。\r\n            \r\n","\r\n            Sequence points permit Syntax to be null.  But all other contexts require a non-null Syntax,\r\n            so we annotate it for the majority of uses.\r\n            ":"\r\n            序列点允许语法为无效。但是所有其他上下文都需要非编号语法，\r\n            因此，我们将其注释为大多数用途。\r\n            \r\n","\r\n            The node being visited is not necessarily equal to statements[startIndex]. \r\n            When traversing down a set of labels, we set node to the label.body and recurse, but statements[startIndex] still refers to the original parent label \r\n            as we haven't actually moved down the original statement list\r\n            ":"\r\n            访问的节点不一定等于语句[StartIndex]。\r\n            在浏览一组标签时，我们将节点设置为标签。Body和Recurse，但语句[StartIndex]仍然是指原始的父级标签\r\n            因为我们实际上还没有从原始语句列表中移动\r\n            \r\n","Gets the class keyword token.":"获取类关键字令牌。\r\n","A base type was marked as not having to be compliant with the Common Language Specification (CLS) in an assembly that was marked as being CLS compliant. Either remove the attribute that specifies the assembly is CLS compliant or remove the attribute that i ...":"基本类型被标记为不必符合标记为CLS符合CLS的组件中的常见语言规范（CLS）。删除指定汇编为CLS的属性要么符合CLS，要么删除I ...\r\n","\r\n            Lexer entry point for LexMode.XmlElementTag\r\n            ":"\r\n            lexmode.xmlelementtag的Lexer入口点\r\n            \r\n","\r\n            Gets the ordinal position of the parameter. The first parameter has ordinal zero.\r\n            The \"'this' parameter has ordinal -1.\r\n            ":"\r\n            获取参数的顺序位置。第一个参数具有序数零。\r\n            “'此'参数具有序数-1。\r\n            \r\n","\r\n            When this is more that 0, returns are emitted as \"methodValue = value; goto exitLabel;\"\r\n            ":"\r\n            当更多的是0时，将返回发射为“ methodValue = value; goto exitlabel; goto exitlabel;'';\r\n            \r\n","\r\n              Looks up a localized string similar to extern alias.\r\n            ":"\r\n              查找类似于外部别名的局部字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': abstract properties cannot have private accessors.\r\n            ":"\r\n              查找类似于“ {0}”的局部字符串：抽象属性不能具有私人访问者。\r\n            \r\n","\r\n            If this is a property of a tuple type, return corresponding underlying property from the\r\n            tuple underlying type. Otherwise, null. \r\n            ":"\r\n            如果这是元组类型的属性，请从\r\n            元组基础类型。否则，null。\r\n            \r\n"," (as well as\r\n            ":" （也\r\n            \r\n","Called when the visitor visits a ThisExpressionSyntax node.":"当访问者访问thisexpressyntax节点时，请致电。\r\n","A number that was passed to the #pragma warning preprocessor directive was not a valid warning number. Verify that the number represents a warning, not an error.":"传递给#Pragma警告预处理器指令的数字不是有效的警告号码。验证该数字表示警告，而不是错误。\r\n","Base type for parameter list syntax.":"参数列表语法的基本类型。\r\n","\r\n            A counterpart to the GetValEscape, which validates if given escape demand can be met by the expression.\r\n            The result indicates whether the escape is possible. \r\n            Additionally, the method emits diagnostics (possibly more than one, recursively) that would help identify the cause for the failure.\r\n            ":"\r\n            getValeScape的对应物，该表达式可以满足逃脱需求的验证。\r\n            结果表明逃脱是否可能。\r\n            此外，该方法会发出诊断（可能是递归的），这将有助于确定失败的原因。\r\n            \r\n","A partial method must be declared within a partial type":"必须在部分类型中声明部分方法\r\n","\r\n            Only adds warnings, so does not affect control flow (i.e. no need to check for failure).\r\n            ":"\r\n            仅添加警告，因此不会影响控制流（即无需检查故障）。\r\n            \r\n","\r\n              Looks up a localized string similar to ref reassignment.\r\n            ":"\r\n              查找类似于参考重新分配的本地化字符串。\r\n            \r\n","\r\n            An enumerable collection of extension method scopes in search\r\n            order, from the given Binder, out through containing Binders.\r\n            ":"\r\n            搜索中列出的扩展方法范围的集合\r\n            从给定的粘合剂中订购通过包含粘合剂的顺序。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot update '{0}'; attribute '{1}' is missing..\r\n            ":"\r\n              查找类似于无法更新'{0}'的本地化字符串;属性'{1}'丢失了。\r\n            \r\n","\r\n            Returns the original input for this evaluation, stripped of all Type Evaluations.\r\n            \r\n            A BoundDagTypeEvaluation doesn't change the underlying object being pointed to\r\n            So two evaluations act on the same input so long as they have the same original input.\r\n            ":"\r\n            返回此评估的原始输入，并剥离了所有类型评估。\r\n            \r\n            界限值不会改变所指向的基础对象\r\n            因此，只要有相同的原始输入，两个评估就对相同的输入起作用。\r\n            \r\n","Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}'":"类型参数'{0}'继承冲突的约束'{1}'和'{2}'\r\n","A result of a stackalloc expression of type '{0}' cannot be used in this context because it may be exposed outside of the containing method":"在此上下文中不能使用类型“ {0}”类型的stackalloc表达式的结果，因为它可以在包含方法之外暴露\r\n","Creates a new NullableTypeSyntax instance.":"创建一个新的nullableTypesyntax实例。\r\n","\r\n              Looks up a localized string similar to '{0}' is not a valid warning number.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串不是有效的警告号码。\r\n            \r\n","\r\n            Represents a result of lookup operation over a 0 or 1 symbol (as opposed to a scope). The\r\n            typical use is to represent that a particular symbol is good/bad/unavailable.\r\n            \r\n            For more explanation of Kind, Symbol, Error - see LookupResult.\r\n            ":"\r\n            代表在0或1符号上查找操作的结果（与范围相反）。这\r\n            典型的用途是表示特定符号是好/坏/不可用。\r\n            \r\n            有关类型，符号，错误的更多说明 - 请参见LookupResult。\r\n            \r\n","\r\n            Returns true if the second is a better location than the first.\r\n            ":"\r\n            如果第二个位置比第一个更好，则返回true。\r\n            \r\n","Creates a new RegionDirectiveTriviaSyntax instance.":"创建一个新的regionDirectivtriviaSyntax实例。\r\n","\r\n              Looks up a localized string similar to Cannot use '{0}' for Main method because it is imported.\r\n            ":"\r\n              查找类似于Main方法的局部字符串，类似于无法使用'{0}'，因为它是导入的。\r\n            \r\n","SecurityAction value '{0}' is invalid for PrincipalPermission attribute":"SecurityAction值'{0}'对于principalpermission属性无效\r\n","\r\n            The constructor takes a parameter of type Microsoft.CodeAnalysis.Scripting.Session - the session reference.\r\n            It adds the object being constructed into the session by calling Microsoft.CSharp.RuntimeHelpers.SessionHelpers.SetSubmission,\r\n            and retrieves strongly typed references on all previous submission script classes whose members are referenced by this submission.\r\n            The references are stored to fields of the submission (":"构造函数采用类型Microsoft.scodeanalysis.scripting.session-会话参考。\r\n            它通过调用microsoft.csharp.runtimehelpers.sessionhelpers.setsubmission，将要构造的对象添加到会话中\r\n            并在所有以前的提交脚本类上检索强烈键入的参考，其成员由本提交的提交引用。\r\n            参考文献存储到提交的字段（\r\n",". If it is subsumed,\r\n            returns an error code suitable for reporting the issue. If it is not subsumed, returns 0.\r\n            ":"。如果被包含在\r\n            返回适用于报告问题的错误代码。如果不包含，则返回0。\r\n            \r\n","\r\n            Returns true if all type parameter references within the given\r\n            types belong to containingSymbol or its containing types.\r\n            ":"\r\n            如果给定的所有类型参数引用，则返回true\r\n            类型属于ContiningSymbol或其包含类型。\r\n            \r\n","\r\n            If IsConst returns true, then returns the constant value of the field or enum member. If IsConst returns\r\n            false, then returns null.\r\n            ":"\r\n            如果ISCONST返回true，则返回字段或枚举成员的常数值。如果ISCONST返回\r\n            错误，然后返回null。\r\n            \r\n","\r\n            The number of characters in the current lexeme.\r\n            ":"\r\n            当前Lexeme中的字符数。\r\n            \r\n","\r\n              Looks up a localized string similar to fixed variable.\r\n            ":"\r\n              查找类似于固定变量的本地化字符串。\r\n            \r\n"," for N1.N2. For the global namespace, the declaring\r\n            syntax will be the ":" 对于N1.N2。对于全球名称空间，声明\r\n            语法将是\r\n","\r\n            Is this a NoPia local type explicitly declared in source, i.e.\r\n            top level type with a TypeIdentifier attribute on it?\r\n            ":"这是在源中明确声明的NOPIA本地类型，即\r\n            顶级类型带有类型识别符属性？\r\n            \r\n"," of the parameter of which this is the type (or ":" 这是类型的参数（或\r\n","\r\n            Returns true if and only if the endpoint of the last statement in the region is reachable or the region contains no\r\n            statements.\r\n            ":"\r\n            当且仅当该区域中最后一个语句的端点可以到达或区域包含否时，返回true\r\n            语句。\r\n            \r\n","\r\n              Looks up a localized string similar to A throw expression is not allowed in this context..\r\n            ":"\r\n              在此上下文中不允许查找类似于投掷表达式的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot create delegate from method '{0}' because it is a partial method without an implementing declaration.\r\n            ":"\r\n              查找类似于方法'{0}'的本地化字符串无法创建委派，因为它是没有实现声明的部分方法。\r\n            \r\n","The using alias '{0}' appeared previously in this namespace":"以前出现在此名称空间中的使用别名'{0}'\r\n","Ambiguous reference in cref attribute":"CREF属性中的模棱两可的参考\r\n","\r\n              Looks up a localized string similar to Cannot pass null for friend assembly name.\r\n            ":"\r\n              查找类似于朋友汇编名称的局部字符串。\r\n            \r\n"," modifier. Also returns true on a type declared as \"abstract\", all\r\n            interface types, and members of interface types.\r\n            ":" 修饰符。还返回在称为“抽象”的类型上返回的\r\n            接口类型和接口类型的成员。\r\n            \r\n","InitializerExpressionSyntax representing the initializer expression for the object being created.":"initializerexpressionsyntax表示要创建的对象的初始化器表达式。\r\n","index of first character to be included":"要包含的第一个字符的索引\r\n","\r\n            Perform a lookup for the specified method on the specified expression by attempting to invoke it \r\n            ":"\r\n            通过尝试调用指定表达式的指定方法查找\r\n            \r\n","\r\n            Represents a named type symbol whose members are declared in source.\r\n            ":"\r\n            代表一个命名类型符号，其成员在源中声明。\r\n            \r\n","\r\n            \r\n             becomes\r\n             \r\n             ":"\r\n            \r\n             变成\r\n             \r\n             \r\n","Public signing is not supported for netmodules.":"NetModules不支持公共签名。\r\n","\r\n              Looks up a localized string similar to  The parameter modifier 'out' cannot be used with 'this' .\r\n            ":"\r\n              查找类似于参数修饰符“ OUT”的本地化字符串，不能与“此”一起使用。\r\n            \r\n","\r\n            If a method is annotated with `[MemberNotNull(...)]` attributes, returns the list of members\r\n            listed in those attributes.\r\n            Otherwise, an empty array.\r\n            ":"\r\n            如果用`[membernotnull（...）]注释方法`属性，请返回成员列表\r\n            在这些属性中列出。\r\n            否则，一个空数组。\r\n            \r\n","\r\n            Preprocessor states corresponding to positions in ":"\r\n            对应于位置的前处理器状态\r\n"," when a compilation is not available and that method will never return\r\n            true for retargeting symbols.\r\n            ":" 当不可用时，该方法将永远不会返回\r\n            对重新定位符号的正确。\r\n            \r\n","the original method body is the last statement in the block":"原始方法主体是块中的最后一个陈述\r\n","A nested array initializer is expected":"预计会嵌套阵列初始化器\r\n","\r\n              Looks up a localized string similar to Missing file specification for '{0}' option.\r\n            ":"查找类似于“ {0}”选项的丢失文件规范的本地化字符串。\r\n            \r\n","Called when the visitor visits a SwitchSectionSyntax node.":"当访问者访问开关系数节点时调用。\r\n","Bound attribute":"绑定属性\r\n","\r\n            Analyzes method body for try blocks with awaits in finally blocks \r\n            Also collects labels that such blocks contain.\r\n            ":"\r\n            分析方法主体，用于在最后块中等待的尝试块\r\n            还收集了此类块包含的标签。\r\n            \r\n"," method\r\n            is used on a hot path for fluent calls and this size change is enough that it causes us\r\n            to exceed our thresholds in EndToEndTests.OverflowOnFluentCall.\r\n            ":" 方法\r\n            在热门通话的热路径上使用，这种尺寸的变化足以使我们造成\r\n            超过我们在endToendTests.overflowloonfluentcall中的阈值。\r\n            \r\n","Record structs":"记录结构\r\n","Creates a new TypeOfExpressionSyntax instance.":"创建一个新的typeofexpressionsyntax实例。\r\n","Alias symbol if syntax binds to an alias.":"别名符号如果语法与别名结合。\r\n","PE symbols don't provide this information and always return null.":"PE符号不提供此信息，并且始终返回null。\r\n","Method to be invoked on the receiver.":"在接收器上调用的方法。\r\n","The generators to create this driver with":"用来创建此驱动程序的发电机\r\n","\r\n            Produce a `.HasValue` and a `.GetValueOrDefault()` for nullable expressions that are neither always null or never null, and functionally equivalent parts for other cases.\r\n            ":"\r\n            生产一个.hasvalue'和``getValueorDefault（）`对于既不总是null或始终为null或永不零的null且在功能上等效的零件，而对于其他情况。\r\n            \r\n","\r\n            A node representing the dispatch by value (equality). This corresponds to a classical C switch\r\n            statement, except that it also handles values of type float, double, decimal, and string.\r\n            ":"\r\n            按值表示调度的节点（平等）。这对应于经典的C开关\r\n            语句，除了它还处理浮点，双，十进制和字符串的类型值。\r\n            \r\n","\r\n            Returns the index of the first node of a specified kind in the node list.\r\n            ":"\r\n            返回节点列表中指定类型的第一个节点的索引。\r\n            \r\n","Nullability of reference types in type of parameter doesn't match partial method declaration.":"参数类型中参考类型的无效性不匹配部分方法声明。\r\n","\r\n              Looks up a localized string similar to Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}'..\r\n            ":"\r\n              查找类似于“ {0}”中参考类型的无效类型的本地化字符串，不匹配隐式实现的成员'{1}'..\r\n            \r\n","\r\n              Looks up a localized string similar to Async-iterator '{0}' has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable<>.GetAsyncEnumerator' will be unconsumed.\r\n            ":"\r\n              查找类似于Async-eterator'{0}'的本地化字符串具有一个或多个类型的“ cancellationToken”的参数，但它们都没有装饰有'EnumeratorCancellation'属性，因此从属于属的'iAsyncenumoss <> iasyncenumoser <> excellation tokeltion参数中.getAsyncenumerator'将不受约束。\r\n            \r\n","Windows PDB writer doesn't support deterministic compilation: '{0}'":"Windows PDB Writer不支持确定性汇编：'{0}'\r\n","\r\n            Returns what symbol(s), if any, the given expression syntax bound to in the program.\r\n            \r\n            An AliasSymbol will never be returned by this method. What the alias refers to will be\r\n            returned instead. To get information about aliases, call GetAliasInfo.\r\n            \r\n            If binding the type name C in the expression \"new C(...)\" the actual constructor bound to\r\n            will be returned (or all constructor if overload resolution failed). This occurs as long as C\r\n            unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple\r\n            types, or C binds to a static class, then type(s) are returned.\r\n            ":"\r\n            返回程序中绑定到的给定表达式语法（如果有的话）。\r\n            \r\n            这种方法将永远不会返回别名鲍尔。别名是什么\r\n            而是返回。要获取有关别名的信息，请致电Getaliasinfo。\r\n            \r\n            如果在“新c（...）”表达式中绑定类型名称c\r\n            将返回（如果过载分辨率失败，则将返回所有构造函数）。这是在C\r\n            明确地与具有构造函数的单一类型结合。如果c模糊地与多个结合\r\n            类型或C结合到静态类，然后返回类型。\r\n            \r\n","\r\n            If this is a lazy nullable type pending resolution, forces this to be resolved as a nullable reference type.\r\n            ":"\r\n            如果这是一种懒惰的类型待处理分辨率，则迫使将其解析为可无效的参考类型。\r\n            \r\n","\r\n            Generate a thread-safe accessor for a WinRT field-like event.\r\n            \r\n            Add:\r\n              return EventRegistrationTokenTable<Event>.GetOrCreateEventRegistrationTokenTable(ref _tokenTable).AddEventHandler(value);\r\n            \r\n            Remove:\r\n              EventRegistrationTokenTable<Event>.GetOrCreateEventRegistrationTokenTable(ref _tokenTable).RemoveEventHandler(value);\r\n            ":"\r\n            为WinRT字段式事件生成线程安全登录器。\r\n            \r\n            添加：\r\n              返回EventRegistrationTokentable <epts> .getOrcreateeVentRegistrationTokentable（ref _tokentable）.addeventHandler（value）;\r\n            \r\n            消除：\r\n              EventRegistrationTokentable <epts> .getOrCreateeVentRegistrationTokentable（ref _tokentable）.removeEventHandler（value）;\r\n            \r\n","\r\n            A utility class that is used to scan a when clause to determine if it might assign a pattern variable\r\n            declared in that case, directly or indirectly. Used to determine if we can skip the allocation of\r\n            pattern-matching temporary variables and use user-declared pattern variables instead, because we can\r\n            conclude that they are not mutated by a when clause while the pattern-matching automaton is running.\r\n            ":"\r\n            用来扫描A子句时用于确定是否可以分配模式变量的实用程序类\r\n            在这种情况下直接或间接声明。用于确定我们是否可以跳过分配\r\n            模式匹配的临时变量并使用用户指定的模式变量，因为我们可以\r\n            得出的结论是，在模式匹配自动机运行时，它们不会被何时突变。\r\n            \r\n","\r\n            Get all instance fields of a struct. They are not necessarily returned in order.\r\n            ":"\r\n            获取结构的所有实例字段。它们不一定按顺序返回。\r\n            \r\n","\r\n            This method boils down to Rewrite(XDocument.Load(fileAttrValue).XPathSelectElements(pathAttrValue)).  \r\n            Everything else is error handling.\r\n            ":"\r\n            此方法归结为重写（xdocument.load（FileatTrvalue）.xpathSelectelements（pathattrvalue））。\r\n            其他一切都是错误处理。\r\n            \r\n","\r\n              Looks up a localized string similar to The switch case has already been handled by a previous case..\r\n            ":"\r\n              查找类似于交换机外壳的本地化字符串已经由以前的情况处理。\r\n            \r\n","Enums cannot contain explicit parameterless constructors":"枚举不能包含明确的无参数构造函数\r\n","\r\n            This only forces binding of attributes that look like they may be forwarded types attributes (syntactically).\r\n            ":"\r\n            这仅将看起来像是转发类型属性的属性的结合（语法上）。\r\n            \r\n","\r\n            Given a variable designation (typically in the left-hand-side of a deconstruction declaration statement),\r\n            figure out its type by looking at the declared symbol of the corresponding variable.\r\n            ":"\r\n            给定一个变量名称（通常在解构声明的左侧中），\r\n            通过查看相应变量的声明符号来弄清楚其类型。\r\n            \r\n","\r\n            Represents a compiler generated synthesized method symbol\r\n            that must be emitted in the compiler generated\r\n            PrivateImplementationDetails class\r\n            ":"\r\n            代表编译器生成的合成方法符号\r\n            必须在编译器生成的编译器中排放\r\n            私有IMPLENTATIONDETAILS类\r\n            \r\n","\r\n            Record declared variables in the pattern.\r\n            ":"\r\n            记录模式中的声明变量。\r\n            \r\n","\r\n            Gets a StatementSyntax the represents the statement to be executed when the condition is true.\r\n            ":"\r\n            获取statementsyntax表示条件为真时要执行的语句。\r\n            \r\n","Cannot await in the body of a finally clause":"无法在最后条款的身体中等待\r\n","\r\n            Members that are not listed directly on their containing type or namespace symbol as they were synthesized in a lowering phase,\r\n            after the symbol has been created.\r\n            ":"\r\n            未直接在其包含类型或名称空间符号上列出的成员，因为它们是在降低阶段合成的，\r\n            创建符号后。\r\n            \r\n","\r\n            The extension method candidate was rejected because type\r\n            inference based on the \"instance\" argument failed.\r\n            ":"\r\n            由于类型\r\n            基于“实例”参数的推论失败。\r\n            \r\n","\r\n              Looks up a localized string similar to The property or indexer '{0}' cannot be used in this context because the set accessor is inaccessible.\r\n            ":"\r\n              在此上下文中查找类似于属性或索引器'{0}'的本地化字符串，因为设置访问者无法访问。\r\n            \r\n"," --\r\n            only a type parameter that is constrained to a non-nullable type can be ":"  -   - \r\n            只有被约束至不可废型类型的类型参数才能是\r\n","\r\n              Looks up a localized string similar to Possibly incorrect assignment to local '{0}' which is the argument to a using or lock statement. The Dispose call or unlocking will happen on the original value of the local..\r\n            ":"\r\n              查找与本地'{0}'可能不正确的分配类似的本地化字符串，这是对使用或锁定语句的参数。处置通话或解锁将发生在本地的原始价值上。\r\n            \r\n","\r\n              Looks up a localized string similar to Debug entry point must be a definition of a method declared in the current compilation..\r\n            ":"\r\n              查找类似于调试入口点的本地化字符串必须是当前汇编中声明的方法的定义。\r\n            \r\n","\r\n              Looks up a localized string similar to Obsolete member '{0}' overrides non-obsolete member '{1}'.\r\n            ":"\r\n              查找类似于过时成员'{0}'的本地化字符串覆盖非观察构件'{1}'。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' cannot be both abstract and sealed.\r\n            ":"\r\n              查找类似于“ {0}”的局部字符串不能既是抽象的又是密封的。\r\n            \r\n","Analyzer":"分析仪\r\n","A generic task-like return type was expected, but the type '{0}' found in 'AsyncMethodBuilder' attribute was not suitable. It must be an unbound generic type of arity one, and its containing type (if any) must be non-generic.":"预计会有一种通用的任务返回类型，但是在“ asyncmethodbuilder”属性中找到的类型“ {0}”不合适。它必须是一种无限的ARITY ONE类型，并且其包含类型（如果有）必须是非类型的。\r\n","\r\n              Looks up a localized string similar to Public signing is not supported for netmodules..\r\n            ":"\r\n              在NetModules中不支持与公共签名类似的本地化字符串。\r\n            \r\n","Specific part of the symbol to which the attributes apply, or ":"属性应用的符号的特定部分，或\r\n","True if member is from the current compilation.":"如果成员来自当前的汇编，则为true。\r\n","\r\n              Looks up a localized string similar to Named argument specifications must appear after all fixed arguments have been specified in a dynamic invocation..\r\n            ":"\r\n              在动态调用中指定了所有固定的参数之后，必须查找类似于命名参数规范的本地化字符串。\r\n            \r\n","'{0}': structs cannot call base class constructors":"'{0}'：structs无法调用基类构造函数\r\n"," on the async method builder\r\n            to make the result available to the caller.\r\n            ":" 在异步方法构建器上\r\n            为了使结果提供给呼叫者。\r\n            \r\n","\r\n            Given a list of viable lookup results (based on the name, arity, and containing symbol),\r\n            attempt to select one.\r\n            ":"\r\n            给定可行的查找结果列表（基于名称，arity和包含符号），\r\n            尝试选择一个。\r\n            \r\n","\r\n            This type provides means for instrumenting compiled methods for dynamic analysis.\r\n            It can be combined with other ":"\r\n            这种类型提供了用于动态分析的仪器编译方法的手段。\r\n            它可以与其他\r\n","Parameters to skip.":"跳过的参数。\r\n","\r\n            Produce a randomly-selected value for testing purposes.\r\n            ":"\r\n            产生随机选择的值以进行测试。\r\n            \r\n","Friend assembly reference '{0}' is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations.":"朋友汇编引用'{0}'无效。坚固的签名组件必须在其内部Visibleto声明中指定公共密钥。\r\n","\r\n            True if this an indexed property; that is, a property with parameters\r\n            within a [ComImport] type.\r\n            ":"\r\n            如果是索引属性，则为thus；也就是说，具有参数的属性\r\n            在[comimport]类型中。\r\n            \r\n","A topologically sorted list of nodes in the decision dag.":"决策DAG中拓扑排序的节点列表。\r\n","Member does not hide an inherited member; new keyword is not required":"成员不会隐藏继承的成员；不需要新关键字\r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 6. Please use language version {1} or greater..\r\n            ":"\r\n              查找类似于功能'{0}'的本地化字符串。\r\n            \r\n","\r\n            Gets all the attribute lists for this named type.  If ":"\r\n            获取此命名类型的所有属性列表。如果\r\n","Nullable reference types":"无效的参考类型\r\n"," can't get out of sync.\r\n            ":" 无法摆脱同步。\r\n            \r\n","Parameter '{0}' must have a non-null value when exiting.":"退出时，参数'{0}'必须具有非零值。\r\n","The type that contains member (member.ContainingType).":"包含成员的类型（成员。脑型类型）。\r\n","\r\n            \r\n             Element-wise conversions occur late, together with the element-wise comparisons. They might not be evaluated.\r\n             ":"\r\n            \r\n             元素转化率与元素的比较一起迟到。他们可能无法评估。\r\n             \r\n","User-defined operator '{0}' must be declared static and public":"用户定义的运算符'{0}必须被声明为静态和公共\r\n","\r\n            If the parameter type is a struct and the default value of the parameter\r\n            is the default value of the struct type or of type parameter type which is \r\n            not known to be a referenced type, then this property will return null.\r\n            ":"\r\n            如果参数类型是struct和参数的默认值\r\n            是结构类型的默认值或类型参数类型的默认值\r\n            不知道是引用类型，那么此属性将返回null。\r\n            \r\n","\r\n            Returns true if the type is output-unsafe or input-unsafe, as defined in the C# spec.\r\n            Roughly, a type is output-unsafe if it could not be the return type of a method and\r\n            input-unsafe if it could not be a parameter type of a method.\r\n            ":"\r\n            如果类型是输出-UNSAFE或INPUT-UNSAFE，则返回true，如C＃Spec中所定义。\r\n            大致，如果不能是方法的返回类型，则可以输出不安全\r\n            输入 - 不安全如果不能是方法的参数类型。\r\n            \r\n","\r\n              Looks up a localized string similar to <null>.\r\n            ":"\r\n              查找类似于<null>的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Field-like event '{0}' cannot be 'readonly'..\r\n            ":"\r\n              查找类似于字段的事件'{0}'不能'readonly'的本地化字符串。\r\n            \r\n","\r\n            True if we should produce instrumentation and sequence points, which we do for a switch statement and a switch expression.\r\n            This affects \r\n            - whether or not we invoke the instrumentation APIs\r\n            - production of sequence points\r\n            - synthesized local variable kind\r\n              The temp variables must be long lived in a switch statement since their lifetime spans across sequence points.\r\n            ":"\r\n            如果我们要产生仪器和序列点，则是正确的，我们为开关语句和开关表达式做到这一点。\r\n            这会影响\r\n             - 我们是否调用仪器API\r\n             - 序列的产生\r\n             - 合成的本地变量类型\r\n              温度变量必须长期存在于开关语句中，因为它们的寿命跨越序列点。\r\n            \r\n","\r\n              Looks up a localized string similar to The constructor call needs to be dynamically dispatched, but cannot be because it is part of a constructor initializer. Consider casting the dynamic arguments..\r\n            ":"\r\n              查找类似于构造函数调用的本地化字符串需要动态调度，但不能是因为它是构造函数初始化器的一部分。考虑施放动态论点。\r\n            \r\n","Synthesized implementation or null if not needed.":"合成实施或无需null。\r\n","\r\n            Produce Environment.CurrentManagedThreadId if available, otherwise CurrentThread.ManagedThreadId\r\n            ":"\r\n            product universion.currentManagedThreadId如果有的话\r\n            \r\n","\r\n            The result of member analysis.\r\n            ":"\r\n            成员分析的结果。\r\n            \r\n","\r\n             True if there is any error.\r\n             ":"\r\n             如果有任何错误，则为正确。\r\n             \r\n","!=":"！=\r\n","\r\n            For test purposes only.\r\n            ":"\r\n            仅出于测试目的。\r\n            \r\n","\r\n              Looks up a localized string similar to The type '{0}' may not be used as a type argument.\r\n            ":"\r\n              查找类似于“ {0}”类型的本地化字符串可能不会用作类型参数。\r\n            \r\n","\r\n              Looks up a localized string similar to 'is' expression's given expression is always of the provided type.\r\n            ":"\r\n              查找类似于“ IS”表达式表达式的本地化字符串始终是提供的类型。\r\n            \r\n","\r\n            Gets the semantic information for an ordering clause in an orderby query clause.\r\n            ":"\r\n            获取订购查询子句中订购子句的语义信息。\r\n            \r\n","\r\n            NOTE:   We have no GetDeclaredSymbol overloads for subtypes of BaseTypeDeclarationSyntax as all of them return a NamedTypeSymbol.\r\n            ":"\r\n            注意：我们没有GetDeclaredSymbol的超载，因为所有底层型larationsyntax的子类型都返回命名typeymbol。\r\n            \r\n","\r\n             Converts the expression for creating a tuple instance into an expression creating a ValueTuple (if short) or nested ValueTuples (if longer).\r\n            \r\n             For instance, for a long tuple we'll generate:\r\n             creationExpression(ctor=largestCtor, args=firstArgs+(nested creationExpression for remainder, with smaller ctor and next few args))\r\n             ":"\r\n             将创建元组实例的表达式转换为创建估值（如果短）或嵌套的估值（如果更长的话）的表达式。\r\n            \r\n             例如，对于长元组，我们将生成：\r\n             creationexpression（ctor = lasterctor，args = firstArgs+（剩余的嵌套创建表达，带有较小的CTOR和接下来的几个args））\r\n             \r\n","\r\n            Based on CompilationPass::CLSReduceSignature.\r\n            ":"\r\n            基于CompilationPass :: ClsreduceSignature。\r\n            \r\n","Called when the visitor visits a FieldDeclarationSyntax node.":"当访问者访问fieldDeclarationsyntax节点时，请致电。\r\n","Use referenced assemblies for resolution.":"使用引用的组件进行分辨。\r\n","Attribute constructor parameter '{0}' is optional, but no default parameter value was specified.":"属性构造函数参数'{0}'是可选的，但是未指定默认参数值。\r\n","\r\n            True if some symbol in the parent hierarchy is known to be Obsolete. Unknown if any\r\n            symbol's Obsoleteness is Unknown. False, if we are certain that no symbol in the parent\r\n            hierarchy is Obsolete.\r\n            ":"\r\n            是的，如果已知父层次结构中的某些符号已过时。未知是否有\r\n            符号的过度是未知的。错误，如果我们确定父母没有符号\r\n            层次结构已过时。\r\n            \r\n","The new trivia to use in the new tree in place of the old\r\n            trivia.":"在新树中使用的新琐事代替旧树\r\n            琐事。\r\n","Constructor '{0}' cannot call itself":"构造函数'{0}'无法调用自己\r\n"," that contains path, line and column information.\r\n            ":" 其中包含路径，行和列信息。\r\n            \r\n","\r\n            Accumulate diagnostics related to the variance safety of an interface method/property parameter.\r\n            ":"\r\n            累积与接口方法/属性参数的方差安全有关的诊断。\r\n            \r\n","Class which represents the syntax node for conditional access expression.":"代表条件访问表达式的语法节点的类。\r\n","\r\n              Looks up a localized string similar to Possible unintended reference comparison; left hand side needs cast.\r\n            ":"\r\n              查找类似于可能意外参考比较的局部字符串；左手需要铸造。\r\n            \r\n","\r\n            If this compilation allows unsafe code (note: allows, not contains), then when we actually emit the assembly/module, \r\n            we're going to synthesize SecurityPermissionAttribute/UnverifiableCodeAttribute.  However, at synthesis time, it is\r\n            too late to report diagnostics or cancel the emit.  Instead, we check for use site errors on the types and members\r\n            we know we'll need at synthesis time.\r\n            ":"\r\n            如果此汇编允许不安全的代码（注意：允许，不包含），那么当我们实际发射汇编/模块时，\r\n            我们将综合SecurityPermissionAttribute/unverifiablecodeattribute。但是，在合成时，它是\r\n            为了报告诊断或取消EMIT的时间太晚。相反，我们在类型和成员的类型上检查使用网站错误\r\n            我们知道我们需要在合成时间。\r\n            \r\n","\r\n            Grab the next character and advance the position.\r\n            ":"\r\n            抓住下一个角色并提高位置。\r\n            \r\n",".\r\n            \r\n            All loops have been converted to gotos and labels by this stage,\r\n            so we do not have to visit them to do so. Similarly all ":"。\r\n            \r\n            所有循环已经在此阶段转换为Gotos和标签，\r\n            因此，我们不必拜访他们。同样\r\n","The character position for determining the enclosing declaration\r\n            scope and accessibility.":"确定封闭声明的角色位置\r\n            范围和可访问性。\r\n","Static classes cannot have instance constructors":"静态类不能具有实例构造函数\r\n","The new rewritten token.":"新的重写令牌。\r\n","\r\n            Expression is the RHS of an assignment operation.\r\n            ":"\r\n            表达是分配操作的RHS。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' is not supported by the language.\r\n            ":"\r\n              该语言不支持查找类似于“ {0}”的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to A default expression introduces a null value for a type parameter..\r\n            ":"\r\n              查找类似于默认表达式的本地化字符串引入了类型参数的空值。\r\n            \r\n","\r\n              Looks up a localized string similar to Provided documentation mode is unsupported or invalid: '{0}'..\r\n            ":"\r\n              查找类似于提供的文档模式的本地化字符串是不支持的或无效的：'{0}'..\r\n            \r\n","Interfaces cannot contain instance fields":"接口不能包含实例字段\r\n"," graph\r\n            visiting each CSharpSyntaxNode and its child SyntaxNodes and ":" 图形\r\n            访问每个csharpsyntaxnode及其子语法词法和\r\n","True if the error/warning should be recorded.":"如果要记录错误/警告，则为正确。\r\n","\r\n            Return a sample pattern that would lead to the given decision dag node.\r\n            ":"\r\n            返回将导致给定决策DAG节点的样本模式。\r\n            \r\n","\r\n            Indicates that the current context allows unsafe constructs.\r\n            ":"\r\n            表示当前上下文允许不安全的构造。\r\n            \r\n","Properties which return by reference must have a get accessor":"通过参考返回的属性必须具有GET登录器\r\n","The last index (non-inclusive)":"最后一个索引（非包容）\r\n","Module initializers":"模块初始化器\r\n","A constant value is expected":"预期恒定值\r\n","\r\n            Given a set of fields, produce an expression that is true when all of the given fields on\r\n            `this` are equal to the fields on ":"\r\n            给定一组字段，产生一个表达式，当所有给定字段上的所有给定字段\r\n            ``这个等于字段\r\n","Member must have a non-null value when exiting.":"退出时成员必须具有非零值。\r\n","'{0}': static classes cannot contain user-defined operators":"'{0}'：静态类不能包含用户定义的运算符\r\n","The return type of a method, delegate, or function pointer cannot be '{0}'":"方法，委托或功能指针的返回类型不能为'{0}'\r\n","The constant '{0}' cannot be marked static":"常数'{0}'不能标记为静态\r\n","\r\n            The type of the property.\r\n            ":"\r\n            属性的类型。\r\n            \r\n","Operator '{0}' is ambiguous on operands '{1}' and '{2}'":"操作员'{0}'对操作数'{1}'和'{2}'是模棱两可的\r\n","\r\n            Is the attribute syntax appearing on a parameter of a partial method implementation part?\r\n            Since attributes are merged between the parts of a partial, we need to look at the syntax where the\r\n            attribute appeared in the source to see if it corresponds to a partial method implementation part.\r\n            ":"\r\n            属性语法是否出现在部分方法实现部分的参数上？\r\n            由于属性是在部分部分之间合并的，因此我们需要查看语法\r\n            属性出现在源中，以查看它是否对应于部分方法实现部分。\r\n            \r\n","#endif directive expected":"#endif指令期望\r\n","Method to invoke.":"方法来调用。\r\n","\r\n            A MergedNamespaceSymbol represents a namespace that merges the contents of two or more other\r\n            namespaces. Any sub-namespaces with the same names are also merged if they have two or more\r\n            instances.\r\n            \r\n            Merged namespaces are used to merge the symbols from multiple metadata modules and the\r\n            source \"module\" into a single symbol tree that represents all the available symbols. The\r\n            compiler resolves names against this merged set of symbols.\r\n            \r\n            Typically there will not be very many merged namespaces in a Compilation: only the root\r\n            namespaces and namespaces that are used in multiple referenced modules. (Microsoft, System,\r\n            System.Xml, System.Diagnostics, System.Threading, ...)\r\n            ":"\r\n            合并的namespaceSymbol代表一个命名空间，该空间合并了两个或更多其他的内容\r\n            名称空间。如果有两个或更多的子名称，则具有相同名称的任何子名称空间也可以合并\r\n            实例。\r\n            \r\n            合并的名称空间用于合并来自多个元数据模块的符号和\r\n            源“模块”到表示所有可用符号的单个符号树中。这\r\n            编译器针​​对这组合并的符号解决名称。\r\n            \r\n            通常，汇编中不会有很多合并的名称空间：只有根\r\n            在多个引用模块中使用的名称空间和名称空间。 （Microsoft，系统，\r\n            system.xml，system.diagnostics，system.threading，...）\r\n            \r\n","Path of the file to which the PE image will be written.":"PE映像要编写的文件的路径。\r\n","\r\n              Looks up a localized string similar to The CallerLineNumberAttribute may only be applied to parameters with default values.\r\n            ":"\r\n              查找类似于CallerlineNumberAttribute的本地化字符串只能应用于具有默认值的参数。\r\n            \r\n","\r\n              Looks up a localized string similar to Type does not implement interface member. Nullability of reference types in interface implemented by the base type doesn't match..\r\n            ":"\r\n              查找类似于类型的本地化字符串未实现接口成员。基本类型实现的接口中参考类型的无效性不匹配。\r\n            \r\n","\r\n             A mapping from the local variable slot to the symbol for the local variable itself.\r\n            \r\n             The first slot, slot 0, is reserved for indicating reachability, so the first tracked variable will\r\n             be given slot 1. When referring to VariableIdentifier.ContainingSlot, slot 0 indicates\r\n             that the variable in VariableIdentifier.Symbol is a root, i.e. not nested within another\r\n             tracked variable. Slots less than 0 are illegal.\r\n             ":"\r\n             从局部变量插槽到局部变量本身的符号的映射。\r\n            \r\n             第一个插槽插槽0保留用于指示可及性，因此第一个跟踪变量将\r\n             给出插槽1.指参考变量识别器。ContainingsLot，插槽0指示\r\n             可变识别符中的变量是词根，即不嵌套在另一个\r\n             跟踪变量。小于0的老虎机是非法的。\r\n             \r\n","\r\n            'true' if non-nullable member warnings should be issued at return points.\r\n            One situation where this is 'false' is when we are analyzing field initializers and there is a constructor symbol in the type.\r\n            ":"\r\n            如果应在退货点发出不可阻止的会员警告，则“正确”。\r\n            当我们分析字段初始化器并且类型中有一个构造函数符号时，这是“错误”的一种情况。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': type used in an async using statement must be implicitly convertible to 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method..\r\n            ":"\r\n              查找类似于“ {0}'：使用语句中使用的类型类型的本地化字符串，必须隐式转换为'system.iasyncdisposable'或实现合适的'disposeasync'方法。\r\n            \r\n","Linked netmodule metadata must provide a full PE image: '{0}'.":"链接的NetModule元数据必须提供完整的PE图像：'{0}'。\r\n","\r\n            Matches an attribute by metadata namespace, metadata type name. Does not load the type symbol for\r\n            the attribute.\r\n            ":"\r\n            匹配元数据名称空间，元数据类型名称的属性。不加载类型符号\r\n            属性。\r\n            \r\n","\r\n             Recursively builds a Conversion object with Kind=Deconstruction including information about any necessary\r\n             Deconstruct method and any element-wise conversion.\r\n            \r\n             Note that the variables may either be plain or nested variables.\r\n             The variables may be updated with inferred types if they didn't have types initially.\r\n             Returns false if there was an error.\r\n             ":"\r\n             递归地构建一个具有KINT =解构的转换对象，包括有关任何必要的信息\r\n             解构方法和任何元素转换。\r\n            \r\n             请注意，变量可以是普通变量或嵌套变量。\r\n             如果变量最初没有类型，则可以使用推断类型进行更新。\r\n             如果有错误，返回false。\r\n             \r\n","\r\n            Get a SemanticModel object that is associated with a type syntax node that did not appear in\r\n            this source code. This can be used to get detailed semantic information about sub-parts\r\n            of a type syntax that did not appear in source code. \r\n            ":"\r\n            获取与未出现在\r\n            此源代码。这可以用来获取有关子部分的详细语义信息\r\n            未出现在源代码中的类型语法。\r\n            \r\n","\r\n             A position is inside a body if it is inside the block or expression\r\n             body. \r\n            \r\n             A position is considered to be inside a block if it is on or after\r\n             the open brace and strictly before the close brace. A position is\r\n             considered to be inside an expression body if it is on or after\r\n             the '=>' and strictly before the semicolon.\r\n             ":"\r\n             如果位置在块内或表达式内部，则位于身体内部\r\n             身体。\r\n            \r\n             如果位置在块上或之后，则认为该位置在块内\r\n             开放式支撑，严格在近距离支撑之前。职位是\r\n             如果在表达主体上，则被认为是在表达主体内部或之后\r\n             “ =>”，严格在半隆之前。\r\n             \r\n","\r\n            Returns true if this symbol represents a partial method definition (the part that specifies a signature but no body).\r\n            ":"\r\n            如果此符号表示部分方法定义（指定签名但没有正体的部分），则返回true。\r\n            \r\n","\r\n            Snapshots are kept in a dictionary of position -> snapshot at that position. These are stored in descending order.\r\n            ":"\r\n            快照保存在该位置的位置->快照字典中。 这些按降序存储。\r\n            \r\n","\r\n              Looks up a localized string similar to Referenced assembly has different culture setting.\r\n            ":"\r\n              查找类似于引用组装的本地化字符串具有不同的文化设置。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use a default literal as an argument to a dynamically dispatched operation..\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法使用默认字体作为动态调度操作的参数。\r\n            \r\n","\r\n            Perform the substitution on the given type.  Each occurrence of the type parameter is\r\n            replaced with its corresponding type argument from the map.\r\n            ":"\r\n            在给定类型上执行替换。每次出现类型参数是\r\n            用地图中的相应类型参数替换。\r\n            \r\n","Creates a new InterpolatedStringTextSyntax instance.":"创建一个新的InterpolatedStringTextSyntax实例。\r\n","\r\n            The \"state\" of the state machine that is the translation of the iterator method.\r\n            ":"\r\n            状态机的“状态”是迭代方法的翻译。\r\n            \r\n","\r\n              Looks up a localized string similar to The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. Nullability of type argument '{3}' doesn't match constraint type '{1}'..\r\n            ":"\r\n              在通用类型或方法'{0}'中查找类似于类型的'{3}'类型的本地化字符串。类型参数的无效性'{3}'不匹配约束类型'{1}'..\r\n            \r\n","\r\n            Figure out if the target runtime supports static abstract members in interfaces.\r\n            ":"\r\n            找出目标运行时是否支持接口中的静态抽象成员。\r\n            \r\n","int M()":"int m（）\r\n"," Flat array of created methods, non-empty if not-null ":" 创建的方法平坦，如果没有空的话\r\n","\r\n            C# language version 7.1\r\n            ":"\r\n            C＃语言版本7.1\r\n            \r\n","\r\n            Specifying the slot manually may be necessary if the symbol is a field,\r\n            in which case ":"\r\n            如果符号是字段，则可能需要手动指定插槽\r\n            在这种情况下\r\n","\r\n              Looks up a localized string similar to The /doc compiler option was specified, but one or more constructs did not have comments..\r\n            ":"\r\n              查找类似于 /DOC编译器选项的本地化字符串，但一个或多个构造没有注释。\r\n            \r\n","\r\n            Gets \"effective\" ref kind of an argument. \r\n            If the ref kind is 'in', marks that that correwsponding parameter was matched with a value\r\n            We need that to detect when there were optional 'in' parameters for which values were not supplied.\r\n            \r\n            NOTE: Generally we know if a formal argument is passed as ref/out/in by looking at the call site. \r\n            However, 'in' may also be passed as an ordinary val argument so we need to take a look at corresponding parameter, if such exists. \r\n            There are cases like params/vararg, when a corresponding parameter may not exist, then val cannot become 'in'.\r\n            ":"\r\n            得到“有效”的裁判。\r\n            如果ref类型是“在”中\r\n            我们需要检测到何时有可选的“在”参数中未提供值。\r\n            \r\n            注意：通常，我们知道是否通过查看呼叫站点将正式的论点作为参考/淘汰/输入传递。\r\n            但是，“ in”也可以作为普通的val参数传递，因此如果存在，我们需要查看相应的参数。\r\n            在某些情况下，当可能不存在相应的参数时，诸如params/vararg之类的情况，则val不能成为“在”中。\r\n            \r\n","Overloaded method '{0}' differing only by unnamed array types is not CLS-compliant":"超载方法'{0}'仅由未命名的数组类型不同，不符合CLS\r\n","\r\n            Returns true if this symbol was declared as requiring an override; i.e., declared with\r\n            the \"abstract\" modifier. Also returns true on a type declared as \"abstract\", all\r\n            interface types, and members of interface types.\r\n            ":"\r\n            如果该符号被宣布为替代，则返回为真；即，宣布\r\n            “抽象”修饰符。还返回在称为“抽象”的类型上返回的\r\n            接口类型和接口类型的成员。\r\n            \r\n","\r\n            Accumulate diagnostics related to the variance safety of a delegate.\r\n            ":"\r\n            积累与代表的方差安全有关的诊断。\r\n            \r\n","-=":" -  =\r\n","A bound node that computes the pointer to the required frame":"计算指针指向所需帧的界点\r\n","\r\n              Looks up a localized string similar to {0}.\r\n            ":"\r\n              查找类似于{0}的局部字符串。\r\n            \r\n","Type conflicts with imported namespace":"类型与导入名称空间的冲突\r\n","\r\n            The singleton NoOp instrumenter, can be used to terminate the chain of ":"\r\n            Singleton Noop仪器可用于终止\r\n","\r\n            Visit a statement.\r\n            ":"\r\n            访问声明。\r\n            \r\n"," it is reversed.\r\n            See ":" 它是逆转的。\r\n            看\r\n","The entire text of the comment including the leading '//' token for single line comments\r\n            or stop or start tokens for multiline comments.":"评论的整个文本，包括单行评论的领先'//'令牌\r\n            或停止或启动令牌以获取多行论。\r\n","\r\n              Looks up a localized string similar to Nullability of reference types in type doesn't match overridden member..\r\n            ":"\r\n              查找类似于类型中参考类型的无效性类似的本地化字符串与不匹配的成员。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' must {2}return by reference to match overridden member '{1}'.\r\n            ":"\r\n              查找类似于“ {0}”必须{2}返回的本地化字符串，以匹配覆盖成员'{1}'。\r\n            \r\n"," is true, the tuple was constructed with an explicit\r\n            'new ValueTuple' call, in which case the 8-th element, if any, represents the 'Rest' field.\r\n            ":" 是的，元组是用明确构建的\r\n            “新的估值”呼叫，在这种情况下，第8-元素（如果有）代表“休息”字段。\r\n            \r\n","\r\n            Given a delegate declaration, get the corresponding type symbol.\r\n            ":"\r\n            给定代表声明，获取相应的类型符号。\r\n            \r\n","\r\n            In regular C#, all field initializers are assignments to fields and the assigned expressions\r\n            may not reference instance members.\r\n            ":"\r\n            在常规C＃中，所有字段初始化器都是对字段和分配的表达式的作业\r\n            可能不会参考实例成员。\r\n            \r\n","\r\n              Looks up a localized string similar to User-defined conversion must convert to or from the enclosing type.\r\n            ":"\r\n              查找类似于用户定义的转换类似的本地化字符串必须转换为封闭类型。\r\n            \r\n","\r\n            Returns the owner of attributes that apply to this symbol.\r\n            ":"\r\n            返回适用于此符号的属性的所有者。\r\n            \r\n","\r\n              Looks up a localized string similar to Member '{0}' overrides obsolete member '{1}'. Add the Obsolete attribute to '{0}'..\r\n            ":"\r\n              查找类似于成员'{0}'覆盖过时成员'{1}'的本地化字符串。将过时的属性添加到'{0}'..\r\n            \r\n","\r\n            Used to parse normal blocks that appear inside method bodies.  For the top level block\r\n            of a method/accessor use ":"\r\n            用于解析出现在方法体内的正常块。对于顶级块\r\n            方法/登录器的使用\r\n","\r\n              Looks up a localized string similar to Syntax error, '{0}' expected.\r\n            ":"\r\n              查找类似于语法错误'{0}'预期的本地化字符串。\r\n            \r\n","'{0}' does not have a suitable static 'Main' method":"'{0}'没有合适的静态'主'方法\r\n","\r\n            Returns child node or token that contains given position.\r\n            ":"\r\n            返回包含给定位置的子节点或令牌。\r\n            \r\n"," state; if the delegate throws\r\n            an exception, it'll be allowed to propagate on the thread, crashing the process.\r\n            ":" 状态;如果代表投掷\r\n            一个例外，将允许在线程上传播，从而崩溃。\r\n            \r\n","The type of the input expression":"输入表达式的类型\r\n","Conversion to be performed.":"要执行的转换。\r\n","Gets the open paren keyword.":"获取Open Paren关键字。\r\n","\r\n              Looks up a localized string similar to Friend access was granted by '{0}', but the public key of the output assembly ('{1}') does not match that specified by the InternalsVisibleTo attribute in the granting assembly..\r\n            ":"\r\n              查找类似于朋友访问的本地化字符串由“ {0}”授予，但是输出组件（'{1}'）的公共密钥与授予程序集中的InternalSvisibleto属性指定的公共密钥不匹配。\r\n            \r\n","Array size cannot be specified in a variable declaration (try initializing with a 'new' expression)":"数组大小不能在变量声明中指定（尝试使用“新”表达式初始化）\r\n","Gets the identifier name.":"获取标识符名称。\r\n","\r\n            Should only be used with scopes that could declare local functions.\r\n            ":"\r\n            仅应与可以声明本地功能的范围一起使用。\r\n            \r\n","\r\n            Parse an element of a cref parameter list.\r\n            ":"\r\n            解析CREF参数列表的元素。\r\n            \r\n","\r\n            We may have ended up with a closure environment containing only\r\n            'this'. This is basically equivalent to the containing type itself,\r\n            so we can inline the 'this' parameter into environments that\r\n            reference this one or lower closures directly onto the containing\r\n            type.\r\n            ":"\r\n            我们可能最终只有一个包含的封闭环境\r\n            '这个'。这基本上等同于包含类型本身，\r\n            因此，我们可以将“此”参数插入到环境中\r\n            将此一个或下关闭直接引用到包含\r\n            类型。\r\n            \r\n","Too many characters in character literal":"角色字面字符太多\r\n","\r\n              Looks up a localized string similar to The modifier 'abstract' is not valid on fields. Try using a property instead..\r\n            ":"\r\n              查找类似于修饰符“摘要”的本地化字符串在字段上无效。尝试使用属性。\r\n            \r\n"," rules.\r\n            ":" 规则。\r\n            \r\n","The range variable '{0}' has already been declared":"范围变量'{0}'已经声明了\r\n","\r\n              Looks up a localized string similar to Invalid anonymous type member declarator. Anonymous type members must be declared with a member assignment, simple name or member access..\r\n            ":"\r\n              查找类似于无效的匿名类型成员声明器的本地化字符串。必须使用成员分配，简单名称或成员访问声明匿名类型成员。\r\n            \r\n","Async lambda expression converted to a 'Task' returning delegate cannot return a value. Did you intend to return 'Task<T>'?":"异步lambda表达式转换为“任务”返回委托无法返回值。您打算返回“任务<t>”？\r\n","#r directive.":"#R指令。\r\n","\r\n            Binds the CrefSyntax expression in the context of the specified location and gets symbol information.\r\n            This method is used to get symbol information about an expression that did not actually\r\n            appear in the source code.\r\n            ":"\r\n            在指定位置的上下文中绑定crefsyntax表达式，并获取符号信息。\r\n            此方法用于获取有关表达式的符号信息\r\n            出现在源代码中。\r\n            \r\n","\r\n            This is a lossy conversion; it is not possible to recover the original ":"\r\n            这是一个有损的转换；无法恢复原始\r\n","\r\n            Returns true if syntax form is OK (so no errors were reported)\r\n            ":"\r\n            如果语法表格正常，则返回true（没有报告错误）\r\n            \r\n","Called when the visitor visits a NullableTypeSyntax node.":"当访问者访问nullableTypesyntax节点时调用。\r\n","Attribute '{0}' is ignored when public signing is specified.":"指定公共签名时，属性'{0}'被忽略。\r\n","\r\n              Looks up a localized string similar to Type byte, sbyte, short, ushort, int, uint, long, or ulong expected.\r\n            ":"\r\n              查找类似于字节，sbyte，short，ushort，int，uint，long或ulong期望的局部字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Call to non-readonly member '{0}' from a 'readonly' member results in an implicit copy of '{1}'..\r\n            ":"\r\n              从'readonly'成员中查找类似于调用非读取成员'{0}'的本地化字符串，从而导致“ {1}” ..的隐式副本。\r\n            \r\n","\r\n            Get a symbol of constructed anonymous type property by property index\r\n            ":"\r\n            通过属性索引获取构造的匿名类型属性的象征\r\n            \r\n","The assembly {0} does not contain any analyzers.":"汇编{0}不包含任何分析仪。\r\n","\r\n              Looks up a localized string similar to SearchCriteria is expected..\r\n            ":"\r\n              查找与搜索标准类似的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Ambiguous reference in cref attribute: '{0}'. Assuming '{1}', but could have also matched other overloads including '{2}'..\r\n            ":"\r\n              查找类似于CREF属性中的模棱两可的引用的本地化字符串：'{0}'。假设'{1}'，但也可以匹配其他过载，包括'{2}'..\r\n            \r\n","The side of the test handling higher values. The false side for < and <=, the true side for > and >=.":"测试的侧面处理较高的值。 <and <=，> and> =的false侧。\r\n","A variable set to the first expression in the left that isn't a declaration or discard":"左侧第一个表达式的变量设置不是声明或丢弃\r\n","Attribute parameter '{0}' must be specified.":"必须指定属性参数'{0}'。\r\n","A syntax node that represents a parsed method declaration. This method should not be\r\n            present in the syntax tree associated with this object, but must have identical signature to the method containing\r\n            the given ":"表示解析方法声明的语法节点。此方法不应该是\r\n            存在与该对象关联的语法树中，但必须与包含的方法具有相同的签名\r\n            给定\r\n","SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.":"语法的语法列表代表隐式数组创建表达式中的逗号。\r\n","Nullable value type may be null.":"无效的值类型可能为null。\r\n","The symbols array containing both the latent and implementing declaration":"符号阵列包含潜在和实施声明\r\n","the method to be analyzed":"要分析的方法\r\n","\r\n              Looks up a localized string similar to collection initializer.\r\n            ":"\r\n              查找类似于Collection Initializer的本地化字符串。\r\n            \r\n","namespace alias qualifier":"名称空间别名预选赛\r\n","invariantly":"不变\r\n","\r\n            Method that is called from the CachingLookup to get all child names. Looks in all\r\n            constituent namespaces.\r\n            ":"\r\n            从缓存lookup调用以获取所有子名称的方法。总的来说\r\n            组成名称空间。\r\n            \r\n","Class which represents the syntax node for a base expression.":"代表基本表达式的语法节点的类。\r\n","\r\n            Get the symbol for a special member. The use of this method to get a special member\r\n            that does not exist will result in an exception of type MissingPredefinedMember being thrown\r\n            containing an appropriate diagnostic for the caller to report.\r\n            ":"\r\n            获取特殊成员的符号。使用此方法获得特殊会员\r\n            这不存在将导致抛出类型的类型缺失定义的人\r\n            包含适当的诊断供呼叫者报告。\r\n            \r\n","Digit separators after base specifier":"基本指定符之后的数字分离器\r\n","\r\n              Looks up a localized string similar to The parameter type for ++ or -- operator must be the containing type.\r\n            ":"\r\n              查找类似于++或 - 运算符的参数类型的本地化字符串必须是包含类型。\r\n            \r\n","\r\n            Returns the scope to which a local can \"escape\" ref assignments or other form of aliasing\r\n            Makes sense only for locals with formal scopes - i.e. source locals\r\n            ":"\r\n            返回本地可以“逃脱”参考作业或其他形式的混叠的范围\r\n            仅对于具有正式范围的当地人才有意义 - 即来源当地人\r\n            \r\n","\r\n            Lookup declaration for FX type in this Assembly.\r\n            ":"\r\n            该组件中FX类型的查找声明。\r\n            \r\n","\r\n             The new ":"\r\n             新的\r\n","\r\n              Looks up a localized string similar to An instance of analyzer {0} cannot be created from {1} : {2}..\r\n            ":"\r\n              查找类似于分析仪实例{0}实例的本地化字符串，无法从{1}中创建：{2} ..\r\n            \r\n","Assignment in conditional expression is always constant":"条件表达中的分配始终是恒定的\r\n","\r\n              Looks up a localized string similar to XML comment has syntactically incorrect cref attribute.\r\n            ":"\r\n              查找类似于XML注释的本地化字符串的句法错误的CREF属性。\r\n            \r\n","Block bodies and expression bodies cannot both be provided.":"不能提供块体和表达体。\r\n","Sealed record ToString":"密封的记录to\r\n"," with custom modifiers copied from ":" 使用自定义修饰符复制\r\n","\r\n            The type parameter to use for determining constraints. If there is a base\r\n            method that the owner method is overriding, the corresponding type\r\n            parameter on that method is used. Otherwise, the result is null.\r\n            ":"\r\n            用于确定约束的类型参数。如果有基地\r\n            所有者方法覆盖的方法，相应的类型\r\n            使用该方法上的参数。否则，结果为null。\r\n            \r\n","Type type of the input expression (before nullable analysis).\r\n            Used to determine which types can contain null.":"输入表达式的类型类型（可为空分析之前）。\r\n            用于确定哪些类型可以包含null。\r\n","\r\n            Gets the rewritten attribute constructor arguments, i.e. the arguments\r\n            are in the order of parameters, which may differ from the source\r\n            if named constructor arguments are used.\r\n            \r\n            For example:\r\n                void Foo(int x, int y, int z, int w = 3);\r\n            \r\n                Foo(0, z: 2, y: 1);\r\n                \r\n                Arguments returned: 0, 1, 2, 3\r\n            ":"\r\n            获取重写的属性构造函数参数，即参数\r\n            按照参数顺序，可能与源不同\r\n            如果使用命名的构造函数。\r\n            \r\n            例如：\r\n                void foo（int x，int y，int z，int w = 3）;\r\n            \r\n                foo（0，z：2，y：1）;\r\n                \r\n                返回的论点：0、1、2、3\r\n            \r\n","\r\n            Returns True when field symbol is not mapped directly to a field in the underlying tuple struct.\r\n            ":"\r\n            当未直接映射到基础元组结构中的字段时，返回true。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': cannot override because '{1}' is not a function.\r\n            ":"\r\n              查找类似于'{0}'：不能覆盖的本地化字符串，因为'{1}'不是函数。\r\n            \r\n","Should interop types be embedded in the created assembly?":"Interop类型是否应该嵌入创建的组件中？\r\n","\r\n              Looks up a localized string similar to Cannot pass '{0}' as a ref or out argument because it is a '{1}'.\r\n            ":"\r\n              查找类似于不能传递'{0}'的本地化字符串作为ref或out参数，因为它是'{1}'。\r\n            \r\n","'{0}': type used in an asynchronous using statement must be implicitly convertible to 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method.":"'{0}'：使用语句中的异步中使用的类型必须隐式转换为'system.iasyncdisposable'或实现合适的“ disposeasync”方法。\r\n","The label '{0}' is a duplicate":"标签'{0}'是重复\r\n","\r\n            Represents a reference to another C# compilation. \r\n            ":"\r\n            表示对另一个C＃汇编的引用。\r\n            \r\n","\r\n            Forces binding and decoding of attributes.\r\n            ":"\r\n            属性结合和解码的力。\r\n            \r\n","Multiple assemblies with equivalent identity have been imported: '{0}' and '{1}'. Remove one of the duplicate references.":"已导入具有等效身份的多个组件：'{0}'和'{1}'。删除重复引用之一。\r\n","\r\n            Some kinds of methods are not considered to be hideable by certain kinds of members.\r\n            Specifically, methods, properties, and types cannot hide constructors, destructors,\r\n            operators, conversions, or accessors.\r\n            ":"\r\n            某些类型的成员不认为某些方法可以掩盖。\r\n            具体而言，方法，属性和类型不能隐藏构造函数，毁灭者，\r\n            操作员，转换或登录器。\r\n            \r\n","\r\n            Lower a foreach loop that will enumerate a multi-dimensional array.\r\n            \r\n            A[...] a = x;\r\n            int q_0 = a.GetUpperBound(0), q_1 = a.GetUpperBound(1), ...;\r\n            for (int p_0 = a.GetLowerBound(0); p_0 <= q_0; p_0 = p_0 + 1)\r\n                for (int p_1 = a.GetLowerBound(1); p_1 <= q_1; p_1 = p_1 + 1)\r\n                    ...\r\n                        {\r\n                            V v = (V)a[p_0, p_1, ...];   /* OR */   (D1 d1, ...) = (V)a[p_0, p_1, ...];\r\n                            /* body */\r\n                        }\r\n            ":"\r\n            较低的foreach循环，将列举多维阵列。\r\n            \r\n            a [...] a = x;\r\n            int q_0 = a.getUpperBound（0），q_1 = a.getUpperBound（1），...;\r\n            for（int p_0 = a.getLowerBound（0）; p_0 <= q_0; p_0 = p_0 + 1）\r\n                for（int p_1 = a.getlowerbound（1）; p_1 <= q_1; p_1 = p_1 + 1）\r\n                    ...\r\n                        {\r\n                            v v =（v）a [p_0，p_1，...]; / *或 */（d1 d1，...）=（v）a [p_0，p_1，...];\r\n                            /* 身体 */\r\n                        }\r\n            \r\n","The field symbols that were declared.":"声明的字段符号。\r\n","\r\n            The checks here are equivalent to StatementBinder::CheckForUnobservedAwaitable() in the native compiler.\r\n            ":"\r\n            此处的检查等同于本机编译器中的SpatectBinder :: CheckForunoBservedAaitable（）。\r\n            \r\n","Overloadable operator expected":"预期可超载的操作员\r\n","\r\n            Subclasses may override LeaveRegion to perform any action at the end of the region.\r\n            ":"\r\n            子类可能覆盖莱维利奥以在该地区尽头执行任何动作。\r\n            \r\n","\r\n            Return true if the given type contains the specified type parameter.\r\n            ":"\r\n            如果给定类型包含指定的类型参数，则返回true。\r\n            \r\n","\r\n            Produce a 'logical and' operation that is clearly irrefutable (":"\r\n            产生显然无法理解的“逻辑和”操作（\r\n","\r\n              Looks up a localized string similar to '{0}': base type '{1}' is not CLS-compliant.\r\n            ":"\r\n              查找类似于'{0}'：基本类型'{1}'的本地化字符串不合同。\r\n            \r\n","\r\n            NOTE: every struct has a public parameterless constructor either user-defined or default one\r\n            ":"\r\n            注意：每个结构都有一个无公共参数构造函数用户定义或默认一个\r\n            \r\n","In order to be applicable as a short circuit operator a user-defined logical operator ('{0}') must have the same return type and parameter types":"为了作为短路运算符，用户定义的逻辑运算符（'{0}'）必须具有相同的返回类型和参数类型\r\n","\r\n            Given a local function declaration syntax, get the corresponding symbol.\r\n            ":"\r\n            给定局部函数声明语法，获取相应的符号。\r\n            \r\n","Expressions and statements can only occur in a method body":"表达式和陈述只能发生在方法主体中\r\n"," for an explanation.\r\n            ":" 用于解释。\r\n            \r\n","Cannot create an instance of the variable type '{0}' because it does not have the new() constraint":"无法创建变量类型'{0}'的实例，因为它没有新（）约束\r\n","The params parameter must be a single dimensional array":"参数必须是单个维数组\r\n","\r\n            A member was found, but it was not a method\r\n            ":"\r\n            找到了一个成员，但这不是一种方法\r\n            \r\n","\r\n            An abstract flow pass that takes some shortcuts in analyzing finally blocks, in order to enable\r\n            the analysis to take place without tracking exceptions or repeating the analysis of a finally block\r\n            for each exit from a try statement.  The shortcut results in a slightly less precise\r\n            (but still conservative) analysis, but that less precise analysis is all that is required for\r\n            the language specification.  The most significant shortcut is that we do not track the state\r\n            where exceptions can arise.  That does not affect the soundness for most analyses, but for those\r\n            analyses whose soundness would be affected (e.g. \"data flows out\"), we track \"unassignments\" to keep\r\n            the analysis sound.\r\n            ":"\r\n            一个抽象流通过，在分析最终封锁时需要一些快捷方式，以启用\r\n            进行的分析而无需跟踪例外或重复最终阻止的分析\r\n            对于试用语句的每个退出。快捷键导致精确略微降低\r\n            （但仍然是保守的）分析，但是，不太精确的分析是所有需要的\r\n            语言规范。最重要的快捷方式是我们不追踪国家\r\n            可能会出现例外。这不会影响大多数分析的健全性，而是对那些分析的\r\n            其健全性会受到影响的分析（例如，“数据流出”），我们跟踪“裁员”以保持\r\n            分析声音。\r\n            \r\n","Creates a new OrderByClauseSyntax instance.":"创建一个新的OrderByClausesyntax实例。\r\n"," and we have an IGoo with a different arity or accessibility \r\n            (e.g. ":" 而且我们有一个具有不同ARITY或可访问性的Igoo\r\n            （例如。\r\n","Creates a new CrefBracketedParameterListSyntax instance.":"创建一个新的CrefbracketedParameterListsyntax实例。\r\n","Since this is an async method, the return expression must be of type '{0}' rather than 'Task<{0}>'":"由于这是一个异步方法，因此返回表达式必须是类型'{0}'而不是'task <{0}>'\r\n","Object and collection initializer expressions may not be applied to a delegate creation expression":"对象和收集初始化器表达式不得应用于代表创建表达式\r\n","\r\n            The variable that captures the result of a pattern matching operation like \"i\" in \"expr is int i\"\r\n            ":"\r\n            捕获模式匹配操作结果的变量，例如“ expr is int i”中的“ i”\r\n            \r\n","Features:":"特征：\r\n","\r\n            We need to be able to differentiate between a FunctionPointer used as a type and a function pointer used\r\n            as a StandaloneMethodSig. To do this, we wrap the ":"\r\n            我们需要能够区分用作类型和使用的功能指针的功能pointer\r\n            作为独立术。为此，我们包裹\r\n","\r\n            Returns substitution currently used by the rewriter for a placeholder node.\r\n            Each occurrence of the placeholder node is replaced with the node returned.\r\n            Throws if there is no substitution.\r\n            ":"\r\n            返回替代者目前由占位符节点使用的替代。\r\n            占位符节点的每个出现都被返回的节点替换。\r\n            如果没有替代，则投掷。\r\n            \r\n","Cannot apply indexing with [] to an expression of type '{0}'":"不能将索引[]应用于类型'{0}'的表达式\r\n","\r\n            In the CLI, accessors are just regular methods and their overriding/hiding rules are the same as for\r\n            regular methods.  In C#, however, accessors are intimately connected with their corresponding events.\r\n            Rather than walking up the type hierarchy from the containing type of this accessor, looking for members\r\n            with the same name, MakeEventAccessorOverriddenOrHiddenMembers delegates to the associated event.\r\n            For an accessor to hide a member, the hidden member must be a corresponding accessor on a event hidden\r\n            by the associated event.  For an accessor to override a member, the overridden member must be a\r\n            corresponding accessor on a event (directly or indirectly) overridden by the associated event.\r\n            ":"\r\n            在CLI中，访问者只是常规方法，其压倒/隐藏规则与\r\n            常规方法。但是，在C＃中，登录器与相应的事件密切相关。\r\n            而不是走上包含此登录类型的类型层次结构，而是寻找成员\r\n            MakeeventAccessoroverridendorhiddenmbers以相同的名字代表了相关事件。\r\n            要使登录器隐藏成员，隐藏的成员必须是隐藏事件的相应访问者\r\n            通过相关事件。对于替补成员的登记器，覆盖成员必须是\r\n            事件（直接或间接）被关联事件覆盖的事件上的对应访问者。\r\n            \r\n","\r\n              Looks up a localized string similar to foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance definition for '{1}'. Did you mean 'await foreach' rather than 'foreach'?.\r\n            ":"\r\n              查找类似于foreach语句的本地化字符串无法在类型'{0}'的变量上操作，因为'{0}'不包含'{1}'的公共实例定义。您的意思是“等待“ foreach”而不是“ foreach”？\r\n            \r\n","\r\n            No tests to be performed; the result is false (failure).\r\n            ":"\r\n            没有测试要执行；结果是错误（失败）。\r\n            \r\n","$@":"$@\r\n","\r\n            Returns the parameter corresponding to the given argument index.\r\n            ":"返回与给定参数索引相对应的参数。\r\n            \r\n","\r\n            There is some similarity between this member and OverriddenOrHiddenMembersHelpers.FindOverriddenOrHiddenMembersInType.\r\n            When making changes to this member, think about whether or not they should also be applied in MemberSymbol.\r\n            One key difference is that custom modifiers are considered when looking up overridden members, but\r\n            not when looking up implicit implementations.  We're preserving this behavior from Dev10.\r\n            ":"\r\n            该成员和覆盖式Hiddenmembershelpers.findoverridendorhiddenmermbersIntype之间有一些相似之处。\r\n            在更改该会员时，请考虑是否也应将其应用于会员符号。\r\n            一个关键区别是，在查找覆盖成员时会考虑自定义修饰符，但是\r\n            当查找隐式实现时而不是。我们正在从Dev10中保存这种行为。\r\n            \r\n","\r\n            This enumeration is parallel to and almost the same as the CandidateReason enumeration.\r\n            Changes to one should usually result in changes to the other.\r\n            \r\n            There are two enumerations because:\r\n              1) CandidateReason in language-independent, while this enum is language specific.\r\n              2) The name \"CandidateReason\" didn't make much sense in the way LookupResultKind is used internally.\r\n              3) Viable isn't used in CandidateReason, but we need it in LookupResultKind, and there isn't a \r\n                 a way to have internal enumeration values.\r\n            ":"\r\n            这种枚举与候选季节平行，几乎相同。\r\n            一个更改通常应导致另一个变化。\r\n            \r\n            有两个枚举，因为：\r\n              1）与语言无关的候选人季节，而该枚举是特定于语言的。\r\n              2）“ Candidatereason”这个名字在内部使用LookupResultKind的方式上没有多大意义。\r\n              3）在候选季季中不使用可行，但我们在LookupResultkind中需要它，也没有\r\n                 具有内部枚举值的一种方法。\r\n            \r\n","\r\n            The candidate member was rejected because it a constraint on a type parameter was not satisfied.\r\n            ":"\r\n            候选人成员被拒绝，因为不满足对类型参数的约束。\r\n            \r\n"," Anonymous type location ":" 匿名类型位置\r\n","\r\n            array.\r\n            ":"\r\n            大批。\r\n            \r\n"," to speed up type reference resolution\r\n            for metadata coming from this module. The map is lazily populated\r\n            as we load types from the module.\r\n            ":" 加快类型参考分辨率\r\n            对于来自该模块的元数据。该地图懒洋洋\r\n            当我们从模块加载类型时。\r\n            \r\n","Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes).":"类型的参数类型不匹配被压制成员（可能是由于无效属性）。\r\n","\r\n              Looks up a localized string similar to Source file references are not supported..\r\n            ":"\r\n              查找与源文件参考类似的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to The enumerator name '{0}' is reserved and cannot be used.\r\n            ":"\r\n              查找类似于枚举器名称'{0}'的本地化字符串已保留，无法使用。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid return type in XML comment cref attribute.\r\n            ":"\r\n              查找类似于XML注释CREF属性中无效返回类型的本地化字符串。\r\n            \r\n","'{0}': user-defined conversions to or from the dynamic type are not allowed":"'{0}'：不允许使用动态类型的用户定义的转换\r\n","\r\n            A struct that combines a single type with annotations\r\n            ":"\r\n            将单一类型与注释相结合的结构\r\n            \r\n"," within constraint types according to the IsValueType state inferred\r\n            from the constraint types.\r\n            ":" 根据ISVALUETYPE状态推断，在约束类型中\r\n            来自约束类型。\r\n            \r\n","The generic type or method.":"通用类型或方法。\r\n","The compiler implicitly widened and sign-extended a variable, and then used the resulting value in a bitwise OR operation. This can result in unexpected behavior.":"编译器隐式扩大并扩展了一个变量，然后在位或操作中使用了结果值。这可能导致意外的行为。\r\n","\r\n            For the purpose of escape verification we operate with the depth of local scopes.\r\n            The depth is a uint, with smaller number representing shallower/wider scopes.\r\n            The 0 and 1 are special scopes - \r\n            0 is the \"external\" or \"return\" scope that is outside of the containing method/lambda. \r\n              If something can escape to scope 0, it can escape to any scope in a given method or can be returned.\r\n            1 is the \"parameter\" or \"top\" scope that is just inside the containing method/lambda. \r\n              If something can escape to scope 1, it can escape to any scope in a given method, but cannot be returned.\r\n            n + 1 corresponds to scopes immediately inside a scope of depth n. \r\n              Since sibling scopes do not intersect and a value cannot escape from one to another without \r\n              escaping to a wider scope, we can use simple depth numbering without ambiguity.\r\n            ":"\r\n            为了进行逃生验证，我们以当地范围的深度运行。\r\n            深度是UINT，数量较小，代表较浅/更宽的范围。\r\n            0和1是特殊范围 - \r\n            0是包含方法/lambda之外的“外部”或“返回”范围。\r\n              如果某些东西可以逃脱到范围0，则可以在给定方法中逃脱到任何范围，也可以返回。\r\n            1是仅包含方法/lambda内部的“参数”或“顶部”范围。\r\n              如果某种东西可以逃到范围1，它可以逃到给定方法中的任何范围，但不能返回。\r\n            n + 1对应于深度n范围内的范围。\r\n              由于兄弟姐妹范围不会相交，并且一个价值无法在没有的情况下逃脱\r\n              逃到更广泛的范围，我们可以使用简单的深度编号而不会含糊不清。\r\n            \r\n","\r\n              Looks up a localized string similar to The first operand of an 'is' or 'as' operator may not be a lambda expression, anonymous method, or method group..\r\n            ":"\r\n              查找类似于“ IS”或“”操作员的局部字符串类似于“操作员”可能不是lambda表达式，匿名方法或方法组。\r\n            \r\n","\r\n            Metadata types need to compute their base types in order to know their TypeKinds, and that can lead\r\n            to cycles if base types are already being computed.\r\n            ":"\r\n            元数据类型需要计算其基本类型才能知道他们的类型，这可以领导\r\n            如果已经计算了基本类型，请循环。\r\n            \r\n"," for an initialization of a generated property based on record parameter.\r\n            ":" 用于基于记录参数的生成属性的初始化。\r\n            \r\n","\r\n            Corresponds to ":"\r\n            对应于\r\n","Called when the visitor visits a CrefParameterSyntax node.":"当访客访问crefparametersyntax节点时，请致电。\r\n","\r\n            This node represents an out or deconstruction variable.\r\n            It is only used temporarily during initial binding.\r\n            ":"\r\n            该节点代表一个或解构变量。\r\n            它仅在初始结合期间暂时使用。\r\n            \r\n","The analyzed argument list":"分析的参数列表\r\n","Alias '{0}' conflicts with {1} definition":"别名'{0}'与{1}定义冲突\r\n","\r\n            Async methods have both a return type (void, Task, or Task<T>) and a 'result' type, which is the\r\n            operand type of any return expressions in the async method. The result type is void in the case of\r\n            Task-returning and void-returning async methods, and T in the case of Task<T>-returning async\r\n            methods.\r\n            \r\n            System.Runtime.CompilerServices provides a collection of async method builders that are used in the\r\n            generated code of async methods to create and manipulate the async method's task. There are three\r\n            distinct async method builder types, one of each async return type: AsyncVoidMethodBuilder,\r\n            AsyncTaskMethodBuilder, and AsyncTaskMethodBuilder<T>. \r\n            \r\n            AsyncMethodBuilderMemberCollection provides a common mechanism for accessing the well-known members of\r\n            each async method builder type. This avoids having to inspect the return style of the current async method\r\n            to pick the right async method builder member during async rewriting.\r\n            ":"\r\n            异步方法既具有返回类型（void，task或task <t>），又有“结果”类型，即\r\n            异步方法中任何返回表达式的操作数类型。结果类型在\r\n            在任务<t>返回异步的情况下，返回任务和无效的异步方法，t\r\n            方法。\r\n            \r\n            system.runtime.compilerServices提供了在该中使用的异步方法构建器的集合\r\n            生成异步方法的代码来创建和操纵异步方法的任务。有三种\r\n            独特的异步方法构建器类型，每种异步返回类型之一：asyncvoidMethodBuilder，\r\n            AsynctaskMethodbuilder和AsynctaskMethodBuilder <T>。\r\n            \r\n            AsyncmethodbuilderMemberCollection提供了一种常见的机制，可以访问众所周知的成员\r\n            每个异步方法构建器类型。这避免了必须检查当前异步方法的返回样式\r\n            在异步重写期间选择正确的异步方法构建器成员。\r\n            \r\n","\r\n            This portion of the binder converts an AwaitExpressionSyntax into a BoundExpression\r\n            ":"\r\n            粘合剂的这一部分将AwaiteXpressynntax转换为界表达\r\n            \r\n","Converting method group to non-delegate type":"将方法组转换为非贵族类型\r\n","\r\n              Looks up a localized string similar to An expression tree may not contain an unsafe pointer operation.\r\n            ":"\r\n              查找类似于表达树的本地化字符串可能不包含不安全的指针操作。\r\n            \r\n","(a, ...) == (...)":"（a，...）==（...）\r\n","\r\n            Creates a new compilation without the old tree but with the new tree.\r\n            ":"\r\n            创建一个没有旧树的新汇编，但带有新树。\r\n            \r\n","\r\n              Looks up a localized string similar to Member hides inherited member; missing new keyword.\r\n            ":"\r\n              查找类似于成员隐藏成员的局部字符串；缺少新关键字。\r\n            \r\n","\r\n            The nullable annotations that can apply in source.\r\n            ":"\r\n            可用于源中的无效注释。\r\n            \r\n","\r\n            The sequence of groups of TypeDef row ids for types contained within the namespace, \r\n            recursively including those from nested namespaces. The row ids are grouped by the \r\n            fully-qualified namespace name case-sensitively. There could be multiple groups \r\n            for each fully-qualified namespace name. The groups are sorted by their \r\n            key in case-sensitive manner. Empty string is used as namespace name for types \r\n            immediately contained within Global namespace. Therefore, all types in this namespace, if any, \r\n            will be in several first IGroupings.\r\n            \r\n            This member is initialized by constructor and is cleared in EnsureAllMembersLoaded \r\n            as soon as symbols for children are created.\r\n            ":"\r\n            命名空间中包含的类型类型的Typedef行ID组序列，\r\n            递归包括来自嵌套名称空间的。行ID由\r\n            完全合格的名称空间案例敏感。可能有多个组\r\n            对于每个符合条件的名称空间名称。小组被他们的分类\r\n            以情况敏感的方式关键。空字符串用作类型的名称名称\r\n            立即包含在全球名称空间中。因此，此名称空间中的所有类型（如果有）\r\n            将在几个第一个Igroupings中。\r\n            \r\n            该构件由构造函数初始化，并在neareallembers中清除\r\n            创建儿童符号后。\r\n            \r\n","Type cannot be used in this context because it cannot be represented in metadata.":"在这种情况下不能使用类型，因为它不能在元数据中表示。\r\n","\r\n              Looks up a localized string similar to '{0}' cannot implement interface member '{1}' in type '{2}' because feature '{3}' is not available in C# {4}. Please use language version '{5}' or greater..\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串，无法在类型'{2}'中实现接口成员'{1}'，因为功能'{3}'在c＃{4}中不可用。请使用语言版本'{5}'或更大。\r\n            \r\n","\r\n            Given a SynthesizedSealedPropertyAccessor (an accessor with a reference to the accessor it overrides),\r\n            construct a BoundBlock body.\r\n            ":"\r\n            给定一个合成的SealedPropertyAccessor（带有登录器覆盖的登录器），\r\n            构建一个边界的身体。\r\n            \r\n","\r\n            True if this symbol has been marked with the ":"\r\n            如果已标记了此符号\r\n","\r\n              Looks up a localized string similar to Instance of type '{0}' cannot be used inside an anonymous function, query expression, iterator block or async method.\r\n            ":"\r\n              查找类似于类型的'{0}'实例的本地化字符串，无法在匿名函数，查询表达式，迭代块或异步方法中使用。\r\n            \r\n","foreach iteration variable":"foreach迭代变量\r\n","Called when the visitor visits a DefaultConstraintSyntax node.":"当访问者访问DefaultConstraintsyntax节点时，请致电。\r\n","\r\n             Produce an element-wise comparison and logic to ensure the result is a bool type.\r\n            \r\n             If an element-wise comparison doesn't return bool, then:\r\n             - if it is dynamic, we'll do ":"\r\n             产生元素的比较和逻辑，以确保结果是BOOL类型。\r\n            \r\n             如果元素的比较无法返回bool，则：\r\n              - 如果是动态的，我们会做\r\n","Attribute is ignored when public signing is specified.":"指定公共签名时忽略属性。\r\n","\r\n            Return the single symbol if there is exactly one, otherwise null.\r\n            ":"如果完全有一个，则返回单个符号，否则为空。\r\n            \r\n","\r\n            As an optimization, viability checking in the lookup code should use this property instead\r\n            of ":"\r\n            作为优化，查找代码中的可行性检查应改用此属性\r\n            的\r\n","\r\n            For each parameter of a source method, construct a corresponding synthesized parameter\r\n            for a destination method.\r\n            ":"\r\n            对于源方法的每个参数，构造一个相应的合成参数\r\n            对于目标方法。\r\n            \r\n","\r\n            If new checks are added to this method, they will also need to be added to ":"\r\n            如果将新的检查添加到此方法中，则还需要添加它们\r\n","\r\n            A binder used only for performing overload resolution of runtime helper methods.\r\n            ":"\r\n            仅用于执行运行时辅助方法过载分辨率的粘合剂。\r\n            \r\n","A throw expression is not allowed in this context.":"在这种情况下，不允许进行投掷表达。\r\n","\r\n              Looks up a localized string similar to An expression tree may not contain a tuple conversion..\r\n            ":"\r\n              查找类似于表达树的本地化字符串可能不包含元组转换。\r\n            \r\n","\r\n            This binder owns the scope for Simple Program top-level statements.\r\n            ":"\r\n            这个活页夹拥有简单程序顶级语句的范围。\r\n            \r\n","\r\n            This method is intended to return values consistent with the definition of C#, which\r\n            may differ from the actual meaning at runtime.\r\n            \r\n            Note: we don't need a different path for interfaces - Event.OverriddenOrHiddenMembers handles that.\r\n            \r\n            CONSIDER: It is an error for an event to have only one accessor.  Currently, we mimic the behavior for\r\n            properties, for consistency, but an alternative approach would be to say that nothing is overridden.\r\n            \r\n            CONSIDER: is there a way to share code with MakePropertyAccessorOverriddenOrHiddenMembers?\r\n            ":"\r\n            此方法旨在返回与C＃的定义一致的值\r\n            可能与运行时的实际含义有所不同。\r\n            \r\n            注意：我们不需要接口的路径 -  event.overridendorhiddenmbers处理。\r\n            \r\n            考虑：事件只有一个访问者是一个错误。目前，我们模仿\r\n            出于一致性而属性，但另一种方法是说什么都没有被覆盖。\r\n            \r\n            考虑：有没有一种方法可以与MakePropertyAccessoroverridendorhiddendembers共享代码？\r\n            \r\n","\r\n            Method context for resolving generic method type arguments.\r\n            ":"\r\n            解决通用方法类型参数的方法上下文。\r\n            \r\n","\r\n              Looks up a localized string similar to declaration of expression variables in member initializers and queries.\r\n            ":"\r\n              查找类似于成员初始化和查询中表达变量声明的局部字符串。\r\n            \r\n","The alias symbol that was declared, or null if a duplicate alias symbol was declared.":"如果宣布重复的别名符号，则声明的别名符号或null。\r\n","\r\n            Return true if the type has a public parameterless constructor.\r\n            ":"\r\n            如果该类型具有无参数构造函数，则返回true。\r\n            \r\n","receiver.Deconstruct(out var x1, out var x2, ...)":"receiver.deconstruct（out var x1，out var x2，...）\r\n"," returns\r\n            true. Otherwise, returns false.\r\n            ":" 返回\r\n            真的。否则，返回false。\r\n            \r\n","\r\n            Holds the information for a tuple comparison, either at the top-level (like `(a, b) == ...`) or nested (like `(..., (a, b)) == (..., ...)`).\r\n            ":"\r\n            在顶级（例如`（a，b）== ...`）或嵌套（例如`（...，（A，b））==（.. 。，...）`）。\r\n            \r\n","\r\n            Get a SemanticModel object that is associated with an initializer that did not appear in\r\n            this source code. This can be used to get detailed semantic information about sub-parts\r\n            of a field initializer or default parameter value that did not appear in source code.\r\n            ":"\r\n            获取与未出现在\r\n            此源代码。这可以用来获取有关子部分的详细语义信息\r\n            未出现在源代码中的字段初始化器或默认参数值。\r\n            \r\n","Expression will always cause a System.NullReferenceException because the default value of '{0}' is null":"表达式将始终导致系统。NullReferenceException，因为'{0}'的默认值为null\r\n","\r\n            Represents an element-wise null/null comparison.\r\n            For instance, ":"\r\n            表示元素的无效/空比较。\r\n            例如，\r\n","'{0}' is already listed in the interface list on type '{2}' with different tuple element names, as '{1}'.":"'{0}'已经在类型'{2}'的接口列表中列出，带有不同的元组元素名称为'{1}'。\r\n","True if the implementing type is from some compilation (i.e. not from metadata).":"如果实现类型来自某些汇编（即不是来自元数据），则为true。\r\n","Called when the visitor visits a SubpatternSyntax node.":"当访问者访问Subpatternsyntax节点时，请致电。\r\n","\r\n            The effective \"bounds\" of a type parameter: the constraint types, effective\r\n            interface set, and effective base type, determined from the declared\r\n            constraints, with any cycles removed. The fields are exposed by the\r\n            TypeParameterSymbol as ConstraintTypes, Interfaces, and BaseType.\r\n            ":"\r\n            类型参数的有效“界限”：约束类型，有效\r\n            界面集和有效的基本类型，由声明的\r\n            约束，除去任何周期。这些场是由\r\n            Typeparametersymbol作为约束类型，接口和底型。\r\n            \r\n","\r\n            Gets the conversion node for passing to ":"\r\n            获取转换节点以传递到\r\n","\r\n              Looks up a localized string similar to 'await' cannot be used in an expression containing a call to '{0}' because it returns by reference.\r\n            ":"\r\n              查找类似于“等待”的本地化字符串，无法在包含“ {0}”调用的表达式中使用，因为它通过引用返回。\r\n            \r\n","Invalid public key token.":"无效的公钥令牌。\r\n","\r\n            Represents a state machine method other than a MoveNext method.\r\n            All such methods are considered debugger hidden. \r\n            ":"\r\n            代表除movenext方法以外的状态机方法。\r\n            所有此类方法都被认为是隐藏的调试器。\r\n            \r\n","\r\n            A trivia with kind EndOfLineTrivia containing a single line feed character.\r\n            ":"\r\n            带有单线饲料特征的带有类似内膜的琐事。\r\n            \r\n","\r\n            Prepares locals (or fields in global statement) and lvalue expressions corresponding to the variables of the declaration.\r\n            The locals/fields/lvalues are kept in a tree which captures the nesting of variables.\r\n            Each local or field is either a simple local or field access (when its type is known) or a deconstruction variable pending inference.\r\n            The caller is responsible for releasing the nested ArrayBuilders.\r\n            ":"\r\n            准备与声明变量相对应的当地人（或全局语句中的字段）和lvalue表达式。\r\n            当地人/字段/lvalues被保存在捕获变量嵌套的树中。\r\n            每个本地或字段是简单的本地访问或字段访问（已知的类型）或解构变量待处理推断。\r\n            呼叫者负责释放嵌套的阵列构建器。\r\n            \r\n","The text of the parenthesized argument list.":"括号的参数列表的文本。\r\n","Called when the visitor visits a ConditionalAccessExpressionSyntax node.":"当访问者访问条件表达元素节点时调用。\r\n","__arglist is not valid in this context":"__ Arglist在这种情况下无效\r\n","Attribute constructor parameter '{0}' has type '{1}', which is not a valid attribute parameter type":"属性构造函数参数'{0}'具有类型'{1}'，这不是有效的属性参数类型\r\n","\r\n            Is this type a managed type (false for everything but enum, pointer, and\r\n            some struct types).\r\n            ":"\r\n            这种类型是托管类型吗（除枚举、指针和\r\n            一些结构类型）。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': only CLS-compliant members can be abstract.\r\n            ":"\r\n              查找类似于“ {0}'的局部字符串：只有符合CLS的成员才能抽象。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' explicit method implementation cannot implement '{1}' because it is an accessor.\r\n            ":"\r\n              查找类似于“ {0}”显式方法实现的本地化字符串无法实现'{1}'，因为它是访问者。\r\n            \r\n","\r\n              Looks up a localized string similar to A variable was declared with the same name as a variable in a base class. However, the new keyword was not used. This warning informs you that you should use new; the variable is declared as if new had been used in the declaration..\r\n            ":"\r\n              查找类似于变量的本地化字符串，该字符串与基类中的变量相同。但是，未使用新关键字。此警告告诉您，您应该使用新的；该变量被声明，好像是在声明中使用的。\r\n            \r\n","Creates a new ImplicitObjectCreationExpressionSyntax instance.":"创建一个新的intimitObjectCreationexpressyntax实例。\r\n"," Anonymous type fields ":" 匿名类型字段\r\n","\r\n            Loads analyzer assemblies from their original locations in the file system.\r\n            Assemblies will only be loaded from the locations specified when the loader\r\n            is instantiated.\r\n            ":"\r\n            从文件系统中的原始位置加载分析仪组件。\r\n            只有从加载器时指定的位置加载组件\r\n            实例化。\r\n            \r\n","Cannot define a class or member that utilizes tuples because the compiler required type '{0}' cannot be found. Are you missing a reference?":"无法定义使用元组的类或成员，因为找不到编译器所需的类型“ {0}”。您是否缺少参考？\r\n","Feature '{0}' is not available in C# 7.1. Please use language version {1} or greater.":"C＃7.1中不可用功能'{0}'。请使用语言版本{1}或更大。\r\n","\r\n            A region analysis walker that computes the set of variables whose values flow into (are used\r\n            in) the region. A variable assigned outside is used inside if an analysis that leaves the\r\n            variable unassigned on entry to the region would cause the generation of \"unassigned\" errors\r\n            within the region.\r\n            ":"\r\n            一个区域分析步行者，该步行器计算值流入的变量集（使用\r\n            在该区域。如果一项分析留下的分析\r\n            进入该地区时未分配的可变将导致“未分配”错误的产生\r\n            在区域内。\r\n            \r\n","\r\n            Returns data decoded from source assembly attributes or null if there are none.\r\n            ":"\r\n            返回从源组件属性解码的数据或null如果没有的数据。\r\n            \r\n","extern alias":"外部别名\r\n","Option overrides attribute given in a source file or added module":"选项覆盖源文件或添加模块中给出的属性\r\n"," is false.\r\n            Leaves a dot and a name unconsumed if the name is not followed by another dot\r\n            and checkForMember is true.\r\n            ":" 是错误的。\r\n            如果没有跟随另一个点，请留下一个点和一个名字\r\n            和CheckFormember是正确的。\r\n            \r\n","\r\n            A common base class for lowering the pattern switch statement and the pattern switch expression.\r\n            ":"\r\n            用于降低模式开关语句和模式开关表达式的公共基类。\r\n            \r\n","\r\n            Gets the all the diagnostics for the compilation, including syntax, declaration, and binding. Does not\r\n            include any diagnostics that might be produced during emit.\r\n            ":"\r\n            获取汇编的所有诊断，包括语法，声明和绑定。才不是\r\n            包括发射过程中可能产生的任何诊断。\r\n            \r\n","\r\n            Translate the single test into _sideEffectBuilder and _conjunctBuilder.\r\n            ":"\r\n            将单个测试转换为_sideeffectBuilder和_conjunctbuilder。\r\n            \r\n","\r\n            Returns ConstantValue.Bad if, and only if, the resulting string length exceeds ":"\r\n            返回constantValue.bad时，只有当结果的字符串长度超过\r\n","\r\n            This method checks to see if the given symbol is Obsolete or if any symbol in the parent hierarchy is Obsolete.\r\n            ":"\r\n            此方法检查给定符号是否已过时，或者父层中的任何符号是否已过时。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': a class with the ComImport attribute cannot specify field initializers..\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串：带有Comimport属性的类无法指定字段初始化器。\r\n            \r\n","\r\n            If qualifierOpt is null, look for any symbols in\r\n            scope with the given name and arity.\r\n            Otherwise look for symbols that are members of the specified qualifierOpt.\r\n            ":"\r\n            如果预选赛为null，请在\r\n            带有给定名称和arity的范围。\r\n            否则，请查找指定限制性符号成员的符号。\r\n            \r\n","\r\n            The underlying NamespaceSymbol, cannot be another RetargetingNamespaceSymbol.\r\n            ":"\r\n            基础命名符号，不能是另一个RetargetingNamespaceSymbol。\r\n            \r\n","\r\n            Called to report attribute related diagnostics after all attributes have been bound and decoded.\r\n            Called even if there are no attributes.\r\n            ":"在所有属性都被绑定和解码后，要求报告属性相关的诊断。\r\n            即使没有属性也称为。\r\n            \r\n","\r\n            Indicates that the transfer function for a particular node (the function mapping the\r\n            state before the node to the state after the node) is not monotonic, in the sense that\r\n            it can change the state in either direction in the lattice. If the transfer function is\r\n            monotonic, the transfer function can only change the state toward the ":"\r\n            表示特定节点的传输函数（函数映射\r\n            在节点之后到状态之前的状态）不是单调的，从某种意义上说\r\n            它可以在晶格中的任一方向上改变状态。如果传输函数为\r\n            单调，传输函数只能将状态更改为\r\n","\r\n            Copy this tuple, but modify it to use the new element names.\r\n            Also applies new location of the whole tuple as well as each element.\r\n            Drops the inferred positions.\r\n            ":"\r\n            复制此元组，但将其修改为使用新元素名称。\r\n            还应用了整个元组以及每个元素的新位置。\r\n            掉落推断的位置。\r\n            \r\n"," means the decision is to be made based on the shape of the ":" 意味着该决定是根据形状做出的\r\n","\r\n                 [return: TupleElementNamesAttribute(new[] { \"x\", \"y\" })]\r\n                 System.ValueTuple<int, int> M() { ... }\r\n             ":"\r\n                 [返回：tupleelementnamesattribute（new [] {“ x”，“ y”}）]\r\n                 system.valuetuple <int，int> m（）{...}\r\n             \r\n","Error reading ruleset file {0} - {1}":"错误读取规则集文件{0}  -  {1}\r\n","Quoted file name expected":"报价的文件名期望\r\n","Accessing a member on '{0}' may cause a runtime exception because it is a field of a marshal-by-reference class":"在“ {0}”上访问成员可能会导致运行时异常\r\n","\r\n              Looks up a localized string similar to The range variable '{0}' has already been declared.\r\n            ":"\r\n              查找类似于范围变量'{0}'的本地化字符串已被声明。\r\n            \r\n","\r\n            This override can handle non-PE types.\r\n            ":"\r\n            此替代可以处理非PE类型。\r\n            \r\n","\r\n            Gets a list of documents from the method definitions in the types in ":"\r\n            从类型中的方法定义中获取文档列表\r\n","\r\n            Intended to be used to create ParameterSymbols for a SignatureOnlyMethodSymbol.\r\n            ":"\r\n            打算用于为签名的yllyMethodSymbol创建参数符号。\r\n            \r\n","The 8-byte unsigned integer value to be represented by the returned token.":"返回令牌将要表示的8字节未签名的整数值。\r\n","$\"":"$”\r\n","Tuples must have at least two elements.":"元组必须至少有两个要素。\r\n","Assembly symbol or null.":"组件符号或空。\r\n","\r\n            Return error code that has highest priority while calculating use site error for this symbol.\r\n            ":"\r\n            返回错误代码在计算此符号的使用站点错误时具有最高优先级。\r\n            \r\n","\r\n            and store it in ":"\r\n            并将其存储在\r\n","<throw expression>":"<投掷表达>\r\n","\r\n            \r\n            We make some key observations:\r\n              1) The type parameter name in the cref is not tied to the type parameter name in the type declaration.\r\n              2) A relationship exists between the two occurrences of \"U\" in the cref: they both refer to (or define)\r\n                   the same symbol.\r\n            \r\n            In Roslyn, we've decided on the following representation: within the (entire) scope of a cref, the names\r\n            of all type parameters \"declared\" in the cref are in scope and bind to the corresponding type parameters.\r\n            This representation has one major advantage: as long as the appropriate binder (i.e. the one that knows\r\n            about the implicitly-declared type parameters) is used, TypeSyntaxes within the cref can be bound by\r\n            calling BindType.  In addition to eliminating the necessity for custom binding code in the batch case,\r\n            this reduces the problem of exposing such nodes in the SemanticModel to one of ensuring that the right\r\n            enclosing binder is chosen.  That is, new code will have to be written to handle CrefSyntaxes, but the\r\n            existing code for TypeSyntaxes should just work!\r\n            \r\n            In the example above, this means that, between the cref quotation marks, the name \"U\" binds to an\r\n            implicitly declared type parameter, whether it is in \"B{U}\", \"M{U}\", or \"M{List{U[]}}\".\r\n            \r\n            Of course, it's not all gravy.  One thing we're giving up by using this representation is the ability to\r\n            distinguish between \"declared\" type parameters with the same name.  Consider the following example:\r\n            \r\n            ":"我们做出一些关键观察：\r\n              1）CREF中的类型参数名称与类型声明中的类型参数名称无关。\r\n              2）在CREF中的“ U”两次发生之间存在关系：它们都指（或定义）\r\n                   相同的符号。\r\n            \r\n            在罗斯林（Roslyn\r\n            在CREF中“声明”的所有类型参数中，都处于范围，并绑定到相应的类型参数。\r\n            该表示形式具有一个主要优势：只要适当的粘合剂（即知道的粘合剂\r\n            关于隐式指定的类型参数），CREF中的典型字符可以由\r\n            调用bindtype。除了消除批处理案例中自定义绑定代码的必要性外，\r\n            这减少了将这种节点暴露在语义模型中的问题，以确保正确\r\n            选择包装粘合剂。也就是说，必须编写新的代码来处理crefsyntaxes，但是\r\n            现有的典型字符代码应该只能使用！\r\n            \r\n            在上面的示例中，这意味着，在Cref引号之间，名称“ U”绑在一个\r\n            隐式声明为类型参数，无论是在“ b {u}”，“ m {u}”中，还是“ m {list {u [u []}}”。\r\n            \r\n            当然，这并不全是肉汁。我们通过使用此表示放弃的一件事是能够\r\n            区分具有相同名称的“声明”类型参数。考虑以下示例：\r\n            \r\n            \r\n","\r\n            Number of characters in the character window.\r\n            ":"\r\n            字符窗口中的字符数。\r\n            \r\n","\r\n             Is this System.Nullable`1 type, or its substitution.\r\n            \r\n             To check whether a type is System.Nullable`1 or is a type parameter constrained to System.Nullable`1\r\n             use ":"是该系统.nullable'1类型还是替换。\r\n            \r\n             检查一个类型是system.nullable`1还是是限制在system.nullable'1的类型参数\r\n             利用\r\n","\r\n              Looks up a localized string similar to The CallerMemberNameAttribute will have no effect; it is overridden by the CallerFilePathAttribute.\r\n            ":"\r\n              查找类似于Callermemberneattribute的本地化字符串将没有效果。它被callerfilepathatribute覆盖。\r\n            \r\n","\r\n              Looks up a localized string similar to 'await' cannot be used in an expression containing the type '{0}'.\r\n            ":"\r\n              在包含“ {0}”类型的表达式中查找类似于“等待”的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Member '{0}' added during the current debug session can only be accessed from within its declaring assembly '{1}'..\r\n            ":"\r\n              查找类似于当前调试会话中添加的成员'{0}'的本地化字符串，只能从其声明的汇编'{1}'..中访问。\r\n            \r\n","\r\n              Looks up a localized string similar to Ignoring /noconfig option because it was specified in a response file.\r\n            ":"\r\n              查找类似于忽略 /noconfig选项的本地化字符串，因为它是在响应文件中指定的。\r\n            \r\n","\r\n            Method to merge attributes from the given attributesSyntaxLists and filter out attributes by attribute target.\r\n            This is the first step in attribute binding.\r\n            ":"\r\n            从给定的属性列表清单合并属性并通过属性目标过滤属性的方法。\r\n            这是属性绑定的第一步。\r\n            \r\n","\r\n              Looks up a localized string similar to Deconstruction must contain at least two variables..\r\n            ":"\r\n              查找类似于解构的本地化字符串必须至少包含两个变量。\r\n            \r\n","\r\n            Get the custom attributes, but filter out any ParamArrayAttributes.\r\n            ":"\r\n            获取自定义属性，但要滤除任何paramarrayattributes。\r\n            \r\n","\r\n            Create a NamespaceExtent that represents a given AssemblySymbol.\r\n            ":"\r\n            创建一个代表给定的汇编符号的命名续文。\r\n            \r\n","stackalloc arrays support initializers":"Stackalloc阵列支持初始化器\r\n","\r\n              Looks up a localized string similar to Cannot return 'this' by reference..\r\n            ":"\r\n              查找类似于无法返回“此”的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Different checksum values given for '{0}'.\r\n            ":"\r\n              查找类似于“ {0}”给出的不同校验和值类似的本地化字符串。\r\n            \r\n","\r\n            Creates a SemanticModel for the method.\r\n            ":"\r\n            为该方法创建一个语义模型。\r\n            \r\n","\r\n             If an element in a tuple literal has an explicit name which doesn't match the name on the other side, we'll warn.\r\n             The user can either remove the name, or fix it.\r\n            \r\n             This method handles two expressions, each of which is either a tuple literal or an expression with tuple type.\r\n             In a tuple literal, each element can have an explicit name, an inferred name or no name.\r\n             In an expression of tuple type, each element can have a name or not.\r\n             ":"\r\n             如果元组中的元素具有一个明确的名称，该名称不符合另一侧的名称，我们会警告。\r\n             用户可以删除名称，也可以修复它。\r\n            \r\n             此方法处理两个表达式，每个表达式都是元组字面或带有元组类型的表达式。\r\n             在元组中，每个元素都可以具有一个明确的名称，一个推断名称或没有名称。\r\n             在元组类型的表达中，每个元素都可以具有一个名称。\r\n             \r\n","\r\n            Methods imported from metadata can explicitly implement more than one method,\r\n            that is why return type is ImmutableArray.\r\n            ":"\r\n            从元数据中导入的方法可以明确实现多个方法，\r\n            这就是为什么返回类型是ImmutableArray的原因。\r\n            \r\n","\r\n            Current design of early decoding well-known attributes doesn't permit decoding attribute arguments/constructor as this can lead to binding cycles.\r\n            For well-known attributes used by the binder, where we need the decoded arguments, we must handle them specially in one of the following possible ways:\r\n              (a) Avoid decoding the attribute arguments during binding and delay the corresponding binder tasks to a separate post-pass executed after binding.\r\n              (b) As the cycles can be caused only when we are binding attribute arguments/constructor, special case the corresponding binder tasks based on the current BinderFlags.\r\n            ":"\r\n            当前的早期解码属性属性的设计不允许解码属性参数/构造函数，因为这可能会导致结合周期。\r\n            对于粘合剂所使用的众所周知的属性，我们需要解码的论点，我们必须特别以以下可能的方式处理它们：\r\n              （a）避免在绑定过程中解码属性参数，并将相应的粘合剂任务延迟到绑定后执行的单独的后通道。\r\n              （b）只有在我们绑定属性参数/构造函数时才能引起周期，特殊情况是基于当前绑定器的相应粘合剂任务。\r\n            \r\n","\r\n            Performs the same function as ErrArgFlags::Unique in the native compiler.\r\n            ":"\r\n            在本机编译器中执行与Errargflags ::唯一的功能。\r\n            \r\n","\r\n            Reports use-site diagnostics for the specified symbol.\r\n            ":"\r\n            报告指定符号的用途诊断。\r\n            \r\n","Called when the visitor visits a PrefixUnaryExpressionSyntax node.":"当访问者访问前fixunary expressyntax节点时调用。\r\n","\r\n            Contains a snapshot of the state of the NullableWalker at any given point of execution, used for restoring the walker to\r\n            a specific point for speculatively analyzing a piece of code that does not appear in the original tree.\r\n            ":"\r\n            包含NullableWalker在任何给定执行点的状态快照，用于将walker还原为\r\n            推测性地分析原始树中没有出现的一段代码的特定点。\r\n            \r\n","\r\n              Looks up a localized string similar to Method '{0}' has a parameter modifier 'this' which is not on the first parameter.\r\n            ":"\r\n              查找类似于方法'{0}'的本地化字符串具有参数修饰符'this'，而不是第一个参数。\r\n            \r\n","Cannot assign '{0}' to anonymous type property":"无法将'{0}'分配给匿名类型属性\r\n","\r\n            Produces name of the synthesized delegate symbol that encodes the parameter byref-ness and return type of the delegate.\r\n            The arity is appended via `N suffix in MetadataName calculation since the delegate is generic.\r\n            ":"\r\n            生成综合委托符号的名称，该符号编码byref- and byref-和返回类型的代表符号。\r\n            由于代表是通用的，因此通过元数据计算中的n n后缀附加了ARITY。\r\n            \r\n","\r\n              Looks up a localized string similar to To use '@$' instead of '$@' for an interpolated verbatim string, please use language version '{0}' or greater..\r\n            ":"\r\n              查找类似于使用'@$'而不是'$@'的本地化字符串作为插值的逐字字符串，请使用语言版本'{0}'或更大。\r\n            \r\n","\r\n            This portion of the binder converts a AnonymousObjectCreationExpressionSyntax into \r\n            a bound anonymous object creation node\r\n            ":"\r\n            粘合剂的这一部分将匿名的creationexpressynntax转换为\r\n            绑定的匿名对象创建节点\r\n            \r\n","\r\n            Visits a node that is possibly a ":"\r\n            访问一个可能是\r\n","'{0}': cannot derive from sealed type '{1}'":"'{0}'：不能从密封类型'{1}'衍生\r\n","'{0}': abstract properties cannot have private accessors":"'{0}'：抽象属性不能具有私人登录器\r\n"," syntax. False\r\n            otherwise.\r\n            ":" 句法。错误的\r\n            否则。\r\n            \r\n","\r\n            Writes compiler version and name to the PDB.\r\n            ":"\r\n            将编译器版本和名称写入PDB。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid image base number '{0}'.\r\n            ":"查找类似于无效的图像基数'{0}'的本地化字符串。\r\n            \r\n","An expression tree may not contain a reference to a local function":"表达树可能不包含对本地函数的引用\r\n","If this is non-null, then ":"如果这是非无效的，那就\r\n","\r\n              Looks up a localized string similar to Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call..\r\n            ":"\r\n              查找类似于此呼叫的本地化字符串，在呼叫完成之前继续执行当前方法。考虑将“等待”操作员应用于通话结果。\r\n            \r\n","Partial declarations of '{0}' must not specify different base classes":"“ {0}”的部分声明不得指定不同的基类\r\n","\r\n            For tuples with no natural type, we still need to verify that an underlying type of proper arity exists, and report if otherwise.\r\n            ":"\r\n            对于没有天然类型的元组，我们仍然需要验证存在一种基本类型的适当性质，并报告否则。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot access protected member '{0}' via a qualifier of type '{1}'; the qualifier must be of type '{2}' (or derived from it).\r\n            ":"\r\n              查找类似于无法访问受保护的成员'{0}'的本地化字符串，通过类型'{1}'的限定符;预选赛必须为“ {2}”类型（或从中派生）。\r\n            \r\n","\r\n            Lexer entry point for LexMode.XmlAttributeText\r\n            ":"\r\n            lexmode.xmlattributetext的Lexer入口点\r\n            \r\n","\r\n            Skip binding type arguments (we use ":"\r\n            跳过绑定类型参数（我们使用\r\n","True to only return a method.":"真实要返回方法。\r\n"," constructor.\r\n            The implementation may depend only on information available from the ":" 构造函数。\r\n            实施可能仅取决于来自\r\n","\r\n            Spec 7.7.7.1:\r\n            An Awaiter A implements the interface System.Runtime.CompilerServices.INotifyCompletion.\r\n            ":"\r\n            规格7.7.7.1：\r\n            等待者A实现接口系统。\r\n            \r\n","\r\n            Determines whether this node is structurally equivalent to another.\r\n            ":"\r\n            确定该节点在结构上是否等同于另一个。\r\n            \r\n","Name '{0}' exceeds the maximum length allowed in metadata.":"名称'{0}'超过元数据中允许的最大长度。\r\n","\r\n              Looks up a localized string similar to Type parameter has the same type as the type parameter from outer method..\r\n            ":"\r\n              查找类似于类型参数的本地化字符串具有与外部方法的类型参数相同的类型。\r\n            \r\n","\r\n            A map of types immediately contained within this namespace \r\n            grouped by their name (case-sensitively).\r\n            ":"\r\n            此名称空间中立即包含的类型地图\r\n            按其名称分组（案例敏感）。\r\n            \r\n","\r\n            Binder that owns the scope for the local function symbol, namely the scope where the\r\n            local function is declared.\r\n            ":"\r\n            拥有本地功能符号范围的活页夹，即范围\r\n            声明本地功能。\r\n            \r\n","ExpressionSyntax node representing the expression to be executed when the condition is false.":"expressionsyntax节点表示条件为false时要执行的表达式。\r\n","The assembly containing type '{0}' references .NET Framework, which is not supported.":"包含类型“ {0}”引用.NET框架的汇编，不支持。\r\n","Source file '{0}' could not be found.":"源文件'{0}'找不到。\r\n","\r\n            The (optional) guard expression.\r\n            ":"\r\n            （可选的）后卫表达。\r\n            \r\n","Operator '{0}' cannot be applied to 'default' and operand of type '{1}' because it is a type parameter that is not known to be a reference type":"操作员'{0}'不能应用于'默认值'和类型'{1}'的操作数，因为它是类型参数，不知道是参考类型\r\n","\r\n            Helper class for binding the pattern switch statement. It helps compute which labels\r\n            are subsumed and/or reachable. The strategy, implemented in ":"\r\n            用于绑定模式开关语句的助手类。它有助于计算哪些标签\r\n            被包含和/或可到达。实施的策略\r\n","Nullability of reference types in return type doesn't match the target delegate (possibly because of nullability attributes).":"返回类型中参考类型的无效性不匹配目标委托（可能是由于无效属性）。\r\n","\r\n            These special types are structs that contain fields of the same type\r\n            (e.g. ":"\r\n            这些特殊类型是包含相同类型字段的结构\r\n            （例如。\r\n","'{0}' does not contain a definition for '{1}'":"'{0}'不包含'{1}'的定义\r\n","Binder for the scope around the method (may be null for operators, constructors, and destructors).":"该方法周围范围的活页夹（对于操作员，构造函数和破坏者来说可能为无效）。\r\n","Unexpected use of an aliased name":"意外使用别名名称\r\n","A format specifier may not contain trailing whitespace.":"格式指定器可能不包含尾随的空格。\r\n","\r\n              Looks up a localized string similar to A Windows Runtime event may not be passed as an out or ref parameter..\r\n            ":"\r\n              查找类似于Windows Runtime事件的本地化字符串可能不会作为OUT或REF参数传递。\r\n            \r\n","A character position used to identify a declaration scope and accessibility. This\r\n            character position must be within the FullSpan of the Root syntax node in this SemanticModel.\r\n            Furthermore, it must be within the span of an existing cref.\r\n            ":"用于标识声明范围和可访问性的角色位置。这个\r\n            字符位置必须在此semanticmodel中的root语法节点的成面内。\r\n            此外，它必须在现有CREF的跨度之内。\r\n            \r\n","\r\n            Defines a set of methods to determine how Unicode characters are treated by the C# compiler.\r\n            ":"\r\n            定义一组方法来确定C＃编译器如何处理Unicode字符。\r\n            \r\n","Cannot emit debug information for a source text without encoding.":"不能在不编码的情况下发布源文本的调试信息。\r\n","\r\n            Finds the member in the containing symbol which is inside the given declaration span.\r\n            ":"\r\n            在给定声明跨度内的包含符号中找到成员。\r\n            \r\n","Target delegate type.":"目标委托类型。\r\n","Multiple global analyzer config files set the same key. It has been unset.":"多个全局分析仪配置文件设置相同的密钥。这是不安的。\r\n","\r\n            Note: Can be default if this SynthesizedContainer was constructed with ":"\r\n            注意：如果使用此合成限制，则可以默认\r\n","\r\n            Returns whether this method is async and returns void.\r\n            ":"\r\n            返回该方法是否为异步并返回void。\r\n            \r\n","\r\n              Looks up a localized string similar to Async method lacks 'await' operators and will run synchronously.\r\n            ":"\r\n              查找类似于异步方法的本地化字符串缺乏“等待”操作员，并且会同步运行。\r\n            \r\n","Total analyzer execution time: {0} seconds.":"总分析仪执行时间：{0}秒。\r\n","The type symbol that was declared.":"声明的类型符号。\r\n","\r\n              Looks up a localized string similar to The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit).\r\n            ":"\r\n              查找类似于fieldOffset属性的本地化字符串只能放置在标记为structlayout（layoutkind.splitic）类型的成员上。\r\n            \r\n","Cannot convert to static type '{0}'":"无法转换为静态类型'{0}'\r\n","expression-bodied property":"表达体的特性\r\n","\r\n              Looks up a localized string similar to The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no implicit reference conversion from '{3}' to '{1}'..\r\n            ":"\r\n              在通用类型或方法'{0}'中查找类似于类型的'{3}'类型的本地化字符串。从“ {3}”到'{1}'..没有隐式参考转换。\r\n            \r\n","Declaration representing the variable declared in an out parameter or deconstruction.":"声明表示在OUT参数或解构中声明的变量。\r\n","\r\n            When we read a field from a struct, the receiver isn't seen as being read until we get to the\r\n            end of the field access expression, because we only read the relevant piece of the struct.\r\n            But we want the receiver to be considered to be read in the region in that case.\r\n            For example, if an rvalue expression is x.y.z and the region is x.y, we want x to be included\r\n            in the ReadInside set.  That is implemented here.\r\n            ":"\r\n            当我们从结构上阅读字段时，接收器才被视为被读取，直到我们到达\r\n            字段访问表达式的结尾，因为我们仅读取结构的相关片段。\r\n            但是，我们希望在这种情况下将接收器视为在该区域中被读取。\r\n            例如，如果RVALUE表达式为X.Y.Z，并且该区域为X.Y，我们希望包括X\r\n            在ReadInside集中。在这里实现。\r\n            \r\n","\r\n            Represents expression and deconstruction variables declared in a global statement.\r\n            ":"\r\n            表示在全局语句中声明的表达和解构变量。\r\n            \r\n"," \r\n            Error symbol is created when there is compiler error; Override this with specific\r\n            implementation; Calling ":" \r\n            当存在编译器错误时，会创建错误符号；用特定的\r\n            执行;打电话\r\n","\r\n            Overload resolution (effectively) starts out assuming that all candidates are valid and then\r\n            gradually disqualifies them.  Therefore, our strategy will be to perform our checks in the\r\n            reverse order - the farther a candidate got through the process without being flagged, the\r\n            \"better\" it was.\r\n            \r\n            Note that \"final validation\" is performed after overload resolution,\r\n            so final validation errors are not seen here. Final validation errors include\r\n            violations of constraints on method type parameters, static/instance mismatches,\r\n            and so on.\r\n            ":"\r\n            超载分辨率（有效）开始假设所有候选人都是有效的，然后\r\n            逐渐取消他们的资格。因此，我们的策略将是在\r\n            反向顺序 - 候选人越远，没有标记，\r\n            “更好”是。\r\n            \r\n            请注意，“最终验证”是在分辨率后执行的，\r\n            因此在这里看不到最终验证错误。最终验证错误包括\r\n            违反对方法类型参数的约束，静态/实例不匹配，\r\n            等等。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' is not an attribute class.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串不是属性类。\r\n            \r\n","\r\n              Looks up a localized string similar to The type forwarder for type '{0}' in assembly '{1}' causes a cycle.\r\n            ":"\r\n              查找类似于类型'{1}'中类型'{0}'的局部字符串会导致一个周期。\r\n            \r\n","If this method returns true, then it will contain a valid MethodResolutionResult.\r\n            Otherwise, it may contain a MethodResolutionResult for an inaccessible constructor (in which case, it will incorrectly indicate success) or nothing at all.":"如果此方法返回true，则将包含有效的MethodResolutionResult。\r\n            否则，它可能包含用于无法访问的构造函数的方法解决方案（在这种情况下，它将错误地表明成功）或根本没有任何内容。\r\n"," type with dynamic type.\r\n            If no System.Runtime.CompilerServices.DynamicAttribute is applied or the decoded dynamic transforms attribute argument is erroneous,\r\n            returns the unchanged ":" 具有动态类型的类型。\r\n            如果没有system.runtime.compilerservices.dynamicattribute或解码的动态变换属性参数是错误的，\r\n            返回不变的\r\n","Extension method must be defined in a non-generic static class":"扩展方法必须在非生成静态类中定义\r\n","Expected 'disable' or 'restore'":"预期的“禁用”或“还原”\r\n","\r\n            Returns true if calls to this method are omitted in this syntax tree. Calls are omitted\r\n            when the called method is a partial method with no implementation part, or when the\r\n            called method is a conditional method whose condition is not true in the source file\r\n            corresponding to the given syntax tree.\r\n            ":"\r\n            如果在此语法树中省略了此方法的调用，则返回true。省略了电话\r\n            当调用方法是没有实现部分的部分方法，或者\r\n            称为方法是条件方法，其条件在源文件中不正确\r\n            对应给定的语法树。\r\n            \r\n","\r\n            To handle a label, we resolve all branches to that label.  Returns true if the state of\r\n            the label changes as a result.\r\n            ":"\r\n            为了处理标签，我们将所有分支解决到该标签。如果状态的状态\r\n            标签随之变化。\r\n            \r\n","\r\n            Translates anonymous type method symbol into an implementation method symbol to be used in emit.\r\n            ":"\r\n            将匿名类型方法符号转换为要在EMIT中使用的实现方法符号。\r\n            \r\n","Diagnostics":"诊断\r\n","Creates a new SwitchExpressionArmSyntax instance.":"创建一个新的SwitchExpressionArmsyntax实例。\r\n","\r\n            Visits a node only if it is a conditional access.\r\n            Returns 'true' if and only if the node was visited.\r\n            ":"\r\n            仅在有条件访问时才访问节点。\r\n            且仅当访问节点时返回“ true”。\r\n            \r\n","\r\n            Return the longest common prefix of two strings\r\n            ":"\r\n            返回两个字符串的最长常见前缀\r\n            \r\n","\r\n            For each lambda in the code, the set of variables that it captures.\r\n            ":"对于代码中的每个lambda，它捕获的变量集。\r\n            \r\n","\r\n            Set of well-known SyntaxTokens commonly found within XML doc comments.\r\n            ":"\r\n            XML Doc评论中常见的一组著名的语法动物集。\r\n            \r\n","\r\n            Represents a reference to a field of a generic type instantiation.\r\n            e.g.\r\n            A{int}.Field\r\n            A{int}.B{string}.C.Field\r\n            ":"\r\n            代表对通用类型实例化字段的引用。\r\n            例如\r\n            {int} .field\r\n            a {int} .b {string} .c.field\r\n            \r\n","Object '{0}' can be disposed more than once.":"对象'{0}'可以不止一次处置。\r\n","\r\n            Is the clause impossible?  We do not consider a when clause with a constant false value to cause the branch to be impossible.\r\n            Note that we do not include the possibility that a when clause is the constant false.  That is treated like any other expression.\r\n            ":"\r\n            条款不可能吗？我们不考虑具有恒定错误值的子句以使分支是不可能的。\r\n            请注意，我们不包括何时子句为常数false的可能性。就像其他任何表达一样。\r\n            \r\n","#pragma":"#pragma\r\n","The \"this\" parameter in the top-most frame, or null if static method":"最高框架中的“此”参数，或者如果静态方法为空\r\n","\r\n              Looks up a localized string similar to '{0}': type used in a using statement must be implicitly convertible to 'System.IDisposable' or implement a suitable 'Dispose' method. Did you mean 'await using' rather than 'using'?.\r\n            ":"\r\n              查找类似于“ {0}'：使用语句中使用的类型类型的本地化字符串，必须隐式转换为“ system.idisposable”或实现合适的“ dispose”方法。您的意思是“等待”而不是“使用”？\r\n            \r\n","\r\n            Attribute location corresponding to this symbol.\r\n            ":"\r\n            属性位置与此符号相对应。\r\n            \r\n","\r\n            This is based on SymbolPreparer::IsCLRMethodImplSame in the native compiler.\r\n            \r\n            ACASEY: What the native compiler actually does is compute the C# answer, compute the CLR answer,\r\n            and then confirm that they override the same method.  What I've done here is check for the situations\r\n            where the answers could disagree.  I believe the results will be equivalent.  If in doubt, a more conservative\r\n            check would be implementingMethod.ContainingType.InterfacesAndTheirBaseInterfaces.Contains(@interface).\r\n            ":"\r\n            这是基于本机编译器中的SymbolPreparer :: isclrmethodimplsame。\r\n            \r\n            Acasey：本机编译器实际上所做的是计算C＃答案，计算CLR答案，\r\n            然后确认它们覆盖了相同的方法。我在这里做的是检查情况\r\n            答案可能不同意。我相信结果将是等效的。如果有疑问，一个更保守的人\r\n            检查将是实现method.containingtype.interfacesand andtheirbaseInterfaces.contains（@interface）。\r\n            \r\n","Cannot await in an unsafe context":"在不安全的环境中无法等待\r\n"," on it Or override this with\r\n            specific implementation; Calling ":" 在它上或覆盖它\r\n            具体实施；打电话\r\n","\r\n              Looks up a localized string similar to By-reference returns may only be used in methods that return by reference.\r\n            ":"\r\n              查找类似于附带返回的本地化字符串只能在通过参考返回的方法中使用。\r\n            \r\n","\r\n            Blocks that are positioned between a block declaring some lifted variables\r\n            and a block that contains the lambda that lifts said variables.\r\n            If such block itself requires a closure, then it must lift parent frame pointer into the closure\r\n            in addition to whatever else needs to be lifted.\r\n            \r\n            NOTE: This information is computed in addition to the regular analysis of the tree and only needed for rewriting.\r\n            If someone only needs diagnostics or information about captures, this information is not necessary.\r\n            ":"\r\n            位于块之间的块，声明一些提升变量\r\n            还有一个包含lambda的块，升压变量。\r\n            如果这样的块本身需要关闭，则必须将父框架指针提升到闭合\r\n            除了其他需要举起的东西。\r\n            \r\n            注意：除了对树的常规分析外，还需要计算此信息，并且仅需要重写。\r\n            如果某人只需要诊断或有关捕获的信息，则无需此信息。\r\n            \r\n","\r\n              Looks up a localized string similar to A local variable named '{0}' is already defined in this scope.\r\n            ":"\r\n              在此范围中已经定义了类似于名为“ {0}”本地变量的本地化字符串。\r\n            \r\n","Creates a new PropertyDeclarationSyntax instance.":"创建一个新的propertyDeclarationsyntax实例。\r\n","\r\n            Gets the ref kind of the method's return value\r\n            ":"\r\n            获取该方法返回值的裁判类型\r\n            \r\n","\r\n            Consider the following method:\r\n                void M() {\r\n                    void L<T>(T t) => Console.Write(t);\r\n                    L(\"A\");\r\n                }\r\n                \r\n            In this example, L<T> is a local function that will be\r\n            lowered into its own method and the type parameter T will be\r\n            alpha renamed to something else (let's call it T'). In this case,\r\n            all references to the original type parameter T in L must be\r\n            rewritten to the renamed parameter, T'.\r\n            ":"\r\n            考虑以下方法：\r\n                void m（）{\r\n                    void l <t>（t t）=> console.write（t）;\r\n                    l（“ a”）;\r\n                }\r\n                \r\n            在此示例中，l <t>是一个本地函数\r\n            降低到自己的方法中，类型参数t为\r\n            alpha重命名为其他东西（我们称其为T'）。在这种情况下，\r\n            所有对L中原始类型参数t的引用必须为\r\n            重写为更名的参数，t'。\r\n            \r\n","\r\n              Looks up a localized string similar to Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Are you missing a reference to 'System.Core.dll' or a using directive for 'System.Linq'?.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法找到源类型“ {0}”的查询模式的实现。 '{1}'找不到。您是否缺少对“ system.core.dll”的引用或使用“ system.linq”的指令？\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use ref local '{0}' inside an anonymous method, lambda expression, or query expression.\r\n            ":"\r\n              在匿名方法，lambda表达式或查询表达式中查找类似于使用ref local'{0}'的本地化字符串。\r\n            \r\n"," if\r\n            the computed value is a well-known \"empty\" value. In this case, bits in ":" 如果\r\n            计算值是众所周知的“空”值。在这种情况下，点\r\n","throw expression":"投掷表达\r\n","\r\n            This symbol is used as the return type of a LambdaSymbol when we failed to infer its return type.\r\n            ":"\r\n            当我们未能推断其返回类型时，该符号用作Lambdasymbol的返回类型。\r\n            \r\n","AttributeTargets or 0":"attributetargets或0\r\n","Potential indexer receiver.":"潜在索引器接收器。\r\n","An expression tree may not contain a throw-expression.":"表达树可能不包含抛出表达。\r\n","\r\n            Gets a SyntaxToken that represents the open braces following the switch sections.\r\n            ":"\r\n            获取一个SyntaxToken，该SyntaxToken表示switch部分后面的打开大括号。\r\n            \r\n","The return expression must be of type '{0}' because this method returns by reference":"返回表达式必须为'{0}'类型，因为此方法通过参考返回\r\n","\r\n            Gets the typed constant kind for the given attribute parameter type.\r\n            ":"\r\n            获取给定属性参数类型的键入常数。\r\n            \r\n","\r\n            CONSIDER: We can remove the above restriction and possibility of cycle if we do an\r\n            early binding of some well known attributes.\r\n            ":"\r\n            考虑：如果我们执行\r\n            一些知名属性的早期结合。\r\n            \r\n","Called when the visitor visits a CasePatternSwitchLabelSyntax node.":"当访客访问casepatternswitchlabelsyntax节点时，请致电。\r\n","If tuple element names are specified, the number of element names must match the cardinality of the tuple.":"如果指定了元组元素名称，则元素名称的数量必须匹配元组的基数。\r\n","\r\n              Looks up a localized string similar to Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create character literal tokens..\r\n            ":"\r\n              查找类似于使用Microsoft.codeanalysis.csharp.syntaxfactory.literal的本地化字符串，以创建字符文字令牌。\r\n            \r\n","The syntax for the invoked method, including receiver.":"调用方法的语法，包括接收器。\r\n","CLS compliance checking will not be performed because it is not visible from outside this assembly":"CLS合规性检查将不会进行\r\n","True if the attribute data matches.":"如果属性数据匹配，则为正确。\r\n","\r\n            A method can me marked as RequiresSecurityObject by applying the DynamicSecurityMethodAttribute in source.\r\n            DynamicSecurityMethodAttribute is a pseudo custom attribute defined as an internal class in System.Security namespace.\r\n            This attribute is set on certain security methods defined within mscorlib.\r\n            ":"\r\n            通过在源中应用DynamicSecurityMethodattribute，可以将我标记为“需要”的方法。\r\n            DynamicSecurityMethodattribute是一种伪自定义属性，该属性定义为System.Security名称空间中的内部类。\r\n            此属性是在Mscorlib中定义的某些安全方法上设置的。\r\n            \r\n","\r\n            Helper method to generate a bound expression with HasErrors set to true.\r\n            Returned bound expression is guaranteed to have a non-null type, except when ":"\r\n            使用HaserRors设置为true的辅助方法的帮助方法。\r\n            返回的绑定表达式保证具有非零类型，除非\r\n","\r\n              Looks up a localized string similar to '{0}': virtual or abstract members cannot be private.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串：虚拟成员或抽象成员不能私有。\r\n            \r\n","\r\n            Determine what we can learn from one successful runtime type test about another planned\r\n            runtime type test for the purpose of building the decision tree.\r\n            We accommodate a special behavior of the runtime here, which does not match the language rules.\r\n            A value of type `int[]` is an \"instanceof\" (i.e. result of the `isinst` instruction) the type\r\n            `uint[]` and vice versa.  It is similarly so for every pair of same-sized numeric types, and\r\n            arrays of enums are considered to be their underlying type.  We need the dag construction to\r\n            recognize this runtime behavior, so we pretend that matching one of them gives no information\r\n            on whether the other will be matched.  That isn't quite correct (nothing reasonable we do\r\n            could be), but it comes closest to preserving the existing C#7 behavior without undesirable\r\n            side-effects, and permits the code-gen strategy to preserve the dynamic semantic equivalence\r\n            of a switch (on the one hand) and a series of if-then-else statements (on the other).\r\n            See, for example, https://github.com/dotnet/roslyn/issues/35661\r\n            ":"\r\n            确定我们可以从一项成功的运行时类型测试中学到什么\r\n            运行时类型测试是为了构建决策树的目的。\r\n            我们在这里适应运行时的特殊行为，这与语言规则不符。\r\n            类型`int []`是“实例”的值（即`iasinst'指令的结果）\r\n            `uint []`，反之亦然。同样，对于每对相同大小的数字类型，\r\n            枚举阵列被认为是其基础类型。我们需要DAG结构\r\n            识别这种运行时行为，因此我们假装匹配其中一个没有提供任何信息\r\n            关于另一个是否会匹配。那不是完全正确的（我们没什么合理的\r\n            可能是），但最接近保留现有的C＃7行为而没有不良的行为\r\n            副作用，并允许代码 - 基因策略保留动态语义等效性\r\n            开关（一方面）和一系列If-then-else语句（另一方面）。\r\n            参见，例如，https：//github.com/dotnet/roslyn/issues/35661\r\n            \r\n","Multiple implementations of the query pattern were found for source type '{0}'.  Ambiguous call to '{1}'.":"为“ {0}”源类型找到了查询模式的多个实现。模棱两可的呼叫“ {1}”。\r\n","\r\n            The set of trees for which a ":"\r\n            一组树木\r\n","Method-level AsyncMethodBuilder":"方法级异步线\r\n","\r\n            Given a compilation unit syntax, get the corresponding Simple Program entry point symbol.\r\n            ":"\r\n            给定汇编单元语法，获取相应的简单程序入口点符号。\r\n            \r\n","\r\n            Compute the flow state resulting from reading from an lvalue.\r\n            ":"\r\n            计算由LVALUE读取导致的流量。\r\n            \r\n"," field in this type matches ":" 此类型中的字段匹配\r\n","\r\n            Binds a lambda with expression e as either { return e; } or { e; }.\r\n            ":"\r\n            将lambda绑定为表达式e {return e; }或{e; }。\r\n            \r\n","Partial method declarations of '{0}' have inconsistent constraints for type parameter '{1}'":"'{0}'的部分方法声明对类型参数'{1}'的约束不一致\r\n","The inherited members '{0}' and '{1}' have the same signature in type '{2}', so they cannot be overridden":"继承的成员'{0}'和'{1}'在类型'{2}'中具有相同的签名，因此不能覆盖它们\r\n","variable":"多变的\r\n","Since '{0}' is an async method that returns 'Task', a return keyword must not be followed by an object expression. Did you intend to return 'Task<T>'?":"由于'{0}'是返回'任务'的异步方法，因此不得返回关键字，然后遵循对象表达式。您打算返回“任务<t>”？\r\n","\r\n              Looks up a localized string similar to Members of readonly field '{0}' cannot be modified (except in a constructor or a variable initializer).\r\n            ":"\r\n              查找类似于ReadOnly字段'{0}'成员的本地化字符串，无法修改（在构造函数或变量初始器中除外）。\r\n            \r\n","\r\n              Looks up a localized string similar to The event '{0}' can only appear on the left hand side of += or -= (except when used from within the type '{1}').\r\n            ":"\r\n              查找类似于事件'{0}'的本地化字符串，只能出现在 +=或 -  =的左侧（当从类型'{1}'中使用时）。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot pass argument with dynamic type to params parameter '{0}' of local function '{1}'..\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法将带有动态类型的参数传递给参数参数'{0}本地函数'{1}'..\r\n            \r\n","Cannot inherit interface '{0}' with the specified type parameters because it causes method '{1}' to contain overloads which differ only on ref and out":"不能用指定的类型参数继承界面'{0}'，因为它导致方法'{1}'包含过载，而过载仅在Ref和Out上有所不同\r\n","\r\n            The signature of the function located at the target memory address.\r\n            ":"\r\n            位于目标内存地址的函数的签名。\r\n            \r\n","set if a false result on ":"如果在错误的结果上设置\r\n","Node representing the optional calling convention.":"表示可选通话约定的节点。\r\n","\r\n            Any special attributes we may be referencing directly as an attribute on this type or\r\n            through a using alias in the file. For example\r\n            ":"\r\n            我们可能直接引用此类型的属性的任何特殊属性或\r\n            通过文件中的使用别名。例如\r\n            \r\n"," as an identifier.\r\n            ":" 作为标识符。\r\n            \r\n","Creates a new UnaryPatternSyntax instance.":"创建一个新的UnaryPatternsyntax实例。\r\n","Called when the visitor visits a DefaultSwitchLabelSyntax node.":"当访问者访问Defaultswitchlabelsyntax节点时，请致电。\r\n","\r\n            Not yet known value is represented by ErrorTypeSymbol.UnknownResultType\r\n            ":"\r\n            尚不知道的值由errortypesymbol.inknownresulttype表示\r\n            \r\n","\r\n            Generate a not-null check and a type check.\r\n            ":"\r\n            生成一个不编号的检查和类型检查。\r\n            \r\n","\r\n              Looks up a localized string similar to Unsafe type '{0}' cannot be used in object creation.\r\n            ":"\r\n              在对象创建中查找类似于不安全类型'{0}'类型的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to {0} is not a valid C# compound assignment operation.\r\n            ":"\r\n              查找类似于{0}的本地化字符串不是有效的C＃复合分配操作。\r\n            \r\n","To cast a negative value, you must enclose the value in parentheses.":"要投下负值，您必须将值包装在括号中。\r\n","\r\n            Intended behavior: this event, E, explicitly implements an interface event, IE, \r\n            if E.add explicitly implements IE.add and E.remove explicitly implements IE.remove.\r\n            ":"\r\n            预期行为：此事件E，明确实现接口事件，即\r\n            如果E.Add明确实现IE.Add和E.Remove明确实现IE.emove。\r\n            \r\n","\r\n            A lazily calculated diagnostic for missing [NonNullTypes(true)].\r\n            ":"\r\n            懒散地计算出的缺失[nonulltypes（true）]的诊断。\r\n            \r\n","Called when the visitor visits a WhenClauseSyntax node.":"当访问者访问何时clalesyntax节点时，请致电。\r\n","\r\n            Gets the NameSyntax associated with the syntax node\r\n            If no syntax is attached it sets the nameString to plain text\r\n            name and returns a null NameSyntax\r\n            ":"\r\n            获取与语法节点关联的nameyntax\r\n            如果没有附加语法，则将命名的纯文本设置为\r\n            名称并返回一个空名称\r\n            \r\n","Method, operator, or accessor '{0}' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation.":"方法，操作员或登录器'{0}'被标记为外部，并且没有属性。考虑添加dllimport属性以指定外部实现。\r\n"," if the attributes apply to the symbol itself.":" 如果属性适用于符号本身。\r\n","\r\n            Returns the inferred signature as a ":"\r\n            返回推断的签名作为\r\n","\r\n              Looks up a localized string similar to SecurityAction value '{0}' is invalid for security attributes applied to an assembly.\r\n            ":"\r\n              查找类似于SecurityAction值'{0}'的本地化字符串对于应用于汇编的安全属性无效。\r\n            \r\n","Use of default literal is not valid in this context":"在这种情况下，使用默认文字是无效的\r\n","\r\n              Looks up a localized string similar to Unable to load Analyzer assembly.\r\n            ":"\r\n              查找类似于无法加载分析仪组件的局部字符串。\r\n            \r\n","Initializer Syntax.":"初始化器语法。\r\n","Invalid image base number '{0}'":"无效的图像基数'{0}'\r\n"," node is contained any SyntaxTree in the current Compilation.":"节点包含当前汇编中的任何语法。\r\n","Attribute to match.":"匹配属性。\r\n","Cannot convert type '{0}' to '{1}' via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion":"无法通过参考转换，拳击转换，拆箱转换，包装转换或NULL类型转换将类型的'{0}'转换为'{1}'\r\n","\r\n            SubstType, but for NamedTypeSymbols only.  This is used for concrete types, so no alpha substitution appears in the result.\r\n            ":"\r\n            orptype，但仅用于命名typesymbols。这用于混凝土类型，因此结果中没有出现alpha替代。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': static classes cannot be used as constraints.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串：静态类不能用作约束。\r\n            \r\n","\r\n            Return a list of assembly symbols than can be accessed without using an alias.\r\n            For example:\r\n              1) /r:A.dll /r:B.dll -> A, B\r\n              2) /r:Goo=A.dll /r:B.dll -> B\r\n              3) /r:Goo=A.dll /r:A.dll -> A\r\n            ":"\r\n            返回一个装配符号列表，而不是不使用别名就可以访问。\r\n            例如：\r\n              1） /r：a.dll /r：b.dll-> a，b\r\n              2） /r:goo = a.dll /r：b.dll-> b\r\n              3） /r：goo = a.dll /r：a.dll-> a\r\n            \r\n","\r\n            Writes ref and out parameters\r\n            ":"\r\n            写入参考参数\r\n            \r\n","--":" -   - \r\n","An anonymous type cannot have multiple properties with the same name":"匿名类型不能具有相同名称的多个属性\r\n","\r\n             ACASEY: This grammar is derived from the behavior and sources of the native compiler.\r\n             Tokens start with underscores (I've cheated for _PredefinedTypeToken, which is not actually a\r\n             SyntaxKind), \"*\" indicates \"0 or more\", \"?\" indicates \"0 or 1\", and parentheses are for grouping.\r\n             \r\n             Cref\t \t\t\t= CrefType _DotToken CrefMember\r\n             \t\t\t\t\t| CrefType\r\n             \t\t\t\t\t| CrefMember\r\n                                 | CrefFirstType _OpenParenToken CrefParameterList? _CloseParenToken\r\n             CrefName\t\t\t= _IdentifierToken (_LessThanToken _IdentifierToken (_CommaToken _IdentifierToken)* _GreaterThanToken)?\r\n             CrefFirstType \t\t= ((_IdentifierToken _ColonColonToken)? CrefName) \r\n                                 | _PredefinedTypeToken\r\n             CrefType \t\t\t= CrefFirstType (_DotToken CrefName)*\r\n             CrefMember \t\t\t= CrefName (_OpenParenToken CrefParameterList? _CloseParenToken)?\r\n             \t\t\t\t\t| _ThisKeyword (_OpenBracketToken CrefParameterList _CloseBracketToken)?\r\n             \t\t\t\t\t| _OperatorKeyword _OperatorToken (_OpenParenToken CrefParameterList? _CloseParenToken)?\r\n             \t\t\t\t\t| (_ImplicitKeyword | _ExplicitKeyword) _OperatorKeyword CrefParameterType (_OpenParenToken CrefParameterList? _CloseParenToken)?\r\n             CrefParameterList\t= CrefParameter (_CommaToken CrefParameter)*\r\n             CrefParameter\t\t= (_RefKeyword | _OutKeyword)? CrefParameterType\r\n             CrefParameterType\t= CrefParameterType2 _QuestionToken? _AsteriskToken* (_OpenBracketToken _CommaToken* _CloseBracketToken)*\r\n             CrefParameterType2 \t= (((_IdentifierToken _ColonColonToken)? CrefParameterType3) | _PredefinedTypeToken) (_DotToken CrefParameterType3)*\r\n             CrefParameterType3 \t= _IdentifierToken (_LessThanToken CrefParameterType (_CommaToken CrefParameterType)* _GreaterThanToken)?\r\n            \r\n             NOTE: type parameters, not type arguments\r\n             NOTE: the first production of Cref is preferred to the other two\r\n             NOTE: pointer, array, and nullable types only work in parameters\r\n             NOTE: CrefParameterType2 and CrefParameterType3 correspond to CrefType and CrefName, respectively.\r\n             Since the only difference is that they accept non-identifier type arguments, this is accomplished\r\n             using parameters on the parsing methods (rather than whole new methods).\r\n             ":"\r\n             Acasey：该语法来自天然编译器的行为和来源。\r\n             令牌从下划线开始（我为_predefinedtypetoken作弊，这实际上不是一个\r\n             语法），“*”指示“ 0或更多”，“？”指示“ 0或1”，括号用于分组。\r\n             \r\n             cref = creftype _dottoken crefmember\r\n             | Creftype\r\n             | Crefmember\r\n                                 | creffirsttype _openparentoken crefparameterList？ _closeparentoken\r\n             crefname = _ identifiertoken（_lessthantoken _istifiertoken（_commatoken _endistifiertoken）* _greaterThantoken）？\r\n             creffirstType =（（（_ identifiertoken _coloncolontoken）？crefname）\r\n                                 | _predefinedTypetoken\r\n             creftype = creffefirsttype（_dottoken crefname）*\r\n             crefmember = crefname（_openparentoken crefparameterList？_closeparentoken）？\r\n             | _ thiskeyword（_openbrackettoken crefparameterlist _closebrackettoken）？\r\n             | _operatorKeyword _operatortoken（_openparentoken crefparameterList？_closeParentoken）？\r\n             | （_implicitKeyword | _explicyKeyword）_operatorKeyword crefparametertype（_openparentoken crefparameterList？_closeParentoken）？\r\n             crefparameterList = crefparameter（_ Commatoken Crefparameter）*\r\n             crefparameter =（_refkeyword | _outkeyword）？ Crefparametertype\r\n             crefparameType = crefparametertype2 _questiontoken？ _asteriskToken*（_openbrackettoken _commatoken* _closebrackettoken）*\r\n             crefparameteType2 =（（（（（（（（_ nistifiertoken），_coloncolontoken）？crefparameteType3）| _ _predefefinedTypeToken）（_dottoken crefparametertype3）*\r\n             crefparametertype3 = _istifiertoken（_lessthantoken crefparameType（_commatoken crefparameType）* _greaterthantoken）？\r\n            \r\n             注意：键入参数，不键入参数\r\n             注意：CREF的首次作品比其他两个产品优先\r\n             注意：指针，数组和无效类型仅在参数中起作用\r\n             注意：CrefparameType2和CrefparameType3分别对应于Creftype和Crefname。\r\n             由于唯一的区别是他们接受非识别符类型参数，因此可以完成\r\n             在解析方法上使用参数（而不是全新的方法）。\r\n             \r\n","\r\n            Gets the locations where the local symbol was originally defined in source.\r\n            There should not be local symbols from metadata, and there should be only one local variable declared.\r\n            TODO: check if there are multiple same name local variables - error symbol or local symbol?\r\n            ":"\r\n            获取最初在源中定义本地符号的位置。\r\n            元数据不应有局部符号，并且只能声明一个局部变量。\r\n            TODO：检查是否有多个相同名称本地变量 - 错误符号或本地符号？\r\n            \r\n","Provided source code kind is unsupported or invalid: '{0}'":"提供的源代码类型不支持或无效：'{0}'\r\n","\r\n            Make a tuple type (with appropriate nesting) from the types (on the left or on the right) collected\r\n            from binding element-wise binary operators.\r\n            If any of the elements is typeless, then the tuple is typeless too.\r\n            ":"从收集的类型（在左侧或右侧）中制作元组类型（带有适当的筑巢）\r\n            来自绑定元素的二进制运算符。\r\n            如果任何元素是无类型的，则元组也没有打字。\r\n            \r\n","\r\n            Reports an error if the await expression did not occur in an async context.\r\n            ":"\r\n            报告如果等待表达在异步上下文中没有发生，则报告错误。\r\n            \r\n","\r\n            Manages anonymous types declared in this compilation. Unifies types that are structurally equivalent.\r\n            ":"\r\n            管理此汇编中声明的匿名类型。统一在结构上等效的类型。\r\n            \r\n","\r\n            The type for which this compilation state is being used.\r\n            ":"\r\n            使用此汇编状态的类型。\r\n            \r\n","\r\n            Bind the cref in the context of the specified location and get semantic information\r\n            such as type, symbols and diagnostics. This method is used to get semantic information about a cref\r\n            that did not actually appear in the source code.\r\n            ":"\r\n            在指定位置的上下文中绑定CREF并获取语义信息\r\n            例如类型，符号和诊断。此方法用于获取有关CREF的语义信息\r\n            实际上并未出现在源代码中。\r\n            \r\n","\r\n            A region analysis walker that computes the set of variables for\r\n            which their assigned values flow out of the region.\r\n            A variable assigned inside is used outside if an analysis that\r\n            treats assignments in the region as unassigning the variable would\r\n            cause \"unassigned\" errors outside the region.\r\n            ":"\r\n            一个计算变量集的区域分析步行器\r\n            其分配的值流出该区域。\r\n            如果分析\r\n            将区域中的分配视为尚未分配的变量\r\n            导致该地区以外的“未分配”错误。\r\n            \r\n","Called when the visitor visits a UndefDirectiveTriviaSyntax node.":"当访客访问UndirectivetriviaSyntax节点时，请致电。\r\n","\r\n            A type can me marked as a ComImport type in source by applying the ":"\r\n            我可以通过应用\r\n","\r\n            Misc implementation metadata flags (ImplFlags in metadata).\r\n            ":"\r\n            MISC实施元数据标志（元数据中的Implflags）。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' does not implement interface member '{1}'. '{2}' cannot implicitly implement a non-public member..\r\n            ":"\r\n              查找类似于“ {0}'的本地化字符串”不实现接口成员'{1}'。 '{2}'不能隐式实施非公共成员。\r\n            \r\n","Represents a switch statement syntax.":"表示开关语句语法。\r\n","\r\n            The name of the namespace.\r\n            ":"\r\n            名称空间的名称。\r\n            \r\n","Duplicate '{0}' attribute":"重复'{0}'属性\r\n","\r\n              Looks up a localized string similar to Cannot bind delegate to '{0}' because it is a member of 'System.Nullable<T>'.\r\n            ":"\r\n              查找类似于“ {0}”的局部字符串，因为它是'system.nullable <t>'的成员。\r\n            \r\n","\r\n            Parse expected lambda expression but assume `x ? () => y :` is a conditional\r\n            expression rather than a lambda expression with an explicit return type and\r\n            return null in that case only.\r\n            ":"\r\n            解析预期的lambda表达，但假设`x？ （）=> y：`是有条件的\r\n            表达而不是具有显式返回类型的lambda表达式\r\n            仅在这种情况下返回null。\r\n            \r\n","\r\n            The result of this method captures some AnalyzedArguments, which must be free'ed by the caller.\r\n            ":"\r\n            该方法的结果捕获了一些分析的量，必须由呼叫者释放。\r\n            \r\n","\r\n              Looks up a localized string similar to The parameter has multiple distinct default values..\r\n            ":"\r\n              查找类似于参数的本地化字符串具有多个不同的默认值。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' has no accessible constructors which use only CLS-compliant types.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串，没有仅使用符合CLS类型的访问构造函数。\r\n            \r\n","Could not write to output file '{0}' -- '{1}'":"无法写入输出文件'{0}' - '{1}'\r\n","\r\n            Verifies that outbound assignments (from parameter to argument) are safe and\r\n            tracks those assignments (or learns from post-condition attributes)\r\n            ":"验证出站分配（从参数到参数）是安全的，并且\r\n            跟踪这些作业（或从条件后属性中学习）\r\n            \r\n","The type of frame to be returned":"要返回的框架类型\r\n","\r\n              Looks up a localized string similar to The '{0}' attribute is valid only on an indexer that is not an explicit interface member declaration.\r\n            ":"\r\n              查找类似于“ {0}”属性类似的本地化字符串仅在不是显式接口成员声明的索引器上有效。\r\n            \r\n","\r\n            In NetFx 4.0, block array initializers do not work on all combinations of {32/64 X Debug/Retail} when array elements are enums.\r\n            This is fixed in 4.5 thus enabling block array initialization for a very common case.\r\n            We look for the presence of ":"\r\n            在NetFX 4.0中，当数组元素是枚举时，块数组初始化器不适用于{32/64 x调试/零售}的所有组合。\r\n            这是在4.5中固定的，因此可以为一个非常常见的情况启用块数组初始化。\r\n            我们寻找存在\r\n","\r\n            A bit array containing the nullability of variables associated with a method scope. If the method is a\r\n            nested function (a lambda or a local function), there is a reference to the corresponding instance for\r\n            the containing method scope. The instances in the chain are associated with a corresponding\r\n            ":"\r\n            一个位数组，包含与方法范围关联的变量的无效性。如果该方法是\r\n            嵌套功能（lambda或本地功能），有一个对相应实例的引用\r\n            包含方法范围。链中的实例与相应的\r\n            \r\n","\r\n            If an argument fails to convert to the type of the corresponding parameter and that\r\n            parameter is a params array, then the error message should reflect the element type\r\n            of the params array - not the array type.\r\n            ":"\r\n            如果一个参数未能转换为相应参数的类型，则\r\n            参数是一个参数数组，然后错误消息应反映元素类型\r\n            参数数组 - 而不是数组类型。\r\n            \r\n","\r\n            Returns false because field can't be defined externally.\r\n            ":"返回false，因为无法外部定义字段。\r\n            \r\n"," of the Dispose method if one is found, otherwise null.":" 如果找到一种，则为处置方法，否则为null。\r\n","\r\n            Returns true if this symbol requires an instance reference as the implicit reciever. This is false if the symbol is static.\r\n            ":"\r\n            如果此符号需要实例参考作为隐式接收器，则返回true。如果符号是静态的，这是错误的。\r\n            \r\n","\r\n            The scope of the expression that contained the interpolated string during initial binding. This is used to determine the SafeToEscape rules\r\n            for the builder during lowering.\r\n            ":"\r\n            在初始结合过程中包含插值字符串的表达式的范围。这用于确定Safetoescape规则\r\n            在降低期间为建筑商而言。\r\n            \r\n","Use of unassigned local variable '{0}'":"使用未分配的本地变量'{0}'\r\n","\r\n            Returns true if calls and delegate invocations with this\r\n            expression as the receiver should be non-virtual calls.\r\n            ":"\r\n            返回true如果通话并将其委派授权\r\n            作为接收器的表达应为非虚拟呼叫。\r\n            \r\n","\r\n            Returns Feature(\"run-nullable-analysis\") as a bool? value:\r\n            true for \"always\"; false for \"never\"; and null otherwise.\r\n            ":"\r\n            返回功能（“无效 - 分析”）作为布尔？价值：\r\n            为“始终”；虚假的“永不”；否则为无效。\r\n            \r\n","\r\n            Report diagnostics that should be reported when using a synthesized attribute. \r\n            ":"\r\n            报告使用合成属性时应报告的诊断。\r\n            \r\n","\r\n            Gets the syntax list of custom attributes that declares attributes for this method symbol.\r\n            ":"\r\n            获取自定义属性的语法列表，该属性声明此方法符号的属性。\r\n            \r\n","\r\n            This property invokes force completion of attributes. If you are accessing this property\r\n            from the binder, make sure that we are not binding within an Attribute context.\r\n            This could lead to a possible cycle in attribute binding.\r\n            We can avoid this cycle by first checking if we are within the context of an Attribute argument,\r\n            i.e. if(!binder.InAttributeArgument) { ...  namedType.ComImportCoClass ... }\r\n            ":"\r\n            该属性调用属性的力完成。如果您要访问此属性\r\n            从活页夹中，确保我们不在属性上下文中绑定。\r\n            这可能导致属性结合中可能的循环。\r\n            我们可以首先检查我们是否在属性参数的上下文中，可以避免此周期\r\n            即if（！binder.inattributeargument）{... nesstype.com.importcoclass ...}\r\n            \r\n","\r\n              Looks up a localized string similar to Unmanaged type '{0}' is only valid for fields..\r\n            ":"\r\n              查找类似于非托管类型的本地化字符串'{0}'仅适用于字段。\r\n            \r\n","??":"？\r\n"," with attached names.\r\n             \r\n             ":"带有附件的名称。\r\n             \r\n             \r\n","\r\n            Get all bounds nodes associated with a node, ordered from highest to lowest in the bound tree.\r\n            Strictly speaking, the order is that of a pre-order traversal of the bound tree.\r\n            ":"\r\n            获取与节点关联的所有边界节点，从绑定树中的最高到最低排序。\r\n            严格来说，该顺序是绑定树的预订遍历。\r\n            \r\n","{ expected":"{ 预期的\r\n","Unable to include XML fragment '{1}' of file '{0}' -- {2}":"无法包含XML Fragment'{1}'的文件'{0}' -  {2}\r\n","\r\n              Looks up a localized string similar to Possible unintended reference comparison; to get a value comparison, cast the left hand side to type '{0}'.\r\n            ":"\r\n              查找类似于可能意外参考比较的局部字符串；要获得值比较，请将左侧施放到键入'{0}'。\r\n            \r\n","\r\n              Looks up a localized string similar to Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance definition for '{1}'. Did you mean 'foreach' rather than 'await foreach'?.\r\n            ":"\r\n              查找类似于异步的foreach语句类似的本地化字符串无法在类型'{0}'的变量上操作，因为'{0}'不包含'{1}'的公共实例定义。您的意思是“ foreach”而不是“等待foreach”？\r\n            \r\n","\r\n            using (x) { } // x counts\r\n            using (IDisposable y = null) { } // y does not count\r\n            ":"\r\n            使用（x）{} // x计数\r\n            使用（idisposable y = null）{} // y不计数\r\n            \r\n","\r\n              Looks up a localized string similar to Interfaces cannot contain conversion, equality, or inequality operators.\r\n            ":"\r\n              查找类似于接口的本地化字符串不能包含转换，平等或不平等运算符。\r\n            \r\n","\r\n              Looks up a localized string similar to Passing a field of a marshal-by-reference class as ref or out or taking its address may cause a runtime exception.\r\n            ":"\r\n              查找类似于将元帅类别的字段（作为参考，或取出其地址）传递的局部字符串可能会导致运行时例外。\r\n            \r\n","Referenced assembly '{0}' does not have a strong name.":"引用的汇编'{0}'没有强的名称。\r\n","\r\n            Any special attributes we may be referencing through a using alias in the file.\r\n            For example ":"\r\n            我们可以通过文件中的使用别名引用的任何特殊属性。\r\n            例如\r\n","\r\n            A base class for components that instrument various portions of executable code.\r\n            It provides a set of APIs that are called by ":"\r\n            一个组件的基类，可以启动可执行代码的各个部分。\r\n            它提供了一组API\r\n"," visitor that visits only the single CSharpSyntaxNode\r\n            passed into its Visit method and produces \r\n            a value of the type specified by the ":" 仅访问单个csharpsyntaxnode的访客\r\n            传递到访问方法并生产\r\n            由\r\n","Type '{1}' already defines a member called '{0}' with the same parameter types":"键入'{1}'已经定义了一个名为'{0}'的成员使用相同的参数类型\r\n","\r\n              Looks up a localized string similar to Algorithm '{0}' is not supported.\r\n            ":"\r\n              不支持查找类似于算法'{0}'的本地化字符串。\r\n            \r\n","'{0}' must declare a body because it is not marked abstract, extern, or partial":"'{0}'必须声明身体，因为它没有标记为抽象，外部或部分\r\n","\r\n              Looks up a localized string similar to Type or member cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute.\r\n            ":"\r\n              查找类似于类型或成员的本地化字符串不能标记为CLS兼容，因为组件没有CLSCompliant属性。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot await in a catch clause.\r\n            ":"\r\n              在捕获子句中查找类似于无法等待的本地化字符串。\r\n            \r\n","\r\n            True if the list has at least one trivia of the specified kind.\r\n            ":"\r\n            是的，如果列表至少有指定类型的琐事。\r\n            \r\n","\r\n            Returns true if the conversion is an implicit tuple conversion or explicit tuple conversion.\r\n            ":"\r\n            如果转换是隐式元组转换或明确的元组转换，则返回true。\r\n            \r\n","A symbol for the well-known member, or null if it is missing and isOptions == true":"众所周知成员的符号，如果缺失了，则null == true\r\n","Type is for evaluation purposes only and is subject to change or removal in future updates.":"类型仅用于评估目的，并且可能会在以后的更新中进行更改或删除。\r\n","\r\n            WARN: Must not check method.MethodKind - PEMethodSymbol.ComputeMethodKind uses this method.\r\n            NOTE: Does not check whether the given method will be marked \"newslot\" in metadata (as\r\n            \"newslot\" is used for covariant method overrides).\r\n            ":"\r\n            警告：不得检查方法。Methodkind-pemethodsymbol.computemethodkind使用此方法。\r\n            注意：不要检查给定方法是否会在元数据中标记为“ newslot”（AS\r\n            “ NewsLot”用于协变量方法覆盖）。\r\n            \r\n","\r\n            Get the next binder in which to look up a name, if not found by this binder, asserting if `Next` is null.\r\n            ":"\r\n            获取下一个可以查找名称的活页夹，如果该活页夹找不到的话，请断言``next''是null。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot define/undefine preprocessor symbols after first token in file.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法定义/不确定的预处理程序符号。\r\n            \r\n",",\r\n            the ":"，，，，\r\n            这\r\n","Asynchronous foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNextAsync' method and public 'Current' property":"异步范围要求'{1}'的返回类型'{0}'必须具有合适的公共'moveNextAsync'方法和公共'当前'属性\r\n",". We don't include manifest resources in ref assemblies":"。我们不在参考组装中包括清单资源\r\n","\r\n              Looks up a localized string similar to Type has no accessible constructors which use only CLS-compliant types.\r\n            ":"\r\n              查找类似于类型的本地化字符串，没有仅使用符合CLS类型的访问构造函数。\r\n            \r\n","\r\n            One would expect this comparer to have requireSourceMethod = true, but it doesn't because (for source types)\r\n            we allow inexact matching of custom modifiers when computing implicit member implementations. Consider the\r\n            following scenario: interface I has a method M with custom modifiers C1, source type ST includes I in its\r\n            interface list but has no method M, and metadata type MT has a method M with custom modifiers C2.\r\n            In this scenario, we want to compare I.M to MT.M without regard to custom modifiers, because if C1 != C2,\r\n            we can just synthesize an explicit implementation of I.M in ST that calls MT.M.\r\n            ":"\r\n            人们会期望此比较具有sirceorsourcemethod = true，但这不是因为（对于源类型）\r\n            在计算隐式成员实现时，我们允许自定义修饰符的不精确匹配。考虑一下\r\n            以下方案：接口i具有具有自定义修饰符C1的方法m，源类型ST包括在其中\r\n            接口列表，但没有方法M，并且Metadata Type MT具有带有自定义修饰符C2的方法M。\r\n            在这种情况下，我们希望将I.M与MT.M进行比较，而无需考虑自定义修饰符，因为如果C1！= C2，\r\n            我们可以在ST中综合I.M的明确实现，该实现致电MT.M.\r\n            \r\n"," object\r\n            associated with a member within substituted type, ":" 目的\r\n            与替代类型中的成员相关联\r\n","\r\n            The smallest value of ":"\r\n            最小的价值\r\n","Class which represents the syntax node for member binding expression.":"代表成员结合表达的语法节点的类。\r\n","\r\n            Returns the constraint kind for the given type parameter.\r\n            ":"\r\n            返回给定类型参数的约束类型。\r\n            \r\n","\r\n            This is a layer on top of the Compilation version that generates a diagnostic if the well-known\r\n            type isn't found.\r\n            ":"\r\n            这是汇编版本顶部的一层，如果众所周知\r\n            找不到类型。\r\n            \r\n","Cannot use anonymous type in a constant expression":"不能在恒定表达式中使用匿名类型\r\n","\r\n            Takes an expression and returns the bound local expression \"temp\" \r\n            and the bound assignment expression \"temp = expr\".\r\n            ":"\r\n            采用表达式并返回绑定的局部表达式“ temp”\r\n            和绑定的分配表达式“ temp = expr”。\r\n            \r\n","\r\n              Looks up a localized string similar to Fixed size buffer fields may only be members of structs.\r\n            ":"\r\n              查找类似于固定尺寸缓冲区字段的本地化字符串可能仅是结构的成员。\r\n            \r\n","\r\n              Looks up a localized string similar to No source files specified.\r\n            ":"\r\n              查找类似于未指定源文件的本地化字符串。\r\n            \r\n","\r\n            The intermediate type to which the output of the ":"\r\n            输出的中间类型\r\n","\r\n            Create a new nested scope under the current scope, and replace ":"\r\n            在当前范围下创建一个新的嵌套范围，然后替换\r\n","Called when the visitor visits a TypeCrefSyntax node.":"当访问者访问typecrefsyntax节点时，请致电。\r\n","Required white space was missing.":"缺少所需的空白。\r\n","\r\n              Looks up a localized string similar to The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'..\r\n            ":"\r\n              查找类似于“ {0}”类型的本地化字符串与导入的命名空间'{3}'中的类型“ {1}”中的类似。使用“ {0}”中定义的类型。\r\n            \r\n","If a method group conversion, the desired ref kind of the delegate":"如果方法组转换，则所需的裁判类型\r\n","'is' expression's given expression is never of the provided type":"“是”表达式的表达式永远不会是提供的类型\r\n","\r\n            During early attribute decoding, we consider a safe subset of all members that will not\r\n            cause cyclic dependencies.  Get all such members for this symbol that have a particular name.\r\n            \r\n            In particular, this method will return nested types and fields (other than auto-property\r\n            backing fields).\r\n            ":"\r\n            在早期属性解码期间，我们考虑所有成员的安全子集\r\n            导致循环依赖性。获取具有特定名称的此符号的所有此类成员。\r\n            \r\n            特别是，此方法将返回嵌套类型和字段（自动范围除外\r\n            支持字段）。\r\n            \r\n","\r\n            Check that the pattern type is valid for the operand. Return true if an error was reported.\r\n            ":"\r\n            检查模式类型是否对操作数有效。如果报告错误，请返回true。\r\n            \r\n","\r\n            Assumes that the local symbol will be declared (i.e. in the LocalsOpt array) of an enclosing block.\r\n            Assumes that using statements with multiple locals have already been split up into multiple using statements.\r\n            ":"\r\n            假设将在封闭块中声明本地符号（即在localsopt数组中）。\r\n            假设使用多个当地人使用语句已经被分为多个使用语句。\r\n            \r\n","\r\n              Looks up a localized string similar to Do not use refout when using refonly..\r\n            ":"\r\n              查找类似于使用重新装置时不使用Refout的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Async methods cannot have by reference locals.\r\n            ":"\r\n              查找类似于异步方法的本地化字符串，无法通过参考当地人使用。\r\n            \r\n","\r\n            Look for names in scope\r\n            ":"\r\n            在范围内查找名称\r\n            \r\n","'{0}' duplicate TypeForwardedToAttribute":"'{0}'重复type typeforwardedtoattribute\r\n","Creates a new ImplicitElementAccessSyntax instance.":"创建一个新的intimitelementAccessSyntax实例。\r\n","\r\n            An ErrorSymbol is used when the compiler cannot determine a symbol object to return because\r\n            of an error. For example, if a field is declared \"Goo x;\", and the type \"Goo\" cannot be\r\n            found, an ErrorSymbol is returned when asking the field \"x\" what it's type is.\r\n            ":"\r\n            当编译器无法确定要返回的符号对象时，请使用错误符号\r\n            错误。例如，如果字段声明为“ goo x;”，而类型“ goo”不能为\r\n            发现，当询问字段“ x”字段时，将返回一个错误符号。\r\n            \r\n","Inconsistent accessibility: constraint type '{1}' is less accessible than '{0}'":"不一致的可访问性：约束类型'{1}'比'{0}'不太访问\r\n","Class which represents the syntax node for a range expression.":"表示范围表达式的语法节点的类。\r\n","\r\n            A delegate to create the final (guarded) decision in a path when adding to the decision tree.\r\n            ":"添加到决策树时，代表在路径中创建最终（保护）决定。\r\n            \r\n","Local name is too long for PDB":"PDB的本地名称太长了\r\n","\r\n            Represents an interactive code entry point that is inserted into the compilation if there is not an existing one. \r\n            ":"\r\n            代表一个交互式代码输入点，如果没有现有的代码输入点，则将其插入汇编。\r\n            \r\n","'{0}' does not implement interface member '{1}'":"'{0}'不实现接口成员'{1}'\r\n","\r\n            Internal for testing.  Non-test code should use ":"\r\n            内部测试。非测试代码应使用\r\n","'await' requires that the type {0} have a suitable 'GetAwaiter' method":"“等待”要求类型{0}具有合适的'getawaiter'方法\r\n","\r\n            Is this is an _ identifier in a context where discards are allowed?\r\n            ":"\r\n            在允许丢弃的情况下，这是_标识符吗？\r\n            \r\n","\r\n            A trivia with kind EndOfLineTrivia containing a single carriage return character.\r\n            ":"\r\n            带有单个马车返回特征的善良内翼曲线的琐事。\r\n            \r\n","The * or -> operator must be applied to a pointer":"*或 - >运算符必须应用于指针\r\n","'{0}' does not implement interface member '{1}'. '{2}' is not public.":"'{0}'不实现接口成员'{1}'。 '{2}'不是公开。\r\n","\r\n            An array of assemblies involved in canonical type resolution of\r\n            NoPia local types defined within this assembly. In other words, all \r\n            references used by a compilation referencing this assembly.\r\n            The array and its content is provided by ReferenceManager and must not be modified.\r\n            ":"\r\n            参与规范类型分辨率的一系列组件\r\n            NOPIA在此组件中定义的本地类型。换句话说，所有人\r\n            参考此组件的汇编使用的参考文献。\r\n            数组及其内容由ReferenceManager提供，不得修改。\r\n            \r\n","\r\n              Looks up a localized string similar to A pointer must be indexed by only one value.\r\n            ":"\r\n              查找类似于指针的本地化字符串必须仅由一个值索引。\r\n            \r\n"," of the conversion.":" 转换。\r\n","\r\n             Produces the underlying ValueTuple corresponding to this list of element types.\r\n            \r\n             Pass a null diagnostic bag and syntax node if you don't care about diagnostics.\r\n             ":"\r\n             产生与此元素类型列表相对应的基本估值。\r\n            \r\n             如果您不在乎诊断，则通过无效的诊断袋和语法节点。\r\n             \r\n","\r\n            The assembly to which the given type is forwarded or null, if there isn't one.\r\n            ":"\r\n            如果没有，则给定类型的组件转发或无效。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot specify default parameter value in conjunction with DefaultParameterAttribute or OptionalAttribute.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法与DefaultParameterAttribute或OptionalAttribute一起指定默认参数值。\r\n            \r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 5.  Please use language version {1} or greater..\r\n            ":"\r\n              查找类似于功能'{0}'的本地化字符串。\r\n            \r\n","'{0}': an entry point cannot be generic or in a generic type":"'{0}'：入口点不能是通用的，也不能是通用类型\r\n","If we're being called while parsing a C# top-level statements (Script or Simple Program).\r\n            At the top level in Script, we allow most statements *except* for local-decls/local-funcs.\r\n            Those will instead be parsed out as script-fields/methods.":"如果我们在解析C＃顶级语句（脚本或简单程序）时被调用。\r\n            在脚本中的最高级别，我们允许大多数语句 *除 * local-decls/local-funcs之外。\r\n            相反，这些将被解析为脚本场/方法。\r\n","\r\n            Translate a statement that declares a given set of locals.  Also allocates and frees hoisted temps as\r\n            required for the translation.\r\n            ":"\r\n            翻译一个声明，该声明声明一组当地人。还分配并自由将温度吊起\r\n            翻译所需的。\r\n            \r\n","\r\n              Looks up a localized string similar to Type '{1}' already defines a member called '{0}' with the same parameter types.\r\n            ":"\r\n              查找类似于类型的'{1}'的本地化字符串已经定义了一个名为“ {0}”的成员使用相同的参数类型。\r\n            \r\n","\r\n            Return a list of assembly symbols than can be accessed without using an alias.\r\n            For example:\r\n              1) /r:A.dll /r:B.dll -> A, B\r\n              2) /r:Foo=A.dll /r:B.dll -> B\r\n              3) /r:Foo=A.dll /r:A.dll -> A\r\n            ":"\r\n            返回一个装配符号列表，而不是不使用别名就可以访问。\r\n            例如：\r\n              1） /r：a.dll /r：b.dll-> a，b\r\n              2） /r：foo = a.dll /r：b.dll-> b\r\n              3） /r：foo = a.dll /r：a.dll-> a\r\n            \r\n","\r\n              Looks up a localized string similar to Type '{0}' is defined in this assembly, but a type forwarder is specified for it.\r\n            ":"\r\n              在此组件中定义了类似于“ {0}”类型的本地化字符串，但是为其指定了类型的转发器。\r\n            \r\n","Optional list of identifiers that will contribute to an unmanaged calling convention.":"可选的标识符列表将有助于无管理的通话公约。\r\n","\r\n              Looks up a localized string similar to Cannot use '{0}' as a ref or out value because it is a '{1}'.\r\n            ":"\r\n              查找类似于不能使用'{0}'作为ref或out值的本地化字符串，因为它是'{1}'。\r\n            \r\n","\r\n            Return the extension methods from this specific binding scope that match the name and optional\r\n            arity. Since the lookup of extension methods is iterative, proceeding one binding scope at a time,\r\n            GetCandidateExtensionMethods should not defer to the next binding scope. Instead, the caller is\r\n            responsible for walking the nested binding scopes from innermost to outermost. This method is overridden\r\n            to search the available members list in binding types that represent types, namespaces, and usings.\r\n            ":"\r\n            从与名称和可选的特定绑定范围中返回扩展方法\r\n            arity。由于扩展方法的查找是迭代的，因此一次进行一个绑定范围，\r\n            getCandidateExtensionMethods不应延迟下一个绑定范围。相反，呼叫者是\r\n            负责将嵌套的绑定范围从最内向到最外面行走。此方法被覆盖\r\n            搜索表示类型，名称空间和使用的绑定类型中的可用成员列表。\r\n            \r\n","\r\n              Looks up a localized string similar to In order to be applicable as a short circuit operator a user-defined logical operator ('{0}') must have the same return type and parameter types.\r\n            ":"\r\n              查找类似于短路运算符的本地化字符串，用户定义的逻辑运算符（'{0}'）必须具有相同的返回类型和参数类型。\r\n            \r\n","An ImmutableArray containing all the members of this symbol. If this symbol has no members,\r\n            returns an empty ImmutableArray. Never returns null.":"一个包含此符号的所有成员的不可分付款。如果此符号没有成员，\r\n            返回一个空的Immutablearray。永远不会返回零。\r\n"," override ":" 覆盖\r\n","The pattern is unreachable. It has already been handled by a previous arm of the switch expression or it is impossible to match.":"该模式无法到达。它已经由开关表达式的先前臂处理，或者无法匹配。\r\n",", which is either dynamic type OR is a constructed type with dynamic type present in it's type argument tree,\r\n            returns a synthesized DynamicAttribute with encoded dynamic transforms array.\r\n            ":"，它是动态类型，或者是具有动态类型的构造类型，它的类型参数树中存在\r\n            返回具有编码动态变换数组的合成动力学归因。\r\n            \r\n","The return type of the delegate, if known. It isn't\r\n            known when we're attempting to infer the return type of a method group for type inference.":"如果已知的话，代表的返回类型。不是\r\n            当我们试图推断用于类型推理的方法组的返回类型时知道。\r\n","Use of unassigned local variable":"使用未分配的本地变量\r\n","The 8-byte signed integer value to be represented by the returned token.":"8字节签名的整数值将由返回令牌表示。\r\n","\r\n            Returns True or False if we can determine whether the type is managed\r\n            without looking at its fields and Unknown otherwise.\r\n            Also returns whether or not the given type is generic.\r\n            ":"\r\n            如果我们可以确定是否管理类型，则返回对还是错\r\n            不查看其领域，否则未知。\r\n            还返回给定类型是否是通用的。\r\n            \r\n","AppConfigPath must be absolute.":"AppConfigPath必须是绝对的。\r\n","\r\n            NOTE:   We have no GetDeclaredSymbol overloads for subtypes of BaseMethodDeclarationSyntax as all of them return a MethodSymbol.\r\n            ":"\r\n            注意：我们没有GetDeclaredSymbol的超载，因为它们都返回Methodsymbol，因此basemethoddeclarationsyntax的亚型。\r\n            \r\n","\r\n            Returns an array of AssemblySymbol objects corresponding to assemblies referenced \r\n            by this module. Items at the same position from GetReferencedAssemblies and \r\n            from GetReferencedAssemblySymbols should correspond to each other. If reference is \r\n            not resolved by compiler, GetReferencedAssemblySymbols returns MissingAssemblySymbol in the\r\n            corresponding item.\r\n            ":"\r\n            返回与引用的汇编相对应的汇编符号对象\r\n            通过此模块。从GetRefercrededsemblies和\r\n            从GetRefercedsed Assemblysymbols中应相对应。如果参考为\r\n            编译器无法解决，getRefercrededAssemblysymbols返回在此处返回的Assemblysymbol\r\n            相应的项目。\r\n            \r\n","\r\n            WARNING: it is possible that \"list\" is really the underlying builder of a SeparateSyntaxListBuilder,\r\n            so it is important that we not add anything to the list.\r\n            ":"\r\n            警告：“列表”实际上可能是一个分离的基金会的基础构建器，\r\n            因此，重要的是不要在列表中添加任何内容。\r\n            \r\n","\r\n              Looks up a localized string similar to Forwarded type '{0}' conflicts with type declared in primary module of this assembly..\r\n            ":"\r\n              查找类似于转发类型'{0}'冲突的本地化字符串与此汇编主模块中声明的类型冲突。\r\n            \r\n","\r\n              Looks up a localized string similar to You cannot use the fixed statement to take the address of an already fixed expression.\r\n            ":"\r\n              查找类似于您的本地化字符串，无法使用固定的语句来获取已经固定的表达式的地址。\r\n            \r\n","\r\n              Looks up a localized string similar to Type parameter '{0}' has the same name as the type parameter from outer type '{1}'.\r\n            ":"\r\n              查找类似于类型参数'{0}'的本地化字符串与外部类型'{1}'的类型参数具有相同的名称。\r\n            \r\n"," A not-null collection of synthesized methods generated for the current source type. ":" 为当前源类型生成的合成方法的非核算集合。\r\n","\r\n            Condensed flags storing useful information about the ":"\r\n            凝结的标志，存储有用的信息\r\n","\r\n            A class containing factory methods for constructing syntax nodes, tokens and trivia.\r\n            ":"\r\n            一个包含用于构建语法节点，令牌和琐事的工厂方法的类。\r\n            \r\n","\r\n            Returns a hash code for the current ":"\r\n            返回当前的哈希代码\r\n","Predefined type '{0}' is declared in multiple referenced assemblies: '{1}' and '{2}'":"预定义的类型'{0}'在多个引用的汇编中声明：'{1}'和'{2}'\r\n","Outputs without source must have the /out option specified":"没有源的输出必须指定 /OUT选项\r\n","V v = /* expression */":"V V = / *表达式 * /\r\n"," it was found in.\r\n            ":" 它被发现。\r\n            \r\n","\r\n            This symbol is used as the return type of a LambdaSymbol when we are interpreting\r\n            lambda's body in order to infer its return type.\r\n            ":"\r\n            当我们解释时，此符号用作lambdasymbol的返回类型\r\n            Lambda的身体是为了推断其返回类型。\r\n            \r\n",".\r\n            If the domain of ":"。\r\n            如果是\r\n","\r\n            Analyzes a method body if settings indicate we should.\r\n            ":"\r\n            如果设置表示我们应该，则分析方法主体。\r\n            \r\n","'/keepalive' option is only valid with '/shared' option.":"“/keepalive”选项仅使用“/共享”选项有效。\r\n","s available to generators in this driver.":"该驱动程序中的发电机可用于。\r\n","ReadOnlySpan":"ReadonlySpan\r\n","\r\n              Looks up a localized string similar to A foreach loop must declare its iteration variables..\r\n            ":"\r\n              查找类似于foreach循环的本地化字符串必须声明其迭代变量。\r\n            \r\n","Class which represents the syntax node for element binding expression.":"代表元素结合表达式语法节点的类。\r\n","\r\n              Looks up a localized string similar to '{0}': access modifiers are not allowed on static constructors.\r\n            ":"\r\n              查找类似于“ {0}'：静态构造函数的访问修饰符类似的本地化字符串。\r\n            \r\n","\r\n            Creates a trivia with kind PreprocessingMessageTrivia.\r\n            ":"\r\n            用善良的预处理制作琐事。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use local variable '{0}' before it is declared.\r\n            ":"\r\n              在声明之前，查找类似于局部变量'{0}'的本地化字符串。\r\n            \r\n","\r\n            Returns true when ":"\r\n            返回true\r\n","Creates a new XmlElementSyntax instance.":"创建一个新的Xmlelementsyntax实例。\r\n","Type parameter has the same type as the type parameter from outer method.":"类型参数具有与外部方法的类型参数相同的类型。\r\n","\r\n            True if the type is a delegate.\r\n            ":"\r\n            如果类型是代表，则为true。\r\n            \r\n","\r\n            Similar to SymbolExtensions.GetParameters, but returns empty for unsupported symbols\r\n            and handles delegates.\r\n            ":"\r\n            类似于symbolextensions.getParameters，但返回空白的符号\r\n            并处理代表。\r\n            \r\n","\r\n            When queries are translated into expressions select and group-by expressions such that\r\n            1) select/group-by expression is the same identifier as the \"source\" identifier and\r\n            2) at least one Where or OrderBy clause but no other clause is present in the contained query body or\r\n               the expression in question is a group-by expression and the body has no clause\r\n            \r\n            do not translate into lambdas.\r\n            By \"source\" identifier we mean the identifier specified in the from clause that initiates the query or the query continuation that includes the body.\r\n            \r\n            The above condition can be derived from the language specification (chapter 7.16.2) as follows:\r\n            - In order for 7.16.2.5 \"Select clauses\" to be applicable the following conditions must hold:\r\n              - There has to be at least one clause in the body, otherwise the query is reduced into a final form by 7.16.2.3 \"Degenerate query expressions\".\r\n              - Only where and order-by clauses may be present in the query body, otherwise a transformation in 7.16.2.4 \"From, let, where, join and orderby clauses\"\r\n                produces pattern that doesn't match the requirements of 7.16.2.5.\r\n              \r\n            - In order for 7.16.2.6 \"Groupby clauses\" to be applicable the following conditions must hold:\r\n              - Only where and order-by clauses may be present in the query body, otherwise a transformation in 7.16.2.4 \"From, let, where, join and orderby clauses\"\r\n                produces pattern that doesn't match the requirements of 7.16.2.5.\r\n            ":"\r\n            当查询被翻译成表达式时，选择和组逐个表达式\r\n            1）选择/group-by表达式与“源”标识符和标识符相同\r\n            2）至少一个或订购条款的位置，但在包含的查询主体中不存在其他条款或\r\n               所讨论的表达是一个小组表达式，身体没有子句\r\n            \r\n            不要转化为lambdas。\r\n            通过“源”标识符，我们的意思是从子句中指定的标识符，该标识符启动查询或包括身体的查询延续。\r\n            \r\n            上述条件可以从语言规范（第7.16.2章）中得出：如下：\r\n             - 为了适用7.16.2.5“选择条款”，必须保持以下条件：\r\n               - 身体中必须至少有一个子句，否则查询将减少为7.16.2.3“退化查询表达式”。\r\n               - 只有在查询体中出现的位置和订单条款，否则在7.16.2.4中进行转换，“从，LET，何处，加入和订购条款”\r\n                产生的模式与7.16.2.5的要求不符。\r\n              \r\n             - 为了适用7.16.2.6“ groupby Renauses”，必须保持以下条件：\r\n               - 只有在查询体中出现的位置和订单条款，否则在7.16.2.4中进行转换，“从，LET，何处，加入和订购条款”\r\n                产生的模式与7.16.2.5的要求不符。\r\n            \r\n","\r\n            Gets a value indicating whether this type has System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute or not.\r\n            ":"\r\n            获取一个指示此类型是否具有system.runtime.compilerservices.interpolatingstringhandleratlibute的值。\r\n            \r\n",")\r\n             ":"）\r\n             \r\n","\r\n            Entry point to the array initialization.\r\n            Assumes that we have newly created array on the stack.\r\n            \r\n            inits could be an array of values for a single dimensional array\r\n            or an array (of array)+ of values for a multidimensional case\r\n            \r\n            in either case it is expected that number of leaf values will match number \r\n            of elements in the array and nesting level should match the rank of the array.\r\n            ":"\r\n            阵列初始化的切入点。\r\n            假设我们在堆栈上有新创建的数组。\r\n            \r\n            INIT可能是单个维数组的值数组\r\n            或多维情况的值的数组（数组）+值\r\n            \r\n            无论哪种情况，都可以预期叶值的数量将匹配数字\r\n            数组和嵌套级别中的元素应与数组的等级相匹配。\r\n            \r\n","\r\n            If this binder owns the scope that can declare using aliases, a set of declared aliases should be returned (even if empty).\r\n            Otherwise, a default instance should be returned. \r\n            Note, only aliases syntactically declared within the enclosing declaration are included. For example, global aliases\r\n            declared in a different compilation units are not included.\r\n            ":"\r\n            如果此活页夹拥有可以使用别名声明的范围，则应返回一组声明的别名（即使为空）。\r\n            否则，应返回默认实例。\r\n            注意，仅包括在封闭声明中句法声明的别名。例如，全球别名\r\n            不包括在不同的汇编单元中声明。\r\n            \r\n","SyntaxToken representing the omitted type argument.":"Syntaxtoken表示省略的类型参数。\r\n","\r\n            instances based on underlying symbols, if any.\r\n            ":"\r\n            基于基本符号（如果有）的实例。\r\n            \r\n","Query expressions over source type 'dynamic' or with a join sequence of type 'dynamic' are not allowed":"不得\r\n","Called when the visitor visits a ParenthesizedPatternSyntax node.":"当访客访问括号源patternsyntax节点时，请致电。\r\n","\r\n            Get all modules in this compilation, including the source module, added modules, and all\r\n            modules of referenced assemblies that do not come from an assembly with an extern alias.\r\n            Metadata imported from aliased assemblies is not visible at the source level except through\r\n            the use of an extern alias directive. So exclude them from this list which is used to construct\r\n            the global namespace.\r\n            ":"\r\n            获取此编辑中的所有模块，包括源模块，添加的模块以及所有模块\r\n            参考组件的模块不是来自带有外部别名的组件。\r\n            从源级别上不可见从混叠组件中导入的元数据，除非通过\r\n            使用外部别名指令。因此，将它们从用于构建的列表中排除\r\n            全局名称空间。\r\n            \r\n","The old pending branches, which are to be merged with the current ones":"旧的未决分支，将与当前的分支合并\r\n","\r\n              Looks up a localized string similar to '{0}' cannot implement interface member '{1}' in type '{2}' because it has an __arglist parameter.\r\n            ":"\r\n              在类型'{2}'中查找类似于'{0}'类似于“ {0}”的本地化字符串，因为它具有__arglist参数。\r\n            \r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 1.  Please use language version {1} or greater..\r\n            ":"\r\n              查找类似于功能'{0}'的本地化字符串。\r\n            \r\n","\r\n            If this binder owns a scope for locals, return syntax node that is used\r\n            as the scope designator. Otherwise, null.\r\n            ":"\r\n            如果此活页夹拥有当地人的范围，请返回使用的语法节点\r\n            作为示波器指定器。否则，null。\r\n            \r\n","\r\n            Represents a simple compiler generated parameter of a given type.\r\n            ":"\r\n            表示给定类型的简单编译器生成的参数。\r\n            \r\n","Called when the visitor visits a NameEqualsSyntax node.":"当访问者访问nameequalssyntax节点时，请致电。\r\n","\r\n            Find the Deconstruct method for the expression on the right, that will fit the number of assignable variables on the left.\r\n            Returns an invocation expression if the Deconstruct method is found.\r\n                If so, it outputs placeholders that were coerced to the output types of the resolved Deconstruct method.\r\n            The overload resolution is similar to writing ":"\r\n            在右侧找到表达式的解构方法，该方法将适合左侧的可分配变量的数量。\r\n            如果找到解构方法，则返回调用表达式。\r\n                如果是这样，它将输出被胁迫的占位符，以解决已解决的解构方法的输出类型。\r\n            超负荷分辨率类似于写作\r\n","\r\n            Given a variable declarator syntax, get the corresponding symbol.\r\n            ":"\r\n            给定可变声明语法，获取相应的符号。\r\n            \r\n","\r\n            Emits receiver in a form that allows member accesses ( O or & ). \r\n            For verifier-reference types it is the actual reference. \r\n            For the value types it is an address of the receiver.\r\n            For generic types it is either a boxed receiver or the address of the receiver with readonly intent. \r\n            \r\n            addressKind - kind of address that is needed in case if receiver is not a reference type.\r\n            \r\n            May introduce a temp which it will return. (otherwise returns null)\r\n            ":"\r\n            以允许成员访问（O或＆）的形式发射接收器。\r\n            对于验证者引用类型，它是实际参考。\r\n            对于值类型，它是接收器的地址。\r\n            对于通用类型，它是盒装接收器，也可以是带有可读意图的接收器的地址。\r\n            \r\n            地址金 - 如果接收者不是参考类型，则需要的一种地址。\r\n            \r\n            可能会引入将返回的温度。 （否则返回null）\r\n            \r\n","\r\n            Create a new nested scope under the current scope, or reuse the current\r\n            scope if there's no change in the bound node for the nested scope.\r\n            Records the given locals as declared in the aforementioned scope.\r\n            ":"\r\n            在当前范围下创建一个新的嵌套范围，或重复使用电流\r\n            范围如果嵌套范围的绑定节点没有更改。\r\n            在上述范围中记录给定的当地人。\r\n            \r\n","\r\n            Containing namespace.\r\n            ":"\r\n            包含名称空间。\r\n            \r\n","\r\n            Expression is returned by reference.\r\n            ":"\r\n            表达式通过参考返回。\r\n            \r\n","\r\n            For each value in variableScope, identifies the closest owning method, lambda, or local function.\r\n            ":"对于variablesCope中的每个值，标识最接近的拥有方法，lambda或本地函数。\r\n            \r\n",") or property-like (see\r\n            ":"）或类似财产（请参阅\r\n            \r\n","\r\n            State machine interface method implementation.\r\n            ":"\r\n            状态计算机接口方法实现。\r\n            \r\n","There is no argument given that corresponds to the required formal parameter '{0}' of '{1}'":"没有参数对应于“ {1}'的所需形式参数'{0}'\r\n","\r\n              Looks up a localized string similar to You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking.\r\n            ":"\r\n              查找类似于您的本地化字符串必须指定汇编（而不是模块）上的CLSCompliant属性，以启用CLS合规性检查。\r\n            \r\n","\r\n              Looks up a localized string similar to An explicit interface implementation of an event must use event accessor syntax.\r\n            ":"\r\n              查找类似于事件的显式接口实现的本地化字符串必须使用事件访问语法。\r\n            \r\n","true if the character is a binary digit.":"如果字符是二进制数字，则为thu。\r\n","\r\n              Looks up a localized string similar to Invalid debug information format: {0}.\r\n            ":"\r\n              查找类似于无效调试信息格式的本地化字符串：{0}。\r\n            \r\n","\r\n            Gets the type of the parameter along with its annotations.\r\n            ":"\r\n            获取参数的类型及其注释。\r\n            \r\n","\r\n            The declaration diagnostics for a parameter depend on the containing symbol.\r\n            For instance, if the containing symbol is a method the declaration diagnostics\r\n            go on the compilation, but if it is a local function it is part of the local\r\n            function's declaration diagnostics.\r\n            ":"\r\n            参数的声明诊断取决于包含的符号。\r\n            例如，如果包含符号是一种方法，则声明诊断\r\n            进行编译，但是如果是本地功能，则是本地的一部分\r\n            功能的声明诊断。\r\n            \r\n","Indicates whether static member of this type are safe for multi-threaded operations.":"指示这种类型的静态成员是否对多线程操作安全。\r\n"," random values of type ":" 类型的随机值\r\n","\r\n            directly and provide an explicit format.\r\n            Sealed so that ":"\r\n            直接并提供明确的格式。\r\n            密封，这样\r\n","Within cref attributes, nested types of generic types should be qualified":"在CREF属性中，嵌套类型的通用类型应有资格\r\n","\r\n            To duplicate native compiler behavior for some scenarios we force a priority among\r\n            operators. If two operators are both applicable and both have a non-null Priority,\r\n            the one with the numerically lower Priority value is preferred.\r\n            ":"\r\n            为了复制某些情况的本地编译器行为，我们将优先考虑\r\n            操作员。如果两个运营商都适用并且都有非无效的优先级，则\r\n            优先级值较低的一个优选。\r\n            \r\n","\r\n            Returns whether this method is async and returns an IAsyncEnumerator`1.\r\n            ":"\r\n            返回该方法是否为异步并返回IASYNCENUMERATOR“ 1。\r\n            \r\n","\r\n            Return the location of the accessor, or if no accessor, the location of the event.\r\n            ":"\r\n            返回登录器的位置，或者如果没有登录器，则返回事件的位置。\r\n            \r\n","Members overridden or hidden by this accessor.":"成员被此登录器覆盖或隐藏。\r\n","Do not use 'System.Runtime.CompilerServices.DynamicAttribute'. Use the 'dynamic' keyword instead.":"请勿使用'system.runtime.compilerServices.dynamicattribute'。改用“动态”关键字。\r\n","\r\n              Looks up a localized string similar to Catch clauses cannot follow the general catch clause of a try statement.\r\n            ":"\r\n              查找类似于捕获子句的本地化字符串无法遵循try语句的一般捕获子句。\r\n            \r\n","\r\n            Determines whether this method is a candidate for a default assembly entry point \r\n            (i.e. it is a static method called \"Main\").\r\n            ":"\r\n            确定此方法是否是默认汇编入口点的候选者\r\n            （即，这是一种称为“主”的静态方法）。\r\n            \r\n","\r\n              Looks up a localized string similar to Resource identifier '{0}' has already been used in this assembly.\r\n            ":"\r\n              查找类似于资源标识符'{0}'的本地化字符串已在此组件中使用。\r\n            \r\n"," is true.\r\n               A subsequent call with ":" 是真的。\r\n               随后的电话\r\n","\r\n              Looks up a localized string similar to The tuple element name '{0}' is ignored because a different name or no name is specified by the target type '{1}'..\r\n            ":"查找类似于元组元素名称'{0}'的本地化字符串被忽略，因为目标类型'{1}'..指定了不同的名称或未指定名称。\r\n            \r\n",")\r\n            pair for each generated method.\r\n            \r\n            ":"）\r\n            对每个生成的方法对。\r\n            \r\n            \r\n","\r\n              Looks up a localized string similar to A property or indexer may not be passed as an out or ref parameter.\r\n            ":"\r\n              查找类似于属性或索引器的本地化字符串可能不会作为OUT或REF参数传递。\r\n            \r\n","\r\n            If this is an extension method, returns a reduced extension method\r\n            symbol representing the method. Otherwise, returns null.\r\n            ":"如果这是一种扩展方法，请返回减少的扩展方法\r\n            代表方法的符号。否则，返回null。\r\n            \r\n","The maximum warning level to allow. Diagnostics with a higher warning level will be filtered out.":"允许的最大警告级别。警告级别较高的诊断将被过滤掉。\r\n","\r\n            Returns -1 if None.\r\n            ":"\r\n            返回-1如果没有。\r\n            \r\n","\r\n            Merges nested nullability from an otherwise identical type.\r\n            ":"\r\n            合并与原本相同类型的嵌套无效性。\r\n            \r\n","\r\n            Returns an expression which converts the given expression into a string (or null).\r\n            If necessary, this invokes .ToString() on the expression, to avoid boxing value types.\r\n            ":"\r\n            返回将给定表达式转换为字符串（或null）的表达式。\r\n            如有必要，这将在表达式上调用.tostring（），以避免拳击值类型。\r\n            \r\n"," \r\n            Current compilation\r\n            ":" \r\n            当前汇编\r\n            \r\n","\r\n            Helper methods that exist to share code between properties and events.\r\n            ":"\r\n            在属性和事件之间共享代码的帮助方法。\r\n            \r\n","Member for which an implementation should be found.":"应找到实施的成员。\r\n","Class representing an identifier name followed by an equals token.":"代表标识符名称的类，后跟令牌。\r\n","Creates a new AttributeArgumentListSyntax instance.":"创建一个新的attributeargumentListsyntax实例。\r\n","\r\n            Generally ArgumentSyntax nodes do not declare symbols, except when used as arguments of a tuple literal.\r\n            Example:  var x = (Alice: 1, Bob: 2);\r\n                      ArgumentSyntax \"Alice: 1\" declares a tuple element field \"(int Alice, int Bob).Alice\"\r\n            ":"\r\n            通常，当用作元组文字的参数时，grimentsyntax节点不会声明符号。\r\n            示例：var x =（爱丽丝：1，鲍勃：2）;\r\n                      grumentsyntax“爱丽丝：1”声明了一个元组元素字段”（int alice，int bob）。\r\n            \r\n","\r\n            Import options of the compilation being built.\r\n            ":"构建汇编的导入选项。\r\n            \r\n","\r\n            The set of anonymous type templates created by\r\n            this AnonymousTypeManager, in fixed order.\r\n            ":"由\r\n            这个匿名者按固定顺序。\r\n            \r\n","\r\n            The behavior of the C# command-line compiler is as follows:\r\n              1) If the /out switch is specified, then the explicit assembly name is used.\r\n              2) Otherwise,\r\n                 a) if the assembly is executable, then the assembly name is derived from\r\n                    the name of the file containing the entrypoint;\r\n                 b) otherwise, the assembly name is derived from the name of the first input\r\n                    file.\r\n            \r\n            Since we don't know which method is the entrypoint until well after the\r\n            SourceAssemblySymbol is created, in case 2a, its name will not reflect the\r\n            name of the file containing the entrypoint.  We leave it to our caller to\r\n            provide that name explicitly.\r\n            ":"\r\n            C＃命令行编译器的行为如下：\r\n              1）如果指定 /OUT开关，则使用显式汇编名称。\r\n              2）否则，\r\n                 a）如果组件是可执行的，则从\r\n                    包含入口点的文件的名称；\r\n                 b）否则，汇编名称是从第一个输入的名称派生的\r\n                    文件。\r\n            \r\n            由于我们不知道哪种方法是入口点，直到\r\n            创建了Sourceassemblysymbol，如果情况2A，其名称不会反映\r\n            包含入口点的文件的名称。我们将其留给我们的呼叫者\r\n            明确提供该名称。\r\n            \r\n","If method is an extension method, this must be non-null.":"如果方法是一种扩展方法，则必须是非null。\r\n","\r\n            A `?` annotation on a type that isn't a value type causes:\r\n            - an error before C# 8.0\r\n            - a warning outside of a NonNullTypes context\r\n            ":"\r\n            ````````````''````''不是值类型的类型的注释：\r\n             -  C＃8.0之前的错误\r\n             - 在非杀人型上下文之外的警告\r\n            \r\n","\r\n            Return the longest prefix matching [whitespace]*[*][whitespace]*.\r\n            ":"\r\n            返回最长的前缀匹配[whitespace]*[*] [whitespace]*。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' cannot implement '{1}' because '{2}' is a Windows Runtime event and '{3}' is a regular .NET event..\r\n            ":"\r\n              查找类似于'{0}'无法实现'{1}'的本地化字符串，因为'{2}'是一个Windows运行时事件，'{3}'是常规的.NET事件。\r\n            \r\n"," is true for this tree prior to invoking this method.\r\n            ":" 在调用此方法之前，该树是正确的。\r\n            \r\n"," if it's not\r\n            overridden \r\n            ":" 如果不是\r\n            覆盖\r\n            \r\n","\r\n            Keeps a sliding buffer over the SourceText of a file for the lexer. Also\r\n            provides the lexer with the ability to keep track of a current \"lexeme\"\r\n            by leaving a marker and advancing ahead the offset. The lexer can then\r\n            decide to \"keep\" the lexeme by erasing the marker, or abandon the current\r\n            lexeme by moving the offset back to the marker.\r\n            ":"\r\n            将滑动缓冲区保留在lexer文件的源源上。还\r\n            为Lexer提供了跟踪当前“ Lexeme”的能力\r\n            通过留下标记并提前前进。 lexer可以\r\n            决定通过擦除标记或放弃电流来“保持”词汇\r\n            通过将偏移量移回标记来通过Lexeme。\r\n            \r\n","\r\n            Represents a compiler generated and embedded attribute type.\r\n            This type has the following properties:\r\n            1) It is non-generic, sealed, internal, non-static class.\r\n            2) It derives from System.Attribute\r\n            3) It has Microsoft.CodeAnalysis.EmbeddedAttribute\r\n            4) It has System.Runtime.CompilerServices.CompilerGeneratedAttribute\r\n            5) It has a parameter-less constructor\r\n            ":"\r\n            代表编译器生成和嵌入式属性类型。\r\n            此类型具有以下属性：\r\n            1）它是非生成的，密封的，内部的，非静态类的。\r\n            2）它源自system.tribute\r\n            3）它具有Microsoft.sodeanalysis.embeddedattribute\r\n            4）它具有system.runtime.compilerServices.com pilergeneratedAttribute\r\n            5）它具有无参数的构造函数\r\n            \r\n","\r\n            If the given expression is an indexer access, then this method will return the list of indexers\r\n            that could be invoked on the result, not the list of indexers that were considered.\r\n            ":"\r\n            如果给定的表达式是索引器访问权限，则此方法将返回索引列表\r\n            这可以在结果中调用，而不是被考虑的索引列表。\r\n            \r\n","\r\n            This does the same comparison that MethodSignature used to do.\r\n            ":"这样做的比较与用于执行的方法相同。\r\n            \r\n","The text of the declaration.":"声明的文字。\r\n","\r\n            Creates a remarks element within an xml documentation comment.\r\n            ":"\r\n            在XML文档注释中创建备注元素。\r\n            \r\n",",\r\n            where the ":"，，，，\r\n            在哪里\r\n","A previous catch clause already catches all exceptions":"以前的捕获子句已经捕获所有异常\r\n","\r\n            A helper method for ReferenceManager to set assembly identities for assemblies \r\n            referenced by this module and corresponding AssemblySymbols.\r\n            ":"引用meanager的辅助方法，以设置汇编的汇编身份\r\n            由该模块和相应的汇编符号引用。\r\n            \r\n"," will set the part ":" 将设置零件\r\n","\r\n              Looks up a localized string similar to Cannot yield in the body of a finally clause.\r\n            ":"\r\n              查找类似于最终子句的正文的局部字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to The Guid attribute must be specified with the ComImport attribute.\r\n            ":"\r\n              必须使用Comimport属性指定类似于GUID属性的本地化字符串。\r\n            \r\n","\r\n            The member symbol \r\n            ":"\r\n            成员符号\r\n            \r\n","\r\n            If the type implements one of a select few WinRT interfaces, the interface type is\r\n            projected to the CLR collection type (e.g., IVector to IList).\r\n            When importing a winmd type it may implement one or more winmd collection\r\n            interfaces. When the collection interfaces are projected, we may need\r\n            to add the projected members to the imported type so that calls to those\r\n            members succeed as normal. This method adds the interface methods to\r\n            the lookup, if necessary. The CLR understands that a call to the .NET interface\r\n            should be projected onto the WinRT interface method.\r\n            ":"\r\n            如果该类型实现了几个WINRT接口之一，则接口类型为\r\n            投影到CLR收集类型（例如，ivector to Ilist）。\r\n            导入WinMD类型时，它可能会实现一个或多个WinMD收集\r\n            接口。当收集界面投影时，我们可能需要\r\n            将投影成员添加到导入的类型中，以便打电话给那些\r\n            成员正常成功。此方法将接口方法添加到\r\n            如有必要，查找。 CLR了解对.NET接口的调用\r\n            应投影到WinRT接口方法上。\r\n            \r\n","'{0}' is not a valid format specifier":"'{0}'不是有效的格式指定符\r\n","\r\n            Indicates whether the method is effectively readonly,\r\n            by either the method or the containing type being marked readonly.\r\n            ":"\r\n            指示该方法是否有效阅读，\r\n            通过方法或包含的类型被标记为可读。\r\n            \r\n","\r\n            Creates the syntax representation of an xml newline token for xml documentation comments.\r\n            ":"\r\n            为XML文档注释创建XML Newline令牌的语法表示。\r\n            \r\n","\r\n            Holds the information for an element-wise comparison (like `a == b` as part of `(a, ...) == (b, ...)`)\r\n            ":"\r\n            保留元素比较的信息（例如`== b`作为`（a，...）==（b，...）`）的一部分。\r\n            \r\n","Type parameter '{1}' has the 'struct' constraint so '{1}' cannot be used as a constraint for '{0}'":"类型参数'{1}'具有'struct'约束so'{1}'不能用作'{0}'的约束\r\n","\r\n            Replace Task-like types with Task types.\r\n            ":"\r\n            用任务类型替换类似任务的类型。\r\n            \r\n","\r\n            All bits except those that are involved into describing various nullability aspects.\r\n            ":"\r\n            除了描述各种无效方面的内容外，所有位。\r\n            \r\n","Attribute argument syntax.":"属性参数语法。\r\n","\r\n            This enum describes the types of components that could give\r\n            us diagnostics.  We shouldn't read the list of diagnostics\r\n            until all of these types are accounted for.\r\n            ":"\r\n            这个枚举描述了可以给出的组件的类型\r\n            美国诊断。我们不应该阅读诊断列表\r\n            在考虑所有这些类型之前。\r\n            \r\n","\r\n            The target type of the conversion specified explicitly in source,\r\n            or null if not an explicit conversion.\r\n            ":"\r\n            在源中明确指定的转换的目标类型，\r\n            如果不是明确的转换，则为null。\r\n            \r\n","Called when the visitor visits a QueryBodySyntax node.":"当访问者访问QueryBodySyntax节点时，请致电。\r\n","\r\n            Return the identifier of an out declaration argument expression.\r\n            ":"\r\n            返回OUT声明参数表达式的标识符。\r\n            \r\n","\r\n              Looks up a localized string similar to <global namespace>.\r\n            ":"\r\n              查找类似于<全局名称空间>的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to The 'class' or 'struct' constraint must come before any other constraints.\r\n            ":"查找类似于“类”或“ struct”约束的本地化字符串必须在任何其他约束之前进行。\r\n            \r\n","\r\n              Looks up a localized string similar to Event is never used.\r\n            ":"\r\n              查找与事件类似的本地化字符串。\r\n            \r\n","'{0}': containing type does not implement interface '{1}'":"'{0}'：包含类型不实现接口'{1}'\r\n","\r\n              Looks up a localized string similar to Cannot assign to '{0}' because it is a '{1}'.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串，因为它是'{1}'。\r\n            \r\n","Using '{0}' as a ref or out value or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class":"使用'{0}'作为ref或out value或占用其地址可能会导致运行时例外\r\n","SyntaxToken representing the kind of the operator in the member access expression.":"Syntaxtoken表示成员访问表达式中运算符的种类。\r\n","\r\n              Looks up a localized string similar to Only assignment, call, increment, decrement, and new object expressions can be used as a statement.\r\n            ":"\r\n              查找与仅分配，呼叫，增量，减少和新对象表达式相似的本地化字符串可以用作语句。\r\n            \r\n","\r\n              Looks up a localized string similar to The type or namespace name '{0}' could not be found (are you missing a using directive or an assembly reference?).\r\n            ":"查找类似于类型或名称空间名称'{0}'的本地化字符串（您是否缺少使用指令或汇编引用？）。\r\n            \r\n","\r\n            If this binder owns the scope that can declare extern aliases, a set of declared aliases should be returned (even if empty).\r\n            Otherwise, a default instance should be returned. \r\n            ":"\r\n            如果此活页夹拥有可以声明外部别名的范围，则应返回一组声明的别名（即使是空的）。\r\n            否则，应返回默认实例。\r\n            \r\n","\r\n            Placeholders are bound expressions with type and state.\r\n            But for typeless expressions (such as `null` or `(null, null)` we hold onto the original bound expression,\r\n            as it will be useful for conversions from expression.\r\n            ":"\r\n            占位符是带有类型和状态的绑定表达式。\r\n            但是对于无键的表达式（例如null”或“（null，null）``我们都保持原始绑定表达式，\r\n            因为这对于来自表达的转换非常有用。\r\n            \r\n","\r\n            Given a syntax node that declares a property or member accessor, get the corresponding symbol.\r\n            ":"\r\n            给定一个声明属性或成员登录器的语法节点，获取相应的符号。\r\n            \r\n","\r\n              Looks up a localized string similar to Type does not implement the collection pattern; member is either static or not public.\r\n            ":"\r\n              查找类似于类型的本地化字符串不会实现集合模式。成员要么是静态的，要么不公开。\r\n            \r\n","Expected expression":"预期表达\r\n","SyntaxToken representing the new keyword.":"Syntaxtoken代表新关键字。\r\n","The token to normalize.":"令牌正常化。\r\n","\r\n            Return a node that is associated with open brace of the block. Ok to return null.\r\n            ":"\r\n            返回与块开放式支撑相关的节点。可以返回null。\r\n            \r\n"," from a string input, returning default if input was null.\r\n            ":" 从字符串输入中，如果输入为null，则返回默认值。\r\n            \r\n","\r\n            Represents a PE custom attribute\r\n            ":"\r\n            代表PE自定义属性\r\n            \r\n","Local function '{0}' must be 'static' in order to use the Conditional attribute":"本地函数'{0}'必须是'static'才能使用条件属性\r\n","Invalid type for parameter in XML comment cref attribute":"XML注释CREF属性中的参数类型无效类型\r\n","Deconstruction 'var (...)' form disallows a specific type for 'var'.":"解构“ var（...）”表单不允许“ var”的特定类型。\r\n","nullable types":"无效类型\r\n","Nullability of reference types in type of parameter doesn't match implicitly implemented member (possibly because of nullability attributes).":"参数类型中参考类型的无性性不匹配隐式实现的成员（可能是由于无效属性）。\r\n","Cannot return '{0}' by reference because it was initialized to a value that cannot be returned by reference":"无法通过引用返回'{0}'，因为它被初始化为无法通过参考返回的值\r\n","A sequence of syntax nodes.":"一系列语法节点。\r\n","\r\n              Looks up a localized string similar to /sourcelink switch is only supported when emitting PDB..\r\n            ":"\r\n              查找类似于 /Sourcelink开关的本地化字符串仅在发射PDB时才支持。\r\n            \r\n","\r\n              Looks up a localized string similar to Tuple element name '{0}' is only allowed at position {1}..\r\n            ":"\r\n              查找类似于元组元素名称'{0}'的本地化字符串仅在位置{1} ..\r\n            \r\n","\r\n            Creates a root declaration that contains a Script class declaration (possibly in a namespace) and namespace declarations.\r\n            Top-level declarations in script code are nested in Script class.\r\n            ":"创建一个root声明，其中包含脚本类声明（可能在名称空间中）和名称空间声明。\r\n            脚本代码中的顶级声明嵌套在脚本类中。\r\n            \r\n","\r\n              Looks up a localized string similar to A default literal 'default' is not valid as a case constant. Use another literal (e.g. '0' or 'null') as appropriate. If you intended to write the default label, use 'default:' without 'case'..\r\n            ":"\r\n              查找类似于默认字体“默认”的本地化字符串无效作为情况常数。适当地使用另一个文字（例如'0'或'null'）。如果您打算编写默认标签，请使用'默认值：“无案例”。\r\n            \r\n","The text of the end of line. Any text can be specified here, however only carriage return and\r\n            line feed characters are recognized by the parser as end of line.":"线的末尾。任何文本都可以在此处指定，但是只有运输返回和\r\n            线条饲料字符被解析器识别为线的结尾。\r\n","'{0}': cannot override because '{1}' does not have an overridable set accessor":"'{0}'：不能覆盖，因为'{1}'没有固定式访问者\r\n","\r\n              Looks up a localized string similar to Fully qualified name is too long for debug information.\r\n            ":"\r\n              查找类似于完全合格名称的本地化字符串对于调试信息太长。\r\n            \r\n","\r\n            Never returns null.\r\n            ":"\r\n            永远不会返回零。\r\n            \r\n","Will be used to report non-fatal errors during look up.":"在查找过程中将用于报告非致命错误。\r\n","\r\n            Return the translated node, or null if no code is necessary in the translation.\r\n            ":"\r\n            返回翻译的节点，如果在翻译中不需要代码，则返回null。\r\n            \r\n","Construct a Range object using the start and end indexes.":"使用开始索引和结束索引构建范围对象。\r\n","\r\n              Looks up a localized string similar to Nullability of reference types in type of parameter '{0}' of '{1}' doesn't match the target delegate '{2}'..\r\n            ":"\r\n              查找类似于参数类型的无效类型的本地化字符串，'{1}'的参数类型'{0}'与目标委托'{2}'..\r\n            \r\n","By-value returns may only be used in methods that return by value":"副价值返回只能用于按值返回的方法\r\n","Argument of type '{0}' is not applicable for the DefaultParameterValue attribute":"类型'{0}'的参数不适用于DefaultParameterValue属性\r\n","\r\n            Helper method to force type parameter constraints to be resolved.\r\n            ":"\r\n            强迫类型参数约束的帮助方法要解决。\r\n            \r\n","\r\n              Looks up a localized string similar to __arglist cannot have an argument passed by 'in' or 'out'.\r\n            ":"\r\n              查找类似于__arglist类似的本地化字符串，不能具有“或“ Out'”的参数。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' does not implement the '{1}' pattern. '{2}' has the wrong signature..\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串不会实现'{1}'模式。 '{2}'签名错误。\r\n            \r\n","\r\n            A TupleTypeSymbol represents a tuple type, such as (int, byte) or (int a, long b).\r\n            ":"\r\n            TupletypeSymbol代表元组类型，例如（int，byte）或（int a，long b）。\r\n            \r\n","\r\n              Looks up a localized string similar to Indexing an array with a negative index (array indices always start at zero).\r\n            ":"\r\n              查找类似于索引带有负索引的数组的本地化字符串（数组索引始终以零开始）。\r\n            \r\n","\r\n            A number that is distinct for each case and monotonically increasing from earlier to later cases.\r\n            Since we always keep the cases in order, this is only used to assist with debugging (e.g.\r\n            see DecisionDag.Dump()).\r\n            ":"\r\n            每个情况都不同的数字从较早的情况下单调增加。\r\n            由于我们始终将案件保留顺序，因此仅用于协助调试（例如\r\n            请参阅dekistiondag.dump（））。\r\n            \r\n","\r\n              Looks up a localized string similar to Field or property cannot be of type '{0}'.\r\n            ":"\r\n              查找类似于字段或属性的本地化字符串不能为'{0}'类型。\r\n            \r\n","\r\n            Return the name in string form, without trivia or generic arguments, for use in diagnostics.\r\n            ":"\r\n            以字符串形式返回名称，没有琐事或通用参数，以用于诊断。\r\n            \r\n","Compilation cancelled by user":"用户取消汇编\r\n","the lowered conditional branch into the case block":"降低的条件分支进入案例块\r\n","\r\n              Looks up a localized string similar to Cannot return '{0}' by reference because its receiver may not be returned by reference.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法通过引用返回'{0}'，因为它的接收器可能不会通过参考返回。\r\n            \r\n","Cannot return by reference a member of '{0}' because it was initialized to a value that cannot be returned by reference":"无法通过引用返回“ {0}”的成员，因为它是初始化为无法通过参考返回的值\r\n","Class which represents a simple pattern-maching expresion using the \"is\" keyword.":"代表使用“”关键字的简单模式结出的类。\r\n","Class which represents the syntax node for MakeRef expression.":"代表makeref表达的语法节点的类。\r\n","\r\n            This method ignores any [NullableContext]. For example, if there is a [NullableContext(1)]\r\n            at the containing type, and this type reference is oblivious, NeedsNullableAttribute()\r\n            will return false even though a [Nullable(0)] will be emitted for this type reference.\r\n            In practice, this shouldn't be an issue though since EnsuresNullableAttributeExists()\r\n            will have returned true for at least some of other type references that required\r\n            [Nullable(1)] and were subsequently aggregated to the [NullableContext(1)].\r\n            ":"\r\n            此方法忽略了任何[nulleableContext]。例如，如果有一个[nullableContext（1）]\r\n            在包含类型上，此类型参考是忽略的，需要NeullableAbeatTribute（）\r\n            即使将发出[nullable（0）]以供此类型参考，即使将返回false。\r\n            实际上，这不是一个问题，因为确保nullableAbeatTributeexists（）\r\n            至少需要一些其他类型的参考，将返回正确\r\n            [nullable（1）]，随后汇总到[nulleableContext（1）]。\r\n            \r\n","Cannot convert {0} to type '{1}' because it is not a delegate type":"不能将{0}转换为type' {1}'，因为它不是委托类型\r\n","Called when the visitor visits a PredefinedTypeSyntax node.":"当访问者访问预定型typesyntax节点时调用。\r\n","GetTuple() == (..., ...)":"getTuple（）==（...，...）\r\n","\r\n            Creates the syntax representation of a named empty xml element within xml documentation comments.\r\n            ":"\r\n            在XML文档注释中创建命名为空XML元素的语法表示。\r\n            \r\n","\r\n            Since this method is intended to be used for error reporting, it stops as soon as it finds\r\n            any type forwarder (or an error to report). It does not check other assemblies for consistency or better results.\r\n            ":"\r\n            由于此方法旨在用于错误报告，因此一旦找到它就会停止\r\n            任何类型的转发器（或报告错误）。它不会检查其他组件是否有一致性或更好的结果。\r\n            \r\n","\r\n            True if this is a partial method that doesn't have an implementation part.\r\n            ":"\r\n            如果这是没有实现零件的部分方法，则为true。\r\n            \r\n","\r\n              Looks up a localized string similar to Partial declarations of '{0}' must have the same type parameter names and variance modifiers in the same order.\r\n            ":"\r\n              查找类似于“ {0}”部分声明类似的本地化字符串，必须以相同的顺序具有相同的类型参数名称和方差修饰符。\r\n            \r\n","\r\n            Wrap the initializer in a BoundFixedLocalCollectionInitializer so that the rewriter will have the\r\n            information it needs (e.g. conversions, helper methods).\r\n            ":"\r\n            将初始化器包裹在boundfixedLocalCollectionInitializer中，以便重写器将\r\n            它需要的信息（例如，转换，辅助方法）。\r\n            \r\n","\r\n            Expression lvalue and rvalue requirements.\r\n            ":"\r\n            表达式和RVALUE要求。\r\n            \r\n","\r\n            Returns true if the type is defined in source and contains field initializers.\r\n            This method is only valid on a definition.\r\n            ":"\r\n            如果类型是在源中定义的，并且包含字段初始化器，则返回true。\r\n            此方法仅在定义上有效。\r\n            \r\n","\r\n            Is this an event of a tuple type?\r\n            ":"\r\n            这是元组类型的事件吗？\r\n            \r\n",").\r\n             Inside a `try` or `catch` with a `finally`, we'll use the label directly preceding the `finally`.\r\n             Inside a `try` or `catch` with an extracted `finally`, we will use the label preceding the extracted `finally`.\r\n             Inside a `finally`, we'll have no/null label (disposal continues without a jump).\r\n             ":"）。\r\n             在``try''或``最后''的“ try”或“ catch”内部，我们将直接在“最后”之前使用标签。\r\n             在提取的``最后''中``try''或“ catch”内部，我们将使用提取的``最终''之前的标签。\r\n             在“最后”内部，我们没有/零标签（在没有跳跃的情况下继续处置）。\r\n             \r\n","Nullability of reference types in type of parameter doesn't match implemented member.":"参数类型中参考类型的无效性不匹配实现的成员。\r\n","\r\n              Looks up a localized string similar to Cannot specify 'readonly' modifiers on both property or indexer '{0}' and its accessor. Remove one of them..\r\n            ":"\r\n              查找类似于属性或索引器'{0}'及其访问者的局部字符串。删除其中一个..\r\n            \r\n","True if we should produce an ambiguity warning per https://github.com/dotnet/roslyn/issues/45453 .":"是的，如果我们应该每https://github.com/dotnet/roslyn/issues/45453产生歧义性警告。\r\n","true if there was a non-exhaustive warning reported":"如果有不详尽的警告报告\r\n","\r\n            NOTE: If you are early decoding any new well-known attribute, make sure to update PostEarlyDecodeWellKnownAttributeTypes \r\n            to default initialize this data.\r\n            ":"\r\n            注意：如果您正在提早解码任何新的知名属性，请确保更新postlydecodewellnownnoateattributetypes\r\n            默认初始化此数据。\r\n            \r\n","\r\n            At this point, we have a list of viable symbols and no parameter list with which to perform\r\n            overload resolution.  We'll just return the first symbol, giving a diagnostic if there are\r\n            others.\r\n            Caveat: If there are multiple candidates and only one is from source, then the source symbol\r\n            wins and no diagnostic is reported.\r\n            ":"\r\n            此时，我们有一个可行符号的列表，没有参数列表\r\n            超负荷分辨率。我们只会返回第一个符号，如果有\r\n            其他。\r\n            警告：如果有多个候选人，只有一个来自源，则是源符号\r\n            胜利，没有诊断。\r\n            \r\n","The symbol that was declared.":"被宣布的符号。\r\n","There is no defined ordering between fields in multiple declarations of partial struct":"在部分结构的多个声明中，字段之间没有定义的排序\r\n","\r\n            A guarded decision tree, which simply binds a set of variables (this is used to assign to the\r\n            pattern variables of the switch case), optionally evaluates a Guard expression (which corresponds\r\n            to the `when` expression of a switch case), and the branches to a given label if the guard\r\n            is true (or there is no guard).\r\n            ":"\r\n            一个受保护的决策树，它只是绑定一组变量（这用于分配给\r\n            开关情况的模式变量），可选地评估护罩表达式（对应\r\n            到开关案例的`''表达式），如果警卫\r\n            是真的（或没有警卫）。\r\n            \r\n","\r\n            For source symbols, there can only be a valid clone method if this is a record, which is a\r\n            simple syntax check. This will need to change when we generalize cloning, but it's a good\r\n            heuristic for now.\r\n            ":"\r\n            对于源符号，只有在这是记录时才可以有效的克隆方法\r\n            简单的语法检查。当我们概括克隆时，这将需要改变，但这是一个很好的\r\n            现在启发式。\r\n            \r\n","\r\n            The underlying EventSymbol.\r\n            ":"\r\n            基础事件符号。\r\n            \r\n","Member modifier '{0}' must precede the member type and name":"成员修饰符'{0}'必须先于成员类型和名称\r\n","\r\n              Looks up a localized string similar to A single-element deconstruct pattern requires some other syntax for disambiguation. It is recommended to add a discard designator '_' after the close paren ')'..\r\n            ":"\r\n              查找类似于单元素解构模式类似的本地化字符串需要一些其他语法才能消除歧义。建议在关闭Paren之后添加丢弃的指定器“ _”）。\r\n            \r\n",",\r\n            or null if the version string specified in the ":"，，，，\r\n            或null如果在\r\n","\r\n            Get the symbol for a well-known member. The use of this method to get a well-known member\r\n            that does not exist will result in an exception of type ":"\r\n            获取一个著名成员的符号。使用这种方法来获得知名会员\r\n            这不存在将导致类型的例外\r\n","\r\n              Looks up a localized string similar to Invalid initializer member declarator.\r\n            ":"\r\n              查找类似于无效初始化器成员声明器的本地化字符串。\r\n            \r\n","\r\n            Is the following set of tokens, interpreted as a type, the type `var`?\r\n            ":"\r\n            是否将以下令牌解释为类型，类型为“ Var”？\r\n            \r\n","\r\n            Given a namespace declaration syntax node, get the corresponding namespace symbol for the declaration\r\n            assembly.\r\n            ":"\r\n            给定名称空间声明语法节点，获取声明的相应名称空间符号\r\n            部件。\r\n            \r\n","\r\n              Looks up a localized string similar to byref locals and returns.\r\n            ":"\r\n              查找类似于Byref当地人和返回的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' is a {1} but is used like a {2}.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串是{1}，但像{2}一样使用。\r\n            \r\n","Type of conditional expression cannot be determined because '{0}' and '{1}' implicitly convert to one another":"条件表达式的类型无法确定，因为'{0}'和'{1}'隐式转换彼此\r\n","\r\n              Looks up a localized string similar to An expression tree may not contain an assignment operator.\r\n            ":"\r\n              查找类似于表达树的本地化字符串可能不包含分配操作员。\r\n            \r\n","Referenced assembly '{0}' has different culture setting of '{1}'.":"引用的汇编'{0}'具有'{1}'的不同文化设置。\r\n","\r\n            Copy this tuple, but modify it to use the new element types.\r\n            ":"\r\n            复制此元组，但将其修改为使用新元素类型。\r\n            \r\n","'":"'\r\n","\r\n            Returns a synthesized debugger display attribute or null if one\r\n            could not be synthesized.\r\n            ":"\r\n            返回合成的调试器显示属性或null如果一个\r\n            无法合成。\r\n            \r\n","\r\n            Creates the syntax representation of a see element within xml documentation comments,\r\n            that points to the 'null' language keyword.\r\n            ":"\r\n            创建XML文档注释中的See元素的语法表示，\r\n            这指向“ null”语言关键字。\r\n            \r\n","The type of the list elements in the separated list.":"列表中的列表元素的类型。\r\n","\r\n              Looks up a localized string similar to The switch statement contains multiple cases with the label value '{0}'.\r\n            ":"\r\n              查找类似于Switch语句的本地化字符串包含带有标签值'{0}'的多个情况。\r\n            \r\n","\r\n            As defined in 10.1.5 of the specification.\r\n            ":"\r\n            如规范的10.1.5所定义。\r\n            \r\n","\r\n            A type parameter for a method that either overrides a base\r\n            type method or explicitly implements an interface method.\r\n            ":"\r\n            覆盖碱基的方法的类型参数\r\n            键入方法或明确实现接口方法。\r\n            \r\n","\r\n            Returns true if this symbol was declared to override a base class member; i.e., declared\r\n            with the ":"\r\n            如果该符号被宣布覆盖基类成员，则返回为True；即，宣布\r\n            与\r\n","\r\n            Gets the name of this symbol. Symbols without a name return the empty string; null is\r\n            never returned.\r\n            ":"\r\n            获取此符号的名称。没有名称的符号返回空字符串；空是\r\n            从未回来。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot assign '{0}' to anonymous type property.\r\n            ":"\r\n              查找类似于匿名类型属性的本地化字符串无法分配“ {0}”。\r\n            \r\n",") expected":"） 预期的\r\n","\r\n              Looks up a localized string similar to Invalid extern alias for '/reference'; '{0}' is not a valid identifier.\r\n            ":"\r\n              查找类似于“/参考”的无效外部别名类似的局部字符串； '{0}'不是有效的标识符。\r\n            \r\n","\r\n            Print Commandline help message (up to 80 English characters per line)\r\n            ":"\r\n            打印命令行帮助消息（每行最多80个英语字符）\r\n            \r\n","\r\n            Structure containing all semantic information about an await expression.\r\n            ":"\r\n            结构包含有关等待表达的所有语义信息。\r\n            \r\n","\r\n            The input expression to this branch of the decision tree.\r\n            ":"\r\n            决策树该分支的输入表达式。\r\n            \r\n","\r\n            Checks if the given type implements (or extends, in the case of an interface),\r\n            System.Collections.IEnumerable or System.Collections.Generic.IEnumerable<T>,\r\n            for at least one T.\r\n            ":"\r\n            检查给定类型是否实施（或扩展，在接口的情况下），\r\n            system.collections.ienumerable或system.collections.generic.ienumerable <t>，\r\n            至少一个T。\r\n            \r\n","\r\n            True if generic method constraints should be checked at the call-site.\r\n            ":"\r\n            正确，如果应在呼叫站点检查通用方法约束。\r\n            \r\n","\r\n            A collection of type parameter constraint kinds, populated when\r\n            constraint kinds for the first type parameter is requested.\r\n            Initialized in two steps. Hold a copy if accessing during initialization.\r\n            ":"\r\n            类型参数约束类型的集合，当\r\n            请求第一个类型参数的约束种类。\r\n            以两个步骤初始化。如果在初始化期间访问，请持有副本。\r\n            \r\n","Called when the visitor visits a MemberAccessExpressionSyntax node.":"当访问者访问成员cessexpressyntax节点时调用。\r\n","\r\n            Get the query range variable declared in a join into clause.\r\n            ":"\r\n            获取在JOIN中声明的查询范围变量中的子句。\r\n            \r\n","\r\n              Looks up a localized string similar to Neither 'is' nor 'as' is valid on pointer types.\r\n            ":"\r\n              查找类似于“也不是”的本地化字符串在指针类型上都是有效的。\r\n            \r\n","\r\n            Returns true if the type is a non-generic type named \"System.Linq.Expressions.Expression\"\r\n            or \"System.Linq.Expressions.LambdaExpression\".\r\n            ":"\r\n            如果该类型是名为“ System.linq.expressions.expression”的非传播类型，则返回true。\r\n            或“ system.linq.expressions.lambdaexpression”。\r\n            \r\n","\r\n              Looks up a localized string similar to Return type is not CLS-compliant.\r\n            ":"\r\n              查找类似于返回类型的本地化字符串不符合CLS。\r\n            \r\n"," objects are equal and true otherwise.\r\n            ":" 对象是平等的，否则是真实的。\r\n            \r\n","\r\n            Displays the version number in the format expected on the command-line (/langver flag).\r\n            For instance, \"6\", \"7\", \"7.1\", \"latest\".\r\n            ":"\r\n            在命令行（/langver标志）上以预期的格式显示版本号。\r\n            例如，“ 6”，“ 7”，“ 7.1”，“最新”。\r\n            \r\n","The result of the expression is always 'null' of type '{0}'":"表达的结果始终是类型'{0}'的'null'\r\n","\r\n            for reanalyzing a lambda.\r\n            ":"\r\n            重新分析lambda。\r\n            \r\n","Gets the optional \"readonly\" keyword.":"获取可选的“ ReadOnly”关键字。\r\n","(..., (a, b)) == (..., ...)":"（...，（a，b））==（...，...）\r\n","\r\n              Looks up a localized string similar to '{0}': cannot change tuple element names when overriding inherited member '{1}'.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串：当覆盖的构件'{1}''覆盖时，无法更改元组元素名称。\r\n            \r\n","\r\n              Looks up a localized string similar to The assembly name '{0}' is reserved and cannot be used as a reference in an interactive session.\r\n            ":"\r\n              查找类似于汇编名称'{0}'的本地化字符串已保留，不能在交互式会话中用作参考。\r\n            \r\n","A list of xml node syntax that will be the content within the summary element.":"XML节点语法的列表将是摘要元素中的内容。\r\n","&&":"&&\r\n","\r\n            Either a SubstitutedNestedTypeSymbol or a ConstructedNamedTypeSymbol, which share in common that they\r\n            have type parameters substituted.\r\n            ":"\r\n            取代的甲板符号或构造的typesymbol，它们共有共同\r\n            具有替换的类型参数。\r\n            \r\n"," for example\r\n             - nested expressions that aren't tuple literals, like ":" 例如\r\n              - 不是元组文字的嵌套表情，\r\n","\r\n            Determines if the source type is convertible to the destination type via\r\n            any standard implicit or standard explicit conversion.\r\n            ":"\r\n            确定源类型是否可通过\r\n            任何标准的隐式或标准显式转换。\r\n            \r\n","Program does not contain a static 'Main' method suitable for an entry point":"程序不包含适合入口点的静态“主”方法\r\n","\r\n              Looks up a localized string similar to A static member '{0}' cannot be marked as override, virtual, or abstract.\r\n            ":"\r\n              查找类似于静态成员'{0}'的本地化字符串，不能标记为覆盖，虚拟或抽象。\r\n            \r\n","\r\n            Gets corresponding primitive type code for this type declaration.\r\n            ":"\r\n            获取此类型声明的相应原始类型代码。\r\n            \r\n","\r\n            Given a node that represents a lambda body returns a node that represents the lambda.\r\n            ":"\r\n            给定代表lambda身体的节点返回代表lambda的节点。\r\n            \r\n","\r\n              Looks up a localized string similar to The non-generic {1} '{0}' cannot be used with type arguments.\r\n            ":"\r\n              查找类似于非生成{1}'{0}'的本地化字符串，不能与类型参数一起使用。\r\n            \r\n","\r\n              Looks up a localized string similar to Possible null reference argument for parameter '{0}' in '{1}'..\r\n            ":"\r\n              查找类似于参数'{0}'in'{1}'的参数'{0}'的可能的null引用参数类似的本地化字符串。\r\n            \r\n"," This list consists of synthesized method symbols for ToString, \r\n            Equals and GetHashCode which are not part of symbol table ":" 此列表包括用于ToString的合成方法符号，\r\n            不是符号表的一部分\r\n","\r\n            SymbolExtensions for member symbols.\r\n            ":"\r\n            成员符号的Symbolextensions。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': ref structs cannot implement interfaces.\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串：ref structs无法实现接口。\r\n            \r\n","\r\n              Looks up a localized string similar to Expression or declaration statement expected..\r\n            ":"\r\n              查找类似于表达式或声明语句的本地化字符串。\r\n            \r\n"," instead).\r\n            For example, currently used when type constraints are bound in some scenarios.\r\n            ":" 反而）。\r\n            例如，当前在某些情况下绑定类型约束时使用。\r\n            \r\n","The map from type parameters to type arguments.":"从类型参数到类型参数的地图。\r\n","\r\n              Looks up a localized string similar to type.\r\n            ":"\r\n              查找类似于类型的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' duplicate TypeForwardedToAttribute.\r\n            ":"\r\n              查找类似于'{0}'重复typeforwarddoattribute的本地化字符串。\r\n            \r\n",".\r\n            Returns the type that it actually locks onto (it's possible that it had already locked onto ErrorType).\r\n            ":"。\r\n            返回其实际锁定到的类型（可能已经锁定在错误类型上）。\r\n            \r\n","\r\n            Like BindForEachParts, but only bind the deconstruction part of the foreach, for purpose of inferring the types of the declared locals.\r\n            ":"\r\n            像bindforeachParts一样，但仅结合福特的解构部分，目的是推断已声明的当地人的类型。\r\n            \r\n","Called when the visitor visits a XmlPrefixSyntax node.":"当访问者访问XMLPReFixSyntax节点时，请致电。\r\n","\r\n            Find canonical type for NoPia embedded type.\r\n            ":"\r\n            查找NOPIA嵌入式类型的规范类型。\r\n            \r\n","\r\n            Even for metadata symbols, ":"\r\n            即使对于元数据符号，\r\n","\r\n            Search the declared members of a type for one that could be an implementation\r\n            of a given interface member (depending on interface declarations).\r\n            ":"\r\n            搜索可能是实施的类型的声明成员\r\n            给定的接口成员（取决于接口声明）。\r\n            \r\n"," symbol is missing,\r\n            or any of the members in ":" 符号缺失，\r\n            或任何成员\r\n","\r\n              Looks up a localized string similar to A class with the ComImport attribute cannot have a user-defined constructor.\r\n            ":"\r\n              查找与Comimport属性类似的本地化字符串，不能具有用户定义的构造函数。\r\n            \r\n","The bound node to be rewritten":"绑定的节点要重写\r\n","\r\n              Looks up a localized string similar to Invalid name for a preprocessing symbol; '{0}' is not a valid identifier.\r\n            ":"\r\n              在预处理符号中查找类似于无效名称的本地化字符串； '{0}'不是有效的标识符。\r\n            \r\n","Parameter must have a non-null value when exiting.":"退出时，参数必须具有非null值。\r\n","\r\n            A diagnostic bag to receive warnings if we should allow multiple definitions and pick one.\r\n            ":"\r\n            如果我们允许多个定义并选择一个诊断袋，以接收警告。\r\n            \r\n","\r\n            We know that we'll never have a method context because that's what we're\r\n            trying to find.  Instead, just return an indexed type parameter that will\r\n            make comparison easier.\r\n            ":"我们知道我们永远不会有方法上下文，因为这就是我们\r\n            试图找到。相反，只需返回索引类型参数\r\n            使比较更容易。\r\n            \r\n","\r\n            Creates a speculative SemanticModel for an initializer node (field initializer, constructor initializer, or parameter default value)\r\n            that did not appear in the original source code.\r\n            ":"\r\n            为初始化器节点（字段初始化器，构造函数初始化程序或参数默认值）创建一个投机词素模型）\r\n            那没有出现在原始源代码中。\r\n            \r\n","Cannot derive from '{0}' because it is a type parameter":"不能源自'{0}'，因为它是类型参数\r\n","Creates a new EnumMemberDeclarationSyntax instance.":"创建一个新的enummemberdeclarationsyntax实例。\r\n","\r\n              Looks up a localized string similar to No suitable Deconstruct instance or extension method was found for type '{0}', with {1} out parameters and a void return type..\r\n            ":"\r\n              查找一个类似于类型的“ {0}”的局部字符串，类似于未找到合适的解构实例或扩展方法，其中{1} out参数和void return类型。\r\n            \r\n","\r\n              Looks up a localized string similar to anonymous types.\r\n            ":"\r\n              查找类似于匿名类型的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Error opening icon file {0} -- {1}.\r\n            ":"\r\n              查找类似于错误打开图标文件{0}  -  {1}的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Duplicate type parameter '{0}'.\r\n            ":"\r\n              查找类似于重复类型参数'{0}'的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to The type of one of the expressions in the {0} clause is incorrect.  Type inference failed in the call to '{1}'..\r\n            ":"\r\n              查找类似于{0}子句中表达式之一的类型的本地化字符串是不正确的。类型推理在调用'{1}'..的呼叫中失败。\r\n            \r\n","\r\n            Returns false because module can't be defined externally.\r\n            ":"\r\n            返回false，因为无法外部定义模块。\r\n            \r\n","\r\n            with the current state.\r\n            ":"\r\n            具有当前状态。\r\n            \r\n","\r\n            Filters extension attributes from the attribute results.\r\n            ":"\r\n            过滤器扩展属性来自属性结果。\r\n            \r\n","\r\n            The lookup failed to find anything\r\n            ":"\r\n            查找未能找到任何东西\r\n            \r\n","\r\n              Looks up a localized string similar to 'id#' syntax is no longer supported. Use '$id' instead..\r\n            ":"\r\n              不再支持查找类似于“ ID＃”语法的本地化字符串。改用“ $ id”。\r\n            \r\n","\r\n            Creates a token with kind XmlTextLiteralToken.\r\n            ":"\r\n            用善良的xmlTextLiteralToken创建一个令牌。\r\n            \r\n","\r\n              Looks up a localized string similar to The call to method '{0}' needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access..\r\n            ":"\r\n              查找类似于调用方法'{0}'的局部字符串，需要动态调度，但不能是因为它是基本访问表达式的一部分。考虑施放动态参数或消除基本访问。\r\n            \r\n","Assemblies '{0}' and '{1}' refer to the same metadata but only one is a linked reference (specified using /link option); consider removing one of the references.":"汇编'{0}'和'{1}'请参阅同一元数据，但只有一个是链接引用（使用 /链接选项指定）;考虑删除其中一个参考文献。\r\n","\r\n              Looks up a localized string similar to {0}. See also error CS{1}..\r\n            ":"\r\n              查找类似于{0}的局部字符串。另请参见错误CS {1} ..\r\n            \r\n","Anonymous type field type":"匿名类型字段类型\r\n","Assuming assembly reference matches identity":"假设组装参考与身份匹配\r\n","The raw text of the identifier name, including any escapes or leading '@'\r\n            character as it is in source.":"标识符名称的原始文本，包括任何逃逸或领先的“@”\r\n            字符像源一样。\r\n","\r\n            Initializes namespaces and types maps with information about \r\n            namespaces and types immediately contained within this namespace.\r\n            ":"\r\n            初始化名称空间和类型地图，并提供有关信息的信息\r\n            该名称空间中立即包含的名称空间和类型。\r\n            \r\n",". Reachability and definite assignment are monotonic, and\r\n            permit a more efficient analysis. Region analysis and nullable analysis are not\r\n            monotonic. This is just an optimization; we could treat all of them as nonmonotonic\r\n            without much loss of performance. In fact, this only affects the analysis of (relatively\r\n            rare) try statements, and is only a slight optimization.\r\n            ":"。达到性和确定的作业是单调的，并且\r\n            允许进行更有效的分析。区域分析和无效分析不是\r\n            单调。这只是一个优化；我们可以将所有这些都视为非单调\r\n            没有太多的表现。实际上，这只会影响分析（相对\r\n            罕见）尝试语句，只是一个轻微的优化。\r\n            \r\n","\r\n            This is for debugger display use only: ":"\r\n            这是用于调试器显示仅使用：\r\n","True if the constraints were satisfied, false otherwise.":"如果满足约束，则为错误，否则为错误。\r\n","\r\n            An internal helper class for building a switch statement.\r\n            ":"\r\n            用于构建开关语句的内部帮手类。\r\n            \r\n","Class which represents an expression that has a binary operator.":"代表具有二进制运算符的表达式。\r\n","The 'async' modifier can only be used in methods that have a body.":"“异步”修饰符只能用于具有身体的方法中。\r\n","Cannot return '{0}' by reference because it is a '{1}'":"无法通过引用返回'{0}'，因为它是'{1}'\r\n","\r\n            A synthesized local variable.\r\n            ":"\r\n            合成的局部变量。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' cannot be both extern and abstract.\r\n            ":"\r\n              查找类似于“ {0}”的局部字符串不能既是外部和抽象。\r\n            \r\n","\r\n            Represents a field in a class, struct or enum\r\n            ":"\r\n            代表类，结构或枚举中的字段\r\n            \r\n","alternative interpolated verbatim strings":"替代插入的逐字串\r\n","\r\n            \"State when not null\" can only propagate out of a conditional access if\r\n            it is not subject to a user-defined conversion whose parameter is not of a non-nullable value type.\r\n            ":"\r\n            如果“状态何时为null”，则只能在条件访问中传播\r\n            它不受用户定义的转换的约束，该转换的参数不是不可删除的值类型。\r\n            \r\n","\r\n            Given a type declaration, get the corresponding type symbol.\r\n            ":"\r\n            给定类型声明，获取相应的类型符号。\r\n            \r\n","Base type for method declaration syntax.":"方法声明语法的基本类型。\r\n","The hintName '{0}' contains an invalid character '{1}' at position {2}.":"hintname'{0}'在位置{2}中包含一个无效的字符'{1}'。\r\n","\r\n              Looks up a localized string similar to Identifier '{0}' differing only in case is not CLS-compliant.\r\n            ":"\r\n              查找类似于标识符'{0}'的本地化字符串，仅在情况下不符合CLS。\r\n            \r\n","void M((int x, int y))":"void m（（int x，int y））\r\n","\r\n            Returns whether the specified ":"\r\n            返回是否指定\r\n","\r\n              Looks up a localized string similar to Conversion of a stackalloc expression of type '{0}' to type '{1}' is not possible..\r\n            ":"\r\n              查找类似于类型的stackalloc表达式“ {0}”的局部字符串，类型为'{1}'。\r\n            \r\n","\r\n              Looks up a localized string similar to __arglist cannot have an argument of void type.\r\n            ":"\r\n              查找类似于__arglist类似的本地化字符串不能具有void类型的参数。\r\n            \r\n","Error reading Win32 manifest file '{0}' -- '{1}'":"错误读取win32清单文件'{0}' - '{1}'\r\n","\r\n              Looks up a localized string similar to Option '{0}' overrides attribute '{1}' given in a source file or added module.\r\n            ":"\r\n              在源文件或添加的模块中查找类似于选项'{0}'覆盖属性'{1}'的本地化字符串。\r\n            \r\n","\r\n            Method to early decode the type of well-known attribute which can be queried during the BindAttributeType phase.\r\n            This method is called first during attribute binding so that any attributes that affect semantics of type binding\r\n            can be decoded here.\r\n            ":"\r\n            早期解码可以在BindattributeType阶段查询的众所周知属性的类型。\r\n            该方法在属性绑定过程中首先称为，因此任何影响类型绑定语义的属性\r\n            可以在这里解码。\r\n            \r\n","\r\n              Looks up a localized string similar to You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly.\r\n            ":"\r\n              查找类似于您的本地化字符串，无法在模块上指定与汇编上CLSCompliant属性不同的模块上的ClScompliant属性。\r\n            \r\n","Iterators cannot have unsafe parameters or yield types":"迭代器不能具有不安全的参数或产量类型\r\n","Error signing output with public key from file '{0}' -- {1}":"通过文件'{0}'' -  {1}使用公共密钥签名输出的错误签名输出\r\n","Syntax representation of the reference to the exception type.":"对异常类型的引用的语法表示。\r\n","\r\n              Looks up a localized string similar to declaration expression.\r\n            ":"\r\n              查找类似于声明表达式的局部字符串。\r\n            \r\n","tuple equality":"元组平等\r\n","\r\n              Looks up a localized string similar to '{0}': a class with the ComImport attribute cannot specify a base class.\r\n            ":"查找类似于'{0}'的本地化字符串：带有Comimport属性的类无法指定基类。\r\n            \r\n","\r\n            Check for a GetEnumerator (or GetAsyncEnumerator) method on collectionExprType.  Failing to satisfy the pattern is not an error -\r\n            it just means that we have to check for an interface instead.\r\n            ":"\r\n            在CollectionExprType上检查getEnumerer（或getAsyncenumerator）方法。无法满足模式不是错误 - \r\n            这只是意味着我们必须检查接口。\r\n            \r\n","\r\n            Manages anonymous types created in owning compilation. All requests for \r\n            anonymous type symbols go via the instance of this class.\r\n            ":"\r\n            管理在拥有汇编中创建的匿名类型。所有请求\r\n            匿名类型符号通过此类的实例进行。\r\n            \r\n","\r\n              Looks up a localized string similar to The evaluation of the constant value for '{0}' involves a circular definition.\r\n            ":"\r\n              查找类似于“ {0}”常数评估的局部字符串涉及一个圆形定义。\r\n            \r\n","\r\n              Looks up a localized string similar to Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement.\r\n            ":"\r\n              查找类似于分配，呼叫，增量，减少，等待的本地化字符串，并且可以将新对象表达式用作语句。\r\n            \r\n"," is default, remove all async keywords, if any.\r\n            Otherwise, replace the existing ":" 为默认值，请删除所有异步关键字（如果有）。\r\n            否则，替换现有的\r\n","\r\n              Looks up a localized string similar to Invalid option '{0}' for /debug; must be 'portable', 'embedded', 'full' or 'pdbonly'.\r\n            ":"\r\n              查找类似于无效选项'{0}'的本地化字符串for /debug;必须是“便携式”，“嵌入”，“完整”或“ pdbonly”。\r\n            \r\n","\r\n              Looks up a localized string similar to Inconsistent accessibility: parameter type '{1}' is less accessible than indexer '{0}'.\r\n            ":"\r\n              查找类似于不一致的可访问性的本地化字符串：参数类型'{1}''不如indexer'{0}'访问。\r\n            \r\n","\r\n            The three different kinds of nodes in the decision tree.\r\n            ":"\r\n            决策树中的三种不同类型的节点。\r\n            \r\n","Called when the visitor visits a PointerTypeSyntax node.":"当访问者访问PointerTypesyntax节点时，请致电。\r\n","\r\n            Synthesized parameterless constructors in structs chain to the \"default\" constructor\r\n            ":"\r\n            结构链中的无参数构造函数的合成无参数构造函数到“默认”构造函数\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' is a {1}, which is not valid in the given context.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串是{1}，在给定上下文中无效。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have the matching return type of '{3}'..\r\n            ":"\r\n              查找类似于“ {0}'的本地化字符串”不实现接口成员'{1}'。 '{2}'无法实现'{1}'，因为它没有'{3}'..的匹配返回类型\r\n            \r\n","\r\n              Looks up a localized string similar to Expected 'enable', 'disable', or 'restore'.\r\n            ":"\r\n              查找类似于预期的“启用”，“禁用”或“还原”的本地化字符串。\r\n            \r\n","Cannot restore warning because it was disabled globally":"无法恢复警告，因为它在全球范围内被禁用\r\n","\r\n            Returns data decoded from ":"\r\n            返回数据解码的数据\r\n","Optional method name":"可选方法名称\r\n","\r\n              Looks up a localized string similar to Variable is assigned but its value is never used.\r\n            ":"\r\n              查找与变量类似的本地化字符串，但从未使用其值。\r\n            \r\n",". FileLinePositionSpans are used\r\n            primarily for diagnostics and source locations.\r\n            ":"。使用filelinePositionspans\r\n            主要用于诊断和源位置。\r\n            \r\n","Creates a new LocalFunctionStatementSyntax instance.":"创建一个新的localFunctionStattatementsyntax实例。\r\n","<?":"<？\r\n","\r\n            Creates the syntax representation of an example element within xml documentation comments.\r\n            ":"\r\n            在XML文档注释中创建示例元素的语法表示。\r\n            \r\n","A list of trivia immediately following the token.":"令牌之后的琐事列表。\r\n","\r\n              Looks up a localized string similar to The body of an async-iterator method must contain a 'yield' statement. Consider removing 'async' from the method declaration or adding a 'yield' statement..\r\n            ":"\r\n              查找类似于异步 - 列表方法的主体的局部字符串必须包含“收益率”语句。考虑从方法声明中删除“异步”或添加“产量”陈述。\r\n            \r\n","\r\n            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };\r\n            int[] subArray1 = someArray[0..2]; // { 1, 2 }\r\n            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }\r\n            ":"\r\n            int [] someArray = new int [5] {1，2，3，4，5};\r\n            int [] subaray1 = someArray [0..2]; // {1，2}\r\n            int [] subarray2 = someArray [1 ..^0]; // {2，3，4，5}\r\n            \r\n","The list of nodes and tokens.":"节点和令牌列表。\r\n","Members of property '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type":"属性'{0}'类型'{1}'的成员无法用对象初始化器分配，因为它是值类型\r\n","True if the binder will be used to bind a using directive.":"如果将粘合剂用于使用指令绑定A，则为正确。\r\n","Cannot update '{0}'; attribute '{1}' is missing.":"无法更新'{0}';属性'{1}'丢失。\r\n","default literal":"默认文字\r\n","\r\n            Gets the available named symbols in the context of the specified location and optional\r\n            container. Only symbols that are accessible and visible from the given location are\r\n            returned.\r\n            ":"\r\n            在指定位置和可选的上下文中获取可用的命名符号\r\n            容器。只有从给定位置可访问和可见的符号是\r\n            回来。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid name for a preprocessing symbol; not a valid identifier.\r\n            ":"\r\n              在预处理符号中查找类似于无效名称的本地化字符串；不是有效的标识符。\r\n            \r\n","Indicating if the index is from the start or from the end.":"指示该索引是从开始还是从末端开始。\r\n","\r\n              Looks up a localized string similar to disposable.\r\n            ":"\r\n              查找类似于一次性的局部字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Reference to type '{0}' claims it is defined in '{1}', but it could not be found.\r\n            ":"\r\n              查找类似于“ {0}”主张的引用的本地化字符串，它是在'{1}'中定义的，但找不到。\r\n            \r\n","\r\n              Looks up a localized string similar to Parameter not valid for the specified unmanaged type..\r\n            ":"\r\n              查找类似于参数类似的本地化字符串，对于指定的非托管类型。\r\n            \r\n","The caller's buffer into which we produce additional methods to be emitted by the caller":"呼叫者的缓冲区我们会产生其他方法，以供呼叫者发出\r\n","\r\n            NOTE: we are specifically diverging from dev11 to improve the user experience.\r\n            Since treating the \"async\" keyword as an identifier in older language\r\n            versions can never result in a correct program, we instead accept it as a\r\n            keyword regardless of the language version and produce an error if the version\r\n            is insufficient.\r\n            ":"注意：我们专门从DEV11分歧以改善用户体验。\r\n            由于将“异步”关键字视为旧语言的标识符\r\n            版本永远无法导致正确的程序，我们将其接受为\r\n            关键字不管语言版本如何，如果版本，请产生错误\r\n            不足。\r\n            \r\n","Next binder in the chain (enclosing).":"链中的下一个粘合剂（封闭）。\r\n","Possible null reference argument for parameter '{0}' in '{1}'.":"参数'{​​0}'in'{1}'的可能的null引用参数。\r\n","\r\n            Walk up the scope tree looking for a nested function.\r\n            ":"\r\n            走上瞄准镜树寻找嵌套功能。\r\n            \r\n",", also stores the ":"，也存储\r\n","SyntaxToken representing the base keyword.":"Syntaxtoken表示基本关键字。\r\n","\r\n              Looks up a localized string similar to Supported language versions:.\r\n            ":"\r\n              查找类似于受支持的语言版本的本地化字符串：。\r\n            \r\n","\r\n              Looks up a localized string similar to Missing XML comment for publicly visible type or member '{0}'.\r\n            ":"\r\n              查找类似于缺少XML评论的本地化字符串，用于公开可见类型或成员'{0}'。\r\n            \r\n","\r\n              Looks up a localized string similar to partial types.\r\n            ":"查找类似于部分类型的本地化字符串。\r\n            \r\n","Context for the accessibility check (e.g. containing type of method with ":"可访问性检查的上下文（例如，包含方法类型\r\n","\r\n            Represents a method that is based on another method.\r\n            When inheriting from this class, one shouldn't assume that \r\n            the default behavior it has is appropriate for every case.\r\n            That behavior should be carefully reviewed and derived type\r\n            should override behavior as appropriate.\r\n            ":"\r\n            表示基于另一种方法的方法。\r\n            从这个课程继承时，不应该假设\r\n            它具有的默认行为适用于每种情况。\r\n            该行为应仔细审查和派生类型\r\n            应适当地覆盖行为。\r\n            \r\n","\r\n            Lower a foreach loop that will enumerate the characters of a string.\r\n            \r\n            string s = x;\r\n            for (int p = 0; p < s.Length; p = p + 1) {\r\n                V v = (V)s.Chars[p];\r\n                // body\r\n            }\r\n            ":"\r\n            降低foreach循环，该循环将枚举字符串的字符。\r\n            \r\n            字符串s=x;\r\n            对于(int p=0;p<S.长度;p=p+1){\r\n                V v=(V)s.Chars[p];\r\n                //身体\r\n            }\r\n            \r\n","The {1} '{0}' cannot be used with type arguments":"{1}'{0}'不能与类型参数一起使用\r\n"," for the underlying \r\n            metadata as soon as the are needed. \r\n            \r\n            The new compilation uses whatever metadata is currently being provided by the ":" 对于基础\r\n            元数据一旦需要。\r\n            \r\n            新汇编使用当前正在提供的任何元数据\r\n","\r\n            If you pass in a method symbol, its type arguments will be re-inferred and the re-inferred method will be returned.\r\n            ":"\r\n            如果您传递方法符号，则将重新提出其类型参数，并将返回该方法。\r\n            \r\n","\r\n            Computes the scope to which the given invocation can escape\r\n            NOTE: the escape scope for ref and val escapes is the same for invocations except for trivial cases (ordinary type returned by val) \r\n                  where escape is known otherwise. Therefore we do not vave two ref/val variants of this.\r\n                  \r\n            NOTE: we need scopeOfTheContainingExpression as some expressions such as optional ":"\r\n            计算给定调用可以逃脱的范围\r\n            注意：除了琐碎的情况（Val返回的普通类型）外，REF和Val Escapes的逃生范围是相同的\r\n                  逃脱的地方是另外的。因此，我们不为此提供两个参考/val变体。\r\n                  \r\n            注意：我们需要范围内表达作为一些表达式（例如可选）\r\n","\r\n              Looks up a localized string similar to Module '{0}' in assembly '{1}' is forwarding the type '{2}' to multiple assemblies: '{3}' and '{4}'..\r\n            ":"\r\n              查找类似于Module'{0}'insedbly'{1}'的本地化字符串将类型'{2}'转发到多个汇编：'{3}'和'{4}'。\r\n            \r\n","Flag indicating whether a speculative semantic model was created.":"标志指示是否创建了投机语义模型。\r\n","\r\n            Gets the last directive of the tree rooted by this node.\r\n            ":"\r\n            获取由该节点扎根的树的最后指令。\r\n            \r\n"," value with the outcome of the lookup":" 与查找结果的价值\r\n","\r\n              Looks up a localized string similar to The CallerFilePathAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments.\r\n            ":"\r\n              查找类似于CallerFilePathTribute的本地化字符串将无效，因为它适用于不允许可选参数的上下文中使用的成员。\r\n            \r\n","\r\n            Decides whether to the add the bound node to the cache or not.\r\n            ":"\r\n            决定是否将界点添加到缓存中。\r\n            \r\n","\r\n              Looks up a localized string similar to The using alias '{0}' appeared previously in this namespace.\r\n            ":"\r\n              查找类似于使用别名'{0}'的本地化字符串，以前在此名称空间中出现。\r\n            \r\n","\r\n              Looks up a localized string similar to Both partial method declarations, '{0}' and '{1}', must use the same tuple element names..\r\n            ":"\r\n              查找类似于两个部分方法声明的本地化字符串'{0}'和'{1}'，必须使用相同的元组元素名称。\r\n            \r\n"," if the set is empty. If the set\r\n            contains values but we cannot produce a particular value (e.g. for the set `nint > int.MaxValue`), returns null.\r\n            ":" 如果设置为空。如果设置\r\n            包含值，但我们无法产生特定的值（例如，对于集合`nint> int.maxvalue'），返回null。\r\n            \r\n","\r\n            Creates a new token with the specified old trivia replaced with a new trivia. The old trivia may appear in\r\n            the token's leading or trailing trivia.\r\n            ":"\r\n            创建一个新的令牌，指定的旧琐事被一个新的琐事代替。旧琐事可能出现在\r\n            令牌的领导或尾随琐事。\r\n            \r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 2.  Please use language version {1} or greater..\r\n            ":"\r\n              查找类似于功能'{0}'的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Dereference of a possibly null reference..\r\n            ":"\r\n              查找类似于null引用的解除的局部字符串。\r\n            \r\n","Friend access was granted by '{0}', but the public key of the output assembly ('{1}') does not match that specified by the InternalsVisibleTo attribute in the granting assembly.":"Friend Access由“ {0}”授予，但是输出组件（'{1}'）的公共密钥与授予程序集中的InternalSvisibleto属性指定的公共密钥不匹配。\r\n","Creates a new NameColonSyntax instance.":"创建一个新的namecolonsyntax实例。\r\n"," will query the given ":" 会查询给定的\r\n","\r\n            If the condition has a constant value, then just use the selected branch.\r\n            e.g. \"true ? x : y\" becomes \"x\".\r\n            ":"\r\n            如果条件具有恒定值，则只需使用选定的分支即可。\r\n            例如“ true？x：y”变为“ x”。\r\n            \r\n","'{0}' is an ambiguous reference between '{1}' and '{2}'":"'{0}'是'{1}'和'{2}'之间的模棱两可的引用\r\n","\r\n            If we have a type test followed by a cast to that type, and the types are reference types,\r\n            then we can replace the pair of them by a conversion using `as` and a null check.\r\n            ":"\r\n            如果我们有类型的测试，然后是该类型的铸件，并且类型是参考类型，则\r\n            然后，我们可以使用“ AS”和NULL检查来替换它们对。\r\n            \r\n","Overloadable binary operator expected":"预期可超载的二进制运营商\r\n","Sequence of simple plain names.":"简单名称的顺序。\r\n","\r\n            Take the given text and treat it as the contents of a string literal, returning a token for that.\r\n            ":"\r\n            以给定的文本并将其视为字符串文字的内容，为此返回令牌。\r\n            \r\n","\r\n            A collection of local variables that are written outside the region.\r\n            ":"\r\n            该地区以外写的本地变量的集合。\r\n            \r\n","\r\n              Looks up a localized string similar to The result of the expression is always 'null' of type '{0}'.\r\n            ":"查找类似于表达式结果的本地化字符串始终是“ {0}”类型的“ null”。\r\n            \r\n","Will be used to return the namespace of the found forwarder, \r\n            if any.":"将用于返回发现的货币的名称空间，\r\n            如果有的话。\r\n","Class which represents the syntax node for identifier name.":"代表标识符名称的语法节点的类。\r\n"," returns the value of the ":" 返回\r\n","\r\n              Looks up a localized string similar to Missing path attribute.\r\n            ":"\r\n              查找类似于缺少路径属性的本地化字符串。\r\n            \r\n","The references for the new compilation.":"新汇编的参考。\r\n","RHS":"RHS\r\n","\r\n            We are diverging from the C# 4 spec (and Dev10) to follow the C# 5 spec.\r\n            The iteration variable will be declared *inside* each loop iteration,\r\n            rather than outside the loop.\r\n            ":"\r\n            我们与C＃4规格（和Dev10）有所不同，以遵循C＃5规格。\r\n            迭代变量将被声明 *内部 *每个循环迭代，\r\n            而不是外部循环。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' has some invalid arguments.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串不包含“ {1}”的定义，而最佳的扩展方法Overload'{2}'具有一些无效的参数。\r\n            \r\n","\r\n            Lazy cache of well known members.\r\n            Not yet known value is represented by ErrorTypeSymbol.UnknownResultType\r\n            ":"\r\n            知名会员的懒惰缓存。\r\n            尚不知道的值由errortypesymbol.inknownresulttype表示\r\n            \r\n","\r\n              Looks up a localized string similar to Expected 'disable' or 'restore'.\r\n            ":"\r\n              查找类似于预期的“禁用”或“还原”的局部字符串。\r\n            \r\n","\r\n            Get a SemanticModel object that is associated with a statement that did not appear in\r\n            this source code. This can be used to get detailed semantic information about sub-parts\r\n            of a statement that did not appear in source code. \r\n            ":"\r\n            获取与未出现在\r\n            此源代码。这可以用来获取有关子部分的详细语义信息\r\n            源代码中未出现的语句。\r\n            \r\n","Called when the visitor visits a ObjectCreationExpressionSyntax node.":"当访问者访问objectCreationexpressyntax节点时调用。\r\n","SyntaxToken representing equals greater than.":"语法代表的等于大于。\r\n","\r\n              Looks up a localized string similar to '{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context (consider using System.Runtime.InteropServices.Marshal.SizeOf).\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串没有预定义的大小，因此只能在不安全的上下文中使用sizeof（请考虑使用system.runtime.interopservices.marshal.sizeof）。\r\n            \r\n","\r\n            C# 4.0 §3.6: For the purposes of signatures, the types object and dynamic are considered the\r\n            same. \r\n            ":"\r\n            C＃4.0§3.6：出于签名的目的，类型对象和动态被视为\r\n            相同的。\r\n            \r\n","\r\n            We will follow Dev10 in diverging from the C# 4 spec by ignoring Array's \r\n            implementation of IEnumerable and just indexing into its elements.\r\n            \r\n            NOTE: We're assuming that sequence points have already been generated.\r\n            Otherwise, lowering to nested for-loops would generated spurious ones.\r\n            ":"\r\n            我们将遵循Dev10，通过忽略数组来偏离C#4规范 \r\n            实现IEnumerable和只是索引到它的元素。\r\n            \r\n            注意：我们假设序列点已经生成。\r\n            否则，降低到嵌套for循环将生成虚假循环。\r\n            \r\n","\r\n               Looks up a localized string similar to \r\n                                         Visual C# Compiler Options\r\n            \r\n                                   - OUTPUT FILES -\r\n            -out:<file>                   Specify output file name (default: base name of\r\n                                          file with main class or first file)\r\n            -target:exe                   Build a console executable (default) (Short\r\n                                          form: -t:exe)\r\n            -target:winexe                Build a Windows executable (Short form:\r\n                                          -t:winexe)\r\n            -target:library               B [rest of string was truncated]\";.\r\n             ":"\r\n               查找类似于\r\n                                         视觉C＃编译器选项\r\n            \r\n                                    - 输出文件 - \r\n            -out：<file>指定输出文件名称（默认值：\r\n                                          带有主类或第一个文件的文件）\r\n            -target：exe构建控制台可执行文件（默认）（简短）\r\n                                          表格：-t：exe）\r\n            -target：Winexe构建Windows可执行文件（简短表格：\r\n                                          -t：winexe）\r\n            -target：库B [弦的其余部分被截断];。\r\n             \r\n","\r\n            Visit the switch expression, and return the initial break state.\r\n            ":"\r\n            访问开关表达式，然后返回初始中断状态。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot define a class or member that utilizes 'dynamic' because the compiler required type '{0}' cannot be found. Are you missing a reference?.\r\n            ":"\r\n              查找类似于使用“动态”的类或成员的局部字符串，因为找不到编译器所需类型'{0}'。您是否缺少参考？\r\n            \r\n",").\r\n            When it returns false, it does not advance in the token stream.\r\n            ":"）。\r\n            当它返回false时，它不会在令牌流中前进。\r\n            \r\n"," with a matching original symbol somewhere in the given scope or nested scopes.\r\n            ":" 在给定的示波器或嵌套范围中的某个地方，带有匹配的原始符号。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' cannot implement '{1}' because it is not supported by the language.\r\n            ":"\r\n              查找类似于“ {0}'无法实现'{1}”的本地化字符串，因为该语言不支持它。\r\n            \r\n","Duplicate '{0}' modifier":"重复'{0}'修饰符\r\n",",\r\n            or top-level ":"，，，，\r\n            或顶级\r\n","\r\n            Used to generate the dynamic attributes for the required typesymbol.\r\n            ":"用于生成所需类型符号的动态属性。\r\n            \r\n","System.Type type symbol.":"System.Type类型符号。\r\n","\r\n            Returned binder doesn't need to have ":"返回的粘合剂不需要\r\n","\r\n              Looks up a localized string similar to query expression.\r\n            ":"\r\n              查找类似于查询表达式的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to A parameter array cannot be used with 'this' modifier on an extension method.\r\n            ":"\r\n              在扩展方法上查找类似于参数阵列的本地化字符串。\r\n            \r\n","a calling ctor":"呼叫ctor\r\n","\r\n            Returns true if the node is the object of an invocation expression.\r\n            ":"\r\n            如果节点是调用表达式的对象，则返回true。\r\n            \r\n","\r\n            Module's ordinal within containing assembly's Modules array.\r\n            0 - for a source module, etc.\r\n            -1 - for a module that doesn't have containing assembly, or has it, but is not part of Modules array. \r\n            ":"\r\n            包含组件模块阵列中的模块的序数。\r\n            0-对于源模块，等。\r\n            -1-对于没有包含汇编的模块，或没有包含的模块，但不是模块数组的一部分。\r\n            \r\n","\r\n            Returns this list as a ":"\r\n            将此列表返回\r\n","SyntaxNode representing the body of the lambda expression.":"语法句表示代表lambda表达的主体。\r\n","\r\n            Add sequence point |here|:\r\n            \r\n            foreach (Type var in |expr|) { }\r\n            ":"\r\n            添加序列点/这里|:\r\n            \r\n            foreach(类型var in/expr/){}\r\n            \r\n","Single-line comment or end-of-line expected":"单线评论或期望\r\n","\r\n            If necessary, report a diagnostic for a hidden abstract member.\r\n            ":"\r\n            如有必要，请报告隐藏的抽象成员的诊断。\r\n            \r\n","Additional argument type":"附加参数类型\r\n","\r\n            Creates a SemanticModel for an autoprop initializer of a named type\r\n            ":"\r\n            为命名类型的Autoprop初始化器创建smanticmodel\r\n            \r\n","Creates a new IndexerMemberCrefSyntax instance.":"创建一个新的indexermembercrefsyntax实例。\r\n","\r\n            The ValueTuple type for this tuple.\r\n            The type argument corresponding to the type of the extension field (VT[8].Rest),\r\n            which is at the 8th (one based) position is always a symbol for another tuple, \r\n            rather than its underlying type.\r\n            ":"\r\n            该元组的估值类型。\r\n            与扩展字段类型相对应的类型参数（VT [8] .rest），\r\n            在第八位（一个基于一个）位置始终是另一个元组的符号，\r\n            而不是其基础类型。\r\n            \r\n"," which\r\n            hasn't had logic to move the proxy analysis into ":" 哪个\r\n            没有逻辑将代理分析转移到\r\n","You have added a reference to an assembly using /link (Embed Interop Types property set to True). This instructs the compiler to embed interop type information from that assembly. However, the compiler cannot embed interop type information from that assemb ...":"您已使用 /链接添加了对汇编的引用（嵌入Interop类型设置为true）。这指示编译器从该组件中嵌入Interop类型信息。但是，编译器无法嵌入该组件的Interop类型信息...\r\n"," with no known type, given lookup resultKind.\r\n            ":" 没有已知类型，给定查找结果。\r\n            \r\n","\r\n              Looks up a localized string similar to { or ; or => expected.\r\n            ":"\r\n              查找类似于{或;或=>预期。\r\n            \r\n","An alternative SyntaxKind that can be inferred for this token in special\r\n            contexts. These are usually keywords.":"可以在特殊的代币中推断出的替代语法\r\n            上下文。这些通常是关键字。\r\n","\r\n            Force a variable to have a slot.  Returns -1 if the variable has an empty struct type.\r\n            ":"\r\n            强制变量具有插槽。返回-1如果变量具有空结构类型。\r\n            \r\n","Parameter list syntax.":"参数列表语法。\r\n","\r\n              Looks up a localized string similar to Assembly reference is invalid and cannot be resolved.\r\n            ":"查找类似于汇编引用的本地化字符串无效，无法解决。\r\n            \r\n","The underlying type for a tuple must be tuple-compatible.":"元组的基础类型必须兼容。\r\n","Struct members cannot return 'this' or other instance members by reference":"结构成员不能通过参考返回“此”或其他实例成员\r\n","Not all code paths return a value in {0} of type '{1}'":"并非所有代码路径返回一个类型'{1}'的{0}中的值\r\n","Members of readonly field '{0}' cannot be returned by writable reference":"Readonly Field'{0}'的成员不能通过Writable Reference返回\r\n","\r\n              Looks up a localized string similar to The dynamically dispatched call to method '{0}' may fail at runtime because one or more applicable overloads are conditional methods..\r\n            ":"\r\n              查找类似于方法'{0}'的动态调用的本地化字符串在运行时可能会失败，因为一个或多个适用的过载是条件方法。\r\n            \r\n","Creates a new TypePatternSyntax instance.":"创建一个新的TypePatternsyntax实例。\r\n","\r\n            Represents a reference to a type nested in an instantiation of a generic type.\r\n            e.g. \r\n            A{int}.B\r\n            A.B{int}.C.D\r\n            ":"表示对嵌套在通用类型的实例化中的类型的引用。\r\n            例如\r\n            a {int} .b\r\n            a.b {int} .c.d\r\n            \r\n","An instance of analyzer {0} cannot be created from {1} : {2}.":"无法从{1}：{2}创建分析仪的实例{0}。\r\n","'{0}': a parameter, local variable, or local function cannot have the same name as a method type parameter":"'{0}'：参数，本地变量或本地函数不能与方法类型参数具有相同的名称\r\n","\r\n            Essentially this is a wrapper around another AssemblySymbol that is responsible for retargeting\r\n            symbols from one assembly to another. It can retarget symbols for multiple assemblies at the same time. \r\n            \r\n            For example, compilation C1 references v1 of Lib.dll and compilation C2 references C1 and v2 of Lib.dll. \r\n            In this case, in context of C2, all types from v1 of Lib.dll leaking through C1 (through method \r\n            signatures, etc.) must be retargeted to the types from v2 of Lib.dll. This is what \r\n            RetargetingAssemblySymbol is responsible for. In the example above, modules in C2 do not \r\n            reference C1.m_AssemblySymbol, but reference a special RetargetingAssemblySymbol created for \r\n            C1 by ReferenceManager.\r\n            \r\n            Here is how retargeting is implemented in general:\r\n            - Symbols from underlying assembly are substituted with retargeting symbols.\r\n            - Symbols from referenced assemblies that can be reused as is (i.e. doesn't have to be retargeted) are\r\n              used as is.\r\n            - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.\r\n            ":"\r\n            本质上，这是另一个围绕另一个负责重新定位的包装器\r\n            从一个组件到另一个组件的符号。它可以同时重新定位多个组件。\r\n            \r\n            例如，lib.dll的c1参考v1和汇编C2参考c1和v2的lib.dll的v2。\r\n            在这种情况下，在C2的背景下，Lib.dll的V1的所有类型都通过C1泄漏（通过方法\r\n            签名等。这是什么\r\n            retargetingAssemblysymbol负责。在上面的示例中，C2中的模块不\r\n            参考C1.M_ASSEMBLYSYMBOL，但请参考为创建的特殊retargetingAssemblysymbol\r\n            C1由ReferenceManager。\r\n            \r\n            这是如何实施重新定位的方式：\r\n             - 基础组件的符号用重新定位符号代替。\r\n             - 可以按原样重复使用的参考组件的符号（即不必重新定位）是\r\n              按原样使用。\r\n             - 必须重新定位的参考组件中的符号被重新定位的结果代替。\r\n            \r\n","\r\n            One or more errors occurred while performing the lookup\r\n            ":"\r\n            执行查找时发生一个或多个错误\r\n            \r\n","LookupOptions has an invalid combination of options":"Lookupotions具有无效的选项组合\r\n","SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.":"参数的分离列表，代表参数列表。\r\n","Return type of '{0}' is not CLS-compliant":"'{0}'的返回类型不符合CLS\r\n","dictionary initializer":"字典初始化器\r\n","\r\n            If we are outputting a .winmdobj then the setter name is put_, not set_.\r\n            ":"\r\n            如果我们要输出.winmdobj，则setter名称为put_，而不是set_。\r\n            \r\n","Creates a new CatchDeclarationSyntax instance.":"创建一个新的catchdeclarationsyntax实例。\r\n","\r\n              Looks up a localized string similar to '{0}' is a local function and must therefore always have a body..\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串是一个本地函数，因此必须始终具有一个主体。\r\n            \r\n","Function pointers":"功能指针\r\n","\r\n            This reflects the Dev10 compiler's rules for when a variable initialization is considered a \"use\"\r\n            for the purpose of suppressing the warning about unused variables.\r\n            ":"\r\n            这反映了DEV10编译器何时将变量初始化视为“使用”的规则\r\n            为了抑制有关未使用变量的警告。\r\n            \r\n","\r\n            The set of local variables and parameters that were hoisted and need a proxy.\r\n            ":"\r\n            悬挂并需要代理的局部变量和参数集。\r\n            \r\n","\r\n            Add the variable to the captured set. For range variables we only add it if inside the region.\r\n            ":"\r\n            将变量添加到捕获的集合中。对于范围变量，我们仅在区域内添加它。\r\n            \r\n"," doesn't close over.\r\n            If a scope is in this set, don't use a struct closure.\r\n            ":" 没有结束。\r\n            如果该集合中有一个示波器，请不要使用结构闭合。\r\n            \r\n","\r\n              Looks up a localized string similar to Could not find '{0}' specified for Main method.\r\n            ":"\r\n              查找类似于主要方法指定的'{0}'的本地化字符串。\r\n            \r\n","\r\n            Is the current token something that could follow a type in a pattern?\r\n            ":"当前的令牌是否可以遵循模式的类型？\r\n            \r\n","\r\n              Looks up a localized string similar to Members of readonly field '{0}' cannot be used as a ref or out value (except in a constructor).\r\n            ":"\r\n              查找类似于ReadOnly字段'{0}'成员的本地化字符串不能用作ref或out值（在构造函数中除外）。\r\n            \r\n","\r\n            A SyntaxReference implementation that lazily translates the result (CSharpSyntaxNode) of the\r\n            original syntax reference to a syntax reference for its NamespaceDeclarationSyntax.\r\n            ":"\r\n            懒洋洋地翻译结果（csharpsyntaxnode）的语法实现\r\n            原始语法引用其命名eClarationsyntax的语法引用。\r\n            \r\n","Remarks, mutually exclusive with ":"备注，互斥\r\n","A character position used to identify a declaration scope and accessibility. This\r\n            character position must be within the FullSpan of the Root syntax node in this SemanticModel.\r\n            ":"用于标识声明范围和可访问性的角色位置。这个\r\n            字符位置必须在此semanticmodel中的root语法节点的成面内。\r\n            \r\n","<=":"<=\r\n","\r\n              Looks up a localized string similar to Struct members cannot return 'this' or other instance members by reference.\r\n            ":"\r\n              查找类似于struct成员的本地化字符串无法通过参考返回“此”或其他实例成员。\r\n            \r\n","Error opening Win32 manifest file {0} -- {1}":"错误打开Win32清单文件{0}  -  {1}\r\n","String interpolation":"字符串插值\r\n","\r\n              Looks up a localized string similar to The tuple element names in the signature of method '{0}' must match the tuple element names of interface method '{1}' (including on the return type)..\r\n            ":"\r\n              在方法'{0}'签名中的元组元素名称类似的本地化字符串必须匹配接口方法的元组元素名称'{1}'（包括返回类型）。\r\n            \r\n","\r\n            Set only in conjunction with ":"\r\n            仅与\r\n","\r\n            Used only for testing.\r\n            ":"\r\n            仅用于测试。\r\n            \r\n","true if there is a top-level explicit null check":"如果存在顶级显式null检查，则为true\r\n","Cannot convert {0} to type '{1}' because the parameter types do not match the delegate parameter types":"无法将{0}转换为type' {1}'，因为参数类型与委托参数类型不匹配\r\n","Gets the \"this\" or \"base\" keyword.":"获取“此”或“基本”关键字。\r\n","\r\n             Decodes PermissionSetAttribute applied in source to determine if it needs any fixup during codegen.\r\n             ":"\r\n             解码在源中应用的PermissionsetAttribute确定它是否需要在CodeGen期间进行任何修复。\r\n             \r\n"," resolves to an alias name, return the AliasSymbol corresponding\r\n            to A. Otherwise return null.\r\n            ":" 解析为别名名称，返回别扬symbol对应\r\n            向A.否则返回null。\r\n            \r\n","\r\n             To implement an interface member, a candidate member must be public, non-static, and have\r\n             the same signature.  \"Have the same signature\" has a looser definition if the type implementing\r\n             the interface is from source.\r\n             ":"\r\n             要实现接口成员，候选人必须是公共，非静态的，并且\r\n             相同的签名。如果实现类型，则“具有相同的签名”具有宽松的定义\r\n             接口来自源。\r\n             \r\n","\r\n              Looks up a localized string similar to The syntax 'var' for a pattern is not permitted to refer to a type, but '{0}' is in scope here..\r\n            ":"\r\n              查找类似于语法“ var”的本地化字符串，不允许引用某种类型，但是“ {0}”在此处。\r\n            \r\n","readonly references":"可读的参考\r\n","Cannot make reference to variable of type '{0}'":"无法引用类型'{0}'的变量\r\n"," makes multiple calls\r\n             to this function, only one result is observable.\r\n             ":" 拨打多个电话\r\n             对于此功能，只能观察到一个结果。\r\n             \r\n","\r\n            The list of trivia that appears before this node in the source code.\r\n            ":"源代码中此节点之前出现的琐事列表。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use alias '{0}' with '::' since the alias references a type. Use '.' instead..\r\n            ":"\r\n              由于别名引用类型，因此查找类似于使用'{0}'的本地化字符串。利用 '。'反而..\r\n            \r\n","\r\n               Looks up a localized string similar to You have added a reference to an assembly using /link (Embed Interop Types property set to True). This instructs the compiler to embed interop type information from that assembly. However, the compiler cannot embed interop type information from that assembly because another assembly that you have referenced also references that assembly using /reference (Embed Interop Types property set to False).\r\n            \r\n            To embed interop type information for both assemblies, use /link for references to each assembly (set the Em [rest of string was truncated]\";.\r\n             ":"\r\n               查找类似于您的本地化字符串，使用 /链接添加了对汇编的引用（嵌入Interop类型属性设置为true）。这指示编译器从该组件中嵌入Interop类型信息。但是，编译器无法嵌入该组件中的Interop类型信息，因为您引用的另一个组件还引用了使用 /参考（嵌入Interop类型属性设置为false）的汇编。\r\n            \r\n            要嵌入两个组件的Interop类型信息，请使用 /链接以引用到每个组件（设置EM [String的其余部分被截断]”;。\r\n             \r\n","Indexers cannot have void type":"索引器不能具有无效类型\r\n","'{0}': cannot explicitly call operator or accessor":"'{0}'：无法明确调用操作员或登录器\r\n","\r\n              Looks up a localized string similar to Identifier expected; '{1}' is a keyword.\r\n            ":"\r\n              查找类似于预期标识符的局部字符串； '{1}'是一个关键字。\r\n            \r\n","\r\n            Rewrites the given bound node with nullability information, and returns snapshots for later speculative analysis at positions inside this member.\r\n            ":"\r\n            使用无效信息重写给定的结合节点，并返回快照以进行以后在该成员内部位置的投机分析。\r\n            \r\n","Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy":"假设由'{1}'匹配身份'{2}'的'{3}'使用的汇编引用'{0}'使用，您可能需要提供运行时策略\r\n","\r\n            Return the sub-expressions for the righthand side of a deconstruction\r\n            assignment. cf. LocalRewriter.GetRightParts.\r\n            ":"\r\n            返回解构的右侧的子表达\r\n            任务。参见LocalRewriter.getRightParts。\r\n            \r\n","\r\n            Is a member with declared accessibility \"declaredAccessibility\" accessible from within\r\n            \"within\", which must be a named type or an assembly.\r\n            ":"\r\n            是可以从内部访问的成员\r\n            “在内部”，必须是命名类型或一个组件。\r\n            \r\n","\r\n            These won't be returned by GetAttributes on source methods, but they\r\n            will be returned by GetAttributes on metadata symbols.\r\n            ":"\r\n            这些不会通过源方法上的getAttibutes返回，但是它们\r\n            将通过元数据符号上的getAttributes返回。\r\n            \r\n","The index of the first non-whitespace char in the string":"字符串中的第一个非Whitespace char的索引\r\n","Cannot create delegate with '{0}' because it or a method it overrides has a Conditional attribute":"无法用'{0}'创建委派，因为它或覆盖的方法具有条件属性\r\n","A list of syntax nodes that represents the content of the exception element.":"表示异常元素内容的语法节点列表。\r\n","True if errors were found.":"如果发现错误，则为真实。\r\n","A /reference option that declares an extern alias can only have one filename. To specify multiple aliases or filenames, use multiple /reference options.":"声明外部别名的A /参考选项只能具有一个文件名。要指定多个别名或文件名，请使用多个 /参考选项。\r\n","\r\n            Computes the scope to which the given invocation can escape\r\n            NOTE: the escape scope for ref and val escapes is the same for invocations except for trivial cases (ordinary type returned by val) \r\n                  where escape is known otherwise. Therefore we do not have two ref/val variants of this.\r\n                  \r\n            NOTE: we need scopeOfTheContainingExpression as some expressions such as optional ":"\r\n            计算给定调用可以逃脱的范围\r\n            注意：除了琐碎的情况（Val返回的普通类型）外，REF和Val Escapes的逃生范围是相同的\r\n                  逃脱的地方是另外的。因此，我们没有两个Ref/Val变体。\r\n                  \r\n            注意：我们需要范围内表达作为一些表达式（例如可选）\r\n","\r\n              Looks up a localized string similar to Named argument specifications must appear after all fixed arguments have been specified. Please use language version {0} or greater to allow non-trailing named arguments..\r\n            ":"\r\n              在指定所有固定参数后，必须出现类似于命名参数规范的本地化字符串。请使用语言版本{0}或更大的范围以允许非拨号命名参数。\r\n            \r\n","Type or member cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute":"类型或成员不能标记为CLS兼容，因为组件没有CLSCompliant属性\r\n","ArrayTypeSyntax node representing the type of the array.":"代表数组类型的arrayTypesyntax节点。\r\n","\r\n            Syntax offset is a unique identifier for the local within the emitted method body.\r\n            It's based on position of the local declarator. In single-part method bodies it's simply the distance\r\n            from the start of the method body syntax span. If a method body has multiple parts (such as a constructor\r\n            comprising of code for member initializers and constructor initializer calls) the offset is calculated\r\n            as if all source these parts were concatenated together and prepended to the constructor body.\r\n            The resulting syntax offset is then negative for locals defined outside of the constructor body.\r\n            ":"\r\n            语法偏移是发射方法主体内局部的唯一标识符。\r\n            它基于本地宣告者的位置。在单部分方法的主体中，这只是距离\r\n            从方法的开始，主体语法跨度。如果方法主体有多个部分（例如构造函数\r\n            包括成员初始化器和构造函数初始化器调用的代码）计算偏移量\r\n            好像所有来源的这些部分都被连接在一起，并添加到构造函数上。\r\n            然后，所得的语法偏移量对于在构造函数主体外定义的当地人为负。\r\n            \r\n","\r\n            Gets the MemberSemanticModel that contains the node.\r\n            ":"\r\n            获取包含节点的成员emanticmodel。\r\n            \r\n","\r\n            Marks the method builder as successfully completed, and sets the result if method is Task<T>-returning.\r\n            ":"\r\n            将方法构建器标记为成功完成，并设置结果，如果方法为任务<t>返回。\r\n            \r\n","\r\n            This method is introduced to move the implicit conversion operator call from the caller\r\n            so as to reduce the caller stack frame size\r\n            ":"\r\n            引入此方法以从呼叫者移动隐式转换操作员调用\r\n            为了减少呼叫者堆栈框架尺寸\r\n            \r\n","\r\n            Binds the provided expression in the given context.\r\n            ":"\r\n            在给定上下文中绑定提供的表达式。\r\n            \r\n","The type name '{0}' could not be found in the global namespace. This type has been forwarded to assembly '{1}' Consider adding a reference to that assembly.":"类型名称'{0}'在全局名称空间中找不到。此类型已转发到汇编'{1}'考虑对该组件添加引用。\r\n","\r\n              Looks up a localized string similar to 'await' requires that the return type '{0}' of '{1}.GetAwaiter()' have suitable 'IsCompleted', 'OnCompleted', and 'GetResult' members, and implement 'INotifyCompletion' or 'ICriticalNotifyCompletion'.\r\n            ":"\r\n              查找类似于“等待”的本地化字符串，要求'{1} .getawaiter（）'具有合适的'iSComplet'，“ oncompleteD”和“ getResult”成员的返回类型'{0}'和实现'inotifyCompletion， '或“ IcriticalnotifyCompletion”。\r\n            \r\n","\r\n            Creates the syntax representation of an xml element that spans multiple text lines.\r\n            ":"\r\n            创建跨多个文本行的XML元素的语法表示。\r\n            \r\n","Cannot implicitly convert type '{0}' to '{1}'":"不能隐式将类型'{0}'转换为'{1}'\r\n","\r\n            Returns TupleType when a possible tuple type is found.\r\n            Note that this is not MustBeType, so that the caller can consider deconstruction syntaxes.\r\n            The caller is expected to have consumed the opening paren.\r\n            ":"\r\n            当发现可能的元组类型时，返回tupletype。\r\n            请注意，这不是粗型，因此呼叫者可以考虑解构语法。\r\n            预计呼叫者将消耗开幕式。\r\n            \r\n",", it requires the version\r\n            of the data in the stream to exactly match the current format version.\r\n            Should only be used to read data written by the same version of Roslyn.\r\n            ":"，需要版本\r\n            流中的数据以与当前格式版本完全匹配。\r\n            仅应用于读取由同一版本的罗斯琳编写的数据。\r\n            \r\n","\r\n            Gets the set of interfaces that this type directly implements, plus the base interfaces\r\n            of all such types.\r\n            ":"\r\n            获取该类型直接实现的接口集，以及基础接口\r\n            所有这些类型。\r\n            \r\n","override":"覆盖\r\n","'{0}': cannot derive from the dynamic type":"'{0}'：不能从动态类型派生\r\n","\r\n            Gets the attributes for this symbol. Returns an empty ":"\r\n            获取此符号的属性。返回空\r\n","True if some IEnumerable is found (may still be ambiguous).":"如果发现某些可感染的话（仍然可能是模棱两可的）。\r\n","Cannot infer the type of implicitly-typed deconstruction variable '{0}'.":"无法推断隐型解构变量的类型'{0}'。\r\n","'{0}' cannot be extern and declare a body":"'{0}'不能外部并声明身体\r\n"," that represents its eventual completion.\r\n            ":" 这代表其最终的完成。\r\n            \r\n","Class representing what language construct an attribute targets.":"代表哪种语言构建属性目标的类。\r\n","\r\n            Represents a parameter of a method or a property of a tuple type\r\n            ":"代表方法或元组类型的属性的参数\r\n            \r\n","Expression over which to iterate.":"表达迭代的表达。\r\n","\r\n            Currently allowAnyTarget flag is only set to true by AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,\r\n            where we must consider user defined implicit conversions from the type of the switch expression to\r\n            any of the possible switch governing types.\r\n            ":"\r\n            目前，仅通过AnalyzeImplicerDefinedConversionForsWitchGoverningType设置允许YANYTARGET标志，\r\n            我们必须考虑用户定义的隐式转换从开关表达式的类型到\r\n            任何可能的开关管理类型。\r\n            \r\n","SyntaxToken representing the greater than token.":"语法代表比令牌更大。\r\n","Attributes are not valid in this context.":"在这种情况下，属性无效。\r\n","Creates a new ConstructorDeclarationSyntax instance.":"创建一个新的constructordeclarationsyntax实例。\r\n",".\r\n            to allow derived classes to ensure constraints within the containing\r\n            type or method are resolved in a consistent order, regardless of the\r\n            order the callers query individual type parameters.\r\n            ":"。\r\n            允许派生的类以确保包含的约束\r\n            类型或方法以一致的顺序解析，而不管\r\n            订购呼叫者查询各个类型参数。\r\n            \r\n","\r\n            Returns the System.String that represents the current TypedConstant.\r\n            ":"\r\n            返回代表当前键入的系统。\r\n            \r\n","\r\n            Returns true if...\r\n            1. The precedence is less than or equal to Assignment, and\r\n            2. The current token is the identifier var or a predefined type, and\r\n            3. it is followed by (, and\r\n            4. that ( begins a valid parenthesized designation, and\r\n            5. the token following that designation is =\r\n            ":"\r\n            如果...返回true\r\n            1.优先级小于或等于分配，并且\r\n            2.当前令牌是标识符VAR或预定义的类型，并且\r\n            3.其次是（和\r\n            4.（开始有效的括号指定，\r\n            5.以下名称的令牌为=\r\n            \r\n","\r\n            A MemberCrefSyntax specified by an operator keyword, an operator symbol and an optional parameter list.\r\n            For example, \"operator +\" or \"operator -[int]\".\r\n            NOTE: the operator must be overloadable.\r\n            ":"\r\n            由操作员关键字，操作员符号和可选参数列表指定的成员crefsyntax。\r\n            例如，“操作员 +”或“操作员 -  [int]”。\r\n            注意：操作员必须超载。\r\n            \r\n","\r\n            This method should be kept consistent with Compiler.BindConstructorInitializer (e.g. same error codes).\r\n            ":"\r\n            该方法应与Compiler.BindConstructorinitializer（例如相同的错误代码）保持一致。\r\n            \r\n","\r\n            An array of cached well known types available for use in this Compilation.\r\n            Lazily filled by GetWellKnownType method.\r\n            ":"\r\n            一系列可用于此汇编的缓存众所周知的类型。\r\n            懒洋洋地填充了getwellknowntype方法。\r\n            \r\n","Catch clauses cannot follow the general catch clause of a try statement":"捕获子句不能遵循试用语句的一般捕获条款\r\n"," to construct an instantiation.\r\n             ":" 构建实例化。\r\n             \r\n","\r\n            Perform a check whether the type or at least one of its generic arguments \r\n            is defined in the specified assemblies. The check is performed recursively. \r\n            ":"\r\n            执行检查类型还是至少一种通用参数\r\n            在指定的组件中定义。检查是递归执行的。\r\n            \r\n","\r\n              Looks up a localized string similar to Type argument cannot be null.\r\n            ":"\r\n              查找类似于类型参数的本地化字符串不能为null。\r\n            \r\n","SyntaxToken representing the kind of the operator of the postfix unary expression.":"Syntaxtkoken表示后缀Unary表达式的运算符类型。\r\n","\r\n            When set, do not perform aggressive optimizations that degrade debugging experience.\r\n            In particular we do not do the following:\r\n            \r\n            1) Do not elide any user defined locals, even if never read from. \r\n               Example:\r\n                 {\r\n                   var dummy = Goo();    // should not become just \"Goo\"\r\n                 }\r\n                   \r\n               User might want to examine dummy in the debugger.\r\n            \r\n            2) Do not carry values on the stack between statements\r\n               Example:\r\n                 {\r\n                   var temp = Goo();\r\n                   temp.ToString();       // should not become   Goo().ToString();\r\n                 }\r\n                  \r\n               User might want to examine temp in the debugger.\r\n                   \r\n            ":"\r\n            设置时，请勿执行激进的优化，以降低调试经验。\r\n            特别是我们不执行以下操作：\r\n            \r\n            1）即使从未阅读，也不要列出任何用户定义的当地人。\r\n               例子：\r\n                 {\r\n                   var dummy = goo（）; //不应该只是“粘”\r\n                 }\r\n                   \r\n               用户可能想检查调试器中的假人。\r\n            \r\n            2）不要在语句之间的堆栈上携带值\r\n               例子：\r\n                 {\r\n                   var temp = goo（）;\r\n                   temp.tostring（）; //不应成为goo（）。toString（）;\r\n                 }\r\n                  \r\n               用户可能想检查调试器中的临时工。\r\n                   \r\n            \r\n","Creates a new InvocationExpressionSyntax instance.":"创建一个新的Invocation expressionsyntax实例。\r\n","Invalid name for a preprocessing symbol; not a valid identifier":"预处理符号的无效名称；没有有效的标识符\r\n","\r\n            A value of this type may represent the intermediate state of merging of an old change into an unadjusted new change,\r\n            resulting in a temporary unadjusted new change whose ":"\r\n            这种类型的值可能代表旧更改合并为未经调整的新更改的中间状态，\r\n            导致暂时未经调整的新变化\r\n","\r\n              Looks up a localized string similar to CLS-compliant interfaces must have only CLS-compliant members.\r\n            ":"\r\n              查找类似于符合CLS的接口类似的本地化字符串必须只有符合CLS的成员。\r\n            \r\n","\r\n              Looks up a localized string similar to The type must be 'var'..\r\n            ":"\r\n              查找类似于类型的本地化字符串必须为“ var”。\r\n            \r\n","\r\n            Implicit dynamic conversions are described in section 6.1.8 of the C# language specification.\r\n            ":"\r\n            隐式动态转换在C＃语言规范的第6.1.8节中描述。\r\n            \r\n","\r\n            should be given for an invalid conversion.\r\n            ":"\r\n            应该给予无效的转换。\r\n            \r\n","\r\n            The closure only contains a reference to the containing class instance (\"this\").\r\n            We don't emit a display class, lambdas are emitted directly to the containing class as its instance methods.\r\n            ":"\r\n            闭合仅包含对包含类实例的引用（“ this”）。\r\n            我们不发出显示类别，lambdas直接发射到包含类的实例方法上。\r\n            \r\n","\r\n            Do not call for a local function.\r\n            ":"\r\n            不要要求本地功能。\r\n            \r\n","'{0}' is a type not supported by the language":"'{0}'是语言不支持的一种类型\r\n","\r\n            Either ":"\r\n            任何一个\r\n","\r\n              Looks up a localized string similar to The type or namespace name '{0}' could not be found in the global namespace (are you missing an assembly reference?).\r\n            ":"\r\n              查找类似于类型或名称空间名称'{0}'的本地化字符串（在全局名称空间中找不到）（您是否缺少“汇编”参考？）。\r\n            \r\n","\r\n            Returns a boolean value if we can determine whether the type is managed\r\n            without looking at its fields and Unset otherwise.\r\n            ":"\r\n            如果我们可以确定是否管理类型，则返回布尔值\r\n            不查看其领域，否则就无法设置。\r\n            \r\n","Statement containing the target label":"包含目标标签的语句\r\n","\r\n            Produces a MoveNext() method for an async-iterator method.\r\n            Compared to an async method, this handles rewriting `yield return` (with states decreasing from -3) and\r\n            `yield break`, and adds special handling for `try` to allow disposal.\r\n            `await` is handled like in async methods (with states 0 and up).\r\n            ":"\r\n            为异步 - 列表方法产生movenext（）方法。\r\n            与异步方法相比，此处理重写“收益率”（状态从-3降低）和\r\n            “收益率中断”，并为``尝试''添加了特殊处理以允许处置。\r\n            “等待”像异步方法一样（具有状态为0及以上）。\r\n            \r\n","\r\n              Looks up a localized string similar to A switch expression or case label must be a bool, char, string, integral, enum, or corresponding nullable type in C# 6 and earlier..\r\n            ":"\r\n              查找类似于开关表达式或案例标签的本地化字符串必须是C＃6和更早的BOOL，CHAR，字符串，积分，枚举或相应的无效类型。\r\n            \r\n",".\r\n            Otherwise, call ":"。\r\n            否则请致电\r\n","Cannot take the address of, get the size of, or declare a pointer to a managed type ('{0}')":"无法获取地址，获取大小或声明指向托管类型的指针（'{0}'）\r\n","\r\n            Advance the current position by one. No guarantee that this\r\n            position is valid.\r\n            ":"\r\n            将当前位置提高一个。不能保证这个\r\n            位置有效。\r\n            \r\n","A local or parameter named '{0}' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter":"在此范围中不能声明名为“ {0}”的本地或参数，因为该名称在封闭的本地范围中使用以定义本地或参数\r\n","\r\n            Reports top-level nullability problem in assignment.\r\n            ":"\r\n            报告分配中的顶级无效问题。\r\n            \r\n","The queue of work items. Also used as a lock to protect all relevant state.":"工作项目的队列。也用作保护所有相关状态的锁。\r\n","\r\n              Looks up a localized string similar to '{0}' is not a valid format specifier.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串不是有效的格式指定符。\r\n            \r\n","The expression evaluator needs to bind deconstructions (both assignments and declarations) as expression-statements\r\n                and still access the returned value":"表达式评估者需要将解构（分配和声明）绑定为表达式陈述\r\n                并仍然访问返回的值\r\n","\r\n              Looks up a localized string similar to A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint..\r\n            ":"\r\n              查找类似于无效类型参数的本地化字符串必须已知是值类型或不可删除的参考类型。考虑添加“类”，“ struct”或类型约束。\r\n            \r\n","\r\n              Looks up a localized string similar to A static local function cannot contain a reference to '{0}'..\r\n            ":"\r\n              查找类似于静态本地函数的本地化字符串不能包含对“ {0}” ..的引用。\r\n            \r\n","Cannot specify the Out attribute on a ref parameter without also specifying the In attribute.":"如果不指定in in属性，就无法在REF参数上指定OUT属性。\r\n","\r\n              Looks up a localized string similar to Did you mean to use the default switch label (`default:`) rather than `case default:`? If you really mean to use the default literal, consider `case (default):` or another literal (`case 0:` or `case null:`) as appropriate..\r\n            ":"\r\n              查找类似于使用默认开关标签的本地化字符串（'默认值：`）而不是`case默认值：`？如果您真的是要使用默认字体，请考虑``case of case of case（默认值）：``或其他字面词（case 0：``或``case null：```case null：`'''）。\r\n            \r\n","The symbol information for the topmost node of the expression.":"表达式最高节点的符号信息。\r\n","ExpressionSyntax node representing the object that the member belongs to.":"表示成员属于的对象的eNSTRANIONYNTAX节点。\r\n","A ref or out value must be an assignable variable":"参考价值或输出值必须是可分配的变量\r\n","The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'.":"类型'{3}'在通用类型或方法'{0}'中不能用作类型参数'{2}'。无效的类型'{3}'不满足'{1}'的约束。\r\n","\r\n              Looks up a localized string similar to Chaining speculative semantic model is not supported. You should create a speculative model from the non-speculative ParentModel..\r\n            ":"\r\n              不支持查找类似于链式投机语义模型的本地化字符串。您应该从非规范源模型中创建一个投机模型。\r\n            \r\n","\r\n              Looks up a localized string similar to Control cannot leave the body of a finally clause.\r\n            ":"\r\n              查找类似于控件的本地化字符串不能离开最后子句的主体。\r\n            \r\n","SyntaxToken representing open bracket.":"Syntaxtoken代表开放式括号。\r\n","\r\n              Looks up a localized string similar to Cannot return '{0}' by reference because it is a '{1}'.\r\n            ":"\r\n              查找类似于不能返回'{0}'的本地化字符串，因为它是'{1}'。\r\n            \r\n","Invalid instrumentation kind: {0}":"无效仪器类型：{0}\r\n","'{0}': an abstract type cannot be sealed or static":"'{0}'：无法密封或静态的抽象类型\r\n","\r\n            Parse a CompilationUnitSyntax using the grammar rule for an entire compilation unit (file). To produce a\r\n            SyntaxTree instance, use CSharpSyntaxTree.ParseText instead.\r\n            ":"\r\n            使用整个汇编单元（文件）的语法规则解析汇编单数。产生一个\r\n            SyntaxTree实例，改用CSHARPSYNTAXTREE.PARSETEXT。\r\n            \r\n","\r\n            Should this be used for tuple fields as well?\r\n            ":"\r\n            这也应该用于元组田吗？\r\n            \r\n","Metadata file '{0}' could not be found":"找不到元数据文件'{0}'\r\n","\r\n            Parse a TypeNameSyntax node using the grammar rule for type names.\r\n            ":"\r\n            使用语法规则对类型名称进行解析。\r\n            \r\n","True if target location is considered read from.":"如果考虑到目标位置，则正确。\r\n","Creates a new CrefParameterListSyntax instance.":"创建一个新的crefparameterListsyntax实例。\r\n","\r\n              Looks up a localized string similar to Inconsistent accessibility: parameter type '{1}' is less accessible than method '{0}'.\r\n            ":"\r\n              查找类似于不一致的可访问性的本地化字符串：参数类型'{1}'比方法'{0}'易于访问。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' does not contain a definition for '{1}' and no extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive for '{2}'?).\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串不包含'{1}''的定义，并且没有扩展方法'{1}'接受类型'{0}'的第一个参数（您是否丢失了一个用于“ {2}'？）的指令。\r\n            \r\n","Class or struct constraint syntax.":"类或结构约束语法。\r\n","Called when the visitor visits a CheckedStatementSyntax node.":"当访问者访问checkedstatementsyntax节点时，请致电。\r\n","int[,]":"int [，]\r\n",".  Each frame is given a single field for each captured\r\n             variable in the corresponding scope.  These are maintained in ":"。为每个捕获的每个帧都有一个字段\r\n             相应范围中的变量。这些被维持在\r\n","\r\n            True if the method itself is excluded from code covarage instrumentation.\r\n            True for source methods marked with ":"\r\n            如果将方法本身排除在CORVARAGE仪器中，则为true。\r\n            对于标记的源方法是正确的\r\n","\r\n            A tuple of the found ":"\r\n            发现的元组\r\n","Type or namespace definition, or end-of-file expected":"类型或名称空间定义或文件终止预期\r\n","\r\n            Simple helper method to get the object creation expression for this data. This should only be used in\r\n            scenarios where the data in ":"\r\n            简单的助手方法获取此数据的对象创建表达式。这仅应在\r\n            方案数据中的数据\r\n","\r\n              Looks up a localized string similar to Type of conditional expression cannot be determined because '{0}' and '{1}' implicitly convert to one another.\r\n            ":"\r\n              查找类似于条件表达式类型的本地化字符串无法确定，因为'{0}'和'{1}'隐式转换彼此。\r\n            \r\n","Indexers must have at least one parameter":"索引器必须至少具有一个参数\r\n","An array access may not have a named argument specifier":"数组访问可能没有命名参数指定符\r\n","\r\n            In ":"\r\n            在\r\n","\r\n              Looks up a localized string similar to Cannot restore warning 'CS{0}' because it was disabled globally.\r\n            ":"\r\n              查找类似于无法还原警告“ CS {0}”的本地化字符串，因为它在全球范围内被禁用。\r\n            \r\n","CLS compliance checking will not be performed on '{0}' because it is not visible from outside this assembly":"CLS合规性检查将不会在“ {0}”上进行\r\n"," The index of the next wrapped method to be used ":" 要使用的下一个包装方法的索引\r\n","Called when the visitor visits a CrefBracketedParameterListSyntax node.":"当访客访问crefbracketedparameterListsyntax节点时，请致电。\r\n","\r\n              Looks up a localized string similar to Cannot implicitly convert type '{0}' to '{1}'.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法隐式将类型'{0}'转换为'{1}'。\r\n            \r\n","\r\n              Looks up a localized string similar to Unexpected use of an aliased name.\r\n            ":"\r\n              查找类似于别名名称的意外使用的本地化字符串。\r\n            \r\n","\r\n            The parent namespace. There is always one, Global namespace contains all\r\n            top level namespaces. \r\n            ":"\r\n            父命名空间。总是有一个，全局名称空间包含全部\r\n            顶级名称空间。\r\n            \r\n"," with no known type\r\n            ":" 没有已知类型\r\n            \r\n","The syntax node of the labeled statement.":"标记语句的语法节点。\r\n"," when asking multiple questions about a syntax tree, because\r\n            information from the first question may be reused. This also means that holding onto an\r\n            instance of SemanticModel for a long time may keep a significant amount of memory from being\r\n            garbage collected.\r\n            ":" 在问多个语法树问题时，因为\r\n            第一个问题的信息可能会重复使用。这也意味着坚持\r\n            长时间的semanticmodel实例可能会阻止大量内存\r\n            收集了垃圾。\r\n            \r\n","A foreach loop must declare its iteration variables.":"foreach循环必须声明其迭代变量。\r\n","\r\n            Return true if the type contains any function pointer types.\r\n            ":"\r\n            如果类型包含任何功能指针类型，则返回true。\r\n            \r\n","a == d":"a == d\r\n","Inherited interface '{1}' causes a cycle in the interface hierarchy of '{0}'":"继承的界面'{1}'导致'{0}'的接口层次结构中的周期\r\n","\r\n              Looks up a localized string similar to Using a field of a marshal-by-reference class as a ref or out value or taking its address may cause a runtime exception.\r\n            ":"\r\n              查找类似于使用逐元类别的字段作为ref或out值的本地化字符串，或者取出其地址可能会导致运行时例外。\r\n            \r\n","\r\n            Given anonymous type descriptor provided constructs an anonymous type symbol.\r\n            ":"\r\n            给定的匿名类型描述符提供的构造是匿名类型的符号。\r\n            \r\n","\r\n            Pointer conversions are described in section 18.4 of the C# language specification.\r\n            \r\n            Returns true if the conversion is a conversion \r\n             a) from a pointer type to void*, \r\n             b) from a pointer type to another pointer type (other than void*),\r\n             c) from the null literal to a pointer type,\r\n             d) from an integral numeric type to a pointer type,\r\n             e) from a pointer type to an integral numeric type, or\r\n             d) from a function pointer type to a function pointer type.\r\n            \r\n            Does not return true for user-defined conversions to/from pointer types.\r\n            Does not return true for conversions between pointer types and IntPtr/UIntPtr.\r\n            ":"\r\n            C＃语言规范第18.4节中描述了指针转换。\r\n            \r\n            如果转换为转换，则返回true\r\n             a）从指针类型到void*，\r\n             b）从指针类型到另一种指针类型（void*除外），\r\n             c）从零字面到指针类型，\r\n             d）从积分数字类型到指针类型，\r\n             e）从指针类型到积分数字类型，或\r\n             d）从功能指针类型到功能指针类型。\r\n            \r\n            对于用户定义的转换，请勿返回到指针类型的转换。\r\n            对于指针类型和INTPTR/UINTPTR之间的转换，不返回true。\r\n            \r\n","\r\n            If C# picks a different implementation than the CLR (see IsPossibleImplementationUnderClrRules), then we might\r\n            still be okay, but dynamic dispatch might result in C#'s choice getting called anyway.\r\n            ":"\r\n            如果C＃选择了与CLR不同的实现（请参见IspossibleImplementationunderclrules），那么我们可能会\r\n            仍然可以，但是动态调度可能会导致C＃的选择无论如何都会被调用。\r\n            \r\n","The text of the bracketed parameter list.":"包围参数列表的文本。\r\n","\r\n            Insert one or more tokens in the list at the specified index.\r\n            ":"\r\n            在指定索引的列表中插入一个或多个令牌。\r\n            \r\n","Member '{1}' overrides '{0}'. There are multiple override candidates at run-time. It is implementation dependent which method will be called. Please use a newer runtime.":"成员'{1}'覆盖'{0}'。运行时间有多个替代候选人。这是实现依赖性的，将调用哪种方法。请使用较新的运行时间。\r\n","\r\n              Looks up a localized string similar to Field-targeted attributes on auto-properties are not supported in language version {0}. Please use language version {1} or greater..\r\n            ":"\r\n              在语言版本{0}中不支持类似于自动properties的字段定位属性的本地化字符串。请使用语言版本{1}或更大。\r\n            \r\n"," is non-null, report diagnostics within this span in the ":" 在此跨度内的诊断是非无效的\r\n","\r\n              Looks up a localized string similar to Cannot modify members of '{0}' because it is a '{1}'.\r\n            ":"\r\n              查找类似于“ {0}”成员的本地化字符串，因为它是'{1}'。\r\n            \r\n","\r\n            Used to determine whether it would be appropriate to use the binder for the statement (if any).\r\n            Not used to determine whether the position is syntactically within the statement.\r\n            ":"\r\n            用于确定将活页夹用于语句（如果有）是否合适。\r\n            不用于确定该位置是否在语句中句法。\r\n            \r\n","Literal of type double cannot be implicitly converted to type '{1}'; use an '{0}' suffix to create a literal of this type":"类型double的文字不能隐式转换为'{1}';使用'{0}'后缀创建这种类型的文字\r\n","automatically implemented properties":"自动实现属性\r\n","\r\n            Expression is the operand of an address-of operation (&).\r\n            ":"\r\n            表达是地址操作（＆）的操作数。\r\n            \r\n","\r\n            This is an implementation of a special symbol comparer, which is supposed to be used for sorting\r\n            original definition symbols (explicitly or implicitly declared in source within the same compilation)\r\n            in lexical order of their declarations. It will not work on anything that uses non-source locations.\r\n            ":"\r\n            这是特殊符号比较的实现，该比较应该用于排序\r\n            原始定义符号（在同一汇编中明确或隐式声明）\r\n            按照他们声明的词汇顺序。它不会在使用非源地点的任何东西上使用。\r\n            \r\n","\r\n            A value set implementation for ":"\r\n            一个值集的实现\r\n","\r\n              Looks up a localized string similar to '{0}': event property must have both add and remove accessors.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串：事件属性必须同时具有添加和删除访问者。\r\n            \r\n","Called when the visitor visits a AttributeListSyntax node.":"当访问者访问属性元素nondax节点时调用。\r\n","\r\n            Returns the number of nestings required to represent numElements as nested ValueTuples.\r\n            For example, for 8 elements, you need 2 ValueTuples and the remainder (ie the size of the last nested ValueTuple) is 1.\r\n            ":"\r\n            返回表示数字为嵌套估值所需的嵌套数量。\r\n            例如，对于8个元素，您需要2个估值，其余的（即最后的嵌套估值）为1。\r\n            \r\n","True to compare without regard to custom modifiers, false by default.":"True 比较不考虑自定义修饰符，默认为 false。\r\n","Creates a new JoinIntoClauseSyntax instance.":"创建一个新的JoinIntoClausesyntax实例。\r\n","The CallerMemberNameAttribute may only be applied to parameters with default values":"Callermemberneateattribute只能应用于具有默认值的参数\r\n","\r\n            For better error recovery 'static =>' is also considered a possible lambda expression.\r\n            ":"\r\n            为了获得更好的错误恢复，“静态=>”也被认为是可能的lambda表达式。\r\n            \r\n","\r\n            C# 4.0 §10.6: The name, the type parameter list and the formal parameter list of a method define\r\n            the signature (§3.6) of the method. Specifically, the signature of a method consists of its\r\n            name, the number of type parameters and the number, modifiers, and types of its formal\r\n            parameters. For these purposes, any type parameter of the method that occurs in the type of\r\n            a formal parameter is identified not by its name, but by its ordinal position in the type\r\n            argument list of the method. The return type is not part of a method's signature, nor are\r\n            the names of the type parameters or the formal parameters.\r\n            ":"\r\n            C＃4.0§10.6：名称，类型参数列表和方法定义的形式参数列表\r\n            该方法的签名（§3.6）。具体而言，一种方法的签名包括\r\n            名称，类型参数的数量以及其正式的数字，修饰符和类型\r\n            参数。出于这些目的，在类型中发生的任何类型参数\r\n            正式参数不是用其名称来标识的\r\n            该方法的参数列表。返回类型不是方法签名的一部分，也不是\r\n            类型参数或形式参数的名称。\r\n            \r\n","Creates a new XmlCDataSectionSyntax instance.":"创建一个新的xmlcDatasectionsyntax实例。\r\n","No overload for method '{0}' takes {1} arguments":"方法'{0}'take {1}参数没有超载\r\n","\r\n            Should the name returned by Name property be mangled with [`arity] suffix in order to get metadata name.\r\n            Must return False for a type with Arity == 0.\r\n            ":"\r\n            是否应将属性返回的名称与[Arity]后缀混合在一起，以获取元数据名称。\r\n            必须返回false fors a arity == 0的类型。\r\n            \r\n","The alias symbol that was declared.":"被宣布的别名符号。\r\n","\r\n              Looks up a localized string similar to Inconsistent accessibility: property type '{1}' is less accessible than property '{0}'.\r\n            ":"\r\n              查找类似于不一致的可访问性的本地化字符串：属性类型'{1}'比属性'{0}'易于访问。\r\n            \r\n","\r\n            AssemblySymbol to represent missing, for whatever reason, CorLibrary.\r\n            The symbol is created by ReferenceManager on as needed basis and is shared by all compilations\r\n            with missing CorLibraries.\r\n            ":"\r\n            汇编符号代表缺失的，无论出于何种原因）。\r\n            该符号由ReferenceManager根据需要创建，并由所有汇编共享\r\n            缺少圆锥形。\r\n            \r\n","\r\n            C# language version 5\r\n            ":"\r\n            C＃语言版本5\r\n            \r\n","Name of looked up member.":"查找成员的名字。\r\n","\r\n            Produce the states in topological order.\r\n            ":"\r\n            以拓扑顺序产生状态。\r\n            \r\n","\r\n            Produce assignment of the input expression. This method is also responsible for assigning\r\n            variables for some pattern-matching temps that can be shared with user variables.\r\n            ":"\r\n            产生输入表达式的分配。此方法还负责分配\r\n            可以与用户变量共享的一些模式匹配温度的变量。\r\n            \r\n","\r\n            Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this \r\n            assembly is the Cor Library\r\n            ":"\r\n            查找成员在此组件中以预定义的Corlib类型声明。只有在此时有效\r\n            集会是Cor库\r\n            \r\n","Feature '{0}' is experimental and unsupported; use '/features:{1}' to enable.":"功能'{0}'是实验性且不受支持的；使用'/功能：{1}'启用。\r\n","\r\n            Get a SemanticModel object that is associated with a cref syntax node that did not appear in\r\n            this source code. This can be used to get detailed semantic information about sub-parts\r\n            of a cref syntax that did not appear in source code. \r\n            ":"\r\n            获取与未出现在\r\n            此源代码。这可以用来获取有关子部分的详细语义信息\r\n            未出现在源代码中的CREF语法。\r\n            \r\n","How warning diagnostics should be reported":"应如何报告警告诊断\r\n","The owning source symbol.":"拥有的源符号。\r\n","Called when the visitor visits a InterpolationFormatClauseSyntax node.":"访问者访问InterPolationFormatClausesyntax节点时调用。\r\n","\r\n             Variables local to current frame do not need temps when re-read multiple times\r\n             as long as there is no code that may write to locals in between accesses and they\r\n             are not captured.\r\n             \r\n             Example:\r\n                    l += goo(ref l);\r\n             \r\n             even though l is a local, we must access it via a temp since \"goo(ref l)\" may change it\r\n             on between accesses.\r\n            \r\n             Note: In `this.x++`, `this` cannot change between reads. But in `(this, ...) == (..., this.Mutate())` it can.\r\n             ":"\r\n             当重新阅读多次阅读时，本地到当前帧本地帧不需要温度\r\n             只要没有代码可以在访问之间写给当地人，他们\r\n             没有被捕获。\r\n             \r\n             例子：\r\n                    l +=粘胶（ref l）;\r\n             \r\n             即使L是本地人，我们也必须通过温度访问它，因为“ Goo（Ref L）可能会改变它\r\n             在两次访问之间。\r\n            \r\n             注意：在`this.x ++'中，```'''之间无法更改读取。但是在`（this，...）==（...，this.mutate（））`它可以。\r\n             \r\n","A syntax node that represents a parsed expression. This expression should not be\r\n            present in the syntax tree associated with this object.":"表示解析表达式的语法节点。这个表达不应该是\r\n            存在与此对象关联的语法树中。\r\n","exception filter":"异常过滤器\r\n","\r\n            The order of values here is used in the computation of ":"\r\n            此处的值顺序用于计算\r\n","\r\n            Return true if the accessor accessibility is more restrictive\r\n            than the property accessibility, otherwise false.\r\n            ":"\r\n            如果登录器可访问性更具限制性，则返回true\r\n            比属性可访问性，否则是错误的。\r\n            \r\n","\r\n            This method exists to mimic the behavior of GetOwnOrInheritedGetMethod, but it\r\n            should only ever look at the overridden event in error scenarios.\r\n            ":"\r\n            这种方法的存在是为了模仿getownorinheritedgetMethod的行为，但是\r\n            只能在错误方案中查看覆盖事件。\r\n            \r\n","\r\n            Given a syntax node of tuple expression, get the tuple type symbol.\r\n            ":"\r\n            给定元组表达式的语法节点，获取元组类型符号。\r\n            \r\n","\r\n            Similar to SymbolExtensions.GetMemberTypeParameters, but returns empty for unsupported symbols.\r\n            ":"\r\n            类似于symbolextensions.getMemberTypeparameters，但返回空白的符号。\r\n            \r\n","\r\n            The member whose parameter types and params modifiers were considered during overload resolution.\r\n            ":"\r\n            在过载分辨率期间，考虑了其参数类型和参数修饰符的成员。\r\n            \r\n","In order for '{0}' to be applicable as a short circuit operator, its declaring type '{1}' must define operator true and operator false":"为了使'{0}'适用于短路运算符，其声明类型'{1}'必须定义操作员true and Operator false\r\n","Type is not CLS-compliant":"类型不符合CLS\r\n","\r\n            Create a duplicate of this compilation with different symbol instances.\r\n            ":"\r\n            使用不同的符号实例创建此汇编的副本。\r\n            \r\n","Unnecessary using directive.":"不必要使用指令。\r\n","The CallerLineNumberAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments":"CallerlineNumberattribute将无效，因为它适用于不允许可选参数的上下文中使用的成员\r\n","Argument type is not CLS-compliant":"参数类型不符合CLS\r\n","'{0}' overrides Object.Equals(object o) but does not override Object.GetHashCode()":"'{0}'覆盖object.equals（object o），但不覆盖object.gethashcode（）\r\n","\r\n            Does this symbol represent a missing module.\r\n            ":"\r\n            此符号是否代表缺失的模块。\r\n            \r\n","Whether to permit following paths that test for null.":"是否允许以下​​测试零的路径。\r\n","\r\n            Gets the containing expression that is actually a language expression and not just typed\r\n            as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side\r\n            of qualified names and member access expressions are not language expressions, yet the\r\n            containing qualified names or member access expressions are indeed expressions.\r\n            ":"\r\n            获取实际上是一种语言表达的表达式，而不仅仅是键入\r\n            为了方便起见，作为表达方式。例如，右侧的nameyntax节点\r\n            合格的名称和成员访问表达式不是语言表达式\r\n            包含合格的名称或成员访问表达式确实是表达式。\r\n            \r\n","\r\n            In emit phase every time a created anonymous type is referenced we try to store the lowest \r\n            location of the template. It will be used for ordering templates and assigning emitted type names.\r\n            ":"\r\n            每次引用创建的匿名类型时，在发射阶段中，我们都会尝试存储最低\r\n            模板的位置。它将用于订购模板和分配发射的类型名称。\r\n            \r\n","\r\n            Initialize the state machine class.\r\n            ":"\r\n            初始化状态计算机类。\r\n            \r\n","\r\n            C# language version 4\r\n            ":"\r\n            C＃语言版本4\r\n            \r\n","\r\n            Compiles a list of all labels that are targeted by gotos within a\r\n            node, but are not declared within the node.\r\n            ":"\r\n            编译所有由GoTOS针对的标签的列表\r\n            节点，但没有在节点内声明。\r\n            \r\n","\r\n              Looks up a localized string similar to Extension method must be defined in a non-generic static class.\r\n            ":"\r\n              查找类似于扩展方法的本地化字符串必须在非类别静态类中定义。\r\n            \r\n","Cannot infer the type of implicitly-typed out variable '{0}'.":"无法推断隐式型变量'{0}'的类型。\r\n",". Used to make a ":"。用来做一个\r\n","\r\n            Gets the \"GetEnumerator\" method.\r\n            ":"\r\n            获取“ getEnumerer”方法。\r\n            \r\n","\r\n            The default language version, which is the latest major supported version.\r\n            ":"\r\n            默认语言版本，这是最新的主要支持版本。\r\n            \r\n","An expression tree lambda may not contain a coalescing operator with a null or default literal left-hand side":"表达树lambda可能不包含具有无效或默认字面左侧的合并操作员\r\n","Called when the visitor visits a AliasQualifiedNameSyntax node.":"当访问者访问AliasqualifiedNamesyntax节点时，请致电。\r\n","\r\n            True if this walker was created using an initial state.\r\n            ":"\r\n            是的，如果使用初始状态创建此步行者。\r\n            \r\n","\r\n              Looks up a localized string similar to Struct member '{0}' of type '{1}' causes a cycle in the struct layout.\r\n            ":"\r\n              查找类似于struct成员'{0}'的局部字符串'{1}'在struct布局中导致一个周期。\r\n            \r\n"," with no known type, and the given bound children.\r\n            ":" 没有已知类型，也没有给定的孩子。\r\n            \r\n","\r\n            Gets the corresponding member for a symbol from initial binding to match an updated receiver type in NullableWalker.\r\n            For instance, this will map from List<string~>.Add(string~) to List<string?>.Add(string?) in the following example:\r\n            ":"\r\n            从初始绑定中获取符号的相应成员，以匹配Nullable Walker中更新的接收器类型。\r\n            例如，这将在以下示例中从列表<string 〜> .add（string〜）映射到列表<string？>。add（string？）：\r\n            \r\n","'{0}' is a {1} but is used like a {2}":"'{0}'是{1}，但像{2}一样使用\r\n","|=":"| =\r\n",", this class performs a quick \r\n            traversal of the symbol table and performs processing of synthesized symbols if necessary\r\n            ":"，这堂课很快\r\n            符号表的遍历，并在必要时执行综合符号的处理\r\n            \r\n","\r\n            This is specifically a private helper function (rather than a public property or extension method)\r\n            because applying this predicate to a non-method member doesn't have a clear meaning.  The goal was\r\n            simply to avoid repeating ad-hoc code in a group of related collections.\r\n            ":"\r\n            这是特别是私人辅助功能（而不是公共财产或扩展方法）\r\n            因为将此谓词应用于非方法成员没有明确的含义。目标是\r\n            只是为了避免在一组相关集合中重复临时代码。\r\n            \r\n","Gets the semicolon token.":"获取分号令牌。\r\n","\r\n             Bind the constructor initializer in the context of the specified location and get semantic information\r\n             about symbols. This method is used to get semantic information about a constructor\r\n             initializer that did not actually appear in the source code.\r\n            \r\n             NOTE: This will only work in locations where there is already a constructor initializer.\r\n             ":"\r\n             在指定位置的上下文中绑定构造函数初始化器并获取语义信息\r\n             关于符号。此方法用于获取有关构造函数的语义信息\r\n             实际上并未出现在源代码中的初始化程序。\r\n            \r\n             注意：这只能在已经有构造函数初始化器的位置工作。\r\n             \r\n","\r\n            Spec section 7.9: if the left operand is int or uint, mask the right operand with 0x1F;\r\n            if the left operand is long or ulong, mask the right operand with 0x3F.\r\n            ":"\r\n            规格第7.9节：如果左操作数为int或uint，请用0x1f掩盖右操作数；\r\n            如果左操作数长或乌隆，请用0x3F掩盖右操作数。\r\n            \r\n","Creates a new ConditionalExpressionSyntax instance.":"创建一个新的条件alexpressionsyntax实例。\r\n"," to substitute the correct slot for a ":" 用正确的插槽代替\r\n",". It means that if the optional parameter is annotated with ":"。这意味着如果可选参数注释\r\n","Failed to emit module '{0}': {1}":"无法发射模块'{0}'：{1}\r\n","\r\n            Don't call this one directly - call one of the helpers.\r\n            ":"\r\n            不要直接打电话给这个-打电话给一个助手。\r\n            \r\n","\r\n              Looks up a localized string similar to Keyword, identifier, or string expected after verbatim specifier: @.\r\n            ":"\r\n              查找类似于关键字，标识符或逐字指示符后预期的局部字符串： @。\r\n            \r\n"," effective for this symbol (type or DllImport method).\r\n            Nothing if ":" 对于此符号有效（类型或dllimport方法）。\r\n            没有\r\n","Assembly reference '{0}' is invalid and cannot be resolved":"汇编引用'{0}'是无效的，无法解决\r\n","The expression to classify. This expression does not need to be\r\n            present in the syntax tree associated with this object.":"分类的表达式。这个表达不需要\r\n            存在与此对象关联的语法树中。\r\n","\r\n            A single field to hold optional auxiliary data.\r\n            In many scenarios it is possible to avoid allocating this, thus saving total space in ":"\r\n            单个字段以容纳可选的辅助数据。\r\n            在许多情况下，有可能避免分配此问题，从而节省了总空间\r\n","\r\n            All of the labels seen so far in this forward scan of the body\r\n            ":"到目前为止在身体的前扫描中看到的所有标签\r\n            \r\n","\r\n            Look up a well known SyntaxToken for a given XML element tag or attribute.\r\n            This is a performance optimization to avoid creating duplicate tokens for the same content.\r\n            ":"\r\n            为给定的XML元素标签或属性查找知名的Santaxtoken。\r\n            这是一种性能优化，以避免为相同内容创建重复令牌。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot assign to a member of {0} '{1}' because it is a readonly variable.\r\n            ":"\r\n              查找类似于{0}'{1}'成员的本地化字符串，因为它是一个可读变量。\r\n            \r\n","Gets the > token.":"获取>令牌。\r\n"," or the method it\r\n            overrides, but in a more derived type?\r\n            ":" 或方法\r\n            覆盖，但以更派生的类型？\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': the enumerator value is too large to fit in its type.\r\n            ":"\r\n              查找类似于“ {0}”的局部字符串：枚举器值太大而无法适合其类型。\r\n            \r\n","A syntax node that represents a parsed constructor initializer. This syntax node\r\n            need not and typically does not appear in the source code referred to SemanticModel instance.":"代表解析的构造函数初始化器的语法节点。此语法节点\r\n            不需要，通常不会出现在引用SemanticModel实例的源代码中。\r\n","Class which represents the syntax node for TypeOf expression.":"代表用于typeof表达式的语法节点的类。\r\n","Creates a new NameEqualsSyntax instance.":"创建一个新的nameequalssyntax实例。\r\n","Error writing to XML documentation file: {0}":"错误写入XML文档文件：{0}\r\n","\r\n            Containing assembly.\r\n            ":"\r\n            包含组件。\r\n            \r\n","'{0}' does not contain a definition for '{1}' and no extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive for '{2}'?)":"'{0}'不包含'{1}'的定义，并且可以找到类型'{0}'的第一个参数（您是否缺少使用'{2的指令） }'？）\r\n","ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.":"代表参数列表作为对象创建表达式的一部分所传递的参数列表。\r\n","Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.":"提供了代表简单名称语法节点的类的基类。这是一个抽象类。\r\n","The given expression cannot be used in a fixed statement":"给定的表达式不能在固定语句中使用\r\n","\r\n            Frees a temp.\r\n            ":"\r\n            释放一个临时。\r\n            \r\n","The result of the expression is always the same since a value of this type is never equal to 'null'":"表达的结果始终是相同的，因为这种类型的值永远不等于“ null”\r\n","Creates a new BinaryExpressionSyntax instance.":"创建一个新的binary expressionsyntax实例。\r\n","\r\n            Returns a string that represents the ":"\r\n            返回一个表示代表的字符串\r\n","\r\n              Looks up a localized string similar to Referenced assembly '{0}' has different culture setting of '{1}'..\r\n            ":"\r\n              查找类似于引用的汇编'{0}'的本地化字符串具有“ {1}” ..的不同文化设置。\r\n            \r\n","\r\n            Walk up the type hierarchy from ContainingType and list members that this\r\n            member either overrides (accessible members with the same signature, if this\r\n            member is declared \"override\") or hides (accessible members with the same name\r\n            but different kinds, plus members that would be in the overrides list if\r\n            this member were not declared \"override\").\r\n            \r\n            Members in the overridden list may be non-virtual or may have different\r\n            accessibilities, types, accessors, etc.  They are really candidates to be\r\n            overridden.\r\n            \r\n            Members in the hidden list are definitely hidden.\r\n            \r\n            Members in the runtime overridden list are indistinguishable from the members\r\n            in the overridden list from the point of view of the runtime (see\r\n            FindOtherOverriddenMethodsInContainingType for details).\r\n            ":"从包含类型的类型层次结构上沿着列表成员列出这一类型层次结构。\r\n            成员要么覆盖（如果此，则具有相同签名的可访问成员\r\n            会员被声明为“覆盖”）或皮肤（具有相同名称的可访问成员\r\n            但是不同的种类，加上成员在覆盖列表中的成员\r\n            该成员没有被宣布为“替代”）。\r\n            \r\n            覆盖列表中的成员可能是非虚拟的，或者可能有不同的\r\n            访问性，类型，访问者等。它们确实是候选人\r\n            覆盖。\r\n            \r\n            隐藏列表中的成员绝对是隐藏的。\r\n            \r\n            运行时覆盖列表中的成员与成员没有区别\r\n            从运行时的角度来看，在覆盖列表中（请参阅\r\n            有关详细信息，请找到hotheroverridenmethodsincontaindingtype）。\r\n            \r\n","Typed reference expression.":"键入的参考表达式。\r\n","\r\n              Looks up a localized string similar to A partial method may not explicitly implement an interface method.\r\n            ":"\r\n              查找类似于部分方法的本地化字符串可能无法明确实现接口方法。\r\n            \r\n","\r\n              Looks up a localized string similar to Allocated instance of {0} is not disposed along all exception paths.  Call System.IDisposable.Dispose() before all references to it are out of scope..\r\n            ":"\r\n              查找类似于{0}的分配实例的本地化字符串，并未沿所有异常路径处置。在所有引用均超出范围之前，请致电System.Idisposable.dispose（）。\r\n            \r\n","Creates a new AccessorDeclarationSyntax instance.":"创建一个新的accessOdeClarationSyntax实例。\r\n","ParameterSyntax node representing the parameter of the lambda expression.":"代表lambda表达式参数的参数字母节点。\r\n","Cannot bind delegate to '{0}' because it is a member of 'System.Nullable<T>'":"无法将委托人绑定到'{0}'，因为它是'system.nullable <t>'的成员\r\n","\r\n              Looks up a localized string similar to An expression tree lambda may not contain a dictionary initializer..\r\n            ":"\r\n              查找类似于表达树lambda的本地化字符串可能不包含字典初始化器。\r\n            \r\n","Bound attributes.":"绑定属性。\r\n","\r\n              Looks up a localized string similar to Type defines operator == or operator != but does not override Object.GetHashCode().\r\n            ":"\r\n              查找类似于类型的局部字符串，以定义运算符==或operator！= =但不覆盖object.gethashcode（）。\r\n            \r\n"," that return a delegate.\r\n            If it is an extension method, it is returned in reduced form.\r\n            ":" 返回代表。\r\n            如果是扩展方法，则以还原的形式返回。\r\n            \r\n","\r\n            Map from variables that had their addresses taken, to the location of the first corresponding\r\n            address-of expression.\r\n            ":"\r\n            来自带有地址的变量的地图，到第一个相应的位置\r\n            地址表达。\r\n            \r\n","\r\n            Accumulates side-effects that come before the next conjunct.\r\n            ":"\r\n            积累了下一个结合之前发生的副作用。\r\n            \r\n","XML comment has a duplicate param tag":"XML评论具有重复的参数标签\r\n","true if the Unicode character is a decimal digit.":"如果Unicode字符是十进制数字，则为正确。\r\n","The type '{2}' must be a reference type in order to use it as parameter '{1}' in the generic type or method '{0}'":"类型'{2}'必须是参考类型\r\n","\r\n             From ExpressionBinder::EnsureQMarkTypesCompatible:\r\n             \r\n             The v2.0 specification states that the types of the second and third operands T and S of a ternary operator\r\n             must be TT and TS such that either (a) TT==TS, or (b), TT->TS or TS->TT but not both.\r\n            \r\n             Unfortunately that is not what we implemented in v2.0.  Instead, we implemented\r\n             that either (a) TT=TS or (b) T->TS or S->TT but not both.  That is, we looked at the\r\n             convertibility of the expressions, not the types.\r\n            \r\n            \r\n             Changing that to the algorithm in the standard would be a breaking change.\r\n            \r\n             b ? (Func<int>)(delegate(){return 1;}) : (delegate(){return 2;})\r\n            \r\n             and\r\n            \r\n             b ? 0 : myenum\r\n            \r\n             would suddenly stop working.  (The first because o2 has no type, the second because 0 goes to\r\n             any enum but enum doesn't go to int.)\r\n            \r\n             It gets worse.  We would like the 3.0 language features which require type inference to use\r\n             a consistent algorithm, and that furthermore, the algorithm be smart about choosing the best\r\n             of a set of types.  However, the language committee has decided that this algorithm will NOT\r\n             consume information about the convertibility of expressions. Rather, it will gather up all\r\n             the possible types and then pick the \"largest\" of them.\r\n            \r\n             To maintain backwards compatibility while still participating in the spirit of consistency,\r\n             we implement an algorithm here which picks the type based on expression convertibility, but\r\n             if there is a conflict, then it chooses the larger type rather than producing a type error.\r\n             This means that b?0:myshort will have type int rather than producing an error (because 0->short,\r\n             myshort->int).\r\n             ":"\r\n             来自ExpressionBinder::EnsureQMarkTypesCompatible:\r\n             \r\n             V2.0规范规定三元运算符的第二和第三操作数T和S的类型\r\n             必须是TT和TS，使得（a）TT==TS，或（b），TT->TS或TS->TT但不是两者兼而有之。\r\n            \r\n             不幸的是，这不是我们在v2.0中实现的。  相反，我们实现了\r\n             即（a）TT=TS或（b）T->TS或S->TT但不是两者兼而有之。  也就是说，我们看着\r\n             表达式的可转换性，而不是类型。\r\n            \r\n            \r\n             将其更改为标准中的算法将是一个重大变化。\r\n            \r\n             乙？ (Func<int>)(delegate(){return1;}):(delegate(){return2;})\r\n            \r\n             和\r\n            \r\n             乙？ 0：myenum\r\n            \r\n             会突然停止工作。  （第一个因为o2没有类型，第二个因为0去\r\n             任何枚举，但枚举不转到int。)\r\n            \r\n             情况变得更糟。  我们希望使用需要类型推断的3.0语言特性\r\n             一个一致的算法，而且，该算法是聪明的选择最好的\r\n             的一组类型。  然而，语言委员会已经决定，这个算法不会\r\n             使用有关表达式可转换性的信息。 相反，它将收集所有\r\n             可能的类型，然后选择其中的\"最大\"。\r\n            \r\n             在保持向后兼容性的同时，仍然本着一致性的精神,\r\n             我们在这里实现了一个算法，它根据表达式的可兑换性来选择类型，但是\r\n             如果存在冲突，那么它选择较大的类型，而不是产生类型错误。\r\n             这意味着b？0：myshort将具有int类型，而不是产生错误（因为0->short,\r\n             myshort->int）。\r\n             \r\n","\r\n              Looks up a localized string similar to Allocated instance is not disposed along all exception paths.\r\n            ":"\r\n              查找类似于分配实例的本地化字符串并未沿所有异常路径处置。\r\n            \r\n","\r\n              Looks up a localized string similar to Type parameter '{0}' has the same name as the containing type, or method.\r\n            ":"\r\n              查找类似于类型参数'{0}'的本地化字符串与包含类型或方法的名称相同。\r\n            \r\n","\r\n            The conversion (from Conversions.ClassifyConversionFromExpression for\r\n            instance) from which all BoundConversions in the group were created.\r\n            ":"\r\n            转换（从转换。\r\n            实例）创建了组中的所有界面。\r\n            \r\n","\r\n              Looks up a localized string similar to Named argument '{0}' cannot be specified multiple times.\r\n            ":"\r\n              查找类似于命名参数'{0}'的本地化字符串，不能多次指定。\r\n            \r\n","\r\n            Returns true if this local variable is declared in for-initializer\r\n            ":"\r\n            如果此局部变量在for Initializer中声明，则返回true\r\n            \r\n","\r\n              Looks up a localized string similar to Auto-implemented properties must have get accessors..\r\n            ":"\r\n              查找类似于自动实现属性的本地化字符串必须有访问者。\r\n            \r\n","\r\n            Given the full text of a multi-line style documentation comment, broken into lines, strip off\r\n            the comment punctuation (/**, */, etc) and add appropriate indentations.\r\n            ":"\r\n            鉴于多行样式文档注释的全文，分为线条，脱掉\r\n            评论标点符号（/**，*/等）并添加适当的凹痕。\r\n            \r\n","\r\n              Looks up a localized string similar to Type overrides Object.Equals(object o) but does not override Object.GetHashCode().\r\n            ":"\r\n              查找类似于Overdride Object的本地化字符串。Equals.equals（Object O），但不覆盖Object.gethashcode（）。\r\n            \r\n","Called when the visitor visits a DeclarationExpressionSyntax node.":"当访问者访问声明expressyntax节点时，请致电。\r\n","\r\n            Set the current state to one that indicates that it is unreachable.\r\n            ":"\r\n            将当前状态设置为表明其无法达到的一种状态。\r\n            \r\n","Gets the case keyword token.":"获取案例关键字令牌。\r\n","\r\n            Represents the results of overload resolution for a single member.\r\n            ":"\r\n            表示单个成员的过载分辨率的结果。\r\n            \r\n","\r\n            Usages of TestOptions.RegularNext and LanguageVersionFacts.CSharpNext\r\n            will be replaced with TestOptions.RegularN and LanguageVersion.CSharpN when language version N is introduced.\r\n            ":"\r\n            testoptions.regularnext和languageversionfacts.csharpnext\r\n            将被testOptions.regularn和LanguageVersion替换。CSHARPN引入语言n时。\r\n            \r\n","\r\n              Looks up a localized string similar to Assembly '{0}' with identity '{1}' uses '{2}' which has a higher version than referenced assembly '{3}' with identity '{4}'.\r\n            ":"\r\n              查找类似于sidembly'{0}'sidentity'{1}'use'{2}'的本地化字符串，其具有比引用的'{3}'具有sidentity'{4}'的版本更高的版本。\r\n            \r\n","Introducing a 'Finalize' method can interfere with destructor invocation":"引入“最终确定”方法可能会干扰destructor invocation\r\n","\r\n            Produce:\r\n            await /* disposeCall */;\r\n            ":"\r\n            生产：\r\n            等待 / * dispoSecall * /;\r\n            \r\n","\r\n              Looks up a localized string similar to stackalloc initializer.\r\n            ":"\r\n              查找类似于Stackalloc Initializer的本地化字符串。\r\n            \r\n","\r\n            Fix a TypeWithAnnotations based on Allow/DisallowNull annotations prior to a conversion or assignment.\r\n            Note this does not work for nullable value types, so an additional check with ":"\r\n            在转换或分配之前，基于允许/删除注释来修复基于允许/删除的注释。\r\n            请注意，这对无效的价值类型不起作用，因此请与\r\n","\r\n            Is the pattern in a state in which it is fully matched and there is no when clause?\r\n            ":"\r\n            是否完全匹配它的状态，并且在子句时没有？\r\n            \r\n","Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier or Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier to create identifier tokens.":"使用Microsoft.codeanalysis.csharp.syntaxfactory.Identifier或Microsoft.codeanalysis.csharp.syntaxfactory.verbatimidentifier创建标识符令牌。\r\n","\r\n            Indicates whether or not the method returns by reference\r\n            ":"\r\n            指示该方法是否通过参考返回\r\n            \r\n","Extract inferred name from a single deconstruction variable.":"提取从单个解构变量推断名称。\r\n","\r\n              Looks up a localized string similar to The event '{0}' is never used.\r\n            ":"\r\n              查找类似于事件“ {0}”的本地化字符串。\r\n            \r\n","\r\n            Declaration security information associated with this type, or null if there is none.\r\n            ":"\r\n            与此类型关联的声明安全信息，或者如果没有，则无效。\r\n            \r\n","\r\n            Additional information for rewriting an async-iterator.\r\n            ":"\r\n            用于重写异步属的其他信息。\r\n            \r\n","If variable.Kind is RangeVariable, its underlying lambda parameter. Else null.":"如果可变范围可范围，则其基础lambda参数。其他空。\r\n","\r\n              Looks up a localized string similar to Invalid reference alias option: '{0}=' -- missing filename.\r\n            ":"\r\n              查找类似于无效参考别名选项的本地化字符串：'{0} =' - 缺少文件名。\r\n            \r\n","\r\n              Looks up a localized string similar to The abstract {0} '{1}' cannot be marked virtual.\r\n            ":"\r\n              查找类似于摘要{0}'{1}'的本地化字符串，不能标记为虚拟。\r\n            \r\n","\r\n             Get a SemanticModel object that is associated with a constructor initializer that did not appear in\r\n             this source code. This can be used to get detailed semantic information about sub-parts\r\n             of a constructor initializer that did not appear in source code.\r\n            \r\n             NOTE: This will only work in locations where there is already a constructor initializer.\r\n             ":"\r\n             获取与未出现在\r\n             此源代码。这可以用来获取有关子部分的详细语义信息\r\n             未出现在源代码中的构造函数初始化器\r\n            \r\n             注意：这只能在已经有构造函数初始化器的位置工作。\r\n             \r\n","\r\n            return true if the type is constructed from System.Linq.Expressions.Expression`1\r\n            ":"\r\n            返回true如果类型是从system.linq.expressions.expression'1构造的类型\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot specify /main if building a module or library.\r\n            ":"\r\n              如果构建模块或库，则查找类似于类似的本地化字符串，无法指定 /主。\r\n            \r\n","XML comment has cref attribute that refers to a type parameter":"XML注释具有CREF属性，指的是类型参数\r\n","\r\n              Looks up a localized string similar to The pattern has already been handled by a previous arm of the switch expression..\r\n            ":"\r\n              查找类似于该模式的局部字符串已经由开关表达式的先前臂处理。\r\n            \r\n","\r\n            Returns the implementation part of a partial method definition, \r\n            or null if this is not a partial method or it is the definition part.\r\n            ":"\r\n            返回部分方法定义的实现部分，\r\n            或null如果这不是部分方法，也不是定义部分。\r\n            \r\n","\r\n            Learn something about the input from a test of a given expression against a given pattern.  The given\r\n            state is updated to note that any slots that are tested against `null` may be null.\r\n            ":"\r\n            从针对给定模式的给定表达式测试中了解有关输入的一些信息。  给定的\r\n            状态被更新以注意任何针对\"null\"测试的插槽都可能为null。\r\n            \r\n","Cannot convert null to type parameter '{0}' because it could be a non-nullable value type. Consider using 'default({0})' instead.":"无法将null转换为类型参数'{0}'，因为它可能是不可删除的值类型。考虑使用“默认值（{0}）”。\r\n","\r\n            Given a local symbol, gets an updated version of that local symbol adjusted for nullability analysis\r\n            if the analysis affects the local.\r\n            ":"\r\n            给定一个本地符号，获取已调整的该本地符号的更新版本，以进行无效分析\r\n            如果分析影响本地。\r\n            \r\n","Class which represents a simple pattern-matching expression using the \"is\" keyword.":"使用“ IS”关键字代表简单模式匹配表达式的类。\r\n",".GetValueOrDefault()":".getValueordEfault（）\r\n","\r\n              Looks up a localized string similar to Inconsistent accessibility: parameter type '{1}' is less accessible than delegate '{0}'.\r\n            ":"\r\n              查找类似于不一致的可访问性的本地化字符串：参数类型'{1}'的访问范围不如委托'{0}'。\r\n            \r\n","\r\n            Reports use-site diagnostics and dependencies for the specified symbol.\r\n            ":"\r\n            报告指定符号的用途诊断和依赖关系。\r\n            \r\n","More expression-bodied members":"更表达的成员\r\n","\r\n            Get the operators for this type by their metadata name\r\n            ":"\r\n            通过其元数据名称获取此类操作员\r\n            \r\n","\r\n              Looks up a localized string similar to Control cannot fall through from one case label ('{0}') to another.\r\n            ":"\r\n              查找类似于控件的本地化字符串不能从一个案例标签（'{0}'）到另一个情况。\r\n            \r\n","The type name '{0}' could not be found in the namespace '{1}'. This type has been forwarded to assembly '{2}' Consider adding a reference to that assembly.":"类型名称'{0}'在名称空间'{1}'中找不到。此类型已转发到汇编'{2}'考虑对该组件添加引用。\r\n","\r\n            Gives an indication of how successful the conversion was.\r\n            Viable - found a best built-in or user-defined conversion.\r\n            Empty - found no applicable built-in or user-defined conversions.\r\n            OverloadResolutionFailure - found applicable conversions, but no unique best.\r\n            ":"\r\n            指出转换的成功程度。\r\n            可行 - 找到最佳的内置或用户定义的转换。\r\n            空 - 发现没有适用的内置或用户定义的转换。\r\n            OrforloadResolutionFailure-发现了适用的转换，但没有唯一的最佳选择。\r\n            \r\n","The argument to the '{0}' attribute must be a valid identifier":"“ {0}”属性的参数必须是有效的标识符\r\n","'{0}' cannot implement interface member '{1}' in type '{2}' because it has an __arglist parameter":"'{0}'无法在类型'{2}'中实现接口成员'{1}'，因为它具有__arglist参数\r\n","\r\n            Returns true if there is any applied CompilationRelaxationsAttribute assembly attribute for this module.\r\n            ":"\r\n            如果有任何适用的compilationRelaxationsattribute汇编属性，则返回true。\r\n            \r\n","\r\n            Creates a trivia with kind WhitespaceTrivia containing the specified text. Elastic trivia are used to\r\n            denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.\r\n            ":"\r\n            用包含指定文本的善良的whitespacrivia创建琐事。弹性琐事习惯\r\n            表示未通过解析源文本产生的琐事，通常在格式期间没有保留。\r\n            \r\n","The contextual keyword 'var' may only appear within a local variable declaration or in script code":"上下文关键字“ var”可能仅在本地变量声明或脚本代码中出现\r\n","InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.":"InitializereXpressionsyntax表示隐式数组创建表达式的初始化器表达式。\r\n","\r\n            Returns a value set that includes any values that satisfy the given relation when compared to the given value.\r\n            ":"\r\n            返回一个值集，该值包含与给定值相比，所有满足给定关系的值。\r\n            \r\n","\r\n            folds two concat constants into one if possible\r\n            otherwise returns null.\r\n            It is generally always possible to concat constants, unless resulting string would be too large.\r\n            ":"\r\n            如果可能的话将两个concat常数折叠\r\n            否则返回null。\r\n            通常总是有可能进行concat stromstants，除非产生的字符串太大。\r\n            \r\n","\r\n            Executed at the start of visiting a local function body. The ":"\r\n            在访问本地功能主体开始时执行。这\r\n","\r\n              Looks up a localized string similar to Cannot initialize an implicitly-typed variable with an array initializer.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法用数组初始化器初始化隐式类型的变量。\r\n            \r\n","\r\n            Returns false because module can't be virtual.\r\n            ":"\r\n            返回false，因为模块不能虚拟。\r\n            \r\n","Unrecognized resource file format.":"无法识别的资源文件格式。\r\n","Type does not implement the collection pattern; members are ambiguous":"类型不会实现集合模式；成员是模棱两可的\r\n","\r\n              Looks up a localized string similar to The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match constraint type..\r\n            ":"\r\n              在通用类型或方法中查找类似于类型的本地化字符串。类型参数的无效性不匹配约束类型。\r\n            \r\n","\r\n            Defines sequence locals and record them so that they could be retained for the duration of the encompassing expression\r\n            Use this when taking a reference of the sequence, which can indirectly refer to any of its locals.\r\n            ":"\r\n            定义序列当地人并记录它们，以便可以在包含表达式的持续时间内保留它们\r\n            在参考序列时使用此功能，该序列可以间接地指其任何当地人。\r\n            \r\n","\r\n            True if this field is not serialized (metadata flag NotSerialized is set).\r\n            ":"\r\n            如果该字段未序列化（设置了元数据标志，则设置了该字段）。\r\n            \r\n","\r\n              Looks up a localized string similar to Duplicate '{0}' attribute in '{1}'.\r\n            ":"\r\n              查找类似于'{1}'中的重复'{0}'属性的本地化字符串。\r\n            \r\n","\r\n            May introduce a temp which it will return. (otherwise returns null)\r\n            ":"\r\n            可能会引入将返回的温度。 （否则返回null）\r\n            \r\n","\r\n            This is the entry point for foreach-loop lowering.  It delegates to\r\n              RewriteEnumeratorForEachStatement\r\n              RewriteSingleDimensionalArrayForEachStatement\r\n              RewriteMultiDimensionalArrayForEachStatement\r\n              CanRewriteForEachAsFor\r\n            ":"\r\n            这是用于降低座环的切入点。它委派\r\n              重写EnumeratorForeachStatement\r\n              重写少量驱动器宣传\r\n              重新构成二维的arrayForeachStatement\r\n              canrewriteforeachasfor\r\n            \r\n","\r\n            Tracks synthesized fields that are needed in a submission being compiled.\r\n            ":"\r\n            跟踪要编译的提交中所需的合成字段。\r\n            \r\n","Duplicate initialization of member '{0}'":"成员'{0}'的重复初始化\r\n","\r\n            Performs the same function as GetEnclosingBinder, but is known to take place within a\r\n            specified lambda.  Walks up the syntax hierarchy until a node with an associated binder\r\n            is found.\r\n            ":"\r\n            执行与getEnclosingBinder相同的功能，但已知发生在\r\n            指定的lambda。走上语法层次结构，直到带有关联粘合剂的节点\r\n            被发现。\r\n            \r\n","\r\n            If this symbol represents a tuple type, get the types of the tuple's elements.\r\n            ":"\r\n            如果此符号代表元组类型，请获取元组元素的类型。\r\n            \r\n","\r\n            A comparator that treats dynamic and object as \"the same\" types.\r\n            ":"将动态和对象视为“相同”类型的比较器。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': CLS-compliant interfaces must have only CLS-compliant members.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串：符合CLS的接口必须只有符合CLS的成员。\r\n            \r\n","Known array bounds.":"已知的数组界。\r\n","\r\n              Looks up a localized string similar to The CallerFilePathAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments.\r\n            ":"\r\n              查找类似于应用于参数'{0}'的CallerFilePathTribute类似的本地化字符串将没有效果，因为它适用于不允许可选参数的上下文中使用的成员。\r\n            \r\n","Called when the visitor visits a CompilationUnitSyntax node.":"访问者访问compilationunitsyntax节点时调用。\r\n","Class which represents the syntax node for argument.":"代表参数语法节点的类。\r\n","\r\n            Returns this instance if includeNullability is correct, and returns a\r\n            cached clone of this instance with distinct IncludeNullability otherwise.\r\n            ":"返回此实例，如果包含的可包含性正确，并返回\r\n            缓存该实例的克隆，否则具有不同的包含性。\r\n            \r\n","\r\n              Looks up a localized string similar to A query body must end with a select clause or a group clause.\r\n            ":"\r\n              查找类似于查询主体的本地化字符串必须以选择子句或组子句结束。\r\n            \r\n","\r\n            Returns a list of attributes to emit to CustomAttribute table.\r\n            The ":"\r\n            返回一个属性列表，以排放到自定义大限表。\r\n            这\r\n","Type containing the desired method symbol.":"包含所需方法符号的类型。\r\n","\r\n            Determines if the source expression of given type is convertible to the destination type via\r\n            any built-in or user-defined conversion.\r\n            \r\n            This helper is used in rare cases involving synthesized expressions where we know the type of an expression, but do not have the actual expression.\r\n            The reason for this helper (as opposed to ClassifyConversionFromType) is that conversions from expressions could be different\r\n            from conversions from type. For example expressions of dynamic type are implicitly convertable to any type, while dynamic type itself is not.\r\n            ":"\r\n            确定给定类型的源表达是否可通过\r\n            任何内置或用户定义的转换。\r\n            \r\n            该辅助器用于涉及合成表达式的极少数情况，我们知道表达的类型，但没有实际表达式。\r\n            该帮手的原因（而不是分类为fromType）是表达式转换可能不同\r\n            来自类型的转换。例如，动态类型的表达方式隐式转换为任何类型，而动态类型本身不是。\r\n            \r\n","Called when an \"attribute-dependent\" type such as 'dynamic', 'string?', etc. is not permitted.":"当不允许使用'动态'，'string？'等“属性依赖性”类型时称为“属性相关”类型。\r\n","while (true)":"而（true）\r\n","\r\n            Construct a body for a method containing a call to a single other method with the same signature (modulo name).\r\n            ":"\r\n            构建一个主体，用于包含与单个其他方法相同签名（模量名）的单个方法的方法。\r\n            \r\n","Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect":"源文件已超过PDB中可表示的16,707,565行的限制；调试信息将不正确\r\n","\r\n              Looks up a localized string similar to An expression tree lambda may not contain a coalescing operator with a null or default literal left-hand side.\r\n            ":"\r\n              查找类似于表达树lambda的局部字符串可能不包含具有无效或默认字面左侧的合并操作员。\r\n            \r\n","A pointer must be indexed by only one value":"指针必须仅由一个值索引\r\n"," was lowered and transformed.\r\n            The ":" 被降低并转变。\r\n            这\r\n","\r\n              Looks up a localized string similar to Duplicate '{0}' modifier.\r\n            ":"\r\n              查找类似于重复'{0}'修饰符的本地化字符串。\r\n            \r\n","Invalid type for parameter {0} in XML comment cref attribute: '{1}'":"XML注释CREF属性中的参数{0}的无效类型：'{1}'\r\n","the method's body":"该方法的身体\r\n","\r\n            The incremental binder is used when binding statements. Whenever a statement\r\n            is bound, it checks the bound node cache to see if that statement was bound, \r\n            and returns it instead of rebinding it. \r\n            \r\n            For example, we might have:\r\n               while (x > foo())\r\n               {\r\n                 y = y * x;\r\n                 z = z + y;\r\n               }\r\n            \r\n            We might first get semantic info about \"z\", and thus bind just the statement\r\n            \"z = z + y\". Later, we might bind the entire While block. While binding the while\r\n            block, we can reuse the binding we did of \"z = z + y\".\r\n            ":"\r\n            绑定语句时使用增量粘合剂。每当语句\r\n            是绑定的，它检查绑定的节点缓存以查看该语句是否已绑定，\r\n            并返回它而不是重新定位。\r\n            \r\n            例如，我们可能有：\r\n               while（x> foo（））\r\n               {\r\n                 y = y * x;\r\n                 z = z + y;\r\n               }\r\n            \r\n            我们可能首先获得有关“ Z”的语义信息，因此仅绑定语句\r\n            “ z = z + y”。稍后，我们可能会绑定整个块。在绑定时\r\n            块，我们可以重复使用“ z = z + y”的绑定。\r\n            \r\n","A sequence of nodes or tokens, alternating between nodes and separator tokens.":"一系列节点或令牌，在节点和分离器令牌之间交替。\r\n","\r\n             Converts access to a tuple instance into access into the underlying ValueTuple(s).\r\n            \r\n             For instance, tuple.Item8\r\n             produces fieldAccess(field=Item1, receiver=fieldAccess(field=Rest, receiver=ValueTuple for tuple))\r\n             ":"\r\n             将对元组实例的访问转换为访问基础估值。\r\n            \r\n             例如，tuple.item8\r\n             生产fieldAccess（field = item1，reveriver = fieldaccess（field = retain，receiver = for tuple for Tuple））\r\n             \r\n","\r\n            No [NullableContext] attribute\r\n            ":"\r\n            否[nulleableContext]属性\r\n            \r\n","\r\n              Looks up a localized string similar to XML comment on '{1}' has a typeparamref tag for '{0}', but there is no type parameter by that name.\r\n            ":"\r\n              查找类似于'{1}'上的XML注释的本地化字符串，具有'{0}'的typeparamref标签，但没有该名称的类型参数。\r\n            \r\n","Cryptographic failure while creating hashes.":"创建哈希时的加密故障。\r\n"," property). \r\n            ":" 财产）。\r\n            \r\n","\r\n              Looks up a localized string similar to Not a C# symbol..\r\n            ":"\r\n              查找类似于C＃符号的本地化字符串。\r\n            \r\n","\r\n            A lazily calculated diagnostic for use of nullable annotations outside of a '#nullable' annotations context.\r\n            ":"\r\n            懒惰的诊断，用于在“ #nullable”注释上下文之外使用无效注释。\r\n            \r\n","\r\n              Looks up a localized string similar to The CallerMemberNameAttribute will have no effect; it is overridden by the CallerLineNumberAttribute.\r\n            ":"\r\n              查找类似于Callermemberneattribute的本地化字符串将没有效果。它被CallerlineNumberattribute覆盖。\r\n            \r\n","Supported language versions:":"支持的语言版本：\r\n","\r\n              Looks up a localized string similar to path is too long or invalid.\r\n            ":"\r\n              查找类似于路径的局部字符串太长或无效。\r\n            \r\n","Creates a new VariableDeclarationSyntax instance.":"创建一个新的variabledeclarationsyntax实例。\r\n"," == true":"== true\r\n","a == b":"a == b\r\n","SyntaxToken representing the open parenthesis.":"Syntaxtkoken表示开放括号。\r\n","the receiver of the reported diagnostics":"报告诊断的接收器\r\n"," is needed for indexers since getter and setter\r\n            may have distinct optional parameter values.\r\n            ":" 索引器需要Getter和Setter需要\r\n            可能具有不同的可选参数值。\r\n            \r\n","\r\n            IsManagedType is simple for most named types:\r\n                enums are not managed;\r\n                non-enum, non-struct named types are managed;\r\n                type parameters are managed unless an 'unmanaged' constraint is present;\r\n                all special types have spec'd values (basically, (non-string) primitives) are not managed;\r\n            \r\n            Only structs are complicated, because the definition is recursive.  A struct type is managed\r\n            if one of its instance fields is managed.  Unfortunately, this can result in infinite recursion.\r\n            If the closure is finite, and we don't find anything definitely managed, then we return true.\r\n            If the closure is infinite, we disregard all but a representative of any expanding cycle.\r\n            \r\n            Intuitively, this will only return true if there's a specific type we can point to that is would\r\n            be managed even if it had no fields.  e.g. struct S { S s; } is not managed, but struct S { S s; object o; }\r\n            is because we can point to object.\r\n            ":"\r\n            对于大多数命名类型，IsmanagedType很简单：\r\n                枚举没有管理；\r\n                非纳姆，非结构命名类型是管理的；\r\n                除非存在“未管理”约束，否则将管理类型参数；\r\n                所有特殊类型都有规格的值（基本上是（非弦乐）原语）均未管理；\r\n            \r\n            仅结构很复杂，因为定义是递归的。结构类型已管理\r\n            如果管理其中一个字段。不幸的是，这可能导致无限递归。\r\n            如果关闭是有限的，并且我们找不到任何肯定的管理，那么我们返回真实。\r\n            如果封闭是无限的，我们将除了任何扩展周期的代表外，都无视所有。\r\n            \r\n            直观地，这只有在我们可以指出的特定类型的情况下才能返回true\r\n            即使没有字段，也可以管理。例如struct s {s s; }不管理，而是结构s {s s;对象o; }\r\n            是因为我们可以指向对象。\r\n            \r\n","\r\n            True if the given token is not really some contextual keyword.\r\n            This method is for use in executable code, as it treats ":"\r\n            如果给定的令牌不是真正的上下文关键字，则是的。\r\n            此方法用于可执行代码，因为它处理\r\n","\r\n            A string representation for testing purposes.\r\n            ":"\r\n            用于测试目的的字符串表示。\r\n            \r\n","\r\n            SPEC: When a property or indexer declared in a struct-type is the target of an \r\n            SPEC: assignment, the instance expression associated with the property or indexer \r\n            SPEC: access must be classified as a variable. If the instance expression is \r\n            SPEC: classified as a value, a compile-time error occurs. Because of 7.6.4, \r\n            SPEC: the same rule also applies to fields.\r\n            ":"\r\n            规格：在结构类型中声明的属性或索引器时\r\n            规格：分配，与属性或索引器关联的实例表达式\r\n            规格：访问必须分类为变量。如果实例表达式为\r\n            规格：被分类为值，会发生编译时间误差。由于7.6.4，\r\n            规格：同一规则也适用于字段。\r\n            \r\n","A local variable or function named '{0}' is already defined in this scope":"在此范围中已经定义了名为“ {0}”的局部变量或函数\r\n","Empty switch block":"空开关块\r\n","\r\n            Whenever assigning a variable, and that variable is not declared at the point the state is being set,\r\n            and the new state is not ":"\r\n            每当分配变量，并且在状态设置的点未声明该变量时，\r\n            新状态不是\r\n","\r\n            Always returns false.\r\n            ":"\r\n            总是返回false。\r\n            \r\n","\r\n               Looks up a localized string similar to This warning occurs when you create a class with a method whose signature is public virtual void Finalize.\r\n            \r\n            If such a class is used as a base class and if the deriving class defines a destructor, the destructor will override the base class Finalize method, not Finalize..\r\n             ":"\r\n               查找与此警告相似的本地化字符串，当您使用签名为公共虚拟空隙最终确定的方法创建类时会发生。\r\n            \r\n            如果将这样的类用作基类，并且派生类定义了驱动器，则驱动器将覆盖基类实现方法，而不是最终确定。\r\n             \r\n","\r\n              Looks up a localized string similar to The entry point of the program is global script code; ignoring '{0}' entry point..\r\n            ":"\r\n              查找类似于程序的输入点的本地化字符串是全局脚本代码。忽略'{0}'入口点..\r\n            \r\n","Syntax node for attribute specification":"属性规范的语法节点\r\n","\r\n            For enum types, returns the synthesized instance field used\r\n            for generating metadata. Returns null for non-enum types.\r\n            ":"\r\n            对于枚举类型，返回所使用的合成实例字段\r\n            用于生成元数据。返回非Enum类型的null。\r\n            \r\n","\r\n            Where all diagnostics are deposited.\r\n            ":"\r\n            所有诊断存放的地方。\r\n            \r\n","Declaration is not valid; use '{0} operator <dest-type> (...' instead":"声明无效；使用'{0}操作员<dest-type>（...'而不是\r\n","Creates a new AccessorListSyntax instance.":"创建一个新的ConsecorListSyntax实例。\r\n","\r\n            First error calculating bounds.\r\n            ":"\r\n            第一个错误计算边界。\r\n            \r\n","\r\n            Look for a field with the same name and an appropriate type (i.e. the same type, except in WinRT).\r\n            If one is found, the caller will assume that this event was originally field-like and associate\r\n            the two symbols.\r\n            ":"\r\n            查找具有相同名称和适当类型的字段（即相同的类型，除了WinRT之外）。\r\n            如果找到一个，呼叫者将假定此事件最初是类似现场的，并且\r\n            两个符号。\r\n            \r\n","Topologically sorted ":"拓扑排序\r\n"," if it's not overridden \r\n            ":" 如果不被覆盖\r\n            \r\n","A trivia node with the new-line text":"带有新文本的琐事节点\r\n","\r\n              Looks up a localized string similar to enum generic type constraints.\r\n            ":"\r\n              查找类似于枚举通用类型约束的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to extensible fixed statement.\r\n            ":"\r\n              查找类似于可扩展的固定语句的本地化字符串。\r\n            \r\n","\r\n            This instance is used to check whether one member overrides another, according to the C# definition.\r\n            ":"\r\n            根据C＃定义，该实例用于检查一个成员是否覆盖另一个成员。\r\n            \r\n","\r\n            Given a syntax node that declares a (custom) event, get the corresponding event symbol.\r\n            ":"\r\n            给定一个语法节点，该节点声明（自定义）事件，获取相应的事件符号。\r\n            \r\n","The specified version string does not conform to the recommended format - major.minor.build.revision":"指定的版本字符串不符合推荐格式-Major.minor.build.revision\r\n","\r\n              Looks up a localized string similar to { expected.\r\n            ":"\r\n              查找类似于{预期的局部字符串。\r\n            \r\n","\r\n            Used when iterating through base types in contexts in which the caller needs to avoid cycles and can't use BaseType\r\n            (perhaps because BaseType is in the process of being computed)\r\n            ":"\r\n            在通过基本类型的上下文中迭代时使用，呼叫者需要避免循环并且不能使用底层类型\r\n            （也许是因为底于计算的过程中）\r\n            \r\n","\r\n            Represents a compiler generated backing field for an automatically implemented property.\r\n            ":"代表自动实现属性的编译器生成的备份字段。\r\n            \r\n","\r\n            If the nullable expression always has a value, returns the value, otherwise null.\r\n            This is normally performed on a lowered expression, however for the purpose of\r\n            tuples and tuple equality operators, we do this on a partially lowered expression in\r\n            which conversions appearing at the top of the expression have not been lowered.\r\n            If this method is updated to recognize more complex patterns, callers should be reviewed.\r\n            ":"\r\n            如果可通用的表达式始终具有一个值，请返回值，否则为null。\r\n            这通常是在降低的表达式上执行的，但是\r\n            元组和元组平等运算符，我们以部分降低的表达方式进行此操作\r\n            表达式顶部出现哪些转换尚未降低。\r\n            如果更新此方法以识别更复杂的模式，则应审查呼叫者。\r\n            \r\n","Different checksum values given for '{0}'":"给出的“ {0}”给出的不同校验和值\r\n","Invalid version {0} for /subsystemversion. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise":"无效版本{0}用于 /子系统。该版本必须为6.02或更高，对于ARM或APPCONTAINEREXE，以及4.00或更大的版本\r\n",",\r\n            rather than the forwarding method. In other words, it is the method that the forwarding method forwards to.\r\n            ":"，，，，\r\n            而不是转发方法。换句话说，这是转发方法转发的方法。\r\n            \r\n","Iterators cannot have by-reference locals":"迭代者不能有重复引用当地人\r\n",", but may be \r\n            much faster to retrieve for source code assemblies, since it does not require binding\r\n            the assembly-level attributes that contain the version number and other assembly\r\n            information.\r\n            ":"，但可能是\r\n            对于源代码组件的检索速度要快得多，因为它不需要绑定\r\n            包含版本号和其他汇编的组装级级属性\r\n            信息。\r\n            \r\n"," was changed. False otherwise.\r\n             ":"被改变了。否则为错误。\r\n             \r\n","\r\n            This property can return true for bogus indexers.\r\n            Rationale: If a type in metadata has a single, bogus indexer\r\n            and a source method tries to invoke it, then Dev10 reports a bogus\r\n            indexer rather than lack of an indexer.\r\n            ":"\r\n            该属性可以返回伪造索引器。\r\n            理由：如果元数据中的类型具有单个伪造索引器\r\n            源方法试图调用它，然后Dev10报告了一个伪造\r\n            索引者而不是缺少索引器。\r\n            \r\n","\r\n              Looks up a localized string similar to Operator '{0}' is ambiguous on operands 'default' and 'default'.\r\n            ":"\r\n              在操作数“默认”和“默认”上查找类似于操作员'{0}'类似的本地化字符串。\r\n            \r\n","\r\n            Expression is the receiver of a fixed buffer field access\r\n            Same as ReadonlyRef. The difference is just for error reporting.\r\n            ":"\r\n            表达是固定缓冲区访问的接收器\r\n            与Readonlyref相同。区别仅用于错误报告。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid base type.\r\n            ":"\r\n              查找类似于无效的基本类型的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Accessing a member on '{0}' may cause a runtime exception because it is a field of a marshal-by-reference class.\r\n            ":"\r\n              查找类似于“ {0}”上访问成员的本地化字符串可能会导致运行时异常，因为它是逐个参考类的字段。\r\n            \r\n","The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'":"预定义的类型“ {0}”是在全局别名中的多个汇编中定义的；使用来自'{1}'的定义\r\n","\r\n            In source, we regard a property as an indexer if it is declared with an IndexerDeclarationSyntax.\r\n            From metadata, we regard a property if it has parameters and is a default member of the containing\r\n            type.\r\n            CAVEAT: To ensure that this property (and indexer Names) roundtrip, source properties are not\r\n            indexers if they are explicit interface implementations (since they will not be marked as default\r\n            members in metadata).\r\n            ":"\r\n            在来源中，如果用索引declarationsyntax声明了索引，我们将属性视为索引。\r\n            从元数据中，我们认为该属性是否具有参数，并且是包含的默认成员\r\n            类型。\r\n            警告：为了确保此属性（和索引器名称）往返，源属性不是\r\n            索引器如果是显式接口实现（因为它们不会被标记为默认值\r\n            元数据成员）。\r\n            \r\n","\r\n            The buffer backing the current window.\r\n            ":"\r\n            缓冲区备份当前窗口。\r\n            \r\n","\r\n            Returns true if nullable analysis is enabled in the text span.\r\n            ":"\r\n            如果在文本跨度启用了无效的分析，则返回true。\r\n            \r\n","\r\n              Looks up a localized string similar to CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead..\r\n            ":"\r\n              查找类似于CLSCompliant属性的本地化字符串，当应用于参数时没有含义。尝试将其放在方法上。\r\n            \r\n","\r\n            Note that a variable is read.\r\n            ":"\r\n            请注意，读取变量。\r\n            \r\n","The syntax 'var (...)' as an lvalue is reserved.":"保留语法“ var（...）”作为LVALUE。\r\n","\r\n              Looks up a localized string similar to The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'.\r\n            ":"\r\n              查找类似于'{0}'中的名称空间'{1}'的本地化字符串与'{2}'中的类型'{3}'冲突。\r\n            \r\n","\r\n            Conversion applied to operand of the user-defined conversion.\r\n            ":"\r\n            转换应用于用户定义的转换的操作数。\r\n            \r\n","The PDB writer does not support adding compiler info.":"PDB作者不支持添加编译器信息。\r\n","ExpressionSyntax node representing the object conditionally accessed.":"表示有条件访问的对象的extressionsyntax节点。\r\n","\r\n             Lookup well-known member declaration in provided type.\r\n            \r\n             If a well-known member of a generic type instantiation is needed use this method to get the corresponding generic definition and\r\n             ":"查找以提供类型的知名会员声明。\r\n            \r\n             如果需要使用此方法来获取相应的通用定义和\r\n             \r\n","The label symbol for that label.":"该标签的标签符号。\r\n","\r\n            Returns true if the type is generic or non-generic custom task-like type due to the\r\n            [AsyncMethodBuilder(typeof(B))] attribute. It returns the \"B\".\r\n            ":"\r\n            如果该类型为通用或非传播定制任务类型，则返回true\r\n            [asyncmethodbuilder（typeOf（b））]属性。它返回“ B”。\r\n            \r\n","\r\n              Looks up a localized string similar to  Badly formed XML file \"{0}\" cannot be included .\r\n            ":"\r\n              查找类似于不良形成的XML文件“ {0}”的本地化字符串。\r\n            \r\n","\r\n            The explicitly overridden method (e.g. as would be declared in the PE method in covariant return scenarios).\r\n            ":"\r\n            明确覆盖的方法（例如，在协方差返回方案中的PE方法中所声明）。\r\n            \r\n","Reference of type '{0}' is not valid for this compilation.":"类型“ {0}”的引用对于此汇编无效。\r\n","\r\n            Returns true if body contains await in a finally block.\r\n            ":"\r\n            如果身体在最后一个块中等待，则返回true。\r\n            \r\n","\r\n            Represents a base implementation for anonymous type synthesized methods.\r\n            ":"\r\n            代表匿名类型合成方法的基本实现。\r\n            \r\n","Partially populated (all but conversions) or null if there was an error.":"如果有错误，则部分填充（除所有转换）或无效。\r\n","The type symbol of the argument.":"参数的类型符号。\r\n","\r\n              Looks up a localized string similar to Use of null is not valid in this context.\r\n            ":"\r\n              在此上下文中查找类似于使用NULL的本地化字符串是无效的。\r\n            \r\n","{0}. See also error CS{1}.":"{0}。另请参见错误CS {1}。\r\n"," if this is an assignment forbidden by DisallowNullAttribute, otherwise ":" 如果这是disallownullattribute禁止的作业，则\r\n",".\r\n            When in doubt we conservatively use ":"。\r\n            如有疑问，我们保守地使用\r\n","\r\n            Gets the set of interfaces that this type directly implements, plus the base interfaces\r\n            of all such types. Keys are compared using ":"\r\n            获取此类型直接实现的一组接口，以及基本接口\r\n            所有此类类型。比较键\r\n","\r\n            Matches an attribute by metadata namespace, metadata type name and metadata signature. Does not load the\r\n            type symbol for the attribute.\r\n            ":"\r\n            匹配元数据名称空间，元数据类型名称和元数据签名的属性。不加载\r\n            属性的类型符号。\r\n            \r\n","\r\n            Finds types or namespaces described by a qualified name.\r\n            ":"\r\n            查找由合格名称描述的类型或名称空间。\r\n            \r\n","Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}'.":"参数类型中的参考类型的无效性'{0}'不匹配实现的成员'{1}'。\r\n","\r\n              Looks up a localized string similar to Identifier '{0}' is not CLS-compliant.\r\n            ":"\r\n              查找类似于标识符'{0}'的本地化字符串不符合CLS。\r\n            \r\n","\r\n             Lower a foreach loop that will enumerate a collection using an enumerator.\r\n            \r\n             ":"\r\n             降低一个foreach循环，该循环将使用枚举器枚举集合。\r\n            \r\n             \r\n","\r\n            Unconditionally visits an expression and returns the \"state when not null\" for the expression.\r\n            ":"\r\n            无条件访问表达式并返回“未null null”的表达式。\r\n            \r\n","BlockSyntax node representing the body of the anonymous method.":"blocksyntax节点代表匿名方法的主体。\r\n","\r\n              Looks up a localized string similar to '{0}': user-defined conversions to or from a base class are not allowed.\r\n            ":"\r\n              查找类似于“ {0}'的本地化字符串：不允许使用consem for Base类的用户定义转换。\r\n            \r\n","\r\n              Looks up a localized string similar to Operation caused a stack overflow..\r\n            ":"\r\n              查找类似于操作的局部字符串引起了堆栈溢出。\r\n            \r\n","The parameter modifier '{0}' cannot be used with '{1}'":"参数修饰符'{0}'不能与'{1}'一起使用\r\n","\r\n            Perform a first analysis pass in preparation for removing all lambdas from a method body.  The entry point is Analyze.\r\n            The results of analysis are placed in the fields seenLambda, blockParent, variableBlock, captured, and captures.\r\n            ":"\r\n            进行第一次分析通过，准备从方法主体中删除所有lambdas。分析入口点。\r\n            分析结果放置在SiewLambda，Blockparent，可变板，捕获和捕获的字段中。\r\n            \r\n","The type '{0}' cannot be declared const":"类型'{0}'不能声明为const\r\n","\r\n              Looks up a localized string similar to '{0}': member names cannot be the same as their enclosing type.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串：成员名称不能与其封闭类型相同。\r\n            \r\n","\r\n              Looks up a localized string similar to An anonymous method expression cannot be converted to an expression tree.\r\n            ":"\r\n              查找类似于匿名方法表达式的局部字符串无法转换为表达树。\r\n            \r\n","The syntax for the query clause generating this invocation expression, if any.":"查询子句的语法生成此调用表达式（如果有）。\r\n","\r\n            Produces a syntax tree by parsing the source text.\r\n            ":"\r\n            通过解析源文本产生语法树。\r\n            \r\n","\r\n              Looks up a localized string similar to An expression tree may not contain a throw-expression..\r\n            ":"\r\n              查找类似于表达树的本地化字符串可能不包含抛出表达。\r\n            \r\n","\r\n            An elastic trivia with kind WhitespaceTrivia containing a single tab character. Elastic trivia are used to\r\n            denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.\r\n            ":"\r\n            具有单个标签字符的弹性琐事。弹性琐事习惯\r\n            表示未通过解析源文本产生的琐事，通常在格式期间没有保留。\r\n            \r\n","\r\n              Looks up a localized string similar to Too many characters in character literal.\r\n            ":"\r\n              在字符文字中查找类似于太多字符的本地化字符串。\r\n            \r\n","<![CDATA[":"<！[cdata [\r\n","\r\n              Looks up a localized string similar to '{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' requires a receiver of type '{3}'.\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串不包含“ {1}'”的定义，最佳扩展方法Overload'{2}'需要一个类型'{3}'的接收器。\r\n            \r\n","\r\n              Looks up a localized string similar to Circular base class dependency involving '{0}' and '{1}'.\r\n            ":"\r\n              查找类似于涉及“ {0}'和'{1}'的圆形基类依赖关系类似的局部字符串。\r\n            \r\n","True if there exists a type map such that Map(LHS) == Map(RHS).":"如果存在类型的映射，则为true。\r\n","\r\n            true if ToString may be used; false if using ToString could lead to observable differences in behavior.\r\n            ":"\r\n            如果可以使用肿胀，则为是真的；错误，如果使用to弦可能会导致可观察到的行为差异。\r\n            \r\n"," will be returned, respectively.\r\n            If passing true for forceComplete, ensure that cycles will not occur by not calling in the process of binding\r\n            an attribute argument.\r\n            ":" 将分别返回。\r\n            如果将true用于forcecterte，请确保不会通过绑定的过程不调用循环\r\n            一个属性参数。\r\n            \r\n","A 'using static' directive can only be applied to types; '{0}' is a namespace not a type. Consider a 'using namespace' directive instead":"“使用静态”指令只能应用于类型； '{0}'是名称空间而不是类型。考虑一个“使用名称空间”指令\r\n","\r\n            Call the correct VisitXXX method in this class based on the particular type of symbol that is passed in.\r\n            Return default(TResult) if symbol is null\r\n            ":"\r\n            基于传递的特定类型的符号类型，在此类中调用正确的visitxxx方法。\r\n            返回默认值（tresult）如果符号为null\r\n            \r\n","\r\n              Looks up a localized string similar to unconstrained type parameters in null coalescing operator.\r\n            ":"\r\n              查找类似于NULL合并操作员中无约束类型参数的局部字符串。\r\n            \r\n","\r\n            Returns true if this symbol is \"static\"; i.e., declared with the \"static\" modifier or\r\n            implicitly static.\r\n            ":"\r\n            如果此符号为“静态”，则返回true；即，用“静态”修饰符声明或\r\n            隐式静态。\r\n            \r\n","\r\n            Computes the scope to which the given invocation can escape\r\n            NOTE: the escape scope for ref and val escapes is the same for invocations except for trivial cases (ordinary type returned by val) \r\n                  where escape is known otherwise. Therefore we do not vave two ref/val variants of this.\r\n                  \r\n            NOTE: we need scopeOfTheContainingExpression as some expressions such as optional `in` parameters or `ref dynamic` behave as \r\n                  local variables declared at the scope of the invocation.\r\n            ":"\r\n            计算给定调用可以逃脱的范围\r\n            注意：除了琐碎的情况（Val返回的普通类型）外，REF和Val Escapes的逃生范围是相同的\r\n                  逃脱的地方是另外的。因此，我们不为此提供两个参考/val变体。\r\n                  \r\n            注意：我们需要范围内的表达方式作为某些表达式，例如可选的`in参数或`ref dynamic'Behip h.\r\n                  在调用范围内声明的本地变量。\r\n            \r\n","\r\n            A collection of statements inside the region that jump to locations outside the region.\r\n            ":"\r\n            在区域内的陈述集合，这些语句跳到该地区以外的位置。\r\n            \r\n","\r\n            Get the symbol for a well-known member. The use of this method to get a well-known member\r\n            that does not exist will result in an exception of type MissingPredefinedMember being thrown\r\n            containing an appropriate diagnostic for the caller to report.\r\n            ":"\r\n            获取一个著名成员的符号。使用这种方法来获得知名会员\r\n            这不存在将导致抛出类型的类型缺失定义的人\r\n            包含适当的诊断供呼叫者报告。\r\n            \r\n"," after it has finished binding attributes on the symbol,\r\n            has executed ":" 在符号上完成绑定属性后，\r\n            已执行\r\n"," used for overload resolution.":" 用于超负荷分辨率。\r\n","\r\n              Looks up a localized string similar to Async-iterator member has one or more parameters of type 'CancellationToken' but none of them is decorated with the 'EnumeratorCancellation' attribute, so the cancellation token parameter from the generated 'IAsyncEnumerable<>.GetAsyncEnumerator' will be unconsumed.\r\n            ":"\r\n              查找类似于Async-静脉构件类似的局部字符串，具有一个或多个类型的“ cancellationToken”参数，但它们都没有用“ EnumeratorCancellation”属性装饰，因此从生成的“ iasyncenncenncenumerable <> getAsyncencenumerator'Will Will中，取消令牌参数不耗费。\r\n            \r\n"," for the specified text ":" 对于指定的文本\r\n","\r\n            Get a SemanticModel object that is associated with a type syntax node that did not appear in\r\n            this source code. This can be used to get detailed semantic information about sub-parts\r\n            of a type syntax that did not appear in source code.\r\n            ":"\r\n            获取与未出现在\r\n            此源代码。这可以用来获取有关子部分的详细语义信息\r\n            未出现在源代码中的类型语法。\r\n            \r\n","\r\n            True if the event itself is excluded from code covarage instrumentation.\r\n            True for source events marked with ":"\r\n            如果将事件本身排除在CORVARAGE仪器中，则为诚然。\r\n            对于标记的源事件是正确的\r\n","Nullability of reference types in type of parameter doesn't match the target delegate (possibly because of nullability attributes).":"参数类型中参考类型的无效性不匹配目标委托（可能是由于无效属性）。\r\n","\r\n            Produces a clone of a ":"\r\n            产生一个克隆\r\n","The text of the attribute argument list.":"属性参数列表的文本。\r\n",", the incoming conversion is assumed to be from binding\r\n            and will be re-calculated, this time considering nullability.\r\n            Note that the conversion calculation considers nested nullability only.\r\n            The caller is responsible for checking the top-level nullability of\r\n            the type returned by this method.\r\n            ":"，假定传入的转换是由结合\r\n            并将重新计算，这次考虑了无效性。\r\n            请注意，转换计算仅考虑嵌套无效性。\r\n            呼叫者负责检查最高级别的可取性\r\n            该方法返回的类型。\r\n            \r\n","Creates a new DefineDirectiveTriviaSyntax instance.":"创建一个新的定义定义的实例实例。\r\n","\r\n            Represents an event of a tuple type (such as (int, byte).SomeEvent)\r\n            that is backed by an event within the tuple underlying type.\r\n            ":"\r\n            代表元组类型的事件（例如（int，byte）.someevent）\r\n            这是由元组基础类型中的事件支持的。\r\n            \r\n","Circular base type dependency involving '{0}' and '{1}'":"涉及'{0}'和'{1}'的圆形基本类型依赖关系\r\n","Gets the enum keyword token.":"获取枚举关键字令牌。\r\n","\r\n            Used to detect whether we are in a cref return type.\r\n            ":"\r\n            用于检测我们是否处于CREF返回类型中。\r\n            \r\n","\r\n            Represents the result of visiting an expression.\r\n            Contains a result type which tells us whether the expression may be null,\r\n            and an l-value type which tells us whether we can assign null to the expression.\r\n            ":"\r\n            代表访问表达式的结果。\r\n            包含结果类型，该类型告诉我们表达是否可能为null，\r\n            和L值类型，它告诉我们是否可以将null分配给表达式。\r\n            \r\n","\r\n              Looks up a localized string similar to The params parameter cannot be declared as {0}.\r\n            ":"\r\n              查找类似于参数的本地化字符串不能将其声明为{0}。\r\n            \r\n","\r\n              Looks up a localized string similar to The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute..\r\n            ":"\r\n              查找类似于应用于参数'{0}'的callermemberneattribute类似的本地化字符串将没有效果。它被CallerFilePathattribute覆盖。\r\n            \r\n"," which will have current syntax tree as its parent.\r\n            \r\n             Caller must guarantee that if the same instance of ":" 它将以当前的语法树作为父。\r\n            \r\n             呼叫者必须保证，如果相同的实例\r\n","\r\n              Looks up a localized string similar to Cannot await in an unsafe context.\r\n            ":"\r\n              在不安全的上下文中查找类似于无法等待的本地化字符串。\r\n            \r\n","\r\n            Create a metadata reference to a compilation.\r\n            ":"\r\n            创建对汇编的元数据引用。\r\n            \r\n","\r\n            Set to true while we are analyzing the interior of an expression lambda.\r\n            ":"\r\n            当我们分析表达lambda的内部时，设置为真。\r\n            \r\n"," which will have current syntax tree as its parent.\r\n            \r\n            Caller must guarantee that if the same instance of ":" 它将以当前的语法树作为父。\r\n            \r\n            呼叫者必须保证，如果相同的实例\r\n","Creates a new AliasQualifiedNameSyntax instance.":"创建一个新的AliasqualifyNamesyntax实例。\r\n","\r\n              Looks up a localized string similar to Both partial method declarations must be readonly or neither may be readonly.\r\n            ":"\r\n              查找类似于两个部分方法声明的本地化字符串，必须阅读或不可阅读。\r\n            \r\n","\r\n              Looks up a localized string similar to Embedded statement cannot be a declaration or labeled statement.\r\n            ":"\r\n              查找类似于嵌入式语句的本地化字符串不能是声明或标记的语句。\r\n            \r\n","Type parameter declaration must be an identifier not a type":"类型参数声明必须是标识符而不是类型\r\n","The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match constraint type.":"该类型不能用作通用类型或方法中的类型参数。类型参数的无效性不匹配约束类型。\r\n","\r\n            Attempt a quick classification of builtin conversions.  As result of \"no conversion\"\r\n            means that there is no built-in conversion, though there still may be a user-defined\r\n            conversion if compiling against a custom mscorlib.\r\n            ":"\r\n            尝试快速对内置转换进行分类。由于“不转换”\r\n            意味着没有内置的转换，尽管仍然有用户定义\r\n            转换如果与自定义MSCORLIB进行编译。\r\n            \r\n","\r\n            Requires that scope is either the same as ":"\r\n            要求范围与\r\n","Called when the visitor visits a GotoStatementSyntax node.":"当访问者访问gotostatementsyntax节点时，请致电。\r\n","\r\n            May be user-defined.\r\n            ":"\r\n            可能是用户定义的。\r\n            \r\n","\r\n            Binder used to place the parameters of a method, property, indexer, or delegate\r\n            in scope when binding <param> tags inside of XML documentation comments.\r\n            ":"\r\n            粘合剂用于放置方法，属性，索引器或委托的参数\r\n            在XML文档注释中绑定<param>标签时，在范围中。\r\n            \r\n","Error signing output with public key from container '{0}' -- {1}":"来自容器'{0}'的公共密钥的错误签名输出 -  {1}\r\n","\r\n              Looks up a localized string similar to Warning level must be in the range 0-4.\r\n            ":"\r\n              查找类似于警告级别的局部字符串必须在0-4范围内。\r\n            \r\n","\r\n            when predicate is just a simple string check.\r\n            ":"\r\n            当谓词只是一个简单的字符串检查。\r\n            \r\n","\r\n            The overload resolution portion of FindForEachPatternMethod.\r\n            ":"\r\n            FindForeachPatternMethod的过载分辨率部分。\r\n            \r\n","Containing type.":"包含类型。\r\n"," which is an expression\r\n            specifically created in NullableWalker to represent the flow analysis state.\r\n            ":" 这是一个表达\r\n            专门在Nullable Walker中创建以表示流程分析状态。\r\n            \r\n","\r\n            True if the parameter is marked by ":"\r\n            如果参数标记为true\r\n","\r\n              Looks up a localized string similar to '{0}' is already listed in the interface list on type '{1}' with different nullability of reference types..\r\n            ":"\r\n              在类型'{1}'的接口列表中列出了类似于“ {0}”的本地化字符串，并具有不同的参考类型的无效性。\r\n            \r\n","\r\n            A position is considered to be inside a block if it is on or after\r\n            the open brace and strictly before the close brace.\r\n            ":"\r\n            如果位置在块上或之后，则认为该位置在块内\r\n            开放式支撑，严格在近距离支撑之前。\r\n            \r\n"," generic type.  These occur only\r\n            within a ":" 通用类型。这些仅发生\r\n            在\r\n","\r\n              Looks up a localized string similar to Nullability in constraints for type parameter '{0}' of method '{1}' doesn't match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead..\r\n            ":"\r\n              在类型参数'{1}'的type参数'{0}'的约束中，查找类似于不可限制的本地化字符串，与类型参数'{2}'接口方法'{3}'的约束不匹配。考虑使用显式接口实现。\r\n            \r\n","\r\n            The method that declared this type parameter, or null.\r\n            ":"\r\n            声明此类型参数或null的方法。\r\n            \r\n","\r\n            Describes how the parameter is marshalled when passed to native code.\r\n            Null if no specific marshalling information is available for the parameter.\r\n            ":"\r\n            描述将参数传递给本机代码时的编组方式。\r\n            null如果没有特定的编组信息可用于参数。\r\n            \r\n","Auto-implemented property '{0}' must be fully assigned before control is returned to the caller.":"在将控件返回到呼叫者之前，必须完全分配自动实施属性'{0}'。\r\n","Iterators cannot have ref, in or out parameters":"迭代器不能具有参数或输出参数\r\n","\r\n              Looks up a localized string similar to A parameter cannot have all the specified modifiers; there are too many modifiers on the parameter.\r\n            ":"\r\n              查找类似于参数的本地化字符串不能具有所有指定的修饰符。参数上的修饰符太多。\r\n            \r\n"," of the conversion.\r\n            ":" 转换。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' cannot be extern and have a constructor initializer.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串不能是外部的，并且具有构造函数初始化器。\r\n            \r\n"," available in this assembly\r\n            its referenced assemblies.\r\n            ":" 在这个大会上可用\r\n            其引用的组件。\r\n            \r\n","\r\n            Represents a getter for anonymous type property.\r\n            ":"\r\n            代表匿名类型属性的getter。\r\n            \r\n","\r\n            Mapping from local or parameter to inferred type.\r\n            ":"\r\n            从本地或参数映射到推断类型。\r\n            \r\n","\r\n            True if we are currently in an unsafe region (type, member, or block).\r\n            ":"\r\n            是的，如果我们当前处于不安全区域（类型，成员或块）。\r\n            \r\n","\r\n            Parts are not localized until they are converted to strings.\r\n            ":"\r\n            零件直到将其转换为字符串之前才能定位。\r\n            \r\n","\r\n            Bind the pattern switch labels, reporting in the process which cases are subsumed. The strategy,\r\n            implemented with the help of ":"\r\n            绑定图案开关标签，在此过程中报告哪些情况。策略，\r\n            借助于\r\n","\r\n              Looks up a localized string similar to Pattern-matching is not permitted for pointer types..\r\n            ":"\r\n              在指针类型中不允许查找类似于模式匹配的本地化字符串。\r\n            \r\n","index of last character to be included":"最后一个字符的索引\r\n","\r\n            If the node is \"nint\" or \"nuint\" and not alone inside nameof, return the corresponding native integer symbol.\r\n            Otherwise return null.\r\n            ":"\r\n            如果节点为“ nint”或“ nuint”，而不是孤单的名称，则返回相应的本机整数符号。\r\n            否则返回null。\r\n            \r\n","\r\n              Looks up a localized string similar to A throw statement with no arguments is not allowed in a finally clause that is nested inside the nearest enclosing catch clause.\r\n            ":"\r\n              在嵌套在最近的封闭捕获子句中的最后条款中，查找类似于抛出语句的本地化字符串，类似于抛出语句。\r\n            \r\n","Gets the \"operator\" keyword.":"获取“运算符”关键字。\r\n","\r\n            A map from section syntax to the first label in that section.\r\n            ":"\r\n            该部分中的第一个标签从节语法到第一个标签。\r\n            \r\n","Called when the visitor visits a ArrayCreationExpressionSyntax node.":"当访问者访问arrayCreationexpressyntax节点时调用。\r\n","\r\n            A list of all nested functions (all lambdas and local functions) declared in this scope.\r\n            ":"\r\n            此范围中声明的所有嵌套功能（所有lambdas和local功能）的列表。\r\n            \r\n","\r\n             A tree of binary operators for tuple comparisons.\r\n            \r\n             For ":"\r\n             二进制操作员的树，用于元组比较。\r\n            \r\n             为了\r\n","The namespace symbol that was declared by the namespace declaration.":"名称空间声明声明的名称空间符号。\r\n","Nullability of reference types in return type of '{0}' doesn't match implicitly implemented member '{1}'.":"“ {0}”返回类型中的参考类型的无效性不匹配隐式实现的成员'{1}'。\r\n","Type does not implement the collection pattern; member is is not a public instance or extension method.":"类型不会实现集合模式；成员不是公共实例或扩展方法。\r\n","Creates a new InterpolationFormatClauseSyntax instance.":"创建一个新的InterPolationFormatClausesyNTAX实例。\r\n","\r\n              Looks up a localized string similar to Type parameter '{0}' has the same name as the type parameter from outer method '{1}'.\r\n            ":"\r\n              查找类似于类型参数'{0}'的本地化字符串，其名称与外部方法'{1}'的类型参数相同。\r\n            \r\n","\r\n            Pointer conversions are described in section 18.4 of the C# language specification.\r\n            \r\n            Returns true if the conversion is a conversion \r\n             a) from a pointer type to void*, \r\n             b) from a pointer type to another pointer type (other than void*),\r\n             c) from the null literal to a pointer type,\r\n             d) from an integral numeric type to a pointer type, or\r\n             e) from a pointer type to an integral numeric type.\r\n            \r\n            Does not return true for user-defined conversions to/from pointer types.\r\n            Does not return true for conversions between pointer types and IntPtr/UIntPtr.\r\n            ":"C＃语言规范第18.4节中描述了指针转换。\r\n            \r\n            如果转换为转换，则返回true\r\n             a）从指针类型到void*，\r\n             b）从指针类型到另一种指针类型（void*除外），\r\n             c）从零字面到指针类型，\r\n             d）从积分数字类型到指针类型，或\r\n             e）从指针类型到积分数字类型。\r\n            \r\n            对于用户定义的转换，请勿返回到指针类型的转换。\r\n            对于指针类型和INTPTR/UINTPTR之间的转换，不返回true。\r\n            \r\n",".\r\n            \r\n            Finally, we walk and rewrite the input bound tree, keeping track of the following:\r\n            (1) The current set of active frame pointers, in ":"。\r\n            \r\n            最后，我们走路并重写输入绑定的树，跟踪以下内容：\r\n            （1）当前的活动帧指针集\r\n","Async methods cannot have ref, in or out parameters":"异步方法不能具有参数或输出参数\r\n","\r\n            Bind the switch statement, reporting in the process any switch labels that are subsumed by previous cases.\r\n            ":"\r\n            绑定开关语句，在该过程中报告任何交换标签，这些交换机标签由以前的情况包含。\r\n            \r\n"," from this C# conversion.\r\n            ":" 从这个C＃转换。\r\n            \r\n","Method to invoke in constructed body.":"在构造身体中调用的方法。\r\n","\r\n            Special HasHome for fields. Fields have homes when they are writable.\r\n            ":"特殊的田野藏品。田野在写作时有房屋。\r\n            \r\n","\r\n            Corresponds to Microsoft.CSharp.RuntimeBinder.CSharpBinderFlags.\r\n            ":"\r\n            对应于Microsoft.csharp.runtimebinder.csharpbinderflags。\r\n            \r\n","'{1} {0}' has the wrong return type":"'{1} {0}'的返回类型错误\r\n","\r\n            A collection of the local variables that are declared within the region. Note that the region must be\r\n            bounded by a method's body or a field's initializer, so method parameter symbols are never included\r\n            in the result, but lambda parameters might appear in the result.\r\n            ":"\r\n            该区域内声明的本地变量的集合。请注意，该地区必须是\r\n            由方法的身体或字段的初始化器界定，因此永远不会包括方法参数符号\r\n            在结果中，但是lambda参数可能出现在结果中。\r\n            \r\n","True if target location is considered written to.":"如果将目标位置写成，则为正确。\r\n","BracketedArgumentListSyntax node representing the list of arguments of the element binding expression.":"表示元素绑定表达式参数列表的brackeDargumentListSyntax节点。\r\n","\r\n              Looks up a localized string similar to Attribute parameter '{0}' or '{1}' must be specified..\r\n            ":"\r\n              必须指定类似于属性参数'{0}'或'{1}'的本地化字符串。\r\n            \r\n","fixed size buffers":"固定尺寸缓冲区\r\n","Argument of type '{0}' cannot be used as an output of type '{1}' for parameter '{2}' in '{3}' due to differences in the nullability of reference types.":"由于参考类型的无效性差异，因此不能将类型'{0}'的参数用作参数'{2}'的类型'{1}'的输出。\r\n"," it can.\r\n             ":" 它可以。\r\n             \r\n","\r\n            Type is annotated with '?' - string?, T?.\r\n            ":"\r\n            类型带有“？”的注释 - 字符串？，t？。\r\n            \r\n","Create an Index pointing at beyond last element.":"创建一个指向最后一个元素的索引。\r\n","Can only use array initializer expressions to assign to array types. Try using a new expression instead.":"只能使用数组初始化器表达式分配给数组类型。尝试使用新表达式。\r\n","\r\n            Given a method, find the first method that it overrides from the perspective of the CLI.\r\n            Key differences from C#: non-virtual methods are ignored, the RuntimeSignatureComparer\r\n            is used (i.e. consider return types, ignore ref/out distinction).  Sets ":"\r\n            给定方法，找到从CLI的角度覆盖其覆盖的第一种方法。\r\n            与C＃的关键差异：忽略了非虚拟方法，runtimesIgnatureComparer\r\n            使用（即考虑返回类型，忽略参考/退出区别）。套\r\n","Creates a new ClassOrStructConstraintSyntax instance.":"创建一个新的classorsstructconstraintsyntax实例。\r\n"," \r\n            Get a 'wrapper' method for the original one. \r\n            ":" \r\n            获取原始方法的“包装器”方法。\r\n            \r\n","Unexpected use of an unbound generic name":"意外使用无限制的通用名称\r\n","Parameter not valid for the specified unmanaged type.":"参数对于指定的非托管类型无效。\r\n","\r\n            returns true when implicit conversion is not necessarily the same as explicit conversion\r\n            ":"\r\n            当隐式转换不一定与显式转换相同时，返回true\r\n            \r\n","{ or ; or => expected":"{ 或者 ;或=>预期\r\n","\r\n            Walk up the scope tree looking for a closure.\r\n            ":"\r\n            走上瞄准镜树寻找封闭。\r\n            \r\n","\r\n            Some nodes have special binder's for their contents (like Block's)\r\n            ":"\r\n            有些节点具有特殊的粘合剂，适合其内容（例如Block's）\r\n            \r\n","::":"::\r\n","\r\n            Gets a reference to the source for this application of the attribute. Returns null for applications of attributes on metadata Symbols.\r\n            ":"\r\n            获取属性此应用程序的来源的引用。返回元数据符号上属性应用的null。\r\n            \r\n","\r\n              Looks up a localized string similar to CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead..\r\n            ":"\r\n              查找类似于CLSCompliant属性的本地化字符串，当应用于返回类型时没有任何含义。尝试将其放在方法上。\r\n            \r\n","\r\n            To facilitate lookup, all indexer symbols have the same name.\r\n            Check the MetadataName property to find the name we imported.\r\n            ":"\r\n            为了促进查找，所有索引器符号都具有相同的名称。\r\n            检查元数据属性属性以查找我们导入的名称。\r\n            \r\n","An expression tree may not contain an out argument variable declaration.":"表达树可能不包含OUT参数变量声明。\r\n","\r\n            Defines the starting state used in the local function body to\r\n            produce diagnostics and determine types.\r\n            ":"\r\n            将本地功能主体中使用的起始状态定义为\r\n            产生诊断并确定类型。\r\n            \r\n","\r\n              Looks up a localized string similar to Unnecessary using directive..\r\n            ":"\r\n              查找类似于使用指令的不必要的本地化字符串。\r\n            \r\n","\r\n            Return the nullable annotation to use when two annotations are expected to be \"compatible\", which means\r\n            they could be the same. These are the \"invariant\" merging rules. (NotAnnotated wins over Annotated which wins over Oblivious)\r\n            ":"\r\n            在预期两个注释“兼容”时，将无效的注释返回可使用的注释，这意味着\r\n            他们可能是一样的。这些是“不变”的合并规则。 （赢得胜利的注释胜利）\r\n            \r\n","\r\n            In order to build this automaton, we start (in\r\n            ":"\r\n            为了构建此自动机，我们开始（在\r\n            \r\n","\r\n              Looks up a localized string similar to Overloaded method '{0}' differing only by unnamed array types is not CLS-compliant.\r\n            ":"\r\n              查找类似于超载方法'{0}'的本地化字符串，仅由未命名数组类型不同，不符合Cls cls。\r\n            \r\n","Failed to insert some or all of included XML":"未能插入一些或全部包含的XML\r\n","<switch expression>":"<开关表达式>\r\n","Gets the \"default\" keyword.":"获取“默认”关键字。\r\n","\r\n            Register declaration of predefined CorLib type in this Assembly.\r\n            ":"\r\n            在此组件中注册预定义的Corlib类型的声明。\r\n            \r\n","\r\n              Looks up a localized string similar to The 'as' operator may produce a null value when '{0}' is a non-nullable reference type..\r\n            ":"\r\n              查找类似于“ AS”操作员的本地化字符串，当“ {0}”是一种不可删除的参考类型时，可能会产生空值。\r\n            \r\n","\r\n              Looks up a localized string similar to The type name '{0}' could not be found. This type has been forwarded to assembly '{1}'. Consider adding a reference to that assembly..\r\n            ":"\r\n              查找类似于类型名称'{0}'的本地化字符串。这种类型已转发到汇编'{1}'。考虑添加对该组件的参考。\r\n            \r\n","\r\n              Looks up a localized string similar to Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type.\r\n            ":"\r\n              查找类似于两个索引器的本地化字符串具有不同的名称；索引属性必须在类型中的每个索引器上与相同名称一起使用。\r\n            \r\n","<global namespace>":"<全局名称空间>\r\n","\r\n            Parse an ArgumentListSyntax node.\r\n            ":"\r\n            解析一个参数清单元素节点。\r\n            \r\n","\r\n            The underlying type, unless overridden by _extensions.\r\n            ":"\r\n            基础类型，除非被extensions覆盖。\r\n            \r\n","The already bound arguments to the constructor.":"已经绑定的论点与构造函数。\r\n","\r\n            Won't include indexers that are explicit interface implementations.\r\n            ":"\r\n            不包括显式接口实现的索引器。\r\n            \r\n","Metadata file '{0}' could not be opened -- {1}":"元数据文件'{0}'无法打开 -  {1}\r\n","The syntax node that declares an enum member.":"声明枚举成员的语法节点。\r\n","An alias-qualified name is not an expression.":"别名合格的名称不是表达式。\r\n","\r\n              Looks up a localized string similar to Inconsistent accessibility: return type '{1}' is less accessible than operator '{0}'.\r\n            ":"\r\n              查找类似于不一致的可访问性的本地化字符串：返回类型'{1}'比操作员'{0}'易于访问。\r\n            \r\n","\r\n            Returns 'NotApplicable' because local variable can't be used outside the member body..\r\n            ":"\r\n            返回“非适当”，因为无法在会员体外使用本地变量。\r\n            \r\n","A parameter can only have one '{0}' modifier":"一个参数只能有一个'{0}'修饰符\r\n","It is always legal to access a protected base class constructor\r\n            via a constructor initializer, but not from an object creation expression.":"访问受保护的基类构造函数总是合法的\r\n            通过构造函数初始化器，而不是来自对象创建表达式。\r\n","Called when the visitor visits a ParenthesizedLambdaExpressionSyntax node.":"访问者访问括号lambdaexpressyntax节点时调用。\r\n","\r\n              Looks up a localized string similar to Foreach cannot operate on a '{0}'. Did you intend to invoke the '{0}'?.\r\n            ":"\r\n              查找类似于foreach的本地化字符串无法在'{0}'上操作。您是否打算调用'{0}'？\r\n            \r\n","\r\n            Given an array of bound initializer expressions, this method converts these bound expressions\r\n            to array's element type and generates a BoundArrayInitialization with the converted initializers.\r\n            ":"\r\n            给定一系列绑定的初始器表达式，此方法转换了这些界表达式\r\n            对于数组的元素类型，并与转换的初始化器生成边界化。\r\n            \r\n","\r\n            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte unsigned integer value.\r\n            ":"\r\n            从文本和相应的4字节未签名的整数值中创建一个具有属性数字的令牌。\r\n            \r\n","\r\n             A trivia with kind WhitespaceTrivia containing a single space character.\r\n            ":"\r\n             具有单个空间特征的善良的琐事。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use local '{0}' in this context because it may expose referenced variables outside of their declaration scope.\r\n            ":"\r\n              在此上下文中查找类似于不能使用本地'{0}'的本地化字符串，因为它可以在其声明范围之外暴露引用变量。\r\n            \r\n","Called when the visitor visits a SwitchStatementSyntax node.":"访问者访问switchstatementsyntax节点时调用。\r\n","Class which represents the syntax node for tuple type.":"代表元组类型的语法节点的类。\r\n"," on the symbol, \r\n            the string might be null or an invalid guid representation. False, \r\n            if there is no ":" 在符号上，\r\n            字符串可能为null或无效的GUID表示。错误的，\r\n            如果没有\r\n","\r\n            This implements the same logic as ":"\r\n            这实现了与\r\n","\r\n            Map a language version (such as Default, Latest, or CSharpN) to a specific version (CSharpM).\r\n            ":"\r\n            将语言版本（例如默认版本，最新或CSHARPN）映射到特定版本（CSHARPM）。\r\n            \r\n","\r\n              Looks up a localized string similar to User-defined operator '{0}' must be declared static and public.\r\n            ":"\r\n              查找类似于用户定义的运算符'{0}'的本地化字符串必须被声明为静态和公共。\r\n            \r\n","\r\n            Might be a pointer type or a multiplication.\r\n            ":"\r\n            可能是指针类型或乘法。\r\n            \r\n","\r\n            Should only be called by ":"\r\n            只应由 \r\n","\r\n            Creates a threadsafty element within an xml documentation comment.\r\n            ":"\r\n            在XML文档注释中创建线程安全元素。\r\n            \r\n","The CallerFilePathAttribute will have no effect; it is overridden by the CallerLineNumberAttribute":"CallerFilePathAttribute无效；它被CallerlineNumberattribute覆盖\r\n","\r\n            A trivia with kind EndOfLineTrivia containing both the carriage return and line feed characters.\r\n            ":"带有携带返回和线条饲料字符的善良内膜的琐事。\r\n            \r\n","List of parameters of the anonymous method expression, or null if there no parameters are specified.":"匿名方法表达式的参数列表，如果没有指定参数，则为null。\r\n","Do not consider implementation in an interface as a valid candidate for the purpose of this computation.":"不要将界面中的实现视为该计算目的的有效候选者。\r\n","\r\n             Generate a thread-safe accessor for a WinRT field-like event.\r\n            \r\n             Add:\r\n               return EventRegistrationTokenTable<Event>.GetOrCreateEventRegistrationTokenTable(ref _tokenTable).AddEventHandler(value);\r\n            \r\n             Remove:\r\n               EventRegistrationTokenTable<Event>.GetOrCreateEventRegistrationTokenTable(ref _tokenTable).RemoveEventHandler(value);\r\n             ":"\r\n             为WinRT字段式事件生成线程安全登录器。\r\n            \r\n             添加：\r\n               返回EventRegistrationTokentable <epts> .getOrcreateeVentRegistrationTokentable（ref _tokentable）.addeventHandler（value）;\r\n            \r\n             消除：\r\n               EventRegistrationTokentable <epts> .getOrCreateeVentRegistrationTokentable（ref _tokentable）.removeEventHandler（value）;\r\n             \r\n","\r\n            Gets type information about an expression.\r\n            ":"\r\n            获取有关表达式的类型信息。\r\n            \r\n","\r\n            This should be nested inside ":"\r\n            这应该嵌套在里面\r\n","SyntaxToken representing the semicolon token.":"Syntaxtkoken代表半代币。\r\n","\r\n              Looks up a localized string similar to Auto-implemented 'set' accessor '{0}' cannot be marked 'readonly'..\r\n            ":"\r\n              查找类似于自动实现的“ set'concector'{0}'的本地化字符串，无法标记为'ReadOnly'..\r\n            \r\n","\r\n              Looks up a localized string similar to A static readonly field cannot be returned by writable reference.\r\n            ":"\r\n              查找类似于静态可读字段的本地化字符串，无法通过写入引用返回。\r\n            \r\n","Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement":"仅分配，呼叫，增量，减少，等待和新对象表达式可以用作语句\r\n","An expression tree may not contain an indexed property":"表达树可能不包含索引属性\r\n","\r\n            A member was found, but it was not callable\r\n            ":"\r\n            找到了一个成员，但不是可叫的\r\n            \r\n","\r\n              Looks up a localized string similar to Inherited interface '{1}' causes a cycle in the interface hierarchy of '{0}'.\r\n            ":"\r\n              查找类似于继承的接口'{1}'的本地化字符串在'{0}'的接口层次结构中导致一个周期。\r\n            \r\n","Creates a new ConstructorInitializerSyntax instance.":"创建一个新的constructorizersyntax实例。\r\n","A single node.":"一个节点。\r\n","\r\n            Returns an implicit type symbol for this namespace or null if there is none. This type\r\n            wraps misplaced global code.\r\n            ":"\r\n            如果没有，则返回此名称空间或空的隐式类型符号。这个类型\r\n            包装放置的全局代码。\r\n            \r\n","\r\n            An error/warning directive tells the compiler to indicate a syntactic error/warning\r\n            at the current location.\r\n            \r\n            Format: #error Error message string\r\n            Resulting message: from the first non-whitespace character after the directive\r\n            keyword until the end of the directive (aka EOD) at the line break or EOF.\r\n            Resulting span: [first non-whitespace char, EOD)\r\n            \r\n            Examples (pipes indicate span):\r\n            #error |goo|\r\n            #error  |goo|\r\n            #error |goo |\r\n            #error |goo baz|\r\n            #error |//goo|\r\n            #error |/*goo*/|\r\n            #error |/*goo|\r\n            ":"\r\n            错误/警告指令告诉编译器表示句法错误/警告\r\n            在当前位置。\r\n            \r\n            格式：#Error错误消息字符串\r\n            结果消息：指令之后的第一个非Whitespace字符\r\n            关键字，直到指令末尾（又名EOD）处于线路断裂或EOF处。\r\n            结果跨度：[第一个非Whitespace Char，EOD）\r\n            \r\n            示例（管道表示跨度）：\r\n            #Error | Goo |\r\n            #Error | Goo |\r\n            #Error | Goo |\r\n            #Error | Goo Baz |\r\n            #Error | //糟糕|\r\n            #Error |/*粘糊糊*/|\r\n            #Error |/*Goo |\r\n            \r\n","Expected a script (.csx file) but none specified":"期待脚本（.csx文件），但没有指定\r\n","\r\n              Looks up a localized string similar to Expression will always cause a System.NullReferenceException because the type's default value is null.\r\n            ":"\r\n              查找类似于表达式的本地化字符串将始终导致系统。NullReferenceException，因为该类型的默认值为null。\r\n            \r\n","\r\n            IsManagedType is simple for most named types:\r\n                enums are not managed;\r\n                non-enum, non-struct named types are managed;\r\n                generic types and their nested types are managed;\r\n                type parameters are managed;\r\n                all special types have spec'd values (basically, (non-string) primitives) are not managed;\r\n            \r\n            Only structs are complicated, because the definition is recursive.  A struct type is managed\r\n            if one of its instance fields is managed.  Unfortunately, this can result in infinite recursion.\r\n            If the closure is finite, and we don't find anything definitely managed, then we return true.\r\n            If the closure is infinite, we disregard all but a representative of any expanding cycle.\r\n            \r\n            Intuitively, this will only return true if there's a specific type we can point to that is would\r\n            be managed even if it had no fields.  e.g. struct S { S s; } is not managed, but struct S { S s; object o; }\r\n            is because we can point to object.\r\n            ":"\r\n            对于大多数命名类型，IsmanagedType很简单：\r\n                枚举没有管理；\r\n                非纳姆，非结构命名类型是管理的；\r\n                通用类型及其嵌套类型得到管理；\r\n                类型参数被管理；\r\n                所有特殊类型都有规格的值（基本上是（非弦乐）原语）均未管理；\r\n            \r\n            仅结构很复杂，因为定义是递归的。结构类型已管理\r\n            如果管理其中一个字段。不幸的是，这可能导致无限递归。\r\n            如果关闭是有限的，并且我们找不到任何肯定的管理，那么我们返回真实。\r\n            如果封闭是无限的，我们将除了任何扩展周期的代表外，都无视所有。\r\n            \r\n            直观地，这只有在我们可以指出的特定类型的情况下才能返回true\r\n            即使没有字段，也可以管理。例如struct s {s s; }不管理，而是结构s {s s;对象o; }\r\n            是因为我们可以指向对象。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid option '{0}' for /platform; must be anycpu, x86, Itanium or x64.\r\n            ":"\r\n              查找类似于 /平台的无效选项'{0}'的本地化字符串；必须是anycpu，x86，itanium或x64。\r\n            \r\n","\r\n            true if we should check to ensure that out parameters are assigned on every exit point.\r\n            ":"是的，如果我们应该检查以确保在每个出口点上分配OUT参数。\r\n            \r\n","\r\n            True if Optional flag is set in metadata.\r\n            ":"\r\n            如果在元数据中设置了可选标志，则为正确。\r\n            \r\n","\r\n            An extension method with the \"this\" parameter removed.\r\n            Used for the public binding API only, not for compilation.\r\n            ":"\r\n            删除了带有“此”参数的扩展方法。\r\n            仅用于公共绑定的API，而不是用于编译。\r\n            \r\n","The item specified is not the element of a list.":"指定的项目不是列表的元素。\r\n","\r\n            Lambda symbols are mapped to the NameTypeSymbol of the delegate type they were reinferred to,\r\n            and are stored with a null node. The LambdaSymbol itself is position-independent, and does not\r\n            need any more information to serve as a key.\r\n            All other symbol types are stored mapped to exactly the same type as was provided.\r\n            ":"\r\n            lambda符号被映射到被重新赋予的代表类型的名称符合符号，\r\n            并用空节点存储。 lambdasymbol本身是独立于位置的，并且不是\r\n            需要更多信息来充当关键。\r\n            所有其他符号类型都映射到与提供的完全相同类型的映射。\r\n            \r\n","\r\n            As in dev11, we ignore the fact that CLSCompliantAttribute is inherited (i.e. from the base type)\r\n            (see CSemanticChecker::CheckSymForCLS).  This should only affect types where the syntactic parent\r\n            and the inheritance parent disagree.\r\n            ":"\r\n            与Dev11一样，我们忽略了ClsCompliantAttribute是继承的事实（即基本类型）\r\n            （请参阅csemanticchecker :: CheckSymForCls）。这只能影响句法父母的类型\r\n            继承父母不同意。\r\n            \r\n","\r\n            Combine the receiver and arguments of an extension method\r\n            invocation into a single argument list to allow overload resolution\r\n            to treat the invocation as a static method invocation with no receiver.\r\n            ":"\r\n            结合扩展方法的接收器和参数\r\n            调用单个参数列表以允许超载分辨率\r\n            将调用视为无接收器的静态方法调用。\r\n            \r\n","\r\n            The flow analysis state at each label, computed by merging the state from branches to\r\n            that label with the state when we fall into the label.  Entries are created when the\r\n            label is encountered.  One case deserves special attention: when the destination of the\r\n            branch is a label earlier in the code, it is possible (though rarely occurs in practice)\r\n            that we are changing the state at a label that we've already analyzed. In that case we\r\n            run another pass of the analysis to allow those changes to propagate. This repeats until\r\n            no further changes to the state of these labels occurs.  This can result in quadratic\r\n            performance in unlikely but possible code such as this: \"int x; if (cond) goto l1; x =\r\n            3; l5: print x; l4: goto l5; l3: goto l4; l2: goto l3; l1: goto l2;\"\r\n            ":"\r\n            每个标签处的流量分析状态，通过将状态从分支合并到\r\n            当我们跌入标签时，该标签与状态。当\r\n            遇到标签。一个案子值得特别注意：当目的地的目的地\r\n            分支是代码早期的标签，这是可能的（尽管在实践中很少发生）\r\n            我们正在通过已经分析的标签更改状态。在这种情况下，我们\r\n            运行另一个分析的通过，以允许这些更改传播。这重复直到为止\r\n            这些标签的状态没有进一步的变化。这可能导致二次\r\n            以下不太可能但可能的代码性能：“ int x; if（cond）goto l1; x =\r\n            3; L5：打印x； L4：goto l5; L3：goto l4; L2：goto l3; L1：goto l2;”\r\n            \r\n","Ambiguous user defined conversions '{0}' and '{1}' when converting from '{2}' to '{3}'":"模棱两可的用户定义转换'{0}'和'{1}'从'{2}'转换为'{3}'\r\n","\r\n            Summarizes whether a conversion is allowed, and if so, which kind of conversion (and in some cases, the\r\n            associated symbol).\r\n            ":"总结是否允许转换，如果是，则是哪种转换（在某些情况下，\r\n            相关符号）。\r\n            \r\n","\r\n            This class is derived from ":"\r\n            此课程是从\r\n","\r\n            Check that the property and its getter exist and collect any use-site errors.\r\n            ":"\r\n            检查该属性及其Getter是否存在并收集任何用途错误。\r\n            \r\n","\r\n            NOTE: any member overridden by this binder should follow the BuckStopsHereBinder pattern.\r\n            Otherwise, a subsequent binder in the chain could suppress the caching behavior.\r\n            ":"\r\n            注意：此活页夹覆盖的任何成员均应遵循BuckStopShereBinder模式。\r\n            否则，链中的随后的粘合剂可以抑制缓存行为。\r\n            \r\n","Body for implementedMethod.":"实施的身体。\r\n","\r\n            Creates a new syntax tree from a syntax node with text that should correspond to the syntax node.\r\n            ":"\r\n            从具有文本的语法节点中创建一个新的语法树，应与语法节点相对应。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': cannot specify both a constraint class and the 'unmanaged' constraint.\r\n            ":"查找类似于“ {0}'：不能指定约束类别和“未管理”约束的本地化字符串。\r\n            \r\n","\r\n            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte unsigned integer value.\r\n            ":"\r\n            从文本和相应的8字节无签名的整数值中创建一个具有属性数字的令牌。\r\n            \r\n","Type that already has custom modifiers.":"已经具有自定义修饰符的类型。\r\n","\r\n            If the declaring type is constructed, it's possible that two (or more) members have the same signature\r\n            (including custom modifiers).  Return a list of such members so that we can report the ambiguity.\r\n            ":"\r\n            如果构建声明类型，则可能有两个（或更多）成员具有相同的签名\r\n            （包括自定义修饰符）。返回此类成员的列表，以便我们可以报告歧义。\r\n            \r\n","'{0}': only CLS-compliant members can be abstract":"'{0}'：只有符合CLS的成员才能抽象\r\n","\r\n              Looks up a localized string similar to The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'. Nullable types can not satisfy any interface constraints..\r\n            ":"\r\n              在通用类型或方法'{0}'中查找类似于类型的'{3}'类型的本地化字符串。无效的类型'{3}'不满足'{1}'的约束。无效的类型无法满足任何接口约束。\r\n            \r\n","Diagnostic bag for diagnostics":"诊断诊断袋\r\n","\r\n            Binding info for expressions and statements that are part of a member declaration.\r\n            ":"\r\n            绑定属于会员声明一部分的表达式和陈述的信息。\r\n            \r\n","\r\n            Returns true if the type is a valid constraint type.\r\n            Otherwise returns false and generates a diagnostic.\r\n            ":"\r\n            如果类型是有效的约束类型，则返回true。\r\n            否则返回false并生成诊断。\r\n            \r\n","\r\n            Returns true if the conversion is an implicit nullable conversion or explicit nullable conversion.\r\n            ":"\r\n            如果转换是可隐式的无效转换或明确的无效转换，则返回true。\r\n            \r\n","\r\n            When binding imports in scripts/submissions, using aliases (other than from the current submission)\r\n            are considered but other imports are not.\r\n            ":"\r\n            在脚本/提交中绑定导入时，使用别名（除当前提交外）\r\n            被考虑，但其他进口却没有。\r\n            \r\n","\r\n             Decompose the underlying tuple type into its links and store them into the underlyingTupleTypeChain.\r\n            \r\n             For instance, ValueTuple<..., ValueTuple< int >> (the underlying type for an 8-tuple)\r\n             will be decomposed into two links: the first one is the entire thing, and the second one is the ValueTuple< int >\r\n             ":"\r\n             将基础元组类型分解到其链接中，并将其存储到基础上。\r\n            \r\n             例如，valuetuple <...，valuetuple <int >>（8核心的基础类型）\r\n             将分解为两个链接：第一个是整个链接，第二个是valuetuple <int>\r\n             \r\n","\r\n            Return source declaration symbols whose name matches the provided name.  This will be\r\n            faster than ":"\r\n            返回源声明符号的名称与提供的名称匹配。这将是\r\n            比...快\r\n","\r\n            Returns true if the conversion is an implicit user-defined conversion or explicit user-defined conversion.\r\n            ":"\r\n            如果转换是隐式用户定义的转换或明确的用户定义的转换，则返回true。\r\n            \r\n","\r\n            If this is a partial method declaration without a body, and the method also\r\n            has a part that implements it with a body, returns that implementing\r\n            definition.  Otherwise null.\r\n            ":"\r\n            如果这是没有身体的部分方法声明，则该方法也\r\n            具有将其实现的零件，返回实施\r\n            定义。否则为空。\r\n            \r\n",", \r\n            which might return locations of partial methods.\r\n            ":"，，，，\r\n            这可能会返回部分方法的位置。\r\n            \r\n","Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.":"提供代表类型语法节点的类的基类。这是一个抽象类。\r\n","\r\n              Looks up a localized string similar to Attribute '{0}' is not valid on property or event accessors. It is only valid on '{1}' declarations..\r\n            ":"\r\n              查找类似于属性'{0}'的本地化字符串在属性或事件访问器上无效。它仅在“ {1}”声明上有效。\r\n            \r\n","\r\n              Looks up a localized string similar to Duplicate initialization of member '{0}'.\r\n            ":"\r\n              查找类似于成员'{0}'的重复初始化的本地化字符串。\r\n            \r\n","\r\n            Doesn't include fixed statement address-of operands.\r\n            ":"\r\n            不包括固定语句操作数。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot reference 'System.Runtime.CompilerServices.TupleElementNamesAttribute' explicitly. Use the tuple syntax to define tuple names..\r\n            ":"\r\n              查找类似于无法引用'system.runtime.compilerservices.tupleelementnamesattribute'的本地化字符串。使用元组语法定义元组名称。\r\n            \r\n","Major version":"主要版本\r\n"," Region to be used ":" 要使用的区域\r\n","\r\n              Looks up a localized string similar to Failed to emit module '{0}'..\r\n            ":"\r\n              查找类似于失败的局部字符串，以发射模块'{0}'..\r\n            \r\n","\r\n            This method determines if an applied attribute must be emitted.\r\n            Some attributes appear in symbol model to reflect the source code,\r\n            but should not be emitted.\r\n            ":"\r\n            此方法确定是否必须发出应用属性。\r\n            一些属性出现在符号模型中以反映源代码，\r\n            但不应该发出。\r\n            \r\n","Creates a new LineSpanDirectiveTriviaSyntax instance.":"创建一个新的linesPandirectiviviaSyntax实例。\r\n","\r\n            If we are tracking exceptions, then by convention the first entry in the pending branches\r\n            buffer contains a summary of the states that can arise from exceptions.\r\n            ":"\r\n            如果我们正在跟踪异常\r\n            缓冲区包含可能从例外引起的状态的摘要。\r\n            \r\n",", a consumer can determine\r\n            if the InvalidCharacter was in the user's source or a sentinel.\r\n            \r\n            Comments and string literals are allowed to contain any Unicode character.\r\n            ":"，消费者可以确定\r\n            如果无效的charracter在用户的源或哨兵中。\r\n            \r\n            注释和字符串文字被允许包含任何Unicode字符。\r\n            \r\n","The dynamically dispatched call to method '{0}' may fail at runtime because one or more applicable overloads are conditional methods.":"动态调用对方法'{0}'可能会在运行时失败，因为一个或多个适用的过载是条件方法。\r\n","Cannot await in the filter expression of a catch clause":"无法在捕获子句的过滤器表达中等待\r\n","\r\n            Returns false because module can't be sealed.\r\n            ":"\r\n            返回错误，因为模块无法密封。\r\n            \r\n","The type parameter '{0}' cannot be used with the 'as' operator because it does not have a class type constraint nor a 'class' constraint":"类型参数'{0}'不能与'AS'运算符一起使用，因为它没有类类型约束或“类”约束\r\n","\r\n              Looks up a localized string similar to A null literal introduces a null value for a type parameter..\r\n            ":"\r\n              查找类似于null文字的本地化字符串引入了类型参数的空值。\r\n            \r\n","The implementing property or null, if there isn't one.":"实现属性或 null，如果没有的话。\r\n","The property or indexer '{0}' cannot be used in this context because the set accessor is inaccessible":"在此上下文中无法使用属性或索引器'{0}'，因为SET访问者无法访问\r\n","\r\n              Looks up a localized string similar to Method '{0}' specifies a 'class' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a reference type..\r\n            ":"\r\n              查找类似于方法'{0}'的本地化字符串指定类型参数'{1}'的'class'约束，但是相应的类型参数'{2}'{2}'的被覆盖或明确实现的方法'{3}'是参考类型..\r\n            \r\n","The visited symbol":"访问的符号\r\n","\r\n            Make a local variable symbol whose type can be inferred (if necessary) by binding and enclosing construct.\r\n            ":"\r\n            制作一个局部变量符号，可以通过绑定和封闭构造来推断（如有必要）的类型。\r\n            \r\n","\r\n             are mutually recursive. The non-recursive parts of this method tend to reserve significantly large \r\n             stack frames due to their use of large struct like ":"\r\n             是相互递归的。该方法的非恢复部分倾向于保留很大的\r\n             由于使用大型结构，例如\r\n","\r\n            Some `finally` clauses may have already been rewritten and extracted to a plain block (":"\r\n            一些最终的条款可能已经重写并提取到一个普通的块（\r\n","Creates a new GenericNameSyntax instance.":"创建一个新的GenericNamesyntax实例。\r\n","Invalid #pragma checksum syntax":"无效的#pragma校验和语法\r\n","\r\n            List of assemblies lookup has already visited (since type forwarding can introduce cycles).\r\n            ":"\r\n            集会查找列表已经访问过（因为类型转发可以引入周期）。\r\n            \r\n","\r\n            Returns true if the type is one of the restricted types, namely: ":"\r\n            如果类型是受限类型之一，则返回true，即：\r\n","\r\n            Return the arity of a member.\r\n            ":"\r\n            返回会员的贫苦。\r\n            \r\n"," tree the only information available is\r\n            ":" 树唯一可用的信息是\r\n            \r\n","'{0}': type used in an asynchronous using statement must be implicitly convertible to 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method. Did you mean 'using' rather than 'await using'?":"'{0}'：使用语句中的异步中使用的类型必须隐式转换为'system.iasyncdisposable'或实现合适的“ disposeasync”方法。您的意思是“使用”而不是“等待使用”？\r\n","Optionally, expand ":"可选，扩展\r\n","Argument {0} must be passed with the '{1}' keyword":"参数{0}必须用'{1}'关键字传递\r\n","The call is ambiguous between the following methods or properties: '{0}' and '{1}'":"呼叫在以下方法或属性之间是模棱两可的：'{0}'和'{1}'\r\n","\r\n            Generate implementation-specific state machine member method implementations.\r\n            ":"\r\n            生成实现特定状态机器成员方法实现。\r\n            \r\n","\r\n            Changes in this function should be mirrored in ":"\r\n            此功能的更改应镜像\r\n","\r\n              Looks up a localized string similar to  The parameter modifier '{0}' cannot be used with '{1}'.\r\n            ":"\r\n              查找类似于参数修饰符'{0}'的本地化字符串，不能与'{1}'一起使用。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot pass argument with dynamic type to generic local function '{0}' with inferred type arguments..\r\n            ":"\r\n              查找类似于类似于动态类型的参数的本地化字符串与通用本地函数'{0}'，带推断类型参数。\r\n            \r\n","\r\n            At the local function's use site, checks that all variables read\r\n            are assigned and assigns all variables that are definitely assigned\r\n            to be definitely assigned.\r\n            ":"\r\n            在本地函数的使用网站上，检查所有变量是否读取\r\n            分配并分配了绝对分配的所有变量\r\n            绝对分配。\r\n            \r\n","\r\n            Builds an array of public type symbols defined in netmodules included in the compilation\r\n            and type forwarders defined in this compilation or any included netmodule (in this order).\r\n            ":"\r\n            构建编辑中包含的NetModules中定义的一系列公共类型符号\r\n            和类型在本汇编或任何包含的NetModule中定义的转发器（按照此顺序）。\r\n            \r\n","Array type specifier, [], must appear before parameter name":"数组类型指定符[]必须出现在参数名称之前\r\n","The Conditional attribute is not valid on interface members":"条件属性在接口成员上无效\r\n","\r\n            Abstract base class for mutable and immutable type maps.\r\n            ":"\r\n            可变和不可变型地图的抽象基类。\r\n            \r\n"," is always true unless we jump from after \r\n            the beginning of a scope, to a point in between the beginning of the parent scope, and the beginning of the scope\r\n            ":" 除非我们从之后跳下来，否则总是正确的\r\n            范围的开始，到父范围的开头和范围的开始之间\r\n            \r\n","\r\n            Represents a compiler generated field.\r\n            ":"\r\n            代表编译器生成的字段。\r\n            \r\n","\r\n              Looks up a localized string similar to A 'using static' directive cannot be used to declare an alias.\r\n            ":"\r\n              查找类似于“使用静态”指令类似的本地化字符串，不能用于声明别名。\r\n            \r\n","\r\n            Basically, what we need to know is, if an exception occurred within the fixed statement, would\r\n            additional code in the current method be executed before its stack frame was popped?\r\n            ":"\r\n            基本上，我们需要知道的是，如果固定语句中发生异常，\r\n            在弹出堆栈框架之前，在当前方法中执行其他代码？\r\n            \r\n","\r\n            Keep check and error in sync with ConstructNamedTypeUnlessTypeArgumentOmitted.\r\n            ":"\r\n            与constructNamedTypeunlessTylessTypeartose的构造和错误保持检查和错误。\r\n            \r\n"," containing the label in its body.\r\n            ":" 在其体内包含标签。\r\n            \r\n"," API, this method returns the \"Body\" part\r\n            of the MethodImpl entry, i.e. the method that implements the ":" API，此方法返回“身体”部分\r\n            方法IMPL条目，即实施的方法\r\n","Struct type declaration syntax.":"结构类型声明语法。\r\n","\r\n              Looks up a localized string similar to The constant '{0}' cannot be marked static.\r\n            ":"\r\n              查找类似于常数'{0}'的局部字符串，不能标记为静态。\r\n            \r\n","\r\n            Compute the \"effective accessibility\" of the current class for the purpose of warnings about unused fields.\r\n            ":"\r\n            计算当前课程的“有效可访问性”，目的是针对未使用领域的警告。\r\n            \r\n","\r\n              Looks up a localized string similar to Error reading file '{0}' specified for the named argument '{1}' for PermissionSet attribute: '{2}'.\r\n            ":"\r\n              查找类似于错误读取文件'{0}'的本地化字符串，为permissionset属性：'{2}'指定的命名参数'{1}'。\r\n            \r\n","\r\n              Looks up a localized string similar to The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'.\r\n            ":"\r\n              查找类似于'{0}'类型的'{1}'与命名空间'{3}'中的类型的本地化字符串。\r\n            \r\n","Use of possibly unassigned field '{0}'":"使用可能未分配的字段'{0}'\r\n","\r\n              Looks up a localized string similar to The specified version string does not conform to the required format - major[.minor[.build[.revision]]].\r\n            ":"\r\n              查找类似于指定版本字符串的本地化字符串不符合所需的格式-Maine [.minor [.build [.revision]]]。\r\n            \r\n","Interop type '{0}' cannot be embedded. Use the applicable interface instead.":"Interop类型'{0}'无法嵌入。改用适用的接口。\r\n","CLS-compliant field cannot be volatile":"符合CLS的字段不能挥发\r\n","\r\n            If two (or more) fixed statements are nested, then we want to avoid having the outer\r\n            fixed statement re-traverse the lowered bound tree of the inner one.  We accomplish\r\n            this by having each fixed statement cache a set of unmatched gotos that can be\r\n            reused by any containing fixed statements.\r\n            ":"\r\n            如果两个（或更多）固定语句是嵌套的，那么我们要避免使用外部\r\n            固定语句重新介绍了内部的较低的绑定树。我们完成了\r\n            通过让每个固定语句缓存一组无与伦比的gotos可以是\r\n            由任何包含固定语句的任何内容重复使用。\r\n            \r\n","The class System.Object cannot have a base class or implement an interface":"类System.Object不能具有基类或实现接口\r\n","SeparatedSyntaxList of TypeSyntax node representing the type arguments.":"代表类型参数的typeyntax节点的分离列表列表。\r\n","\r\n              Looks up a localized string similar to await in catch blocks and finally blocks.\r\n            ":"\r\n              查找类似于捕获块的局部字符串，最后是块。\r\n            \r\n","\r\n            Determines if two lists of syntax nodes are the same, disregarding trivia differences.\r\n            ":"\r\n            确定语法节点的两个列表是否相同，无视琐事差异。\r\n            \r\n","The symbol for which to retrieve documentation comments.":"检索文档评论的符号。\r\n","\r\n            Generate the body for ":"\r\n            产生身体\r\n","Expected contextual keyword 'on'":"预期上下文关键字“ on”\r\n","\r\n            Checks if 'symbol' is accessible from within 'within', which must be a NamedTypeSymbol\r\n            or an AssemblySymbol. \r\n            ":"\r\n            检查是否可以从“内部”内部访问“符号”，这必须是名为tytypesymbol\r\n            或组件符号。\r\n            \r\n","CSharpSyntaxNode of the expression requiring method group conversion.":"需要方法组转换的表达式的csharpsyntaxnode。\r\n","\r\n            Synthesizes an expression that evaluates to the index of a source document in the table of debug source documents.\r\n            ":"\r\n            合成一个表达式，该表达式评估了调试源文档表中源文档的索引。\r\n            \r\n","\r\n              Looks up a localized string similar to The pathmap option was incorrectly formatted..\r\n            ":"\r\n              查找类似于Pathmap选项的本地化字符串的格式不正确。\r\n            \r\n","\r\n            Gets the \"MoveNext\" method (or \"MoveNextAsync\" in an asynchronous foreach).\r\n            ":"\r\n            在异步方面获取“ moveNext”方法（或“ moveNextAsync”）。\r\n            \r\n","If is true, then we produce a special diagnostic if the\r\n            open brace is missing.":"如果是真的，那么我们会产生一个特殊的诊断\r\n            缺少开放式支撑。\r\n","'{0}' duplicate named attribute argument":"'{0}'重复命名属性参数\r\n","Represents a labeled statement syntax.":"代表标记的语句语法。\r\n","\r\n            Creates a see element within an xml documentation comment.\r\n            ":"\r\n            在XML文档注释中创建一个See元素。\r\n            \r\n","The given simple name updated with the given identifier.":"给定的简单名称使用给定标识符更新。\r\n","Arguments for constraints checking.":"约束检查的论点。\r\n","The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion from '{3}' to '{1}'.":"类型'{3}'在通用类型或方法'{0}'中不能用作类型参数'{2}'。没有从“ {3}”到'{1}'的拳击转换。\r\n","\r\n            Recognizes constructors known to not have side-effects (which means they can be skipped unless the constructed object is used)\r\n            ":"\r\n            识别已知没有副作用的构造函数（这意味着可以跳过，除非使用构造的对象）\r\n            \r\n","\r\n            A value of type nint may, in a 64-bit runtime, take on values less than ":"\r\n            NINT类型的值可能在64位运行时，将值少于小于\r\n","\r\n              Looks up a localized string similar to Invalid real literal..\r\n            ":"\r\n              查找类似于无效的真实文字的本地化字符串。\r\n            \r\n"," makes multiple calls\r\n            to this function, only one result is observable.\r\n            ":" 拨打多个电话\r\n            对于此功能，只能观察到一个结果。\r\n            \r\n","Indicates whether the current Range object is equal to another Range object.":"指示当前范围对象是否等于另一个范围对象。\r\n","Invalid rank specifier: expected ',' or ']'":"无效等级规范符：预期'，'或']'\r\n","Plain text name":"纯文本名称\r\n","\r\n            This is the entry point for foreach-loop lowering.  It delegates to\r\n              RewriteEnumeratorForEachStatement\r\n              RewriteSingleDimensionalArrayForEachStatement\r\n              RewriteMultiDimensionalArrayForEachStatement\r\n              RewriteStringForEachStatement\r\n            ":"\r\n            这是用于降低座环的切入点。它委派\r\n              重写EnumeratorForeachStatement\r\n              重写少量驱动器宣传\r\n              重新构成二维的arrayForeachStatement\r\n              重新流通林申请\r\n            \r\n","\r\n            Corresponds to Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags.\r\n            ":"\r\n            对应于Microsoft.csharp.runtimebinder.csharpargumentInfoflags。\r\n            \r\n","\r\n            BoundExpressions to be used for emit. The expressions are assumed\r\n            to be lowered and will not be visited by ":"\r\n            用于发射的绑定表达式。假定表达式\r\n            要降低，不会被访问\r\n","\r\n            True if we were able to optimize the ":"\r\n            如果我们能够优化\r\n","\r\n            Releases a local.\r\n            ":"\r\n            释放本地。\r\n            \r\n","Cannot use a negative size with stackalloc":"无法使用Stackalloc使用负大小\r\n","\r\n            The default language version, which is the latest supported version.\r\n            ":"默认语言版本，这是最新的支持版本。\r\n            \r\n","\r\n            Makes a second attempt if the results are not viable, in order to produce more detailed failure information (symbols and diagnostics).\r\n            ":"\r\n            如果结果不可行，则进行第二次尝试，以产生更详细的失败信息（符号和诊断）。\r\n            \r\n","XML comment has badly formed XML -- '{0}'":"XML评论的形成不佳XML  - '{0}'\r\n","Creates a new OperatorMemberCrefSyntax instance.":"创建一个新的OperatorTormemberCrefsyntax实例。\r\n","New compiler options (-publicsign and -pathmap)":"新编译器选项（-publicsign和-pathmap）\r\n","Creates a new SimpleBaseTypeSyntax instance.":"创建一个新的SimpleBaseTypesyntax实例。\r\n","Creates a new XmlNameAttributeSyntax instance.":"创建一个新的XMLNAGEATTRIBUTESYNTAX实例。\r\n","\r\n            Look up the assembly to which the given metadata type is forwarded.\r\n            ":"\r\n            查找给定的元数据类型被转发到的组件。\r\n            \r\n","\r\n              Looks up a localized string similar to The class System.Object cannot have a base class or implement an interface.\r\n            ":"\r\n              查找类似于类系统的本地化字符串。对象不能具有基类或实现接口。\r\n            \r\n","The reference was explicitly specified in syntax.":"该引用是在语法中明确指定的。\r\n","\r\n            Derive use-site info from a type symbol.\r\n            ":"\r\n            从类型符号中得出用途信息。\r\n            \r\n","Pattern matching enhancements":"图案匹配增强\r\n","\r\n              Looks up a localized string similar to '{0}': instance field in types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute.\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串：用structlayout标记的类型中的实例字段（layoutkind.explicit）必须具有fieldOffset属性。\r\n            \r\n","\r\n            NOTE: not generally set in rewriters.\r\n            ":"\r\n            注意：通常不设置在重写者中。\r\n            \r\n","If true, use ":"如果是真的，请使用\r\n","\r\n            Top level nullability for the node. This should not be used by flow analysis.\r\n            ":"\r\n            节点的最高效率。流量分析不应使用这。\r\n            \r\n","\r\n              Looks up a localized string similar to Added modules must be marked with the CLSCompliant attribute to match the assembly.\r\n            ":"\r\n              查找类似于添加模块的本地化字符串必须用CLSCompliant属性标记以匹配组件。\r\n            \r\n","Nullability of reference types in return type doesn't match implicitly implemented member.":"返回类型中的参考类型的无效性不匹配隐式实现的成员。\r\n","\r\n             The representation of a deconstruction as a tree of Deconstruct methods and conversions.\r\n             Methods only appear in non-terminal nodes. All terminal nodes have a Conversion.\r\n            \r\n             Here's an example:\r\n             A deconstruction like ":"\r\n             解构为解构方法和转换的树的表示。\r\n             方法仅出现在非末端节点中。所有端子节点均具有转换。\r\n            \r\n             这是一个例子：\r\n             像这样的解构\r\n","SyntaxToken representing the SizeOfKeyword.":"Syntaxtoken表示SizeOfKeyword。\r\n","A syntax node that represents a parsed statement. This statement should not be\r\n            present in the syntax tree associated with this object.":"表示解析语句的语法节点。这个声明不应该是\r\n            存在与此对象关联的语法树中。\r\n","\r\n              Looks up a localized string similar to The given expression is always of the provided ('{0}') type.\r\n            ":"\r\n              查找类似于给定表达式的本地化字符串始终是提供的（{0}'）类型。\r\n            \r\n","\r\n            Returns true if the conversion is an interpolated string conversion.\r\n            ":"\r\n            如果转换是插值的字符串转换，则返回true。\r\n            \r\n","\r\n            NOTE: If we are decoding a well-known attribute that could be queried by the binder, consider decoding it during early decoding pass.\r\n            ":"\r\n            注意：如果我们正在解码粘合剂可以查询的知名属性，请考虑在早期解码过程中解码它。\r\n            \r\n","The variable":"变量\r\n","\r\n            Returns interface events explicitly implemented by this event.\r\n            ":"\r\n            返回此事件明确实现的接口事件。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use a negative size with stackalloc.\r\n            ":"\r\n              查找类似于stackalloc的局部字符串不能使用负大小。\r\n            \r\n"," level.\r\n            The result indicates whether the escape is possible. \r\n            Additionally, the method emits diagnostics (possibly more than one, recursively) that would help identify the cause for the failure.\r\n            \r\n            NOTE: we need scopeOfTheContainingExpression as some expressions such as optional ":" 等级。\r\n            结果表明逃脱是否可能。\r\n            此外，该方法会发出诊断（可能是递归的），这将有助于确定失败的原因。\r\n            \r\n            注意：我们需要范围内表达作为一些表达式（例如可选）\r\n","\r\n              Looks up a localized string similar to Expression expected after yield return.\r\n            ":"\r\n              查找与收益率回报后预期的表达式相似的局部字符串。\r\n            \r\n","\r\n            Noteworthy override is in MemberSemanticModel.IncrementalBinder (used for caching).\r\n            ":"\r\n            值得注意的覆盖物在Membormemanticmodel.incrementalbinder（用于缓存）中。\r\n            \r\n","\r\n              Looks up a localized string similar to No suitable 'Deconstruct' instance or extension method was found for type '{0}', with {1} out parameters and a void return type..\r\n            ":"\r\n              查找一个类似于类型的“ {0}”的本地化字符串类似于未找到合适的“解构”实例或扩展方法，{1} out参数和void return类型。\r\n            \r\n"," with scope in the second.\r\n            ":" 在第二个范围内。\r\n            \r\n","\r\n              Looks up a localized string similar to Type parameters are not allowed on a method group as an argument to 'nameof'..\r\n            ":"\r\n              查找类似于类型参数的本地化字符串在方法组上不允许作为“名称”的参数。\r\n            \r\n","\r\n              Looks up a localized string similar to Possible null reference assignment..\r\n            ":"\r\n              查找类似于可能的null参考分配的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Can only use array initializer expressions to assign to array types. Try using a new expression instead..\r\n            ":"\r\n              查找类似于类似的本地化字符串，只能使用数组初始化器表达式分配给数组类型。尝试使用新表达式。\r\n            \r\n","Unboxing a possibly null value.":"拆箱可能的空值。\r\n","\r\n              Looks up a localized string similar to async main.\r\n            ":"\r\n              查找类似于异步主的局部字符串。\r\n            \r\n","\r\n            If this module forwards the given type to another assembly, return that assembly;\r\n            otherwise, return null.\r\n            ":"\r\n            如果此模块将给定类型转发到另一个组件上，请返回该组件；\r\n            否则，返回null。\r\n            \r\n","\r\n              Looks up a localized string similar to covariantly.\r\n            ":"\r\n              查找类似于协变量的本地化字符串。\r\n            \r\n","\r\n            Helps create a tuple type from source.\r\n            ":"\r\n            有助于从源创建元组类型。\r\n            \r\n"," rooted at this node, preserving this node's reference identity.\r\n            ":" 扎根于该节点，保留该节点的参考标识。\r\n            \r\n","\r\n              Looks up a localized string similar to 'is' expression's given expression is never of the provided type.\r\n            ":"\r\n              查找类似于“ IS”表达式表达式的本地化字符串从来都不是提供的类型。\r\n            \r\n","\r\n            Creates a SemanticModel for a true field initializer (field = value) of a named type (incl. Enums).\r\n            ":"\r\n            为命名类型的真实字段初始化器（field =值）创建一个semanticmodel（含量）。\r\n            \r\n","\r\n            Creates a token with kind NumericLiteralToken from an 8-byte signed integer value.\r\n            ":"\r\n            从8字节签名的整数值中创建具有属性数字的令牌。\r\n            \r\n","\"":"“\r\n","\r\n              Looks up a localized string similar to An assembly with the same simple name '{0}' has already been imported. Try removing one of the references (e.g. '{1}') or sign them to enable side-by-side..\r\n            ":"\r\n              查找类似于带有相同简单名称'{0}'的汇编的本地化字符串。尝试删除其中一个参考文献（例如'{1}'）或签名以并排启用。\r\n            \r\n","\r\n            Syntax node that is used as the scope designator. Otherwise, null.\r\n            ":"\r\n            语法节点用作示波器指定器。否则，null。\r\n            \r\n","\r\n            Returns true if the type is a readonly struct\r\n            ":"\r\n            如果类型是可读结构，则返回true\r\n            \r\n","\r\n            Produce a duplicate of this flow analysis state.\r\n            ":"\r\n            产生该流量分析状态的重复。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have matching return by reference..\r\n            ":"\r\n              查找类似于“ {0}'的本地化字符串”不实现接口成员'{1}'。 '{2}'无法实现'{1}'，因为它没有通过参考的匹配返回。\r\n            \r\n","\r\n            Helper method to generate a lowered conversion from the given ":"\r\n            辅助方法是从给定的\r\n","SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.":"参数的分离字母列表，代表参数列表。\r\n","\r\n              Looks up a localized string similar to The CallerMemberNameAttribute may only be applied to parameters with default values.\r\n            ":"\r\n              查找类似于callermemberneattribute的本地化字符串只能应用于具有默认值的参数。\r\n            \r\n",", we want to prefer the one that matches, even\r\n            if the runtime doesn't.\r\n            ":"，我们想更喜欢与之匹配的那个\r\n            如果运行时没有。\r\n            \r\n","\r\n            Returns true if this symbol is \"virtual\", has an implementation, and does not override a\r\n            base class member; i.e., declared with the \"virtual\" modifier. Does not return true for\r\n            members declared as abstract or override.\r\n            ":"\r\n            如果此符号为“虚拟”，具有实现，并且不会覆盖A，则返回true\r\n            基类成员；即，用“虚拟”修饰符声明。不返回true\r\n            成员宣布为抽象或覆盖。\r\n            \r\n","Expected 'disable' or 'restore' after #pragma warning":"#pragma警告后预期的“禁用”或“还原”\r\n","\r\n            Nullable type parameter. The underlying TypeSymbol is resolved\r\n            lazily to avoid cycles when binding declarations.\r\n            ":"\r\n            无效类型参数。基础类型符号已解决\r\n            懒洋洋地避免在结合声明时循环。\r\n            \r\n","\r\n            If the property has a GetMethod, return that.  Otherwise check the overridden\r\n            property, if any.  Repeat for each overridden property.\r\n            ":"\r\n            如果该物业有getMethod，请返回。否则检查被覆盖\r\n            属性，如果有的话。重复每个覆盖属性。\r\n            \r\n","A list of syntax nodes that represents the content of the para element.":"表示Para元素内容的语法节点列表。\r\n","\r\n            Traverses the symbol table checking for CLS compliance.\r\n            ":"\r\n            遍历CLS合规性检查符号表。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid variance modifier. Only interface and delegate type parameters can be specified as variant..\r\n            ":"\r\n              查找类似于无效方差修饰符的局部字符串。只能将接口和委托类型参数指定为变体。\r\n            \r\n","Unsafe code may only appear if compiling with /unsafe":"不安全的代码只有在与 /不安全的编译时出现\r\n","'{0}': cannot override because '{1}' is not a property":"'{0}'：不能覆盖，因为'{1}不是属性\r\n","\r\n            Assuming that nullable annotations are enabled:\r\n            T => true\r\n            T where T : struct => false\r\n            T where T : class => false\r\n            T where T : class? => true\r\n            T where T : IComparable => true\r\n            T where T : IComparable? => true\r\n            ":"\r\n            假设启用了无效的注释：\r\n            t => true\r\n            t其中t：struct => false\r\n            t其中t：class => false\r\n            t在哪里：上课？ => true\r\n            t其中t：iComable => true\r\n            t t：可观的？ => true\r\n            \r\n","\r\n              Looks up a localized string similar to The first parameter of a 'ref' extension method '{0}' must be a value type or a generic type constrained to struct..\r\n            ":"查找类似于“ Ref”扩展方法'{0}'的第一个参数的本地化字符串，必须是一个值类型或限制为结构的通用类型。\r\n            \r\n","\r\n            Check that every rvalue has been converted in the definite assignment pass only (not later passes deriving from it).\r\n            ":"\r\n            检查是否仅在确定的分配通行证中转换了每个RVALUE（不要以后从其派生）。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot specify a default value for the 'this' parameter.\r\n            ":"\r\n              查找类似于类似的本地化字符串无法指定“ this”参数的默认值。\r\n            \r\n","\r\n              Looks up a localized string similar to An __arglist expression may only appear inside of a call or new expression.\r\n            ":"\r\n              查找类似于__arglist表达式类似的本地化字符串只能出现在呼叫或新表达式中。\r\n            \r\n","\r\n              Looks up a localized string similar to Branches of a ref conditional operator cannot refer to variables with incompatible declaration scopes.\r\n            ":"\r\n              查找类似于RED条件运算符的分支类似的本地化字符串，无法指出具有不兼容声明范围的变量。\r\n            \r\n",", so we don't want to duplicate them here.\r\n            ":"，所以我们不想在这里复制它们。\r\n            \r\n","\r\n              Looks up a localized string similar to Overloaded method differing only in ref or out, or in array rank, is not CLS-compliant.\r\n            ":"\r\n              查找类似于仅在REF或OUT或ARRAY等级中不同的过载方法类似的本地化字符串，不符合CLS。\r\n            \r\n","Expected contextual keyword 'by'":"预期上下文关键字'by'\r\n","\r\n              Looks up a localized string similar to Field-like events are not allowed in readonly structs..\r\n            ":"\r\n              在Readonly结构中不允许查找类似于字段的局部字符串。\r\n            \r\n","The list is pessimistic because it may claim more or larger regions than actually changed.":"该列表是悲观的，因为它可能要求或更大的区域比实际更改更大。\r\n","\r\n            Returns true iff the values are related according to the given relation.\r\n            ":"\r\n            返回true如果iff该值是根据给定关系相关的。\r\n            \r\n","\r\n            True if this closure directly or transitively captures 'this' (captures\r\n            a local function which directly or indirectly captures 'this').\r\n            Calculated in ":"\r\n            如果直接或传统地捕获“此”，则是真的（捕获\r\n            直接或间接捕获“此”）的本地函数。\r\n            计算\r\n","ExpressionSyntax representing the operand of the postfix unary expression.":"表达式元素代表后缀一般表达的操作数。\r\n","\r\n            Lookup a top level type referenced from metadata, names should be\r\n            compared case-sensitively.  Detect cycles during lookup.\r\n            ":"\r\n            查找从元数据引用的顶级类型，名称应为\r\n            比较病例敏感。在查找过程中检测周期。\r\n            \r\n","!":"呢\r\n","Invalid #pragma checksum syntax; should be #pragma checksum \"filename\" \"{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\" \"XXXX...\"":"无效的#pragma校验和语法;应该是#pragma charchsum“ fileName”“ {xxxxxxxx-xxxx-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}”“ xxxx ...”\r\n","pattern matching":"模式匹配\r\n","\r\n            Within this method, characters that are not XML meta-characters can be seamlessly\r\n            replaced with the corresponding XML entities.\r\n            ":"\r\n            在此方法中，不是XML元字符的字符可以无缝\r\n            替换为相应的XML实体。\r\n            \r\n"," with no known type, given lookupResultKind and given symbols for GetSemanticInfo API,\r\n            and the given bound child.\r\n            ":" 没有已知类型，给定LookupResultKind并给出了GetManticinfo API的符号，\r\n            和给定的孩子。\r\n            \r\n","true if str.TrimStart().StartsWith(prefix)":"trus如果str.trimstart（）。startswith（前缀）\r\n","\r\n            What we need to do is find a *repeatable* arbitrary way to choose between\r\n            two errors; we can for example simply take the one whose arguments are lower in alphabetical\r\n            order when converted to a string.  As an optimization, we compare error codes\r\n            first and skip string comparison if they differ.\r\n            ":"\r\n            我们需要做的是找到一种 *可重复的 *任意方法来选择\r\n            两个错误；例如，我们可以简单地以字母顺序排列的论点较低的一个\r\n            转换为字符串时订购。作为优化，我们比较错误代码\r\n            首先，跳过字符串比较是否有所不同。\r\n            \r\n","Creates a new SwitchSectionSyntax instance.":"创建一个新的SwitchSectionsyntax实例。\r\n","Name of the invoked method.":"调用方法的名称。\r\n","\r\n              Looks up a localized string similar to Unexpected use of a generic name.\r\n            ":"\r\n              查找类似于通用名称的意外使用的本地化字符串。\r\n            \r\n","Invalid operand for pattern match; value required, but found '{0}'.":"图案匹配的操作数无效；需要的值，但发现了“ {0}”。\r\n","\r\n              Looks up a localized string similar to Non-nullable field is uninitialized. Consider declaring as nullable..\r\n            ":"\r\n              查找类似于不可解开字段的本地化字符串是未经初始化的。考虑宣布为无效。\r\n            \r\n","Delegate declaration syntax.":"委托声明语法。\r\n","ExpressionSyntax node representing the expression that is being casted.":"表达式元素节点表示正在施放的表达式。\r\n","\r\n            Gets the containing expression that is actually a language expression and not just typed\r\n            as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side\r\n            of qualified names and member access expressions are not language expressions, yet the\r\n            containing qualified names or member access expressions are indeed expressions.\r\n            Similarly, if the input node is a cref part that is not independently meaningful, then\r\n            the result will be the full cref.\r\n            ":"\r\n            获取实际上是一种语言表达的表达式，而不仅仅是键入\r\n            为了方便起见，作为表达方式。例如，右侧的nameyntax节点\r\n            合格的名称和成员访问表达式不是语言表达式\r\n            包含合格的名称或成员访问表达式确实是表达式。\r\n            同样，如果输入节点是没有独立有意义的Cref部分，则\r\n            结果将是完整的Cref。\r\n            \r\n"," if a diagnostic was added. Otherwise, ":" 如果添加了诊断。否则，\r\n","\r\n            A visitor that generates the part of the documentation comment after the initial type\r\n            and colon.\r\n            ":"\r\n            初始类型后生成文档注释的一部分的访问者\r\n            和结肠。\r\n            \r\n","\r\n            Variables instance for containing method, or null if this is the outermost method.\r\n            ":"\r\n            用于包含方法的变量实例，如果这是最外层的方法，则为null。\r\n            \r\n","Unmanaged type '{0}' is only valid for fields.":"非托管类型'{0}'仅适用于字段。\r\n",",\r\n            if one should be passed.\r\n            ":"，，，，\r\n            如果应该通过。\r\n            \r\n","The literal string ']]>' is not allowed in element content.":"在元素内容中不允许文字字符串']]>'。\r\n","Invalid search path specified":"指定的搜索路径无效\r\n","\r\n            This class represents an event declared in source without explicit accessors.\r\n            It implicitly has thread safe accessors and an associated field (of the same\r\n            name), unless it does not have an initializer and is either extern or inside\r\n            an interface, in which case it only has accessors.\r\n            ":"\r\n            该类代表一个没有明确登录器的源中声明的事件。\r\n            它隐含具有线程安全登录器和相关字段（相同的字段\r\n            名称），除非它没有初始化器，并且是外部或内部\r\n            接口，在这种情况下，它只有登录器。\r\n            \r\n","A list of text tokens used as the text of the xml text node.":"用作XML文本节点的文本的文本令牌列表。\r\n","\r\n              Looks up a localized string similar to '{0}': property or indexer must have at least one accessor.\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串：属性或索引器必须至少具有一个访问者。\r\n            \r\n","Gets the tilde token.":"获取Tilde代币。\r\n","\r\n            Is there any code to execute in the given statement that could have side-effects,\r\n            such as throwing an exception? This implementation is conservative, in the sense\r\n            that it may return true when the statement actually may have no side effects.\r\n            ":"\r\n            在给定语句中是否有任何代码可以执行，可能具有副作用，\r\n            例如抛出例外？从意义上讲，这种实施是保守的\r\n            当该语句实际上没有副作用时，它可能会返回。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot take the address of, get the size of, or declare a pointer to a managed type ('{0}').\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法接收地址，获取大小或声明指向托管类型的指针（'{0}'）。\r\n            \r\n","The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'.":"“等待”操作员只能在异步方法中使用。考虑使用“异步”修饰符标记此方法，然后将其返回类型更改为“任务”。\r\n",", or has ":"，或有\r\n","\r\n            Represents a goto statement syntax\r\n            ":"\r\n            代表goto语句语法\r\n            \r\n"," may be required.\r\n            ":" 可能需要。\r\n            \r\n","\r\n            This method indicates whether or not the runtime will regard the method\r\n            as virtual (as indicated by the presence of the \"virtual\" modifier in the\r\n            signature).\r\n            WARN WARN WARN: We won't have a final value for this until declaration\r\n            diagnostics have been computed for all ":"\r\n            此方法指示运行时是否会考虑该方法\r\n            如虚拟（如在该中存在“虚拟”修饰符的存在所示\r\n            签名）。\r\n            警告警告：直到宣布，我们不会对此有最终价值\r\n            已经计算出所有人的诊断\r\n","\r\n              Looks up a localized string similar to '{0}' defines operator == or operator != but does not override Object.GetHashCode().\r\n            ":"\r\n              查找类似于'{0}'定义operator ==或operator！=的本地化字符串！但不覆盖object.gethashcode（）。\r\n            \r\n","The constraints for type parameter '{0}' of method '{1}' must match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.":"类型参数'{1}'类型参数'{0}'的约束必须匹配type参数'{2}'接口方法'{3}'的约束。考虑使用显式接口实现。\r\n","\r\n            WARNING: will resolve lazy diagnostics - do not call this before the member lists are completed\r\n            or you could trigger infinite recursion.\r\n            ":"\r\n            警告：将解决懒惰诊断 - 在成员列表完成之前请勿调用此问题\r\n            或者您可以触发无限递归。\r\n            \r\n","\r\n            Computes the widest scope depth to which the given expression can escape by value.\r\n            \r\n            NOTE: unless the type of expression is ref-like, the result is Binder.ExternalScope since ordinary values can always be returned from methods. \r\n            ":"\r\n            计算给定表达式可以按值逃脱的最宽度深度。\r\n            \r\n            注意：除非表达式类型类似于参考，否则结果是粘合剂。\r\n            \r\n","\r\n            Relative and absolute paths treated the same as ":"\r\n            相对和绝对路径与\r\n","Overload resolution result for method group executed by caller.":"通过呼叫者执行的方法组的过载分辨率结果。\r\n","\r\n            will be invoked; otherwise ":"\r\n            将被调用；否则\r\n","\r\n              Looks up a localized string similar to Fixed size buffer type must be one of the following: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float or double.\r\n            ":"\r\n              查找类似于固定尺寸缓冲区类型的局部字符串必须是以下一个：布尔，字节，短，int，长，char，sbyte，sbyte，ushort，uint，uint，ulong，ulong，float或double。\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability of reference types in type of parameter doesn't match implicitly implemented member..\r\n            ":"\r\n              查找类似于参数类型中参考类型的无效性类似的本地化字符串与隐式实现的成员不匹配。\r\n            \r\n","\r\n            Get a SemanticModel object that is associated with a cref that did not appear in\r\n            this source code. This can be used to get detailed semantic information about sub-parts\r\n            of a cref that did not appear in source code. \r\n            \r\n            NOTE: This will only work in locations where there is already a cref.\r\n            ":"\r\n            获取与未出现在\r\n            此源代码。这可以用来获取有关子部分的详细语义信息\r\n            未出现在源代码中的CREF。\r\n            \r\n            注意：这只能在已经有CREF的地方工作。\r\n            \r\n","\r\n            Returns true if the specified node represents a lambda.\r\n            ":"\r\n            如果指定的节点表示lambda，则返回true。\r\n            \r\n","Await in catch/finally blocks":"等待捕获/最后阻塞\r\n","\r\n            If the extension method is applicable based on the \"this\" argument type, return\r\n            the method constructed with the inferred type arguments. If the method is not an\r\n            unconstructed generic method, type inference is skipped. If the method is not\r\n            applicable, or if constraints when inferring type parameters from the \"this\" type\r\n            are not satisfied, the return value is null.\r\n            ":"\r\n            如果扩展方法是根据“此”参数类型适用的，请返回\r\n            用推断类型参数构建的方法。如果该方法不是\r\n            未结构的通用方法，类型推断被跳过。如果该方法不是\r\n            适用，或者在从“此”类型中推断类型参数时的约束\r\n            不满足，返回值为null。\r\n            \r\n","Creates a new ShebangDirectiveTriviaSyntax instance.":"创建一个新的shebangdirectivtriviasyntax实例。\r\n","Called when the visitor visits a StructDeclarationSyntax node.":"访问者访问structDeclarationsyntax节点时调用。\r\n","\r\n            Returns the start of the current lexeme relative to the window start.\r\n            ":"\r\n            返回相对于窗口启动的当前Lexeme的开始。\r\n            \r\n","\r\n            It is rare but possible for a source type to be convertible to a destination type\r\n            by both an implicit user-defined conversion and a built-in explicit conversion.\r\n            In that circumstance, this method classifies the conversion as the implicit conversion or explicit depending on \"forCast\"\r\n            ":"\r\n            很少见，但可能使源类型可转换为目的地类型\r\n            通过隐式用户定义的转换和内置的显式转换。\r\n            在这种情况下，此方法将转换归类为隐式转换或明确取决于“预播”\r\n            \r\n","The symbol to be displayed.":"要显示的符号。\r\n",".\r\n            For those fields, we map from their definition to an index.\r\n            ":"。\r\n            对于这些字段，我们将其定义映射到索引。\r\n            \r\n","\r\n            A binder that places the members of a symbol in scope.\r\n            ":"\r\n            将符号成员置于范围中的活页夹。\r\n            \r\n","Creates a new IdentifierNameSyntax instance.":"创建一个新的dissinifierNamesyntax实例。\r\n","\r\n            Element types.\r\n            ":"\r\n            元素类型。\r\n            \r\n","\r\n            Gets the conversion that occurred between the expression's type and type implied by the expression's context.\r\n            ":"\r\n            获取表达式上下文所隐含的表达式类型和类型之间发生的转换。\r\n            \r\n","\r\n              Looks up a localized string similar to Type parameter has the same name as the type parameter from outer type.\r\n            ":"\r\n              查找类似于类型参数的本地化字符串与外部类型的类型参数具有相同的名称。\r\n            \r\n","'{0}': base type '{1}' is not CLS-compliant":"'{0}'：基本类型'{1}'不符合CLS\r\n","An expression of type '{0}' cannot be handled by a pattern of type '{1}'.":"类型'{0}'的表达式无法通过类型'{1}'的模式来处理。\r\n","\r\n              Looks up a localized string similar to SyntaxTree is not part of the compilation, so it cannot be removed.\r\n            ":"\r\n              查找类似于语法的本地化字符串不是汇编的一部分，因此无法将其删除。\r\n            \r\n","\r\n            The closure doesn't declare any variables, and is never converted to a delegate.\r\n            Lambdas are emitted directly to the containing class as a static method.\r\n            ":"\r\n            关闭没有声明任何变量，也不会转换为委托。\r\n            Lambdas直接以静态方法发射到包含类。\r\n            \r\n","Operator declaration syntax.":"运营商声明语法。\r\n","The input diagnostic":"输入诊断\r\n","\r\n            Bag of assembly's custom attributes and decoded well-known attribute data from source.\r\n            ":"\r\n            汇编的自定义属性和解码众所周知的属性数据来自源。\r\n            \r\n","\r\n            Diagnostic is disabled.\r\n            ":"\r\n            诊断是禁用的。\r\n            \r\n","\r\n            Determine if the given type is an empty struct type.\r\n            ":"\r\n            确定给定类型是否为空结构类型。\r\n            \r\n","Creates a new ExpressionColonSyntax instance.":"创建一个新的ExpressionColonsyntax实例。\r\n","\r\n            Check if it is a regular collection of expressions or there are nested initializers.\r\n            ":"\r\n            检查它是定期的表达式集合还是有嵌套的初始化器。\r\n            \r\n","Node for diagnostics.":"诊断节点。\r\n","Parameter '{0}' has no matching param tag in the XML comment for '{1}' (but other parameters do)":"参数'{​​0}'在XML注释中没有匹配的param标签（{1}}'（但是其他参数为）\r\n","Called when the visitor visits a IfStatementSyntax node.":"访问者访问ifstatementsyntax节点时调用。\r\n","Type parameter '{0}' has no matching typeparam tag in the XML comment on '{1}' (but other type parameters do)":"键入参数'{0}'在XML上没有匹配的Typeparam标签，上面'{1}'（但是其他类型的参数do）\r\n","\r\n              Looks up a localized string similar to XML comment is not placed on a valid language element.\r\n            ":"\r\n              查找类似于XML注释的本地化字符串未在有效的语言元素上放置。\r\n            \r\n","\r\n              Looks up a localized string similar to Comparison made to same variable.\r\n            ":"\r\n              查找类似于与同一变量的比较类似的局部字符串。\r\n            \r\n","Creates a new EventFieldDeclarationSyntax instance.":"创建一个新的EventFieldDeclarationsyntax实例。\r\n","Called when the visitor visits a BracketedParameterListSyntax node.":"当访客访问括号内级列表节点时，请致电。\r\n","true if there was at least one error":"如果至少有一个错误\r\n","\r\n            The bound expression that is the invocation of a \"Cast\" method specified by the query translation.\r\n            ":"\r\n            查询翻译指定的“铸造”方法的调用的界表达式。\r\n            \r\n","\r\n            This instance is used to determine if some API specific to records is explicitly declared.\r\n            It is the same as ":"\r\n            此实例用于确定是否明确声明了某些特定于记录的API。\r\n            与\r\n","\r\n            Returns true if this symbol was automatically created by the compiler, and does not\r\n            have an explicit corresponding source code declaration.  \r\n            \r\n            This is intended for symbols that are ordinary symbols in the language sense,\r\n            and may be used by code, but that are simply declared implicitly rather than\r\n            with explicit language syntax.\r\n            \r\n            Examples include (this list is not exhaustive):\r\n              the default constructor for a class or struct that is created if one is not provided,\r\n              the BeginInvoke/Invoke/EndInvoke methods for a delegate,\r\n              the generated backing field for an auto property or a field-like event,\r\n              the \"this\" parameter for non-static methods,\r\n              the \"value\" parameter for a property setter,\r\n              the parameters on indexer accessor methods (not on the indexer itself),\r\n              methods in anonymous types,\r\n            ":"\r\n            如果此符号是由编译器自动创建的，则返回true，而不是\r\n            具有明确的相应源代码声明。\r\n            \r\n            这是针对语言意义上的普通符号的符号\r\n            并且可以由代码使用，但只是隐式声明而不是\r\n            带有明确的语言语法。\r\n            \r\n            示例包括（此列表并不详尽）：\r\n              如果不提供一个类别的类或结构的默认构造函数，则\r\n              委托人的开头/调用/endinvoke方法，\r\n              自动属性或类似现场的事件的生成的背面字段，\r\n              非静态方法的“此”参数，\r\n              属性设置器的“值”参数，\r\n              索引器访问者方法上的参数（不在索引本身上）​​，\r\n              匿名类型的方法，\r\n            \r\n","foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'. Did you mean 'await foreach' rather than 'foreach'?":"foreach语句无法在类型'{0}'的变量上操作，因为'{0}'不包含'{1}'的公共实例或扩展定义。您的意思是“等待“ foreach”而不是“ foreach”？\r\n","\r\n              Looks up a localized string similar to An expression tree may not contain an out argument variable declaration..\r\n            ":"查找类似于表达树的本地化字符串可能不包含OUT参数变量声明。\r\n            \r\n","InitializerExpressionSyntax node representing the initializer of the stackalloc array creation expression.":"InitializereXpressionsyntax节点表示stackalloc数组创建表达式的初始化器。\r\n","'{0}' has no applicable method named '{1}' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.":"'{0}'没有名为'{1}'的适用方法，但似乎具有该名称的扩展方法。扩展方法不能动态调度。考虑在没有扩展方法语法的情况下施放动态参数或调用扩展方法。\r\n","\r\n            Update the null-state based on MaybeNull/NotNull\r\n            ":"\r\n            根据Maybenull/Notnull更新零状态\r\n            \r\n","\r\n            Each application of an attribute is effectively a constructor call.  Since the attribute constructor\r\n            might have a CallerMemberName parameter, we need to keep track of which method/property/event\r\n            the attribute is on/in (e.g. on a parameter) so that we can use the name of that member as the \r\n            CallerMemberName argument.\r\n            ":"属性的每个应用程序实际上都是构造函数调用。由于属性构造函数\r\n            可能具有CallerMemberName参数，我们需要跟踪哪种方法/属性/事件\r\n            该属性在/in（例如，参数）上，因此我们可以将该成员的名称用作\r\n            callermembername参数。\r\n            \r\n","Value for argument '/shared:' must not be empty":"参数的价值'/共享：'不得为空\r\n","Gets the attribute declaration list.":"获取属性声明列表。\r\n","\r\n            NOTE:    This method is intended for passes other than the LocalRewriter.\r\n            NOTE:    Use MakeConversion helper method in the LocalRewriter instead,\r\n            NOTE:    it generates a synthesized conversion in its lowered form.\r\n            ":"\r\n            注意：此方法旨在用于除localrewriter以外的其他方法。\r\n            注意：改用localrewriter中的makeconversion助手方法，\r\n            注意：它以降低形式生成合成的转换。\r\n            \r\n","\r\n            Perform a lookup for the specified method on the specified type.  Perform overload resolution\r\n            on the lookup results.\r\n            ":"\r\n            在指定类型上对指定方法进行查找。执行超负荷分辨率\r\n            在查找结果上。\r\n            \r\n","Programmatic suppression of an analyzer diagnostic":"程序抑制分析仪诊断\r\n","Called when the visitor visits a SizeOfExpressionSyntax node.":"访问者访问sizeofexpressyntax节点时调用。\r\n","\r\n            Returns true if the node is in a position where an unbound type\r\n            such as (C<,>) is allowed.\r\n            ":"\r\n            如果节点处于未结合类型的位置，则返回true\r\n            例如（c <，>）。\r\n            \r\n","The text from which this token was created (e.g. lexed).":"创建该令牌的文本（例如Lexed）。\r\n","\r\n            If an expression node that declares synthesized short-lived locals (currently only sequence) contains\r\n            a spill sequence (from an await or switch expression), these locals become long-lived since their\r\n            values may be read by code that follows. We promote these variables to long-lived of kind\r\n            ":"\r\n            如果声明合成的短寿命当地人（当前仅序列）的表达节点包含\r\n            溢出序列（来自等待或开关表达式），这些当地人已经长期存在\r\n            值可以通过以下代码读取。我们将这些变量推广到长寿\r\n            \r\n","Creates a new BinaryPatternSyntax instance.":"创建一个新的BinaryPatternsyntax实例。\r\n","\r\n              Looks up a localized string similar to The /moduleassemblyname option may only be specified when building a target type of 'module'.\r\n            ":"\r\n              在构建目标类型的“模块”类型时，才可以指定类似于 /模量的局部字符串。\r\n            \r\n","XML comment has syntactically incorrect cref attribute":"XML评论在句法上不正确CREF属性\r\n","\r\n            Returns a bag of custom attributes applied on the property and data decoded from well-known attributes. Returns null if there are no attributes.\r\n            ":"\r\n            返回对属性上应用的自定义属性和从众所周知的属性解码的数据。如果没有属性，则返回null。\r\n            \r\n","\r\n                SemanticInfo SemanticModel.GetSemanticInfo(ExpressionSyntax expression);\r\n                SemanticInfo SemanticModel.BindExpression(CSharpSyntaxNode location, ExpressionSyntax expression);\r\n                SemanticInfo SemanticModel.BindType(CSharpSyntaxNode location, ExpressionSyntax type);\r\n                SemanticInfo SemanticModel.BindNamespaceOrType(CSharpSyntaxNode location, ExpressionSyntax type);\r\n            ":"\r\n                semanticinfo semanticmodel.getSemanticinfo（表达式表达式）;\r\n                semanticinfo semanticmodel.bindexpression（csharpsyntaxnode位置，表达式表达式）;\r\n                semanticinfo semanticmodel.bindtype（csharpsyntaxnode位置，表达式类型类型）;\r\n                semanticinfo semanticmodel.bindnames -paceortype（csharpsyntaxnode位置，表达式类别类型）;\r\n            \r\n",".\r\n            Assumes that the public key has been determined. The result will be cached.\r\n            ":"。\r\n            假设已确定了公钥。结果将被缓存。\r\n            \r\n","\r\n            Schedules the state machine to proceed to the next action when the specified awaiter completes.\r\n            ":"\r\n            计划机器在指定的等待者完成后继续进行下一个操作。\r\n            \r\n","Arguments to the method call.":"对方法调用的论点。\r\n","The ref modifier of a method's return value or a local.":"方法的返回值或本地的REF修饰符。\r\n","\r\n            Does the struct variable at the given slot have all of its instance fields assigned?\r\n            ":"\r\n            给定插槽处的结构变量是否分配了其所有实例字段？\r\n            \r\n","\r\n            The constructor of the class that is the translation of an iterator method.\r\n            ":"\r\n            类的构造函数是迭代方法的翻译。\r\n            \r\n","\r\n              Looks up a localized string similar to } expected.\r\n            ":"\r\n              查找类似于预期的本地化字符串。\r\n            \r\n"," will be lowered to ":" 将降低到\r\n","\r\n            Returns true if the Unicode character represents a whitespace.\r\n            ":"\r\n            如果Unicode字符代表空格，则返回true。\r\n            \r\n","\r\n            Gets the token for this symbol as it appears in metadata. Most of the time this is 0,\r\n            as it is when the symbol is not loaded from metadata.\r\n            ":"\r\n            在元数据中显示该符号的令牌。大多数时候这是0，\r\n            就像符号未从元数据加载时一样。\r\n            \r\n","\r\n              Looks up a localized string similar to SyntaxTree is not part of the compilation.\r\n            ":"\r\n              查找类似于语法的本地化字符串不是汇编的一部分。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid option '{0}'; Resource visibility must be either 'public' or 'private'.\r\n            ":"\r\n              查找类似于无效选项的本地化字符串'{0}';资源可见性必须是“公共”或“私人”。\r\n            \r\n","Use of null is not valid in this context":"在这种情况下，使用null是无效的\r\n","Creates a new LocalDeclarationStatementSyntax instance.":"创建一个新的localDeclarationStatatementSyntax实例。\r\n","\r\n              Looks up a localized string similar to Arrays as attribute arguments is not CLS-compliant.\r\n            ":"\r\n              查找类似于数组的本地化字符串，因为属性参数不符合CLS。\r\n            \r\n","\r\n            Creates a new compilation with an old metadata reference replaced with a new metadata reference.\r\n            ":"\r\n            用新的元数据替换为新的元数据参考，创建新的汇编。\r\n            \r\n","\r\n            Gets the root node of the syntax tree.\r\n            ":"\r\n            获取语​​法树的根节点。\r\n            \r\n","\r\n            Given the type containing constructors, gets the list of candidate instance constructors and uses overload resolution to determine which one should be called.\r\n            ":"\r\n            给定包含构造函数的类型，获取候选实例构造函数的列表，并使用过载分辨率来确定应调用哪一个。\r\n            \r\n","Executables cannot be satellite assemblies; culture should always be empty":"可执行文件不能是卫星组件；文化应该永远是空的\r\n","Compilation (C#):":"汇编（C＃）：\r\n"," for each of them, containing\r\n            the state transitions (including the test to perform at each node and the successor nodes) but\r\n            not the state descriptions. A ":" 对于每个人，包含\r\n            状态过渡（包括在每个节点和后继节点上执行的测试），但是\r\n            不是国家描述。一个\r\n",",\r\n            value = explicitly implementing methods/properties/events declared on this type (normally a single value, multiple in case of\r\n            an error).\r\n            ":"，，，，\r\n            值=在此类型上声明的明确实现方法/属性/事件（通常是一个值，多个在\r\n            一个错误）。\r\n            \r\n","The constructor call needs to be dynamically dispatched, but cannot be because it is part of a constructor initializer. Consider casting the dynamic arguments.":"构造函数调用需要动态调度，但不能是因为它是构造函数初始化器的一部分。考虑施放动态论点。\r\n"," for a metadata reference used to create this compilation.\r\n            ":" 对于用于创建此汇编的元数据参考。\r\n            \r\n","'{0}': 'readonly' can only be used on accessors if the property or indexer has both a get and a set accessor":"'{0}'：'ReadOnly'仅在属性或索引器具有GET和SET访问器时才能在登录机上使用\r\n","The field '{0}' is never used":"从未使用过字段'{0}'\r\n","\r\n              Looks up a localized string similar to extension method.\r\n            ":"\r\n              查找类似于扩展方法的本地化字符串。\r\n            \r\n","\r\n            A source parameter that has no default value, no attributes,\r\n            and is not params.\r\n            ":"\r\n            一个没有默认值的源参数，没有属性，\r\n            而不是参数。\r\n            \r\n","The statement to be included in the analysis.":"分析中包含的声明。\r\n","\r\n            Creates a singleton list of tokens.\r\n            ":"\r\n            创建一个名字列表。\r\n            \r\n","\r\n              Looks up a localized string similar to 'await' requires that the type '{0}' have a suitable GetAwaiter method. Are you missing a using directive for 'System'?.\r\n            ":"\r\n              查找类似于“等待”的本地化字符串，要求类型“ {0}”具有合适的Getawaiter方法。您是否缺少使用“系统”的指令？\r\n            \r\n","\r\n            Indicates that this method inherits attributes from the base method, its parameters, return type, and type parameters.\r\n            ":"\r\n            指示此方法从基本方法，其参数，返回类型和类型参数继承属性。\r\n            \r\n","\r\n            We used to sort symbols on demand and relied on row ids to figure out the order between symbols of the same kind.\r\n            However, that was fragile because, when map tables are used in metadata, row ids in the map table define the order\r\n            and we don't have them.\r\n            Members are grouped by kind. First we store fields, then methods, then properties, then events and finally nested types.\r\n            Within groups, members are sorted based on declaration order.\r\n            ":"\r\n            我们曾经按需对符号进行排序，并依靠行ID来找出同类符号之间的顺序。\r\n            但是，这很脆弱，因为当元数据中使用地图表时，地图表中的行ID定义顺序\r\n            而且我们没有它们。\r\n            成员通过善良分组。首先，我们存储字段，然后是方法，然后属性，然后是事件，最后嵌套类型。\r\n            在小组内部，根据声明顺序对成员进行分类。\r\n            \r\n","Desired variance of type.":"所需类型的差异。\r\n","No such label '{0}' within the scope of the goto statement":"在goto语句的范围内没有这样的标签'{0}'\r\n","\r\n            The class to represent all types imported from a PE/module.\r\n            ":"\r\n            代表从PE/模块导入的所有类型的类。\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability of reference types in type of parameter doesn't match the target delegate..\r\n            ":"\r\n              在参数类型中查找类似于参考类型的无效性类似的本地化字符串与目标委托不匹配。\r\n            \r\n","\r\n              Looks up a localized string similar to The using directive for '{0}' appeared previously in this namespace.\r\n            ":"\r\n              查找类似于“ {0}”的使用指令类似的本地化字符串，此前以前出现在此名称空间中。\r\n            \r\n","\r\n            Lower a block of code by performing local rewritings.\r\n            ":"\r\n            通过执行本地重写来降低代码块。\r\n            \r\n","#endif":"＃万一\r\n","expression-bodied method":"表达体的方法\r\n","\r\n            True if the type itself is excluded from code coverage instrumentation.\r\n            True for source types marked with ":"\r\n            如果将类型本身从代码覆盖仪器中排除在外，则为正确。\r\n            标记为源类型\r\n","\r\n            Substitutes all occurrences of dynamic type with Object type.\r\n            ":"\r\n            用对象类型替代了动态类型的所有出现。\r\n            \r\n","\r\n            In C#9, annotations are allowed regardless of constraints.\r\n            ":"\r\n            在C＃9中，无论限制如何，都允许注释。\r\n            \r\n","The switch case is unreachable. It has already been handled by a previous case or it is impossible to match.":"开关案例无法到达。它已经由以前的案例处理，或者不可能匹配。\r\n","\r\n            Creates a trivia with kind either SingleLineCommentTrivia or MultiLineCommentTrivia containing the specified\r\n            text.\r\n            ":"\r\n            创建一个具有单一核心的琐事\r\n            文本。\r\n            \r\n","Creates a new IndexerDeclarationSyntax instance.":"创建一个新的indexerDeclarationsyntax实例。\r\n","Called when the visitor visits a LineSpanDirectiveTriviaSyntax node.":"当访问者访问LinesPandirectiviviaSynyntax节点时调用。\r\n","'{0}': a class with the ComImport attribute cannot specify field initializers.":"'{0}'：带有Comimport属性的类无法指定字段初始化器。\r\n","Create an Index pointing at first element.":"创建一个指向第一个元素的索引。\r\n","\r\n            Used to allow ":"\r\n            用于允许\r\n","\r\n              Looks up a localized string similar to range operator.\r\n            ":"\r\n              查找类似于范围运算符的本地化字符串。\r\n            \r\n","\r\n            A binder that places the members of a symbol in scope.  If there is a container declaration\r\n            with using directives, those are merged when looking up names.\r\n            ":"\r\n            将符号成员置于范围中的活页夹。如果有容器声明\r\n            使用指令，查找名称时会合并。\r\n            \r\n","\r\n              Looks up a localized string similar to An extern alias declaration must precede all other elements defined in the namespace.\r\n            ":"查找类似于外部别名声明的本地化字符串必须先于名称空间中定义的所有其他元素。\r\n            \r\n","NOTE: Do not use this method elsewhere, instead use ":"注意：请勿在其他地方使用此方法，而是使用\r\n",", are problematic when\r\n            inlined. The methods themselves are small but they end up allocating significantly larger\r\n            frames due to the use of biggish value types within them. The ":"，当\r\n            嵌入式。这些方法本身很小，但最终分配了明显更大的\r\n            由于其中使用了大价值类型，因此框架。这\r\n"," parameters or ":" 参数或\r\n"," will\r\n            be non-null.\r\n            ":" 将要\r\n            是非效果。\r\n            \r\n","\r\n            Out params are updated by assignment.  If you require thread-safety, pass temps and then\r\n            CompareExchange them back into shared memory.\r\n            ":"\r\n            通过分配更新参数。如果您需要线程安全，请通过温度然后\r\n            compareexchange它们回到共享内存中。\r\n            \r\n","\r\n            Any of these bits is equivalent to presence of 'struct' constraint. \r\n            ":"\r\n            这些位中的任何一个等同于“结构”约束的存在。\r\n            \r\n","\r\n            If there are no constraints, returns an empty immutable array. Otherwise, returns an immutable\r\n            array of kinds, indexed by the constrained type parameter in ":"\r\n            如果没有约束，则返回一个空的不变阵列。否则，返回不变的\r\n            种类数组，由约束类型参数索引\r\n","\r\n            Since this method is expected to be called on every nested expression of the argument, it doesn't\r\n            need to recurse (directly).\r\n            ":"\r\n            由于预计该方法会在参数的每个嵌套表达式上调用，因此\r\n            需要（直接）。\r\n            \r\n","\r\n            Represents symbols imported to the binding scope via using namespace, using alias, and extern alias.\r\n            ":"\r\n            代表通过使用名称空间，使用别名和外部别名导入到绑定范围的符号。\r\n            \r\n","\r\n            Imports declared by this submission (null if this isn't one).\r\n            ":"\r\n            通过此提交声明的导入（如果不是一个）。\r\n            \r\n","Cannot assign to a member of {0} '{1}' because it is a readonly variable":"无法分配给{0}'{1}'的成员，因为它是一个可读变量\r\n","'{0}': not all code paths return a value":"'{0}'：并非所有代码路径返回值\r\n","\r\n            Make a variable for a declaration expression appearing as one of the declared variables of the left-hand-side\r\n            of a deconstruction assignment.\r\n            ":"\r\n            使声明表达式变量显示为左侧声明变量之一\r\n            解构分配。\r\n            \r\n","\r\n            Gets a new SyntaxTreeSemanticModel for the specified syntax tree.\r\n            ":"\r\n            为指定的语法树获取新的语法eManticmodel。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' cannot define an overloaded {1} that differs only on parameter modifiers '{2}' and '{3}'.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串无法定义仅在参数修饰符'{2}'和'{3}'上不同的超载{1}。\r\n            \r\n","\r\n            The set of method symbols from which this call's method was chosen. \r\n            Only kept in the tree if the call was an error and overload resolution\r\n            was unable to choose a best method.\r\n            ":"\r\n            选择此调用方法的一组方法符号。\r\n            只有在通话是错误和超载分辨率的情况下才保存在树上\r\n            无法选择最佳方法。\r\n            \r\n","\r\n            The combined paths. If ":"\r\n            组合路径。如果\r\n","\r\n              Looks up a localized string similar to First argument to a security attribute must be a valid SecurityAction.\r\n            ":"\r\n              查找与第一个参数类似于安全属性的本地化字符串必须是有效的安全性。\r\n            \r\n","\r\n            Return the location of the accessor, or if no accessor, the location of the property.\r\n            ":"\r\n            返回登录器的位置，或者如果没有登录器，则返回属性的位置。\r\n            \r\n","Creates a new TypeCrefSyntax instance.":"创建一个新的TypeCrefsyntax实例。\r\n"," class to create a new syntax tree rooted at the given root node.\r\n            This method does not create a clone of the given root, but instead preserves it's reference identity.\r\n            ":" 类创建扎根于给定的根节点的新语法树。\r\n            此方法不会创建给定词的克隆，而是保留其参考身份。\r\n            \r\n","\r\n              Looks up a localized string similar to Constant value '{0}' cannot be converted to a '{1}'.\r\n            ":"\r\n              查找类似于常数值'{0}'的本地化字符串不能转换为'{1}'。\r\n            \r\n","\r\n            Number of entries tracked during analysis.\r\n            ":"\r\n            分析过程中跟踪的条目数。\r\n            \r\n","This warning occurs when you create a class with a method whose signature is public virtual void Finalize.\r\n            \r\n            If such a class is used as a base class and if the deriving class defines a destructor, the destructor will override the base class Finalize method, ...":"当您使用签名为公共虚拟空隙最终确定的方法创建类时，就会发生此警告。\r\n            \r\n            如果将这样的类用作基类，并且派生类定义了驱动器，则驱动器将覆盖基类最终确定方法，...\r\n","True if overload resolution successfully chose an accessible constructor.":"如果超负荷分辨率成功选择了可访问的构造函数，则为正确。\r\n","\r\n            Returns false because label can't be static.\r\n            ":"\r\n            返回false，因为标签不能静态。\r\n            \r\n","\r\n            If this symbol represents a tuple type, get the names of the tuple's elements.\r\n            ":"\r\n            如果此符号代表元组类型，请获取元组元素的名称。\r\n            \r\n","\r\n            Gets symbol information about the 'Add' method corresponding to an expression syntax ":"\r\n            获取有关表达语法对应的“添加”方法的符号信息\r\n","\r\n              Looks up a localized string similar to Modifiers cannot be placed on event accessor declarations.\r\n            ":"\r\n              在Event Accessor声明上查找类似于修饰符的本地化字符串。\r\n            \r\n","\r\n            The underlying AssemblySymbol.\r\n            This cannot be an instance of RetargetingAssemblySymbol.\r\n            ":"\r\n            基础组合符号。\r\n            这不能是retargetingAssemblysymbol的一个实例。\r\n            \r\n"," builder is freed after all its items are enumerated.\r\n            ":" 在列举其所有物品后，建造者将被释放。\r\n            \r\n","\r\n            True if this module is an ENC update.\r\n            ":"\r\n            如果此模块是ENG更新，则为true。\r\n            \r\n","\r\n            Helper for determining whether a local function transitively\r\n            only captures this (only captures this or other local functions\r\n            which only capture this).\r\n            ":"\r\n            用于确定局部函数是否过渡的助手\r\n            仅捕获此（仅捕获此本地功能\r\n            只捕获这个）。\r\n            \r\n","\r\n            associate the frame with the first lambda that caused it to exist. \r\n            we need to associate this with some syntax.\r\n            unfortunately either containing method or containing class could be synthetic\r\n            therefore could have no syntax.\r\n            ":"\r\n            将框架与导致其存在的第一个lambda相关联。\r\n            我们需要将其与一些语法相关联。\r\n            不幸的是，要么包含方法或包含类可能是合成的\r\n            因此可能没有语法。\r\n            \r\n","Called when the visitor visits a BracketedArgumentListSyntax node.":"当访客访问一个括号内符号列表节点时，请致电。\r\n","\r\n            Abstraction over the file system that is useful for test hooks\r\n            ":"\r\n            在文件系统上的抽象，对测试钩有用\r\n            \r\n","\r\n            Returns false because field can't be sealed.\r\n            ":"\r\n            返回错误，因为字段无法密封。\r\n            \r\n","A syntax node that represents a parsed accessor declaration. This accessor should not be\r\n            present in the syntax tree associated with this object.":"代表解析的登录声声明的语法节点。这个登录器不应该是\r\n            存在与此对象关联的语法树中。\r\n","Assembly '{0}' with identity '{1}' uses '{2}' which has a higher version than referenced assembly '{3}' with identity '{4}'":"带有身份'{1}'use'{2}'的汇编'{0}'具有高于引用汇编的版本'{3}'with Identity'{4}'{4}'\r\n","\r\n             Lower a block of code by performing local rewritings. \r\n             The goal is to not have exception handlers that contain awaits in them.\r\n             \r\n             1) Await containing finally blocks:\r\n                 The general strategy is to rewrite await containing handlers into synthetic handlers.\r\n                 Synthetic handlers are not handlers in IL sense so it is ok to have awaits in them.\r\n                 Since synthetic handlers are just blocks, we have to deal with pending exception/branch/return manually\r\n                 (this is the hard part of the rewrite).\r\n            \r\n                 try{\r\n                    code;\r\n                 }finally{\r\n                    handler;\r\n                 }\r\n            \r\n             Into ===>\r\n            \r\n                 Exception ex = null;\r\n                 int pendingBranch = 0;\r\n            \r\n                 try{\r\n                     code;  // any gotos/returns are rewritten to code that pends the necessary info and goes to finallyLabel\r\n                     goto finallyLabel;\r\n                 }catch (ex){  // essentially pend the currently active exception\r\n                 };\r\n            \r\n                 finallyLabel:\r\n                 {\r\n                    handler;\r\n                    if (ex != null) throw ex;     // unpend the exception\r\n                    unpend branches/return\r\n                 }\r\n             \r\n             2) Await containing catches:\r\n                 try{\r\n                     code;\r\n                 }catch (Exception ex){\r\n                     handler;\r\n                     throw;\r\n                 }\r\n             \r\n             \r\n             Into ===>\r\n            \r\n                 Object pendingException;\r\n                 int pendingCatch = 0;\r\n            \r\n                 try{\r\n                     code; \r\n                 }catch (Exception temp){  // essentially pend the currently active exception\r\n                     pendingException = temp;\r\n                     pendingCatch = 1;\r\n                 };\r\n            \r\n                 switch(pendingCatch):\r\n                 {\r\n                    case 1:\r\n                     {\r\n                         Exception ex = (Exception)pendingException;\r\n                         handler;\r\n                         throw pendingException\r\n                     }\r\n                 }\r\n             ":"\r\n             通过执行本地重写来降低代码块。\r\n             目的是不要有外来的处理程序，其中包含等待的处理程序。\r\n             \r\n             1）等待最终包含：\r\n                 一般策略是将等待处理者重写为合成处理程序。\r\n                 合成处理程序在IL方面不是处理程序，因此可以等待它们。\r\n                 由于合成处理程序只是块，因此我们必须处理待处理的例外/分支/返回\r\n                 （这是重写的困难部分）。\r\n            \r\n                 尝试{\r\n                    代码;\r\n                 }最后{\r\n                    处理程序\r\n                 }\r\n            \r\n             进入===>\r\n            \r\n                 异常ex = null;\r\n                 int pendingBranch = 0;\r\n            \r\n                 尝试{\r\n                     代码; //任何gotos/returns均已重写为伪造必要信息的代码，然后转到最终标签\r\n                     goto终于列表;\r\n                 } catch（ex）{//本质上是pend当前活动异常\r\n                 };\r\n            \r\n                 最后列表：\r\n                 {\r\n                    处理程序\r\n                    if（ex！= null）投掷ex; //取消例外\r\n                    取消分支机构/退货\r\n                 }\r\n             \r\n             2）等待包含捕获物：\r\n                 尝试{\r\n                     代码;\r\n                 } catch（异常EX）{\r\n                     处理程序\r\n                     扔;\r\n                 }\r\n             \r\n             \r\n             进入===>\r\n            \r\n                 对象pENDENDEXCEPTION;\r\n                 int pendingCatch = 0;\r\n            \r\n                 尝试{\r\n                     代码;\r\n                 } catch（异常温度）{//本质上是pend当前活动异常\r\n                     pendingException = temp;\r\n                     pendendCatch = 1;\r\n                 };\r\n            \r\n                 开关（pendendCatch）：\r\n                 {\r\n                    情况1：\r\n                     {\r\n                         异常ex =（异常）pendendException;\r\n                         处理程序\r\n                         投掷pendendException\r\n                     }\r\n                 }\r\n             \r\n","\r\n              Looks up a localized string similar to '{0}' cannot define overloaded methods that differ only on ref and out.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串无法定义仅在REF和OUT上不同的过载方法。\r\n            \r\n","'{0}': event must be of a delegate type":"'{0}'：事件必须是代表类型\r\n"," represents the test performed by evaluating the expression of the\r\n            when-clause of a switch case; and ":" 表示通过评估表达来执行的测试\r\n            转换案例的条款；和\r\n","Called when the visitor visits a UnsafeStatementSyntax node.":"当访问者访问unsafstatementsyntax节点时调用。\r\n","\r\n            By default we defer to this.Type.IsPointerType() \r\n            However in some cases this may cause circular dependency via binding a\r\n            pointer that points to the type that contains the current field.\r\n            Fortunately in those cases we do not need to force binding of the field's type \r\n            and can just check the declaration syntax if the field type is not yet known.\r\n            ":"\r\n            默认情况下，我们将其推迟到this.type.ispointertype（）\r\n            但是在某些情况下，这可能会通过结合A导致循环依赖性\r\n            指向包含当前字段的类型的指针。\r\n            幸运的是，在这种情况下，我们不需要强迫该领域类型的绑定\r\n            如果尚不知道字段类型，则可以检查声明语法。\r\n            \r\n","Since '{1}' has the ComImport attribute, '{0}' must be extern or abstract":"由于'{1}'具有comimport属性，{0}必须是外部或抽象\r\n","Embedded statement cannot be a declaration or labeled statement":"嵌入式语句不能是声明或标记的语句\r\n","Creates a new ElifDirectiveTriviaSyntax instance.":"创建一个新的ElifDirectivtRiviaSyntax实例。\r\n","(Location of symbol related to previous error)":"（与以前错误有关的符号的位置）\r\n","Called when the visitor visits a UsingDirectiveSyntax node.":"当访问者访问directirectivesyntax节点时，请致电。\r\n","\r\n              Looks up a localized string similar to Cannot define a new extension method because the compiler required type '{0}' cannot be found. Are you missing a reference to System.Core.dll?.\r\n            ":"\r\n              查找类似于类似的本地化字符串无法定义新的扩展方法，因为找不到编译器类型“ {0}”。您是否缺少对system.core.dll的引用？\r\n            \r\n","\r\n              Looks up a localized string similar to Field is never assigned to, and will always have its default value.\r\n            ":"\r\n              查找类似于字段的本地化字符串永远不会分配给，并且将始终具有其默认值。\r\n            \r\n"," \r\n            is set to ":" \r\n            被设定为\r\n","\r\n            In cases 1 and 2b, we expect (metadataName == sourceAssembly.MetadataName).\r\n            ":"\r\n            在情况1和2B中，我们期望（元数据== sourceassembly.metadataname）。\r\n            \r\n","\r\n            Gets a list of all the diagnostics in the syntax tree.\r\n            ":"\r\n            获取语​​法树中所有诊断的列表。\r\n            \r\n","\r\n              Looks up a localized string similar to Static classes cannot contain destructors.\r\n            ":"\r\n              查找类似于静态类的本地化字符串不能包含损坏器。\r\n            \r\n","\r\n            This is a map from TypeDef handle to the target ":"\r\n            这是从Typedef手柄到目标的地图\r\n","\r\n             PROPERTIES:\r\n             NOTE: we're not checking whether this property has at least the accessors\r\n             declared in the interface.  Dev10 considers it a match either way and,\r\n             reports failure to implement accessors separately.\r\n            \r\n             If the implementing type (i.e. the type with the interface in its interface\r\n             list) is in source, then we can ignore custom modifiers in/on the property\r\n             type because they will be copied into the bridge property that explicitly\r\n             implements the interface property (or they would be, if we created such\r\n             a bridge property).  Bridge *methods* (not properties) are inserted in \r\n             SourceNamedTypeSymbol.ImplementInterfaceMember.\r\n            \r\n             CONSIDER: The spec for interface mapping (13.4.4) could be interpreted to mean that this\r\n             property is not an implementation unless it has an accessor for each accessor of the\r\n             interface property.  For now, we prefer to represent that case as having an implemented\r\n             property and an unimplemented accessor because it makes finding accessor implementations\r\n             much easier.  If we decide that we want the API to report the property as unimplemented,\r\n             then it might be appropriate to keep current result internally and just check the accessors\r\n             before returning the value from the public API (similar to the way MethodSymbol.OverriddenMethod\r\n             filters MethodSymbol.OverriddenOrHiddenMembers.\r\n             ":"\r\n             特性：\r\n             注意：我们没有检查此属性至少是否具有登录器\r\n             在接口中声明。 dev10无论哪种方式都认为它是匹配的，\r\n             报告未能单独实施访问者。\r\n            \r\n             如果实现类型（即带有接口的类型\r\n             列表）在源中，然后我们可以忽略属性中/在属性中的自定义修饰符\r\n             类型是因为它们将被复制到明确的桥梁属性中\r\n             实现接口属性（如果我们创建了这样的话，它们将是\r\n             桥梁财产）。桥 *方法 *（非属性）插入\r\n             Sourcenamedtypesymbol.ImplementInterfacemember。\r\n            \r\n             考虑：接口映射的规格（13.4.4）可以解释为表示这\r\n             属性不是实现的\r\n             接口属性。目前，我们更喜欢表示该案件已实施\r\n             属性和未完成的登录器，因为它使查找登录器实现\r\n             容易得多。如果我们决定希望API将属性报告为未完成的属性，请\r\n             然后，在内部保持最新结果并只检查登录器可能是合适的\r\n             在从公共API返回值之前（类似于Methodsymbol.overridendmethod的方式\r\n             滤波器方法符号。\r\n             \r\n"," according to the\r\n            default EqualityComparer.\r\n            ":" 根据\r\n            默认EqualityComparer。\r\n            \r\n","\r\n              Looks up a localized string similar to Within cref attributes, nested types of generic types should be qualified.\r\n            ":"\r\n              查找类似于CREF属性的本地化字符串，应符合通用类型的嵌套类型。\r\n            \r\n","\r\n            Used to create a root binder.\r\n            ":"\r\n            用于创建根粘合剂。\r\n            \r\n","\r\n              Looks up a localized string similar to contravariant.\r\n            ":"\r\n              查找类似于contravariant的局部字符串。\r\n            \r\n","\r\n             Do the members differ in terms of tuple names (both in their return type and parameters), but would match ignoring names?\r\n            \r\n             We'll look at the result of equality without tuple names (1) and with tuple names (2).\r\n             The question is whether there is a change in tuple element names only (3).\r\n            \r\n             member1                  vs. member2                   | (1) | (2) |    (3)    |\r\n             `(int a, int b) M()`     vs. `(int a, int b) M()`      | yes | yes |   match   |\r\n             `(int a, int b) M()`     vs. `(int x, int y) M()`      | yes | no  | different |\r\n             `void M((int a, int b))` vs. `void M((int x, int y))`  | yes | no  | different |\r\n             `int M()`                vs. `string M()`              | no  | no  |   match   |\r\n            \r\n             ":"\r\n             成员在元组名称方面是否有所不同（在其返回类型和参数方面）是否有所不同，但是忽略名称会匹配吗？\r\n            \r\n             我们将查看没有元组名称（1）和元组名称（2）的平等结果。\r\n             问题是元组元素名称（3）是否存在更改。\r\n            \r\n             成员1与成员2 | （1）| （2）| （3）|\r\n             `（int a，int b）m（）`vs.`（int a，int b）m（）`|是|是|匹配|\r\n             `（int a，int b）m（）`vs.`（int x，int y）m（）`|是|否|不同的|\r\n             `void m（（int a，int b））是|否|不同的|\r\n             `int m（）`vs.否|否|匹配|\r\n            \r\n             \r\n","A ref or out parameter cannot have a default value":"ref或out参数不能具有默认值\r\n","Class which represents the syntax node for anonymous object creation expression.":"代表匿名对象创建表达式的语法节点的类。\r\n","Called when the visitor visits a XmlElementStartTagSyntax node.":"当访问者访问XMlelementStartTagSyntax节点时，请致电。\r\n","\r\n            The underlying PropertySymbol.\r\n            ":"\r\n            基础属性符号。\r\n            \r\n","A declaration is not allowed in this context.":"在这种情况下，不允许声明。\r\n","False to prevent selecting a params method in unexpanded form.":"false以防止以未表面形式选择参数方法。\r\n","Creates a new ContinueStatementSyntax instance.":"创建一个新的ContinuStatementSyntax实例。\r\n","\r\n              Looks up a localized string similar to Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy.\r\n            ":"\r\n              查找与'{1}'匹配'{3}'匹配'{2}'使用的汇编引用'{0}'的局部字符串，您可能需要提供运行时策略。\r\n            \r\n","\r\n            No diagnostics will be reported for such candidates unless they \"win\" overload resolution.\r\n            ":"\r\n            除非他们“赢得”过载分辨率，否则不会报告此类候选人的诊断。\r\n            \r\n","\r\n              Looks up a localized string similar to An expression tree may not contain a base access.\r\n            ":"\r\n              查找类似于表达树的本地化字符串可能不包含基本访问。\r\n            \r\n","\r\n            Associate the method with a particular property. Returns\r\n            false if the method is already associated with a property or event.\r\n            ":"\r\n            将方法与特定属性相关联。返回\r\n            false如果该方法已经与属性或事件关联。\r\n            \r\n","\r\n              Looks up a localized string similar to #pragma.\r\n            ":"\r\n              查找类似于#pragma的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to The language name is invalid.\r\n            ":"\r\n              查找类似于语言名称的本地化字符串无效。\r\n            \r\n",".\r\n            A value set representing values of type nint groups them all together, so that it is not possible to\r\n            distinguish one such value from another.  The flag ":"。\r\n            一个代表类型nint值组的值集的值集，因此不可能\r\n            区分一个这样的价值与另一个值。旗帜\r\n"," descriptions for all of the states, we create a new\r\n            ":" 对所有州的描述，我们创建一个新的\r\n            \r\n","The default value specified for parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments":"为参数'{0}'指定的默认值无效，因为它适用于不允许可选参数的上下文中使用的成员\r\n","\r\n              Looks up a localized string similar to '{0}' does not implement interface member '{1}'. Nullability of reference types in interface implemented by the base type doesn't match..\r\n            ":"\r\n              查找类似于“ {0}'的本地化字符串”不实现接口成员'{1}'。基本类型实现的接口中参考类型的无效性不匹配。\r\n            \r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 7.2. Please use language version {1} or greater..\r\n            ":"\r\n              查找类似于功能“ {0}”的本地化字符串在C＃7.2中不可用。请使用语言版本{1}或更大。\r\n            \r\n","\r\n            The list of custom modifiers, if any, associated with the ":"\r\n            自定义修饰符的列表（如果有的话）\r\n","The syntax node to perform lookup on":"进行查找的语法节点\r\n","\r\n            Usings can't see other usings, so this is extra info when looking at a namespace\r\n            or compilation unit scope.\r\n            ":"用途看不到其他使用，因此查看名称空间时，这是额外的信息\r\n            或编译单元范围。\r\n            \r\n","The return type of operator True or False must be bool":"运算符的返回类型是正确或错误的\r\n","\r\n            The default Visit method called when visiting any ":"\r\n            访问任何默认访问方法\r\n","Keyword 'base' is not available in the current context":"关键字“基础”在当前上下文中不可用\r\n","Fields of a struct must be fully assigned in a constructor before control is returned to the caller":"在将控件返回到呼叫者之前，必须在构造函数中完全分配结构的字段\r\n","\r\n            Given a syntax node that declares an indexer, get the corresponding declared symbol.\r\n            ":"\r\n            给定一个声明索引器的语法节点，获取相应的声明符号。\r\n            \r\n","\r\n            Returns true if the Unicode character is a hexadecimal digit.\r\n            ":"\r\n            如果Unicode字符是十六进制的数字，则返回true。\r\n            \r\n","\r\n            True if the type is not null.\r\n            ":"\r\n            如果类型不为空，则为true。\r\n            \r\n","\r\n            Get all of the DocumentationCommentTriviaSyntax associated with any declaring syntax of the\r\n            given symbol (except for partial methods, which only consider the part with the body).\r\n            ":"\r\n            获取所有与任何声明语法相关的DocumentationCommentTriviaSyntax\r\n            给定的符号（除部分方法外，仅考虑身体的零件）。\r\n            \r\n","'{0}' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static, or const, or read-write properties which are public and not static.":"'{0}'不是有效的命名属性参数。命名属性参数必须是不读取，静态或const或读取属性的字段，这些属性是公共而不是静态的。\r\n","\r\n            The exprReturnLabel is used to label the return handling code at the end of the async state-machine\r\n            method. Return expressions are rewritten as unconditional branches to exprReturnLabel.\r\n            ":"\r\n            Exprreturnlabel用于标记异步状态机末端的返回处理代码\r\n            方法。返回表达式被重写为无条件分支到Exprreturnlabel。\r\n            \r\n","Cannot convert anonymous method block without a parameter list to delegate type '{0}' because it has one or more out parameters":"如果没有参数列表，无法转换匿名方法块，以委托类型'{0}'，因为它具有一个或多个参数\r\n","Cannot pass null for friend assembly name":"无法通过null for Friend Assembly名称\r\n","\r\n            A map from a type parameter symbol to a boolean value that should be used as a replacement for a value returned by\r\n            ":"\r\n            从类型参数符号到布尔值的地图，应用作替换的值\r\n            \r\n","\r\n            Bind the RHS of a member access expression, given the bound LHS.\r\n            It is assumed that CheckValue has not been called on the LHS.\r\n            ":"\r\n            鉴于结合的LHS，结合成员访问表达式的RHS。\r\n            假定尚未在LHS上调用CheckValue。\r\n            \r\n","\r\n              Looks up a localized string similar to Argument {0} must be passed with the '{1}' keyword.\r\n            ":"\r\n              查找类似于参数{0}的本地化字符串必须使用'{1}'关键字传递。\r\n            \r\n","Constraint cannot be a dynamic type '{0}'":"约束不能是动态类型'{0}'\r\n","\r\n              Looks up a localized string similar to The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'notnull' constraint..\r\n            ":"\r\n              在通用类型或方法'{0}'中查找类似于类型的'{2}'类型的本地化字符串。类型参数的无效性'{2}'不匹配'notnull'约束。\r\n            \r\n","\r\n              Looks up a localized string similar to The range variable '{0}' cannot have the same name as a method type parameter.\r\n            ":"\r\n              查找类似于范围变量'{0}'的本地化字符串不能与方法类型参数具有相同的名称。\r\n            \r\n","\r\n            Returns true if locals are to be initialized\r\n            ":"\r\n            如果要初始化当地人，则返回true\r\n            \r\n","Nullability of reference types in return type doesn't match implemented member.":"返回类型中参考类型的无效性不匹配实现的成员。\r\n","Warning is overriding an error":"警告正在覆盖错误\r\n","lambda expression":"lambda表达\r\n","\r\n            Returns the type arguments that have been substituted for the type parameters.\r\n            If nothing has been substituted for a given type parameter,\r\n            then the type parameter itself is consider the type argument.\r\n            ":"\r\n            返回已替换为类型参数的类型参数。\r\n            如果没有什么可以代替给定类型参数，\r\n            然后，类型参数本身为类型参数。\r\n            \r\n","The name '{0}' does not exist in the current context":"名称'{0}'在当前上下文中不存在\r\n","The 'new()' constraint cannot be used with the 'struct' constraint":"“新（）”约束不能与“ struct”约束一起使用\r\n","\r\n              Looks up a localized string similar to An alias-qualified name is not an expression..\r\n            ":"\r\n              查找类似于别名合格名称的本地化字符串不是表达式。\r\n            \r\n","\r\n            The default implementation is always correct, but may be unnecessarily slow.\r\n            ":"\r\n            默认实现始终是正确的，但可能不必要地放慢速度。\r\n            \r\n","Use of unassigned out parameter '{0}'":"使用未分配的参数'{0}'\r\n","Rank of the array type.":"阵列类型的等级。\r\n",".Member*.\r\n            \r\n            Since completeParts is used as a flag indicating completion of other assignments \r\n            it must be volatile to ensure the read is not reordered/optimized to happen \r\n            before the writes.\r\n            ":"。成员*。\r\n            \r\n            由于完整部门用作指示完成其他作业的标志\r\n            确保未重新排序/优化的读取必须是波动的\r\n            在写作之前。\r\n            \r\n","\r\n            Represents an attribute applied to a Symbol.\r\n            ":"\r\n            表示应用于符号的属性。\r\n            \r\n","\r\n            During early attribute decoding, we consider a safe subset of all members that will not\r\n            cause cyclic dependencies.  Get all such members for this symbol.\r\n            \r\n            In particular, this method will return nested types and fields (other than auto-property\r\n            backing fields).\r\n            ":"\r\n            在早期属性解码期间，我们考虑所有成员的安全子集\r\n            导致循环依赖性。为此符号获取所有此类成员。\r\n            \r\n            特别是，此方法将返回嵌套类型和字段（自动范围除外\r\n            支持字段）。\r\n            \r\n","\r\n              Looks up a localized string similar to A '{0}' character may only be escaped by doubling '{0}{0}' in an interpolated string..\r\n            ":"\r\n              查找类似于“ {0}”字符的本地化字符串只能通过在interpolated字符串中加倍'{0} {0}'来逃脱。\r\n            \r\n","\r\n            This method is called by the binder from ":"\r\n            活页夹从\r\n","\r\n            Return the interface with an original definition matches\r\n            the original definition of the target. If the are no matches,\r\n            or multiple matches, the return value is null.\r\n            ":"\r\n            用原始定义匹配返回界面\r\n            目标的原始定义。如果没有比赛，\r\n            或多次匹配，返回值为null。\r\n            \r\n",".\r\n            Such a new change must be adjusted before being added to the result list.\r\n            ":"。\r\n            在添加结果列表之前，必须调整这样的新更改。\r\n            \r\n","\r\n            Variable declarations in global code are parsed as field declarations so we need to fallback if we encounter a declaration statement.\r\n            ":"\r\n            全局代码中的可变声明被解析为字段声明，因此，如果我们遇到声明声明，我们需要退缩。\r\n            \r\n","\r\n            as the one given.\r\n            ":"\r\n            作为给出的。\r\n            \r\n","\r\n            Gets the list of custom modifiers, if any, associated with the field.\r\n            ":"\r\n            获取与该字段关联的自定义修饰符列表。\r\n            \r\n","\r\n            Perform data flow analysis, reporting all necessary diagnostics.\r\n            ":"\r\n            执行数据流分析，报告所有必要的诊断。\r\n            \r\n","\r\n              Looks up a localized string similar to Return type of '{0}' is not CLS-compliant.\r\n            ":"\r\n              查找类似于“ {0}”类型的本地化字符串不符合CLS。\r\n            \r\n","Nullability of return type doesn't match overridden member (possibly because of nullability attributes).":"返回类型的无效性不匹配被覆盖的成员（可能是由于无效属性）。\r\n","\r\n            If the left and right are tuples of matching cardinality, we'll try to bind the operator element-wise.\r\n            When that succeeds, the element-wise conversions are collected. We keep them for semantic model.\r\n            The element-wise binary operators are collected and stored as a tree for lowering.\r\n            ":"\r\n            如果左右与匹配的基数相匹配，我们将尝试绑定操作员元素的元素。\r\n            成功时，会收集元素转换。我们将它们保留为语义模型。\r\n            收集元素的二进制操作员并将其存储为降低的树。\r\n            \r\n","\r\n            Symbol for a deconstruction local that might require type inference.\r\n            For instance, local ":"\r\n            解构本地的符号可能需要类型推理。\r\n            例如，本地\r\n","\r\n              Looks up a localized string similar to The first parameter of an extension method cannot be of type '{0}'.\r\n            ":"\r\n              查找类似于扩展方法的第一个参数类似的本地化字符串，不能是类型'{0}'。\r\n            \r\n","'await' requires that the return type '{0}' of '{1}.GetAwaiter()' have suitable 'IsCompleted', 'OnCompleted', and 'GetResult' members, and implement 'INotifyCompletion' or 'ICriticalNotifyCompletion'":"“等待”要求“ {1} .getawaiter（）'具有合适的'iSComplet'，'oncompleted'和“ getResult”成员，并实现“ InotifyCompletion”或'iCriticalnotifyCompletion'\r\n","Conditional member '{0}' cannot have an out parameter":"有条件的成员'{0}'不能具有OUT参数\r\n","\r\n            Update tracked value on assignment.\r\n            ":"\r\n            更新分配的跟踪值。\r\n            \r\n","\r\n            Report diagnostics if the await expression occurs in a context where it is not allowed.\r\n            ":"\r\n            报告诊断如果等待表达在不允许的情况下发生。\r\n            \r\n","\r\n            Gets the syntax node represented the structure of this trivia, if any. The HasStructure property can be used to \r\n            determine if this trivia has structure.\r\n            ":"\r\n            获取语​​法节点表示该琐事的结构，如果有的话。哈斯结构属性可用于\r\n            确定这个琐事是否具有结构。\r\n            \r\n","\r\n            Returns true if the type is a valid switch expression type.\r\n            ":"\r\n            如果类型是有效的开关表达式类型，则返回true。\r\n            \r\n","Nullability of reference types in return type doesn't match implemented member '{0}'.":"返回类型中参考类型的无效性不匹配实现的成员'{0}'。\r\n","Parameter {0} should not be declared with the '{1}' keyword":"参数{0}不应用'{1}'关键字声明\r\n","\r\n            Owning AssemblySymbol. This can be a PEAssemblySymbol or a SourceAssemblySymbol.\r\n            ":"\r\n            拥有汇编符号。这可以是peassemblysymbol或源切除术。\r\n            \r\n","Predefined type is defined in multiple assemblies in the global alias":"预定义的类型在全局别名的多个组件中定义\r\n","\r\n            Trivia nodes represent parts of the program text that are not parts of the\r\n            syntactic grammar, such as spaces, newlines, comments, preprocessor\r\n            directives, and disabled code.\r\n            ":"\r\n            琐事节点代表程序文本的一部分，不是\r\n            句法语法，例如空格，新线，评论，预处理器\r\n            指令和禁用代码。\r\n            \r\n","Extension methods must be defined in a top level static class; {0} is a nested class":"扩展方法必须在顶层静态类中定义； {0}是一个嵌套类\r\n","\r\n              Looks up a localized string similar to Invalid hash algorithm name: '{0}'.\r\n            ":"\r\n              查找类似于无效哈希算法名称的本地化字符串：'{0}'。\r\n            \r\n","\r\n              Looks up a localized string similar to CLS compliance checking will not be performed because it is not visible from outside this assembly.\r\n            ":"\r\n              查找类似于CLS合规性检查的本地化字符串将不会执行，因为从该组件外部看不到它。\r\n            \r\n","Newline in constant":"NEWLINE恒定\r\n"," which represents an invocation of a type's\r\n            \"Deconstruct\" method; ":" 代表一种类型的调用\r\n            “解构”方法；\r\n","\r\n            A map shared by all type parameters for an overriding method or a method\r\n            that explicitly implements an interface. The map caches the overridden method\r\n            and a type map from overridden type parameters to overriding type parameters.\r\n            ":"\r\n            由所有类型参数共享的地图，用于覆盖方法或方法\r\n            这明确实现了接口。地图缓存了覆盖方法\r\n            以及从覆盖类型参数到覆盖类型参数的类型映射。\r\n            \r\n","\r\n              Looks up a localized string similar to Structs without explicit constructors cannot contain members with initializers..\r\n            ":"\r\n              查找类似于没有明确构造函数的结构类似的本地化字符串，无法包含带有初始化器的成员。\r\n            \r\n","The kind of the quote token to be used to quote the value (e.g. \" or ').":"用来用来引用该值的报价令牌（例如“或'）。\r\n","\r\n            Index is used by the C# compiler to support the new index syntax\r\n            ":"\r\n            C＃编译器使用索引来支持新的索引语法\r\n            \r\n",", where the list elements start with a node and then alternate between\r\n            additional nodes and separator tokens.\r\n            ":"，列表元素以节点开头，然后在之间交替\r\n            其他节点和分离器令牌。\r\n            \r\n","The specific type of the element nodes.":"元素节点的特定类型。\r\n","ExpressionSyntax or BlockSyntax representing the body of the lambda expression.":"表示表示lambda表达的身体的表达式或块状字符。\r\n","\r\n            This compound assignment must have been created from C# code.\r\n            ":"\r\n            此复合分配必须是从C＃代码创建的。\r\n            \r\n","\r\n            Maps delegate signature shape (number of parameters and their ref-ness) to a synthesized generic delegate symbol.\r\n            Unlike anonymous types synthesized delegates are not available through symbol APIs. They are only used in lowered bound trees.\r\n            Currently used for dynamic call-site sites whose signature doesn't match any of the well-known Func or Action types.\r\n            ":"\r\n            地图委托签名形状（参数数及其参考）授予合成的通用委托符号。\r\n            与匿名类型不同，合成的代表无法通过符号API获得。它们仅用于降低的树木。\r\n            目前用于动态呼叫站点的签名不匹配任何众所周知的功能或动作类型。\r\n            \r\n","\r\n            C# language version 2\r\n            ":"\r\n            C＃语言版本2\r\n            \r\n","\r\n              Looks up a localized string similar to The params parameter cannot be declared as ref or out.\r\n            ":"\r\n              查找类似于参数的本地化字符串不能将其声明为参考或退出。\r\n            \r\n","\r\n            A common base class for lowering a decision dag.\r\n            ":"\r\n            降低决策DAG的普通基类。\r\n            \r\n","The parameter name '{0}' is a duplicate":"参数名称'{0}'是重复\r\n","\r\n              Looks up a localized string similar to A default literal 'default' is not valid as a pattern. Use another literal (e.g. '0' or 'null') as appropriate. To match everything, use a discard pattern '_'..\r\n            ":"\r\n              查找类似于默认字体“默认”的本地化字符串无效作为模式。适当地使用另一个文字（例如'0'或'null'）。要匹配所有内容，请使用丢弃模式'_'..\r\n            \r\n","\r\n              Looks up a localized string similar to using variable.\r\n            ":"\r\n              查找类似于使用变量的本地化字符串。\r\n            \r\n","Floating-point constant is outside the range of type '{0}'":"浮点常数不在类型'{0}'的范围之外\r\n","\r\n              Looks up a localized string similar to Reference to an implicitly-typed out variable '{0}' is not permitted in the same argument list..\r\n            ":"\r\n              在同一参数列表中不允许查找类似于对隐式输出变量'{0}'的引用类似的本地化字符串。\r\n            \r\n","\r\n            A set of namespace or type symbols with given qualified name (might comprise of types with multiple generic arities), \r\n            or an empty set if the member can't be found (the qualified name is ambiguous or the symbol doesn't exist).\r\n            ":"\r\n            一组具有给定合格名称的名称空间或类型符号（可能包括具有多个通用障碍的类型），\r\n            如果找不到成员，则为空集（合格的名称是模棱两可或不存在符号的）。\r\n            \r\n","Class which represents the syntax node for alias qualified name.":"代表别名合格名称的语法节点的类。\r\n","\r\n            Creates an IdentifierNameSyntax node.\r\n            ":"\r\n            创建一个标识名称列表节点。\r\n            \r\n","\r\n            Do not set this directly, except when setting the root scope. \r\n            Instead use ":"\r\n            不要直接设置此，除非设置根部范围。\r\n            而是使用\r\n","async function":"异步函数\r\n","\r\n            Override this property to return the child operations if the IOperation API corresponding to this bound node is not yet designed or implemented.\r\n            ":"\r\n            如果尚未设计或实现与此界点相对应的ioperation API，则覆盖此属性以返回子操作。\r\n            \r\n","A Windows Runtime event may not be passed as an out or ref parameter.":"Windows运行时事件可能不会作为OUT或REF参数传递。\r\n","\r\n            Does not consider ":"\r\n            不考虑 \r\n","Referenced assembly does not have a strong name":"引用的大会没有强烈的名字\r\n","\r\n            Contains the main method of this assembly, if there is one.\r\n            ":"\r\n            如果有一个，则包含此组件的主要方法。\r\n            \r\n","An assembly with the same simple name '{0}' has already been imported. Try removing one of the references (e.g. '{1}') or sign them to enable side-by-side.":"带有相同简单名称'{0}'的汇编已经导入。尝试删除其中一个参考文献（例如'{1}'）或签名以并排启用。\r\n","A list of syntax nodes that represents the content of the param element (e.g. \r\n            the description and meaning of the parameter).":"代表参数元素内容的语法节点列表（例如\r\n            参数的描述和含义）。\r\n","Type '{1}' already reserves a member called '{0}' with the same parameter types":"类型'{1}'已经保留了一个名为'{0}'的成员，具有相同的参数类型\r\n","\r\n            This class implements the region data flow analysis operations.  Region data flow analysis\r\n            provides information how data flows into and out of a region.  The analysis is done lazily.\r\n            When created, it performs no analysis, but simply caches the arguments. Then, the first time\r\n            one of the analysis results is used it computes that one result and caches it. Each result\r\n            is computed using a custom algorithm.\r\n            ":"该类实现区域数据流分析操作。区域数据流分析\r\n            提供信息如何流入和流出区域。分析懒惰地进行。\r\n            创建时，它不会执行任何分析，而只是缓存了参数。然后，第一次\r\n            使用了一个分析结果，它计算出一个结果并缓存它。每个结果\r\n            使用自定义算法计算。\r\n            \r\n","'{0}' specified for Main method must be a non-generic class, record, struct, or interface":"为主方法指定的'{0}'必须是非生成类，记录，结构或接口\r\n","\r\n            Note, the name of this field could be somewhat confusing because it is also \r\n            used to store models for attributes and default parameter values, which are\r\n            not members.\r\n            ":"\r\n            注意，此字段的名称可能有些混乱，因为它也是\r\n            用于存储属性和默认参数值的模型，\r\n            不是成员。\r\n            \r\n","\r\n              Looks up a localized string similar to Partial method declarations have inconsistent nullability in constraints for type parameter.\r\n            ":"\r\n              查找类似于部分方法声明的本地化字符串在类型参数的约束中具有不一致的无效性。\r\n            \r\n","Class which represents the syntax node for prefix unary expression.":"代表前缀单一表达式的语法节点的类。\r\n","\r\n              Looks up a localized string similar to Invalid #pragma checksum syntax; should be #pragma checksum \"filename\" \"{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\" \"XXXX...\".\r\n            ":"\r\n              查找类似于无效#pragma charchsum语法的本地化字符串；应该是#pragma charchsum“ filename”“ {xxxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx fileName”。\r\n            \r\n","\r\n            Creates a new compilation without any metadata references\r\n            ":"\r\n            创建一个新的汇编，而无需任何元数据参考\r\n            \r\n","Tuple element name '{0}' is inferred. Please use language version {1} or greater to access an element by its inferred name.":"推断元组元素名称'{0}'。请使用语言版本{1}或更大的内容，以通过其推断名称访问元素。\r\n","True if a diagnostic has been added.":"如果添加了诊断，则为是真的。\r\n","\r\n              Looks up a localized string similar to Invalid #pragma checksum syntax.\r\n            ":"\r\n              查找类似于无效#pragma charchsum语法的本地化字符串。\r\n            \r\n","Binder to use. If null, ":"使用的粘合剂。如果无效，\r\n","\r\n            The nullable state of an rvalue computed in ":"\r\n            计算出的RVALUE的无效状态\r\n","\r\n              Looks up a localized string similar to Type parameter has no matching typeparam tag in the XML comment (but other type parameters do).\r\n            ":"\r\n              查找类似于类型参数的本地化字符串在XML注释中没有匹配的Typeparam标签（但其他类型参数确实可以）。\r\n            \r\n","\r\n              Looks up a localized string similar to Referenced assembly '{0}' does not have a strong name..\r\n            ":"\r\n              查找类似于引用的汇编'{0}'的本地化字符串没有强的名称。\r\n            \r\n","Constructor method.":"构造方法。\r\n","Option '{0}' overrides attribute '{1}' given in a source file or added module":"选项'{0}'覆盖属性'{1}在源文件中给出或添加的模块\r\n","\r\n            Visit a boolean condition expression.\r\n            ":"\r\n            访问布尔条件表达。\r\n            \r\n","\r\n            The set of method symbols from which this conversion's method was chosen. \r\n            Only kept in the tree if the conversion was an error and overload resolution\r\n            was unable to choose a best method.\r\n            ":"选择此转换方法的一组方法符号。\r\n            仅在转换是错误和超载分辨率的情况下才保存在树上\r\n            无法选择最佳方法。\r\n            \r\n","<!-- Badly formed XML comment ignored for member \"{0}\" -->":"<！ - 成员“ {0}”  - >不忽略的XML注释不佳 - >\r\n","'{0}' is not a recognized attribute location. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.":"'{0}'不是公认的属性位置。此声明的有效属性位置为“ {1}”。该块中的所有属性将被忽略。\r\n","\r\n            As in Dev10, we won't report anything if the attribute TYPES are missing (note: missing, not erroneous) because we won't\r\n            synthesize anything in that case.  We'll only report diagnostics if the attribute TYPES are present and either they or \r\n            the attribute CONSTRUCTORS have errors.\r\n            ":"\r\n            与dev10一样，如果缺少属性类型，我们不会报告任何内容（注意：缺少，不是错误），因为我们不会\r\n            在这种情况下合成任何内容。如果存在属性类型以及它们或\r\n            属性构造函数有错误。\r\n            \r\n","A reference to a volatile field will not be treated as volatile":"对挥发性场的引用将不会被视为挥发性\r\n","Whether Nullable Reference Types feature is enabled globally":"全球启用了无效的参考类型功能是否启用\r\n"," property. Used when accessing the property for a type parameter symbol\r\n            that has an entry in the map is not safe and can cause a cycle.  \r\n            ":" 财产。访问类型参数符号的属性时使用\r\n            在地图中有一个条目是不安全的，可能会导致周期。\r\n            \r\n","The awaitable provided by ":"等待的\r\n","The string value to be represented by the returned token.":"返回令牌要表示的字符串值。\r\n","The stream cannot be written to.":"流无法写入。\r\n","Bad array declarator: To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type.":"不良数组声明器：要声明一个托管数组，等级规范符先于变量的标识符。要声明固定的大小缓冲区字段，请在字段类型之前使用固定的关键字。\r\n","\r\n              Looks up a localized string similar to '{0}': cannot reference a type through an expression; try '{1}' instead.\r\n            ":"\r\n              查找类似于'{0}'：无法通过表达式引用类型的本地化字符串；尝试'{1}'而不是。\r\n            \r\n","Compilation that owns the symbol table.":"拥有符号表的汇编。\r\n","Cannot return an expression of type 'void'":"无法返回“ void”类型的表达\r\n","\r\n            Full type name with generic name mangling.\r\n            ":"\r\n            带有通用名称的完整名称。\r\n            \r\n",",\r\n            parameterized by a type class\r\n            ":"，，，，\r\n            由类型类参数化\r\n            \r\n","\r\n            Returns the scope to which values of a local can \"escape\" via ordinary assignments\r\n            Makes sense only for ref-like locals with formal scopes - i.e. source locals\r\n            ":"\r\n            返回本地值可以通过普通作业“逃脱”的范围\r\n            仅对于具有正式范围的涉及当地人才有意义 - 即源本地人\r\n            \r\n"," attribute hasn't been cracked yet.\r\n            ":" 属性尚未破解。\r\n            \r\n","\r\n              Looks up a localized string similar to Cryptographic failure while creating hashes..\r\n            ":"\r\n              在创建哈希时，查找类似于加密故障的局部字符串。\r\n            \r\n","True if no constructed generic type was encountered.":"如果没有遇到构造的通用类型，则为真实。\r\n","A syntax node that represents a parsed constructor initializer.\r\n            This node should not be present in the syntax tree associated with this object.":"代表解析的构造函数初始化器的语法节点。\r\n            该节点不应存在于与此对象关联的语法树中。\r\n","\r\n            Returns true if this assembly might contain extension methods. If this property\r\n            returns false, there are no extension methods in this assembly.\r\n            ":"\r\n            如果此组件可能包含扩展方法，则返回true。如果此属性\r\n            返回错误，此组件中没有扩展方法。\r\n            \r\n","Error opening icon file {0} -- {1}":"打开图标文件{0}  -  {1}\r\n","\r\n              Looks up a localized string similar to Partial methods with only a defining declaration or removed conditional methods cannot be used in expression trees.\r\n            ":"\r\n              查找类似于只有定义声明或删除条件方法的部分方法的本地化字符串，不能在表达树中使用。\r\n            \r\n"," false will return the same value.\r\n             - If no symbol is returned for ":" fals会返回相同的值。\r\n              - 如果没有返回符号\r\n","\r\n            The candidate member was accepted in its expanded form, after expanding a \"params\" parameter.\r\n            ":"\r\n            在扩展了“参数”参数后，候选成员以其扩展形式接受。\r\n            \r\n","Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public instance or extension definition for '{1}'. Did you mean 'foreach' rather than 'await foreach'?":"异步语句无法在类型'{0}'的变量上操作，因为'{0}'不包含'{1}'的公共实例或扩展定义。您的意思是“ foreach”而不是“等待foreach”？\r\n","\r\n            This instance is used as a fallback when it is determined that one member does not implicitly implement\r\n            another. It applies a looser check to determine whether the proposed implementation should be reported\r\n            as \"close\".\r\n            ":"\r\n            当确定一个成员不会隐式实施时，此实例被用作后备\r\n            其他。它应用了一个宽松的检查以确定是否应报告拟议的实施\r\n            为“关闭”。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' is not CLS-compliant because base interface '{1}' is not CLS-compliant.\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串不符合cls cls，因为基本接口'{1}'不符合cls cls。\r\n            \r\n","\r\n            Replace a BoundTypeOrValueExpression with a BoundExpression for either a type (if useType is true)\r\n            or a value (if useType is false).  Any other node is unmodified.\r\n            ":"\r\n            用任何一种类型的界表达替换边界表达式（如果USETYPE为true）\r\n            或值（如果使用情况是错误）。任何其他节点都没有修改。\r\n            \r\n","\r\n            Removes duplicate entries in ":"\r\n            删除重复的条目\r\n","\r\n            Is this a symbol for an anonymous type (including delegate).\r\n            ":"\r\n            这是匿名类型（包括委托）的符号。\r\n            \r\n","Called when the visitor visits a LocalFunctionStatementSyntax node.":"当访问者访问localFunctionStattatementsyntax节点时调用。\r\n","SyntaxToken representing the close brace.":"Syntaxtoken代表近距离支撑。\r\n","\r\n            A region analysis walker that records reads and writes of all variables, both inside and outside the region.\r\n            ":"\r\n            记录的区域分析步行者读取和写入该地区内部和外部的所有变量。\r\n            \r\n","Class which represents the syntax node for a this expression.":"代表该表达式的语法节点的类。\r\n","\r\n              Looks up a localized string similar to '{0}': a parameter, local variable, or local function cannot have the same name as a method type parameter.\r\n            ":"\r\n              查找类似于“ {0}”的局部字符串：参数，本地变量或本地函数不能与方法类型参数具有相同的名称。\r\n            \r\n","Creates a new CompilationUnitSyntax instance.":"创建一个新的compilationunitsyntax实例。\r\n","\r\n              Looks up a localized string similar to Property accessor already defined.\r\n            ":"\r\n              查找类似于已经定义的属性登录器的本地化字符串。\r\n            \r\n","\r\n            Returns true if this is the original definition of this symbol.\r\n            ":"\r\n            如果这是此符号的原始定义，则返回true。\r\n            \r\n","\r\n            The set of trees for which enough analysis was performed in order to record usage of using directives.\r\n            Once all trees are processed the value is set to null.\r\n            ":"\r\n            为了记录使用指令的用法，进行了足够的分析的树一组。\r\n            一旦处理了所有树，则将值设置为空。\r\n            \r\n","\r\n            Returns \"Item1\" for position=1\r\n            Returns \"Item12\" for position=12\r\n            ":"\r\n            返回位置= 1的“ item1”\r\n            返回位置= 12的“ item12”\r\n            \r\n","Given operation has a non-null parent.":"给定的操作具有非无效父母。\r\n","\r\n            In a case if it cannot a bad expression is returned and diagnostics is produced.\r\n            ":"\r\n            在情况下，如果无法返回不良表达并产生诊断。\r\n            \r\n","\r\n            Represents a Source custom attribute specification\r\n            ":"\r\n            表示源自定义属性规范\r\n            \r\n","\r\n            Binds the expression for a pattern.  Sets ":"\r\n            结合图案的表达式。套\r\n","!((a == b).op_false)":"！（（a == b）.op_false）\r\n","\r\n              Looks up a localized string similar to element.\r\n            ":"\r\n              查找类似于元素的本地化字符串。\r\n            \r\n","\r\n            Construct a parameter symbol for a property loaded from metadata.\r\n            ":"\r\n            为从元数据加载的属性构建一个参数符号。\r\n            \r\n","\r\n            Gets the list of named field or property value arguments specified by this application of the attribute.\r\n            ":"\r\n            获取本属性应用程序指定的命名字段或属性值参数的列表。\r\n            \r\n","The kind of the quote for the referenced item in the cref attribute.":"CREF属性中引用项目的报价类型。\r\n","\r\n            Infer the result type of the switch expression by looking for a common type\r\n            to which every arm's expression can be converted.\r\n            ":"\r\n            通过寻找公共类型来推断开关表达式的结果类型\r\n            每个手臂的表达都可以转换为此。\r\n            \r\n","Ref mismatch between '{0}' and delegate '{1}'":"参考“ {0}'和委托'{1}'之间的不匹配\r\n","\r\n            Represents a reference to a generic method instantiation, closed over type parameters,\r\n            e.g. MyNamespace.Class.Method{T}()\r\n            ":"\r\n            代表对通用方法实例化的引用，封闭了类型参数，\r\n            例如mynamespace.class.method {t}（）\r\n            \r\n","\r\n            Expression is passed as a ref or out parameter or assigned to a byref variable.\r\n            ":"\r\n            表达式作为参数或输出参数传递或分配给BYREF变量。\r\n            \r\n","\r\n              Looks up a localized string similar to using declarations.\r\n            ":"\r\n              查找类似于使用声明的本地化字符串。\r\n            \r\n"," are all in a type that derives from the type containing\r\n            ":" 全部都是从包含类型的类型中\r\n            \r\n","\r\n            Never returns null (empty instead).\r\n            Expected implementations: for source, return type and field members; for metadata, return all members.\r\n            ":"\r\n            永远不要返回null（而代替为空）。\r\n            预期实现：用于源，返回类型和现场成员；对于元数据，请退还所有成员。\r\n            \r\n","\r\n              Looks up a localized string similar to Interface '{0}' has an invalid source interface which is required to embed event '{1}'..\r\n            ":"\r\n              查找类似于接口'{0}'的本地化字符串具有无效的源接口，该接口是嵌入事件'{1}'..所需的无效源接口。\r\n            \r\n","\r\n            Any diagnostics reported while converting the Namespace/Type syntax into the Declaration\r\n            instance.  Generally, we determine and store some diagnostics here because we don't want \r\n            to have to go back to Syntax when we have our NamespaceSymbol or NamedTypeSymbol.\r\n            ":"\r\n            在将名称空间/类型语法转换为声明时报告的任何诊断\r\n            实例。通常，我们在这里确定并存储一些诊断，因为我们不想要\r\n            当我们拥有命名paceSymbol或名为typesymbol时，必须返回语法。\r\n            \r\n","\r\n            Spec 7.7.7.1:\r\n            An awaitable expression t has an accessible instance or extension method called GetAwaiter with no\r\n            parameters and no type parameters, and a return type A that meets the additional requirements for an\r\n            Awaiter.\r\n            NOTE: this is an error in the spec.  An extension method of the form\r\n            Awaiter<T> GetAwaiter<T>(this Task<T>) may be used.\r\n            ":"\r\n            规格7.7.7.1：\r\n            等待的表达式T具有可访问的实例或扩展方法，称为Getawaiter，没有\r\n            参数和无类型参数，以及满足额外要求的返回类型A\r\n            服务员。\r\n            注意：这是规格中的错误。形式的扩展方法\r\n            可以使用getawaiter <t>（此任务<t>）。\r\n            \r\n","[0].\r\n            If it is an extension method, it is returned in reduced form.\r\n            ":"[0]。\r\n            如果是扩展方法，则以还原的形式返回。\r\n            \r\n","Called when the visitor visits a ThrowStatementSyntax node.":"当访问者访问throwStatementSyntax节点时，请致电。\r\n","\r\n            Returns true if nullable analysis is enabled for the method. For constructors, the\r\n            region considered may include other constructors and field and property initializers.\r\n            ":"\r\n            如果对该方法启用了无效的分析，则返回true。对于构造函数，\r\n            所考虑的区域可能包括其他构造函数，现场和属性初始化器。\r\n            \r\n","\r\n              Looks up a localized string similar to Compiler version: '{0}'. Language version: {1}..\r\n            ":"\r\n              查找类似于编译器版本的本地化字符串：'{0}'。语言版本：{1} ..\r\n            \r\n","\r\n            Indicates that the unsafe diagnostics are not reported in the current context, regardless\r\n            of whether or not it is (part of) an unsafe region.\r\n            ":"\r\n            表明在当前情况下未报告不安全的诊断，无论如何\r\n            它是否是（一部分）不安全的区域。\r\n            \r\n","\r\n              Looks up a localized string similar to An expression tree may not contain an indexed property.\r\n            ":"\r\n              查找类似于表达树的本地化字符串可能不包含索引属性。\r\n            \r\n","\r\n            A binder that places class/interface/struct/delegate type parameters in scope\r\n            ":"\r\n            将类/接口/结构/委托参数放置在范围中的活页夹\r\n            \r\n","\r\n            Emit nullable attributes for only those members that are visible outside the assembly\r\n            (public, protected, and if any [InternalsVisibleTo] attributes, internal members).\r\n            If false, attributes are emitted for all members regardless of visibility.\r\n            ":"\r\n            仅适用于大会外可见成员的无效属性\r\n            （公共，受保护，以及任何[InternalSvisibleto]属性，内部成员）。\r\n            如果是错误的，则不论可见性如何，所有成员都会发出属性。\r\n            \r\n","Syntax Node.":"语法节点。\r\n","\r\n              Looks up a localized string similar to Error building Win32 resources -- {0}.\r\n            ":"\r\n              查找类似于错误构建Win32资源的本地化字符串 -  {0}。\r\n            \r\n","\r\n            The .Cast<T>() operation generated from the query range variable's type restriction,\r\n            or null if the type restriction isn't specified. \r\n            ":"\r\n            从查询范围变量限制生成的.cast <t>（）操作，\r\n            或null如果未指定类型限制。\r\n            \r\n","\r\n            Returns 'NotApplicable'\r\n            ":"\r\n            返回“非适当”\r\n            \r\n","\r\n            This will provide a useful representation, but it would be clearer to call ":"\r\n            这将提供有用的表示形式，但要打电话更清楚\r\n","\r\n              Looks up a localized string similar to A void or int returning entry point cannot be async.\r\n            ":"\r\n              查找类似于void或int返回的入口点类似的局部字符串，不能是异步。\r\n            \r\n","Nullability of reference types in return type of '{0}' doesn't match the target delegate '{1}' (possibly because of nullability attributes).":"“ {0}”返回类型中参考类型的无效性不匹配目标委托'{1}'（可能是由于无效属性）。\r\n","Indices and ranges":"指数和范围\r\n","\r\n            Classifies the different ways in which a found symbol might be incorrect.\r\n            Higher values are considered \"better\" than lower values. These values are used\r\n            in a few different places:\r\n               1) Inside a LookupResult to indicate the quality of a symbol from lookup.\r\n               2) Inside a bound node (for example, BoundBadExpression), to indicate\r\n                  the \"binding quality\" of the symbols referenced by that bound node.\r\n               3) Inside an error type symbol, to indicate the reason that the candidate symbols\r\n                  in the error type symbols were not good.\r\n                  \r\n            While most of the values can occur in all places, some of the problems are not\r\n            detected at lookup time (e.g., NotAVariable), so only occur in bound nodes.\r\n            ":"\r\n            分类发现的符号可能不正确的不同方式。\r\n            较高的值被认为是“更好”的值。这些值被使用\r\n            在几个不同的地方：\r\n               1）在查找中，以指示查找中的符号的质量。\r\n               2）在一个绑定的节点内（例如，boundbadexpression），以指示\r\n                  该结合节点引用的符号的“绑定质量”。\r\n               3）在错误类型符号内，以指示候选符号的原因\r\n                  在错误类型中，符号不好。\r\n                  \r\n            虽然大多数值都可以在所有地方发生，但其中一些问题不是\r\n            在查找时间检测到（例如，均值），因此仅出现在绑定节点中。\r\n            \r\n","\r\n              Looks up a localized string similar to The expression must be of type '{0}' to match the alternative ref value.\r\n            ":"\r\n              查找类似于表达式的本地化字符串必须为“ {0}”类型，以匹配替代参考值。\r\n            \r\n","\r\n            Visit the given type and, in the case of compound types, visit all \"sub type\".\r\n            One of the predicates will be invoked at each type. If the type is a\r\n            TypeWithAnnotations, ":"\r\n            请访问给定类型，对于复合类型，请访问所有“子类型”。\r\n            其中一个谓词将在每种类型上调用。如果类型是\r\n            打字，\r\n","\r\n              Looks up a localized string similar to Type parameter declaration must be an identifier not a type.\r\n            ":"\r\n              查找类似于类型参数声明的本地化字符串必须是标识符而不是类型。\r\n            \r\n","\r\n            Creates an empty list of syntax nodes.\r\n            ":"创建一个空语节点的空列表。\r\n            \r\n","Creates a new DeclarationExpressionSyntax instance.":"创建一个新的声明expressionsyntax实例。\r\n","warning action enable":"警告行动启用\r\n","\r\n            All user-defined and long-lived synthesized variables must return a reference to a node that is \r\n            tracked by the EnC diffing algorithm. For example, for ":"\r\n            所有用户定义和长期综合变量的所有用户定义的变量都必须返回对一个节点的引用\r\n            由ENC扩散算法跟踪。例如，对于\r\n","\r\n            Binds the type for the syntax taking into account possibility of the type being a keyword.\r\n            If the syntax binds to an alias symbol to a type, it returns the alias symbol.\r\n            PREREQUISITE: syntax should be checked to match the keyword, like ":"\r\n            考虑到类型是关键字的可能性，将语法类型绑定。\r\n            如果语法与别名符号结合到类型，则返回别名符号。\r\n            先决条件：应该检查语法以匹配关键字，例如\r\n","\r\n            Returns true if this local variable was declared in a catch clause. \r\n            ":"如果在捕获子句中声明此局部变量，则返回true。\r\n            \r\n","Creates a new OmittedArraySizeExpressionSyntax instance.":"创建一个新的省略artiteRaysizeexpressionsyntax实例。\r\n","\r\n              Looks up a localized string similar to A lambda expression with a statement body cannot be converted to an expression tree.\r\n            ":"\r\n              查找类似于语句主体的lambda表达式类似的局部字符串，无法转换为表达树。\r\n            \r\n","Base list syntax.":"基本列表语法。\r\n","A member on currType that could implement the interface, or null.":"CurrType上的成员可以实现接口或null。\r\n","\r\n              Looks up a localized string similar to The field has multiple distinct constant values..\r\n            ":"\r\n              查找类似于该字段的局部字符串具有多个不同的常数值。\r\n            \r\n","\r\n            Implicit and explicit enumeration conversions are described in sections 6.1.3 and 6.2.2 of the C# language specification.\r\n            ":"\r\n            在C＃语言规范的第6.1.3和6.2.2节中描述了隐式和明确的枚举转换。\r\n            \r\n","\r\n            Infer return type. If `nullableState` is non-null, nullability is also inferred and `NullableWalker.Analyze`\r\n            uses that state to set the inferred nullability of variables in the enclosing scope. `conversions` is\r\n            only needed when nullability is inferred.\r\n            ":"\r\n            推断返回类型。如果`nulleableState`无效，也可以推断出nullable Walker.Analyze`'Nullability'\r\n            使用该状态设置封闭范围中变量的推断可取性。 “转换”是\r\n            仅在推断出无效性时才需要。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' cannot implement interface member '{1}' in type '{2}' because the target runtime doesn't support default interface implementation..\r\n            ":"\r\n              在类型'{2}'中查找类似于'{0}'类似于“ {0}”的本地化字符串，因为目标运行时不支持默认接口实现。\r\n            \r\n","\r\n              Looks up a localized string similar to dynamic.\r\n            ":"\r\n              查找类似于动态的本地化字符串。\r\n            \r\n","A typeclass supporting that floating-point type.":"一种支持该浮点类型的类型类型。\r\n","\r\n              Looks up a localized string similar to Filter expression is a constant 'true', consider removing the filter.\r\n            ":"\r\n              查找类似于过滤器表达式的局部字符串是常数“ true”，请考虑删除过滤器。\r\n            \r\n","\r\n            The current offset inside the window (relative to the window start).\r\n            ":"窗口内的当前偏移量（相对于窗口启动）。\r\n            \r\n"," when the raw value belongs to the C# syntax kind; otherwise, ":" 当原始值属于C＃语法类型时；否则，\r\n","\r\n            Represents a non-element field of a tuple type (such as (int, byte).Rest)\r\n            that is backed by a real field within the tuple underlying type.\r\n            ":"\r\n            代表元组类型的非元素字段（例如（int，byte）.rest）\r\n            这是由元组基础类型中的真实场所支持的。\r\n            \r\n","\r\n              Looks up a localized string similar to The 'as' operator may produce a null value for a type parameter..\r\n            ":"\r\n              查找类似于“ AS”运算符的本地化字符串可能会为类型参数产生零值。\r\n            \r\n","The symbols that were declared.":"声明的符号。\r\n"," itself) and populates ":" 本身）和人口\r\n","Decoded well-known attribute data, could be null.":"解码众所周知的属性数据可能为无效。\r\n","\r\n            Validate attribute usage target and duplicate attributes.\r\n            ":"\r\n            验证属性使用目标和重复属性。\r\n            \r\n","The tuple element name is ignored because a different name or no name is specified by the assignment target.":"元组元素名称被忽略，因为分配目标指定了不同的名称或未指定名称。\r\n","Attribute will be ignored in favor of the instance appearing in source":"属性将被忽略，而有利于出现在源中的实例\r\n","\r\n              Looks up a localized string similar to '{0}': cannot have instance property or field initializers in structs.\r\n            ":"\r\n              查找类似于'{0}'：无法在structs中具有实例属性或字段初始化器的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to No such label '{0}' within the scope of the goto statement.\r\n            ":"\r\n              在Goto语句的范围内查找类似于没有此类标签'{0}'的本地化字符串。\r\n            \r\n","Gets the \"delegate\" keyword.":"获取“委托”关键字。\r\n","CallerFilePathAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'":"无法应用CallerFilePathAttribute，因为从类型'{0}'type'{1}'类型中没有标准转换\r\n","An expression evaluating the argument later (e.g. reading the temp), including a possible deferred user-defined conversion.":"稍后评估参数的表达式（例如，读取温度），包括可能的递延用户定义的转换。\r\n","\r\n            Given a syntax node of an argument expression, get the declared symbol.\r\n            ":"\r\n            给定参数表达式的语法节点，获取声明的符号。\r\n            \r\n","Represents a default label within a switch statement.":"表示开关语句中的默认标签。\r\n","var (x, y) = ...":"var（x，y）= ...\r\n","\r\n            Creates a syntax node for a preliminary element within a xml documentation comment.\r\n            ":"\r\n            在XML文档注释中为初步元素创建语法节点。\r\n            \r\n","\r\n            If the method has both block body and an expression body\r\n            present, this is not treated as expression-bodied.\r\n            ":"\r\n            如果该方法同时具有块体和表达式身体\r\n            现在，这不是被视为表达的。\r\n            \r\n","Creates a new VariableDeclaratorSyntax instance.":"创建一个新的variabledeclaratorsyntax实例。\r\n","\r\n            Given a parameter declaration syntax node, get the corresponding symbol.\r\n            ":"\r\n            给定参数声明语法节点，获取相应的符号。\r\n            \r\n"," Name to be used as metadata name during emit ":" 发射期间用作元数据名称的名称\r\n","An add or remove accessor must have a body":"添加或卸下登录器必须具有身体\r\n","\r\n            Default char set for contained types, or null if not specified.\r\n            ":"\r\n            默认字符集用于包含类型，如果未指定为null。\r\n            \r\n","Called when the visitor visits a ConversionOperatorMemberCrefSyntax node.":"当访问者访问转换式室crefsyntax节点时，请致电。\r\n","\r\n            Gets the diagnostics produced during symbol declaration headers.  There are no diagnostics for accessor or\r\n            method bodies, for example.\r\n            ":"\r\n            获取在符号声明标题中产生的诊断。没有访问者的诊断或\r\n            例如，方法主体。\r\n            \r\n","True if it is a method group conversion":"如果是方法组转换，则为true\r\n","\r\n            Helper method that calls ":"\r\n            呼叫的帮助方法\r\n","The type of the top-most frame":"最高框架的类型\r\n","\r\n              Looks up a localized string similar to /REFERENCEPATH option.\r\n            ":"\r\n              查找类似于 /参考路径选项的本地化字符串。\r\n            \r\n","Methods list":"方法列表\r\n",", using the decoded dynamic transforms attribute argument,\r\n            by replacing each occurrence of ":"，使用解码的动态变换属性参数，\r\n            通过替换每次发生\r\n","An expression tree may not contain an anonymous method expression":"表达树可能不包含匿名方法表达式\r\n","Builder to fill in. ":"建造者填写。\r\n","Type '{0}' cannot be embedded because it is a nested type. Consider setting the 'Embed Interop Types' property to false.":"类型'{0}'不能嵌入，因为它是嵌套类型。考虑将“嵌入Interop类型”属性设置为false。\r\n"," to get the combo but some (object and array initializers) \r\n            hoist all call-site initialization code and emit multiple invocations of the same site.\r\n            ":" 要获得组合，但有些（对象和数组初始化器）\r\n            提起所有呼叫站点初始化代码，并发出同一站点的多个调用。\r\n            \r\n"," token that is closing ":" 即将关闭的令牌\r\n","Throw expressions":"投掷表情\r\n","\r\n            The scope within a documentation cref.  Contains the implicitly declared type parameters\r\n            of the cref (see ":"\r\n            文档CREF中的范围。包含隐式声明的类型参数\r\n            cref（见\r\n","; Override this method with\r\n            specific implementation; Calling default ":";用\r\n            具体实施；调用默认值\r\n","True to give an error when a non-identifier\r\n            type argument is seen, false to accept.  No change in the shape of the tree.":"当非标识符\r\n            可以看到类型的参数，错误接受。树的形状没有变化。\r\n",").\r\n            When we enter a `try` that has a `finally`, we'll use the label directly preceding the `finally`.\r\n            When we enter a `try` that has an extracted `finally`, we will use the label preceding the extracted `finally`.\r\n            ":"）。\r\n            当我们输入具有``终于''的“尝试”时，我们将直接使用``最终''之前的标签。\r\n            当我们输入带有``最后提取''的“尝试”时，我们将使用提取的``最终''之前的标签。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': new protected member declared in sealed class.\r\n            ":"\r\n              查找类似于“ {0}”的局部字符串：在密封类中声明的新受保护成员。\r\n            \r\n","Called when the visitor visits a LoadDirectiveTriviaSyntax node.":"当访问者访问LoadDirectivtriviaSyntax节点时调用。\r\n",".\r\n            Must be implemented by all methods that may contain user code.\r\n            ":"。\r\n            必须通过所有可能包含用户代码的方法实现。\r\n            \r\n","Class which represents the syntax node for a simple lambda expression.":"代表简单lambda表达式的语法节点的类。\r\n","\r\n            If a local function is in the set, at some point in the code it is converted\r\n            to a delegate and should then not be optimized to a struct closure.\r\n            Also contains all lambdas (as they are converted to delegates implicitly).\r\n            ":"\r\n            如果集合中的本地函数，则在代码中的某个时刻将其转换\r\n            委托，然后不应将其优化为结构封闭。\r\n            还包含所有lambdas（因为它们被隐式转换为代表）。\r\n            \r\n",".\r\n            Returns imediately in the first case,\r\n            Replaces ":"。\r\n            在第一种情况下立即返回，\r\n            替换\r\n","No analyzers found":"没有发现分析仪\r\n","\r\n            Given a tuple element syntax, get the corresponding symbol.\r\n            ":"\r\n            给定元组元素语法，获取相应的符号。\r\n            \r\n","\r\n            Returns true if the nullable analysis is needed for the region represented by ":"\r\n            如果需要对代表的区域进行无效分析，则返回为真\r\n","\r\n              Looks up a localized string similar to Yield statements may not appear at the top level in interactive code..\r\n            ":"\r\n              在交互式代码中查找类似于产量语句的本地化字符串可能不会出现在顶级。\r\n            \r\n","\r\n            If the receiver is an indexer expression, the list will contain the indexers that could be applied to the result\r\n            of accessing the indexer, not the set of candidates that were considered during construction of the indexer expression.\r\n            ":"\r\n            如果接收器是索引器表达式，则列表将包含可以应用于结果的索引器\r\n            访问索引者，而不是在构造索引表达式期间考虑的一组候选者。\r\n            \r\n","\r\n            Get a ModuleSymbol that refers to the module being created by compiling all of the code.\r\n            By getting the GlobalNamespace property of that module, all of the namespaces and types\r\n            defined in source code can be obtained.\r\n            ":"\r\n            获取一个模块符号，该模块是指通过编译所有代码创建的模块。\r\n            通过获取该模块的全局名称属性，所有名称空间和类型\r\n            可以在源代码中定义。\r\n            \r\n","Unrecognized option: '{0}'":"未识别的选项：'{0}'\r\n","\r\n              Looks up a localized string similar to Attribute '{0}' is only valid on classes derived from System.Attribute.\r\n            ":"\r\n              查找类似于属性'{0}'的本地化字符串仅在从system.attribute派生的类中有效。\r\n            \r\n","\r\n            Returns true if tuple type syntax can be used to refer to the tuple type without loss of information.\r\n            For example, it cannot be used when extension tuple is using non-default friendly names. \r\n            ":"\r\n            如果可以使用元组类型语法来参考元组类型，则返回true。\r\n            例如，当扩展元组使用非默认友好名称时，无法使用它。\r\n            \r\n","\r\n              Looks up a localized string similar to Command-line syntax error: Missing Guid for option '{1}'.\r\n            ":"\r\n              查找类似于命令行语法错误的本地化字符串：选项'{1}'丢失GUID。\r\n            \r\n","implicitly typed array":"隐式键入数组\r\n","\r\n              Looks up a localized string similar to readonly references.\r\n            ":"\r\n              查找类似于阅读引用的本地化字符串。\r\n            \r\n","Identifier differing only in case is not CLS-compliant":"仅在情况下不同的标识符不符合CLS\r\n","\r\n            Map from switch section's syntax to the lowered code for the section.\r\n            ":"\r\n            从开关部分的语法映射到该部分的降低代码。\r\n            \r\n","\r\n              Looks up a localized string similar to An expression tree lambda may not contain a call to a method, property, or indexer that returns by reference.\r\n            ":"\r\n              查找类似于表达树lambda的本地化字符串可能不包含对通过参考返回的方法，属性或索引器的调用。\r\n            \r\n","\r\n              Looks up a localized string similar to Matching the tuple type '{0}' requires '{1}' subpatterns, but '{2}' subpatterns are present..\r\n            ":"\r\n              查找类似于匹配元组类型'{0}'需要'{1}'subpattern的本地化字符串，但是存在'{2}'subpattern。\r\n            \r\n","\r\n            Compute the underlying lambda parameter symbol for a range variable, if any.\r\n            ":"\r\n            计算范围变量的基础lambda参数符号（如果有）。\r\n            \r\n","\r\n            Return true if the type contains any tuples with element names.\r\n            ":"\r\n            如果类型包含任何带有元素名称的元组，则返回true。\r\n            \r\n","Pointers and fixed size buffers may only be used in an unsafe context":"指针和固定尺寸缓冲区只能在不安全的上下文中使用\r\n","\r\n              Looks up a localized string similar to '{0}' is of type '{1}'. The type specified in a constant declaration must be sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, an enum-type, or a reference-type..\r\n            ":"\r\n              查找类似于'{1}'的本地化字符串。常数声明中指定的类型必须为sbyte，byte，short，ushort，int，uint，uint，long，ulong，char，float，float，double，double，Decimal，bool，bool，string，enum-type或参考类型..\r\n            \r\n",") when it can be.\r\n            ":"）何时可以。\r\n            \r\n","\r\n            Returns true if this type might contain extension methods. If this property\r\n            returns false, there are no extension methods in this type.\r\n            ":"\r\n            如果此类型可能包含扩展方法，则返回true。如果此属性\r\n            返回false，此类型中没有扩展方法。\r\n            \r\n","\r\n            The syntax node corresponding to the switch section.\r\n            ":"\r\n            与开关部分相对应的语法节点。\r\n            \r\n","The type being pointed at.":"指向的类型。\r\n","\r\n            Indicates whether or not the method returns by ref readonly\r\n            ":"\r\n            指示该方法是否通过Ref Readonly返回\r\n            \r\n","ExpressionSyntax node representing the expression on the left of the binary operator.":"表示二进制运算符左侧的表达式的表达式节点。\r\n","Implicitly-typed variables must be initialized":"必须初始化隐式型变量\r\n","\r\n            Gets the type of this local along with its annotations.\r\n            ":"\r\n            获取此本地的类型及其注释。\r\n            \r\n","\r\n            A container synthesized for a lambda, iterator method, async method, or dynamic-sites.\r\n            ":"\r\n            用于lambda，迭代方法，异步方法或动态座位的容器合成的容器。\r\n            \r\n","A bound sequence that uses a temp to achieve the correct side effects and return value.":"使用温度实现正确的副作用和返回值的界序列。\r\n","The fully qualified name for '{0}' is too long for debug information. Compile without '/debug' option.":"“ {0}”的完全合格名称对于调试信息太长。无需“/调试”选项编译。\r\n","Only class types can contain destructors":"只有类类型可以包含破坏者\r\n","\r\n              Looks up a localized string similar to By-value returns may only be used in methods that return by value.\r\n            ":"\r\n              查找类似于副价值返回的本地化字符串只能在按值返回的方法中使用。\r\n            \r\n","\r\n            The imports for all containing namespace declarations (innermost-to-outermost, including global),\r\n            or null if there are none.\r\n            ":"\r\n            所有包含命名空间声明的进口\r\n            如果没有，则无效。\r\n            \r\n","\r\n            Creates the syntax representation of an xml newline token with a documentation comment exterior trivia at \r\n            the end (continued documentation comment).\r\n            ":"\r\n            使用文档注释外部琐事创建XML Newline令牌的语法表示形式\r\n            结束（持续文档评论）。\r\n            \r\n","Only 65534 locals, including those generated by the compiler, are allowed":"只有65534个当地人，包括编译器生成的当地人\r\n","Not a recognized attribute location":"没有公认的属性位置\r\n","Creates a new XmlEmptyElementSyntax instance.":"创建一个新的Xmlemptyelementsyntax实例。\r\n","\r\n              Looks up a localized string similar to '{0}' does not have a suitable static Main method.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串没有合适的静态主方法。\r\n            \r\n","Called when the visitor visits a InvocationExpressionSyntax node.":"当访问者访问Invocation Expressionsyntax节点时调用。\r\n","Class which represents the syntax node for invocation expression.":"代表调用表达式语法节点的类。\r\n","\r\n              Looks up a localized string similar to A get or set accessor expected.\r\n            ":"\r\n              查找类似于GET或设置登录器预期的本地化字符串。\r\n            \r\n"," is true \r\n            or the method used to perform the conversion for a user-defined conversion if ":" 是真的\r\n            或用于执行用户定义转换转换的方法\r\n","\r\n              Looks up a localized string similar to The type caught or thrown must be derived from System.Exception.\r\n            ":"\r\n              查找类似于捕获或投掷的类型的本地化字符串，必须从System.Exception中得出。\r\n            \r\n","\r\n            Convenience property for determining whether we are currently lexing the\r\n            value of a name attribute.\r\n            ":"\r\n            便利属性，用于确定我们目前是否正在促进\r\n            名称属性的值。\r\n            \r\n","\r\n              Looks up a localized string similar to Do not directly call your base class Finalize method. It is called automatically from your destructor..\r\n            ":"\r\n              查找类似于不直接调用您的基类最终确定方法的本地化字符串。它是从您的破坏者中自动称为。\r\n            \r\n","<<=":"<< =\r\n","\r\n            A binder for a method body, which places the method's parameters in scope\r\n            and notes if the method is an iterator method.\r\n            ":"\r\n            方法主体的粘合剂，将方法的参数置于范围\r\n            并注意该方法是迭代方法。\r\n            \r\n"," that should be used when parsing generated files, or ":" 解析生成的文件或\r\n","\r\n            SourceFieldSymbol takes care of the initializer (plus \"var\" in the interactive case).\r\n            ":"\r\n            SourceFieldSymbol会照顾初始化器（在交互式情况下加上“ var”）。\r\n            \r\n","\r\n            The next character if any are available. InvalidCharacter otherwise.\r\n            ":"\r\n            下一个字符（如果有）。否则无效。\r\n            \r\n","'{0}': CLS-compliant interfaces must have only CLS-compliant members":"'{0}'：符合CLS的接口必须只有符合CLS的成员\r\n","\r\n             Do the members differ in terms of tuple names (both in their return type and parameters), but would match ignoring names?\r\n            \r\n             We'll look at the result of equality without tuple names (1) and with tuple names (2).\r\n             The question is whether there is a change in tuple element names only (3).\r\n            \r\n             member1                       vs. member2                        | (1) | (2) |    (3)    |\r\n             ":"成员在元组名称方面是否有所不同（在其返回类型和参数方面）是否有所不同，但是忽略名称会匹配吗？\r\n            \r\n             我们将查看没有元组名称（1）和元组名称（2）的平等结果。\r\n             问题是元组元素名称（3）是否存在更改。\r\n            \r\n             成员1与成员2 | （1）| （2）| （3）|\r\n             \r\n","\r\n              Looks up a localized string similar to Assemblies '{0}' and '{1}' refer to the same metadata but only one is a linked reference (specified using /link option); consider removing one of the references..\r\n            ":"\r\n              查找类似于汇编'{0}'和'{1}'的本地化字符串，请参阅同一元数据，但只有一个是链接引用（使用 /link选项指定）;考虑删除其中一个参考。\r\n            \r\n","\r\n            Element names, if provided.\r\n            ":"元素名称（如果提供）。\r\n            \r\n","\r\n            Given a syntax node that declares a property, get the corresponding declared symbol.\r\n            ":"\r\n            给定一个声明属性的语法节点，获取相应的声明符号。\r\n            \r\n","False if no further checks are required (because they would be cascading).":"如果不需要进一步检查（因为它们会级联），则为错误。\r\n"," and filterSpanWithinTree is non-null, report diagnostics within this span in the ":" filterspanwithintree是非无效的，在此范围内报告诊断\r\n","\r\n            Is the following set of tokens, interpreted as a type, the type ":"\r\n            是以下一组令牌，被解释为一种类型\r\n","Lookup options":"查找选项\r\n","\r\n              Looks up a localized string similar to The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'..\r\n            ":"\r\n              在通用类型或方法'{0}'中查找类似于类型的'{3}'类型的本地化字符串。无效的类型'{3}'不满足'{1}'..的约束。\r\n            \r\n","\r\n              Looks up a localized string similar to unmanaged constructed types.\r\n            ":"\r\n              查找类似于不受管理的构造类型的本地化字符串。\r\n            \r\n","Chaining speculative semantic model is not supported. You should create a speculative model from the non-speculative ParentModel.":"不支持链式投机语义模型。您应该从非规范源模模型创建一个投机模型。\r\n","\r\n            In some circumstances (e.g. implicit implementation of an interface method by a non-virtual method in a\r\n            base type from another assembly) it is necessary for the compiler to generate explicit implementations for\r\n            some interface methods.  They don't go in the symbol table, but if we are emitting, then we should\r\n            generate code for them.\r\n            ":"\r\n            在某些情况下（例如，通过在\r\n            来自另一个组件的基本类型）必须使编译器生成明确的实现\r\n            一些接口方法。他们不在符号表中，但是如果我们发出，那么我们应该\r\n            为他们生成代码。\r\n            \r\n","Called when the visitor visits a TypeOfExpressionSyntax node.":"当访问者访问typeofexpressyntax节点时调用。\r\n","\r\n            Lower a foreach loop that will enumerate a single-dimensional array.\r\n            \r\n            A[] a = x;\r\n            for (int p = 0; p < a.Length; p = p + 1) {\r\n                V v = (V)a[p];   /* OR */   (D1 d1, ...) = (V)a[p];\r\n                // body\r\n            }\r\n            ":"\r\n            较低的foreach循环，将列举单维阵列。\r\n            \r\n            a [] a = x;\r\n            for（int p = 0; p <a.length; p = p + 1）{\r\n                v v =（v）a [p]; / *或 */（d1 d1，...）=（v）a [p];\r\n                // 身体\r\n            }\r\n            \r\n","\r\n            Declaration locations for individual elements, if provided.\r\n            ":"\r\n            如果提供的话，单个要素的声明地点。\r\n            \r\n","\r\n            Set to false if syntax binds to a type or alias to a type in the current context and true if\r\n            syntax is \"var\" and it binds to \"var\" keyword in the current context.\r\n            ":"设置为false如果语法在当前上下文中与类型或类型的类型或别名结合，则设置为true\r\n            语法为“ var”，并且在当前上下文中绑定到“ var”关键字。\r\n            \r\n"," will be treated as this for uses of parent symbols. For use in EE.":" 将被视为使用父符号的用途。用于EE。\r\n","Conversions instance.":"转换实例。\r\n","\r\n              Looks up a localized string similar to Not a valid warning number.\r\n            ":"查找类似于没有有效警告号码的本地化字符串。\r\n            \r\n","\r\n            Determines if the source type is convertible to the destination type via\r\n            any conversion: implicit, explicit, user-defined or built-in.\r\n            ":"确定源类型是否可通过\r\n            任何转换：隐式，显式，用户定义或内置。\r\n            \r\n","\r\n            Returns true if this symbol is \"static\"; i.e., declared with the ":"\r\n            如果此符号为“静态”，则返回true；即，用\r\n","\r\n              Looks up a localized string similar to '{0}' duplicate named attribute argument.\r\n            ":"\r\n              查找类似于'{0}'副本属性参数的本地化字符串。\r\n            \r\n","The first part of an interpolated string, $\" or $@\"":"插值字符串的第一部分，$“或$@”\r\n","\r\n              Looks up a localized string similar to A goto cannot jump to a location before a using declaration within the same block..\r\n            ":"\r\n              查找类似于goto的本地化字符串在同一块中使用声明之前无法跳到位置。\r\n            \r\n","\r\n            Determines whether this method is a candidate for a default assembly entry point\r\n            (i.e. it is a static method called \"Main\").\r\n            ":"\r\n            确定此方法是否是默认汇编入口点的候选者\r\n            （即，这是一种称为“主”的静态方法）。\r\n            \r\n","\r\n            Returns true if the conversion is an implicit tuple literal conversion or explicit tuple literal conversion.\r\n            ":"\r\n            如果转换是隐式元组文字转换或明确的元组文字转换，则返回为true。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid value for '/define'; not a valid identifier.\r\n            ":"查找类似于“/define”的无效值的本地化字符串；不是有效的标识符。\r\n            \r\n","\r\n            Represents a local variable in a method body.\r\n            ":"\r\n            代表方法主体中的局部变量。\r\n            \r\n","An add or remove accessor expected":"预期的添加或删除登录器\r\n","\r\n              Looks up a localized string similar to An object of a type convertible to '{0}' is required.\r\n            ":"\r\n              查找类似于“ {0}”类型的对象类似的局部字符串。\r\n            \r\n","\r\n            Join nullable annotations from the set of lower bounds for fixing a type parameter.\r\n            This uses the covariant merging rules. (Annotated wins over Oblivious which wins over NotAnnotated)\r\n            ":"\r\n            从下限集中连接无效的注释，以固定类型参数。\r\n            这使用协变量合并规则。 （注释赢得遗忘的胜利，赢得了胜利）\r\n            \r\n","'{0}': an attribute argument cannot use type parameters":"'{0}'：属性参数不能使用类型参数\r\n","\r\n            Note, there is no guarantee that the factory always gives back the same binder instance for the same node.\r\n            ":"\r\n            请注意，不能保证工厂总是将同一节点的同一粘合剂实例归还。\r\n            \r\n","\r\n            Does this symbol represent a missing assembly.\r\n            ":"\r\n            此符号代表缺失的组件吗？\r\n            \r\n"," node.\r\n            ":" 节点。\r\n            \r\n","The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.":"'{0}'中的类型'{1}'与导入的名称空间'{3}'In' {2}'冲突。使用“ {0}”中定义的类型。\r\n","\r\n            The try statement is the most complex part of the state machine transformation.\r\n            Since the CLR will not allow a 'goto' into the scope of a try statement, we must\r\n            generate the dispatch to the state's label stepwise.  That is done by translating\r\n            the try statements from the inside to the outside.  Within a try statement, we\r\n            start with an empty dispatch table (representing the mapping from state numbers\r\n            to labels).  During translation of the try statement's body, the dispatch table\r\n            will be filled in with the data necessary to dispatch once we're inside the try\r\n            block.  We generate that at the head of the translated try statement.  Then, we\r\n            copy all of the states from that table into the table for the enclosing construct,\r\n            but associate them with a label just before the translated try block.  That way\r\n            the enclosing construct will generate the code necessary to get control into the\r\n            try block for all of those states.\r\n            ":"\r\n            尝试语句是状态机转换中最复杂的部分。\r\n            由于CLR不会允许“ goto”进入尝试语句的范围，因此我们必须\r\n            将调度逐步生成到州的标签上。这是通过翻译完成的\r\n            从内部到外部的尝试语句。在尝试语句中，我们\r\n            从一个空调度表开始（表示状态编号的映射\r\n            到标签）。在Try语句的身体翻译时，调度表\r\n            一旦我们进入尝试\r\n            堵塞。我们在翻译的Try语句的头部生成。然后我们\r\n            将所有状态从该表复制到表格中以进行封闭构造，\r\n            但是在翻译的尝试块之前将它们与标签相关联。那样\r\n            封闭构造将生成所需的代码，以控制到\r\n            尝试所有这些状态的块。\r\n            \r\n","Unable to load Analyzer assembly {0} : {1}":"无法加载分析仪组件{0}：{1}\r\n","\r\n            During early attribute decoding, we consider a safe subset of all members that will not\r\n            cause cyclic dependencies.  Get all such members for this symbol that have a particular name.\r\n            ":"\r\n            在早期属性解码期间，我们考虑所有成员的安全子集\r\n            导致循环依赖性。获取具有特定名称的此符号的所有此类成员。\r\n            \r\n","\r\n            Convenience property for determining whether we are currently lexing the\r\n            value of a cref or name attribute.\r\n            ":"\r\n            便利属性，用于确定我们目前是否正在促进\r\n            CREF或名称属性的值。\r\n            \r\n","\r\n            Used for lightweight binding of type constraints. Instead of binding type arguments,\r\n            we'll just use these placeholders instead. That's good enough binding to compute\r\n            ":"\r\n            用于类型约束的轻巧结合。而不是绑定类型参数，而是\r\n            我们只是使用这些占位符。这足以计算\r\n            \r\n","\r\n            For nodes that can generate an ":"\r\n            对于可以生成一个的节点\r\n","digit separators":"数字分离器\r\n","\r\n            Is the operator among those for which ":"\r\n            是运营商中的运营商\r\n","covariant":"协变\r\n","\r\n            CONSIDER: can this share code with MemberSemanticModel.GetEnclosingBinder?\r\n            \r\n            Returned binder doesn't need to have ":"\r\n            考虑：此此共享代码可以与MENSTERMANICMODEL.getEnclosingBinder？\r\n            \r\n            返回的粘合剂不需要\r\n","\r\n            Represents a parameter that is based on another parameter.\r\n            When inheriting from this class, one shouldn't assume that \r\n            the default behavior it has is appropriate for every case.\r\n            That behavior should be carefully reviewed and derived type\r\n            should override behavior as appropriate.\r\n            ":"\r\n            表示基于另一个参数的参数。\r\n            从这个课程继承时，不应该假设\r\n            它具有的默认行为适用于每种情况。\r\n            该行为应仔细审查和派生类型\r\n            应适当地覆盖行为。\r\n            \r\n","\r\n              Looks up a localized string similar to Interface member '{0}' does not have a most specific implementation. Neither '{1}', nor '{2}' are most specific..\r\n            ":"\r\n              查找类似于接口成员'{0}'的本地化字符串没有最具体的实现。 '{1}'，也不是'{2}'最具体的..\r\n            \r\n","\r\n            Return all of the type parameters in this type and enclosing types,\r\n            from outer-most to inner-most type.\r\n            ":"\r\n            返回此类型中的所有类型参数和封闭类型中的参数，\r\n            从最外部到最内部类型。\r\n            \r\n","Keyword, identifier, or string expected after verbatim specifier: @":"关键字，标识符或字符串，逐字指示符： @\r\n","\r\n            Expression can be the operand of an increment or decrement operation.\r\n            Same as CompoundAssignment, the distinction is really just for error reporting.\r\n            ":"\r\n            表达可以是增量或减少操作的操作数。\r\n            与复合设施相同，区别实际上仅用于错误报告。\r\n            \r\n","\r\n              Looks up a localized string similar to Method or delegate cannot return type '{0}'.\r\n            ":"\r\n              查找类似于方法的本地化字符串或委托无法返回类型'{0}'。\r\n            \r\n","Length of String constant resulting from concatenation exceeds System.Int32.MaxValue.  Try splitting the string into multiple constants.":"串联产生的字符串常数超过系统。Int32.maxValue。尝试将字符串分为多个常数。\r\n","\r\n            Look for symbols that are members of the specified namespace or type.\r\n            ":"\r\n            寻找是指定名称空间或类型的成员的符号。\r\n            \r\n","\r\n              Looks up a localized string similar to No enclosing loop out of which to break or continue.\r\n            ":"\r\n              查找类似于无封闭环的本地化字符串，该弦即可突破或继续。\r\n            \r\n","\r\n            This method walks through the array's InitializerExpressionSyntax and binds all the initializer expressions recursively.\r\n            NOTE: It doesn't convert the bound initializer expressions to array's element type.\r\n            NOTE: This is done separately in ConvertAndBindArrayInitialization method below.\r\n            ":"\r\n            该方法沿阵列的initizerexpressyntax漫游，并递归绑定所有初始化器表达式。\r\n            注意：它不会将绑定的初始化器表达式转换为数组的元素类型。\r\n            注意：这是在下面的convertandbindarrayinitialization方法中分别完成的。\r\n            \r\n","The property or indexer '{0}' cannot be used in this context because the get accessor is inaccessible":"在此上下文中无法使用属性或索引器'{0}'，因为Get访问者不可访问\r\n","\r\n            Implicit and explicit reference conversions are described in sections 6.1.6 and 6.2.4 of the C# language specification.\r\n            ":"\r\n            隐式和明确的参考转换在C＃语言规范的第6.1.6和6.2.4节中进行了描述。\r\n            \r\n"," The user-defined asynchronous main method. ":" 用户定义的异步主要方法。\r\n","The parameter token handle.":"参数令牌手柄。\r\n","'{0}' is not CLS-compliant because base interface '{1}' is not CLS-compliant":"'{0}'不符合cls cls，因为碱接口'{1}'不符合cls cls cls\r\n","\r\n            The user-defined operators that were considered when attempting this conversion\r\n            (i.e. the arguments to overload resolution).\r\n            ":"\r\n            尝试此转换时考虑的用户定义的操作员\r\n            （即超载分辨率的论点）。\r\n            \r\n","\r\n            Synthesized methods that must be emitted in the compiler generated\r\n            PrivateImplementationDetails class have null containing type symbol.\r\n            ":"\r\n            必须在编译器生成的编译器中发射的合成方法\r\n            私有ImimplementationDetails类具有NULL包含类型符号。\r\n            \r\n","Throws this exception if the ":"如果是\r\n","\r\n              Looks up a localized string similar to '{0}': cannot derive from the dynamic type.\r\n            ":"\r\n              查找类似于'{0}'：不能从动态类型派生的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to local functions.\r\n            ":"\r\n              查找类似于本地功能的本地化字符串。\r\n            \r\n","SyntaxToken representing the question mark.":"Syntaxtoken代表问号。\r\n","\r\n            Generates the syntax representation of an xml text literal.\r\n            ":"\r\n            生成XML文本文字的语法表示。\r\n            \r\n","\r\n              Looks up a localized string similar to The name '{0}' does not exist in the current context.\r\n            ":"\r\n              在当前上下文中查找类似于名称“ {0}”的本地化字符串。\r\n            \r\n","\r\n            The language version that was used to parse the syntax trees of this compilation.\r\n            ":"用于解析此汇编的语法树的语言版本。\r\n            \r\n","\r\n            A position is inside a property body only if it is inside an expression body.\r\n            All block bodies for properties are part of the accessor declaration (a type\r\n            of BaseMethodDeclaration), not the property declaration.\r\n            ":"\r\n            仅当属性主体内部的表达主体内，位置才有内部。\r\n            所有属性的块主体都是登录声声明的一部分（一种类型\r\n            basemethoddeclaration），而不是财产声明。\r\n            \r\n","foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNext' method and public 'Current' property":"foreach要求'{1}'的返回类型'{0}'必须具有合适的public'movenext'方法和公共'当前'属性\r\n","\r\n            If this is a partial implementation part returns the definition part and vice versa.\r\n            ":"\r\n            如果这是部分实现部分，则返回定义部分，反之亦然。\r\n            \r\n"," attribute or null if there is no ":" 属性或null如果没有\r\n",".\r\n            Note, presence of this flag suppresses generation of Nullable attribute on the corresponding type parameter.\r\n            This imitates the shape of metadata produced by pre-nullable compilers. Metadata import is adjusted accordingly\r\n            to distinguish between the two situations.\r\n            ":"。\r\n            注意，该标志的存在抑制了相应类型参数上的无效属性的生成。\r\n            这模仿了预先呼气的编译器产生的元数据的形状。元数据进口已相应调整\r\n            区分两种情况。\r\n            \r\n","Creates a new DefaultConstraintSyntax instance.":"创建一个新的defaultConstraintSnyntax实例。\r\n",".\r\n            or a ref-like type.\r\n            ":"。\r\n            或类似Ref的类型。\r\n            \r\n","Type parameter '{0}' has the same name as the containing type, or method":"类型参数'{0}'具有与包含类型或方法相同的名称\r\n","\r\n            Returns ConstantValue.Bad if, and only if, compound string length is out of supported limit.\r\n            The ":"\r\n            返回ConstantValue。如果，并且只有当复合字符串长度超出支持的限制时，才会出错。\r\n            该 \r\n","The node whose translation should be translated to contain a frame":"应翻译的节点包含一个框架\r\n","\r\n             The visit result of the receiver for the current conditional access.\r\n            \r\n             For example: A conditional invocation uses a placeholder as a receiver. By storing the\r\n             visit result from the actual receiver ahead of time, we can give this placeholder a correct result.\r\n             ":"\r\n             当前有条件访问的接收器的访问结果。\r\n            \r\n             例如：条件调用使用占位符作为接收者。通过存储\r\n             访问实际接收器的结果，我们可以为该占位符提供正确的结果。\r\n             \r\n"," within collection initializer.\r\n            This is the worker function that is overridden in various derived kinds of Semantic Models. It can assume that \r\n            CheckSyntaxNode has already been called and the ":" 在集合初始化器中。\r\n            这是在各种派生类型的语义模型中被覆盖的工作函数。它可以假设\r\n            checksyntaxnode已经被调用了\r\n","An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type":"属性参数必须是恒定表达式，类型表达式或数组创建表达式属性参数类型\r\n","Private protected":"私人保护\r\n","\r\n            Determines if a bound node, or associated syntax or type has an error (not a warning) \r\n            diagnostic associated with it.\r\n            \r\n            Typically used in the binder as a way to prevent cascading errors. \r\n            In most other cases a more lightweight HasErrors should be used.\r\n            ":"\r\n            确定绑定节点或关联的语法或类型是否有错误（不是警告）\r\n            与之相关的诊断。\r\n            \r\n            通常在粘合剂中使用，以防止级联错误。\r\n            在大多数情况下，应该使用更轻巧的haserrors。\r\n            \r\n","\r\n            In the debugger, the context is always unsafe, but one can still await.\r\n            ":"\r\n            在调试器中，上下文总是不安全的，但仍然可以等待。\r\n            \r\n","\r\n              Looks up a localized string similar to Fixed size buffers must have a length greater than zero.\r\n            ":"\r\n              查找类似于固定尺寸缓冲区的局部字符串必须具有大于零的长度。\r\n            \r\n","\r\n              Looks up a localized string similar to Type of conditional expression cannot be determined because there is no implicit conversion between '{0}' and '{1}'.\r\n            ":"\r\n              查找类似于条件表达式类型的本地化字符串无法确定，因为“ {0}”和“ {1}”之间没有隐含的转换。\r\n            \r\n","\r\n            Lower an await expression that has already had its components rewritten.\r\n            ":"\r\n            降低等待表达，该表达式已经重写其组件。\r\n            \r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not implemented in this compiler..\r\n            ":"\r\n              在此编译器中未实现类似于功能“ {0}”的本地化字符串。\r\n            \r\n","Creates a new BaseExpressionSyntax instance.":"创建一个新的baseexpressionsyntax实例。\r\n","\r\n              Looks up a localized string similar to Could not write to output file '{0}' -- '{1}'.\r\n            ":"\r\n              查找类似于输出文件'{0}' - '{1}'的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to A partial method must be declared within a partial class or partial struct.\r\n            ":"\r\n              必须在部分类别或部分结构中声明类似于部分方法的本地化字符串。\r\n            \r\n","Comparing with null of struct type always produces 'false'":"与结构类型的空比较总是会产生“ false”\r\n","Index of the method symbol in its containing type member list.":"其包含类型成员列表中的方法符号的索引。\r\n"," for each scope with captured variables.  The generated frames are kept\r\n             in ":" 对于带有捕获变量的每个范围。生成的帧保留\r\n             在\r\n","Default literal":"默认文字\r\n","\r\n            Tracks fields that are being bound while binding their initializers.\r\n            ":"\r\n            在绑定其初始化器时绑定的轨迹字段。\r\n            \r\n","Cannot define a class or member that utilizes 'dynamic' because the compiler required type '{0}' cannot be found. Are you missing a reference?":"无法定义使用“动态”的类或成员，因为找不到编译器所需的类型'{0}'。您是否缺少参考？\r\n","\r\n              Looks up a localized string similar to Nullability of reference types in type of '{0}' doesn't match implicitly implemented member '{1}'..\r\n            ":"\r\n              在类型的“ {0}”类型中查找类似于参考类型的无效性类似的本地化字符串，与隐式实现的成员'{1}'..\r\n            \r\n","\r\n              Looks up a localized string similar to Type conflicts with imported namespace.\r\n            ":"\r\n              查找类似于带有导入名称空间的类型冲突的本地化字符串。\r\n            \r\n","\r\n            There are two key reasons why interface overriding/hiding is different from class overriding/hiding:\r\n              1) interface members never override other members; and\r\n              2) interfaces can extend multiple interfaces.\r\n            The first difference doesn't require any special handling - as long as the members have IsOverride=false,\r\n            the code for class overriding/hiding does the right thing.\r\n            The second difference is more problematic.  For one thing, an interface member can hide a different member in\r\n            each base interface.  We only report the first one, but we need to expose all of them in the API.  More importantly,\r\n            multiple inheritance raises the possibility of diamond inheritance.  Spec section 13.2.5, Interface member access,\r\n            says: \"The intuitive rule for hiding in multiple-inheritance interfaces is simply this: If a member is hidden in any\r\n            access path, it is hidden in all access paths.\"  For example, consider the following interfaces:\r\n            \r\n            interface I0 { void M(); }\r\n            interface I1 : I0 { void M(); }\r\n            interface I2 : I0, I1 { void M(); }\r\n            \r\n            I2.M does not hide I0.M, because it is already hidden by I1.M.  To make this work, we need to traverse the graph\r\n            of ancestor interfaces in topological order and flag ones later in the enumeration that are hidden along some path.\r\n            ":"\r\n            接口覆盖/隐藏与类覆盖/隐藏不同的接口覆盖/隐藏不同的原因有两个：\r\n              1）接口成员永远不会覆盖其他成员；和\r\n              2）接口可以扩展多个接口。\r\n            第一个差异不需要任何特殊处理 - 只要成员具有isoverride = false，\r\n            班级覆盖/隐藏的代码可以做正确的事情。\r\n            第二个差异更有问题。一方面，接口成员可以隐藏其他成员\r\n            每个基本接口。我们只报告第一个，但是我们需要将所有这些都暴露在API中。更重要的是，\r\n            多元继承增加了钻石继承的可能性。规格第13.2.5节，接口成员访问，\r\n            说：“隐藏在多元传播界面中的直观规则就是这样：如果一个成员隐藏在任何\r\n            访问路径，它隐藏在所有访问路径中。”例如，请考虑以下接口：\r\n            \r\n            接口i0 {void m（）; }\r\n            接口i1：i0 {void m（）; }\r\n            接口i2：i0，i1 {void m（）; }\r\n            \r\n            i2.m不会隐藏i0.m，因为它已经被i1.m。为了使这项工作，我们需要遍历图形\r\n            以拓扑顺序为祖先界面的界面，后来在枚举中隐藏了一些路径。\r\n            \r\n","The expression that was bound. If ":"绑定的表达。如果\r\n","\r\n              Looks up a localized string similar to Alias '{0}' not found.\r\n            ":"\r\n              查找类似于别名'{0}'的局部字符串。\r\n            \r\n","\r\n            Expression can be an LHS of a compound assignment\r\n            operation (such as +=).\r\n            ":"\r\n            表达可以是复合分配的LHS\r\n            操作（例如 +=）。\r\n            \r\n","Type of '{0}' cannot be inferred since its initializer directly or indirectly refers to the definition.":"不能推断出“ {0}”的类型，因为其初始化器直接或间接地指定义。\r\n","\r\n            Gets the \"Current\" property.\r\n            ":"\r\n            获取“当前”属性。\r\n            \r\n","\r\n            Superficially, it seems as though this should always be the same as DeclarationKind == LocalDeclarationKind.Fixed.\r\n            Unfortunately, when we fix a string expression, it is not the declared local (e.g. char*) but a synthesized temp (string)\r\n            that is pinned.\r\n            ":"\r\n            从表面上看，似乎这应该始终与declarationKind == localdeclarationkind.fixed相同。\r\n            不幸的是，当我们修复字符串表达式时，它不是局部声明的（例如char*），而是合成的temp（string）\r\n            那是固定的。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use {0} '{1}' as a ref or out value because it is a readonly variable.\r\n            ":"\r\n              查找类似于无法使用{0}'{1}'的本地化字符串作为ref或out值，因为它是一个可读的变量。\r\n            \r\n","\r\n            Analyzes a set of bound nodes, recording updated nullability information. This method is only\r\n            used when nullable is explicitly enabled for all methods but disabled otherwise to verify that\r\n            correct semantic information is being recorded for all bound nodes. The results are thrown away.\r\n            ":"\r\n            分析一组绑定的节点，记录更新的无效信息。此方法仅是\r\n            当对所有方法显式启用无效时使用，但否则将其禁用以验证\r\n            所有绑定节点都将记录正确的语义信息。结果被抛弃了。\r\n            \r\n","\r\n            As part of the description of a node of the decision automaton, we keep track of what tests\r\n            remain to be done for each case.\r\n            ":"\r\n            作为决定自动机节点的描述的一部分，我们会跟踪哪些测试\r\n            对于每种情况，仍有待完成。\r\n            \r\n","The other type.":"另一种类型。\r\n",", Partition I, §8.6.1.6 Signature Matching).\r\n            It considers return type, name, parameters, calling convention, and custom modifiers, but ignores\r\n            the difference between ":"，分区i，§8.6.1.6签名匹配）。\r\n            它考虑返回类型，名称，参数，调用惯例和自定义修饰符，但忽略\r\n            和...之间的不同\r\n","Called when the visitor visits a ArgumentSyntax node.":"当访问者访问一个参数ntrax节点时打电话。\r\n","The language name '{0}' is invalid.":"语言名称'{0}'无效。\r\n","Metadata references are not supported.":"不支持元数据参考。\r\n","\r\n              Looks up a localized string similar to Expected identifier or numeric literal..\r\n            ":"\r\n              查找类似于预期标识符或数字文字的本地化字符串。\r\n            \r\n","\r\n            Creates a token with kind NumericLiteralToken from a 4-byte signed integer value.\r\n            ":"\r\n            从4个字节签名的整数值中创建具有属性数字的令牌。\r\n            \r\n","Cannot yield a value in the body of a try block with a catch clause":"用捕获子句无法在试验块的身体中产生值\r\n","\r\n            If this is a lazy nullable type pending resolution, forces this to be resolved as a nullable value type.\r\n            ":"\r\n            如果这是一种懒惰的类型待处理分辨率，则迫使将其解析为无效的值类型。\r\n            \r\n","The best overloaded method match for '{0}' has wrong signature for the initializer element. The initializable Add must be an accessible instance method.":"最佳的超载方法匹配“ {0}”的初始化器元素的签名错误。可初始化的添加必须是一个可访问的实例方法。\r\n","Unterminated string literal":"未终止的字符串文字\r\n","\r\n            Gets the attributes on method's return type.\r\n            Returns an empty array if there are no attributes.\r\n            ":"\r\n            获取方法的返回类型上的属性。\r\n            如果没有属性，则返回一个空数组。\r\n            \r\n","\r\n              Looks up a localized string similar to Method '{0}' cannot implement interface accessor '{1}' for type '{2}'. Use an explicit interface implementation..\r\n            ":"\r\n              查找类似于方法'{0}'的本地化字符串，无法实现interface consector'{1}'type'{2}'。使用显式接口实现。\r\n            \r\n","\r\n            Accumulate diagnostics related to the variance safety of an interface method.\r\n            ":"\r\n            积累与接口方法的方差安全性有关的诊断。\r\n            \r\n","\r\n            Provide structural equality for ReadOnlyMemory{char} instances.\r\n            ":"\r\n            为ReadOnlyMemory {char}实例提供结构平等。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use 'yield' in top-level script code.\r\n            ":"\r\n              在顶级脚本代码中查找类似于无法使用“产量”的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Object and collection initializer expressions may not be applied to a delegate creation expression.\r\n            ":"\r\n              查找类似于对象的本地化字符串，收集初始化器表达式可能不会应用于委托创建表达式。\r\n            \r\n","Nullability of reference types in type doesn't match implicitly implemented member.":"类型中参考类型的无效性不匹配隐式实现的成员。\r\n","\r\n              Looks up a localized string similar to __arglist is not allowed in the parameter list of async methods.\r\n            ":"\r\n              在异步方法的参数列表中不允许查找类似于__arglist的本地化字符串。\r\n            \r\n","The parameter list to match against":"要匹配的参数列表\r\n","\r\n            Might be a generic (qualified) type name or an expression or a method name.\r\n            ":"\r\n            可能是通用（合格的）类型名称或表达式或方法名称。\r\n            \r\n","\r\n            Returns true if this symbol was declared as requiring an override; i.e., declared with\r\n            the ":"\r\n            如果该符号被宣布为替代，则返回为真；即，宣布\r\n            这\r\n","\r\n              Looks up a localized string similar to Assembly reference '{0}' is invalid and cannot be resolved.\r\n            ":"\r\n              查找类似于汇编引用'{0}'的本地化字符串是无效的，无法解决。\r\n            \r\n","\r\n            Validates whether given invocation can allow its results to escape from ":"\r\n            验证给出的调用是否可以允许其结果逃脱\r\n","Source interface '{0}' is missing method '{1}' which is required to embed event '{2}'.":"源界面'{0}'是缺少方法'{1}'，嵌入事件'{2}'所需。\r\n","Creates a new ParenthesizedVariableDesignationSyntax instance.":"创建一个新的括号variabledesignationsyntax实例。\r\n","\r\n            Information early-decoded from well-known custom attributes applied on a parameter.\r\n            ":"\r\n            从参数上应用的众所周知的自定义属性提早编码的信息。\r\n            \r\n","The first operand of an 'as' operator may not be a tuple literal without a natural type.":"如果没有天然类型，“ AS”操作员的第一部操作数可能不是元组字面的。\r\n","\r\n              Looks up a localized string similar to digit separators.\r\n            ":"\r\n              查找类似于数字分离器的局部字符串。\r\n            \r\n","SyntaxToken representing the RefValueKeyword.":"表示refvaluekeyword的义务。\r\n","Comparison made to same variable; did you mean to compare something else?":"与同一变量进行比较；你是说比较其他东西吗？\r\n","A function that computes a replacement trivia for\r\n            the argument trivia. The first argument is the original trivia. The second argument is\r\n            the same trivia rewritten with replaced structure.":"计算替换琐事的功能\r\n            争论琐事。第一个论点是原始琐事。第二个论点是\r\n            相同的琐事用更换的结构重写。\r\n","Constructor declaration syntax.":"构造商声明语法。\r\n","Extension method groups are not allowed as an argument to 'nameof'.":"不允许扩展方法组作为“名称”的参数。\r\n","Expression expected after yield return":"收益回报后预期的表达\r\n","Gets the \"implicit\" or \"explicit\" token.":"获取“隐式”或“显式”令牌。\r\n","\r\n            Symbol to copy bound attributes from, or null if the attributes are not shared among multiple source parameter symbols.\r\n            ":"\r\n            符号以从多个源参数符号之间共享属性，以复制绑定属性或null。\r\n            \r\n","\r\n            User variable declared as an out argument.\r\n            ":"\r\n            用户变量被声明为一个参数。\r\n            \r\n","Possibly incorrect assignment to local which is the argument to a using or lock statement":"可能是对本地分配的错误，这是对使用或锁定语句的参数\r\n","\r\n              Looks up a localized string similar to Cannot create an array with a negative size.\r\n            ":"\r\n              查找类似于类似的本地化字符串无法创建具有负大小的数组。\r\n            \r\n","\r\n            Returns a string representation of an object of primitive type.\r\n            ":"\r\n            返回原始类型对象的字符串表示。\r\n            \r\n","'{0}': static types cannot be used as type arguments":"'{0}'：静态类型不能用作类型参数\r\n","\r\n            The class that represents a translated async or async-iterator method.\r\n            ":"\r\n            代表翻译的异步或异步 - 列表方法的类。\r\n            \r\n","\r\n              Looks up a localized string similar to The type '{0}' cannot be declared const.\r\n            ":"\r\n              查找类似于“ {0}”类型的本地化字符串无法声明const。\r\n            \r\n","\r\n            True if In flag is set in metadata.\r\n            ":"\r\n            如果在元数据中设置了标志，则为true。\r\n            \r\n","True if the expression is awaitable; false otherwise.":"如果表达是等待的，则是真的；否则为错误。\r\n","\r\n            Formally, this is a fairly conventional lattice flow analysis (":"\r\n            正式地，这是一个相当传统的晶格流分析（\r\n","XML comment on '{1}' has a typeparamref tag for '{0}', but there is no type parameter by that name":"XML对'{1}'的评论具有'{0}'的typeparamref标签，但没有该名称的类型参数\r\n","Any generated temps are added here.":"任何生成的温度都在此处添加。\r\n"," \r\n            Map of wrapper methods created for base access of base type virtual methods from \r\n            other classes (like those created for lambdas...); actually each method symbol will \r\n            only need one wrapper to call it non-virtually.\r\n            ":" \r\n            创建的包装方法的地图，用于基本类型虚拟方法的基本访问\r\n            其他类（例如为lambdas创建的类...）；实际上每个方法符号都会\r\n            只需要一个包装器即可非文称。\r\n            \r\n","Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.":"提供代表表达语法节点的类的基类。这是一个抽象类。\r\n","Called when the visitor visits a UsingStatementSyntax node.":"当访问者访问usedstatementsyntax节点时调用。\r\n","\r\n            Location of an attribute if an explicit location is not specified via attribute target specification syntax.\r\n            ":"\r\n            属性的位置如果未通过属性目标规范语法指定显式位置。\r\n            \r\n","\r\n            Binds an expression-bodied member with expression e as either { return e; } or { e; }.\r\n            ":"\r\n            将表达式构件绑定为表达式E，为{return e; }或{e; }。\r\n            \r\n","The shortest path, excluding the node of interest.":"最短的路径，不包括感兴趣的节点。\r\n","\r\n              Looks up a localized string similar to Source file '{0}' could not be found..\r\n            ":"\r\n              查找类似于源文件'{0}'的本地化字符串。\r\n            \r\n","\r\n            Omit ref feature for COM interop: We can pass arguments by value for ref parameters if we are invoking a method/property on an instance of a COM imported type.\r\n            This property returns a flag indicating whether we had any ref omitted argument for the given call.\r\n            ":"\r\n            省略com Interop的参考功能：如果我们在com导入类型的实例上调用方法/属性，则可以按值通过值来传递参数。\r\n            此属性返回一个标志，指示我们是否有任何有关给定电话的参数。\r\n            \r\n","Bitwise-or operator used on a sign-extended operand":"位于签名操作数上的钻头或操作员\r\n","\r\n              Looks up a localized string similar to Unreachable code detected.\r\n            ":"\r\n              查找类似于检测到的无法实现的代码的本地化字符串。\r\n            \r\n","The type of the argument to the DefaultParameterValue attribute must match the parameter type":"参数的类型符合DefaultParameterValue属性必须匹配参数类型\r\n","\r\n            The topmost method of this analysis.\r\n            ":"\r\n            该分析的最佳方法。\r\n            \r\n","\r\n            May be false in lambdas that are outside of member method bodies, e.g. lambdas in\r\n            field initializers.\r\n            ":"\r\n            在成员方法主体之外的lambdas中可能是错误的，例如Lambdas In\r\n            现场初始化器。\r\n            \r\n","\r\n            It seems to be common to do both of these things at once, so provide a way to do so\r\n            without adding two links to the binder chain.\r\n            ":"\r\n            同时做这两个事情似乎很普遍，因此提供一种方法\r\n            不添加两个链接到粘合剂链。\r\n            \r\n","ExpressionSyntax node representing the access expression to be executed when the object is not null.":"表示对象不为null时，表示要执行的访问表达式的exTressionSyntax节点。\r\n","\r\n            The variable(s) of the loop. In correct code this is a tuple\r\n            literal, declaration expression with a tuple designator, or\r\n            a discard syntax in the form of a simple identifier. In broken\r\n            code it could be something else.\r\n            ":"\r\n            循环的变量。 在正确的代码中，这是一个元组\r\n            字面量，带有元组指定符的声明表达式，或\r\n            简单标识符形式的丢弃语法。 在破碎\r\n            代码可能是别的东西。\r\n            \r\n","'{0}': cannot override '{1}' because it is not supported by the language":"'{0}'：不能覆盖'{1}'，因为它不受语言的支持\r\n","\r\n            The underlying AssemblySymbol, cannot be an instance of RetargetingAssemblySymbol.\r\n            ":"\r\n            基础组合符号不能是retargetingAssemblysymbol的一个实例。\r\n            \r\n","\r\n              Looks up a localized string similar to Structs cannot contain explicit parameterless constructors.\r\n            ":"\r\n              查找类似于结构的本地化字符串不能包含明确的无参数构造函数。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot convert {0} to type '{1}' because it is not a delegate type.\r\n            ":"\r\n              查找类似于不能将{0}转换为'{1}'的本地化字符串，因为它不是委托类型。\r\n            \r\n","\r\n            If the next characters in the window match the given string,\r\n            then advance past those characters.  Otherwise, do nothing.\r\n            ":"\r\n            如果窗口中的下一个字符匹配给定的字符串，\r\n            然后超越这些角色。否则，什么也不做。\r\n            \r\n","The compiler emits this warning when it overrides an error with a warning. For information about the problem, search for the error code mentioned.":"编译器在警告中覆盖错误时发出此警告。有关问题的信息，请搜索提到的错误代码。\r\n","\r\n            Creates a \"late\" bound instance with all fields set.\r\n            ":"\r\n            使用所有字段设置创建一个“后期”绑定实例。\r\n            \r\n","\r\n              Looks up a localized string similar to Conditional access may produce a null value for a type parameter..\r\n            ":"\r\n              查找类似于条件访问的本地化字符串可能会为类型参数产生零值。\r\n            \r\n","\r\n            created from the ":"\r\n            由\r\n","\r\n              Looks up a localized string similar to The language name '{0}' is invalid..\r\n            ":"\r\n              查找类似于语言名称'{0}'的本地化字符串是无效的。\r\n            \r\n","\r\n            Get a SemanticModel object that is associated with a statement that did not appear in\r\n            this source code. This can be used to get detailed semantic information about sub-parts\r\n            of a statement that did not appear in source code.\r\n            ":"\r\n            获取与未出现在\r\n            此源代码。这可以用来获取有关子部分的详细语义信息\r\n            源代码中未出现的语句。\r\n            \r\n","\r\n            Reflects the enclosing member, lambda or local function at the current location (in the bound tree).\r\n            ":"\r\n            在当前位置（在绑定的树中）反映封闭的成员，lambda或本地功能。\r\n            \r\n","\r\n            If the expression underwent an implicit conversion, return information about that\r\n            conversion. Otherwise, returns an identity conversion.\r\n            ":"\r\n            如果表达式进行了隐式转换，请返回有关该的信息\r\n            转换。否则，返回身份转换。\r\n            \r\n","You must provide an initializer in a fixed or using statement declaration":"您必须在固定或使用语句声明中提供初始化器\r\n","The new token list.":"新的令牌列表。\r\n","SyntaxToken representing the DefaultKeyword.":"Syntaxtoken表示defaultKeyword。\r\n","\r\n              Looks up a localized string similar to '{0}' must declare a body because it is not marked abstract, extern, or partial.\r\n            ":"\r\n              查找类似于“ {0}”的局部字符串必须声明一个身体，因为它没有标记为抽象，外部或部分。\r\n            \r\n","\r\n              Looks up a localized string similar to This label has not been referenced.\r\n            ":"\r\n              尚未引用类似于此标签的本地化字符串。\r\n            \r\n","\r\n            A collection of the local variables that are read outside the region.\r\n            ":"\r\n            本地变量的集合，这些变量在区域之外读取。\r\n            \r\n","\r\n            This rewriter rewrites an async-iterator method. See async-streams.md for design overview.\r\n            ":"\r\n            此重写器重写异步 - 列表方法。有关设计概述，请参见Async-streams.md。\r\n            \r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 3. Please use language version {1} or greater..\r\n            ":"\r\n              查找类似于功能'{0}'的本地化字符串。\r\n            \r\n","\r\n            Gets the semantic information associated with a documentation comment cref.\r\n            ":"\r\n            获取与文档评论CREF相关的语义信息。\r\n            \r\n","\r\n            We override GetBinder so that the BindStatement override is still\r\n            in effect on nested binders.\r\n            ":"\r\n            我们覆盖getBinder，以使绑定替代仍然是\r\n            实际上是嵌套的粘合剂。\r\n            \r\n","\r\n              Looks up a localized string similar to Expected expression.\r\n            ":"\r\n              查找类似于预期表达式的局部字符串。\r\n            \r\n","Method lacks `[DoesNotReturn]` annotation to match implemented or overridden member.":"方法缺乏``[do notorturn]`符合实现或覆盖成员的注释。\r\n","\r\n            Allow unsafe regions (i.e. unsafe modifiers on members and unsafe blocks).\r\n            ":"\r\n            允许不安全的区域（即成员和不安全块上的不安全修饰符）。\r\n            \r\n",".\r\n             E.g. if the current compilation references a metadata file that has changed since the creation of the compilation\r\n             the new compilation is going to use the updated version, while the current compilation will be using the previous (it doesn't change).\r\n             ":"。\r\n             例如。如果当前汇编引用自汇编创建以来已更改的元数据文件\r\n             新的汇编将使用更新版本，而当前汇编将使用以前的版本（不更改）。\r\n             \r\n","\r\n              Looks up a localized string similar to Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?.\r\n            ":"\r\n              查找类似于引入“最终确定”方法的本地化字符串可能会干扰Destructor调用。您是否打算宣布灾难？\r\n            \r\n","Called when the visitor visits a FunctionPointerParameterSyntax node.":"当访问者访问fintunPoInterParameterSyntax节点时调用。\r\n","\r\n              Looks up a localized string similar to Non-nullable {0} '{1}' is uninitialized. Consider declaring the {0} as nullable..\r\n            ":"\r\n              查找类似于不可用的{0}'{1}'的局部字符串是非初始化的。考虑将{0}声明为无效..\r\n            \r\n","\r\n            A decision tree that, given a non-null input of a type, dispatches based on the\r\n            value of that type. The ":"\r\n            一个决策树，给定类型的非磁输入，根据该类型的输入\r\n            该类型的值。这\r\n","\r\n            Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.\r\n            ":"\r\n            给定匿名对象创建表达式的语法节点，获取匿名对象类型符号。\r\n            \r\n","'{0}': static classes cannot be used as constraints":"'{0}'：静态类不能用作约束\r\n","Creates a new WhereClauseSyntax instance.":"创建一个新的whereclausesyntax实例。\r\n","Branches of a ref conditional operator cannot refer to variables with incompatible declaration scopes":"参考条件运算符的分支机分支不能参考不兼容声明范围的变量\r\n","\r\n              Looks up a localized string similar to 'await' requires that the type {0} have a suitable GetAwaiter method.\r\n            ":"\r\n              查找类似于“等待”的本地化字符串，要求类型{0}具有合适的Getawaiter方法。\r\n            \r\n","The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.":"'{0}'中的类型'{1}'与导入的类型'{3}'在'{2}'中冲突。使用“ {0}”中定义的类型。\r\n","\r\n            Gets a new local symbol with the given TypeWithAnnotations as the new type. This\r\n            type should be identical to the original except for nullability.\r\n            ":"\r\n            获得一个新的本地符号，并以给定的打字量为新类型。这个\r\n            类型应与原始类型相同，除非无效性。\r\n            \r\n","Creates a new EmptyStatementSyntax instance.":"创建一个新的emptystatementsyntax实例。\r\n","\r\n              Looks up a localized string similar to The tuple element name is ignored because a different name or no name is specified by the assignment target..\r\n            ":"\r\n              查找类似于元组元素名称的本地化字符串被忽略，因为分配目标指定了其他名称或未指定名称。\r\n            \r\n","Metadata reference the specified directive resolves to, or null if the ":"元数据参考指定的指令解决或null\r\n","\r\n            Check that the name is a valid identifier.\r\n            ":"\r\n            检查名称是否是有效的标识符。\r\n            \r\n","\r\n            Check for (and assert that there are no) duplicate case labels in the switch.\r\n            ":"\r\n            检查（并断言开关中没有重复的案例标签。\r\n            \r\n"," and throw if it returns false.\r\n            ":" 如果它返回false，则投掷。\r\n            \r\n","The index value. it has to be zero or positive number.":"索引值。它必须为零或正数。\r\n"," on the state from branches to that label with the state\r\n            when we fall into the label.  Entries are created when the label is encountered. One\r\n            case deserves special attention: when the destination of the branch is a label earlier\r\n            in the code, it is possible (though rarely occurs in practice) that we are changing the\r\n            state at a label that we've already analyzed. In that case we run another pass of the\r\n            analysis to allow those changes to propagate. This repeats until no further changes to\r\n            the state of these labels occurs.  This can result in quadratic performance in unlikely\r\n            but possible code such as this: \"int x; if (cond) goto l1; x = 3; l5: print x; l4: goto\r\n            l5; l3: goto l4; l2: goto l3; l1: goto l2;\"\r\n            ":"从分支机构到该标签的状态\r\n            当我们跌入标签时。遇到标签时创建条目。一\r\n            案例值得特别注意：当分支的目的地是较早的标签时\r\n            在代码中，有可能（尽管在实践中很少发生）我们正在更改\r\n            在我们已经分析的标签上说明。在这种情况下，我们经营\r\n            分析以允许这些更改传播。这重复直到没有进一步更改\r\n            这些标签的状态发生。这可能导致不太可能的二次性能\r\n            但是这样可能的代码：“ int x; if（cond）goto l1; x = 3; l5：print x; l4：goto\r\n            L5; L3：goto l4; L2：goto l3; L1：goto l2;”\r\n            \r\n","\r\n            Apply the conversion to the type of the operand and return the resulting type. (If the\r\n            operand does not have an explicit type, the operand expression is used for the type.)\r\n            If `checkConversion` is set, the incoming conversion is assumed to be from binding and will be\r\n            re-calculated, this time considering nullability. (Note that the conversion calculation considers\r\n            nested nullability only. The caller is responsible for checking the top-level nullability of\r\n            the type returned by this method.) `trackMembers` should be set if the nullability of any\r\n            members of the operand should be copied to the converted result when possible.\r\n            ":"\r\n            将转换应用于操作数的类型，然后返回结果类型。 （如果是\r\n            操作数没有显式类型，而是将操作数表达式用于该类型。）\r\n            如果设置了“ checkConversion”，则假定传入转换为绑定，将是\r\n            重新计算，这次考虑了无效性。 （请注意，转换计算考虑了\r\n            仅嵌套无效。呼叫者负责检查最高级别的可取性\r\n            该方法返回的类型。）`trackmembers'如果任何可取性\r\n            操作数的成员应在可能的情况下复制到转换结果。\r\n            \r\n","Parameter must have a non-null value when exiting because parameter referenced by NotNullIfNotNull is non-null.":"退出时，参数必须具有非零值，因为notnullifnotnull引用的参数是非null。\r\n","Cannot embed interop type '{0}' found in both assembly '{1}' and '{2}'. Consider setting the 'Embed Interop Types' property to false.":"在两个汇编'{1}'和'{2}'中都无法嵌入Interop类型'{0}'。考虑将“嵌入Interop类型”属性设置为false。\r\n","\r\n            Helper method for wrapping a string in an SourceText.\r\n            ":"\r\n            辅助方法将字符串包裹在SourceText中。\r\n            \r\n","\r\n            Reflects the enclosing method or lambda at the current location (in the bound tree).\r\n            ":"\r\n            在当前位置（在绑定的树中）反映封闭方法或lambda。\r\n            \r\n","Called when the visitor visits a AccessorDeclarationSyntax node.":"当访问者访问AccessOdeClarationsyntax节点时，请致电。\r\n","Creates a new AssignmentExpressionSyntax instance.":"创建一个新的sizhtment expressionsyntax实例。\r\n","type variance":"类型差异\r\n","\r\n              Looks up a localized string similar to The default value specified for parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments.\r\n            ":"\r\n              查找类似于为参数'{0}'指定的默认值类似的本地化字符串将无效，因为它适用于不允许可选参数的上下文中使用的成员。\r\n            \r\n","ExpressionSyntax node representing the expression on the left of the assignment operator.":"表示分配运算符左侧的表达式的表达式节点。\r\n","Creates a new XmlNameSyntax instance.":"创建一个新的XMLNAMESYNTAX实例。\r\n","Argument contains duplicate analyzer instances.":"参数包含重复的分析仪实例。\r\n","\r\n              Looks up a localized string similar to The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute..\r\n            ":"\r\n              查找类似于应用于参数'{0}'的callermemberneattribute类似的本地化字符串将没有效果。它被CallerlineNumberattribute覆盖。\r\n            \r\n","\r\n              Looks up a localized string similar to Comparing with null of type '{0}' always produces 'false'.\r\n            ":"\r\n              查找与“ {0}”类型的null相似的本地化字符串，总是产生“ false”。\r\n            \r\n","\r\n            Cache of created anonymous type templates used as an implementation of anonymous \r\n            types in emit phase.\r\n            ":"\r\n            创建的匿名类型模板的缓存用作匿名的实现\r\n            发射阶段的类型。\r\n            \r\n","!(comparisonResult.false)":"！（比较result.false）\r\n","\r\n            Given a conditional binding expression, find corresponding conditional access node.\r\n            ":"\r\n            给定条件结合表达式，找到相应的条件访问节点。\r\n            \r\n","\r\n            Contains the map of calls to reinferred method symbols, used by the optional rewriter phase of the compiler.\r\n            ":"\r\n            包含由编译器的可选重写阶段使用的重新授予方法符号的调用图。\r\n            \r\n","Creates a new OrderingSyntax instance.":"创建一个新的OrderingSyntax实例。\r\n","Field is never used":"字段从未使用\r\n","\r\n            Temporary bag for methods synthesized by the rewriting. Added to\r\n            ":"\r\n            通过重写合成的方法的临时袋。添加到\r\n            \r\n","\r\n             This is based on SymbolPreparer::IsCLRMethodImplSame in the native compiler.\r\n            \r\n             ACASEY: What the native compiler actually does is compute the C# answer, compute the CLR answer,\r\n             and then confirm that they override the same method.  What I've done here is check for the situations\r\n             where the answers could disagree.  I believe the results will be equivalent.  If in doubt, a more conservative\r\n             check would be implementingMethod.ContainingType.InterfacesAndTheirBaseInterfaces.Contains(@interface).\r\n             ":"\r\n             这是基于本机编译器中的SymbolPreparer :: isclrmethodimplsame。\r\n            \r\n             Acasey：本机编译器实际上所做的是计算C＃答案，计算CLR答案，\r\n             然后确认它们覆盖了相同的方法。我在这里做的是检查情况\r\n             答案可能不同意。我相信结果将是等效的。如果有疑问，一个更保守的人\r\n             检查将是实现method.containingtype.interfacesand andtheirbaseInterfaces.contains（@interface）。\r\n             \r\n","\r\n            Walk a custom attribute argument bound node and return a TypedConstant.  Verify that the expression is a constant expression.\r\n            ":"\r\n            行走自定义属性参数绑定节点并返回键入constant。验证表达是恒定表达式。\r\n            \r\n","The return type of an async method must be void, Task, Task<T>, a task-like type, IAsyncEnumerable<T>, or IAsyncEnumerator<T>":"异步方法的返回类型必须无效，任务，任务<t>，类似任务的类型，iAsyncenumerable <t>或iasyncencenumerator <t>\r\n","\r\n            Stores positions where preprocessor state changes. Sorted by position.\r\n            The updated state can be found in ":"\r\n            存储在预处理器状态变化的位置。按位置排序。\r\n            可以在\r\n","\r\n            BREAK: Dev11 reports WRN_CLS_ArrayArgumentToAttribute on all symbols, whereas roslyn reports it only\r\n            on accessible symbols.\r\n            ":"\r\n            休息：dev11报告wrn_cls_arrayargumentToattoatTribute在所有符号上，而罗斯林仅报告\r\n            在可访问的符号上。\r\n            \r\n","\r\n            A value set factory, which can be used to create a value set instance.  Like ":"\r\n            值集工厂，可用于创建值集实例。喜欢\r\n","\r\n              Looks up a localized string similar to A partial method may not have multiple implementing declarations.\r\n            ":"\r\n              查找类似于部分方法的本地化字符串可能没有多个实施声明。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use #r after first token in file.\r\n            ":"\r\n              查找类似于文件中的局部字符串，类似于文件中的#r。\r\n            \r\n","\r\n            The incremental binder is used when binding statements. Whenever a statement\r\n            is bound, it checks the bound node cache to see if that statement was bound, \r\n            and returns it instead of rebinding it. \r\n            \r\n            For example, we might have:\r\n               while (x > goo())\r\n               {\r\n                 y = y * x;\r\n                 z = z + y;\r\n               }\r\n            \r\n            We might first get semantic info about \"z\", and thus bind just the statement\r\n            \"z = z + y\". Later, we might bind the entire While block. While binding the while\r\n            block, we can reuse the binding we did of \"z = z + y\".\r\n            ":"\r\n            绑定语句时使用增量粘合剂。每当语句\r\n            是绑定的，它检查绑定的节点缓存以查看该语句是否已绑定，\r\n            并返回它而不是重新定位。\r\n            \r\n            例如，我们可能有：\r\n               while（x> goo（））\r\n               {\r\n                 y = y * x;\r\n                 z = z + y;\r\n               }\r\n            \r\n            我们可能首先获得有关“ Z”的语义信息，因此仅绑定语句\r\n            “ z = z + y”。稍后，我们可能会绑定整个块。在绑定时\r\n            块，我们可以重复使用“ z = z + y”的绑定。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': cannot declare instance members in a static class.\r\n            ":"\r\n              查找类似于'{0}'：无法在静态类中声明实例成员的本地化字符串。\r\n            \r\n","Expected identifier or numeric literal":"预期标识符或数字字面\r\n"," would permit ":" 会允许\r\n","\r\n              Looks up a localized string similar to Unable to resolve file path '{0}' specified for the named argument '{1}' for PermissionSet attribute.\r\n            ":"\r\n              查找一个本地化字符串，类似于无法解析为Permissionset属性指定的命名参数'{1}'指定的文件路径'{0}'。\r\n            \r\n","The original syntax node.":"原始语法节点。\r\n","\r\n            A map from a local NoPia type to corresponding canonical type.\r\n            ":"\r\n            从本地NOPIA类型到相应的规范类型的地图。\r\n            \r\n","\r\n            Performs the analysis step of getting nullability information for a semantic model but\r\n            does not actually use the results. This gives us extra verification of nullable flow analysis.\r\n            It is only used in contexts where nullable analysis is disabled in the compilation but requested\r\n            through \"run-nullable-analysis=always\" or when the compiler is running in DEBUG.\r\n            ":"\r\n            执行分析步骤，以获取语义模型的无效信息，但\r\n            实际上没有使用结果。这为我们提供了无效流分析的额外验证。\r\n            它仅用于在编译中禁用可无效分析但请求的上下文中\r\n            通过“可运行的无效分析=始终”或编译器在调试中运行时。\r\n            \r\n","\r\n            The type of the event.\r\n            ":"\r\n            事件的类型。\r\n            \r\n","\r\n            An element of a BaseCrefParameterListSyntax.\r\n            Unlike a regular parameter, a cref parameter has only an optional ref or out keyword and a type -\r\n            there is no name and there are no attributes or other modifiers.\r\n            ":"\r\n            基本级别列表的元素。\r\n            与常规参数不同，CREF参数仅具有可选的Ref或Out关键字和类型 - \r\n            没有名称，也没有属性或其他修饰符。\r\n            \r\n","The element {0} is missing an attribute named {1}.":"元素{0}缺少一个名为{1}的属性。\r\n","True to allow invocation of fields and properties of delegate type. Only methods are allowed otherwise.":"the允许调用字段和委托类型的属性。否则仅允许使用方法。\r\n","b == e":"b == e\r\n","\r\n            There is some similarity between this member and TypeSymbol.FindPotentialImplicitImplementationMemberDeclaredInType.\r\n            When making changes to this member, think about whether or not they should also be applied in TypeSymbol.\r\n            \r\n            In incorrect or imported code, it is possible that both currTypeBestMatch and hiddenBuilder will be populated.\r\n            ":"\r\n            该成员和typesymbol之间存在一些相似之处。findPotentiMplicerImplementationMemberDeclaredIntype。\r\n            在更改该成员时，请考虑是否也应将其应用于Typesymbol。\r\n            \r\n            在不正确或导入的代码中，CurrTypebestMatch和HiddenBuilder可能会被填充。\r\n            \r\n","\r\n            Returns a bag of applied custom attributes and data decoded from well-known attributes.\r\n            Returns an empty bag if there are no attributes applied on the symbol.\r\n            ":"\r\n            返回一袋应用的自定义属性和从众所周知的属性解码的数据。\r\n            如果符号上没有属性，则返回一个空袋。\r\n            \r\n","\r\n            Determines what type of conversion, if any, would be used if a given expression was\r\n            converted to a given type using an explicit cast.\r\n            ":"\r\n            确定如果给定的表达式为\r\n            使用明确的铸件转换为给定类型。\r\n            \r\n","\r\n            Is the code reachable?\r\n            ":"\r\n            代码可以达到吗？\r\n            \r\n"," from the first ":" 从第一\r\n","Type or member does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute":"类型或成员不需要CLSCompliant属性，因为组件没有CLSCompliant属性\r\n","'{0}' is obsolete: '{1}'":"'{0}'是过时的：'{1}'\r\n","\r\n              Looks up a localized string similar to There is an error in a referenced assembly '{0}'..\r\n            ":"\r\n              查找类似于引用的汇编'{0}'..的本地化字符串。\r\n            \r\n"," and\r\n            this binder simply delegates to it when appropriate. That ensures that the same set of symbols is \r\n            shared across all compilation units.\r\n            ":" 和\r\n            此活页夹在适当的情况下只是将其委派。确保相同的符号是\r\n            在所有汇编单元中共享。\r\n            \r\n","Type '{0}' cannot be embedded because it has a generic argument. Consider setting the 'Embed Interop Types' property to false.":"类型'{0}'不能嵌入，因为它具有通用参数。考虑将“嵌入Interop类型”属性设置为false。\r\n","\r\n            Specifies whether or not method's out parameters should be analyzed. If there's more\r\n            than one location in the method being analyzed, then the method is partial and we prefer\r\n            to report an out parameter in partial method error.\r\n            ":"\r\n            指定是否应分析方法的OUT参数。如果还有更多\r\n            比正在分析的方法中的一个位置，然后该方法是部分的，我们更喜欢\r\n            以部分方法错误报告OUT参数。\r\n            \r\n","\r\n            Returns information retrieved from custom attributes on return type in source, or null if the symbol is not source symbol or there are none.\r\n            ":"\r\n            从返回类型上的自定义属性检索到的返回信息，或者如果符号不是源符号或没有符号，则返回信息。\r\n            \r\n","\r\n            A Compilation the assembly is created for.\r\n            ":"\r\n            为组件创建的汇编。\r\n            \r\n","\r\n            One or more errors occured while performing the lookup\r\n            ":"\r\n            执行查找时发生一个或多个错误\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' does not contain a definition for '{1}' and no extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive or an assembly reference?).\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串不包含'{1}''的定义，并且没有扩展方法'{1}'接受类型'{0}'的第一个参数（您是否丢失了使用指令或装配引用？）。\r\n            \r\n","An expression tree lambda may not contain a method with variable arguments":"表达树lambda可能不包含具有可变参数的方法\r\n","\r\n            Data flow analysis is used to calculate the locals. At yield/await we mark all variables as \"unassigned\".\r\n            When a read from an unassigned variables is reported we add the variable to the captured set.\r\n            \"this\" parameter is captured if a reference to \"this\", \"base\" or an instance field is encountered.\r\n            Variables used in finally also need to be captured if there is a yield in the corresponding try block.\r\n            ":"\r\n            数据流分析用于计算当地人。以产量/等待，我们将所有变量标记为“未分配”。\r\n            报告从未分配变量的读取时，我们将变量添加到捕获的集合中。\r\n            如果遇到“此”，“基础”或实例字段的引用，则将捕获“此”参数。\r\n            如果相应的尝试块中有产率，则最终还需要捕获最终使用的变量。\r\n            \r\n","\r\n            Parse a list of trivia rules for leading trivia.\r\n            ":"\r\n            解析领先琐事的琐事规则清单。\r\n            \r\n",".\r\n            \r\n            In order to reduce allocations, merge environments into a parent environment when it is safe to do so.\r\n            This must be done whilst preserving semantics.\r\n            \r\n            We also have to make sure not to extend the life of any variable.\r\n            This means that we can only merge an environment into its parent if exactly the same closures directly or indirectly reference both environments.\r\n            ":"。\r\n            \r\n            为了减少分配，在安全的情况下将环境合并到父环境中。\r\n            这必须在保存语义的同时完成。\r\n            \r\n            我们还必须确保不要延长任何变量的寿命。\r\n            这意味着，如果直接或间接地引用两个环境，我们只能将环境合并到其父母中。\r\n            \r\n","\r\n              Looks up a localized string similar to An expression tree lambda may not contain a method with variable arguments.\r\n            ":"\r\n              查找类似于表达树lambda的本地化字符串可能不包含具有可变参数的方法。\r\n            \r\n","\r\n              Looks up a localized string similar to The accessibility modifier of the '{0}' accessor must be more restrictive than the property or indexer '{1}'.\r\n            ":"\r\n              查找类似于“ {0}”访问者的可访问性修饰符的本地化字符串必须比属性或索引器'{1}'更具限制性。\r\n            \r\n","\r\n            This method should be the only method adding use-site diagnostics to a diagnostic bag. \r\n            It performs additional adjustments of the location for unification related diagnostics and \r\n            may be the place where to add more use-site location post-processing.\r\n            ":"\r\n            此方法应该是唯一在诊断袋中添加用途诊断的方法。\r\n            它对统一相关诊断的位置进行其他调整和\r\n            可能是添加更多用途位置后处理的地方。\r\n            \r\n","\r\n            If IsFixed is true, the value between brackets in the fixed-size-buffer declaration.\r\n            If IsFixed is false FixedSize is 0.\r\n            Note that for fixed-a size buffer declaration, this.Type will be a pointer type, of which\r\n            the pointed-to type will be the declared element type of the fixed-size buffer.\r\n            ":"\r\n            如果iSfixed是正确的，则固定大小 - 缓冲器声明中的括号之间的值。\r\n            如果ISFIXED为FALSE固定尺寸为0。\r\n            请注意，对于固定A大小缓冲区声明，此.Type将是指指指针类型\r\n            指向类型将是固定尺寸缓冲区的声明元素类型。\r\n            \r\n","Type parameter syntax.":"类型参数语法。\r\n"," checks if the value is equal to a given constant. Of the evaluations,\r\n            there are ":"检查值是否等于给定常数。评估，\r\n            有\r\n","\r\n              Looks up a localized string similar to Type expected.\r\n            ":"\r\n              查找类似于预期类型的​​本地化字符串。\r\n            \r\n","\r\n            Represents the operand type used for the result of a null-coalescing\r\n            operator. Used when determining nullability.\r\n            ":"\r\n            代表用于零污染结果的操作数类型\r\n            操作员。确定无效性时使用。\r\n            \r\n","\r\n            Returns a bag of custom attributes applied on the method return value and data decoded from well-known attributes. Returns null if there are no attributes.\r\n            ":"\r\n            返回对方法返回值和从众所周知属性解码的数据应用的自定义属性袋。如果没有属性，则返回null。\r\n            \r\n","\r\n            Represents an event that is based on another event.\r\n            When inheriting from this class, one shouldn't assume that \r\n            the default behavior it has is appropriate for every case.\r\n            That behavior should be carefully reviewed and derived type\r\n            should override behavior as appropriate.\r\n            ":"\r\n            代表基于另一个事件的事件。\r\n            从这个课程继承时，不应该假设\r\n            它具有的默认行为适用于每种情况。\r\n            该行为应仔细审查和派生类型\r\n            应适当地覆盖行为。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' cannot be sealed because it is not an override.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串，因为它不是替代的，因此无法密封。\r\n            \r\n","An ImmutableArray containing all the members of this symbol with the given name. If there are\r\n            no members with this name, returns an empty ImmutableArray. Never returns null.":"一个immutablearray包含带有给定名称的所有符号成员。如果有\r\n            没有这个名字的成员返回一个空的Immutablearray。永远不会返回零。\r\n","Populated with binding diagnostics.":"填充有约束力的诊断。\r\n","\r\n            CONSIDER: we could probably do less work in the metadata and retargeting cases - we won't use the diagnostics.\r\n            ":"\r\n            考虑：我们可能会在元数据和重定向案例中做更少的工作——我们不会使用诊断。\r\n            \r\n","Creates a new QualifiedNameSyntax instance.":"创建一个新的合格Namesyntax实例。\r\n","\r\n            Even though it is declared with an IndexerDeclarationSyntax, an explicit\r\n            interface implementation is not an indexer because it will not cause the\r\n            containing type to be emitted with a DefaultMemberAttribute (and even if\r\n            there is another indexer, the name of the explicit implementation won't\r\n            match).  This is important for round-tripping.\r\n            ":"即使用索引列表宣布它，也是显式的\r\n            接口实现不是索引器，因为它不会导致\r\n            包含要发射defaultmemberattribute的类型\r\n            还有另一个索引器，明确实现的名称不会\r\n            匹配）。这对于往返很重要。\r\n            \r\n","\r\n            Get the path name starting from the ":"\r\n            从\r\n","\r\n              Looks up a localized string similar to foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public definition for '{1}'.\r\n            ":"查找类似于foreach语句的本地化字符串无法在类型'{0}'的变量上操作，因为'{0}'不包含'{1}'的公共定义。\r\n            \r\n","The CallerLineNumberAttribute may only be applied to parameters with default values":"CallerlineNumberattribute只能应用于具有默认值的参数\r\n","\r\n            For tuple fields that aren't TupleElementFieldSymbol or TupleErrorFieldSymbol, we cache their tuple element index.\r\n            This supports ":"\r\n            对于不是TupleelementFieldSymbol或TupleErriffieldSymbol的元组田，我们会缓存其元组元素索引。\r\n            这支持\r\n","\r\n            The caller is responsible for freeing ":"\r\n            呼叫者负责释放\r\n","\r\n              Looks up a localized string similar to '{1}': cannot derive from static class '{0}'.\r\n            ":"\r\n              查找类似于'{1}'：不能从静态类'{0}'派生的本地化字符串。\r\n            \r\n","XML comment has a duplicate typeparam tag":"XML评论具有重复的Typeparam标签\r\n","\r\n            A MemberCrefSyntax specified by a name (an identifier, predefined type keyword, or an alias-qualified name,\r\n            with an optional type parameter list) and an optional parameter list.\r\n            For example, \"M\", \"M<T>\" or \"M(int)\".\r\n            Also, \"A::B()\" or \"string()\".\r\n            ":"\r\n            由名称指定的成员crefsyntax（标识符，预定义的类型关键字或别名准则的名称，\r\n            带有可选类型参数列表）和可选参数列表。\r\n            例如，“ M”，“ M <t>”或“ M（int）”。\r\n            另外，“ a :: b（）”或“ string（）”。\r\n            \r\n",", when they must share attribute data and default constant value.\r\n            For example, parameters on a property symbol are cloned to generate parameters on accessors.\r\n            Similarly parameters on delegate invoke method are cloned to delegate begin/end invoke methods.\r\n            ":"，当他们必须共享属性数据并默认常数值时。\r\n            例如，将属性符号上的参数克隆到访问者上生成参数。\r\n            类似地，将委托使用方法的参数克隆为委派开始/结束调用方法。\r\n            \r\n","\r\n            Gets a SyntaxToken that represents the open braces succeeding the switch sections.\r\n            ":"\r\n            获取一个代表成功开关部分的开放括号的语法。\r\n            \r\n","To determine the conversion between two types (instead of an expression and a\r\n            type), use Compilation.ClassifyConversion.":"确定两种类型之间的转换（而不是表达式和​​一个\r\n            类型），使用Compilation.ClassifyConversion。\r\n","\r\n            An error type, used to represent a byref return in a metadata signature.\r\n            ":"\r\n            错误类型，用于表示元数据签名中的BYREF返回。\r\n            \r\n","\r\n              Looks up a localized string similar to Expression must be implicitly convertible to Boolean or its type '{0}' must define operator '{1}'..\r\n            ":"\r\n              查找类似于表达式的本地化字符串必须隐式转换为布尔值或其类型“ {0}”必须定义操作符'{1}'..\r\n            \r\n","\r\n            Get the parameters of a member symbol.  Should be a method, property, or event.\r\n            ":"\r\n            获取成员符号的参数。应该是一种方法，属性或事件。\r\n            \r\n","\r\n            Internal cache of built-in operators.\r\n            Cache is compilation-specific because it uses compilation-specific SpecialTypes.\r\n            ":"\r\n            内置操作员的内部缓存。\r\n            缓存是特定于汇编的，因为它使用了汇编特定的特殊特殊类型。\r\n            \r\n","\r\n            Symbol for a foreach iteration variable that can be inferred by binding the\r\n            collection element type of the foreach.\r\n            ":"\r\n            可以通过绑定来推断的foreach迭代变量的符号\r\n            收集元件类型的foreach。\r\n            \r\n","The semantic information for the topmost node of the attribute.":"属性最上方节点的语义信息。\r\n","Attribute '{0}' given in a source file conflicts with option '{1}'.":"源文件中给出的属性'{0}'与选项'{1}'相冲突。\r\n","\r\n            We will follow Dev10 in diverging from the C# 4 spec by ignoring Array's \r\n            implementation of IEnumerable and just indexing into its elements.\r\n            \r\n            NOTE: We're assuming that sequence points have already been generated.\r\n            Otherwise, lowering to for-loops would generated spurious ones.\r\n            ":"\r\n            我们将遵循Dev10，通过忽略数组来偏离C#4规范 \r\n            实现IEnumerable和只是索引到它的元素。\r\n            \r\n            注意：我们假设序列点已经生成。\r\n            否则，降低到for循环会产生虚假的。\r\n            \r\n","The text used within the xml text literal.":"XML文本中使用的文字文字文字。\r\n","Returns non-negative index if the list contains a trivia which matches ":"如果列表包含匹配的琐事，则返回非负索引\r\n","\r\n              Looks up a localized string similar to An array access may not have a named argument specifier.\r\n            ":"\r\n              查找类似于数组访问的本地化字符串可能没有命名参数规范符。\r\n            \r\n","\r\n              Looks up a localized string similar to The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion or type parameter conversion from '{3}' to '{1}'..\r\n            ":"\r\n              在通用类型或方法'{0}'中查找类似于类型的'{3}'类型的本地化字符串。没有拳击转换或类型参数转换从'{3}'到'{1}'..\r\n            \r\n","\r\n            This method is used in deeply recursive parts of the compiler and requires a non-trivial amount of stack\r\n            space to execute. Preventing inlining here to keep recursive frames small.\r\n            ":"\r\n            该方法用于编译器的深层递归部分，需要非平凡的堆栈\r\n            执行的空间。防止在此处插入以保持递归框架较小。\r\n            \r\n","Nullability warnings.":"无效警告。\r\n","Within cref attributes, nested types of generic types should be qualified.":"在CREF属性中，应有资格的通用类型的嵌套类型。\r\n","\r\n            Returns true if the local variable is declared in fixed-pointer-initializer (in unsafe context)\r\n            ":"\r\n            如果在固定销售器中声明本地变量（在不安全的上下文中），则返回true。\r\n            \r\n","\r\n            Determines whether the given text is considered a syntactically complete submission.\r\n            Throws ":"\r\n            确定给定文本是否被视为句法完整提交。\r\n            扔\r\n","Type cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type":"类型不能标记为CLS兼容，因为它是非CLS类型的成员\r\n","\r\n              Looks up a localized string similar to Filter expression is a constant 'false'.\r\n            ":"\r\n              查找类似于过滤器表达式的本地化字符串是常数“ false”。\r\n            \r\n","\r\n            Parse the parameter list (if any) of a cref member (name, indexer, operator, or conversion).\r\n            ":"\r\n            解析CREF成员的参数列表（如果有）（名称，索引器，操作员或转换）。\r\n            \r\n","\r\n            Returns false if the source does not have an implicit conversion to the destination\r\n            because of either incompatible top level or nested nullability.\r\n            ":"\r\n            如果源没有隐式转换到目的地，则返回false\r\n            由于不兼容的顶级或嵌套无效性。\r\n            \r\n","\r\n              Looks up a localized string similar to directory does not exist.\r\n            ":"\r\n              查找与目录类似的本地化字符串。\r\n            \r\n","\r\n            Returns true if nullable analysis is enabled for all methods regardless\r\n            of the actual nullable context.\r\n            If this property returns true but IsNullableAnalysisEnabled returns false,\r\n            any nullable analysis should be enabled but results should be ignored.\r\n            ":"\r\n            如果对所有方法启用了无效的分析，则返回true\r\n            实际无效的上下文。\r\n            如果此属性返回true，但是insnullableAnalysisenabled返回false，则\r\n            应启用任何无效的分析，但应忽略结果。\r\n            \r\n","\r\n              Looks up a localized string similar to Expected contextual keyword 'by'.\r\n            ":"\r\n              查找类似于预期上下文关键字“ by”的本地化字符串。\r\n            \r\n","ref for-loop variables":"Ref For-loop变量\r\n","named argument":"命名参数\r\n","An expression tree may not contain a with-expression.":"表达树可能不包含表达式。\r\n","\r\n              Looks up a localized string similar to Members of readonly field '{0}' cannot be returned by reference.\r\n            ":"\r\n              查找类似于Readonly字段'{0}'成员的本地化字符串，无法通过参考返回。\r\n            \r\n","\r\n              Looks up a localized string similar to The 'partial' modifier can only appear immediately before 'class', 'struct', 'interface', or 'void'.\r\n            ":"\r\n              查找类似于“部分”修饰符的本地化字符串只能在“类”，“ struct”，“界面”或“ void”之前立即出现。\r\n            \r\n","The tuple element name '{0}' is ignored because a different name or no name is specified on the other side of the tuple == or != operator.":"元组元素名称'{0}'被忽略了，因为在元组的另一侧指定了不同的名称或未指定名称。\r\n","\r\n            Returns true if the node is the object of an element access expression.\r\n            ":"\r\n            如果节点是元素访问表达式的对象，则返回true。\r\n            \r\n",",\r\n            meaning that some trailing dimensions don't have the lower bound specified.\r\n            The most common case is all dimensions are zero bound - a null array is returned in this case.\r\n            ":"，，，，\r\n            这意味着某些尾随尺寸没有指定的下限。\r\n            最常见的情况是所有尺寸均为零绑定 - 在这种情况下，返回一个空数组。\r\n            \r\n","The optional parse options to use. If no options are specified default options are\r\n            used.":"可选的解析选项。如果未指定选项，则默认选项为\r\n            用过的。\r\n","\r\n            For methods with annotations, we'll need to visit the arguments twice.\r\n            Once for diagnostics and once for result state (but disabling diagnostics).\r\n            ":"\r\n            对于带注释的方法，我们需要两次访问论点。\r\n            一次用于诊断，一次用于结果状态（但禁用诊断）。\r\n            \r\n","True if this is an interface type.":"如果是接口类型，则为true。\r\n","\r\n            Syntax offset is a unique identifier for the local within the emitted method body.\r\n            It's based on position of the local declarator. In single-part method bodies it's simply the distance\r\n            from the start of the method body syntax span. If a method body has multiple parts (such as a constructor \r\n            comprising of code for member initializers and constructor initializer calls) the offset is calculated\r\n            as if all source these parts were concatenated together and prepended to the constructor body.\r\n            The resulting syntax offset is then negative for locals defined outside of the constructor body.\r\n            ":"\r\n            语法偏移是发射方法主体内局部的唯一标识符。\r\n            它基于本地宣告者的位置。在单部分方法的主体中，这只是距离\r\n            从方法的开始，主体语法跨度。如果方法主体有多个部分（例如构造函数\r\n            包括成员初始化器和构造函数初始化器调用的代码）计算偏移量\r\n            好像所有来源的这些部分都被连接在一起，并添加到构造函数上。\r\n            然后，所得的语法偏移量对于在构造函数主体外定义的当地人为负。\r\n            \r\n","true if the optimization is applied":"如果应用了优化\r\n","\r\n            Return true if the given type is or implements a WinRTAsyncInterface.\r\n            ":"\r\n            如果给定类型为或实现winrtasyncinterface，则返回true。\r\n            \r\n","Node to report diagnostics, if any, such as \"yield statement cannot be used\r\n            inside a lambda expression\"":"报告诊断的节点（如果有的话），例如“无法使用收益语句”\r\n            在lambda表达中”\r\n","Called when the visitor visits a TryStatementSyntax node.":"当访问者访问trystatementsyntax节点时调用。\r\n","\r\n                 [TupleElementNamesAttribute(new[] { \"e3\", \"e4\", \"e1\", \"e2\" });\r\n                 class C : BaseType<System.ValueTuple<\r\n                     System.ValueTuple<int,int>, int>\r\n                 { ... }\r\n             ":"\r\n                 [tupleelementnamesattribute（new [] {“ e3”，“ e4”，“ e1”，“ e2”}）;\r\n                 C级：底型<system.valuetuple <\r\n                     system.valuetuple <int，int>，int>\r\n                 {...}\r\n             \r\n","Class which represents the syntax node for pointer type.":"代表指针类型的语法节点的类。\r\n","\r\n              Looks up a localized string similar to A partial method must be declared within a partial class, partial struct, or partial interface.\r\n            ":"\r\n              查找类似于部分方法的本地化字符串必须在部分类，部分结构或部分接口中声明。\r\n            \r\n","Called when the visitor visits a PragmaChecksumDirectiveTriviaSyntax node.":"当访客访问pragmachecksumdirectivetriviasyntax节点时，请致电。\r\n","An expression tree lambda may not contain a call to a method, property, or indexer that returns by reference":"表达树lambda可能不包含通过参考返回的方法，属性或索引器的调用\r\n","\r\n            Any scope that a method that ":"\r\n            任何范围\r\n","\r\n              Looks up a localized string similar to Cannot embed interop types from assembly '{0}' because it is missing the '{1}' attribute..\r\n            ":"\r\n              查找类似于无法嵌入Interop类型的本地化字符串，因为它缺少'{1}'属性..\r\n            \r\n","\r\n            Report appropriate diagnostics when lookup of a pattern member (i.e. GetEnumerator, Current, or MoveNext) fails.\r\n            ":"\r\n            在查找模式成员（即GetEnumerator，当前或MoveNext）失败时，报告适当的诊断。\r\n            \r\n","\r\n            Appends all trees (including any trees from #load'ed files).\r\n            ":"\r\n            附加所有树（包括＃负载文件中的任何树）。\r\n            \r\n"," delegate to be executed immediately on another thread,\r\n            and returns a ":" 委派将立即在另一个线程上执行，\r\n            并返回a\r\n","\r\n              Looks up a localized string similar to Referenced assembly '{0}' targets a different processor..\r\n            ":"\r\n              查找类似于引用的汇编'{0}'目标的本地化字符串。\r\n            \r\n","\r\n            Sets substitution used by the rewriter for a placeholder node.\r\n            Each occurrence of the placeholder node is replaced with the node returned.\r\n            Throws if there is already a substitution.\r\n            ":"\r\n            将重写器使用的替代设置用于占位符节点。\r\n            占位符节点的每个出现都被返回的节点替换。\r\n            如果已经有替代，则投掷。\r\n            \r\n","\r\n            Return the native integer type corresponding to the underlying type.\r\n            ":"\r\n            返回对应于基础类型的本机整数类型。\r\n            \r\n","\r\n            CONSIDER: it probably isn't truly necessary to cache this.  If space gets tight, consider\r\n            alternative approaches (recompute every time, cache on the side, only store on some types,\r\n            etc).\r\n            ":"\r\n            考虑：可能没有必要缓存它。如果空间变得紧张，请考虑\r\n            替代方法（每次重新计算，缓存在一边，只存储在某些类型上，\r\n            ETC）。\r\n            \r\n","\r\n            This is a layer on top of the Compilation version that generates a diagnostic if the special\r\n            member isn't found.\r\n            ":"\r\n            这是汇编版本顶部的一层，如果特殊\r\n            找不到会员。\r\n            \r\n","\r\n            Returns true if a bad special by ref local was found.\r\n            ":"\r\n            如果发现Ref Local的不良特别节目，则返回。\r\n            \r\n","True when there is no error or warning treated as an error.":"当没有错误或警告视为错误时，是真的。\r\n","Type to check.":"输入检查。\r\n","\r\n              Looks up a localized string similar to Cannot infer the type of implicitly-typed out variable '{0}'..\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法推断隐式型变量的类型'{0}'..\r\n            \r\n","LIB environment variable":"LIB环境变量\r\n","Do not override object.Finalize. Instead, provide a destructor.":"不要覆盖对象。相反，提供攻击函数。\r\n","\r\n              Looks up a localized string similar to Auto-implemented properties inside interfaces cannot have initializers..\r\n            ":"\r\n              查找类似于接口内部的自动实践属性的本地化字符串，无法具有初始化器。\r\n            \r\n","\r\n            The contents are provided by ReferenceManager and may not be modified.\r\n            ":"\r\n            内容由ReferenceManager提供，不得修改。\r\n            \r\n","\r\n             (3) The \"this\" symbol for the current method in ":"\r\n             （3）当前方法中的“此”符号\r\n","\r\n            This method is intended for passes other than the LocalRewriter.\r\n            Use MakeConversion helper method in the LocalRewriter instead,\r\n            it generates a synthesized conversion in its lowered form.\r\n            ":"\r\n            此方法旨在用于除localrewriter以外的其他方法。\r\n            改用localrewriter中使用makeconversion助手方法，\r\n            它以降低形式生成合成的转换。\r\n            \r\n","Cannot yield a value in the body of a catch clause":"无法在捕获子句的正文中产生价值\r\n","\r\n            Indicates whether a type is managed or not (i.e. you can take a pointer to it).\r\n            Contains additional cases to help implement FeatureNotAvailable diagnostics.\r\n            ":"\r\n            指示是否管理类型（即，您可以将指针用于指针）。\r\n            包含其他案例，以帮助实施功能杂志可诊断。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' is explicitly implemented more than once..\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串已不止一次实现。\r\n            \r\n","\r\n             Generate a thread-safe accessor for a regular field-like event.\r\n            \r\n             DelegateType tmp0 = _event; //backing field\r\n             DelegateType tmp1;\r\n             DelegateType tmp2;\r\n             do {\r\n                 tmp1 = tmp0;\r\n                 tmp2 = (DelegateType)Delegate.Combine(tmp1, value); //Remove for -=\r\n                 tmp0 = Interlocked.CompareExchange<DelegateType>(ref _event, tmp2, tmp1);\r\n             } while ((object)tmp0 != (object)tmp1);\r\n            \r\n             Note, if System.Threading.Interlocked.CompareExchange<T> is not available,\r\n             we emit the following code and mark the method Synchronized (unless it is a struct).\r\n            \r\n             _event = (DelegateType)Delegate.Combine(_event, value); //Remove for -=\r\n            \r\n             ":"\r\n             为常规现场事件生成线程安全登录器。\r\n            \r\n             授权型TMP0 = _EVENT; //支持字段\r\n             授权型TMP1;\r\n             授权型TMP2;\r\n             做 {\r\n                 TMP1 = TMP0;\r\n                 tmp2 =（delegateType）delegate.combine（tmp1，value）; //删除 -  =\r\n                 tmp0 = Interlocked.compareexchange <delegatetype>（ref _Event，tmp2，tmp1）;\r\n             } while（（对象）tmp0！=（object）tmp1）;\r\n            \r\n             注意，如果system.threading.interlocked.compareexchange <t>不可用，\r\n             我们发射以下代码并标记该方法同步（除非是结构）。\r\n            \r\n             _event =（delegateType）delegate.combine（_Event，value）; //删除 -  =\r\n            \r\n             \r\n"," or top-level ":" 或顶级\r\n","\r\n              Looks up a localized string similar to '{0}' cannot be added to this assembly because it already is an assembly.\r\n            ":"\r\n              查找类似于“ {0}”的局部字符串，因为它已经是一个程序集，因此无法将其添加到此组件中。\r\n            \r\n","\r\n            Having found the best member to override, we want to find members with the same signature on the\r\n            best member's containing type.\r\n            ":"\r\n            找到了覆盖最佳成员后，我们希望在\r\n            最佳成员包含类型。\r\n            \r\n","This is a cache of a subset of ":"这是一个子集的缓存\r\n","\r\n            Get the bound node corresponding to the root.\r\n            ":"\r\n            获取与根相对应的界点。\r\n            \r\n","\r\n            If overload resolution successfully selected a single best method, returns information\r\n            about that method. Otherwise returns null.\r\n            ":"\r\n            如果超载分辨率成功选择了单个最佳方法，请返回信息\r\n            关于该方法。否则返回null。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot inherit interface '{0}' with the specified type parameters because it causes method '{1}' to contain overloads which differ only on ref and out.\r\n            ":"查找类似于指定类型参数的局部字符串与无法继承界面'{0}'，因为它导致方法'{1}'包含仅在Ref和out上有所不同的过载。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot await '{0}'.\r\n            ":"\r\n              查找类似于无法等待'{0}'的本地化字符串。\r\n            \r\n","\r\n            The two-pass algorithm (accessible constructors, then all constructors) is the reason for the unusual signature\r\n            of this method (i.e. not populating a pre-existing ":"\r\n            两通算法（可访问的构造函数，然后所有构造函数）是异常签名的原因\r\n            这种方法（即不填充预先存在的\r\n","\r\n            Tokens that match the following are considered a possible lambda expression:\r\n            ":"\r\n            匹配以下的代币被认为是可能的lambda表达式：\r\n            \r\n","\r\n            When array operation get long or ulong arguments the args should be \r\n            cast to native int.\r\n            Note that the cast is always checked.\r\n            ":"\r\n            当数组操作长时间或乌隆争论时，args应该是\r\n            铸造给本地int。\r\n            请注意，始终检查演员表。\r\n            \r\n","\r\n            Normally C# arrays have default sizes and lower bounds - sizes are not specified and all dimensions are zero bound.\r\n            This property should return false for any deviations.\r\n            ":"\r\n            通常，C＃数组具有默认尺寸，并且未指定大小，并且所有尺寸均为零界。\r\n            此属性应返回任何偏差的false。\r\n            \r\n","\r\n            Look for overridden or hidden members in a specific type.\r\n            ":"\r\n            在特定类型中寻找覆盖或隐藏的成员。\r\n            \r\n","Only a single {0} can be registered per generator.":"每个发电机只能注册一个{0}。\r\n","\r\n              Looks up a localized string similar to An anonymous type cannot have multiple properties with the same name.\r\n            ":"\r\n              查找类似于匿名类型的本地化字符串不能具有具有相同名称的多个属性。\r\n            \r\n","\r\n              Looks up a localized string similar to A property subpattern requires a reference to the property or field to be matched, e.g. '{{ Name: {0} }}'.\r\n            ":"\r\n              查找类似于属性子图案的本地化字符串需要对要匹配的属性或字段的引用，例如'{{name：{0}}}'。\r\n            \r\n","\r\n            Performs some validation of the accessor that couldn't be done in CheckEventValueKind, because\r\n            the specific accessor wasn't known.\r\n            ":"\r\n            对CheckEventValueKind中无法完成的访问器执行一些验证，因为\r\n            具体的访问器不知道。\r\n            \r\n","\r\n            Get the constant value of type ":"\r\n            获取类型的恒定值\r\n","\r\n            Perform a check whether the type or at least one of its generic arguments \r\n            is an explicitly defined local type. The check is performed recursively. \r\n            ":"\r\n            执行检查类型还是至少一种通用参数\r\n            是明确定义的本地类型。检查是递归执行的。\r\n            \r\n","\r\n            Returns false because local variable can't be abstract.\r\n            ":"\r\n            返回错误，因为本地变量不能抽象。\r\n            \r\n","Called when the visitor visits a CaseSwitchLabelSyntax node.":"当访客访问casewitchlabelsyntax节点时，请致电。\r\n","\r\n            Returns value 'NetModule' of the ":"\r\n            返回值的“ NetModule”\r\n","\r\n              Looks up a localized string similar to Do not override object.Finalize. Instead, provide a destructor..\r\n            ":"\r\n              查找类似于不覆盖对象的本地化字符串。相反，提供攻击函数..\r\n            \r\n","\r\n              Looks up a localized string similar to The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'..\r\n            ":"查找类似于“ {0}”类型的本地化字符串与导入的类型'{3}'中的类型“ {1}”中的相似之处。使用“ {0}”中定义的类型。\r\n            \r\n","\r\n            Will be true in a lambda in an iterator.\r\n            ":"\r\n            在迭代器中的lambda中将是正确的。\r\n            \r\n","\r\n             Where should we jump to to continue the execution of disposal path.\r\n            \r\n             Initially, this is the method's return value label (":"\r\n             我们应该跳到哪里继续执行处置路径。\r\n            \r\n             最初，这是该方法的返回值标签（\r\n","\r\n            Add fields to the state machine class that control the state machine.\r\n            ":"\r\n            将字段添加到控制状态计算机的状态计算机类中。\r\n            \r\n","The type '{0}' has no constructors defined":"类型'{0}'没有定义的构造函数\r\n","\r\n            Returns true if the conversion is an implicit object creation expression conversion.\r\n            ":"\r\n            如果转换是隐式对象创建表达式转换，则返回true。\r\n            \r\n","\r\n            Returns true if the expression on the left-hand-side of an assignment causes the assignment to be a deconstruction.\r\n            ":"\r\n            如果分配的左侧表达式导致分配是解构的，则返回true。\r\n            \r\n"," with minimal binding.\r\n            ":" 具有最小的结合。\r\n            \r\n","\r\n            Gets the list of constructor arguments specified by this application of the attribute.  This list contains both positional arguments\r\n            and named arguments that are formal parameters to the constructor.\r\n            ":"\r\n            获取该属性应用程序指定的构造函数参数列表。此列表包含两个位置参数\r\n            并命名为构造函数正式参数的参数。\r\n            \r\n","Cannot use '{0}' for Main method because it is imported":"无法将'{0}'用于主要方法，因为它是导入的\r\n","\r\n            A DocumentationProvider that provides XML documentation comments for this assembly.\r\n            ":"\r\n            提供此组件的XML文档注释的DocumentationProvider。\r\n            \r\n","\r\n            Does an expression of type ":"\r\n            表达类型\r\n","\r\n              Looks up a localized string similar to Invalid constraint type. A type used as a constraint must be an interface, a non-sealed class or a type parameter..\r\n            ":"\r\n              查找类似于无效约束类型的本地化字符串。用作约束的类型必须是接口，非密封类或类型参数。\r\n            \r\n","\r\n            Bind the pattern switch section, producing subsumption diagnostics.\r\n            ":"\r\n            绑定图案开关部分，产生集合诊断。\r\n            \r\n","Called when the visitor visits a IsPatternExpressionSyntax node.":"当访问者访问isPatterNexpressyntax节点时，请致电。\r\n","\r\n            Since dev11 didn't expose a symbol API, it had the luxury of being able to accept a base class's claim that \r\n            it implements an interface.  Roslyn, on the other hand, needs to be able to point to an implementing symbol\r\n            for each interface member.\r\n            \r\n            DevDiv #718115 was triggered by some unusual metadata in a Microsoft reference assembly (Silverlight System.Windows.dll).\r\n            The issue was that a type explicitly implemented the accessors of an interface event, but did not tie them together with\r\n            an event declaration.  To make matters worse, it declared its own protected event with the same name as the interface\r\n            event (presumably to back the explicit implementation).  As a result, when Roslyn was asked to find the implementing member\r\n            for the interface event, it found the protected event and reported an appropriate diagnostic.  Would it should have done\r\n            (and does do now) is recognize that no event associated with the accessors explicitly implementing the interface accessors\r\n            and returned null.\r\n            \r\n            We resolved this issue by introducing a new step into the interface mapping algorithm: after failing to find an explicit\r\n            implementation in a type, but before searching for an implicit implementation in that type, check for an explicit implementation\r\n            of an associated accessor.  If there is such an implementation, then immediately return the associated property or event,\r\n            even if it is null.  That is, never attempt to find an implicit implementation for an interface property or event with an\r\n            explicitly implemented accessor.\r\n            ":"\r\n            由于 dev11 没有公开符号 API，因此它可以接受基类的声明：\r\n            它实现了一个接口。另一方面，Roslyn 需要能够指向一个实现符号\r\n            对于每个接口成员。\r\n            \r\n            DevDiv #718115 是由 Microsoft 参考程序集 (Silverlight System.Windows.dll) 中的一些异常元数据触发的。\r\n            问题是一个类型显式实现了接口事件的访问器，但没有将它们与\r\n            事件声明。更糟糕的是，它声明了自己的受保护事件，与接口同名\r\n            事件（大概是为了支持显式实现）。结果，当罗斯林被要求找到执行成员时\r\n            对于接口事件，它找到了受保护的事件并报告了适当的诊断。它应该做吗\r\n            （现在确实这样做）是认识到没有与显式实现接口访问器的访问器关联的事件\r\n            并返回空值。\r\n            \r\n            我们通过在接口映射算法中引入一个新步骤来解决这个问题：在找不到显式\r\n            类型中的实现，但在搜索该类型中的隐式实现之前，检查显式实现\r\n            关联的访问者。如果有这样的实现，则立即返回关联的属性或事件，\r\n            即使它是空的。也就是说，永远不要尝试为具有\r\n            显式实现的访问器。\r\n            \r\n","\r\n            Gets the type of the storage location that an instance of the pointer type points to, along with its annotations.\r\n            ":"\r\n            获取指针类型实例指向的存储位置及其注释的类型。\r\n            \r\n","\r\n              Looks up a localized string similar to The type parameter '{0}' cannot be used with the 'as' operator because it does not have a class type constraint nor a 'class' constraint.\r\n            ":"\r\n              查找类似于类型参数'{0}'的本地化字符串不能与'as'运算符一起使用，因为它没有类类型约束或“类”约束。\r\n            \r\n","Extension method must be static":"扩展方法必须是静态的\r\n","\r\n              Looks up a localized string similar to A previous catch clause already catches all exceptions of this or of a super type ('{0}').\r\n            ":"\r\n              查找类似于先前捕获子句的本地化字符串已经捕获了此或超级类型（'{0}'）的所有异常。\r\n            \r\n","\r\n            Wrapper methods are created for base access of base type virtual methods from \r\n            other classes (like those created for lambdas...).\r\n            ":"\r\n            创建包装方法是为基本类型虚拟方法的基本访问而创建的\r\n            其他类（例如为Lambdas创建的类...）。\r\n            \r\n","Called when the visitor visits a ForStatementSyntax node.":"当访问者访问forstatementsyntax节点时，请致电。\r\n","\r\n            Gets the constructor used in this application of the attribute as an ":"\r\n            在此应用程序中使用构造函数作为一个\r\n","Class which represents the syntax node for stackalloc array creation expression.":"代表stackalloc数组创建表达式的语法节点的类。\r\n","\r\n            For each scope that defines variables, identifies the nearest enclosing scope that defines variables.\r\n            ":"\r\n            对于定义变量的每个范围，标识定义变量的最近的封闭范围。\r\n            \r\n","\r\n            A representation of a method symbol that is intended only to be used for comparison purposes\r\n            (esp in MethodSignatureComparer).\r\n            ":"\r\n            方法符号的表示，仅用于比较目的\r\n            （ESP在MethodSignatureComparer中）。\r\n            \r\n","Creates a new XmlTextAttributeSyntax instance.":"创建一个新的XMLTEXTATTATTRIBUTESYNTAX实例。\r\n","\r\n              Looks up a localized string similar to Using the generic {1} '{0}' requires {2} type arguments.\r\n            ":"\r\n              查找类似于使用通用{1}'{0}'的本地化字符串。\r\n            \r\n","SyntaxToken representing the dot.":"表示dot的语法。\r\n","\r\n              Looks up a localized string similar to Array size cannot be specified in a variable declaration (try initializing with a 'new' expression).\r\n            ":"\r\n              在变量声明中查找类似于数组大小的本地化字符串（尝试使用“新”表达式初始化）。\r\n            \r\n","\r\n            Syntax for the block of the nested function.\r\n            ":"嵌套函数块的语法。\r\n            \r\n","Invalid output name: {0}":"无效输出名称：{0}\r\n","\r\n              Looks up a localized string similar to Attribute is ignored when public signing is specified..\r\n            ":"\r\n              当指定公共签名时，查找类似于属性的本地化字符串将被忽略。\r\n            \r\n","\r\n            A binder that represents a scope introduced by 'using' namespace or type directives and deals with looking up names in it.\r\n            ":"\r\n            代表“使用”名称空间或键入指令并在其中查找名称的范围的粘合剂。\r\n            \r\n","CLSCompliant attribute has no meaning when applied to parameters":"当应用于参数时，clscompliant属性没有含义\r\n","Skip loading types in analyzer assembly that fail due to a ReflectionTypeLoadException":"在分析仪组件中跳过加载类型，由于反射型peloadexception而失败\r\n","\r\n            Given a cref syntax that cannot be resolved, get the string that will be written to\r\n            the documentation file in place of a documentation comment ID.\r\n            ":"\r\n            给定一个无法解决的Cref语法，将其写入的字符串\r\n            文档文件代替文档注释ID。\r\n            \r\n","\r\n            Used by EnC to create symbols for emit baseline. The PE symbols are used by ":"\r\n            由enc用来为发射基线创建符号。 PE符号由\r\n","\r\n              Looks up a localized string similar to '{2}' must be a non-abstract type with a public parameterless constructor in order to use it as parameter '{1}' in the generic type or method '{0}'.\r\n            ":"\r\n              查找类似于“ {2}”的本地化字符串必须是具有公共参数无构造器的非抽象类型，以便将其用作通用类型或方法'{0}'中的参数'{1}'。\r\n            \r\n","partial":"部分的\r\n","Member overrides base member with multiple override candidates at run-time":"成员在运行时覆盖具有多个覆盖候选人的基本成员\r\n","Public signing was specified and requires a public key, but no public key was specified.":"指定了公共签名，需要公共密钥，但没有指定公共密钥。\r\n","The compilation in which constraints should be checked.\r\n            Should not be null, but if it is null we treat constraints as we would in the latest\r\n            language version.":"应检查约束的汇编。\r\n            不应该为无效，但是如果是无效的话，我们会像最新的那样对待约束\r\n            语言版本。\r\n","\r\n            Specifies the syntax that a user defined variable comes from.\r\n            ":"\r\n            指定用户定义变量来自的语法。\r\n            \r\n"," or the\r\n            thing that it originally overrides, but in a more derived class?\r\n            ":" 或者\r\n            它最初覆盖的东西，但在更派生的阶级中？\r\n            \r\n"," will be accompanied with \r\n            a MethodImpl entry in metadata, information about which isn't already exposed through\r\n            ":" 将伴随\r\n            元数据中的Methodimpl条目，有关该条目尚未通过\r\n            \r\n","The command line switch '{0}' is not yet implemented and was ignored.":"命令行开关'{0}'尚未实现和忽略。\r\n","\r\n              Looks up a localized string similar to Friend access was granted by '{0}', but the strong name signing state of the output assembly does not match that of the granting assembly..\r\n            ":"\r\n              查找类似于朋友访问的本地化字符串由“ {0}”授予，但是输出组件的强名称签名状态与授予程序集的签名不匹配。\r\n            \r\n","Cannot declare namespace in script code":"无法在脚本代码中声明名称空间\r\n","Resource identifier '{0}' has already been used in this assembly":"资源标识符'{0}'已经在此组件中使用\r\n","\r\n              Looks up a localized string similar to Member '{0}' cannot be initialized. It is not a field or property..\r\n            ":"\r\n              查找类似于成员'{0}'的本地化字符串。它不是字段或属性。\r\n            \r\n","Creates a new ParenthesizedExpressionSyntax instance.":"创建一个新的括号expressionsyntax实例。\r\n","\r\n            Represents not nested missing type.\r\n            ":"\r\n            表示不嵌套缺失类型。\r\n            \r\n","A cref syntax node that points to the referenced item (e.g. a class, struct).":"指向引用项目的CREF语法节点（例如类，struct）。\r\n","Improved overload candidates":"改善了超负荷候选人\r\n","\r\n            If the location path is mapped the resulting path is the path specified in the corresponding ":"\r\n            如果映射位置路径，则结果路径是相应的路径\r\n","Provides the base class from which the classes that represent base type syntax nodes are derived. This is an abstract class.":"提供代表基本类型语法节点的类的基类。这是一个抽象类。\r\n","\r\n              Looks up a localized string similar to Parameter '{0}' has no matching param tag in the XML comment for '{1}' (but other parameters do).\r\n            ":"\r\n              查找类似于参数'{0}'的本地化字符串在'{1}'的XML注释中没有匹配的param标签（但是其他参数为）。\r\n            \r\n"," to the inner pattern after stripping off outer\r\n            ":" 脱离外部后的内部图案\r\n            \r\n","Member '{0}' cannot be initialized. It is not a field or property.":"成员'{0}'不能初始化。它不是字段或属性。\r\n","\r\n            The underlying MethodSymbol.\r\n            ":"\r\n            基础方法符号。\r\n            \r\n","\r\n            Unless explicitly declared,  a record includes a synthesized strongly-typed overload\r\n            of `Equals(R? other)` where `R` is the record type.\r\n            The method is `public`, and the method is `virtual` unless the record type is `sealed`.\r\n            ":"\r\n            除非明确宣布，否则记录包括合成的强大超负荷\r\n            `equals（r？other）``r'在哪里记录类型。\r\n            该方法是``public''，除非记录类型为``sealed''，该方法为`virtual'。\r\n            \r\n"," will be invoked.\r\n            If the corresponding predicate returns true for any type,\r\n            traversal stops and that type is returned from this method. Otherwise if traversal\r\n            completes without the predicate returning true for any type, this method returns null.\r\n            ":" 将被调用。\r\n            如果相应的谓词返回任何类型的true，\r\n            遍历停止，该类型是从此方法返回的。否则，如果遍历\r\n            该方法在没有谓词返回的情况下完成，此方法返回null。\r\n            \r\n"," except that it pays attention to custom modifiers and return type.  \r\n            Normally, the return type isn't considered during overriding, but this comparer is actually used to find\r\n            exact matches (i.e. before tie-breaking takes place amongst close matches).\r\n            ":" 除了注意自定义修饰符和返回类型外。\r\n            通常，返回类型在覆盖过程中不考虑，但实际上使用此比较来查找\r\n            确切的匹配（即，在近距离比赛中进行抢七之前进行）。\r\n            \r\n","\r\n            Synthesize a no-argument call to a given method, possibly applying a conversion to the receiver.\r\n            \r\n            If the receiver is of struct type and the method is an interface method, then skip the conversion\r\n            and just call the interface method directly - the code generator will detect this and generate a \r\n            constrained virtual call.\r\n            ":"\r\n            合成对给定方法的无参数调用，可能将转换应用于接收器。\r\n            \r\n            如果接收器是struct类型且方法是接口方法，则跳过转换\r\n            并直接调用接口方法-代码生成器将检测到这一点，并生成一个 \r\n            受约束的虚拟呼叫。\r\n            \r\n","\r\n              Looks up a localized string similar to XML comment has a duplicate param tag.\r\n            ":"\r\n              查找类似于XML注释的本地化字符串具有重复的param标签。\r\n            \r\n","\r\n            The class to represent all method parameters imported from a PE/module.\r\n            ":"\r\n            代表从PE/模块导入的所有方法参数的类。\r\n            \r\n","\r\n            The types that were directly specified as constraints on the type parameter.\r\n            Duplicates and cycles are removed, although the collection may include\r\n            redundant constraints where one constraint is a base type of another.\r\n            ":"\r\n            直接指定为类型参数的约束的类型。\r\n            重复和周期被删除，尽管该收藏可能包括\r\n            冗余约束是一个约束是另一个约束的基本类型。\r\n            \r\n","Variable is declared but never used":"变量被声明但从未使用\r\n","optional parameter":"可选参数\r\n","Base class for type declaration syntax.":"类型声明语法的基类。\r\n","A 'using static' directive cannot be used to declare an alias":"不能使用“使用静态”指令来声明别名\r\n","\r\n              Looks up a localized string similar to '{0}': cannot implement a dynamic interface '{1}'.\r\n            ":"\r\n              查找类似于'{0}'：无法实现动态接口'{1}'的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability in constraints for type parameter doesn't match the constraints for type parameter in implicitly implemented interface method'..\r\n            ":"\r\n              在类型参数的约束中，查找类似于不可限制的本地化字符串与隐式实现的接口方法中的类型参数的约束不匹配。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot create an instance of the static class '{0}'.\r\n            ":"\r\n              查找类似于类似的本地化字符串无法创建静态类'{0}'的实例。\r\n            \r\n","\r\n            A mapping from each state of the state machine to the new state that will be used to execute\r\n            finally blocks in case the state machine is disposed.  The Dispose method computes the new state\r\n            and then runs MoveNext.  Not used if !this.useFinalizerBookkeeping.\r\n            ":"\r\n            从状态机的每个状态到新状态的映射，该状态将用于执行\r\n            最后，如果处置状态机器，则阻止。处理方法计算新状态\r\n            然后运行movenext。如果！\r\n            \r\n","\r\n            Every walker is walking a specific symbol, and can potentially walk each symbol multiple times\r\n            to get to a stable state. Each of these symbols gets a single shared state slot, which this\r\n            dictionary keeps track of. These slots correspond to indexes into ":"\r\n            每个步行者都在走一个特定的符号，并且可能会多次走每个符号\r\n            以达到稳定状态。 这些符号中的每一个都得到一个共享状态槽，这\r\n            字典跟踪. 这些槽对应于索引到 \r\n",".\r\n            Even for lazily-computed values, it may be possible to avoid allocating ":"。\r\n            即使对于懒惰的值，也可能避免分配\r\n"," was constructed from an error symbol based on ":" 是根据基于错误符号构建的\r\n","\r\n              Looks up a localized string similar to Optional parameters must appear after all required parameters.\r\n            ":"\r\n              在所有必需的参数之后，必须出现类似于可选参数的本地化字符串。\r\n            \r\n"," has been added to the queue.\r\n            ":" 已添加到队列中。\r\n            \r\n","The ref kind of the delegate's return, if known. This is only unknown in\r\n            error scenarios, such as a delegate type that has no invoke method.":"如果已知，代表返回的裁判。这仅在\r\n            错误方案，例如没有调用方法的委托类型。\r\n","Type '{0}' is defined in this assembly, but a type forwarder is specified for it":"在此组件中定义了'{0}'的类型，但是为其指定了类型的转发器\r\n","\r\n              Looks up a localized string similar to Code page '{0}' is invalid or not installed.\r\n            ":"\r\n              查找类似于代码页'{0}'的本地化字符串是无效或未安装的。\r\n            \r\n","\r\n            Determines if this Unicode character can be part of an XML Name.\r\n            ":"\r\n            确定此Unicode字符是否可以成为XML名称的一部分。\r\n            \r\n","\r\n            Inform the variables about found types.\r\n            ":"\r\n            告知有关发现类型的变量。\r\n            \r\n","-->":" - >\r\n","\r\n              Looks up a localized string similar to using alias.\r\n            ":"\r\n              查找类似于使用别名的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to A fixed buffer may only have one dimension..\r\n            ":"\r\n              查找类似于固定缓冲区的局部字符串可能只有一个维度。\r\n            \r\n","True if the method was found (still have to verify that the return (i.e. enumerator) type is acceptable).":"如果发现该方法（仍然必须验证返回（即枚举者）类型是可以接受的）。\r\n","\r\n            Set the underlying implementation type for a given fixed-size buffer field.\r\n            ":"\r\n            为给定的固定尺寸缓冲区字段设置基础实现类型。\r\n            \r\n","Class which represents an expression that has an assignment operator.":"代表具有分配运算符的表达式的类。\r\n","'{0}': cannot specify both a constraint class and the 'unmanaged' constraint":"'{0}'：无法指定约束类和'未管理的'约束\r\n","\r\n            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.\r\n            ":"\r\n            如果没有应用属性，则从适用于符号或空的特殊早期绑定的众所周知众所周知的属性解码的返回数据。\r\n            \r\n","element is expected":"预期要元素\r\n","\r\n            Bind argument and verify argument matches rvalue or out param requirements.\r\n            ":"\r\n            绑定参数并验证参数匹配rvalue或输出参数要求。\r\n            \r\n","Inconsistent accessibility: parameter type '{1}' is less accessible than delegate '{0}'":"不一致的可访问性：参数类型'{1}'比委托'{0}'易于访问\r\n","\r\n              Looks up a localized string similar to The type cannot be used as type parameter in the generic type or method. Nullability of type argument doesn't match 'class' constraint..\r\n            ":"\r\n              在通用类型或方法中查找类似于类型的本地化字符串。类型参数的无效性不匹配“类”约束。\r\n            \r\n","__arglist is not allowed in the parameter list of iterators":"__arglist在迭代器的参数列表中不允许\r\n","Named argument specifications must appear after all fixed arguments have been specified. Please use language version {0} or greater to allow non-trailing named arguments.":"指定所有固定参数后，必须出现命名的参数规范。请使用语言版本{0}或更大的内容允许命名为非访问的参数。\r\n","\r\n            SPEC VIOLATION: according to the spec (section 7.19) constant expressions cannot\r\n            include implicit nullable conversions or nullable subexpressions.  However, Dev10\r\n            specifically folds over lifted == and != (see ExpressionBinder::TryFoldingNullableEquality).\r\n            Dev 10 does do compile-time evaluation of simple lifted operators, but it does so\r\n            in a rewriting pass (see NullableRewriter) - they are not treated as constant values.\r\n            ":"\r\n            规范违反：根据规范（第7.19节）常量表达式不能\r\n            包括隐式可空转换或可空子表达式。  然而，Dev10\r\n            特别是折叠在举==和！=（请参阅ExpressionBinder::TryFoldingNullableEquality）。\r\n            Dev10确实对简单的提升运算符进行编译时评估，但它确实如此\r\n            在重写过程中（请参阅NullableRewriter）-它们不会被视为常量值。\r\n            \r\n","\r\n              Looks up a localized string similar to Expressions and statements can only occur in a method body.\r\n            ":"\r\n              查找类似于表达式的局部字符串，只能在方法主体中出现语句。\r\n            \r\n","'{0}' does not implement the '{1}' pattern. '{2}' is ambiguous with '{3}'.":"'{0}'不会实现'{1}'模式。 '{2}'对'{3}'是模棱两可的。\r\n","\r\n              Looks up a localized string similar to Method, operator, or accessor is marked external and has no attributes on it.\r\n            ":"\r\n              查找类似于方法，操作员或访问者的本地化字符串，其标记为外部，并且没有属性。\r\n            \r\n","\r\n            Escapes non-printable characters.\r\n            ":"\r\n            逃脱了不可打印的字符。\r\n            \r\n","\r\n            True if and only if the parameter has a default argument syntax, \r\n            or the parameter is not a params-array and Optional metadata flag is set.\r\n            ":"\r\n            true当且仅当参数具有默认参数语法时，\r\n            否则参数不是参数阵列，并且设置了可选的元数据标志。\r\n            \r\n","Error reading debug information for '{0}'":"错误阅读“ {0}'的调试信息\r\n","Cannot create an instance of the static class '{0}'":"无法创建静态类'{0}'的实例\r\n","Cannot find the interop type that matches the embedded interop type '{0}'. Are you missing an assembly reference?":"找不到与嵌入式Interop类型'{0}'匹配的Interop类型。您是否错过了组装参考？\r\n","\r\n            This binder owns the scope for an embedded statement.\r\n            ":"\r\n            该活页夹拥有嵌入式陈述的范围。\r\n            \r\n","\r\n            and loop over each member; calling ":"\r\n            并在每个成员上循环；打电话\r\n","\r\n            The operation (e.g. Select(), Where(), etc) that implements the given clause.\r\n            ":"\r\n            实现给定子句的操作（例如Select（），where（）等）。\r\n            \r\n","\r\n            The bound node of the method or initializer being analyzed.\r\n            ":"\r\n            分析方法或初始化器的结合节点。\r\n            \r\n","Gets the return type syntax.":"获取返回类型语法。\r\n","\r\n            Returns true if either Thread.ManagedThreadId or Environment.CurrentManagedThreadId are available\r\n            ":"\r\n            如果thread.managedthreadid或emoverition.currentManagedThreadID可用，则返回true。\r\n            \r\n","Gets the optional body block which may be empty, but it is null if there are no braces.":"获取可能为空的可选车身块，但是如果没有牙套，则是无效的。\r\n","\r\n            When C# interface implementation differs from CLR interface implementation,\r\n            we insert a synthesized explicit interface implementation that delegates\r\n            to the method that C# considers an implicit implementation.\r\n            There are two key scenarios for this:\r\n            1) A single source method is implicitly implementing one or more interface\r\n               methods from metadata and the interface methods have different custom\r\n               modifiers.  In this case, we explicitly implement the interface methods\r\n               and have (all) implementations delegate to the source method.\r\n            2) A non-virtual, non-source method in a base type is implicitly implementing\r\n               an interface method.  Since we can't change the \"virtualness\" of the \r\n               non-source method, we introduce an explicit implementation that delegates\r\n               to it instead.\r\n            ":"\r\n            当C＃接口实现与CLR接口实现不同时，\r\n            我们插入合成的显式接口实现，以委派\r\n            对于C＃考虑隐式实现的方法。\r\n            有两个关键方案：\r\n            1）单个源方法正在隐式实现一个或多个接口\r\n               元数据和接口方法的方法具有不同的自定义\r\n               修饰符。在这种情况下，我们明确实现接口方法\r\n               并将（所有）实现委派给源方法。\r\n            2）基本类型中的一种非虚拟的非源方法正在隐式实施\r\n               接口方法。因为我们无法改变\r\n               非源方法，我们引入了一个明确的实施，该实施\r\n               而是。\r\n            \r\n","\r\n            Represents a new change being processed by ":"\r\n            代表正在处理的新更改\r\n","\r\n            TODO(https://github.com/dotnet/roslyn/projects/26): Delete this.\r\n            This should only be used by ":"\r\n            todo（https://github.com/dotnet/roslyn/projects/26）：删除此。\r\n            这只能由\r\n","True if seeing the ErrorCode should prevent a delegate conversion\r\n            from completing successfully.":"如果看到错误代码应防止委托转换\r\n            从成功完成。\r\n","\r\n            Emits receiver in a form that allows member accesses ( O or & ). For verifiably\r\n            reference types it is the actual reference. For generic types it is a address of the\r\n            receiver with readonly intent. For the value types it is an address of the receiver.\r\n            \r\n            isAccessConstrained indicates that receiver is a target of a constrained callvirt\r\n            in such case it is unnecessary to box a receiver that is typed to a type parameter\r\n            \r\n            May introduce a temp which it will return. (otherwise returns null)\r\n            ":"\r\n            以允许成员访问（O或＆）的形式发射接收器。为了验证\r\n            参考类型是实际参考。对于通用类型，它是\r\n            接收器具有可读意图。对于值类型，它是接收器的地址。\r\n            \r\n            ISACCESSCONDENS表示接收器是受约束CallVirt的目标\r\n            在这种情况下，不需要键入输入到类型参数的接收器\r\n            \r\n            可能会引入将返回的温度。 （否则返回null）\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': cannot explicitly call operator or accessor.\r\n            ":"\r\n              查找类似于'{0}'：无法明确调用操作员或登录器的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to The 'this' object cannot be used before all of its fields are assigned to.\r\n            ":"\r\n              在将所有字段分配给其所有字段之前，都无法使用类似于“此”对象的本地化字符串。\r\n            \r\n"," is a special kind of ":" 是一种特殊的\r\n","SecurityAction value '{0}' is invalid for security attributes applied to a type or a method":"SecurityAction值'{0}'对应用于类型或方法的安全属性无效\r\n","\r\n              Looks up a localized string similar to A local variable or function named '{0}' is already defined in this scope.\r\n            ":"\r\n              在此范围中已经定义了类似于名为“ {0}”的本地变量或函数的本地化字符串。\r\n            \r\n","\r\n            Backing field for field-like event. Will be null if the event\r\n            has no initializer and is either extern or inside an interface.\r\n            ":"\r\n            类似现场活动的背景场。如果事件将无效\r\n            没有初始化器，是外部或界面内部的。\r\n            \r\n","\r\n              Looks up a localized string similar to expression-bodied indexer.\r\n            ":"\r\n              查找类似于表达式索引器的局部字符串。\r\n            \r\n","\r\n            Options to control the internal working of GetSymbolInfoWorker. Not currently exposed\r\n            to public clients, but could be if desired.\r\n            ":"\r\n            控制GetSymbolinFoworker的内部工作的选项。目前未暴露\r\n            给公共客户，但如果需要的话。\r\n            \r\n","\r\n            Add this instance to the set of checked types. Returns true\r\n            if this was added, false if the type was already in the set.\r\n            ":"\r\n            将此实例添加到一组检查类型中。返回真实\r\n            如果添加了此功能，如果该类型已经在集合中，则为false。\r\n            \r\n","\r\n            Type is not annotated - string, int, T (including the case when T is unconstrained).\r\n            ":"\r\n            类型未注释 - 字符串，int，t（包括无约束的情况时）。\r\n            \r\n","\r\n            A syntax node corresponding to the invocation.\r\n            ":"\r\n            与调用相对应的语法节点。\r\n            \r\n"," means the context is 'restore' or not specified.\r\n            ":" 表示上下文是“还原”或未指定的。\r\n            \r\n","Creates a new BlockSyntax instance.":"创建一个新的blocksyntax实例。\r\n","Creates a new FromClauseSyntax instance.":"创建一个来自Clrosusesyntax实例的新的。\r\n","\r\n            This pass detects and reports diagnostics that do not affect lambda convertibility.\r\n            This part of the partial class focuses on features that cannot be used in expression trees.\r\n            CAVEAT: Errors may be produced for ObsoleteAttribute, but such errors don't affect lambda convertibility.\r\n            ":"\r\n            此通行证检测和报告不影响Lambda可转换性的诊断。\r\n            部分类别的这一部分着重于无法在表达树中使用的功能。\r\n            警告：可能会出现错误的错误，但此类错误不会影响Lambda的可转换性。\r\n            \r\n","\r\n            The candidate member was rejected because there were two named arguments with the same parameter name.\r\n            ":"\r\n            候选人成员被拒绝，因为有两个具有相同参数名称的命名参数。\r\n            \r\n","\r\n            Changes in this function around member parsing should be mirrored in ":"\r\n            该功能围绕成员解析的变化应在\r\n"," nodes corresponding to a given method.\r\n            ":" 与给定方法相对应的节点。\r\n            \r\n","\r\n              Looks up a localized string similar to Predefined type '{0}' is declared in multiple referenced assemblies: '{1}' and '{2}'.\r\n            ":"\r\n              在多个引用的汇编中声明类似于预定义的类型'{0}'的本地化字符串：'{1}'和'{2}'。\r\n            \r\n","\r\n            Gets a PatternSyntax that represents the pattern that gets matched for the case label.\r\n            ":"\r\n            获取一个代表CASE标签匹配的模式的patternsyntax。\r\n            \r\n","\r\n              Looks up a localized string similar to Referenced assembly targets a different processor.\r\n            ":"\r\n              查找类似于引用的汇编目标的本地化字符串。\r\n            \r\n","\r\n            Returns true if a node is in a tree location that is expected to be either a namespace or type\r\n            ":"\r\n            如果节点位于树的位置，则返回true\r\n            \r\n","'{0}': new protected member declared in sealed type":"'{0}'：新受保护的成员以密封类型声明\r\n","\r\n            Override the dynamic operation context type for all dynamic calls in the module.\r\n            ":"\r\n            覆盖模块中所有动态调用的动态操作上下文类型。\r\n            \r\n","\r\n            Walk down tuple literals and replace all the side-effecting elements that need saving with temps.\r\n            Expressions that are not tuple literals need saving, as are tuple literals that are involved in\r\n            a simple comparison rather than a tuple comparison.\r\n            ":"\r\n            向下走元组文字，并替换所有需要节省温度的副作用元素。\r\n            不是元组文字需要节省的表达，涉及的元组文字也是如此\r\n            简单的比较而不是元组比较。\r\n            \r\n","\r\n            This method handles unix and windows drive rooted absolute paths only (i.e /a/b or x:\\a\\b). Passing any other kind of path\r\n            including relative, drive relative, unc, or windows device paths will simply return the original input. \r\n            ":"\r\n            此方法仅处理UNIX和Windows驱动器根源的绝对路径（即 /a /b或x：\\ a \\ b）。通过任何其他道路\r\n            包括亲戚，驱动器相对，UNC或Windows设备路径将简单地返回原始输入。\r\n            \r\n","\r\n            Encapsulates information about the non-type members of a (i.e. this) type.\r\n              1) For non-initializers, symbols are created and stored in a list.\r\n              2) For fields and properties/indexers, the symbols are stored in (1) and their initializers are\r\n                 stored with other initialized fields and properties from the same syntax tree with\r\n                 the same static-ness.\r\n            ":"\r\n            封装有关A（即此）类型的非类型成员的信息。\r\n              1）对于非初始化器，创建并存储在列表中。\r\n              2）对于字段和属性/索引器，符号存储在（1）中，其初始化器为\r\n                 与来自同一语法树的其他初始化字段和属性一起存储\r\n                 相同的静态。\r\n            \r\n","\r\n              Looks up a localized string similar to \"Invalid rank specifier: expected ']'.\r\n            ":"\r\n              查找类似于“无效等级规范符：预期']”的本地化字符串。\r\n            \r\n","\r\n            Generally ":"\r\n            一般来说\r\n","\r\n              Looks up a localized string similar to Cannot apply indexing with [] to an expression of type '{0}'.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法将索引与[]应用于类型'{0}'的表达式。\r\n            \r\n","\r\n            Gets the number of dimensions of the array. A regular single-dimensional array\r\n            has rank 1, a two-dimensional array has rank 2, etc.\r\n            ":"\r\n            获取数组尺寸的数量。常规的单维阵列\r\n            有等级1，二维阵列的等级为2，等等。\r\n            \r\n","Creates a new ImplicitStackAllocArrayCreationExpressionSyntax instance.":"创建一个新的intimitStackallocarcaryCreationexpressynntax实例。\r\n","Called when the visitor visits a ParameterListSyntax node.":"当访问者访问参数名单的nondax节点时，请致电。\r\n","InitializerExpressionSyntax node representing the initializer of the array creation expression.":"initializerexpressionsyntax节点表示数组创建表达式的初始化器。\r\n","\r\n            Gets deconstruction foreach info.\r\n            ":"\r\n            获取for for for for foreach信息。\r\n            \r\n","\r\n            The name (contains extension)\r\n            ":"\r\n            名称（包含扩展名）\r\n            \r\n","\r\n              Looks up a localized string similar to Since '{0}' returns void, a return keyword must not be followed by an object expression.\r\n            ":"\r\n              查找类似于“ {0}”返回void的本地化字符串，返回关键字不得跟随对象表达式。\r\n            \r\n","out variable declaration":"输出可变声明\r\n","Identifier expected":"标识符预期\r\n","\r\n            Specifies the language version.\r\n            ":"\r\n            指定语言版本。\r\n            \r\n","\r\n              Looks up a localized string similar to Location must be provided in order to provide minimal type qualification..\r\n            ":"\r\n              查找与位置类似的本地化字符串，以提供最小的类型资格。\r\n            \r\n","\r\n            Holds infrequently accessed fields. See ":"\r\n            持有很少访问的字段。看\r\n","\r\n            A base class for synthesized methods that want a this parameter.\r\n            ":"\r\n            需要此参数的合成方法的基类。\r\n            \r\n","\r\n            The map that captures information about what assembly should be retargeted \r\n            to what assembly. Key is the AssemblySymbol referenced by the underlying module,\r\n            value is the corresponding AssemblySymbol referenced by the retargeting module, and \r\n            corresponding retargeting map for symbols.\r\n            ":"\r\n            捕获有关应该重新定位哪个组件的信息的地图\r\n            到什么组装。关键是基础模块引用的汇编符号\r\n            值是重新定位模块引用的相应汇编符号，和\r\n            符号的相应重新定位地图。\r\n            \r\n",",\r\n            which must be a named type or an assembly.\r\n            ":"，，，，\r\n            必须是命名类型或组件。\r\n            \r\n","\r\n            to minimize diagnostics.\r\n            ":"\r\n            最大程度地减少诊断。\r\n            \r\n","'{0}' is obsolete":"'{0}'是过时的\r\n"," false. A subsequent call\r\n               is guaranteed to return the same result regardless of ":" 错误的。随后的电话\r\n               无论如何，都可以保证返回相同的结果\r\n","ExpressionSyntax node representing the expression which is accessing the element.":"表示访问该元素的表达式的表达式节点。\r\n","\r\n            Gets the root node of the syntax tree if it is already available.\r\n            ":"\r\n            如果已经可用，则获取语法树的根节点。\r\n            \r\n","\r\n            Return the name including the metadata arity suffix.\r\n            ":"\r\n            返回名称，包括元数据。\r\n            \r\n","Creates a new XmlTextSyntax instance.":"创建一个新的XMLTEXTSYNTAX实例。\r\n","\r\n            Add sequence point |here|:\r\n            \r\n            |foreach| (Type var in expr) { }\r\n            ":"\r\n            添加序列点/这里|:\r\n            \r\n            /foreach/（expr中的var类型）{}\r\n            \r\n","\r\n            Look for gotos without corresponding labels in the lowered body of a fixed statement.\r\n            ":"\r\n            在固定语句的降低体中查找没有相应标签的GOTO。\r\n            \r\n","A base class is required for a 'base' reference":"“基础”参考需要基础类\r\n","Suppress the following diagnostics to disable this analyzer: {0}":"抑制以下诊断以禁用此分析仪：{0}\r\n","SyntaxToken representing dot.":"Syntaxtoken代表点。\r\n","\r\n            Return Accessibility declared locally on the accessor, or\r\n            NotApplicable if no accessibility was declared explicitly.\r\n            ":"\r\n            返回可访问性在登录机上本地声明，或\r\n            如果没有明确声明无访问性，则无关紧要。\r\n            \r\n","Security attribute '{0}' is not valid on this declaration type. Security attributes are only valid on assembly, type and method declarations.":"安全属性'{0}'在此声明类型上无效。安全属性仅对汇编，类型和方法声明有效。\r\n","\r\n            Returns whether this method is async and returns a generic task, task-like, or other type with a method-level builder.\r\n            ":"\r\n            返回该方法是异步，并使用方法级构建器返回一般任务，类似于任务或其他类型。\r\n            \r\n","\r\n              Looks up a localized string similar to Type '{0}' exported from module '{1}' conflicts with type '{2}' exported from module '{3}'..\r\n            ":"\r\n              查找类似于从模块'{1}'导出的类型“ {0}”类型的本地化字符串与从模块'{3}的导出的类型'{2}'相冲突。\r\n            \r\n","\r\n            Returns true if the node is the alias of an AliasQualifiedNameSyntax\r\n            ":"\r\n            如果节点是AliasqualifiedNamesyntax的别名，则返回true\r\n            \r\n",",\r\n            is to start with an empty decision tree, and for each case\r\n            we visit the decision tree to see if the case is subsumed. If it is, we report an error.\r\n            If it is not subsumed and there is no guard expression, we then add it to the decision\r\n            tree.\r\n            ":"，，，，\r\n            是从一个空的决策树开始，对于每种情况\r\n            我们访问决策树，以查看案件是否包含。如果是这样，我们报告错误。\r\n            如果不包含并且没有守卫表达式，我们然后将其添加到决定中\r\n            树。\r\n            \r\n"," returns the instance itself.\r\n            ":" 返回实例本身。\r\n            \r\n","\r\n            Check if the variable is captured and, if so, add it to this._capturedVariables.\r\n            ":"\r\n            检查是否捕获了变量，并将其添加到此。_capturedVariables。\r\n            \r\n","\r\n              Looks up a localized string similar to The type name '{0}' does not exist in the type '{1}'.\r\n            ":"\r\n              查找类似于类型名称'{0}'类型的本地化字符串，在类型'{1}'中不存在。\r\n            \r\n","\r\n            True if the symbol is definitely obsolete.\r\n            False if the symbol is definitely not obsolete.\r\n            Unknown if the symbol may be obsolete.\r\n            \r\n            NOTE: The return value reflects obsolete-ness, not whether or not the diagnostic was reported.\r\n            ":"\r\n            如果符号绝对过时，则是真的。\r\n            假，如果符号绝对不淘汰。\r\n            未知符号是否可能已过时。\r\n            \r\n            注意：回报值反映了过时的性质，而不是报告诊断。\r\n            \r\n","\r\n              Looks up a localized string similar to Keyword 'base' is not available in the current context.\r\n            ":"在当前上下文中查找类似于关键字“基础”的本地化字符串。\r\n            \r\n","\r\n            All bits involved into describing various aspects of 'class' constraint. \r\n            ":"\r\n            描述“班级”约束的各个方面所涉及的所有位。\r\n            \r\n","Represents an else statement syntax.":"代表另一个语句语法。\r\n","\r\n            Member declarations that can appear in global code (other than type declarations).\r\n            ":"\r\n            可以在全球代码（类型声明之外）中出现的成员声明。\r\n            \r\n","\r\n            The actual text of this token.\r\n            ":"\r\n            这个令牌的实际文本。\r\n            \r\n","\r\n            Fix a TypeWithAnnotations based on Maybe/NotNull annotations prior to a conversion or assignment.\r\n            Note this does not work for nullable value types, so an additional check with ":"\r\n            在转换或分配之前，基于可能的/notnull注释修复了打字机。\r\n            请注意，这对无效的价值类型不起作用，因此请与\r\n"," if there are none.":" 如果没有。\r\n","\r\n            The class that represents a translated async method.\r\n            ":"\r\n            代表翻译的异步方法的类。\r\n            \r\n","Class which represents the syntax node for the variable declaration in an out var declaration or a deconstruction declaration.":"代表OUT VAR声明或解构声明中变量声明的语法节点的类。\r\n","\r\n            Specialized PENamedTypeSymbol for types with type parameters in metadata.\r\n            NOTE: the type may have Arity == 0 if it has same metadata arity as the metadata arity of the containing type.\r\n            ":"\r\n            元数据中具有类型参数的类型的专用PenamedTypesymbol。\r\n            注意：如果类型具有与包含类型的元数据相同的元数据，则可能具有Arity == 0。\r\n            \r\n","Creates a new RecordDeclarationSyntax instance.":"创建一个新的record -declarationsyntax实例。\r\n","Called when the visitor visits a FinallyClauseSyntax node.":"当访问者访问最终Clairesyntax节点时，请致电。\r\n","\r\n            Lookup well-known member declaration in provided type and reports diagnostics.\r\n            ":"\r\n            查找中著名的成员声明中提供的类型和报告诊断。\r\n            \r\n","\r\n            Map from a target-typed conditional expression (such as a target-typed conditional or switch) to the nullable state on each branch. This\r\n            is then used by VisitConversion to properly set the state before each branch when visiting a conversion applied to such a construct. These\r\n            states will be the state after visiting the underlying arm value, but before visiting the conversion on top of the arm value.\r\n            ":"\r\n            从目标型的条件表达式（例如目标型有条件或开关）映射到每个分支上的无效状态。这个\r\n            然后，visitConversion使用将转换应用于这种构造时，将每个分支的状态正确设置在每个分支之前。这些\r\n            在访问下面的臂值之后，但在访问臂值之上的转换之前，各州将是状态。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot modify the return value of '{0}' because it is not a variable.\r\n            ":"\r\n              查找类似于类似的本地化字符串无法修改“ {0}”的返回值，因为它不是变量。\r\n            \r\n","\r\n            These indices correspond to the merged assembly attributes from source and added net modules, i.e. attributes returned by ":"\r\n            这些索引对应于来自源的合并汇编属性，并添加了净模块，即返回的属性\r\n","\r\n            Process tempStores and add them as side-effects to arguments where needed. The return\r\n            value tells how many temps are actually needed. For unnecessary temps the corresponding\r\n            temp store will be cleared.\r\n            ":"\r\n            处理tempstores并将其添加为需要的副作用，以便在需要的情况下。回报\r\n            值告诉实际需要多少个温度。对于不必要的温度相应\r\n            临时商店将被清除。\r\n            \r\n","\r\n            Replaces references to underlying type with references to native integer type.\r\n            ":"\r\n            用引用本机整数类型替换对基础类型的引用。\r\n            \r\n"," \r\n            Features: async.\r\n            ":" \r\n            功能：异步。\r\n            \r\n","The expression to perform pattern lookup on":"执行图案查找的表达式\r\n","\r\n            C# language version 7.3\r\n            ":"\r\n            C＃语言版本7.3\r\n            \r\n","\r\n            This is for when we are dotting into a field.\r\n            Distinguish from ":"\r\n            这是为了当我们进入一个领域时。\r\n            与众不同\r\n","\r\n            Returns true if the parameter is semantically optional.\r\n            ":"\r\n            如果参数在语义上是可选的，则返回true。\r\n            \r\n","\r\n            If the using directive is an error because it attempts to introduce an alias for which an existing alias was\r\n            previously declared in the same scope, the result is a newly-constructed AliasSymbol (i.e. not one from the\r\n            symbol table).\r\n            ":"\r\n            如果使用指令是错误，因为它试图引入一个现有别名为的别名\r\n            以前在同一范围中声明的结果是新结构的别名符号（即，不是一个\r\n            符号表）。\r\n            \r\n","The name of the empty xml element.":"空XML元素的名称。\r\n","\r\n            Gets deconstruction assignment info.\r\n            ":"\r\n            获取解构分配信息。\r\n            \r\n"," with no known type, and the given bound child.\r\n            ":" 没有已知类型，也没有给定的孩子。\r\n            \r\n"," that represents\r\n            an assembly that is not missing, i.e. the \"real\" thing.\r\n            ":" 代表\r\n            一个不丢失的集会，即“真实”的东西。\r\n            \r\n","\r\n              Looks up a localized string similar to An expression tree lambda may not contain an out or ref parameter.\r\n            ":"\r\n              查找类似于表达树lambda的本地化字符串可能不包含外部或参数。\r\n            \r\n","\r\n            Create a bound node factory. Note that the use of the factory to get special or well-known members\r\n            that do not exist will result in an exception of type ":"\r\n            创建一个绑定的节点工厂。请注意，使用工厂获得特殊或知名会员\r\n            不存在的将导致类型除外\r\n","\r\n            Represents various options that affect compilation, such as \r\n            whether to emit an executable or a library, whether to optimize\r\n            generated code, and so on.\r\n            ":"\r\n            代表影响汇编的各种选项，例如\r\n            是散发可执行文件还是库，是否优化\r\n            生成的代码等等。\r\n            \r\n","\r\n            Encapsulates information about the non-type members of a (i.e. this) type.\r\n              1) For non-initializers, symbols are created and stored in a list.\r\n              2) For fields and properties, the symbols are stored in (1) and their initializers are\r\n                 stored with other initialized fields and properties from the same syntax tree with\r\n                 the same static-ness.\r\n              3) For indexers, syntax (weak) references are stored for later binding.\r\n            ":"\r\n            封装有关A（即此）类型的非类型成员的信息。\r\n              1）对于非初始化器，创建并存储在列表中。\r\n              2）对于字段和属性，符号存储在（1）中，其初始化器为\r\n                 与来自同一语法树的其他初始化字段和属性一起存储\r\n                 相同的静态。\r\n              3）对于索引器，语法（弱）引用存储以供以后结合。\r\n            \r\n","\r\n            then the provided expression should be a ":"\r\n            那么提供的表达应该是\r\n","Reference to type '{0}' claims it is defined in '{1}', but it could not be found":"引用类型'{0}'声明是在'{1}'中定义的，但找不到它\r\n","The compiler options to use.":"使用的编译器选项。\r\n","\r\n            Used for example for event accessors. The \"remove\" method delegates attribute binding to the \"add\" method. \r\n            The bound attribute data are then applied to both accessors.\r\n            ":"\r\n            例如，用于事件访问者。 “删除”方法委托属性绑定到“添加”方法。\r\n            然后将界限数据应用于两个登录器。\r\n            \r\n"," absent from this dictionary means that all values of the type are possible.\r\n            ":" 该词典不存在意味着类型的所有值都是可能的。\r\n            \r\n","Module '{0}' in assembly '{1}' is forwarding the type '{2}' to multiple assemblies: '{3}' and '{4}'.":"Module'{0}'在汇编'{1}'中将类型'{2}'转发到多个汇编：'{3}'和'{4}'。\r\n","Creates a new PrimaryConstructorBaseTypeSyntax instance.":"创建一个新的primalyConstructorbasetypesyntax实例。\r\n","\r\n            Virtual dispatch based on a symbol's particular class. \r\n            ":"\r\n            基于符号的特定类的虚拟调度。\r\n            \r\n"," open after the ":" 在之后打开\r\n","auto property initializer":"自动属性初始化器\r\n","\r\n            Implicit and explicit user-defined conversions are described in section 6.4 of the C# language specification.\r\n            ":"\r\n            在C＃语言规范的第6.4节中描述了隐式和明确的用户定义转换。\r\n            \r\n","\r\n            There is some similarity between this member and TypeSymbol.FindPotentialImplicitImplementationMethodDeclaredInType.\r\n            When making changes to this member, think about whether or not they should also be applied in TypeSymbol.\r\n            \r\n            In incorrect or imported code, it is possible that both currTypeBestMatch and hiddenBuilder will be populated.\r\n            ":"该成员和typesymbol之间存在一些相似之处。findPotentiMplicerImplementationMethodDeclaredIntype。\r\n            在更改该成员时，请考虑是否也应将其应用于Typesymbol。\r\n            \r\n            在不正确或导入的代码中，CurrTypebestMatch和HiddenBuilder可能会被填充。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' is a binary file instead of a text file.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串是一个二进制文件，而不是文本文件。\r\n            \r\n","An expression tree may not contain a tuple literal.":"表达树可能不包含元组文字。\r\n","\r\n              Looks up a localized string similar to '{0}': static constructor cannot have an explicit 'this' or 'base' constructor call.\r\n            ":"\r\n              查找类似于“ {0}'：静态构造器的局部字符串，不能具有显式'this'或'base'构造器调用。\r\n            \r\n","\r\n            Any special attributes we may be referencing directly through a global using alias in the file.\r\n            ":"\r\n            任何特殊属性我们都可以通过文件中的别名直接通过全局引用。\r\n            \r\n"," contains any named constructor arguments or default value arguments,\r\n            it returns an array representing each argument's source argument index. A value of -1 indicates default value argument.\r\n            Otherwise, returns null.\r\n            ":" 包含任何命名的构造函数参数或默认值参数，\r\n            它返回一个代表每个参数的源参数索引的数组。 -1的值表示默认值参数。\r\n            否则，返回null。\r\n            \r\n","Comma separating the arguments.":"逗号分开论点。\r\n","\r\n            Shared walker states are the parts of the walker state that are not unique at a single position,\r\n            but are instead used by all snapshots. Each shared state corresponds to one invocation of Analyze,\r\n            so entering a lambda or local function will create a new state here. The indexes in this array\r\n            correspond to ":"\r\n            共享的沃克州是沃克州的一部分，在一个位置上并非唯一，\r\n            但是，所有快照都使用。每个共享状态对应于一个分析的调用，\r\n            因此，输入lambda或本地功能将在这里创建一个新状态。此数组中的索引\r\n            相当于\r\n","Visual C# Compiler Options\r\n            \r\n                                   - OUTPUT FILES -\r\n            -out:<file>                   Specify output file name (default: base name of\r\n                                          file with main class or first file)\r\n            -target:exe                   Build a consol ...":"视觉C＃编译器选项\r\n            \r\n                                    - 输出文件 - \r\n            -out：<file>指定输出文件名称（默认值：\r\n                                          带有主类或第一个文件的文件）\r\n            -target：exe建立一个consol ...\r\n","\r\n            A small cache for remembering empty struct types for flow analysis.\r\n            ":"\r\n            用于记住空结构类型的小缓存用于流程分析。\r\n            \r\n","The syntax node that declares a method.":"声明方法的语法节点。\r\n","Module name '{0}' stored in '{1}' must match its filename.":"存储在'{1}'中的模块名称'{0}'必须匹配其文件名。\r\n","Creates a new LockStatementSyntax instance.":"创建一个新的lockstatementsyntax实例。\r\n","\r\n              Looks up a localized string similar to Members of readonly field '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type.\r\n            ":"\r\n              查找类似于ReadOnly字段'{1}'的ReadOnly字段'{0}'的局部字符串，因为它是一个值类型，因此无法使用对象初始化器分配。\r\n            \r\n","\r\n            A helper method for ReferenceManager to set AssemblySymbols for assemblies \r\n            referenced by this module.\r\n            ":"\r\n            引用meanager的辅助方法，以设置组件的汇编符号\r\n            该模块引用。\r\n            \r\n",". And the process of looking up an implementation for a property can\r\n            involve figuring out how corresponding accessors are implemented, ":"。查找财产实施的过程可以\r\n            涉及弄清楚如何实现相应的访问者，\r\n","Check the accessibility of this type (probably a parameter or return type).":"检查此类型的可访问性（可能是参数或返回类型）。\r\n","\r\n            Returns true if there are any nullable directives that enable annotations, warnings, or both.\r\n            This does not include any restore directives.\r\n            ":"如果有任何可取消指令可以启用注释，警告或两者兼而有之，则返回。\r\n            这不包括任何还原指令。\r\n            \r\n","SyntaxToken representing whether the calling convention is managed or unmanaged.":"语法代表呼叫惯例是管理还是不受管理。\r\n","The index value from the start.":"索引值从开始。\r\n","\r\n            The declaring syntax for the accessor, or property if there is no accessor-specific\r\n            syntax.\r\n            ":"\r\n            如果没有特定于访问者的话，访问者的声明语法或属性\r\n            句法。\r\n            \r\n","\r\n              Looks up a localized string similar to Attribute '{0}' from module '{1}' will be ignored in favor of the instance appearing in source.\r\n            ":"\r\n              从模块'{1}'查找类似于属性'{0}'的本地化字符串将被忽略，而有利于出现在源中的实例。\r\n            \r\n","\r\n            Check constraints of generic types referenced in constraint types. For instance,\r\n            with \"interface I<T> where T : I<T> {}\", check T satisfies constraints\r\n            on I<T>. Those constraints are not checked when binding ConstraintTypes\r\n            since ConstraintTypes has not been set on I<T> at that point.\r\n            ":"\r\n            检查约束类型中引用的通用类型的约束。例如，\r\n            使用“接口i <t>其中t：i <t> {}”，检查t满足约束\r\n            在i <t>上。绑定约束类型时未检查这些约束\r\n            由于尚未在I <t>上设置约束类型。\r\n            \r\n","\r\n              Looks up a localized string similar to A parameter can only have one '{0}' modifier.\r\n            ":"\r\n              查找类似于参数的本地化字符串只能具有一个'{0}'修饰符。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串不需要CLSCompliant属性，因为汇编没有CLSCompliant属性。\r\n            \r\n","\r\n            (null TypeParameterSymbol \"parameter\"): Checks if the given type is a type parameter \r\n            or its referent type is a type parameter (array/pointer) or contains a type parameter (aggregate type)\r\n            (non-null TypeParameterSymbol \"parameter\"): above + also checks if the type parameter\r\n            is the same as \"parameter\"\r\n            ":"\r\n            （null typeparametersymbol“参数”）：检查给定类型是否是类型参数\r\n            或其参考类型是类型参数（数组/指针）或包含类型参数（聚合类型）\r\n            （非肺结核typeparametersymbol“参数”）：上面 +还检查类型参数是否\r\n            与“参数”相同\r\n            \r\n","\r\n            Creates a separated list of nodes from a sequence of nodes and a sequence of separator tokens.\r\n            ":"\r\n            从一系列节点和一系列分离器令牌中创建一个分离的节点列表。\r\n            \r\n","compilation":"汇编\r\n","\r\n            A binder that places method type parameters in scope.\r\n            ":"\r\n            将方法类型参数放在范围中的粘合剂。\r\n            \r\n","'{0}': static types cannot be used as return types":"'{0}'：静态类型不能用作返回类型\r\n","Cannot yield in the body of a finally clause":"无法在最后条款的正文中屈服\r\n","\r\n            Returns the original syntax nodes for this type declaration across all its parts.  If\r\n            ":"\r\n            返回此类型声明的原始语法节点在其所有部分中声明。如果\r\n            \r\n","The trivia list to normalize.":"琐事列表要归一化。\r\n","\r\n            Compute the nesting depth of a given block.\r\n            Top-most block (where method locals and parameters are defined) are at the depth 0.\r\n            ":"\r\n            计算给定块的嵌套深度。\r\n            最高的块（定义了当地的方法和参数）在深度0。\r\n            \r\n","MoveNext()":"movenext（）\r\n","\r\n            Compiler should always be synthesizing locals with correct escape semantics.\r\n            Checking escape scopes is not valid here.\r\n            ":"编译器应始终用正确的逃生语义合成当地人。\r\n            检查逃生示波器在这里无效。\r\n            \r\n"," objects are equal and false otherwise.\r\n            ":" 对象是平等的，否则是错误的。\r\n            \r\n","\r\n            Open a file and ensure common exception types are wrapped to ":"\r\n            打开文件并确保将常见的异常类型包装到\r\n","Use of possibly unassigned auto-implemented property":"使用可能未分配的自动实施属性\r\n","\r\n              Looks up a localized string similar to ref and out are not valid in this context.\r\n            ":"\r\n              在此上下文中查找类似于REF的本地化字符串，而OUT则无效。\r\n            \r\n","\r\n            Return the boolean expression to be evaluated for the given test. Returns `null` if the test is trivially true.\r\n            ":"返回布尔表达式以评估给定测试。如果测试在微不足道上为真，则返回`null`。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': event in interface cannot have initializer.\r\n            ":"\r\n              查找类似于'{0}'：接口中的事件类似的本地化字符串。\r\n            \r\n","A character position used to identify a declaration scope and accessibility. This\r\n            character position must be within the FullSpan of the Root syntax node in this SemanticModel and must be\r\n            within the FullSpan of a Method body within the Root syntax node.":"用于标识声明范围和可访问性的角色位置。这个\r\n            字符位置必须在此语法模型中的root语法节点的成面内，必须为\r\n            在根语法节点内的方法主体的成面内。\r\n","\r\n            Gets a SyntaxToken that represents the case or default keywords if any exists.\r\n            ":"\r\n            获取一个语法，该语法代表情况或默认关键字（如果存在）。\r\n            \r\n","\r\n              Looks up a localized string similar to Possible null reference argument..\r\n            ":"\r\n              查找类似于可能的null参考参数的本地化字符串。\r\n            \r\n"," to speed up type reference resolution\r\n            for metadata coming from this module. The map is lazily populated\r\n            by ":" 加快类型参考分辨率\r\n            对于来自该模块的元数据。该地图懒洋洋\r\n            经过\r\n","\r\n            Implicit anonymous function conversions are described in section 6.5 of the C# language specification.\r\n            ":"\r\n            隐式匿名函数转换在C＃语言规范的第6.5节中描述。\r\n            \r\n","If an original form of a type constraint \r\n            depends on a type parameter from this set, do not verify this type constraint.":"如果是类型约束的原始形式\r\n            取决于此集合中的类型参数，请勿验证此类型约束。\r\n","Creates a new UndefDirectiveTriviaSyntax instance.":"创建一个新的undectirectivtriviasyntax实例。\r\n","Default values are not valid in this context.":"在此上下文中，默认值无效。\r\n","\r\n              Looks up a localized string similar to The referenced file '{0}' is not an assembly.\r\n            ":"查找类似于引用文件'{0}'的本地化字符串不是组件。\r\n            \r\n","\r\n            RetargetingAssemblySymbol owning retargetingModule.\r\n            ":"\r\n            retargetingAssemblysymbol拥有retargetingModule。\r\n            \r\n","\r\n              Looks up a localized string similar to The operator '{0}' requires a matching operator '{1}' to also be defined.\r\n            ":"\r\n              查找类似于操作员'{0}'的本地化字符串，也需要一个匹配的操作员'{1}'才能被定义。\r\n            \r\n",") pair for each generated method.\r\n             \r\n             ":"）对每种生成的方法对。\r\n             \r\n             \r\n","\r\n            Creates a speculative SemanticModel for a constructor initializer that did not appear in the original source code.\r\n            ":"\r\n            为未出现在原始源代码中的构造函数初始化器创建一个投机性词素模型。\r\n            \r\n","\r\n            Get the indexers for this type.\r\n            ":"\r\n            获取此类型的索引器。\r\n            \r\n","\r\n              Looks up a localized string similar to Possible unintended reference comparison; to get a value comparison, cast the right hand side to type '{0}'.\r\n            ":"\r\n              查找类似于可能意外参考比较的局部字符串；要获得值比较，请将右侧施放到键入'{0}'。\r\n            \r\n","Constructor is marked external":"构造函数是外部的\r\n","\r\n              Looks up a localized string similar to '{0}': cannot override because '{1}' does not have an overridable set accessor.\r\n            ":"\r\n              查找类似于'{0}'：无法覆盖的本地化字符串，因为'{1}'没有过多的设置访问者。\r\n            \r\n","\r\n            The field of the generated async class used in generic task returning async methods to store the value\r\n            of rewritten return expressions. The return-handling code then uses ":"\r\n            在通用任务中使用的生成异步类的字段返回异步方法来存储值\r\n            重写的返回表达式。然后使用返回处理代码\r\n","\r\n              Looks up a localized string similar to auto property initializer.\r\n            ":"\r\n              查找类似于自动属性初始化器的本地化字符串。\r\n            \r\n","\r\n            Returned expression need not be a ":"\r\n            返回的表达不必是\r\n","Individual function pointer unmanaged calling convention.":"单个函数指针非管理呼叫约定。\r\n","Called when the visitor visits a AnonymousMethodExpressionSyntax node.":"当访问者访问匿名的Xpressyntax节点时，请致电。\r\n","\r\n            Determine the constant value of this local and the corresponding diagnostics.\r\n            Set both to constantTuple in a single operation for thread safety.\r\n            ":"\r\n            确定此局部和相应诊断的恒定值。\r\n            将两者都设置为在单个操作中以进行线程安全性。\r\n            \r\n","\r\n            Returns true if the conversion is implicit.\r\n            ":"\r\n            如果转换是隐式的，则返回true。\r\n            \r\n","'{0}': the enumerator value is too large to fit in its type":"'{0}'：枚举器值太大而无法适合其类型\r\n","\r\n            Creates a speculative AttributeSemanticModel that allows asking semantic questions about an attribute node that did not appear in the original source code.\r\n            ":"\r\n            创建一个投机属性：允许询问有关未出现在原始源代码中的属性节点的语义问题。\r\n            \r\n","Argument contains an analyzer instance that does not belong to the 'Analyzers' for this CompilationWithAnalyzers instance.":"参数包含一个分析仪实例，该实例不属于此汇编WithAnalyzs实例的“分析仪”。\r\n","\r\n            Still has all of the comment punctuation (///, /**, etc).\r\n            ":"\r\n            仍然具有所有评论标点符号（///，/**等）。\r\n            \r\n","\r\n            Parse a local variable declaration.\r\n            ":"解析本地变量声明。\r\n            \r\n","Cannot specify default parameter value in conjunction with DefaultParameterAttribute or OptionalAttribute":"不能与默认参数值与DefaultParameterAttribute或OptionalAttribute指定默认参数值\r\n","\r\n              Looks up a localized string similar to The 'await' operator can only be used within an async {0}. Consider marking this {0} with the 'async' modifier..\r\n            ":"\r\n              查找类似于“等待”运算符的本地化字符串只能在异步{0}中使用。考虑使用'async'修饰符标记此{0}。\r\n            \r\n","\r\n            A comparer for sorting cases containing values of type float, double, or decimal.\r\n            ":"\r\n            对包含浮子，双重或十进制类型的值进行分类案例的比较。\r\n            \r\n","A property type or method return type to be checked for dynamification.":"要检查的属性类型或方法返回类型以进行动态化。\r\n","Non-invocable member '{0}' cannot be used like a method.":"不可用的成员'{0}'不能像方法一样使用。\r\n","'{0}' must match by reference return of overridden member '{1}'":"'{0}'必须通过覆盖成员'{1}'的参考返回匹配\r\n","XML comment has a duplicate param tag for '{0}'":"XML注释具有“ {0}'的重复param标签”\r\n","The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'. Nullable types can not satisfy any interface constraints.":"类型'{3}'在通用类型或方法'{0}'中不能用作类型参数'{2}'。无效的类型'{3}'不满足'{1}'的约束。无效类型无法满足任何接口约束。\r\n","\r\n            Parse an overloadable operator, with optional parameters.\r\n            ":"\r\n            解析具有可选参数的可容纳运算符。\r\n            \r\n","The value of the name attribute.":"名称属性的值。\r\n","\r\n            Parse an AttributeArgumentListSyntax node.\r\n            ":"\r\n            解析一个属性级别的ntrax节点。\r\n            \r\n","\r\n            Gets a SyntaxToken that represents the colon that terminates the switch label.\r\n            ":"\r\n            获得一个代表终止开关标签的结肠的语法。\r\n            \r\n","\r\n            Represents a field of a tuple type (such as (int, byte).Item1)\r\n            that doesn't have a corresponding backing field within the tuple underlying type.\r\n            Created in response to an error condition.\r\n            ":"\r\n            代表元组类型的字段（例如（int，byte）.Item1）\r\n            这在元组基础类型中没有相应的后退字段。\r\n            根据错误条件而创建的。\r\n            \r\n","No value for RuntimeMetadataVersion found. No assembly containing System.Object was found nor was a value for RuntimeMetadataVersion specified through options.":"找不到RuntimetAdataversion的值。未找到包含系统的组件。对象也不是通过选项指定的runtimemetadataversion的值。\r\n","\r\n            Gets a SyntaxReference for this syntax node. SyntaxReferences can be used to\r\n            regain access to a syntax node without keeping the entire tree and source text in\r\n            memory.\r\n            ":"\r\n            获取此语法节点的语法rreference。语法介绍可用于\r\n            重新获得对语法节点的访问，而无需保留整个树和源文本\r\n            记忆。\r\n            \r\n","Called when the visitor visits a InitializerExpressionSyntax node.":"当访问者访问initizerexpressionsyntax节点时调用。\r\n","Called when the visitor visits a TypePatternSyntax node.":"当访问者访问TypePatternsyntax节点时，请致电。\r\n","\r\n            If hasFinalizerState is true, this is the state for finalization from anywhere in this\r\n            try block.  Initially set to -1, representing the no-op finalization required at the top\r\n            level.  Not used if !this.useFinalizerBookkeeping.\r\n            ":"如果Hasfinalizerstate是正确的，那么这是从此处任何地方完成的最终确定状态\r\n            尝试块。最初设置为-1，表示顶部所需的NO -OP最终确定\r\n            等级。如果！\r\n            \r\n","\r\n              Looks up a localized string similar to Unexpected character sequence '...'.\r\n            ":"\r\n              查找类似于意外字符序列'...'的本地化字符串。\r\n            \r\n","Parameter syntax.":"参数语法。\r\n","\r\n              Looks up a localized string similar to Cannot yield a value in the body of a catch clause.\r\n            ":"\r\n              查找类似于类似的局部字符串，无法在捕获子句的正文中产生一个值。\r\n            \r\n","\r\n            See SyntaxNode.GetCorrespondingLambdaBody.\r\n            ":"\r\n            请参阅SyntaxNode.getCorresportingLambDabody。\r\n            \r\n","The 'error' or 'warning' token.":"“错误”或“警告”令牌。\r\n","True to suppress overload resolution result diagnostics (but not argument diagnostics).":"真正抑制过载分辨率结果诊断（但不是参数诊断）。\r\n","\r\n            The sequence of groups of TypeDef row ids for types contained within the namespace, \r\n            recursively including those from nested namespaces. The row ids are grouped by the \r\n            fully-qualified namespace name case-sensitively. There could be multiple groups \r\n            for each fully-qualified namespace name. The groups are sorted by their \r\n            key in case-sensitive manner. Empty string is used as namespace name for types \r\n            immediately contained within Global namespace. Therefore, all types in this namespace, if any, \r\n            will be in several first IGroupings.\r\n            ":"\r\n            命名空间中包含的类型类型的Typedef行ID组序列，\r\n            递归包括来自嵌套名称空间的。行ID由\r\n            完全合格的名称空间案例敏感。可能有多个组\r\n            对于每个符合条件的名称空间名称。小组被他们的分类\r\n            以情况敏感的方式关键。空字符串用作类型的名称名称\r\n            立即包含在全球名称空间中。因此，此名称空间中的所有类型（如果有）\r\n            将在几个第一个Igroupings中。\r\n            \r\n","\r\n              Looks up a localized string similar to An expression tree may not contain a discard..\r\n            ":"\r\n              查找类似于表达树的本地化字符串可能不包含丢弃。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot yield a value in the body of a try block with a catch clause.\r\n            ":"\r\n              查找类似于类似的局部字符串，无法在带有捕获子句的try块正文中产生一个值。\r\n            \r\n"," to determine which labels a new child scope appears after.\r\n            ":" 确定新的孩子范围出现的标签。\r\n            \r\n","A clone of the original syntax node that has current ":"具有电流的原始语法节点的克隆\r\n","Control cannot fall out of switch from final case label ('{0}')":"控制无法从最终案例标签（'{0}'）中脱离切换。\r\n",".\r\n            A value set representing values of type nuint groups them all together, so that it is not possible to\r\n            distinguish one such value from another.  The flag ":"。\r\n            代表类型nuint的值组的值集，使得不可能\r\n            区分一个这样的价值与另一个值。旗帜\r\n","\r\n            Report differences between the defining and implementing\r\n            parts of a partial method. Diagnostics are reported on the\r\n            implementing part, matching Dev10 behavior.\r\n            ":"\r\n            报告定义和实施之间的差异\r\n            部分方法的一部分。诊断有报道\r\n            实施零件，匹配DEV10行为。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': cannot change access modifiers when overriding '{1}' inherited member '{2}'.\r\n            ":"\r\n              查找类似于'{0}'：覆盖'{1}'继承的成员'{2}'时无法更改访问修饰符的本地化字符串。\r\n            \r\n","\r\n            If true, the parameter types and nullability from _delegateInvokeMethod is used for\r\n            initial parameter state. If false, the signature of CurrentSymbol is used instead.\r\n            ":"\r\n            如果为true，则使用_delegateInvokeMethod的参数类型和无效性\r\n            初始参数状态。如果是错误的，则使用Currentsymbol的签名。\r\n            \r\n","Source file specified multiple times":"源文件多次指定\r\n","\r\n            Decodes the attributes applied to the given ":"\r\n            解码应用于给定的属性\r\n","\r\n              Looks up a localized string similar to Only CLS-compliant members can be abstract.\r\n            ":"\r\n              查找与仅符合CLS的成员类似的本地化字符串可以抽象。\r\n            \r\n","\r\n              Looks up a localized string similar to Type '{0}' cannot be embedded because it has a generic argument. Consider setting the 'Embed Interop Types' property to false..\r\n            ":"\r\n              查找类似于“ {0}”类型的本地化字符串，因为它具有通用参数，因此无法嵌入。考虑将“嵌入Interop类型”属性设置为false。\r\n            \r\n","\r\n            Attempt to bind the LHS of a member access expression.  If this is a Color Color case (spec 7.6.4.1),\r\n            then return a BoundExpression if we can easily disambiguate or a BoundTypeOrValueExpression if we\r\n            cannot.  If this is not a Color Color case, then return null.\r\n            ":"\r\n            尝试绑定成员访问表达式的LHS。如果这是颜色颜色案例（规格7.6.4.1），则\r\n            如果我们可以轻松地消除歧义或界限表达，如果我们可以返回界表\r\n            不能。如果这不是颜色的情况，请返回null。\r\n            \r\n","\r\n            The state at a given node of the decision finite state automaton. This is used during computation of the state\r\n            machine (":"\r\n            在决策有限状态自动机的给定节点处的状态。这是在状态计算期间使用的\r\n            机器 （\r\n","\r\n              Looks up a localized string similar to Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}'.\r\n            ":"\r\n              查找类似于类型参数'{0}'的本地化字符串，继承了冲突的约束'{1}'和'{2}'。\r\n            \r\n","\r\n            The system assembly, which provides primitive types like Object, String, etc., e.g. mscorlib.dll. \r\n            The value is provided by ReferenceManager and must not be modified. For SourceAssemblySymbol, non-missing \r\n            coreLibrary must match one of the referenced assemblies returned by GetReferencedAssemblySymbols() method of \r\n            the main module. If there is no existing assembly that can be used as a source for the primitive types, \r\n            the value is a Compilation.MissingCorLibrary. \r\n            ":"\r\n            系统组件，提供原始类型，例如对象，字符串等，例如mscorlib.dll。\r\n            该值由ReferenceManager提供，不得修改。对于源切除术，无误\r\n            冠状动脉必须匹配由GetReferendedAssemblysymbols返回的参考组件之一（）方法\r\n            主模块。如果没有现有的组件可以用作原始类型的来源，\r\n            该值是汇编。\r\n            \r\n","'{0}': a volatile field cannot be of the type '{1}'":"'{0}'：一个挥发性字段不能是类型'{1}'\r\n","\r\n              Looks up a localized string similar to Missing file attribute.\r\n            ":"\r\n              查找类似于缺少文件属性的本地化字符串。\r\n            \r\n","XML comment has syntactically incorrect cref attribute '{0}'":"XML评论在句法上不正确cref属性'{0}'\r\n","\r\n            Determines if the source expression is convertible to the destination type via\r\n            any conversion: implicit, explicit, user-defined or built-in.\r\n            ":"\r\n            确定源表达式是否可通过\r\n            任何转换：隐式，显式，用户定义或内置。\r\n            \r\n","\r\n            Contains methods related to synthesizing bound nodes in initial binding\r\n            form that needs lowering, primarily method bodies for compiler-generated methods.\r\n            ":"\r\n            包含与最初结合中合成结合节点有关的方法\r\n            需要降低的形式，主要是用于编译器生成方法的方法。\r\n            \r\n","\r\n            Binds an exception to the method builder.\r\n            ":"\r\n            绑定与方法构建器的例外。\r\n            \r\n","Constraint cannot be the dynamic type":"约束不能是动态类型\r\n","Inconsistent accessibility: parameter type '{1}' is less accessible than indexer '{0}'":"不一致的可访问性：参数类型'{1}'比indexer'{0}'易于访问\r\n","\r\n            Given the full text of a single-line style documentation comment, for each line, strip off\r\n            the comment punctuation (///) and add appropriate indentations.\r\n            ":"鉴于单行样式文档注释的全文，每行，脱掉\r\n            评论标点符号（///）并增加适当的凹痕。\r\n            \r\n","\r\n              Looks up a localized string similar to (Location of symbol related to previous warning).\r\n            ":"\r\n              查找类似于（与以前的警告相关的符号的位置）类似的局部字符串。\r\n            \r\n",", and\r\n             (4) The symbol that is used to access the innermost frame pointer (it could be a local variable or \"this\" parameter)\r\n            \r\n             Lastly, we visit the top-level method and each of the lowered methods\r\n             to rewrite references (e.g., calls and delegate conversions) to local\r\n             functions. We visit references to local functions separately from\r\n             lambdas because we may see the reference before we lower the target\r\n             local function. Lambdas, on the other hand, are always convertible as\r\n             they are being lowered.\r\n             \r\n             There are a few key transformations done in the rewriting.\r\n             (1) Lambda expressions are turned into delegate creation expressions, and the body of the lambda is\r\n                 moved into a new, compiler-generated method of a selected frame class.\r\n             (2) On entry to a scope with captured variables, we create a frame object and store it in a local variable.\r\n             (3) References to captured variables are transformed into references to fields of a frame class.\r\n             \r\n             In addition, the rewriting deposits into ":"， 和\r\n             （4）用于访问最终帧指针的符号（可能是本地变量或“此参数”）\r\n            \r\n             最后，我们访问顶级方法和每个降低的方法\r\n             重写引用（例如呼叫和委派转换）到本地\r\n             功能。我们访问与本地功能的参考\r\n             lambdas，因为我们可能会在降低目标之前看到参考\r\n             本地功能。另一方面，Lambdas总是可转换为\r\n             他们正在降低。\r\n             \r\n             重写中有一些关键的转换。\r\n             （1）lambda表达式变成代表创造表达式，而lambda的正文是\r\n                 移至选定框架类的新编译器生成的方法。\r\n             （2）进入具有捕获变量的范围时，我们创建一个帧对象并将其存储在本地变量中。\r\n             （3）对捕获变量的引用转换为对帧类字段的引用。\r\n             \r\n             此外，将存款重写为\r\n","Output directory could not be determined":"无法确定输出目录\r\n","\r\n            Represents a type of a RetargetingModuleSymbol. Essentially this is a wrapper around \r\n            another NamedTypeSymbol that is responsible for retargeting referenced symbols from one assembly to another. \r\n            It can retarget symbols for multiple assemblies at the same time.\r\n            ":"\r\n            代表一种retargetingModulesymbol。本质上，这是周围的包装纸\r\n            另一个命名为typesymbol，负责将引用的符号从一个组件重新定位为另一个组件。\r\n            它可以同时重新定位多个组件。\r\n            \r\n","\r\n            \"ref\" and \"out\" work, but \"params\", \"this\", and \"__arglist\" don't.\r\n            ":"\r\n            “ ref”和“ out”工作，但“ params”，“ this”和“ __arglist”不会。\r\n            \r\n","Empty format specifier.":"空格式指定符。\r\n","\r\n            Gets the kind of this symbol.\r\n            ":"\r\n            得到这种符号。\r\n            \r\n","\r\n            Always prefer ":"\r\n            总是喜欢\r\n","Cannot use ref local '{0}' inside an anonymous method, lambda expression, or query expression":"无法在匿名方法，lambda表达式或查询表达式中使用Ref Local'{0}'\r\n","\r\n            Determine if \"type\" inherits from or implements \"baseType\", ignoring constructed types, and dealing\r\n            only with original types.\r\n            ":"\r\n            确定“类型”是否继承或实现“底型”，忽略构造的类型，并交易\r\n            仅具有原始类型。\r\n            \r\n","The 'await' operator cannot be used in a static script variable initializer.":"“等待”运算符不能在静态脚本变量初始化器中使用。\r\n","\r\n            Groups the information computed by MakeOverriddenOrHiddenMembers.\r\n            ":"\r\n            分组由MachoverridendorhiddenMembers计算的信息。\r\n            \r\n","\r\n            Gets the constructor used in this application of the attribute.\r\n            ":"\r\n            获取在属性的此应用中使用的构造函数。\r\n            \r\n","Cannot specify a default value for a parameter array":"无法指定参数阵列的默认值\r\n","\r\n              Looks up a localized string similar to The current method calls an async method that returns a Task or a Task<TResult> and doesn't apply the await operator to the result. The call to the async method starts an asynchronous task. However, because no await operator is applied, the program continues without waiting for the task to complete. In most cases, that behavior isn't what you expect. Usually other aspects of the calling method depend on the results of the call or, minimally, the called method is expected to complete before you return from t [rest of string was truncated]\";.\r\n            ":"\r\n              查找类似于当前方法的本地化字符串调用一个异步方法，该方法返回任务或任务<tresult>，并且不将等待运算符应用于结果。对异步方法的调用开始了异步任务。但是，由于没有应用等待操作员，因此该程序将继续，而无需等待任务完成。在大多数情况下，这种行为不是您所期望的。通常，调用方法的其他方面取决于调用的结果，或者最少，在从t返回t [字符串的其余部分被截断]之前，该方法应完成。\r\n            \r\n","Arguments to the attribute constructor.":"属性构造函数的论点。\r\n","Overloadable unary operator expected":"预期可超载的单一操作员\r\n","Integral constant is too large":"整体常数太大\r\n",".  Can be used to avoid having to go back to source\r\n            to retrieve attributes whtn there is no chance they would bind to attribute of interest.\r\n            ":"。可以用来避免必须返回源\r\n            为了检索属性，他们没有机会与感兴趣的属性结合。\r\n            \r\n","\r\n              Looks up a localized string similar to Source file specified multiple times.\r\n            ":"\r\n              查找类似于多次指定的源文件的本地化字符串。\r\n            \r\n","\r\n            Parse a user-defined conversion, with optional parameters.\r\n            ":"\r\n            解析具有可选参数的用户定义转换。\r\n            \r\n","\r\n            Definitely not a type name.\r\n            ":"\r\n            绝对不是类型名称。\r\n            \r\n","\r\n            This visitor represents just the assignment part of the null coalescing assignment\r\n            operator.\r\n            ":"\r\n            该访问者仅代表无效分配的分配部分\r\n            操作员。\r\n            \r\n","\r\n            Expression is the receiver of a fixed buffer field access\r\n            ":"\r\n            表达是固定缓冲区访问的接收器\r\n            \r\n","\r\n            True if this function directly or transitively captures 'this' (captures\r\n            a local function which directly or indirectly captures 'this').\r\n            Calculated in ":"\r\n            如果此功能直接或传统捕获“此”（捕获）\r\n            直接或间接捕获“此”）的本地函数。\r\n            计算\r\n","\r\n            During early attribute decoding, we consider a safe subset of all members that will not\r\n            cause cyclic dependencies.  Get all such members for this symbol.\r\n            ":"\r\n            在早期属性解码期间，我们考虑所有成员的安全子集\r\n            导致循环依赖性。为此符号获取所有此类成员。\r\n            \r\n","\r\n            If the end of a query expression statement is commented out, then the following statement may\r\n            appear to be part of the query.  When this occurs, identifiers within the following statement\r\n            may need to be reinterpreted as query keywords.\r\n            ":"\r\n            如果查询表达式语句的结尾是评论的，​​则以下语句可能\r\n            似乎是查询的一部分。发生这种情况时，以下语句中的标识符\r\n            可能需要重新解释为查询关键字。\r\n            \r\n","\r\n            Returns the default value of the parameter. If ":"\r\n            返回参数的默认值。如果\r\n","\r\n            Lower the body, adding an entry state (-3) at the start,\r\n            so that we can differentiate an async-iterator that was never moved forward with MoveNextAsync()\r\n            from one that is running (-1).\r\n            Then we can guard against some bad usages of DisposeAsync.\r\n            ":"\r\n            降低身体，在开始时添加入口状态（-3），\r\n            这样我们就可以区分一个从未通过moveNextAsync（）向前移动的异步词\r\n            从正在运行的一个（-1）中。\r\n            然后，我们可以防止disposeasync的一些不良用法。\r\n            \r\n","\r\n            Return true if the type parameters specified on the nested type (this),\r\n            that represent the corresponding type parameters on the containing\r\n            types, in fact match the actual type parameters on the containing types.\r\n            ":"\r\n            如果在嵌套类型（this），\r\n            代表包含的相应类型参数\r\n            类型，实际上匹配包含类型上的实际类型参数。\r\n            \r\n","\r\n            Returns the containing assembly. Modules are always directly contained by an assembly,\r\n            so this property always returns the same as ContainingSymbol.\r\n            ":"\r\n            返回包含的组件。模块始终由组件直接包含\r\n            因此，该属性始终返回与ContiningSymbol相同。\r\n            \r\n","\r\n            This method find the set of applicable user-defined and lifted conversion operators, u.\r\n            The set consists of the user-defined and lifted implicit conversion operators declared by\r\n            the classes and structs in d that convert from a type encompassing source to a type encompassed by target.\r\n            However if allowAnyTarget is true, then it considers all operators that convert from a type encompassing source\r\n            to any target. This flag must be set only if we are computing user defined conversions from a given source\r\n            type to any target type.\r\n            ":"\r\n            此方法找到一组适用的用户定义和升起的转换运算符u。\r\n            该集合由用户定义和抬起的隐式转换运算符组成\r\n            D中的类和结构从包含源的类型转换为目标包含的类型。\r\n            但是，如果允许YANYTARGET为TRUE，则考虑所有从类型的运算符\r\n            到任何目标。仅当我们从给定源计算用户定义的转换时，才必须设置此标志\r\n            输入任何目标类型。\r\n            \r\n","Creates a new FunctionPointerCallingConventionSyntax instance.":"创建一个新的fintuctPoInterCallingConventionsyntax实例。\r\n","\r\n            Bind the constructor initializer in the context of the specified location and get semantic information\r\n            such as type, symbols and diagnostics. This method is used to get semantic information about a constructor\r\n            initializer that did not actually appear in the source code.\r\n            \r\n            NOTE: This will only work in locations where there is already a constructor initializer.\r\n            ":"\r\n            在指定位置的上下文中绑定构造函数初始化器并获取语义信息\r\n            例如类型，符号和诊断。此方法用于获取有关构造函数的语义信息\r\n            实际上并未出现在源代码中的初始化程序。\r\n            \r\n            注意：这只能在已经有构造函数初始化器的位置工作。\r\n            \r\n","\r\n              Looks up a localized string similar to The 'l' suffix is easily confused with the digit '1' -- use 'L' for clarity.\r\n            ":"\r\n              查找类似于“ L”后缀的局部字符串很容易与Digit“ 1”  - 使用“ L”相混淆。\r\n            \r\n","\r\n            Get the types of the parameters of a member symbol.  Should be a method, property, or event.\r\n            ":"\r\n            获取成员符号的参数的类型。应该是一种方法，属性或事件。\r\n            \r\n","\r\n            Determine if enum arrays can be initialized using block initialization.\r\n            ":"\r\n            确定是否可以使用块初始化来初始化枚举阵列。\r\n            \r\n","Error building Win32 resources -- {0}":"错误构建Win32资源 -  {0}\r\n","\r\n              Looks up a localized string similar to  Include tag is invalid .\r\n            ":"\r\n              查找类似于包含标签的本地化字符串无效。\r\n            \r\n","\r\n            Count the number of custom modifiers in/on the return type\r\n            and parameters of the specified method.\r\n            ":"\r\n            计算/返回类型中的自定义修饰符的数量\r\n            和指定方法的参数。\r\n            \r\n","Populated with a list of temporary local symbols.":"带有临时本地符号列表。\r\n","Gets the return type.":"获取返回类型。\r\n","\r\n            The class to represent all properties imported from a PE/module.\r\n            ":"\r\n            代表从PE/模块导入的所有属性的类。\r\n            \r\n"," with no known type, given lookupResultKind and given symbols for GetSemanticInfo API.\r\n            ":" 没有已知类型，给出了LookupResultKind，并给出了GetManticinfo API的符号。\r\n            \r\n","\r\n            User variable declared by a declaration expression in the left-hand-side of a deconstruction assignment.\r\n            ":"\r\n            用户变量通过解构分配的左侧声明表达式声明。\r\n            \r\n","\r\n              Looks up a localized string similar to Argument of type '{0}' cannot be used for parameter '{2}' of type '{1}' in '{3}' due to differences in the nullability of reference types..\r\n            ":"\r\n              查找类似于类型'{0}'参数的本地化字符串，由于参考类型的删除性的差异，因此在'{3}'中类型'{1}'的type'{1}'的参数使用。\r\n            \r\n","Members of {0} '{1}' cannot be used as a ref or out value because it is a readonly variable":"{0}'{1}'的成员不能用作ref或淘汰价值，因为它是一个可读变量\r\n","\r\n              Looks up a localized string similar to Circular constraint dependency involving '{0}' and '{1}'.\r\n            ":"\r\n              查找类似于涉及“ {0}'和'{1}'的圆形约束依赖关系的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to foreach requires that the return type '{0}' of '{1}' must have a suitable public 'MoveNext' method and public 'Current' property.\r\n            ":"\r\n              查找类似于foreach的本地化字符串要求“ {1}”的返回类型'{0}'必须具有合适的公共'moveNext'方法和公共'当前'属性。\r\n            \r\n","\r\n            Given a position in the SyntaxTree for this SemanticModel returns the innermost\r\n            NamedType that the position is considered inside of.\r\n            ":"\r\n            在该语义模型的语法中给定一个位置，返回最内在的\r\n            命名为typepe，认为该位置在内部。\r\n            \r\n","\r\n            Return true if this type can unify with the specified type\r\n            (i.e. is the same for some substitution of type parameters).\r\n            ":"如果此类型可以与指定类型统一，则返回true\r\n            （即，对于某些类型参数的替换是相同的）。\r\n            \r\n","Retargeted System.Type type symbol.":"retargeted system.type类型符号。\r\n","\r\n            The class to represent all, but Global, namespaces imported from a PE/module.\r\n            Namespaces that differ only by casing in name are not merged.\r\n            ":"\r\n            从PE/模块导入的全部（全局）名称空间。\r\n            不合并仅通过名称套管而有所不同的名称空间。\r\n            \r\n","Delegate '{0}' does not take {1} arguments":"委托'{0}'不接受{1}参数\r\n","<<":"<<\r\n"," that is responsible for retargeting symbols from one assembly to another. \r\n            It can retarget symbols for multiple assemblies at the same time.\r\n            \r\n            Here is how retargeting is implemented in general:\r\n            - Symbols from underlying module are substituted with retargeting symbols.\r\n            - Symbols from referenced assemblies that can be reused as is (i.e. don't have to be retargeted) are\r\n              used as is.\r\n            - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.\r\n            ":" 这是为了将符号从一个组件重新定位到另一个组件。\r\n            它可以同时重新定位多个组件。\r\n            \r\n            这是如何实施重新定位的方式：\r\n             - 基础模块的符号用重新定位符号代替。\r\n             - 可以按原样重复使用的参考组件的符号（即不必重新定位）是\r\n              按原样使用。\r\n             - 必须重新定位的参考组件中的符号被重新定位的结果代替。\r\n            \r\n","The range variable '{0}' cannot have the same name as a method type parameter":"范围变量'{0}'不能与方法类型参数具有相同的名称\r\n","\r\n            What kind of comparison to use? \r\n            You can ignore custom modifiers, ignore the distinction between object and dynamic, or ignore tuple element names differences.\r\n            ":"\r\n            使用什么样的比较？\r\n            您可以忽略自定义修饰符，忽略对象与动态之间的区别，或忽略元组元素名称差异。\r\n            \r\n","\r\n            Implicit conversions are described in section 6.1 of the C# language specification.\r\n            ":"\r\n            隐式转换在C＃语言规范的第6.1节中描述。\r\n            \r\n","\r\n            If the declaring type is constructed, it's possible that two (or more) members have the same signature\r\n            (including custom modifiers) in metadata (no ref/out distinction).  Return a list of such members so\r\n            that we can report the ambiguity.\r\n            \r\n            Even in a non-generic type, it's possible for two indexers to have the same signature.  For example,\r\n            this would be the case if the default member of a type is \"get_Item\" and indexers \"A\" and \"B\", \r\n            with the same signature, both have an indexer called \"get_Item\".\r\n            \r\n            From: SymbolPreparer.cpp\r\n            DevDiv Bugs 115384: Both out and ref parameters are implemented as references. In addition, out parameters are \r\n            decorated with OutAttribute. In CLR when a signature is looked up in virtual dispatch, CLR does not distinguish\r\n            between these to parameter types. The choice is the last method in the vtable. Therefore we check and warn if \r\n            there would potentially be a mismatch in CLRs and C#s choice of the overridden method. Unfortunately we have no \r\n            way of communicating to CLR which method is the overridden one. We only run into this problem when the \r\n            parameters are generic.\r\n            ":"\r\n            如果构建声明类型，则可能有两个（或更多）成员具有相同的签名\r\n            （包括自定义修饰符）在元数据中（无参考/退出）。返回此类成员的列表\r\n            我们可以报告歧义。\r\n            \r\n            即使在非类型类型中，两个索引器也可能具有相同的签名。例如，\r\n            如果类型的默认成员为“ get_item”和索引器“ A”和“ B”，那将是这种情况。\r\n            具有相同的签名，两者都有一个称为“ get_item”的索引器。\r\n            \r\n            来自：symendpreparer.cpp\r\n            DEVDIV错误115384：OUT和REF参数均以引用实现。另外，参数为\r\n            用外属性装饰。在CLR中，当签名在虚拟调度中查找时，CLR不区分\r\n            在这些参数类型之间。选择是VTable中的最后一种方法。因此，我们检查并警告是否\r\n            在CLR和C＃的选择中，可能会有不匹配。不幸的是我们没有\r\n            与CLR通信的方式是哪种方法。我们只有当\r\n            参数是通用的。\r\n            \r\n","Using declarations":"使用声明\r\n","\r\n              Looks up a localized string similar to The specified version string contains wildcards, which are not compatible with determinism. Either remove wildcards from the version string, or disable determinism for this compilation.\r\n            ":"\r\n              查找类似于指定版本字符串的本地化字符串包含通配符，与确定性不兼容。从版本字符串中删除通配符，或禁用此编译的确定性。\r\n            \r\n","\r\n            This method indicates whether or not the runtime will regard the method\r\n            as newslot (as indicated by the presence of the \"newslot\" modifier in the\r\n            signature).\r\n            WARN WARN WARN: We won't have a final value for this until declaration\r\n            diagnostics have been computed for all ":"\r\n            此方法指示运行时是否会考虑该方法\r\n            如Newslot（如在“新闻插槽”修饰符中的存在所示\r\n            签名）。\r\n            警告警告：直到宣布，我们不会对此有最终价值\r\n            已经计算出所有人的诊断\r\n","\r\n            Generate an accessor for a field-like event.\r\n            ":"\r\n            生成类似现场的事件的登录器。\r\n            \r\n","\r\n            Given an syntax node that declares a property or member accessor, get the corresponding symbol.\r\n            ":"\r\n            给定一个声明属性或成员登录器的语法节点，获取相应的符号。\r\n            \r\n","\r\n              Looks up a localized string similar to '{1} {0}' has the wrong return type.\r\n            ":"\r\n              查找类似于'{1} {0}'的本地化字符串的返回类型错误。\r\n            \r\n","tree not part of compilation":"树而不是汇编的一部分\r\n","'await' cannot be used in an expression containing a ref conditional operator":"“等待”不能在包含REF条件操作员的表达式中使用\r\n","\r\n            Returns true if the type is a readonly sruct\r\n            ":"\r\n            如果类型是可读的sruct，则返回true\r\n            \r\n","\r\n            Patch refKinds for arguments that match 'In' parameters to have effective RefKind.\r\n            For the purpose of further analysis we will mark the arguments as -\r\n            - In        if was originally passed as None\r\n            - StrictIn  if was originally passed as In\r\n            Here and in the layers after the lowering we only care about None/notNone differences for the arguments\r\n            Except for async stack spilling which needs to know whether arguments were originally passed as \"In\" and must obey \"no copying\" rule.\r\n            ":"\r\n            贴片refkinds用于匹配“在”参数中的参数具有有效的参数。\r\n            为了进一步分析，我们将这些论点标记为 - \r\n             -  if最初通过\r\n             - 严格if最初通过\r\n            在降低后的这里和层中，我们只关心任何参数的差异\r\n            除了异步堆栈溢出外，还需要知道是否最初以“在”中的“”中的“”来遵守“不复制”规则。\r\n            \r\n","'{0}': cannot reference a type through an expression; try '{1}' instead":"'{0}'：无法通过表达式引用类型；尝试'{1}'而不是\r\n","\r\n            It is rare but possible for a source type to be convertible to a destination type\r\n            by both an implicit user-defined conversion and a built-in explicit conversion.\r\n            In that circumstance, this method classifies the conversion as the implicit conversion.\r\n            ":"\r\n            很少见，但可能使源类型可转换为目的地类型\r\n            通过隐式用户定义的转换和内置的显式转换。\r\n            在这种情况下，此方法将转换分类为隐式转换。\r\n            \r\n","Delegate type if method group represents a delegate.":"委托类型如果方法组表示委托。\r\n","\r\n            The candidate member was rejected because it was considered worse that another member (according to section\r\n            7.5.3.2 of the language specification).\r\n            ":"\r\n            候选人被拒绝，因为认为另一个成员被认为更糟（根据部分\r\n            7.5.3.2语言规范）。\r\n            \r\n","\r\n            The class that represents a translated iterator method.\r\n            ":"\r\n            代表翻译的迭代方法的类。\r\n            \r\n","\r\n            The empty set of values.\r\n            ":"\r\n            空的值集。\r\n            \r\n","\r\n            Indicates the type of return statement with no expression. Used in InferReturnType.\r\n            ":"\r\n            指示没有表达式的返回语句的类型。用于分泌型。\r\n            \r\n","\r\n            The underlying PropertySymbol, cannot be another RetargetingPropertySymbol.\r\n            ":"\r\n            底层属性符号不能是另一个重新定位propopertysymbol。\r\n            \r\n","\r\n            True if overload resolution successfully selected a single best method.\r\n            ":"\r\n            如果超负荷分辨率成功选择了单个最佳方法，则为正确。\r\n            \r\n","\r\n            The candidate method's type arguments do not satisfy their constraints.\r\n            ":"\r\n            候选方法的类型参数无法满足其约束。\r\n            \r\n","\r\n            Join nullable flow states from distinct branches during flow analysis.\r\n            The result is ":"\r\n            在流量分析过程中加入来自不同分支的无效流状态。\r\n            结果就是\r\n","Cannot use {0} '{1}' as a ref or out value because it is a readonly variable":"不能将{0}'{1}'用作ref或淘汰价值，因为它是一个可读变量\r\n","; for ":";为了\r\n","The syntax node that declares a parameter.":"声明参数的语法节点。\r\n","\r\n              Looks up a localized string similar to Feature is not part of the standardized ISO C# language specification, and may not be accepted by other compilers.\r\n            ":"查找类似于功能的本地化字符串不是标准化的ISO C＃语言规范的一部分，也可能不会被其他编译器接受。\r\n            \r\n","\r\n            Merges features of the type with another type where there is an identity conversion between them.\r\n            The features to be merged are\r\n            object vs dynamic (dynamic wins), tuple names (dropped in case of conflict), and nullable\r\n            annotations (e.g. in type arguments).\r\n            ":"\r\n            将类型的功能与另一种类型的特征合并，其中它们之间存在身份转换。\r\n            要合并的功能是\r\n            对象与动态（动态胜利），元组名称（在发生冲突时丢弃）和无效\r\n            注释（例如类型参数）。\r\n            \r\n","\r\n            If the member is generic, construct it with the CrefTypeParameterSymbols that should be in scope.\r\n            ":"如果成员是通用的，请使用应在范围内的creftyparametersymbols构造。\r\n            \r\n","\r\n            Returns true if this symbol represents a constructor of an interactive submission class.\r\n            ":"\r\n            如果此符号代表交互式提交类的构造函数，则返回true。\r\n            \r\n","'{0}' cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type '{1}'":"'{0}'不能将其标记为CLS兼容，因为它是符合非CLS类型的成员'{1}'\r\n","\r\n            Event accessor that has been synthesized for a field-like event declared in source.\r\n            ":"\r\n            事件访问者已合成为在源中声明的类似现场的事件合成的。\r\n            \r\n","\r\n              Looks up a localized string similar to Accessor '{0}' cannot implement interface member '{1}' for type '{2}'. Use an explicit interface implementation..\r\n            ":"\r\n              查找类似于访问者'{0}'的本地化字符串，无法实现interface member'{1}'type'{2}'。使用显式接口实现。\r\n            \r\n","The nullability-adjusted local, or the original symbol if the nullability analysis made no adjustments or was not run.":"如果无效分析不进行调整或未运行，则根据无效的局部或原始符号。\r\n","Called when the visitor visits a AttributeArgumentListSyntax node.":"当访问者访问attributeargumentListsyntax节点时调用。\r\n","Creates a new RefTypeSyntax instance.":"创建一个新的reftypesyntax实例。\r\n","\r\n            A value set factory, which can be used to create a value set instance.  A given instance of ":"\r\n            值集工厂，可用于创建值集实例。给定的实例\r\n","\r\n            Returns true if the method is the default constructor synthesized for struct types, and\r\n            if ":"\r\n            如果该方法是为结构类型合成的默认构造函数，则返回true\r\n            如果\r\n","\r\n              Looks up a localized string similar to Branches of a ref ternary operator cannot refer to variables with incompatible declaration scopes.\r\n            ":"\r\n              查找类似于参考三元运算符的分支类似的本地化字符串，无法指出具有不兼容声明范围的变量。\r\n            \r\n","\r\n            The node that contains this node in its Children collection.\r\n            ":"\r\n            在其子女系列中包含此节点的节点。\r\n            \r\n","The type for the type pattern.":"类型模式的类​​型。\r\n","\r\n            Returns true if this symbol requires an instance reference as the implicit reciever. This is false if the symbol is static, or a ":"\r\n            如果此符号需要实例参考作为隐式接收器，则返回true。如果符号是静态的，则是错误的\r\n","\r\n              Looks up a localized string similar to Property or indexer '{0}' cannot be assigned to -- it is read only.\r\n            ":"\r\n              查找类似于属性或索引器'{0}'的本地化字符串，不能分配给 - 仅读取。\r\n            \r\n","Member hides inherited member; missing override keyword":"成员隐藏的成员；缺少覆盖关键字\r\n","\r\n              Looks up a localized string similar to Range variable '{0}' cannot be assigned to -- it is read only.\r\n            ":"\r\n              查找类似于范围变量'{0}'的本地化字符串，不能分配给 - 仅读取。\r\n            \r\n","'{0}' hides inherited member '{1}'. Use the new keyword if hiding was intended.":"'{0}'隐藏成员'{1}'。如果隐藏的话，请使用新的关键字。\r\n"," Synthesized method info ":" 合成的方法信息\r\n","\r\n            Environment created in this scope to hold ":"\r\n            在此范围内创建的环境\r\n","\r\n            The method is called at the end of ":"\r\n            该方法在末尾调用\r\n","\r\n              Looks up a localized string similar to Security attribute '{0}' cannot be applied to an Async method..\r\n            ":"\r\n              查找类似于安全属性'{0}'的本地化字符串不能应用于异步方法。\r\n            \r\n","Options used to customize formatting of an object value.":"用于自定义对象值格式的选项。\r\n","\r\n            Infer the result type of the switch expression by looking for a common type.\r\n            ":"\r\n            通过寻找公共类型来推断开关表达式的结果类型。\r\n            \r\n","ref foreach iteration variables":"涉及到教的迭代变量\r\n","\r\n            Holds the information for a tuple comparison, either at the top-level (like ":"\r\n            在顶级上持有元组比较的信息（例如\r\n","\r\n              Looks up a localized string similar to Integral constant is too large.\r\n            ":"\r\n              查找类似于积分常数的局部字符串太大。\r\n            \r\n","\r\n            Compile documentation comments on the symbol and write them to the stream if one is provided.\r\n            ":"\r\n            编译文档在符号上注释，并在提供的情况下将其写入流。\r\n            \r\n","\r\n            A collection of type parameter constraints, populated when\r\n            constraints for the first type parameter are requested.\r\n            ":"\r\n            类型参数约束的集合，当\r\n            请求第一个类型参数的约束。\r\n            \r\n","\r\n            Encoding serialized as ":"\r\n            编码序列化为\r\n","\r\n            Wrap a given expression e into a block as either { e; } or { return e; }\r\n            Shared between lambda and expression-bodied method binding.\r\n            ":"\r\n            将给定的表达式e包裹在一个块中{e; }或{返回e; }\r\n            在lambda和表达体现的方法结合之间共享。\r\n            \r\n","\r\n            Does not preserve diagnostics.\r\n            ":"\r\n            不保留诊断。\r\n            \r\n","\r\n            Rewrites the given interpolated string to the set of handler creation and Append calls, returning an array builder of the append calls and the result\r\n            local temp.\r\n            ":"\r\n            将给定的插值字符串重写为处理程序创建和附加呼叫集，返回附加呼叫的数组构建器，结果\r\n            本地温度。\r\n            \r\n","\r\n            Gets the rewritten attribute constructor arguments, i.e. the arguments\r\n            are in the order of parameters, which may differ from the source\r\n            if named constructor arguments are used.\r\n            \r\n            For example:\r\n                void Goo(int x, int y, int z, int w = 3);\r\n            \r\n                Goo(0, z: 2, y: 1);\r\n                \r\n                Arguments returned: 0, 1, 2, 3\r\n            ":"\r\n            获取重写的属性构造函数参数，即参数\r\n            按照参数顺序，可能与源不同\r\n            如果使用命名的构造函数。\r\n            \r\n            例如：\r\n                void goo（int x，int y，int z，int w = 3）;\r\n            \r\n                Goo（0，Z：2，Y：1）;\r\n                \r\n                返回的论点：0、1、2、3\r\n            \r\n","'{0}' is of type '{1}'. The type specified in a constant declaration must be sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, an enum-type, or a reference-type.":"'{0}'是类型'{1}'的'。恒定声明中指定的类型必须为sbyte，字节，短，ushort，int，uint，uint，long，ulong，char，float，float，double，double，Decimal，bool，string，sning，enum-type或参考类型。\r\n","Expected a {0} SemanticModel.":"预期{0} semanticmodel。\r\n","The CallerFilePathAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments":"CallerFilePathAttribute将无效，因为它适用于不允许可选参数的上下文中使用的成员\r\n",".  If the order here is changed\r\n            then those implementations may have to be revised (or simplified).\r\n            ":"。如果此处的订单已更改\r\n            那么这些实现可能必须修改（或简化）。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot create delegate with '{0}' because it or a method it overrides has a Conditional attribute.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串无法创建委托，因为它或它覆盖的方法具有条件属性。\r\n            \r\n","\r\n            Binds:\r\n            1. dynamically, if either side is dynamic\r\n            2. as tuple binary operator, if both sides are tuples of matching cardinalities\r\n            3. as regular binary operator otherwise\r\n            ":"\r\n            绑定：\r\n            1.动态，如果两侧都是动态的\r\n            2.作为元组二进制操作员，如果双方都是匹配红衣的元素\r\n            3.作为常规二进制操作员，否则\r\n            \r\n","\r\n            CONSIDER: It might be nice to generalize this - maybe an extension method\r\n            on Symbol (e.g. IsOverloadable or HidesByName).\r\n            ":"\r\n            考虑一下：概括这一点可能会很好-也许是一种扩展方法\r\n            在符号上（例如IsOverloadable或HidesByName）。\r\n            \r\n","Type '{0}' exported from module '{1}' conflicts with type '{2}' exported from module '{3}'.":"从模块'{1}'导出与类型'{2}'导出从模块'{3}'导出的类型'{0}'。\r\n","Parameter list syntax with surrounding brackets.":"参数列表语法带有周围的括号。\r\n","Extended property patterns":"扩展的属性模式\r\n","\r\n            Returns whether this method is async and returns a task, task-like, or other type with a method-level builder.\r\n            ":"\r\n            返回该方法是异步，并使用方法级构建器返回任务，类似于任务或其他类型。\r\n            \r\n","\r\n            Returns true and a ":"\r\n            返回真实和\r\n","\r\n            Retrieves methods of anonymous type template which are not placed to symbol table.\r\n            In current implementation those are overridden 'ToString', 'Equals' and 'GetHashCode'\r\n            ":"\r\n            检索未放置到符号表的匿名类型模板的方法。\r\n            在当前实施中，这些被覆盖的“ tostring”，“等于”和“ gethashcode”\r\n            \r\n","\r\n            Returns the map from type parameters to type arguments.\r\n            If this is not a generic method instantiation, returns null.\r\n            The map targets the original definition of the method.\r\n            ":"\r\n            将映射从类型参数返回到类型参数。\r\n            如果这不是通用方法实例化，请返回null。\r\n            该地图针对该方法的原始定义。\r\n            \r\n","Called when the visitor visits a OperatorMemberCrefSyntax node.":"当访问者访问OperatorMemberCrefsyntax节点时，请致电。\r\n"," that a continue statement would branch to.\r\n            Returns null otherwise.\r\n            ":" 继续陈述将分支机构。\r\n            否则返回null。\r\n            \r\n","A non-null property on an interface type.":"接口类型的非空属性。\r\n"," node is contained any SyntaxTree in the current Compilation":" 节点在当前汇编中包含任何语法\r\n","\r\n              Looks up a localized string similar to The expression being assigned to '{0}' must be constant.\r\n            ":"\r\n              查找类似于所分配给'{0}'的表达式类似的本地化字符串必须是恒定的。\r\n            \r\n","\r\n            Generates the Current property.\r\n            ":"\r\n            生成当前属性。\r\n            \r\n","Cannot forward type '{0}' because it is a nested type of '{1}'":"无法转发类型'{0}'，因为它是'{1}'的嵌套类型\r\n","\r\n            Element names, if provided. \r\n            ":"\r\n            元素名称（如果提供）。\r\n            \r\n","\r\n            Checks if an applied attribute with the given attributeType matches the namespace name and type name of the given early attribute's description\r\n            and the attribute description has a signature with parameter count equal to the given attribute syntax's argument list count.\r\n            NOTE: We don't allow early decoded attributes to have optional parameters.\r\n            ":"\r\n            检查给定属性的应用属性是否匹配给定早期属性描述的名称名称和类型名称\r\n            并且属性描述具有一个签名，其参数计数等于给定属性语法的参数列表计数。\r\n            注意：我们不允许早期解码属性具有可选参数。\r\n            \r\n","\r\n              Looks up a localized string similar to Field is assigned but its value is never used.\r\n            ":"\r\n              查找与字段类似的本地化字符串，但从未使用其值。\r\n            \r\n","\r\n            A symbol referenced by a cref attribute (e.g. in a <see> or <seealso> documentation comment tag).\r\n            For example, the M in <see cref=\"M\" />.\r\n            ":"\r\n            由CREF属性引用的符号（例如，在A <see>或<Seealso>中，文档评论标签）。\r\n            例如，<请参见cref =“ m” />中的m。\r\n            \r\n","Called when the visitor visits a ConversionOperatorDeclarationSyntax node.":"当访问者访问转换peratodeclarationsyntax节点时，请致电。\r\n","The left-hand operand of the operation (possibly wrapped in a conversion).":"操作的左手操作数（可能包装在转换中）。\r\n","SyntaxToken representing the alias keyword.":"Syntaxtoken表示别名关键字。\r\n","The managed coclass wrapper class '{0}' for interface '{1}' cannot be found (are you missing an assembly reference?)":"无法找到接口'{1}'的托管coclass包装器类'{0}'（您是否缺少汇编引用？）\r\n","Creates a new LineDirectivePositionSyntax instance.":"创建一个新的LinedirectivePositionSynectax实例。\r\n","\r\n            Return an ordering of the compilations referenced in the graph.\r\n            The actual ordering is not important, but we need some ordering\r\n            to compare source locations across different compilations.\r\n            ":"\r\n            返回图中引用的汇编的排序。\r\n            实际订购并不重要，但是我们需要一些订购\r\n            比较跨不同汇编的源位置。\r\n            \r\n","~":"〜\r\n","\r\n             The purpose of this method is to determine if the expression satisfies desired capabilities. \r\n             If it is not then this code gives an appropriate error message.\r\n            \r\n             To determine the appropriate error message we need to know two things:\r\n            \r\n             (1) What capabilities we need - increment it, assign, return as a readonly reference, . . . ?\r\n            \r\n             (2) Are we trying to determine if the left hand side of a dot is a variable in order\r\n                 to determine if the field or property on the right hand side of a dot is assignable?\r\n                 \r\n             (3) The syntax of the expression that started the analysis. (for error reporting purposes).\r\n             ":"\r\n             该方法的目的是确定表达是否满足所需的功能。\r\n             如果不是，则此代码会提供适当的错误消息。\r\n            \r\n             要确定适当的错误消息，我们需要知道两件事：\r\n            \r\n             （1）我们需要什么功能 - 将其递增，分配，返回为可读引用，。 。 。 ？\r\n            \r\n             （2）我们是否试图确定点的左侧是否为变量\r\n                 确定点的右侧的字段或属性是否可分配？\r\n                 \r\n             （3）开始分析的表达式的语法。 （出于错误报告目的）。\r\n             \r\n","Type '{0}' from assembly '{1}' cannot be used across assembly boundaries because it has a generic type argument that is an embedded interop type.":"从汇编'{1}'类型'{0}'不能在汇编边界上使用，因为它具有嵌入式Interop类型的通用类型参数。\r\n","Additional argument":"其他参数\r\n"," is returned. \r\n            ":" 退回。\r\n            \r\n","'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have matching return by reference.":"'{0}'不实现接口成员'{1}'。 '{2}'无法实现'{1}'，因为它没有通过引用匹配返回。\r\n","The DllImport attribute cannot be applied to a method that is generic or contained in a generic method or type.":"dllimport属性不能应用于通用方法或类型中的通用方法或包含的方法。\r\n","\r\n            If the type is a non-generic value type or Nullable<>, and\r\n            is not a type parameter, the nullability is not included in the byte[].\r\n            ":"\r\n            如果该类型是非传播值类型或可确定的<>，并且\r\n            不是类型的参数，不包含在字节[]中。\r\n            \r\n","\r\n            Writes information about metadata references to the pdb so the same\r\n            reference can be found on sourcelink to create the compilation again\r\n            ":"\r\n            写有关元数据引用PDB的信息\r\n            可以在Sourcelink上找到参考，以再次创建汇编\r\n            \r\n","\r\n            Type of left operand is used.\r\n            ":"\r\n            使用左操作数的类型。\r\n            \r\n","\r\n            Represents a baking field for an anonymous type template property symbol.\r\n            ":"\r\n            代表匿名类型模板属性符号的烘焙字段。\r\n            \r\n"," modifier. Also set for\r\n            types that do not allow a derived class (declared with ":"修饰符。也设定\r\n            不允许派生类的类型（声明\r\n"," is a BoundBadExpression, then it is updated with the ":" 是boundbadexpression，然后将其更新\r\n","Defining an alias named 'global' is ill-advised since 'global::' always references the global namespace and not an alias":"定义一个名为“全局”的别名自全局::'始终引用全局名称空间而不是别名，这是不明智的\r\n","The type '{0}' is defined in an assembly that is not referenced. You must add a reference to assembly '{1}'.":"类型的“ {0}”是在未引用的汇编中定义的。您必须将引用添加到汇编'{1}'中。\r\n","\r\n            Returns a value indicating whether this builder has a symbol that needs IsReadOnlyAttribute to be generated during emit phase.\r\n            The value is set during lowering the symbols that need that attribute, and is frozen on first trial to get it.\r\n            Freezing is needed to make sure that nothing tries to modify the value after the value is read.\r\n            ":"\r\n            返回一个值，指示该构建器是否具有在EMIT阶段生成的需要的符号。\r\n            该值是在降低需要属性的符号期间设置的，并在第一次试验中冻结以获取它。\r\n            需要冻结以确保在读取值后没有试图修改值。\r\n            \r\n","\r\n            Creates a seealso element within an xml documentation comment.\r\n            ":"\r\n            在XML文档注释中创建SEEALSO元素。\r\n            \r\n","An IEnumerable containing all the types that are members of this symbol with the given name and arity.\r\n            If this symbol has no type members with this name and arity,\r\n            returns an empty IEnumerable. Never returns null.":"一个具有给定名称和arity的符号的所有类型的iEnumerable。\r\n            如果此符号没有此名称和arity的类型成员，\r\n            返回一个空的iEnumerable。永远不会返回零。\r\n","\r\n              Looks up a localized string similar to Interop type '{0}' cannot be embedded. Use the applicable interface instead..\r\n            ":"\r\n              查找类似于Interop类型'{0}'的本地化字符串，无法嵌入。改用适用的接口。\r\n            \r\n","\r\n            Variables that were used anywhere, in the sense required to suppress warnings about\r\n            unused variables.\r\n            ":"\r\n            从任何地方使用的变量，就抑制警告所需的意义\r\n            未使用的变量。\r\n            \r\n","Called when the visitor visits a JoinIntoClauseSyntax node.":"当访问者访问JoinIntoClausesyntax节点时，请致电。\r\n","'{0}': cannot override because '{1}' is not a function":"'{0}'：不能覆盖，因为'{1}不是一个函数\r\n","An invalid character was found inside an entity reference.":"在实体参考中发现了无效的字符。\r\n","\r\n            Represents source or metadata assembly.\r\n            ":"\r\n            代表源或元数据组件。\r\n            \r\n","Called when the visitor visits a DiscardPatternSyntax node.":"当访客访问doverpatternsyntax节点时，请致电。\r\n","The right hand side of a fixed statement assignment may not be a cast expression":"固定语句分配的右侧可能不是演员表达式\r\n","Using a field of a marshal-by-reference class as a ref or out value or taking its address may cause a runtime exception":"将逐个参考类的字段用作ref或淘汰价值或占用其地址的字段可能会导致运行时异常\r\n","\r\n              Looks up a localized string similar to A generic type cannot derive from '{0}' because it is an attribute class.\r\n            ":"\r\n              查找类似于通用类型的本地化字符串不能源自“ {0}”，因为它是属性类。\r\n            \r\n","\r\n            The candidate member was rejected because it was an instance member accessed from a type,\r\n            or a static member accessed from an instance.\r\n            ":"\r\n            候选人成员被拒绝，因为它是从类型访问的实例成员，\r\n            或从实例访问的静态成员。\r\n            \r\n","\r\n            Represents a type parameter that is based on another type parameter.\r\n            When inheriting from this class, one shouldn't assume that \r\n            the default behavior it has is appropriate for every case.\r\n            That behavior should be carefully reviewed and derived type\r\n            should override behavior as appropriate.\r\n            ":"\r\n            表示基于其他类型参数的类型参数。\r\n            从这个课程继承时，不应该假设\r\n            它具有的默认行为适用于每种情况。\r\n            该行为应仔细审查和派生类型\r\n            应适当地覆盖行为。\r\n            \r\n","The Guid attribute must be specified with the ComImport attribute":"必须使用Comimport属性指定GUID属性\r\n","\r\n            We use _exprReturnLabel for normal end of method (ie. no more values) and `yield break;`.\r\n            We use _exprReturnLabelTrue for `yield return;`.\r\n            ":"\r\n            我们使用_EXPRRETURNLABEL用于方法的正常末端（即没有更多值）和`屈服折断;'。\r\n            我们使用_EXPRRETURNLABELTRUE进行'屈服回报;'。\r\n            \r\n"," wrapping ":" 包装\r\n","The xml entity value.":"XML实体值。\r\n","The incremental generators to create this driver with":"使用的增量发电机来创建此驱动程序\r\n","Source Generator v2 APIs":"源发电机V2 API\r\n","\r\n              Looks up a localized string similar to A result of a stackalloc expression of type '{0}' cannot be used in this context because it may be exposed outside of the containing method.\r\n            ":"\r\n              在此上下文中查找类似于“ {0}”类型的stackalloc表达式的结果的局部字符串，因为它可以在包含方法之外暴露。\r\n            \r\n","[TypeForwardedToAttribute]":"[typeforwardedtoattribute]\r\n","The syntax to attach to the bound nodes produced":"附着在产生的结合节点上的语法\r\n","\r\n            The nested function that this scope is nested inside. Null if this scope is not nested\r\n            inside a nested function.\r\n            ":"\r\n            该范围嵌套在内部的嵌套函数。无效，如果此范围不嵌套\r\n            在嵌套功能中。\r\n            \r\n","\r\n            Returns true if the type is a struct with no fields or properties.\r\n            ":"\r\n            如果类型是没有字段或属性的结构，则返回true。\r\n            \r\n","Expected ; or = (cannot specify constructor arguments in declaration)":"预期的 ;或=（声明中无法指定构造函数）\r\n","\r\n              Looks up a localized string similar to CallerLineNumberAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'.\r\n            ":"\r\n              查找类似于CallerlineNumberAttribute的本地化字符串，因为从类型'{0}'type'{1}'类型中没有标准转换。\r\n            \r\n","\r\n            Events imported from metadata can explicitly implement more than one event.\r\n            ":"\r\n            从元数据中导入的事件可以明确实施多个事件。\r\n            \r\n","Possible mistaken empty statement":"可能错误的空语句\r\n"," is true when the set is considered\r\n            to contain all values greater than ":" 当考虑集合时是真的\r\n            包含大于\r\n","\r\n            The immediately containing namespace or named type, or the global\r\n            namespace if containing symbol is neither a namespace or named type.\r\n            ":"\r\n            立即包含名称空间或命名类型或全局\r\n            名称空间如果包含符号既不是名称空间，也不是命名类型。\r\n            \r\n","\r\n              Looks up a localized string similar to Deconstruct assignment requires an expression with a type on the right-hand-side..\r\n            ":"查找类似于解构分配的本地化字符串需要一个表达式，并在右侧的类型上。\r\n            \r\n","Note that any of the child nodes may be null.":"请注意，任何儿童节点都可能为无效。\r\n","Embedded interop struct '{0}' can contain only public instance fields.":"嵌入式Interop struct'{0}'只能包含公共实例字段。\r\n","Gets the constraints list.":"获取约束列表。\r\n","\r\n            Creates a SemanticModel for a constructor initializer (\": this(...)\" or \": base(...)\").\r\n            ":"\r\n            为构造函数初始器（“：this（...）”或“：base（...）”创建smanticmodel。\r\n            \r\n","The set of original locals that should be assigned to proxies if lifted":"如果提起，应分配给代理的原始当地人集\r\n","\r\n            Is a protected symbol inside \"originalContainingType\" accessible from within \"within\",\r\n            which much be a named type or an assembly.\r\n            ":"\r\n            是从“内部”内部访问的“ Original -ContainingType”内部的受保护符号\r\n            这是一个命名类型或一个组件。\r\n            \r\n","The compilation to reference.":"参考的汇编。\r\n","Assembly name override, if specified. Otherwise the ":"汇编名称覆盖（如果指定）。否则\r\n","\r\n              Looks up a localized string similar to Comparing with null of struct type always produces 'false'.\r\n            ":"\r\n              查找类似于与结构类型的null相似的本地化字符串总是会产生“ false”。\r\n            \r\n","\r\n            Declaration locations for individual elements, if provided.\r\n            Declaration location for this tuple type symbol\r\n            ":"\r\n            如果提供的话，单个要素的声明地点。\r\n            此元组类型符号的声明位置\r\n            \r\n","Member '{0}' must have a non-null value when exiting with '{1}'.":"使用'{1}'退出时，成员'{0}'必须具有非零值。\r\n","\r\n              Looks up a localized string similar to Use of unassigned out parameter '{0}'.\r\n            ":"\r\n              查找类似于使用未分配的参数'{0}'的本地化字符串。\r\n            \r\n","An optional sequence of whitespace characters that defines a\r\n            single level of indentation.":"白空间字符的可选序列，该字符定义\r\n            单级压痕。\r\n","\r\n            The set of interfaces explicitly declared on the containing type\r\n            parameter and any type parameters on which the containing\r\n            type parameter depends, with duplicates removed.\r\n            ":"\r\n            在包含类型上明确声明的一组接口\r\n            参数和包含的任何类型参数\r\n            类型参数取决于，删除了重复项。\r\n            \r\n","\r\n            Returns true if this method hides base methods by name. This cannot be specified directly\r\n            in the C# language, but can be true for methods defined in other languages imported from\r\n            metadata. The equivalent of the \"hidebyname\" flag in metadata.\r\n            ":"\r\n            如果此方法用名称隐藏基本方法，则返回true。这不能直接指定\r\n            在c＃语言中，但对于以从其他语言定义的方法可能是正确的\r\n            元数据。等效于元数据中的“ hidebyname”标志。\r\n            \r\n","\r\n            This is a special binder used for decoding some special well-known attributes very early in the attribute binding phase.\r\n            It only binds those attribute argument syntax which can produce valid attribute arguments, but doesn't report any diagnostics.\r\n            Subsequent binding phase will rebind such erroneous attributes and generate appropriate diagnostics.\r\n            ":"\r\n            这是一种特殊的粘合剂，用于在属性结合阶段很早就解码一些特殊知名属性。\r\n            它仅结合那些可以产生有效属性参数但不报告任何诊断的属性参数语法。\r\n            随后的结合阶段将重新定义此类错误的属性并生成适当的诊断。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid option '{0}' for /langversion. Use '/langversion:?' to list supported values..\r\n            ":"\r\n              查找类似于 /langversion的无效选项'{0}'的本地化字符串。使用'/langversion：？'列出支持的值。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot assign to {0} '{1}' because it is a readonly variable.\r\n            ":"\r\n              查找类似于{0}'{1}'的本地化字符串，因为它是一个可读变量。\r\n            \r\n"," contains an instance field of type ":" 包含一个类型的实例字段\r\n","An expression that produces the value of the original input if needed\r\n            by the caller.":"如果需要的话，可以产生原始输入值的表达式\r\n            由呼叫者。\r\n","Assembly does not contain any analyzers":"组装不包含任何分析仪\r\n","\r\n            Merges nullability.\r\n            ":"\r\n            合并无效。\r\n            \r\n","An expression tree may not contain an assignment operator":"表达树可能不包含分配操作员\r\n","(null, ...) == (null, ...)":"（null，...）==（null，...）\r\n","For example ":"例如\r\n",", this method should be called to perform the\r\n            state setting and to ensure the mutation is visible outside the finally block when the mutation occurs in a\r\n            finally block.\r\n            ":"，应调用此方法执行\r\n            状态设置并确保在突变发生在A中的突变时，最终可见突变\r\n            最后阻止。\r\n            \r\n","SyntaxToken representing less than.":"Syntaxtoken代表少于。\r\n","\r\n            A location path is considered mapped if the first ":"\r\n            如果第一次，则考虑映射位置路径\r\n","\r\n            Visit all the closures and return true when the ":"\r\n            访问所有关闭，并在\r\n","\r\n            The compilation this object was obtained from.\r\n            ":"\r\n            该对象的汇编是从中获得的。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' in explicit interface declaration is not found among members of the interface that can be implemented.\r\n            ":"\r\n              在可以实现的接口成员中找不到类似于“显式接口声明”中类似于“ {0}”的本地化字符串。\r\n            \r\n","Gets the name of the tuple element.":"获取元组元素的名称。\r\n","The leading trivia of the token.":"代币的主要琐事。\r\n","\r\n            A utility class that is used to scan a when clause to determine if it might assign a variable,\r\n            directly or indirectly. Used to determine if we can skip the allocation of pattern-matching\r\n            temporary variables and use user-declared variables instead, because we can conclude that they\r\n            are not mutated while the pattern-matching automaton is running.\r\n            ":"\r\n            用来扫描A时的实用程序类，以确定是否可以分配变量，\r\n            直接或间接。用于确定我们是否可以跳过模式匹配的分配\r\n            临时变量并使用用户宣布的变量，因为我们可以得出结论，\r\n            当模式匹配自动机运行时，未突变。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': static classes cannot contain user-defined operators.\r\n            ":"\r\n              查找类似于“ {0}'：静态类别的本地化字符串：静态类不能包含用户定义的运算符。\r\n            \r\n","\r\n            Compute the set of remaining tests for a pattern.\r\n            ":"\r\n            计算图案的剩余测试集。\r\n            \r\n",", this class performs a quick\r\n            traversal of the symbol table and performs processing of synthesized symbols if necessary\r\n            ":"，这堂课很快\r\n            符号表的遍历，并在必要时执行综合符号的处理\r\n            \r\n","\r\n            Closes the visibility/debug scopes for the sequence locals, but keep the local slots from reuse\r\n            for the duration of the encompassing expression.\r\n            Use this paired with DefineAndRecordLocals when taking a reference of the sequence, which can indirectly refer to any of its locals.\r\n            ":"\r\n            关闭序列当地人的可见性/调试范围，但请防止本地插槽重复使用\r\n            在包含表达式的持续时间内。\r\n            当序列参考时，请使用与DefineAndrecordLocals配对的，该序列可以间接地指其任何当地人。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' cannot implement both '{1}' and '{2}' because they may unify for some type parameter substitutions.\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串不能同时实现'{1}'和'{2}'，因为它们可以统一某种类型的参数替换。\r\n            \r\n","\r\n            Method group conversions are described in section 6.6 of the C# language specification.\r\n            User-defined conversions are described in section 6.4 of the C# language specification.\r\n            ":"\r\n            方法组转换在C＃语言规范的第6.6节中描述。\r\n            用户定义的转换在C＃语言规范的第6.4节中描述。\r\n            \r\n","\r\n              Looks up a localized string similar to A using clause must precede all other elements defined in the namespace except extern alias declarations.\r\n            ":"\r\n              查找类似于使用子句的本地化字符串必须先于名称空间中定义的所有其他元素，除了外部别名声明。\r\n            \r\n","Named attribute argument expected":"命名属性参数预期\r\n","\r\n            Returns false because label can't be abstract.\r\n            ":"\r\n            返回错误，因为标签不能抽象。\r\n            \r\n","\r\n            Get all the members of this symbol that are types. The members may not be in a particular order, and the order\r\n            may not be stable from call-to-call.\r\n            ":"\r\n            获取此符号的所有成员是类型。成员可能不按特定顺序和订单\r\n            通话通话可能不稳定。\r\n            \r\n","\r\n            Parse a BracketedParameterListSyntax node.\r\n            ":"\r\n            解析一个括号标准级列表节点。\r\n            \r\n","Creates a new LiteralExpressionSyntax instance.":"创建一个新的LiteraleXpressionsyntax实例。\r\n","\r\n            Returns a non-null ":"\r\n            返回非效果\r\n","\r\n              Looks up a localized string similar to The syntax 'var (...)' as an lvalue is reserved..\r\n            ":"\r\n              查找类似于语法“ var（...）”的本地化字符串，因为保留了lvalue。\r\n            \r\n","\r\n            Given a position, locates the containing token.  If the position is actually within the\r\n            leading trivia of the containing token or if that token is EOF, moves one token to the\r\n            left.  Returns the start position of the resulting token.\r\n            \r\n            This has the effect of moving the position left until it hits the beginning of a non-EOF\r\n            token.\r\n            \r\n            Throws an ArgumentOutOfRangeException if position is not within the root of this model.\r\n            ":"\r\n            给定位置，定位包含令牌。如果位置实际上在\r\n            包含令牌的领先琐事或如果该令牌为EOF，则将一个令牌移至\r\n            左边。返回产生令牌的开始位置。\r\n            \r\n            这具有移动左侧位置，直到它撞到非EOF的开始\r\n            令牌。\r\n            \r\n            如果位置不在此模型的根源之内，则会引发一个参数OutofrangeException。\r\n            \r\n","\r\n            True if the type itself is excluded from code covarage instrumentation.\r\n            True for source types marked with ":"\r\n            如果将类型本身排除在CODOVARAGE仪器中，则为true。\r\n            标记为源类型\r\n","\r\n            True if the initial values of locals in the rewritten method need to be preserved. (e.g. enumerable iterator methods)\r\n            ":"\r\n            正确，如果需要保留重写方法中当地人的初始值。 （例如枚举迭代器方法）\r\n            \r\n","\r\n              Looks up a localized string similar to A declaration is not allowed in this context..\r\n            ":"\r\n              在这种情况下，不允许查找类似于声明的本地化字符串。\r\n            \r\n",", which performs an analogous task for LookupSymbols*.\r\n            ":"，它为LookupSymbols*执行类似的任务。\r\n            \r\n","(var x, int y) = ...":"（var x，int y）= ...\r\n","\r\n            Find any deconstruction locals that are still pending inference and fail their inference.\r\n            Set the safe-to-escape scope for all deconstruction locals.\r\n            ":"\r\n            找到仍在推论并失败推理的任何解构当地人。\r\n            为所有解构当地人设置安全的示波范围。\r\n            \r\n","\r\n            Gets the return type of the method along with its annotations\r\n            ":"\r\n            获取该方法的返回类型及其注释\r\n            \r\n","\r\n            Get the constructed task for a Task-returning or Task<T>-returning async method.\r\n            ":"\r\n            获取用于返回任务或任务<t>返回异步方法的构造任务。\r\n            \r\n",", to hide its implementation of ":"，隐藏其实施\r\n","\r\n            Parse a named member (method, property, etc), with optional type\r\n            parameters and regular parameters.\r\n            ":"\r\n            解析具有可选类型的命名成员（方法，属性等）\r\n            参数和常规参数。\r\n            \r\n","\r\n            Is the named type ":"\r\n            是命名类型\r\n","\r\n            Creates a syntax node for a name attribute in a xml element within a xml documentation comment.\r\n            ":"\r\n            在XML文档注释中，在XML元素中为名称属性创建语法节点。\r\n            \r\n","The first operand of an overloaded shift operator must have the same type as the containing type, and the type of the second operand must be int":"超载移动操作员的第一台操作数必须具有与包含类型相同的类型，第二个操作数的类型必须为int\r\n","\r\n            A parenthesized list of cref parameters.\r\n            ":"\r\n            CREF参数的括号列表。\r\n            \r\n","Control cannot leave the body of a finally clause":"控制不能离开最终条款的身体\r\n"," with no known type, given lookupResultKind and given symbols for GetSemanticInfo API,\r\n            and the given bound children.\r\n            ":" 没有已知类型，给定LookupResultKind并给出了GetManticinfo API的符号，\r\n            和给定的孩子。\r\n            \r\n","\r\n            Gets a SyntaxToken that represents the if keyword.\r\n            ":"\r\n            获取代表if关键字的语法。\r\n            \r\n","\r\n            Bind a CrefSyntax and unwrap the result if it's an alias.\r\n            ":"\r\n            绑定crefsyntax，如果是别名，则将结果解开。\r\n            \r\n","\r\n              Looks up a localized string similar to The type name '{0}' could not be found in the namespace '{1}'. This type has been forwarded to assembly '{2}' Consider adding a reference to that assembly..\r\n            ":"\r\n              查找类似于类型名称'{0}'的本地化字符串在名称空间'{1}'中找不到。这种类型已转发到汇编'{2}'考虑对该汇编的引用。\r\n            \r\n","\r\n            Because syntax nodes need to be constructed with context information - to allow us to \r\n            determine whether or not they can be reused during incremental parsing - the syntax\r\n            factory needs a view of some internal parser state.\r\n            ":"\r\n            因为语法节点需要使用上下文信息构建 - 以便我们\r\n            确定在增量解析过程中是否可以重复使用它们 - 语法\r\n            工厂需要一些内部解析器状态的视图。\r\n            \r\n","The language keyword to which the see element points to.":"See元素指向的语言关键字。\r\n","\r\n             Creates a new compilation with the specified references.\r\n             ":"\r\n             使用指定的引用创建新的汇编。\r\n             \r\n","Added modules must be marked with the CLSCompliant attribute to match the assembly":"添加的模块必须用CLSCompliant属性标记以匹配汇编\r\n","The /doc compiler option was specified, but one or more constructs did not have comments.":"指定了 /DOC编译器选项，但是一个或多个构造没有评论。\r\n","Comparison to integral constant is useless; the constant is outside the range of type '{0}'":"与整体常数进行比较是没有用的；常数不在类型'{0}'的范围之外\r\n","Don't call this during a parse--it loads resources":"在分析期间不要称呼它 - 它加载资源\r\n","\r\n              Looks up a localized string similar to default operator.\r\n            ":"\r\n              查找类似于默认操作员的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid type for parameter {0} in XML comment cref attribute: '{1}'.\r\n            ":"\r\n              在XML注释CREF属性中查找类似于参数{0}的无效类型的本地化字符串：'{1}'。\r\n            \r\n","\r\n            An ErrorSymbol is used when the compiler cannot determine a symbol object to return because\r\n            of an error. For example, if a field is declared \"Foo x;\", and the type \"Foo\" cannot be\r\n            found, an ErrorSymbol is returned when asking the field \"x\" what it's type is.\r\n            ":"\r\n            当编译器无法确定要返回的符号对象时，请使用错误符号\r\n            错误。例如，如果字段声明为“ foo x”；而类型“ foo”不能为\r\n            发现，当询问字段“ x”字段时，将返回一个错误符号。\r\n            \r\n","\r\n            Used for parameters of partial implementation. We bind the attributes only on the definition\r\n            part and copy them over to the implementation.\r\n            ":"\r\n            用于部分实现的参数。我们仅在定义上绑定属性\r\n            部分并将其复制到实施中。\r\n            \r\n","\r\n             The Meet operation is the inverse of ":"\r\n             聚会操作是相反的\r\n"," applied on the containing module.\r\n            ":" 应用于包含的模块。\r\n            \r\n","\r\n            Helper that will use Array.Empty if available and elements have 0 length\r\n            NOTE: it is valid only if we know that the API that is being called will not\r\n                  retain or use the array argument for any purpose (like locking or key in a hash table)\r\n                  Typical example of valid use is Linq.Expressions factories - they do not make any\r\n                  assumptions about array arguments and do not keep them or rely on their identity.\r\n            ":"\r\n            将使用阵列的助手，如果可用，empty且元素具有0长度的长度\r\n            注意：仅当我们知道被称为的API不会\r\n                  保留或为任何目的保留数组参数（例如锁定或在哈希表中锁定）\r\n                  有效使用的典型示例是Linq.Expressions工厂 - 它们不做任何\r\n                  关于数组论点的假设，不保留它们或依靠它们的身份。\r\n            \r\n","\r\n              Looks up a localized string similar to Interfaces cannot contain operators.\r\n            ":"\r\n              查找类似于接口的本地化字符串不能包含操作员。\r\n            \r\n","\r\n              Looks up a localized string similar to A '{0}' character must be escaped (by doubling) in an interpolated string..\r\n            ":"必须在插值字符串中查找类似于“ {0}”字符的本地化字符串。\r\n            \r\n","\r\n            Returns whether the reference type constraint (the 'class' constraint) should also be treated as nullable ('class?') or non-nullable (class!).\r\n            In some cases this aspect is unknown (null value is returned). For example, when 'class' constraint is specified in a NonNullTypes(false) context.  \r\n            This API returns false when ":"\r\n            返回参考类型约束（“类”约束）是否也应视为无效（“ class？'）或不可删除（class！）。\r\n            在某些情况下，此方面未知（返回零值）。例如，当在非杀手（false）上下文中指定“类”约束时。\r\n            此API返回false时\r\n","\r\n            to use the ":"\r\n            使用\r\n","\r\n            entryPointOpt is only considered for synthesized methods (to recognize the synthesized MoveNext method for async Main)\r\n            ":"\r\n            仅考虑综合方法的EntryPointOpt（识别异步主的合成moveNEXT方法）\r\n            \r\n","The text contents of a part of the interpolated string.":"插值字符串一部分的文本内容。\r\n","\r\n              Looks up a localized string similar to Auto-implemented property '{0}' must be fully assigned before control is returned to the caller..\r\n            ":"\r\n              查找类似于自动实施属性'{0}'的本地化字符串，必须在将控件返回到呼叫者之前完全分配。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot return a value from an iterator. Use the yield return statement to return a value, or yield break to end the iteration..\r\n            ":"\r\n              查找类似于类似的本地化字符串无法从迭代器返回值。使用收益率回报说明返回值或收益率中断以结束迭代。\r\n            \r\n","User-defined operator cannot convert a type to itself":"用户定义的操作员无法将类型转换为自身\r\n","\r\n            This kind of the hiding member.\r\n            ":"\r\n            这种隐藏成员。\r\n            \r\n","\r\n            Returns true if this method is an extension method.\r\n            ":"\r\n            如果此方法是扩展方法，则返回true。\r\n            \r\n","\r\n            If this method is a reduced extension method, returns the extension method that\r\n            should be used at call site during ILGen. Otherwise, returns null.\r\n            ":"\r\n            如果此方法是减少的扩展方法，请返回扩展方法\r\n            应在伊尔根期间在呼叫站点使用。否则，返回null。\r\n            \r\n","\r\n            Guaranteed not to return null.\r\n            \r\n            CONSIDER: As in dev11, we don't handle ambiguity at this level.  Hypothetically,\r\n            we could just pick one, though an \"ideal\" solution would probably involve a search\r\n            down all ambiguous branches.\r\n            ":"\r\n            保证不要返回null。\r\n            \r\n            考虑：就像在DEV11中一样，我们在此级别上不处理歧义。假设，\r\n            我们可以选择一个，尽管“理想”解决方案可能涉及搜索\r\n            下来所有模棱两可的分支。\r\n            \r\n","\r\n            Make a variable for a declaration expression other than a deconstruction left-hand-side. The only\r\n            other legal place for a declaration expression today is an out variable declaration; this method\r\n            handles that and the error cases as well.\r\n            ":"\r\n            除了解构左侧的解构表达式以外的声明表达式变量。唯一的\r\n            当今声明表达的其他法律场所是一份变量的声明；这个方法\r\n            处理该问题和错误情况。\r\n            \r\n","). \r\n            ":"）。\r\n            \r\n","\r\n            Returns true if the conversion is a conversion to or from IntPtr or UIntPtr.\r\n            ":"\r\n            如果转换是往返INTPTR或UINTPTR的转换，则返回true。\r\n            \r\n","Creates a new CasePatternSwitchLabelSyntax instance.":"创建一个新的casepatternswitchlabelsyntax实例。\r\n","\r\n            For performance reason, we don't validate the input length parameter and the returned offset value against negative values.\r\n            we don't validate either the returned offset is greater than the input length.\r\n            It is expected Index will be used with collections which always have non negative length/count. If the returned offset is negative and\r\n            then used to index a collection will get out of range exception which will be same affect as the validation.\r\n            ":"\r\n            出于性能原因，我们没有验证输入长度参数和返回的偏移值针对负值。\r\n            我们不验证返回的偏移量大于输入长度。\r\n            预计索引将与始终具有非负长度/计数的集合一起使用。如果返回偏移为负，并且\r\n            然后用来索引集合将脱离范围异常，这将与验证相同。\r\n            \r\n","\r\n            This portion of the binder converts an ":"\r\n            粘合剂的这一部分转换\r\n","\r\n            Given an variable declarator syntax, get the corresponding symbol.\r\n            ":"\r\n            给定可变声明语法，获取相应的符号。\r\n            \r\n","\r\n            Get this accessibility that was declared on this symbol. For symbols that do not have\r\n            accessibility declared on them, returns NotApplicable.\r\n            ":"\r\n            获取此符号上声明的可访问性。对于没有的符号\r\n            在他们上声明的可访问性，返回无关紧要。\r\n            \r\n","Called when the visitor visits a ElseDirectiveTriviaSyntax node.":"当访客访问ELSedirectivtRiviaSyntax节点时，请致电。\r\n","Global analyzer config section name is invalid as it is not an absolute path. Section will be ignored.":"Global Analyzer配置部分名称无效，因为它不是绝对路径。节将被忽略。\r\n","\r\n            ReferenceManager encapsulates functionality to create an underlying SourceAssemblySymbol \r\n            (with underlying ModuleSymbols) for Compilation and AssemblySymbols for referenced\r\n            assemblies (with underlying ModuleSymbols) all properly linked together based on\r\n            reference resolution between them.\r\n            \r\n            ReferenceManager is also responsible for reuse of metadata readers for imported modules\r\n            and assemblies as well as existing AssemblySymbols for referenced assemblies. In order\r\n            to do that, it maintains global cache for metadata readers and AssemblySymbols\r\n            associated with them. The cache uses WeakReferences to refer to the metadata readers and\r\n            AssemblySymbols to allow memory and resources being reclaimed once they are no longer\r\n            used. The tricky part about reusing existing AssemblySymbols is to find a set of\r\n            AssemblySymbols that are created for the referenced assemblies, which (the\r\n            AssemblySymbols from the set) are linked in a way, consistent with the reference\r\n            resolution between the referenced assemblies.\r\n            \r\n            When existing Compilation is used as a metadata reference, there are scenarios when its\r\n            underlying SourceAssemblySymbol cannot be used to provide symbols in context of the new\r\n            Compilation. Consider classic multi-targeting scenario: compilation C1 references v1 of\r\n            Lib.dll and compilation C2 references C1 and v2 of Lib.dll. In this case,\r\n            SourceAssemblySymbol for C1 is linked to AssemblySymbol for v1 of Lib.dll. However,\r\n            given the set of references for C2, the same reference for C1 should be resolved against\r\n            v2 of Lib.dll. In other words, in context of C2, all types from v1 of Lib.dll leaking\r\n            through C1 (through method signatures, etc.) must be retargeted to the types from v2 of\r\n            Lib.dll. In this case, ReferenceManager creates a special RetargetingAssemblySymbol for\r\n            C1, which is responsible for the type retargeting. The RetargetingAssemblySymbols could\r\n            also be reused for different Compilations, ReferenceManager maintains a cache of\r\n            RetargetingAssemblySymbols (WeakReferences) for each Compilation.\r\n            \r\n            The only public entry point of this class is CreateSourceAssembly() method.\r\n            ":"\r\n            ReferenceMemanager封装功能以创建基础源筛选\r\n            （带有基础模块符号）用于参考的编译和组合符号\r\n            组件（带有基础模块符号）都根据\r\n            它们之间的参考分辨率。\r\n            \r\n            ReferenceManager还负责重复使用元数据读取器的导入模块\r\n            和组件以及参考组件的现有组合符号。为了\r\n            为此，它维护元数据读取器和汇编符号的全局缓存\r\n            与它们关联。缓存使用虚弱的参考来参考元数据读取器和\r\n            汇编符号允许记忆和资源不再是回收的记忆和资源\r\n            用过的。重用现有汇编符号的棘手部分是找到一组\r\n            为引用的组件创建的汇编符号，\r\n            集合中的汇编符号以某种方式链接，与参考\r\n            参考组件之间的分辨率。\r\n            \r\n            当现有汇编用作元数据参考时，存在某些情况\r\n            潜在的源质膜符号不能用于在新的背景下提供符号\r\n            汇编。考虑经典的多目标场景：汇编C1参考v1\r\n            lib.dll和汇编C2参考文献C1和v2的lib.dll。在这种情况下，\r\n            C1的sureceassemblysymbol链接到lib.dll的V1的汇编符号。然而，\r\n            鉴于C2的一组参考，应针对C1的相同参考\r\n            lib.dll的v2。换句话说，在C2的背景下，lib.dll的V1的所有类型泄漏\r\n            通过C1（通过方法签名等）必须将其重新定位到来自V2的类型\r\n            lib.dll。在这种情况下，ReferenceManager为\r\n            C1，负责重新定位类型。 retargetingAssemblysymbols可以\r\n            也可以重复用于不同的汇编，ReferenceMemanager维护\r\n            每次汇编的retargetingAssemblysymbols（弱转录）。\r\n            \r\n            该类的唯一公共入口点是CreateSourCeassembly（）方法。\r\n            \r\n","\r\n            True if there was a ":"\r\n            如果有一个\r\n","Feature '{0}' is not available in C# 4. Please use language version {1} or greater.":"C＃4中不可用功能'{0}'使用语言版本{1}或更大。\r\n","Called when the visitor visits a LockStatementSyntax node.":"访问者访问lockstatementsyntax节点时调用。\r\n","\r\n            Used by the generated ":"\r\n            由生成的\r\n","The 'init' accessor is not valid on static members":"“ init”登录器对静态成员无效\r\n","\r\n              Looks up a localized string similar to Source file '{0}' could not be opened -- {1}.\r\n            ":"\r\n              无法打开类似于源文件'{0}'的本地化字符串 -  {1}。\r\n            \r\n","\r\n             The left represents a tree of L-values. The structure of right can be missing parts of the tree on the left.\r\n             The conversion holds nested conversisons and deconstruction information, which matches the tree from the left,\r\n             and it provides the information to fill in the missing parts of the tree from the right and convert it to\r\n             the tree from the left.\r\n            \r\n             A bound sequence is returned which has different phases of side-effects:\r\n             - the initialization phase includes side-effects from the left, followed by evaluations of the right\r\n             - the deconstruction phase includes all the invocations of Deconstruct methods and tuple element accesses below a Deconstruct call\r\n             - the conversion phase\r\n             - the assignment phase\r\n             ":"\r\n             左代表一棵L值树。右侧的结构可能缺少左侧的树的部分。\r\n             转换包含嵌套的对话和解构信息，与左侧的树相匹配，\r\n             它提供了信息以填充右侧的树的缺失部分，然后将其转换为\r\n             左边的树。\r\n            \r\n             返回一个结合序列，该序列具有不同的副作用阶段：\r\n              - 初始化阶段包括左侧的副作用，然后对右侧进行评估\r\n              - 解构阶段包括解构方法和元组元素访问的所有调用\r\n              - 转换阶段\r\n              - 作业阶段\r\n             \r\n","\r\n            Returns true if the expression should be used as the source when calculating\r\n            a conversion from this expression, rather than using the type (with nullability)\r\n            calculated by visiting this expression. Typically, that means expressions that\r\n            do not have an explicit type but there are several other cases as well.\r\n            (See expressions handled in ClassifyImplicitBuiltInConversionFromExpression.)\r\n            ":"\r\n            如果在计算时应将表达式用作源，则返回true\r\n            来自此表达式的转换，而不是使用类型（无效）\r\n            通过访问此表达方式计算。通常，这意味着表达\r\n            没有明确的类型，但还有其他几种情况。\r\n            （请参阅在分类构成的fromexpress中处理的表达式。）\r\n            \r\n","Class which represents the syntax node for predefined types.":"代表预定义类型的语法节点的类。\r\n","An object reference is required for the non-static field, method, or property '{0}'":"非静态字段，方法或属性'{0}'需要对象引用\r\n","A readonly field cannot be assigned to (except in a constructor or init-only setter of the type in which the field is defined or a variable initializer)":"无法分配一个可读字段（除了定义该字段或可变初始化器的类型的构造函数或启动设置器以外）\r\n","\r\n            A walker that computes the set of local variables of an iterator/async\r\n            method that must be hoisted to the state machine.\r\n            ":"\r\n            计算迭代器/异步的局部变量集的步行者\r\n            必须将其吊到状态机器的方法。\r\n            \r\n","\r\n            Returns true if this type is known to be a value type. It is never the case that\r\n            IsReferenceType and IsValueType both return true. However, for an unconstrained type\r\n            parameter, IsReferenceType and IsValueType will both return false.\r\n            ":"\r\n            如果已知该类型是值类型，则返回true。从来没有这样\r\n            ISREFERENCETYPE和ISVALUETYPE都返回true。但是，对于不受约束的类型\r\n            参数，IsReferenceType和ISVALUETYPE都将返回false。\r\n            \r\n"," instead! \r\n            If used, a unit-test with a missing member is absolutely a must have.\r\n            ":" 反而！\r\n            如果使用，则必须拥有带有失踪成员的单位测试。\r\n            \r\n","\r\n            Lower a foreach loop that will enumerate a multi-dimensional array.\r\n            \r\n            A[...] a = x;\r\n            int q_0 = a.GetUpperBound(0), q_1 = a.GetUpperBound(1), ...;\r\n            for (int p_0 = a.GetLowerBound(0); p_0 <= q_0; p_0 = p_0 + 1)\r\n                for (int p_1 = a.GetLowerBound(1); p_1 <= q_1; p_1 = p_1 + 1)\r\n                    ...\r\n                        { V v = (V)a[p_0, p_1, ...]; /* body */ }\r\n            ":"\r\n            降低将枚举多维数组的foreach循环。\r\n            \r\n            A[。..]a=x;\r\n            int q_0=A.GetUpperBound(0),q_1=A.GetUpperBound(1),...;\r\n            for(int p_0=A.GetLowerBound(0);p_0<=q_0;p_0=p_0+1)\r\n                for(int p_1=A.GetLowerBound(1);p_1<=q_1;p_1=p_1+1)\r\n                    ...\r\n                        {V v=(V)a[p_0，p_1，。..];/*正文*/}\r\n            \r\n","\r\n              Looks up a localized string similar to Constructor '{0}' is marked external.\r\n            ":"查找类似于构造函数'{0}'的本地化字符串是外部标记的。\r\n            \r\n","\r\n            To scan the whole body, we start outside (before) the region.\r\n            ":"\r\n            为了扫描整个身体，我们从（之前）开始（之前）。\r\n            \r\n","The event '{0}' can only appear on the left hand side of += or -=":"事件'{0}'只能出现在 +=或 -  =的左侧\r\n","\r\n            When binding a name X that was declared with a \"using X=OtherTypeOrNamespace\", return the alias symbol X.\r\n            ":"\r\n            当绑定用“使用x = earthtypeornamespace”声明的名称x时，返回别名符号X。\r\n            \r\n","\r\n            Module's assembly attributes\r\n            ":"\r\n            模块的组装属性\r\n            \r\n","Dynamically dispatched call may fail at runtime because one or more applicable overloads are conditional methods":"动态派遣的呼叫在运行时可能会失败，因为一个或多个适用的过载是条件方法\r\n","\r\n              Looks up a localized string similar to Block bodies and expression bodies cannot both be provided..\r\n            ":"\r\n              查找类似于块体和表达主体类似的局部字符串。\r\n            \r\n","\r\n            Called after it is determined that the expression being enumerated is of a type that\r\n            has a GetEnumerator method.  Checks to see if the return type of the GetEnumerator\r\n            method is suitable (i.e. has Current and MoveNext).\r\n            ":"\r\n            确定被列举的表达式是一种类型\r\n            具有GetEnumerator方法。检查getEnumerator的返回类型是否\r\n            方法是合适的（即具有电流和movenext）。\r\n            \r\n","Invalid option '{0}' for /debug; must be 'portable', 'embedded', 'full' or 'pdbonly'":"无效选项'{0}'for /debug;必须是“便携式”，“嵌入”，“ full”或“ pdbonly”\r\n","\r\n            Returns false because label can't be defined externally.\r\n            ":"\r\n            返回false，因为不能外部定义标签。\r\n            \r\n","\r\n            Scan a single XML character (or entity).  Assumes that leading trivia has already\r\n            been consumed.\r\n            ":"\r\n            扫描单个XML字符（或实体）。假设领导琐事已经\r\n            被消耗了。\r\n            \r\n","The parameter that was declared.":"声明的参数。\r\n","\r\n              Looks up a localized string similar to Passing '{0}' as ref or out or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class.\r\n            ":"\r\n              查找类似于传递“ {0}”的本地化字符串作为ref或out或拿出其地址可能会导致运行时异常，因为它是逐个参考类的字段。\r\n            \r\n","The decimal value to be represented by the returned token.":"返回令牌代表的小数值。\r\n","Called when the visitor visits a XmlElementEndTagSyntax node.":"当访问者访问XMlelementEndTagsyntax节点时，请致电。\r\n","\r\n            Indicates whether or not the property returns a readonly reference\r\n            ":"\r\n            指示该属性是否返回阅读参考\r\n            \r\n"," before and after the ":"之前和之后\r\n","\r\n            This instance is used as a key in the lambda return type inference.\r\n            We basically only interested in parameters since inference will set the return type to null.\r\n            ":"\r\n            此实例用作Lambda返回类型推理中的键。\r\n            我们基本上仅对参数感兴趣，因为推理将将返回类型设置为NULL。\r\n            \r\n","The switch statement contains multiple cases with the label value '{0}'":"Switch语句包含具有标签值'{0}'的多个情况\r\n","Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a suitable public instance or extension definition for '{1}'":"异步语句无法在类型'{0}'的变量上操作，因为'{0}'不包含“ {1}”的合适的公共实例或扩展定义\r\n","\r\n              Looks up a localized string similar to The delegate '{0}' does not have a parameter named '{1}'.\r\n            ":"\r\n              查找类似于委托'{0}'的本地化字符串，没有名为'{1}'的参数。\r\n            \r\n"," so that we can process it as a `finally` block here.\r\n            ":" 这样我们就可以将其作为“最终”块处理。\r\n            \r\n","\r\n            The bound node representing this scope. This roughly corresponds to the bound\r\n            node for the block declaring locals for this scope, although parameters of\r\n            methods/closures are introduced into their Body's scope and do not get their\r\n            own scope.\r\n            ":"\r\n            代表此范围的结合节点。这大致对应于绑定\r\n            尽管参数的参数\r\n            方法/封闭被引入其身体的范围，不要得到他们的\r\n            自己的范围。\r\n            \r\n","The environment for the translated node":"翻译节点的环境\r\n","Method body to optimize":"方法主体以优化\r\n","\r\n            A type class for values (of type ":"\r\n            一个类型类用于值（类型的类型\r\n","\r\n            The root node of the syntax tree that this object is associated with.\r\n            ":"该对象与之关联的语法树的根节点。\r\n            \r\n","\r\n            Get the instance and static constructors for this type.\r\n            ":"\r\n            获取此类型的实例和静态构造函数。\r\n            \r\n","\r\n              Looks up a localized string similar to Name conflict for name {0}.\r\n            ":"\r\n              查找类似于名称{0}的名称冲突的本地化字符串。\r\n            \r\n","Expected contextual keyword 'equals'":"预期上下文关键字“等于”\r\n","An entry point cannot be generic or in a generic type":"入口点不能是通用的，也不能是通用类型\r\n","\r\n             The method group can contain \"duplicate\" symbols that we do not want to display in the IDE analysis.\r\n            \r\n             For example, there could be an overriding virtual method and the method it overrides both in\r\n             the method group. This, strictly speaking, is a violation of the C# specification because we are\r\n             supposed to strip out overriding methods from the method group before overload resolution; overload\r\n             resolution is supposed to treat overridden methods as being methods of the less derived type. However,\r\n             in the IDE we want to display information about the overriding method, not the overridden method, and\r\n             therefore we leave both in the method group. The overload resolution algorithm has been written\r\n             to handle this departure from the specification.\r\n            \r\n             Similarly, we might have two methods in the method group where one is a \"new\" method that hides \r\n             another. Again, in overload resolution this would be handled by the rule that says that methods\r\n             declared on more derived types take priority over methods declared on less derived types. Both\r\n             will be in the method group, but in the IDE we want to only display information about the \r\n             hiding method, not the hidden method.\r\n            \r\n             We can also have \"diamond\" inheritance of interfaces leading to multiple copies of the same\r\n             method ending up in the method group:\r\n             \r\n             interface IB { void M(); }\r\n             interface IL : IB {}\r\n             interface IR : IB {}\r\n             interface ID : IL, IR {}\r\n             ...\r\n             id.M();\r\n            \r\n             We only want to display one symbol in the IDE, even if the member lookup algorithm is unsophisticated\r\n             and puts IB.M in the member group twice. (Again, this is a mild spec violation since a method group\r\n             is supposed to be a set, without duplicates.)\r\n            \r\n             Finally, the interaction of multiple inheritance of interfaces and hiding can lead to some subtle\r\n             situations. Suppose we make a slight modification to the scenario above:\r\n            \r\n             interface IL : IB { new void M(); } \r\n            \r\n             Again, we only want to display one symbol in the method group. The fact that there is a \"path\"\r\n             to IB.M from ID via IR is irrelevant; if the symbol IB.M is hidden by IL.M then it is hidden\r\n             in ID, period.\r\n             ":"\r\n             该方法组可以包含我们不想在IDE分析中显示的“重复”符号。\r\n            \r\n             例如，可能有一个压倒性的虚拟方法，它的方法覆盖了这两种方法\r\n             方法组。严格来说，这违反了C＃规格，因为我们是\r\n             在超载分辨率之前，应该从方法组中剥离覆盖方法；超载\r\n             分辨率应该将被覆盖的方法视为较少派生类型的方法。然而，\r\n             在IDE中，我们想显示有关覆盖方法的信息，而不是覆盖方法，以及\r\n             因此，我们将这两个都留在方法组中。超载分辨率算法已编写\r\n             处理与规格的不同之处。\r\n            \r\n             同样，我们在方法组中可能有两种方法，其中一种是隐藏的“新”方法\r\n             其他。同样，在超负荷解决方案中，这将由说明方法的规则来处理\r\n             在更多的派生类型上声明，优先于在较少派生类型上声明的方法。两个都\r\n             将在方法组中，但是在IDE中，我们只想显示有关\r\n             隐藏方法，而不是隐藏方法。\r\n            \r\n             我们还可以拥有界面的“钻石”继承，导致多个副本相同\r\n             方法最终进入方法组：\r\n             \r\n             接口ib {void m（）; }\r\n             接口IL：IB {}\r\n             接口IR：IB {}\r\n             接口ID：IL，ir {}\r\n             ...\r\n             id.m（）;\r\n            \r\n             我们只想在IDE中显示一个符号，即使成员查找算法不合适\r\n             并将ib.m放在成员组两次。 （同样，这是一种轻度的规格，因为方法组\r\n             应该是一套，没有重复。）\r\n            \r\n             最后，界面和隐藏的多个继承的相互作用会导致一些微妙的\r\n             情况。假设我们对上述情况进行了稍作修改：\r\n            \r\n             接口IL：ib {new void m（）; }\r\n            \r\n             同样，我们只想在方法组中显示一个符号。有“路径”的事实\r\n             从ID通过IR到IB.M是无关紧要的；如果符号ib.m被iL.m隐藏，则隐藏\r\n             在ID，期间。\r\n             \r\n","readonly automatically implemented properties":"RealOnly自动实现属性\r\n","\r\n            Decodes ":"\r\n            解码\r\n","\r\n              Looks up a localized string similar to expression-bodied method.\r\n            ":"\r\n              查找类似于表达式方法的局部字符串。\r\n            \r\n","Assembly and module '{0}' cannot target different processors.":"汇编和模块'{0}'不能瞄准不同的处理器。\r\n","\r\n            C# language version 8.0\r\n            ":"\r\n            C＃语言版本8.0\r\n            \r\n","Accessor '{0}' cannot implement interface member '{1}' for type '{2}'. Use an explicit interface implementation.":"登录器'{0}'无法实现类型'{2}'的接口成员'{1}'。使用显式接口实现。\r\n","A character position used to identify a declaration scope and accessibility. This\r\n            character position must be within the FullSpan of the Root syntax node in this SemanticModel. In order to obtain\r\n            the correct scoping rules for the cref, position should be the Start position of the Span of the original cref.\r\n            ":"用于标识声明范围和可访问性的角色位置。这个\r\n            字符位置必须在此semanticmodel中的root语法节点的成面内。为了得到\r\n            CREF的正确范围规则，位置应为原始CREF的跨度的开始位置。\r\n            \r\n","\r\n            Retargeted custom attributes\r\n            ":"\r\n            重新定制属性\r\n            \r\n","True if we found an extension method, false otherwise.":"是的，如果我们找到了扩展方法，则否则为错误。\r\n","\r\n            Check for illegal nesting into a variant interface.\r\n            ":"\r\n            检查是否将非法嵌套到变体接口中。\r\n            \r\n","\r\n              Looks up a localized string similar to The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'.\r\n            ":"在全局别名的多个汇编中定义了类似于预定义的类型“ {0}”的局部字符串；使用来自“ {1}”的定义。\r\n            \r\n","\r\n              Looks up a localized string similar to Assembly does not contain any analyzers.\r\n            ":"\r\n              查找类似于汇编的本地化字符串不包含任何分析仪。\r\n            \r\n","\r\n            Base class to represent all source method-like symbols. This includes\r\n            things like ordinary methods and constructors, and functions\r\n            like lambdas and local functions.\r\n            ":"\r\n            代表所有类似源方法的符号的基类。这包括\r\n            诸如普通方法和构造函数以及功能之类的东西\r\n            像Lambdas和本地功能一样。\r\n            \r\n","\r\n              Looks up a localized string similar to The CallerFilePathAttribute may only be applied to parameters with default values.\r\n            ":"\r\n              查找类似于CallerFilePathAttribute的本地化字符串只能应用于具有默认值的参数。\r\n            \r\n","\r\n              Looks up a localized string similar to The operand of an increment or decrement operator must be a variable, property or indexer.\r\n            ":"\r\n              查找类似于增量或减少操作员操作数的本地化字符串必须是变量，属性或索引器。\r\n            \r\n","\r\n              Looks up a localized string similar to User-defined operator cannot take an object of the enclosing type and convert to an object of the enclosing type.\r\n            ":"\r\n              查找类似于用户定义的运算符的本地化字符串，无法采用封闭类型的对象，而是转换为封闭类型的对象。\r\n            \r\n"," from metadata and checks if System.Runtime.CompilerServices.DynamicAttribute is applied.\r\n            If so, it transforms the given ":" 从元数据中使用system.runtime.compilerservices.dynamicattribute。\r\n            如果是这样，它会改变给定的\r\n","Creates a new ExpressionStatementSyntax instance.":"创建一个新的ExpressionStateTementYntax实例。\r\n","Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'":"不一致的可访问性：基本接口'{1}'比接口'{0}'易于访问\r\n","\r\n            This instance is used to search for members that have identical signatures in every regard.\r\n            ":"\r\n            此实例用于搜索各个方面具有相同签名的成员。\r\n            \r\n","\r\n            Helper method that checks whether there is an invocable 'nameof' in scope.\r\n            ":"\r\n            助手方法检查范围中是否有一个可不可行的“名称”。\r\n            \r\n","No matching elements were found for the following include tag":"没有发现以下内容的匹配元素包括标签\r\n","\r\n            Gets the root of the syntax tree statically typed as ":"\r\n            获取语​​法树的根部静态键入为\r\n",", which is a snapshot of nodes from the original document.\r\n            We're mutating the tree as we rewrite, so it's important to grab a snapshot of the\r\n            nodes that we're going to reparent before we enumerate them.\r\n            ":"，这是原始文档中节点的快照。\r\n            当我们重写时，我们正在突变这棵树，因此抓住一张快照很重要\r\n            在列举它们之前，我们将要进行修复的节点。\r\n            \r\n","{0} and {1} must have the same length.":"{0}和{1}必须具有相同的长度。\r\n","\r\n              Looks up a localized string similar to Cannot convert {0} to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type.\r\n            ":"\r\n              查找类似于无法将{0}转换为预期委托类型的本地化字符串，因为该块中的某些返回类型不会隐式转换为委托返回类型。\r\n            \r\n","Preprocessor directives must appear as the first non-whitespace character on a line":"预处理器指令必须出现在行上的第一个非Whitespace字符\r\n","\r\n            A binder that brings extern aliases into the scope and deals with looking up names in them.\r\n            ":"\r\n            将外部别名带入范围并处理其中的名称的活页夹。\r\n            \r\n","\r\n            Lower the given nodes into _loweredDecisionDag. Should only be called once per instance of this.\r\n            ":"\r\n            将给定的节点降低到_loweredDecisionDag中。每个实例只能调用一次。\r\n            \r\n","Enum type declaration syntax.":"枚举类型声明语法。\r\n","\r\n            Given a base method declaration syntax, get the corresponding method symbol.\r\n            ":"\r\n            给定基本方法声明语法，获取相应的方法符号。\r\n            \r\n","\r\n            When binding a switch case's expression, it is possible that it resolves to a type (technically, a type pattern).\r\n            This implementation permits either an rvalue or a BoundTypeExpression.\r\n            ":"\r\n            当绑定开关情况的表达式时，它可能会解析为类型（从技术上讲，类型模式）。\r\n            此实现允许rvalue或foundtypeexpression。\r\n            \r\n"," when it is not valid and produces diagnostics (possibly more than one recursively) that helps to figure the reason.\r\n            ":"当它是无效的并产生诊断（可能递归多个）时，有助于弄清原因。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': abstract event cannot have initializer.\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串：抽象事件无法具有初始化器。\r\n            \r\n","\r\n             This implements the casting behavior described in section 6.2.3 of the spec:\r\n             \r\n             - If the nullable conversion is from S to T?, the conversion is evaluated as the underlying conversion \r\n               from S to T followed by a wrapping from T to T?.\r\n            \r\n             This particular check is done in the binder because it involves conversion processing rules (like overflow\r\n             checking and constant folding) which are not handled by Conversions.\r\n             ":"\r\n             这实现了规格第6.2.3节中描述的铸造行为：\r\n             \r\n              - 如果无效的转换从s到t？，则将转换评估为基础转换\r\n               从s到t，然后从t到t？\r\n            \r\n             此特定检查是在活页夹中完成的，因为它涉及转换处理规则（例如溢出\r\n             检查和恒定折叠）未通过转换来处理。\r\n             \r\n","\r\n            If we are inside a context where a break statement is legal,\r\n            returns the ":"\r\n            如果我们处于合法中断陈述的上下文中，\r\n            返回\r\n","\r\n            The set of fields on which the field depends.\r\n            ":"\r\n            该字段依赖的字段集。\r\n            \r\n",", and there is no explicit argument corresponding to it,\r\n            we will provide caller information as a value of this parameter.\r\n            This is done to match the native compiler behavior and user requests (see http://roslyn.codeplex.com/workitem/171). This behavior\r\n            does not match the C# spec that currently requires to provide caller information only in explicit invocations and query expressions.\r\n            ":"，并且没有与之相对应的明确参数\r\n            我们将提供呼叫者信息作为此参数的值。\r\n            这样做是为了匹配本机编译器行为和用户请求（请参阅http://roslyn.codeplex.com/workitem/171）。这种行为\r\n            不匹配当前只需要在明确的调用和查询表达式中提供呼叫者信息的C＃规格。\r\n            \r\n","\r\n            This overload is added to shadow the one from the base.\r\n            ":"\r\n            此过载被添加到从基部的阴影中。\r\n            \r\n","\r\n            Test if the value set contains any values that satisfy the given relation with the given value.\r\n            ":"\r\n            测试值集是否包含满足给定值的任何值。\r\n            \r\n","Gets the optional semicolon token.":"获取可选的分号令牌。\r\n"," should be set\r\n            to the bottom state. False if they should be set to the top state.\r\n            ":" 应该设置\r\n            到底部状态。错误，如果应该设置为最高状态。\r\n            \r\n","\r\n            Returns true if the conversion is an implicit anonymous function conversion.\r\n            ":"\r\n            如果转换是隐式匿名函数转换，则返回true。\r\n            \r\n","/embed switch is only supported when emitting a PDB.":"/嵌入开关仅在排放PDB时支持。\r\n","\r\n            Creates a token with kind NumericLiteralToken from an 8-byte unsigned integer value.\r\n            ":"\r\n            从8个字节的无符号整数值创建具有属性数字的令牌。\r\n            \r\n","\r\n            The implementation of a value set factory of any numeric type ":"\r\n            任何数字类型的价值集工厂的实现\r\n","Set to a ParamArrayAttribute":"设置为paramarrayattribute\r\n","\r\n              Looks up a localized string similar to The 'await' operator may only be used in a query expression within the first collection expression of the initial 'from' clause or within the collection expression of a 'join' clause.\r\n            ":"\r\n              查找类似于“等待”运算符的本地化字符串只能在“初始”子句的第一个集合表达式中的查询表达式中使用，或者在“ join”子句的集合表达式中使用。\r\n            \r\n","\r\n            Called at the point in a loop where the backward branch is placed.\r\n            ":"\r\n            在循环中放置向后分支的循环中的点。\r\n            \r\n"," information from this ":" 来自此的信息\r\n","Cannot return a member of local '{0}' by reference because it is not a ref local":"无法通过引用返回本地'{0}'的成员，因为它不是参考本地\r\n","\r\n            Analyze data-flow within an expression.\r\n            ":"\r\n            在表达式中分析数据流。\r\n            \r\n","\r\n            Gets the \"Dispose\" method (or \"DisposeAsync\" in an asynchronous foreach).\r\n            ":"\r\n            在异步方面获取“处置”方法（或“ disposeasync”）。\r\n            \r\n","A character position used to identify a declaration scope and accessibility. This\r\n            character position must be within the span of an existing constructor initializer.\r\n            ":"用于标识声明范围和可访问性的角色位置。这个\r\n            字符位置必须在现有构造函数初始化器的范围内。\r\n            \r\n","\r\n            Diagnostic for the errorCode added if the warningOptions does not mention suppressed for the errorCode.\r\n            ":"\r\n            如果警告码未提及抑制错误代码，则添加了错误代码的诊断。\r\n            \r\n","Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal to create character literal tokens.":"使用Microsoft.codeanalysis.csharp.syntaxfactory.literal创建字符文字令牌。\r\n","This node is associated with the following syntax kinds:":"该节点与以下语法类型相关联：\r\n","#error: '{0}'":"#Error：'{0}'\r\n","\r\n               Looks up a localized string similar to \r\n                                          Visual C# Compiler Options\r\n            \r\n                                    - OUTPUT FILES -\r\n             /out:<file>                   Specify output file name (default: base name of\r\n                                           file with main class or first file)\r\n             /target:exe                   Build a console executable (default) (Short\r\n                                           form: /t:exe)\r\n             /target:winexe                Build a Windows executable (Short form:\r\n                                           /t:winexe)\r\n             /target:library        [rest of string was truncated]\";.\r\n             ":"\r\n               查找类似于\r\n                                          视觉C＃编译器选项\r\n            \r\n                                     - 输出文件 - \r\n             /out：<file>指定输出文件名（默认值：\r\n                                           带有主类或第一个文件的文件）\r\n             /target：EXE构建控制台可执行文件（默认）（简短）\r\n                                           表格： /t：exe）\r\n             /target：Winexe构建Windows可执行文件（简短表格：\r\n                                           /t：winexe）\r\n             /target：库[弦的其余部分被截断];。\r\n             \r\n","\r\n              Looks up a localized string similar to SecurityAction value '{0}' is invalid for security attributes applied to a type or a method.\r\n            ":"\r\n              查找类似于SecurityAction值'{0}'的本地化字符串对于应用于类型或方法的安全属性无效。\r\n            \r\n","\r\n            There are two BadEventUsage error codes and this method decides which one should\r\n            be used for a given event.\r\n            ":"\r\n            有两个badeventusage错误代码，此方法决定哪个应该\r\n            用于给定事件。\r\n            \r\n","; expected":";预期的\r\n","Nullability of reference types in return type doesn't match implemented member '{0}' (possibly because of nullability attributes).":"返回类型中参考类型的无效性不匹配实现的成员'{0}'（可能是由于无效属性）。\r\n","\r\n            Write own documentation comments and then descend into members.\r\n            ":"\r\n            编写自己的文档评论，然后降为会员。\r\n            \r\n","\r\n              Looks up a localized string similar to A tuple may not contain a value of type 'void'..\r\n            ":"\r\n              查找类似于元组的局部字符串可能不包含“ void”类型的值。\r\n            \r\n","\r\n              Looks up a localized string similar to Type or member does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute.\r\n            ":"\r\n              查找类似于类型或成员的本地化字符串不需要CLSCompliant属性，因为组件没有CLSCompliant属性。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': an abstract class cannot be sealed or static.\r\n            ":"\r\n              查找类似于“ {0}”的局部字符串：不能密封或静态的抽象类。\r\n            \r\n","\r\n            The lexer is for the contents of an interpolation that is followed by a colon that signals the start of the format string.\r\n            ":"\r\n            Lexer是用于插值的内容，其后是标志着格式字符串开始的结肠。\r\n            \r\n","New protected member declared in sealed type":"新的受保护成员以密封类型声明\r\n","(a, b) == ...":"（a，b）== ...\r\n","\r\n              Looks up a localized string similar to '{0}' specified for Main method must be a valid non-generic class or struct.\r\n            ":"\r\n              查找类似于主方法指定的“ {0}”的本地化字符串必须是有效的非类别类或结构。\r\n            \r\n","{":"{\r\n","\r\n            Parse a BracketedArgumentListSyntax node.\r\n            ":"\r\n            解析一个括号内列表元素节点。\r\n            \r\n"," is true.\r\n            Chaining of speculative semantic model is not supported.":" 是真的。\r\n            不支持投机语义模型的链接。\r\n","\r\n            Creates the syntax representation of a see element within xml documentation comments,\r\n            that points to a language keyword.\r\n            ":"\r\n            创建XML文档注释中的See元素的语法表示，\r\n            这指向语言关键字。\r\n            \r\n","\r\n            Some statements by default do not introduce its own scope for locals. \r\n            For example: Expression Statement, Return Statement, etc. However, \r\n            when a statement like that is an embedded statement (like IfStatementSyntax.Statement), \r\n            then it should introduce a scope for locals declared within it. \r\n            Here we are detecting such statements and creating a binder that should own the scope.\r\n            ":"\r\n            默认情况下，某些语句不会引入自己的当地人范围。\r\n            例如：表达式语句，返回语句等，但是，\r\n            当这样的语句是嵌入式语句（例如ifstatementsyntax.statement）时，\r\n            然后，它应该引入一个范围，以供其内部声明的当地人。\r\n            在这里，我们正在检测到此类陈述并创建应该拥有范围的活页夹。\r\n            \r\n","\r\n            Returns true if type a is encompassed by type b (spec 6.4.3),\r\n            and returns false otherwise.\r\n            ":"\r\n            如果A类型由B类（Spec 6.4.3）涵盖，则返回true。\r\n            否则返回false。\r\n            \r\n","\r\n            Applies C#-specific modification and filtering of ":"\r\n            应用C＃特定修改和过滤\r\n","Multiple global analyzer config files set the same key '{0}' in section '{1}'. It has been unset. Key was set by the following files: '{2}'":"多个Global Analyzer配置文件设置相同的密钥'{0}'在'{1}'中。这是不安的。键是由以下文件设置的：'{2}'\r\n","\r\n              Looks up a localized string similar to Bad array declarator: To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type..\r\n            ":"\r\n              查找类似于不良数组声明器的本地化字符串：要声明托管数组等级规范在变量的标识符之前。要声明固定的大小缓冲区字段，请在字段类型之前使用固定的关键字。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' hides inherited abstract member '{1}'.\r\n            ":"\r\n              查找类似于'{0}'隐藏的抽象成员'{1}'的本地化字符串。\r\n            \r\n","Method has the wrong signature to be an entry point":"方法错误的签名是入口点\r\n",").\r\n             The second element is a Multiple containing two Singles (one for the ":"）。\r\n             第二个元素是包含两个单曲的倍数（一个用于\r\n","\r\n              Looks up a localized string similar to The CallerFilePathAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute..\r\n            ":"\r\n              查找类似于应用于参数'{0}'的CallerFilePathTribute类似的本地化字符串将没有效果。它被CallerlineNumberattribute覆盖。\r\n            \r\n","\r\n            To go the opposite direction (from syntax node to symbol), see ":"\r\n            要转向相反的方向（从语法节点到符号），请参阅\r\n",". There are four\r\n            kind of nodes: ":"。有四个\r\n            有点节点：\r\n"," attribute. \r\n            This property returns ":" 属性。\r\n            此属性返回\r\n","\r\n            Gets the syntax list of custom attributes that declares attributes for this parameter symbol.\r\n            ":"\r\n            获取自定义属性的语法列表，该属性声明此参数符号的属性。\r\n            \r\n"," was applied to the type and the attribute argument is a valid named type argument, i.e. accessible class type, then it returns the type symbol for the argument.\r\n            Otherwise, returns null.\r\n            ":" 被应用于类型，属性参数是一个有效的命名类型参数，即可访问的类类型，然后返回该参数的类型符号。\r\n            否则，返回null。\r\n            \r\n","The position the local was declared at.":"当地宣布的职位。\r\n","\r\n            Gets a SyntaxToken that represents the switch keyword.\r\n            ":"\r\n            获取代表Switch关键字的语法。\r\n            \r\n","\r\n            Returns true if this symbol was declared to override a base class member and was also\r\n            sealed from further overriding; i.e., declared with the ":"\r\n            如果该符号被宣布覆盖小型班级成员，则返回为true\r\n            从进一步的覆盖中密封；即，用\r\n","\r\n            This method is used to keep the code that generates binders in sync\r\n            with the code that searches for binders.  We don't want the searcher\r\n            to skip over any nodes that could have associated binders, especially\r\n            if changes are made later.\r\n            \r\n            \"Local binder\" is a term that refers to binders that are\r\n            created by LocalBinderFactory.\r\n            ":"\r\n            此方法用于保留生成粘合剂同步的代码\r\n            使用搜索Binders的代码。我们不想要搜索者\r\n            跳过任何可能具有关联粘合剂的节点，尤其是\r\n            如果以后进行更改。\r\n            \r\n            “本地活页夹”是指粘合剂的术语\r\n            由LocalBinderFactory创建。\r\n            \r\n","Creates a new IncompleteMemberSyntax instance.":"创建一个新的不完整符号字母实例。\r\n","using alias":"使用别名\r\n","\r\n              Looks up a localized string similar to The body of '{0}' cannot be an iterator block because '{0}' returns by reference.\r\n            ":"查找类似于“ {0}'主体的本地化字符串，不能是迭代器块，因为'{0}'通过参考返回。\r\n            \r\n","Base type for type parameter constraint syntax.":"类型的基本类型参​​数约束语法。\r\n","\r\n            The result and l-value type of the last visited expression.\r\n            ":"最后一个访问表达式的结果和L值类型。\r\n            \r\n","A partial method may not have multiple implementing declarations":"部分方法可能没有多个实施声明\r\n","\r\n            A synthesized local variable with a val escape scope.\r\n            ":"\r\n            带有Val逃生范围的合成局部变量。\r\n            \r\n","\r\n            Return true if the given type is valid as a calling convention modifier type.\r\n            ":"\r\n            如果给定类型有效为呼叫约定修饰符类型，则返回true。\r\n            \r\n","SyntaxToken representing the close bracket.":"Syntaxtkoken代表近亲括号。\r\n","\r\n            Check all generic constraints on the given type and any containing types\r\n            (such as A<T> in A<T>.B<U>). This includes checking constraints\r\n            on generic types within the type (such as B<T> in A<B<T>[]>).\r\n            ":"检查给定类型和任何包含类型的所有通用约束\r\n            （例如<t> .b <u>中的A <t>）。这包括检查约束\r\n            在类型中的通用类型上（例如A <b <t> []>中的B <t>）。\r\n            \r\n"," must lie within an existing method body of the Root syntax node for this SemanticModel.\r\n            Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.\r\n            ":" 必须位于该语法模型的根语法节点的现有方法中。\r\n            在这种现有方法主体中声明的当地人和标签不被认为是推测方法主体的范围。\r\n            \r\n","Called when the visitor visits a ImplicitArrayCreationExpressionSyntax node.":"当访问者访问一个隐式creationexpressyntax节点时，请致电。\r\n","\r\n            If this method is a reduced extension method, returns a type inferred during reduction process for the type parameter.\r\n            ":"\r\n            如果此方法是减少的扩展方法，请返回类型参数减少过程中推断出的类型。\r\n            \r\n","\r\n            Contains the shared state used to restore the walker at a specific point\r\n            ":"\r\n            包含用于在特定点恢复助行器的共享状态\r\n            \r\n","\r\n            Validates whether given invocation can allow its results to escape from `escapeFrom` level to `escapeTo` level.\r\n            The result indicates whether the escape is possible. \r\n            Additionally, the method emits diagnostics (possibly more than one, recursively) that would help identify the cause for the failure.\r\n            \r\n            NOTE: we need scopeOfTheContainingExpression as some expressions such as optional `in` parameters or `ref dynamic` behave as \r\n                  local variables declared at the scope of the invocation.\r\n            ":"\r\n            验证给定的调用是否可以使其结果从“逃脱”级别逃到`eScapeto'级别。\r\n            结果表明逃脱是否可能。\r\n            此外，该方法会发出诊断（可能是递归的），这将有助于确定失败的原因。\r\n            \r\n            注意：我们需要范围内的表达方式作为某些表达式，例如可选的`in参数或`ref dynamic'Behip h.\r\n                  在调用范围内声明的本地变量。\r\n            \r\n","The syntax node where to add bound nodes for.":"语法节点在何处添加绑定节点。\r\n","\r\n              Looks up a localized string similar to (Location of symbol related to previous error).\r\n            ":"\r\n              查找类似于（符号的位置与以前的错误相关的位置）的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to The default value specified will have no effect because it applies to a member that is used in contexts that do not allow optional arguments.\r\n            ":"\r\n              查找类似于指定的默认值的本地化字符串将无效，因为它适用于不允许可选参数的上下文中使用的成员。\r\n            \r\n"," is true, the method fails to locate an implementation and an implementation in\r\n            an interface, if any (its presence is not checked), could potentially be a candidate. Returns false otherwise.\r\n            When true is returned, a different call with ":" 是的，该方法无法在\r\n            界面（如果没有检查），则可能是候选人。否则返回false。\r\n            当true返回时，与\r\n","\r\n              Looks up a localized string similar to readonly members.\r\n            ":"\r\n              查找类似于ReadOnly成员的本地化字符串。\r\n            \r\n","\r\n            The runtime considers a method to be a finalizer (i.e. a method that should be invoked\r\n            by the garbage collector) if it (directly or indirectly) overrides System.Object.Finalize.\r\n            ":"\r\n            运行时认为是最终制度的方法（即应调用的方法\r\n            由垃圾收集器）如果（直接或间接）覆盖System.Object.finalize。\r\n            \r\n","\r\n              Looks up a localized string similar to XML comment has cref attribute '{0}' that refers to a type parameter.\r\n            ":"\r\n              查找类似于XML注释的本地化字符串具有CREF属性'{0}'，它是指类型参数。\r\n            \r\n","Called when the visitor visits a ForEachVariableStatementSyntax node.":"当访问者访问foreachVariablestatementsyntax节点时，请致电。\r\n","Source file references are not supported.":"源文件引用不支持。\r\n","\r\n              Looks up a localized string similar to XML comment has cref attribute that could not be resolved.\r\n            ":"\r\n              查找类似于XML注释的本地化字符串具有无法解决的CREF属性。\r\n            \r\n","The '{0}' attribute is valid only on an indexer that is not an explicit interface member declaration":"'{0}'属性仅在不是显式接口成员声明的索引器上有效\r\n","\r\n            Determine whether there is any substitution of type parameters that will\r\n            make two types identical.\r\n            ":"\r\n            确定是否有任何类型参数的替代\r\n            使两种类型相同。\r\n            \r\n","\r\n              Looks up a localized string similar to stackalloc may not be used in a catch or finally block.\r\n            ":"\r\n              查找类似于stackalloc的本地化字符串可能不会在捕获量中或最终阻止。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot convert {0} to delegate type '{1}' because the parameter types do not match the delegate parameter types.\r\n            ":"\r\n              查找类似于不能将{0}转换为委托类型'{1}'的本地化字符串，因为参数类型与委托参数类型不匹配。\r\n            \r\n","\r\n            Lookup a top level type referenced from metadata, names should be\r\n            compared case-sensitively.\r\n            ":"\r\n            查找从元数据引用的顶级类型，名称应为\r\n            比较病例敏感。\r\n            \r\n","\r\n            Count of all nontrivial initializers and count of those that are constants.\r\n            ":"\r\n            所有非平凡的初始化器和常数的计数的计数。\r\n            \r\n","\r\n            Returns false because local variable can't be virtual.\r\n            ":"\r\n            返回false，因为本地变量不能虚拟。\r\n            \r\n","Optionally, allow cancellation of documentation comment retrieval.":"可选，允许取消文档注释检索。\r\n","\r\n              Looks up a localized string similar to The left-hand side of a ref assignment must be a ref local or parameter..\r\n            ":"\r\n              查找类似Ref分配的左侧的本地化字符串必须是Ref Local或参数。\r\n            \r\n","\r\n            Class to represent a synthesized attribute\r\n            ":"\r\n            代表合成属性的类\r\n            \r\n","\r\n            Symbol to copy bound attributes from, or null if the attributes are not shared among multiple source method symbols.\r\n            ":"\r\n            符号以从多个源方法符号之间共享属性，以复制绑定属性或null。\r\n            \r\n","Creates a new ThrowStatementSyntax instance.":"创建一个新的throwStatementsyntax实例。\r\n","\r\n              Looks up a localized string similar to Cannot pass '{0}' as a ref or out argument because it is read-only.\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串作为ref或out参数，因为它是只读的。\r\n            \r\n"," Maps member names to symbol(s) ":" 地图成员名称到符号\r\n","\r\n            Note, only nullability aspects are merged if possible, other mismatches are treated as failures.\r\n            ":"\r\n            请注意，只有在可能的情况下合并了无效方面，其他不匹配被视为失败。\r\n            \r\n","\r\n            Return a node that is associated with close brace of the block. Ok to return null.\r\n            ":"\r\n            返回与块的紧密支撑相关的节点。可以返回null。\r\n            \r\n","\r\n            A cache of the state at the backward branch point of each loop.  This is not needed\r\n            during normal flow analysis, but is needed for DataFlowsOut region analysis.\r\n            ":"\r\n            每个循环的向后分支点处的状态缓存。这不需要\r\n            在正常流量分析期间，需要进行数据流动区域分析。\r\n            \r\n","\r\n            Represents nested missing type.\r\n            ":"\r\n            表示嵌套缺失类型。\r\n            \r\n","Called when the visitor visits a ElifDirectiveTriviaSyntax node.":"当访客访问ElifDirectivtRiviaSynconax节点时，请致电。\r\n","Type parameter '{0}' has the same name as the type parameter from outer method '{1}'":"类型参数'{0}'具有与外部方法'{1}'的类型参数相同的名称\r\n","Class which represents the syntax node for a nullable type.":"代表无效类型的语法节点的类。\r\n","SyntaxTree is not part of the compilation, so it cannot be removed":"语法不是汇编的一部分，因此无法将其删除\r\n","\r\n            The list of contained ModuleSymbol objects. First item in the list\r\n            is RetargetingModuleSymbol that wraps corresponding SourceModuleSymbol \r\n            from underlyingAssembly.Modules list, the rest are PEModuleSymbols for \r\n            added modules.\r\n            ":"\r\n            包含的模块符号对象的列表。列表中的第一项\r\n            是retargetingModulesymbol，包裹相应的SourceModulesymbol\r\n            从下林的仪器列表中，其余的是pemodulesymbols\r\n            添加了模块。\r\n            \r\n","\r\n              Looks up a localized string similar to invariantly.\r\n            ":"\r\n              查找类似于不变的本地化字符串。\r\n            \r\n","Additional file doesn't belong to the underlying 'CompilationWithAnalyzers'.":"其他文件不属于基础“汇编”。\r\n","\r\n              Looks up a localized string similar to Unexpected error writing debug information -- '{0}'.\r\n            ":"\r\n              查找类似于意外错误编写调试信息的本地化字符串 - '{0}'。\r\n            \r\n","\r\n            Find the Deconstruct method for the expression on the right, that will fit the number of assignable variables on the left.\r\n            Returns an invocation expression if the Deconstruct method is found.\r\n                If so, it outputs placeholders that were coerced to the output types of the resolved Deconstruct method.\r\n            The overload resolution is similar to writing `receiver.Deconstruct(out var x1, out var x2, ...)`.\r\n            ":"\r\n            在右侧找到表达式的解构方法，该方法将适合左侧的可分配变量的数量。\r\n            如果找到解构方法，则返回调用表达式。\r\n                如果是这样，它将输出被胁迫的占位符，以解决已解决的解构方法的输出类型。\r\n            过载分辨率类似于编写`receiver.deconstruct（out var x1，out var x2，...）`。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored..\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串不是此声明的有效属性位置。此声明的有效属性位置为“ {1}”。该块中的所有属性将被忽略。\r\n            \r\n","\r\n              Looks up a localized string similar to The Conditional attribute is not valid on '{0}' because its return type is not void.\r\n            ":"\r\n              在“ {0}”上查找类似于条件属性的本地化字符串在“ {0}”上无效，因为其返回类型不是无效的。\r\n            \r\n","An explicit interface implementation of an event must use event accessor syntax":"事件的显式接口实现必须使用事件访问语法\r\n","\r\n            This is a ":"\r\n            这是一个\r\n","Badly formed XML in included comments file -- '{0}'":"在包含的注释文件中形成不良的XML  - '{0}'\r\n","\r\n            If this declaration or identifier is part of a deconstruction, find the deconstruction.\r\n            If found, returns either an assignment expression or a foreach variable statement.\r\n            Returns null otherwise.\r\n            ":"\r\n            如果此声明或标识符是解构的一部分，请找到解构。\r\n            如果发现，则返回分配表达式或for for for for varable语句。\r\n            否则返回null。\r\n            \r\n","\r\n             The record includes a synthesized override of object.ToString().\r\n             For `record R(int I) { public int J; }` it prints `R { I = ..., J = ... }`.\r\n            \r\n             The method can be declared explicitly. It is an error if the explicit\r\n             declaration does not match the expected signature or accessibility, or\r\n             if the explicit declaration doesn't allow overriding it in a derived type and\r\n             the record type is not sealed.\r\n             It is an error if either synthesized or explicitly declared method doesn't\r\n             override `object.ToString()` (for example, due to shadowing in intermediate base types, etc.).\r\n             ":"\r\n             该记录包括一个合成的对象的替代。ToString（）。\r\n             对于记录r（int i）{public int j; }`它打印`r {i = ...，j = ...}`。\r\n            \r\n             该方法可以明确声明。如果显式，这是一个错误\r\n             声明与预期签名或可访问性不匹配，或\r\n             如果明确声明不允许以派生类型和\r\n             记录类型未密封。\r\n             如果合成或明确声明的方法不\r\n             覆盖`object.toString（）`（例如，由于中间基本类型的阴影等）。\r\n             \r\n",". The resulting behavior in asynchronous code\r\n            is the same as one would expect for ":"。异步代码中产生的行为\r\n            与人们期望的一样\r\n","\r\n            Information about the arguments of a call that can turned into a BoundCall later without recalculating\r\n            default arguments.\r\n            ":"\r\n            有关呼叫的参数的信息，该参数稍后可以变成一个界面，而无需重新计算\r\n            默认参数。\r\n            \r\n","Creates a new XmlProcessingInstructionSyntax instance.":"创建一个新的XMLProcessingInstructionsyntax实例。\r\n","\r\n            Represents an element field of a tuple type (such as (int, byte).Item1)\r\n            that is backed by a real field with the same name within the tuple underlying type.\r\n            ":"\r\n            表示元组类型的元素字段（例如（int，byte）.Item1）\r\n            这是由一个真实字段的支持，在元组基础类型中具有相同名称。\r\n            \r\n","Symbol to which the attribute was applied (e.g. a parameter).":"应用属性的符号（例如参数）。\r\n","\r\n            default zero-init constructor symbol is added to a struct when it does not define \r\n            its own parameterless public constructor.\r\n            We do not emit this constructor and do not call it \r\n            ":"\r\n            默认的零输入构造函数符号将在未定义时添加到结构\r\n            它自己的无参数公共构造函数。\r\n            我们不发出这个构造函数，也不称为\r\n            \r\n","Type in which member was looked up.":"输入会员查找的内容。\r\n","\r\n            Returns if the compilation has all of the members necessary to emit metadata about \r\n            dynamic types.\r\n            ":"\r\n            申报表，如果汇编具有发射元数据所需的所有成员\r\n            动态类型。\r\n            \r\n","Implicitly-typed variables cannot be constant":"隐式型变量不能恒定\r\n","\r\n            If the method was written as an iterator method (i.e. with yield statements in its body) returns the\r\n            element type of the iterator.  Otherwise returns default(TypeWithAnnotations).\r\n            ":"\r\n            如果该方法是作为迭代方法写的（即带有屈服声明的方法），则返回\r\n            迭代器的元素类型。否则返回默认值（TypeWithAnnotations）。\r\n            \r\n",". This\r\n            conversion is applied before the operator is applied to the result of this conversion and ":"。这个\r\n            在将操作员应用于此转换的结果之前，将应用转换\r\n","\r\n            True if the compiler should check for overflow while evaluating constant expressions.\r\n            ":"\r\n            正确，如果编译器在评估常数表达式时应检查溢出。\r\n            \r\n","\r\n            In some cases returns are handled as gotos to return epilogue.\r\n            This is used to track the state of the epilogue.\r\n            ":"\r\n            在某些情况下，返回作为返回结尾的返回。\r\n            这用于跟踪结尾状态。\r\n            \r\n","Called when the visitor visits a AttributeArgumentSyntax node.":"当访问者访问属性的nntax节点时调用。\r\n","Exception occurred with following context:\r\n            {0}":"例外情况下有以下上下文：\r\n            {0}\r\n","\r\n            NOTE: Keep this method in sync with ":"\r\n            注意：保持此方法与\r\n","Attribute '{0}' is not valid on property or event accessors. It is only valid on '{1}' declarations.":"属性'{0}'在属性或事件访问器上无效。它仅在“ {1}”声明上有效。\r\n","Called when the visitor visits a RegionDirectiveTriviaSyntax node.":"当访问者访问区域导向尿道节点时，请调用。\r\n","\r\n              Looks up a localized string similar to Cannot specify the DefaultMember attribute on a type containing an indexer.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法在包含索引器的类型上指定defaultmember属性。\r\n            \r\n","\r\n              Looks up a localized string similar to The suppression operator is not allowed in this context.\r\n            ":"\r\n              在这种情况下，不允许查找类似于抑制操作员的本地化字符串。\r\n            \r\n","Creates a new WarningDirectiveTriviaSyntax instance.":"创建一个新的警告导向尿道词法实例。\r\n","\r\n            This class represents an event declared in source.  It may be either\r\n            field-like (see ":"\r\n            此类代表在源中声明的事件。可能是\r\n            类似野外（见\r\n","\r\n            Information to be deduced while binding a foreach loop so that the loop can be lowered\r\n            to a while over an enumerator.  Not applicable to the array or string forms.\r\n            ":"\r\n            在绑定foreach循环时要推导的信息，以便可以降低循环\r\n            一会儿枚举。不适用于数组或字符串表单。\r\n            \r\n","\r\n            Removes substitution currently used by the rewriter for a placeholder node.\r\n            Asserts if there isn't already a substitution.\r\n            ":"\r\n            删除重写者目前使用的替代者为占位符节点。\r\n            断言是否还没有替代。\r\n            \r\n","\r\n              Looks up a localized string similar to The right hand side of a fixed statement assignment may not be a cast expression.\r\n            ":"\r\n              查找类似于固定语句分配的右侧的本地化字符串可能不是铸件表达式。\r\n            \r\n","\r\n            Called when visiting a ":"\r\n            访问时叫\r\n","\r\n              Looks up a localized string similar to Inconsistent accessibility: return type '{1}' is less accessible than delegate '{0}'.\r\n            ":"\r\n              查找类似于不一致的可访问性的本地化字符串：返回类型'{1}'的访问范围不如委托'{0}'。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': cannot override because '{1}' does not have an overridable get accessor.\r\n            ":"\r\n              查找类似于'{0}'：不能覆盖的本地化字符串，因为'{1}'没有过多的get登录器。\r\n            \r\n","Passed in for reusability.":"通过可重复使用。\r\n","\r\n              Looks up a localized string similar to '{0}' does not contain a definition for '{1}'.\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串不包含'{1}'的定义。\r\n            \r\n","\r\n            Creates a summary element within an xml documentation comment.\r\n            ":"\r\n            在XML文档注释中创建摘要元素。\r\n            \r\n","Indicates whether instance members of this type are safe for multi-threaded operations.":"指示此类型的实例成员是否对多线程操作安全。\r\n","Merge conflict marker encountered":"遇到的合并冲突标记\r\n","<text>":"<文本>\r\n","\r\n              Looks up a localized string similar to The inherited members '{0}' and '{1}' have the same signature in type '{2}', so they cannot be overridden.\r\n            ":"\r\n              查找类似于继承的成员'{0}''和'{1}'在类型'{2}'中具有相同签名的本地化字符串，因此不能覆盖它们。\r\n            \r\n","\r\n              Looks up a localized string similar to Unrecognized option: '{0}'.\r\n            ":"\r\n              查找类似于未识别选项的本地化字符串：'{0}'。\r\n            \r\n","\r\n              Looks up a localized string similar to Metadata file '{0}' could not be found.\r\n            ":"\r\n              查找类似于元数据文件'{0}'的本地化字符串。\r\n            \r\n","\r\n            If true then the trees are equivalent if the contained nodes and tokens declaring metadata visible symbolic information are equivalent,\r\n            ignoring any differences of nodes inside method bodies or initializer expressions, otherwise all nodes and tokens must be equivalent.\r\n            ":"\r\n            如果为true，则树是等效的，如果包含的节点和代币声明元数据可见的符号信息是等效的，则\r\n            忽略方法物体或初始化器表达式内部节点的任何差异，否则所有节点和令牌都必须等效。\r\n            \r\n","\r\n              Looks up a localized string similar to The given expression is never of the provided ('{0}') type.\r\n            ":"\r\n              查找类似于给定表达式的本地化字符串永远不会提供所提供的（{0}'）类型。\r\n            \r\n","indicates whether this Script had a trailing expression":"指示此脚本是否具有尾声\r\n","Argument cannot be used as an output for parameter due to differences in the nullability of reference types.":"由于参考类型的无效性差异，参数不能用作参数的输出。\r\n","\r\n            If representative member is non-null and is contained in a constructed type, then find\r\n            other members in the same type with the same signature.  If this is an override member,\r\n            add them to the overridden and runtime overridden lists.  Otherwise, add them to the\r\n            hidden list.\r\n            ":"\r\n            如果代表成员是非无效的，并且包含在构造类型中，请找到\r\n            具有相同签名的同一类型的其他成员。如果这是覆盖成员，\r\n            将它们添加到覆盖和运行时覆盖的列表中。否则，将它们添加到\r\n            隐藏列表。\r\n            \r\n","\r\n            Compares the namespace and type name with the attribute's namespace and type name.\r\n            Returns true if they are the same.\r\n            ":"\r\n            将命名空间和键入名称与属性的名称空间和键入名称进行比较。\r\n            如果它们是相同的，则返回真实。\r\n            \r\n","'{0}': array elements cannot be of static type":"'{0}'：数组元素不能是静态类型\r\n","\r\n            Retrieves a well-known type member and reports diagnostics.\r\n            ":"\r\n            检索知名类型的成员并报告诊断。\r\n            \r\n","\r\n            Decide on what test to use at this node of the decision dag. This is the principal\r\n            heuristic we can change to adjust the quality of the generated decision automaton.\r\n            See https://www.cs.tufts.edu/~nr/cs257/archive/norman-ramsey/match.pdf for some ideas.\r\n            ":"\r\n            确定在决策DAG的该节点上使用的测试。这是校长\r\n            启发式我们可以更改以调整生成的决策自动机的质量。\r\n            请参阅https://www.cs.tufts.edu/~nr/cs257/archive/norman-ramsey/match.pdf，以获取一些想法。\r\n            \r\n","An equivalent path that does not contain any '..' or '.' path parts, or the original path.":"不包含任何“ ..”或“”的等效路径。路径零件或原始路径。\r\n","\r\n            Spec 7.5.12:\r\n            For constant expressions (expressions that can be fully evaluated at compile-time), \r\n            the default overflow checking context is always checked. Unless a constant expression \r\n            is explicitly placed in an unchecked context, overflows that occur during the compile-time \r\n            evaluation of the expression always cause compile-time errors.\r\n            ":"\r\n            规格7.5.12：\r\n            对于恒定表达式（可以在编译时可以充分评估的表达式），\r\n            始终检查默认溢出检查上下文。除非恒定表达\r\n            明确放置在未检查的上下文中，在编译时间期间发生的溢出\r\n            表达式的评估总是会导致编译时间错误。\r\n            \r\n","Converting method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?":"将方法组'{0}'转换为非贵族类型'{1}'。您打算调用该方法吗？\r\n","\r\n            Set in constructor, might be changed while decoding ":"\r\n            设置在构造函数中，解码时可能会更改\r\n","\r\n              Looks up a localized string similar to '{0}': cannot override inherited member '{1}' because it is sealed.\r\n            ":"\r\n              查找类似于'{0}'：无法覆盖的局部字符串，因为它是密封的，因此无法覆盖继承的成员'{1}'。\r\n            \r\n","\r\n            Gets the \"Dispose\" method.\r\n            ":"\r\n            获取“处置”方法。\r\n            \r\n","Class which represents the syntax node for element access expression.":"代表用于元素访问表达式的语法节点的类。\r\n","\r\n            Returns true if the symbol is effectively public or internal based on\r\n            the declared accessibility of the symbol and any containing symbols.\r\n            ":"\r\n            如果该符号有效地公开或基于内部，则返回为true\r\n            已声明的符号和任何包含符号的可访问性。\r\n            \r\n","\r\n             The purpose of this method is to determine if the expression is classified by the \r\n             specification as a *variable*. If it is not then this code gives an appropriate error message.\r\n            \r\n             To determine the appropriate error message we need to know two things:\r\n            \r\n             (1) why do we want to know if this is a variable? Because we are trying to assign it,\r\n                 increment it, or pass it by reference?\r\n            \r\n             (2) Are we trying to determine if the left hand side of a dot is a variable in order\r\n                 to determine if the field or property on the right hand side of a dot is assignable?\r\n             ":"\r\n             该方法的目的是确定表达式是否由\r\n             规范为 *变量 *。如果不是，则此代码会提供适当的错误消息。\r\n            \r\n             要确定适当的错误消息，我们需要知道两件事：\r\n            \r\n             （1）我们为什么要知道这是否是变量？因为我们正在尝试分配它，所以\r\n                 将其递增，还是通过引用传递？\r\n            \r\n             （2）我们是否试图确定点的左侧是否为变量\r\n                 确定点的右侧的字段或属性是否可分配？\r\n             \r\n","'{0}': user-defined conversions to or from a base type are not allowed":"'{0}'：不允许往返基本类型的用户定义的转换\r\n"," for explicit.":" 为了显式。\r\n","\r\n            Generate logic to reset the current instance (rather than creating a new instance)\r\n            ":"\r\n            生成逻辑以重置当前实例（而不是创建新实例）\r\n            \r\n","A get or set accessor expected":"预期的get或设置登录器\r\n","True if documentation comments should be\r\n            included, false by default.":"如果文档评论应该是\r\n            包括，默认情况下为fals。\r\n","\r\n            Generates a lowered form of the assignment operator for the given left and right sub-expressions.\r\n            Left and right sub-expressions must be in lowered form.\r\n            ":"\r\n            为给定的左右子表达式生成降低的分配操作员形式。\r\n            左右子表达必须以降低形式。\r\n            \r\n","Operator '{0}' is ambiguous on operands of type '{1}' and '{2}'":"操作员'{0}'对'{1}'和'{2}'的操作数含糊不清\r\n","\r\n              Looks up a localized string similar to Partial method declarations of '{0}' have inconsistent type parameter constraints.\r\n            ":"\r\n              查找类似于“ {0}”的部分方法声明的本地化字符串，具有不一致的类型参数约束。\r\n            \r\n","Arrays as attribute arguments is not CLS-compliant":"数组作为属性参数不符合CLS\r\n","Called when the visitor visits a OrderingSyntax node.":"当访问者访问有序字母节点时，请致电。\r\n","(Location of symbol related to previous warning)":"（与以前警告相关的符号的位置）\r\n","\r\n            Is this a property of a tuple type?\r\n            ":"\r\n            这是元组类型的属性吗？\r\n            \r\n","      | yes | yes |   match   |\r\n             ":"      |是|是|匹配|\r\n             \r\n","True to leave the ":"真实离开\r\n","\r\n              Looks up a localized string similar to Async methods are not allowed in an Interface, Class, or Structure which has the 'SecurityCritical' or 'SecuritySafeCritical' attribute..\r\n            ":"\r\n              在接口，类或结构中不允许查找类似于异步方法的本地化字符串，该界面，类或结构中具有“安全性”或“ securitySafecritical”属性。\r\n            \r\n","\r\n            This instance is intended to reflect the definition of signature equality used by the runtime \r\n            (":"\r\n            此实例旨在反映运行时使用的签名平等的定义\r\n            （（\r\n","Called when the visitor visits a ForEachStatementSyntax node.":"当访问者访问一个foreachStatementsyntax节点时，请致电。\r\n","Unnecessary using directive":"不必要使用指令\r\n","Feature '{0}' is not available in C# 8.0. Please use language version {1} or greater.":"C＃8.0中不可用功能'{0}'。请使用语言版本{1}或更大。\r\n","local function attributes":"本地功能属性\r\n","\r\n              Looks up a localized string similar to binary literals.\r\n            ":"\r\n              查找类似于二进制文字的局部字符串。\r\n            \r\n","The tuple element names in the signature of method '{0}' must match the tuple element names of interface method '{1}' (including on the return type).":"方法'{0}'签名中的元组元素名称必须匹配接口方法'{1}'的元组元素名称（包括返回类型）。\r\n","Gets the close paren keyword.":"获取Close Paren关键字。\r\n","\r\n            In C# lambda bodies are expressions or block statements. In both cases it's a single node.\r\n            In VB a lambda body might be a sequence of nodes (statements). \r\n            We define this function to minimize differences between C# and VB implementation.\r\n            ":"\r\n            在c＃lambda中是表达式或块语句。在这两种情况下，它都是一个节点。\r\n            在VB中，lambda体可能是一系列节点（语句）。\r\n            我们定义此功能，以最大程度地减少C＃和VB实现之间的差异。\r\n            \r\n","\r\n              Looks up a localized string similar to  The parameter modifier 'ref' cannot be used with 'this' .\r\n            ":"\r\n              查找类似于参数修饰符“ ref”的本地化字符串，不能与“ this”一起使用。\r\n            \r\n","\r\n              Looks up a localized string similar to No best type found for implicitly-typed array.\r\n            ":"\r\n              查找与隐型型数组相似的本地化字符串类似于未找到的最佳类型。\r\n            \r\n","The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'":"'{0}'在'{2}'中与名称空间'{3}'冲突的类型'{1}'在'{2}'中冲突\r\n","\r\n            Contains methods related to synthesizing bound nodes in lowered form \r\n            that does not need any processing before passing to codegen\r\n            ":"\r\n            包含与降低形式合成结合节点有关的方法\r\n            在传递给Codegen之前，不需要任何处理\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' is a type not supported by the language.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串是该语言不支持的类型。\r\n            \r\n","\r\n            Expression is a r/o reference.\r\n            ":"\r\n            表达是R/O参考。\r\n            \r\n","\r\n            A \"not a number\" value for the floating-point type ":"\r\n            浮点类型的“不是数字”值\r\n","\r\n              Looks up a localized string similar to Asynchronous foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a suitable public instance definition for '{1}'.\r\n            ":"\r\n              查找类似于异步的foreach语句类似的本地化字符串无法在类型'{0}'的变量上操作，因为'{0}'不包含适合'{1}'的合适的公共实例定义。\r\n            \r\n","\r\n            Create a value from the expression that can be used as a left-hand-side\r\n            of a member access. This method special-cases method and property\r\n            groups only. All other expressions are returned as is.\r\n            ":"\r\n            从表达式中创建一个可以用作左侧的值\r\n            会员访问。此方法特殊案例方法和属性\r\n            仅组。所有其他表达式都按原样返回。\r\n            \r\n","Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.":"提供代表名称语法节点的类的基类。这是一个抽象类。\r\n"," adds synthesized explicit implementations to the list of synthesized definitions.\r\n            In lieu of running ":" 将合成的显式实现添加到合成定义列表中。\r\n            代替跑步\r\n","The type to be rewritten.":"要重写的类型。\r\n","\r\n              Looks up a localized string similar to '{0}' is obsolete.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串已过时。\r\n            \r\n","\r\n            A list of all locals or parameters that were declared in this scope and captured\r\n            in this scope or nested scopes. \"Declared\" refers to the start of the variable\r\n            lifetime (which, at this point in lowering, should be equivalent to lexical scope).\r\n            ":"\r\n            在此范围内声明并捕获的所有当地人或参数的列表\r\n            在此范围或嵌套范围内。 “已声明”是指变量的开始\r\n            生命周期（在降低的这一点上，应等于词汇范围）。\r\n            \r\n",".  It operates as follows:\r\n            \r\n            First, an analysis of the whole method body is performed that determines which variables are\r\n            captured, what their scopes are, and what the nesting relationship is between scopes that\r\n            have captured variables.  The result of this analysis is left in ":"。它运行如下：\r\n            \r\n            首先，对整个方法主体进行了分析，以确定哪些变量是\r\n            被捕获，它们的范围是什么，以及在范围之间的嵌套关系是什么\r\n            捕获了变量。该分析的结果留在\r\n","\r\n              Looks up a localized string similar to Async lambda expression converted to a 'Task' returning delegate cannot return a value. Did you intend to return 'Task<T>'?.\r\n            ":"\r\n              查找类似于ASYNC lambda表达式类似的本地化字符串，转换为“任务”返回委托无法返回值。您是否打算返回“任务<t>”？\r\n            \r\n","\r\n              Looks up a localized string similar to Partial method declarations of '{0}' have inconsistent nullability in constraints for type parameter '{1}'.\r\n            ":"\r\n              查找类似于“ {0}”的部分方法声明类似的本地化字符串，对类型参数'{1}'的约束不一致。\r\n            \r\n","\r\n              Looks up a localized string similar to obsolete on property accessor.\r\n            ":"\r\n              查找类似于属性登录机的局部字符串。\r\n            \r\n","Invalid token '{0}' in class, record, struct, or interface member declaration":"在类，记录，struct或Interface成员声明中无效的令牌'{0}'\r\n","\r\n            To represent a gap in interface's v-table null value should be returned in the appropriate position,\r\n            unless the gap has a symbol (happens if it is declared in source, for example).\r\n            ":"\r\n            为了表示接口的v台式空值中的差距，应在适当的位置返回\r\n            除非差距具有一个符号（例如，如果在源中声明为符号）。\r\n            \r\n","Nullability of reference types in type of parameter doesn't match implemented member (possibly because of nullability attributes).":"参数类型中参考类型的无效性不匹配实现的成员（可能是由于无效属性）。\r\n","The expression to bind":"结合的表达\r\n","\r\n            This method must be invoked only after all the assembly attributes have been bound.\r\n            ":"\r\n            只有在所有汇编属性绑定后才调用此方法。\r\n            \r\n","\r\n              Looks up a localized string similar to Constructor '{0}' cannot call itself.\r\n            ":"\r\n              查找类似于构造函数'{0}'的本地化字符串无法调用。\r\n            \r\n","\r\n              Looks up a localized string similar to The best overloaded Add method '{0}' for the collection initializer element is obsolete..\r\n            ":"\r\n              查找类似于收集初始化器元素的最佳超载添加方法'{0}'的本地化字符串已过时..\r\n            \r\n","\r\n            If a local function is in the set, at some point in the code it is converted to a delegate and should then not be optimized to a struct closure.\r\n            Also contains all lambdas (as they are converted to delegates implicitly).\r\n            ":"如果本地函数在集合中，则在代码中的某个时刻将其转换为委托，因此不应优化到结构闭合。\r\n            还包含所有lambdas（因为它们被隐式转换为代表）。\r\n            \r\n"," nodes.\r\n             Those last two nested nodes have no ":" 节点。\r\n             最后两个嵌套节点没有\r\n","\r\n            when current and other use spans are regular spans we can have only 2 conflict cases:\r\n            [1, 3) conflicts with [0, 2)\r\n            [1, 3) conflicts with [2, 4)\r\n            \r\n            NOTE: with regular spans, it is not possible for two spans to share an edge point \r\n            unless they belong to the same local. (because we cannot access two real locals at the same time)\r\n            \r\n            specifically:\r\n            [1, 3) does not conflict with [0, 1)   since such spans would need to belong to the same local\r\n            ":"\r\n            当当前和其他使用跨度是常规跨度时，我们只能有2个冲突案例：\r\n            [1，3）与[0，2）冲突\r\n            [1，3）与[2，4）冲突\r\n            \r\n            注意：有了常规跨度，两个跨度不可能共享一个边缘\r\n            除非它们属于同一本地。 （因为我们无法同时访问两个真正的当地人）\r\n            \r\n            具体来说：\r\n            [1，3）与[0，1）不冲突，因为这种跨度需要属于同一局部\r\n            \r\n","\r\n              Looks up a localized string similar to Assembly and module attributes are not allowed in this context.\r\n            ":"\r\n              查找类似于汇编的本地化字符串，在此上下文中不允许模块属性。\r\n            \r\n","\r\n            True iff the parameter has a default argument syntax, \r\n            or the parameter is not a params-array and Optional metadata flag is set.\r\n            ":"\r\n            正确iff参数具有默认参数语法，\r\n            否则参数不是参数阵列，并且设置了可选的元数据标志。\r\n            \r\n","The name of the xml text attribute.":"XML文本属性的名称。\r\n","\r\n            Returns the expression if the statement is actually an expression (ExpressionStatementSyntax with no trailing semicolon).\r\n            ":"\r\n            如果该语句实际上是一个表达式（expressionStattatementsyntax，notailing semicolon），则返回表达式。\r\n            \r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 7.3. Please use language version {1} or greater..\r\n            ":"\r\n              查找类似于功能“ {0}”的本地化字符串在C＃7.3中不可用。请使用语言版本{1}或更大。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': static types cannot be used as return types.\r\n            ":"\r\n              查找类似于“ {0}'：静态类型的本地化字符串，不能用作返回类型。\r\n            \r\n","\r\n            Ends at appropriate quotation mark, EOF, or EndOfDocumentationComment.\r\n            ":"\r\n            以适当的报价标记，EOF或EndofocumentationComment结束。\r\n            \r\n","\r\n              Looks up a localized string similar to Use of possibly unassigned field '{0}'.\r\n            ":"\r\n              查找类似于使用可能未分配的字段'{0}'的本地化字符串。\r\n            \r\n","Attribute parameter '{0}' or '{1}' must be specified.":"必须指定属性参数'{0}'或'{1}'。\r\n","The body of '{0}' cannot be an iterator block because '{0}' returns by reference":"'{0}'的主体不能是迭代器块，因为'{0}'通过参考返回\r\n","A using clause must precede all other elements defined in the namespace except extern alias declarations":"A使用子句必须先于名称空间中定义的所有其他元素，除了外部别名声明\r\n","\r\n            Returns the module containing this symbol. If this symbol is shared across multiple\r\n            modules, or doesn't belong to a module, returns null.\r\n            ":"\r\n            返回包含此符号的模块。如果此符号在多个\r\n            模块，或不属于模块，返回null。\r\n            \r\n","\r\n            The candidate member was rejected because a named argument was specified that did not have a corresponding\r\n            parameter.\r\n            ":"\r\n            候选人成员被拒绝，因为指定了没有相应的参数\r\n            范围。\r\n            \r\n","Inconsistent accessibility: return type '{1}' is less accessible than delegate '{0}'":"不一致的可访问性：返回类型'{1}'比委托'{0}\r\n","'new' cannot be used with tuple type. Use a tuple literal expression instead.":"“新”不能与元组类型一起使用。改用元组文字表达式。\r\n"," for a return type.":" 对于返回类型。\r\n","\r\n            Returns the type to be used as a field type; generates errors in case the type is not\r\n            supported for anonymous type fields.\r\n            ":"返回要用作字段类型的类型；如果类型不是\r\n            支持匿名类型字段。\r\n            \r\n","Creates a new TryStatementSyntax instance.":"创建一个新的trystatementsyntax实例。\r\n","\r\n              Looks up a localized string similar to Thrown value may be null..\r\n            ":"\r\n              查找类似于投掷值的本地化字符串可能为空。\r\n            \r\n",",\r\n            or is the ":"，，，，\r\n            还是\r\n","\r\n              Looks up a localized string similar to A partial method cannot have out parameters.\r\n            ":"\r\n              查找类似于部分方法的本地化字符串不能具有输出参数。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': static classes cannot contain protected members.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串：静态类不能包含受保护的成员。\r\n            \r\n","\r\n            Find the most specific among a set of conversion operators, with the given constraint on the conversion.\r\n            ":"\r\n            在一组转换运算符中找到最具体的，对转换的给定约束。\r\n            \r\n"," A synthesized entrypoint that forwards all calls to an async Main Method ":" 一个合成的入口点，将所有调用转发到异步主方法\r\n","How to speculatively bind the given expression. If this is ":"如何投机绑定给定表达式。如果是\r\n","\r\n            Dynamic call-site delegate, for call-sites that do not\r\n            match System.Action or System.Func signatures.\r\n            ":"\r\n            动态呼叫站点代表，对于不呼叫的位置\r\n            匹配系统或系统签名。\r\n            \r\n","\r\n            State of method group receivers, used later when analyzing the conversion to a delegate.\r\n            (Could be replaced by _analyzedNullabilityMapOpt if that map is always available.)\r\n            ":"\r\n            方法组接收器的状态，以后在分析转换为委托时使用。\r\n            （如果该地图始终可用，则可以用_analyzednullabilitymapopt替换。）\r\n            \r\n","\r\n            Compares content of two nodes ignoring lambda bodies and trivia.\r\n            ":"\r\n            比较两个节点的含量忽略了lambda身体和琐事。\r\n            \r\n","\r\n              Looks up a localized string similar to An add or remove accessor must have a body.\r\n            ":"\r\n              查找类似于添加或卸下访问者的局部字符串必须具有身体。\r\n            \r\n","\r\n              Looks up a localized string similar to The return type of an async method must be void, Task or Task<T>.\r\n            ":"\r\n              查找类似于异步方法的返回类型的本地化字符串必须是无效，任务或任务<t>。\r\n            \r\n"," attribute.\r\n            This property returns ":" 属性。\r\n            此属性返回\r\n","\r\n            Given a labeled statement syntax, get the corresponding label symbol.\r\n            ":"\r\n            给定标记的语句语法，获取相应的标签符号。\r\n            \r\n","Nullability of reference types in type of parameter '{0}' doesn't match partial method declaration.":"参数类型中参考类型的无效性'{0}'与部分方法声明不匹配。\r\n","\r\n            True if this environment captures a reference to a class environment\r\n            declared in a higher scope. Assigned by\r\n            ":"\r\n            如果此环境捕获了对班级环境的参考\r\n            在较高的范围内宣布。分配\r\n            \r\n","\r\n            If a sealed override property defines fewer accessors than the\r\n            original virtual property, it is necessary to synthesize a sealed\r\n            accessor so that the accessor will not be overridable from metadata.\r\n            ":"如果密封的覆盖属性定义了少于\r\n            原始虚拟特性，有必要合成密封的\r\n            登录器，因此登录器不会从元数据中填充。\r\n            \r\n"," depending on the\r\n            return type of the async method.\r\n            ":" 取决于\r\n            返回异步方法的类型。\r\n            \r\n","\r\n            Derived from Dev10's BSYMMGR::UnifyTypes.\r\n            Two types will not unify if they have different custom modifiers.\r\n            ":"\r\n            源自Dev10的BSymmgr :: UnifyTypes。\r\n            如果有不同的自定义修饰符，则两种类型将不统一。\r\n            \r\n","\r\n            Module's custom attributes\r\n            ":"\r\n            模块的自定义属性\r\n            \r\n","\r\n            We can't use BindNamespaceOrTypeSymbol, since it doesn't return inaccessible symbols (directly).\r\n            ":"\r\n            我们不能使用BindNames -paceOrtyPesymbol，因为它不会直接返回无法访问的符号。\r\n            \r\n","\r\n             Bind the constructor initializer in the context of the specified location and get semantic information\r\n             such as type, symbols and diagnostics. This method is used to get semantic information about a constructor\r\n             initializer that did not actually appear in the source code.\r\n            \r\n             NOTE: This will only work in locations where there is already a constructor initializer.\r\n             ":"在指定位置的上下文中绑定构造函数初始化器并获取语义信息\r\n             例如类型，符号和诊断。此方法用于获取有关构造函数的语义信息\r\n             实际上并未出现在源代码中的初始化程序。\r\n            \r\n             注意：这只能在已经有构造函数初始化器的位置工作。\r\n             \r\n","\r\n            Returns whether this method is async and returns a generic task.\r\n            ":"\r\n            返回该方法是否为异步并返回一项通用任务。\r\n            \r\n","\r\n            Gets the expression-body syntax from an expression-bodied member. The\r\n            given syntax must be for a member which could contain an expression-body.\r\n            ":"\r\n            从表达构件中获取表达体语法。这\r\n            给定语法必须适用于可能包含表达体的成员。\r\n            \r\n","\r\n            Try parse a ":"\r\n            尝试解析a\r\n","\r\n              Looks up a localized string similar to A partial method may not have multiple defining declarations.\r\n            ":"\r\n              查找类似于部分方法的本地化字符串可能没有多个定义声明。\r\n            \r\n","Cannot return a value from an iterator. Use the yield return statement to return a value, or yield break to end the iteration.":"无法从迭代器返回值。使用收益率返回语句返回值或收益率中断以结束迭代。\r\n","\r\n            VariablesSnapshot instance for containing method, or null if this is the outermost method.\r\n            ":"\r\n            用于包含方法的variablessnapshot实例，如果这是最外层的方法，则为null。\r\n            \r\n","Called when the visitor visits a SwitchExpressionSyntax node.":"访问者访问switchexpressyntax节点时调用。\r\n","\r\n            This method is intended to match spec section 13.1.3.1 as closely as possible \r\n            (except that the output-unsafe and input-unsafe checks are merged).\r\n            ":"\r\n            此方法旨在尽可能匹配规格第13.1.3.1节\r\n            （除非合并了输出安全性和输入-UNSAFE检查）。\r\n            \r\n","Callback argument.":"回调参数。\r\n","\r\n            The same named type, but without element names.\r\n            ":"\r\n            相同的命名类型，但没有元素名称。\r\n            \r\n","\r\n            Gets the immediately containing symbol of the ":"\r\n            立即包含\r\n","Cannot create an array with a negative size":"无法创建一个负大小的数组\r\n","Populated appropriately.":"填充适当。\r\n","\r\n              Looks up a localized string similar to Invalid '{0}' value: '{1}'..\r\n            ":"\r\n              查找类似于无效'{0}'值的本地化字符串：'{1}'..\r\n            \r\n","'{0}' does not contain a definition for '{1}' and no accessible extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive or an assembly reference?)":"'{0}'不包含'{1}'的定义，并且可以找到一个类型'{0}'的第一个参数（您缺少使用指令还是汇编）参考？）\r\n","\r\n            For every other submission referenced by this submission we add a field, so that we can access members of the target submission.\r\n            A field is also needed for the host object, if provided.\r\n            ":"\r\n            对于本提交的所有其他提交提交的提交，我们添加了一个字段，以便我们可以访问目标提交的成员。\r\n            如果提供，也需要主机对象的字段。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': cannot derive from sealed type '{1}'.\r\n            ":"\r\n              查找类似于'{0}'：不能从密封类型'{1}'派生的本地化字符串。\r\n            \r\n","Class which represents the syntax node for an \"await\" expression.":"代表“等待”表达式的语法节点的类。\r\n","\r\n            Produce a bound expression representing a pointer to a frame of a particular frame class.\r\n            Note that for generic frames, the frameClass parameter is the generic definition, but\r\n            the resulting expression will be constructed with the current type parameters.\r\n            ":"\r\n            产生代表指向特定帧类帧的指针的界表达式。\r\n            请注意，对于通用帧，FrameClass参数是通用定义，但是\r\n            结果表达式将使用当前类型参数构建。\r\n            \r\n","The name of the xml element.":"XML元素的名称。\r\n","\r\n              Looks up a localized string similar to Conflicting options specified: Win32 resource file; Win32 manifest.\r\n            ":"\r\n              查找类似于指定的相互冲突选项的本地化字符串：WIN32资源文件； Win32清单。\r\n            \r\n","\r\n              Looks up a localized string similar to Multiple implementations of the query pattern were found for source type '{0}'.  Ambiguous call to '{1}'..\r\n            ":"\r\n              查找与源类型的“ {0}”的局部字符串类似于查询模式的多个实现。模棱两可的呼吁“ {1}'..\r\n            \r\n","The property or indexer '{0}' cannot be used in this context because it lacks the get accessor":"在此上下文中不能使用属性或索引器'{0}'，因为它缺少GET登录器\r\n","\r\n              Looks up a localized string similar to Static classes cannot have instance constructors.\r\n            ":"\r\n              查找类似于静态类的本地化字符串不能具有实例构造函数。\r\n            \r\n","\r\n            The decision tree to use if the Guard evaluates to false.\r\n            ":"\r\n            如果警卫评估为false，则使用的决策树。\r\n            \r\n","\r\n            Name of the namespace, must be not empty.\r\n            ":"\r\n            名称的名称必须不为空。\r\n            \r\n","\r\n              Looks up a localized string similar to The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'.\r\n            ":"\r\n              查找类似于表达式结果的本地化字符串始终是“ {0}”，因为类型'{1}'的值永远不会等于类型'{2}'的'null'。\r\n            \r\n","A method with vararg cannot be generic, be in a generic type, or have a params parameter":"带有vararg的方法不能是通用的，是通用类型或具有参数\r\n"," nodes.\r\n             Its first nested node has no ":" 节点。\r\n             它的第一个嵌套节点没有\r\n","CLS-compliant field '{0}' cannot be volatile":"符合CLS的字段'{0}'不能挥发\r\n","\r\n              Looks up a localized string similar to {0} version {1}.\r\n            ":"\r\n              查找类似于{0}版本{1}的本地化字符串。\r\n            \r\n","Module '{0}' is already defined in this assembly. Each module must have a unique filename.":"模块'{0}'已在此组件中定义。每个模块必须具有唯一的文件名。\r\n","\r\n            when current and other use spans are regular spans we can have only 2 conflict cases:\r\n            [1, 3) conflicts with [0, 2)\r\n            [1, 3) conflicts with [2, 4)\r\n            \r\n            NOTE: with regular spans, it is not possible for two spans to share an edge point \r\n            unless they belong to the same local. (because we cannot aceess two real locals at the same time)\r\n            \r\n            specifically:\r\n            [1, 3) does not conflict with [0, 1)   since such spans would need to belong to the same local\r\n            ":"\r\n            当当前和其他使用跨度是常规跨度时，我们只能有2个冲突案例：\r\n            [1，3）与[0，2）冲突\r\n            [1，3）与[2，4）冲突\r\n            \r\n            注意：有了常规跨度，两个跨度不可能共享一个边缘\r\n            除非它们属于同一本地。 （因为我们不能同时尊重两个真正的当地人）\r\n            \r\n            具体来说：\r\n            [1，3）与[0，1）不冲突，因为这种跨度需要属于同一局部\r\n            \r\n","Embedding the interop type '{0}' from assembly '{1}' causes a name clash in the current assembly. Consider setting the 'Embed Interop Types' property to false.":"嵌入Interop类型“ {0}”中的'{1}'导致当前汇编中的名称冲突。考虑将“嵌入Interop类型”属性设置为false。\r\n","s in depth-first order.\r\n            ":"s在一阶的深处。\r\n            \r\n","\r\n            Build an object creation expression without performing any rewriting\r\n            ":"\r\n            在不执行任何重写的情况下构建对象创建表达式\r\n            \r\n","Member that is hiding or overriding.":"隐藏或覆盖的成员。\r\n"," to avoid early resolution of nullable types":" 避免尽早解决无效类型\r\n","\r\n              Looks up a localized string similar to Instance of type '{0}' cannot be used inside a nested function, query expression, iterator block or async method.\r\n            ":"\r\n              在嵌套函数，查询表达式，迭代块或异步方法中查找类似于类型的'{0}'实例的本地化字符串。\r\n            \r\n","Global analyzer config section name '{0}' is invalid as it is not an absolute path. Section will be ignored. Section was declared in file: '{1}'":"Global Analyzer配置部分名称“ {0}”是无效的，因为它不是绝对路径。节将被忽略。部分在文件中声明：'{1}'\r\n","\r\n            Find the shortest path from the root node to the node of interest.\r\n            ":"\r\n            从根节点到感兴趣的节点找到最短路径。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot continue since the edit includes a reference to an embedded type: '{0}'..\r\n            ":"\r\n              查找类似于类似的本地化字符串，因为编辑包括对嵌入式类型的引用：'{0}'..\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' hides inherited member '{1}'. Use the new keyword if hiding was intended..\r\n            ":"\r\n              查找类似于'{0}'隐藏成员'{1}'的本地化字符串。如果隐藏的话，请使用新的关键字。\r\n            \r\n","\r\n            Lower a test followed by an evaluation into a side-effect followed by a test. This permits us to optimize\r\n            a type test followed by a cast into an `as` expression followed by a null check. Returns true if the optimization\r\n            applies and the results are placed into ":"\r\n            降低测试，然后对副作用进行评估，然后进行测试。这允许我们优化\r\n            类型测试，然后将铸件施加到“ AS”表达式中，然后进行空检查。如果优化，返回true\r\n            适用并将结果放入\r\n","\r\n            Compute the type code for the comparison operator to be used.  When comparing `byte`s for example,\r\n            the compiler actually uses the operator on the type `int` as there is no corresponding operator for\r\n            the type `byte`.\r\n            ":"\r\n            计算要使用的比较操作员的类型代码。例如，在比较“字节”时，\r\n            编译器实际上在类型`int'上使用运算符，因为没有相应的操作符\r\n            类型“字节”。\r\n            \r\n","Creates a new SelectClauseSyntax instance.":"创建一个新的SelectClausesyntax实例。\r\n","\r\n            Returns a possibly ExtensionAttribute filtered roArray of attributes. If\r\n            filterExtensionAttributes is set to true, the method will remove all ExtensionAttributes\r\n            from the returned array. If it is false, the parameter foundExtension will always be set to\r\n            false and can be safely ignored.\r\n            \r\n            The paramArrayAttribute parameter is similar to the foundExtension parameter, but instead\r\n            of just indicating if the attribute was found, the parameter is set to the attribute handle\r\n            for the ParamArrayAttribute if any is found and is null otherwise. This allows NoPia to filter\r\n            the attribute out for the symbol but still cache it separately for emit.\r\n            ":"\r\n            返回可能的扩展归因于属性的过滤roarray。如果\r\n            FilterExtensionAttributes设置为true，该方法将删除所有扩展名称\r\n            从返回的数组中。如果是错误的，则发现的参数始终将设置为\r\n            错误，可以安全地忽略。\r\n            \r\n            paramarrayattribute参数类似于undextension参数，但\r\n            仅指示是否找到属性，该参数设置为属性句柄\r\n            对于paramarrayattribute，如果找到了，否则为空。这使NOPIA可以过滤\r\n            符号的属性，但仍将其分别缓存以进行发射。\r\n            \r\n","Cannot define a new extension method because the compiler required type '{0}' cannot be found. Are you missing a reference to System.Core.dll?":"无法定义新的扩展方法，因为找不到编译器所需类型的“ {0}”。您是否缺少对system.core.dll的引用？\r\n","Class which represents the syntax node for Checked or Unchecked expression.":"代表用于检查或未选中表达式的语法节点的类。\r\n","\r\n              Looks up a localized string similar to An expression of type '{0}' can never match the provided pattern..\r\n            ":"\r\n              查找类似于“ {0}”类型的表达式的本地化字符串永远无法匹配所提供的模式。\r\n            \r\n"," (Identity).\r\n             Its second nested node has a ":" （身份）。\r\n             它的第二个嵌套节点有一个\r\n","\r\n            A pending branch.  These are created for a return, break, continue, goto statement,\r\n            yield return, yield break, await expression, and await foreach/using. The idea is that\r\n            we don't know if the branch will eventually reach its destination because of an\r\n            intervening finally block that cannot complete normally.  So we store them up and handle\r\n            them as we complete processing each construct.  At the end of a block, if there are any\r\n            pending branches to a label in that block we process the branch.  Otherwise we relay it\r\n            up to the enclosing construct as a pending branch of the enclosing construct.\r\n            ":"\r\n            一个待处理的分支。这些是为了返回，休息，继续，goto语句，\r\n            收益回报，收益率中断，等待表达和等待/使用。想法是\r\n            我们不知道该分支是否最终会因为\r\n            介入最终无法正常完成。所以我们将它们存放并处理\r\n            当我们完成每个构造时，它们。在块的末尾，如果有\r\n            在该块中的标签上等待分支，我们处理分支。否则我们会中继\r\n            直至封闭构造作为封闭构造的待处理分支。\r\n            \r\n"," applied to a specified metadata symbol and\r\n            transforms the specified metadata type, using the decoded dynamic transforms attribute argument,\r\n            by replacing each occurrence of ":" 应用于指定的元数据符号和\r\n            使用解码的动态变换属性参数转换指定的元数据类型，\r\n            通过替换每次发生\r\n","\r\n              Looks up a localized string similar to '{0}': explicit interface declaration can only be declared in a class or struct.\r\n            ":"\r\n              查找类似于“ {0}'的本地化字符串：显式接口声明只能在类或结构中声明。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' is already listed in the interface list on type '{2}' with different tuple element names, as '{1}'..\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串已在类型'{2}'的接口列表中列出，带有不同的元组元素名称，为'{1}'..\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid instrumentation kind: {0}.\r\n            ":"\r\n              查找类似于无效仪器类型的本地化字符串：{0}。\r\n            \r\n","Could not find '{0}' specified for Main method":"找不到针对主要方法指定的'{0}'\r\n","\r\n              Looks up a localized string similar to Provided language version is unsupported or invalid: '{0}'..\r\n            ":"\r\n              查找类似于提供的语言版本的本地化字符串不受支持或无效：'{0}'..\r\n            \r\n","\r\n            Owning assembly.\r\n            ":"\r\n            拥有组装。\r\n            \r\n","\r\n            Creates a token with kind NumericLiteralToken from a 4-byte unsigned integer value.\r\n            ":"\r\n            从4个字节的无符号整数值中创建具有属性数字的令牌。\r\n            \r\n","\r\n            Global imports not including those from previous submissions.\r\n            ":"\r\n            全球进口不包括先前提交的进口。\r\n            \r\n","\r\n              Looks up a localized string similar to Member modifier '{0}' must precede the member type and name.\r\n            ":"\r\n              查找类似于成员修饰符'{0}'的本地化字符串必须先于成员类型和名称。\r\n            \r\n","\r\n              Looks up a localized string similar to SecurityAction value '{0}' is invalid for PrincipalPermission attribute.\r\n            ":"\r\n              查找类似于SecurityAction值'{0}'的本地化字符串对于princionalPermission属性无效。\r\n            \r\n","\r\n              Looks up a localized string similar to Indexers cannot have void type.\r\n            ":"\r\n              查找类似于索引器的本地化字符串不能具有void类型。\r\n            \r\n","\r\n              Looks up a localized string similar to Constructor is marked external.\r\n            ":"\r\n              查找类似于构造函数的本地化字符串是外部标记的。\r\n            \r\n","A partial method may not explicitly implement an interface method":"部分方法可能无法明确实现接口方法\r\n",".  This is needed for testing because\r\n            the default ToString output for float and double changed between desktop and .net core,\r\n            and also because we want the string representation to be locale-independent.\r\n            ":"。这是测试所需的，因为\r\n            float的默认tostring输出，并在桌面和.NET核心之间进行双重更改，\r\n            也是因为我们希望字符串表示与区域无关。\r\n            \r\n","A character position used to identify a declaration scope and accessibility. This\r\n            character position must be within the FullSpan of the Root syntax node in this SemanticModel. In order to obtain\r\n            the correct scoping rules for the attribute, position should be the Start position of the Span of the symbol that\r\n            the attribute is being applied to.\r\n            ":"用于标识声明范围和可访问性的角色位置。这个\r\n            字符位置必须在此semanticmodel中的root语法节点的成面内。为了得到\r\n            属性的正确范围规则，位置应为符号跨度的开始位置\r\n            该属性正在应用于。\r\n            \r\n","\r\n            recursively to produce bound nodes that implement it.\r\n            ":"递归产生实施它的界点。\r\n            \r\n","\r\n              Looks up a localized string similar to default literal.\r\n            ":"\r\n              查找类似于默认文字的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to A default literal 'default' is not valid as a pattern. Use another literal (e.g. '0' or 'null') as appropriate. To match everything, use a discard pattern 'var _'..\r\n            ":"\r\n              查找类似于默认字体“默认”的本地化字符串无效作为模式。适当地使用另一个文字（例如'0'或'null'）。要匹配所有内容，请使用丢弃模式“ var _” ..\r\n            \r\n","\r\n            True if Out flag is set in metadata.\r\n            ":"\r\n            如果在元数据中设置了Out Flag，则为真实。\r\n            \r\n","\r\n            Used to resolve continue statements in each statement form that supports it.\r\n            ":"用来解决支持它的每个语句形式中的继续语句。\r\n            \r\n"," operation directly on the receiver, instead of\r\n            using System.Index helpers.\r\n            ":" 直接在接收器上操作，而不是\r\n            使用System.Index助手。\r\n            \r\n","Called when the visitor visits a ConditionalExpressionSyntax node.":"当访问者访问条件alexpressionsyntax节点时，请致电。\r\n",".HasValue":".hasvalue\r\n","Attach attributes to the backing fields for auto-implemented properties":"将属性附加到自动实施属性的背景字段\r\n","'{0}': new protected member declared in struct":"'{0}'：在struct中声明的新受保护成员\r\n","\r\n            Bind the expression and verify the expression matches the combination of lvalue and\r\n            rvalue requirements given by valueKind. If the expression was bound successfully, but\r\n            did not meet the requirements, the return value will be a ":"\r\n            绑定表达式并验证表达与LVALUE和\r\n            RVALUE要求由ValueKind给出。如果表达成功地束缚，但是\r\n            没有满足要求，回报值将是\r\n","'{0}' is for evaluation purposes only and is subject to change or removal in future updates.":"'{0}'仅用于评估目的，并且可能会在以后的更新中进行更改或删除。\r\n","\r\n            Checks if the given type implements (or extends, in the case of an interface),\r\n            System.Collections.IEnumerable or System.Collections.Generic.IEnumerable<T>,\r\n            (or System.Collections.Generic.IAsyncEnumerable<T>)\r\n            for at least one T.\r\n            ":"\r\n            检查给定类型是否实施（或扩展，在接口的情况下），\r\n            system.collections.ienumerable或system.collections.generic.ienumerable <t>，\r\n            （或system.collections.generic.iasyncenumerable <t>）\r\n            至少一个T。\r\n            \r\n",", but the candidate shouldn't be mentioned in an ambiguity diagnostics.\r\n            ":"，但不应在歧义诊断中提及候选人。\r\n            \r\n","\r\n            Internal version of MakeCrefBinder that allows the caller to explicitly set the underlying binder.\r\n            ":"\r\n            MakeCrefbinder的内部版本，允许呼叫者明确设置基础粘合剂。\r\n            \r\n","\r\n            Visits all arguments of a method, doing any necessary rewriting for interpolated string handler conversions that\r\n            might be present in the arguments and creating temps for any discard parameters.\r\n            ":"\r\n            访问方法的所有参数，对插值字符串处理程序转换进行任何必要的重写\r\n            可能存在于参数中并为任何丢弃参数创建温度。\r\n            \r\n"," produces its output in two forms.  First, it returns a new bound statement\r\n             for the caller to use for the body of the original method.  Second, it returns a collection of\r\n             (":" 以两种形式产生其输出。首先，它返回一个新的绑定语句\r\n             使呼叫者用于原始方法的主体。其次，它返回了\r\n             （（\r\n","\r\n            Set to true after an analysis scan if the analysis was incomplete due to a backward\r\n            \"goto\" branch changing some analysis result.  In this case the caller scans again (until\r\n            this is false). Since the analysis proceeds by monotonically changing the state computed\r\n            at each label, this must terminate.\r\n            ":"\r\n            分析后扫描后设置为TRUE，如果由于向后分析不完整\r\n            “ goto”分支改变了一些分析结果。在这种情况下，呼叫者再次扫描（直到\r\n            这是错误的）。由于分析是通过单调更改计算状态进行的\r\n            在每个标签上，必须终止。\r\n            \r\n","\r\n            If a virtual \"clone\" method is present in the base record, the synthesized \"clone\" method overrides it\r\n            and the return type of the method is the current containing type if the \"covariant returns\" feature is\r\n            supported and the override return type otherwise. An error is produced if the base record clone method\r\n            is sealed. If a virtual \"clone\" method is not present in the base record, the return type of the clone\r\n            method is the containing type and the method is virtual, unless the record is sealed or abstract.\r\n            If the containing record is abstract, the synthesized clone method is also abstract.\r\n            If the \"clone\" method is not abstract, it returns the result of a call to a copy constructor.\r\n            ":"\r\n            如果基本记录中存在虚拟“克隆”方法，则合成的“克隆”方法将其覆盖\r\n            如果“协变返回”功能是\r\n            支持和覆盖返回类型否则。如果基本记录克隆方法会产生错误\r\n            被密封。如果基本记录中不存在虚拟“克隆”方法，则克隆的返回类型\r\n            方法是包含类型，该方法是虚拟的，除非记录是密封或抽象的。\r\n            如果包含记录是抽象的，则合成的克隆方法也是抽象的。\r\n            如果“克隆”方法不是抽象的，则将调用的结果返回复制构造函数。\r\n            \r\n","\r\n              Looks up a localized string similar to Both partial method declarations must be unsafe or neither may be unsafe.\r\n            ":"\r\n              查找类似于两个部分方法声明的本地化字符串必须不安全，或者都不是不安全的。\r\n            \r\n","\r\n            Global Nullable context options.\r\n            ":"\r\n            全局无效上下文选项。\r\n            \r\n","\r\n              Looks up a localized string similar to Constructor '{0}' cannot call itself through another constructor.\r\n            ":"\r\n              查找类似于构造函数'{0}'的本地化字符串，无法通过另一个构造函数调用自身。\r\n            \r\n","\r\n            Smallest location of the template, actually contains the smallest location \r\n            of all the anonymous type instances created using this template during EMIT;\r\n            \r\n            NOTE: if this property is queried, smallest location must not be null.\r\n            ":"\r\n            模板的最小位置，实际上包含最小的位置\r\n            在EMIT期间使用此模板创建的所有匿名类型实例中；\r\n            \r\n            注意：如果查询此属性，则最小的位置不得无效。\r\n            \r\n","\r\n            A simple representation of a type parameter constraint clause\r\n            as a set of constraint bits and a set of constraint types.\r\n            ":"\r\n            类型参数约束子句的简单表示\r\n            作为一组约束位和一组约束类型。\r\n            \r\n","\r\n            Emit code for a null-coalescing operator.\r\n            ":"\r\n            发射代码为无污染的操作员。\r\n            \r\n","Member '{0}' cannot be accessed with an instance reference; qualify it with a type name instead":"成员'{0}'无法使用实例参考访问；用类型名称限定它\r\n","\r\n            Lookup a type within the assembly using its canonical CLR metadata name.\r\n            ":"使用其规范的CLR元数据名称查找装配中的类型。\r\n            \r\n","\r\n            Lexer entry point for LexMode.XmlCommentText\r\n            ":"\r\n            Lexmode.xmlCommentText的Lexer入口点\r\n            \r\n","\r\n            Manages creating snapshots of the walker as appropriate. Null if we're not taking snapshots of\r\n            this walker.\r\n            ":"\r\n            管理适当地创建Walker的快照。如果我们不拍摄快照，则无效\r\n            这个步行者。\r\n            \r\n","There are cases for which a stack is not enough and we need a full heap dump to \r\n            investigate the failure. This method takes care of that. The behavior is that when running\r\n            in our CI environment if the assert triggers we will rudely crash the process and \r\n            produce a heap dump for investigation.":"在某些情况下，堆栈还不够，我们需要一个完整的堆转储来\r\n            调查失败。这种方法会考虑到这一点。行为是运行时\r\n            在我们的CI环境中，如果主张触发器，我们会粗鲁地崩溃该过程，并且\r\n            生产一个堆供应调查。\r\n","Note that any of the child bound nodes may be null.":"请注意，任何孩子的节点都可能为null。\r\n","\r\n            DELIBERATE SPEC VIOLATION: When processing an implicit invocation of an ":"\r\n            故意规格违规：处理一个隐性调用\r\n","\r\n              Looks up a localized string similar to XML comment has cref attribute that refers to a type parameter.\r\n            ":"\r\n              查找类似于XML注释的本地化字符串具有CREF属性，该属性是指类型参数。\r\n            \r\n","Throws an argument exception if the passed lookup options are invalid.":"如果传递的查找选项无效，则引发参数异常。\r\n","Called when the visitor visits a LocalDeclarationStatementSyntax node.":"访问者访问localdeclarationStatementsyntax节点时调用。\r\n","'{0}' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.":"'{0}'不是有效的约束。用作约束的类型必须是接口，非密封类或类型参数。\r\n","\r\n            Gets the plain text name associated with the expression syntax node\r\n            ":"\r\n            获取与表达式语法节点关联的纯文本名称\r\n            \r\n","CallerLineNumberAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'":"无法应用CallerlineNumberatTribute，因为从类型'{0}'到type'{1}'的类型没有标准转换\r\n","Needs parameters.":"需要参数。\r\n","\r\n              Looks up a localized string similar to Specified language version '{0}' cannot have leading zeroes.\r\n            ":"\r\n              查找类似于指定语言版本的本地化字符串“ {0}”不能具有引导零。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': instance field types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute.\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串：用structlayout标记的实例字段类型（layoutkind.explicit）必须具有fieldoffset属性。\r\n            \r\n","\r\n            A value of type nint may, in a 64-bit runtime, take on values greater than ":"\r\n            NINT类型的值可能在64位运行时，其值大于\r\n","\r\n              Looks up a localized string similar to Expected disable or restore.\r\n            ":"\r\n              查找类似于预期禁用或还原的局部字符串。\r\n            \r\n","Called when the visitor visits a AnonymousObjectMemberDeclaratorSyntax node.":"当访问者访问AnonymobjectMemberDeclaratorsyntax节点时，请致电。\r\n","\r\n            Since this method is intended to be used for error reporting, it stops as soon as it finds\r\n            any type forwarder - it does not check other assemblies for consistency or better results.\r\n            ":"\r\n            由于此方法旨在用于错误报告，因此一旦找到它就会停止\r\n            任何类型的转发器 - 它不会检查其他组件是否有一致性或更好的结果。\r\n            \r\n","\r\n            Binds a simple identifier.\r\n            ":"\r\n            绑定一个简单的标识符。\r\n            \r\n","Ignoring /noconfig option because it was specified in a response file":"忽略 /noconfig选项，因为它是在响应文件中指定的\r\n",". The caller\r\n            should place the side-effect before the test in the generated code.\r\n            ":"。呼叫者，召集者\r\n            应将副作用放在测试前的生成代码中。\r\n            \r\n","the bound expression of the when clause":"何时子句的结合表达\r\n","\r\n            The options the compilation was created with.\r\n            ":"\r\n            编译创建的选项。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': a parameter or local variable cannot have the same name as a method type parameter.\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串：参数或本地变量不能与方法类型参数具有相同的名称。\r\n            \r\n",". \r\n             It's used when combining state additively, like when the state from a return statement\r\n             inside a 'try' clause is combined with the end state of a 'finally' clause.\r\n            \r\n             This moves \"down\" our flow lattice, by convention. The following equations must hold:\r\n             1. Meet(Unreachable, X) = Unreachable\r\n             2. Meet(ReachableBottom, X - Unreachable) = ReachableBottom\r\n             3. Meet(Top, X) = X\r\n            \r\n             ":"。\r\n             它在加性结合时使用，例如返回语句的状态\r\n             在“尝试”子句中，将“最后”条款的末端状态结合在一起。\r\n            \r\n             通过惯例，这将“向下”我们的流晶格移动。以下方程式必须保持：\r\n             1.见面（无法到达，x）=无法到达\r\n             2.见面（ReachableBottom，X-无法到达）= ReachableBottom\r\n             3.见面（顶部，x）= x\r\n            \r\n             \r\n","\r\n            Look for a type forwarder for the given type in the containing assembly and any referenced assemblies.\r\n            ":"\r\n            在包含的组件和任何引用的组件中寻找给定类型的类型转发器。\r\n            \r\n","The FieldOffset attribute is not allowed on static or const fields":"在静态或const字段上不允许fieldoffset属性\r\n","\r\n              Looks up a localized string similar to Merge conflict marker encountered.\r\n            ":"\r\n              查找类似于遇到的合并冲突标记的本地化字符串。\r\n            \r\n","collection initializer":"收集初始化器\r\n","\r\n            Walk up to the nearest method/property/event.\r\n            ":"\r\n            步行到最近的方法/属性/事件。\r\n            \r\n","Only tokens for which this predicate returns true are included.  Pass null to include\r\n            all tokens.":"仅包括此谓词返回true的令牌。通过null包括\r\n            所有令牌。\r\n","\r\n            Returns value 'Label' of the ":"\r\n            返回值的“标签”\r\n","\r\n              Looks up a localized string similar to Implicitly-typed variables cannot be constant.\r\n            ":"\r\n              查找类似于隐型变量类似的本地化字符串不能是恒定的。\r\n            \r\n","\r\n            Gets unique source assembly attributes that should be emitted,\r\n            i.e. filters out attributes with errors and duplicate attributes.\r\n            ":"\r\n            获取应发射的唯一源组件属性，\r\n            即，使用错误和重复属性过滤属性。\r\n            \r\n","\r\n            Represents an anonymous type constructor.\r\n            ":"\r\n            代表匿名类型的构造函数。\r\n            \r\n","Called when the visitor visits a XmlNameAttributeSyntax node.":"当访问者访问XMLnameAttributesyntax节点时，请致电。\r\n","\r\n            [NullableContext(2)]\r\n            ":"\r\n            [nullableContext（2）]\r\n            \r\n","extern":"外部\r\n","\r\n              Looks up a localized string similar to Key file '{0}' is missing the private key needed for signing.\r\n            ":"\r\n              查找类似于键文件'{0}'的本地化字符串，缺少签名所需的私钥。\r\n            \r\n","\r\n            The kind of this node in the decision tree.\r\n            ":"\r\n            决策树中的该节点的种类。\r\n            \r\n","\r\n            Constructor of the attribute. If it doesn't exist, the attribute is not created.\r\n            ":"\r\n            属性的构造函数。如果不存在，则不会创建属性。\r\n            \r\n","Gets the type.":"获取类型。\r\n","collection":"收藏\r\n","\r\n            Imports touched by a binder with this flag set are not consider \"used\".\r\n            ":"\r\n            用此标志集接触的活页夹的导入不被考虑“使用”。\r\n            \r\n","Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute on a property":"请勿使用'system.runtime.compilerServices.fixedBuffer'属性上的属性\r\n","\r\n              Looks up a localized string similar to unmanaged generic type constraints.\r\n            ":"\r\n              查找类似于不受管理的通用类型约束的本地化字符串。\r\n            \r\n","\r\n            Represents an assembly imported from a PE.\r\n            ":"\r\n            代表从PE导入的组件。\r\n            \r\n","Feature '{0}' is not available in C# 2. Please use language version {1} or greater.":"C＃2中不可用功能'{0}'使用语言版本{1}或更大。\r\n","\r\n            WORKAROUND:\r\n            We're taking a dependency on the location and structure of a framework assembly resource.  This is not a robust solution.\r\n            \r\n            Possible alternatives:\r\n            1) Polish our XML parser until it matches MSXML.  We don't want to reinvent the wheel.\r\n            2) Build a map that lets us go from XML string positions back to source positions.  \r\n            This is what the native compiler did, and it was a lot of work.  We'd also still need to modify the message.\r\n            3) Do not report a diagnostic.  This is very unhelpful.\r\n            4) Report a vague diagnostic (i.e. there's a problem somewhere in this doc comment).  This is relatively unhelpful.\r\n            5) Always report the message in English, so that we can pull it apart without needing to consume resource files.\r\n            This engenders a lot of ill will.\r\n            6) Report the exception message without modification and (optionally) include the text with respect to which the\r\n            position is specified.  This would not look sufficiently polished.\r\n            ":"\r\n            解决方法：\r\n            我们正在依赖框架组装资源的位置和结构。这不是强大的解决方案。\r\n            \r\n            可能的替代方案：\r\n            1）抛光我们的XML解析器，直到与MSXML匹配。我们不想重新发明轮子。\r\n            2）构建一个地图，使我们可以从XML字符串位置回到源位置。\r\n            这就是本地编译器所做的，这是很多工作。我们还需要修改消息。\r\n            3）不要报告诊断。这是非常无益的。\r\n            4）报告模糊的诊断（即，此文档评论中的某个地方存在问题）。这是相对无助的。\r\n            5）始终用英语报告该消息，以便我们可以将其分开而无需消费资源文件。\r\n            这导致了很多病。\r\n            6）报告没有修改的异常消息，并且（（可选））包括\r\n            指定位置。这看起来还不够抛光。\r\n            \r\n","\r\n              Looks up a localized string similar to An expression cannot be used in this context because it may not be passed or returned by reference.\r\n            ":"\r\n              在此上下文中查找类似于表达式的本地化字符串，因为它可能不会通过参考传递或返回。\r\n            \r\n","TypeSyntax node that represents the element type of the pointer.":"代表指针的元素类型的型号节点。\r\n","\r\n              Looks up a localized string similar to Different #pragma checksum values given.\r\n            ":"\r\n              查找类似于给定的#pragma校验和值的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to <!-- Badly formed XML comment ignored for member \"{0}\" -->.\r\n            ":"\r\n              查找类似于<！的本地化字符串，对于成员“ {0}”  - >，忽略了XML注释不佳。\r\n            \r\n","\r\n            Represents a C# recursive pattern using ITuple.\r\n            ":"\r\n            使用ituple表示C＃递归模式。\r\n            \r\n","\r\n            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.\r\n            ":"\r\n            返回一袋应用的自定义属性和从众所周知的属性解码的数据。返回null如果符号上没有属性。\r\n            \r\n","Called when the visitor visits a EventFieldDeclarationSyntax node.":"当访问者访问EventFieldDeclarationsyntax节点时，请致电。\r\n","\r\n            Returns true if the two partial methods have the same constraints.\r\n            ":"\r\n            如果两个部分方法具有相同的约束，则返回true。\r\n            \r\n","Called GetDeclarationName for a declaration node that can possibly contain multiple variable declarators.":"称为可能包含多个变量声明器的声明节点的getDeclarationName。\r\n"," represents a leaf node when we\r\n            have finally determined exactly which case matches. Each test processes a single input, and there are\r\n            four kinds:":" 代表我们的叶子节点\r\n            最终确定了哪个案例匹配。每个测试过程都有一个输入，并且有\r\n            四种：\r\n","\r\n            for each Scope. This is done by looking for ":"\r\n            对于每个范围。这是通过寻找的\r\n","\r\n              Looks up a localized string similar to Can't reference compilation of type '{0}' from {1} compilation..\r\n            ":"\r\n              查找类似于{1}汇编的类型“ {0}”类型的本地化字符串。\r\n            \r\n","\r\n            If the Kind is ExtendKind.Assembly, returns the assembly symbol that this namespace\r\n            encompasses. Otherwise throws InvalidOperationException.\r\n            ":"\r\n            如果类型是ExtendKind.sembly，请返回此名称空间的汇编符号\r\n            包含。否则会引发无效的exception。\r\n            \r\n","\r\n            It's a non terminal Trivia CSharpSyntaxNode that has a tree underneath it.\r\n            ":"\r\n            这是一个非终端琐事csharpsyntaxnode，其下面有一棵树。\r\n            \r\n","\r\n            An equivalence relation between dag states used to dedup the states during dag construction.\r\n            After dag construction is complete we treat a DagState as using object equality as equivalent\r\n            states have been merged.\r\n            ":"\r\n            在DAG构造过程中，用DAG国家之间的等效关系。\r\n            DAG构造完成后，我们将DAGSTATE视为使用对象平等等效\r\n            国家已合并。\r\n            \r\n","\r\n            We're in a <typeparam> or <typeparamref> element, so we want a binder that can see\r\n            the type parameters of the associated member and nothing else.\r\n            ":"\r\n            我们在<typeparam>或<typeparamref>元素中，所以我们想要一个可以看到的粘合剂\r\n            关联成员的类型参数，没有其他。\r\n            \r\n","\r\n            True if the event itself is excluded from code coverage instrumentation.\r\n            True for source events marked with ":"\r\n            如果将事件本身排除在代码覆盖仪器中，则为是真的。\r\n            对于标记的源事件是正确的\r\n","\r\n            If this symbol represents a tuple type, get the fields for the tuple's elements.\r\n            Otherwise, returns default.\r\n            ":"\r\n            如果此符号代表元组类型，请获取元组元素的字段。\r\n            否则，返回默认值。\r\n            \r\n","Invalid anonymous type member declarator. Anonymous type members must be declared with a member assignment, simple name or member access.":"无效的匿名类型成员声明器。必须使用成员分配，简单名称或成员访问来声明匿名类型成员。\r\n","\r\n            Given anonymous type provided constructs an implementation type symbol to be used in emit phase; \r\n            if the anonymous type has at least one field the implementation type symbol will be created based on \r\n            a generic type template generated for each 'unique' anonymous type structure, otherwise the template\r\n            type will be non-generic.\r\n            ":"\r\n            给定的匿名类型提供了构造的实现类型符号，该符号要在发射阶段中使用；\r\n            如果匿名类型至少具有一个字段，则将基于实现类型符号创建\r\n            为每个“唯一”匿名类型结构生成的通用类型模板，否则模板\r\n            类型将是非生成的。\r\n            \r\n","Invalid constraint type. A type used as a constraint must be an interface, a non-sealed class or a type parameter.":"无效的约束类型。用作约束的类型必须是接口，非密封类或类型参数。\r\n","s and default options\r\n            ":"S和默认选项\r\n            \r\n","Using directive appeared previously in this namespace":"使用指令以前出现在此名称空间中\r\n","Called when the visitor visits a FileScopedNamespaceDeclarationSyntax node.":"当访问者访问filescopednamespacedeclarationsyntax节点时，请致电。\r\n","Called when the visitor visits a AttributeTargetSpecifierSyntax node.":"当访问者访问attributetArgetSpecifiersyntax节点时调用。\r\n","\r\n            Resolve method group based on the optional delegate invoke method.\r\n            If the invoke method is null, ignore arguments in resolution.\r\n            ":"\r\n            基于可选的委托调用方法解析方法组。\r\n            如果调用方法为null，请忽略解决方案中的参数。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': a static constructor must be parameterless.\r\n            ":"\r\n              查找类似于“ {0}”的局部字符串：静态构造函数必须无参数。\r\n            \r\n","Called when the visitor visits a CatchClauseSyntax node.":"当访客访问catchClausesyntax节点时，请致电。\r\n","Called when the visitor visits a DelegateDeclarationSyntax node.":"当访问者访问委托书元素节点时打电话。\r\n","\r\n            Parse an ExpressionSyntax node using the lowest precedence grammar rule for expressions.\r\n            ":"\r\n            使用表达式最低优先语法规则来解析表达式节点。\r\n            \r\n","'{0}': cannot change tuple element names when overriding inherited member '{1}'":"'{0}'：当覆盖的构件'{1}'倒置时无法更改元组元素名称\r\n","\r\n              Looks up a localized string similar to No best type was found for the switch expression..\r\n            ":"\r\n              查找与开关表达式相似的本地化字符串。\r\n            \r\n","\r\n            Returns true if the type may contain embedded references\r\n            ":"\r\n            如果类型可能包含嵌入式引用，则返回true\r\n            \r\n","\r\n              Looks up a localized string similar to The /pdb option requires that the /debug option also be used.\r\n            ":"\r\n              查找类似于 /PDB选项的本地化字符串，要求还使用 /调试选项。\r\n            \r\n","\r\n            Nullable type (ending with ?).\r\n            ":"\r\n            无效的类型（以？）。\r\n            \r\n","A tuple may not contain a value of type 'void'.":"元组可能不包含“ void”类型的值。\r\n","Compilation used to check constraints.  The latest language version is assumed if this is null.":"汇编用于检查约束。如果这为null，则假定最新的语言版本。\r\n","\r\n            Creates a token with kind NumericLiteralToken from an 8-byte floating point value.\r\n            ":"\r\n            从8字节的浮点值创建具有相同数字的令牌。\r\n            \r\n","\r\n            Determines if the source type is convertible to the destination type via\r\n            any user-defined or built-in implicit conversion.\r\n            ":"\r\n            确定源类型是否可通过\r\n            任何用户定义或内置的隐式转换。\r\n            \r\n"," modifier. \r\n            ":" 修饰符。\r\n            \r\n","Missing close delimiter '}' for interpolated expression started with '{'.":"对于插值表达式，缺少关闭的分界符'}'以​​'{'开头。\r\n","\r\n            Produces a chain of equality (or inequality) checks combined logically with AND (or OR)\r\n            ":"\r\n            产生一系列平等（或不平等）检查与逻辑结合和（或）\r\n            \r\n","\r\n             Performs the following checks:\r\n             \r\n             Spec 7.6.5: Invocation expressions (definition of Final Validation) \r\n               The method is validated in the context of the method group: If the best method is a static method, \r\n               the method group must have resulted from a simple-name or a member-access through a type. If the best \r\n               method is an instance method, the method group must have resulted from a simple-name, a member-access\r\n               through a variable or value, or a base-access. If neither of these requirements is true, a binding-time\r\n               error occurs.\r\n               (Note that the spec omits to mention, in the case of an instance method invoked through a simple name, that\r\n               the invocation must appear within the body of an instance method)\r\n            \r\n             Spec 7.5.4: Compile-time checking of dynamic overload resolution \r\n               If F is a static method, the method group must have resulted from a simple-name, a member-access through a type, \r\n               or a member-access whose receiver can't be classified as a type or value until after overload resolution (see §7.6.4.1). \r\n               If F is an instance method, the method group must have resulted from a simple-name, a member-access through a variable or value,\r\n               or a member-access whose receiver can't be classified as a type or value until after overload resolution (see §7.6.4.1).\r\n             ":"执行以下检查：\r\n             \r\n             规格7.6.5：调用表达式（最终验证的定义）\r\n               该方法在方法组的上下文中进行了验证：如果最佳方法是静态方法，则\r\n               该方法组必须通过类型由简单名称或成员访问产生。如果最好\r\n               方法是一个实例方法，方法组必须是由简单名称的成员访问产生的\r\n               通过变量或值，或基本访问。如果这些要求都不正确，则是绑定时间\r\n               发生错误。\r\n               （请注意，规格忽略了，如果是通过简单名称调用的实例方法，\r\n               调用必须出现在实例方法的正文中）\r\n            \r\n             规格7.5.4：动态过载分辨率的编译时间检查\r\n               如果f是静态方法，则该方法组必须是由一个简单名称（通过类型的成员访问）产生的，\r\n               或成员访问的接收器无法将其分类为类型或价值，直到过载分辨率后（请参阅第7.6.4.4.1节）。\r\n               如果f是实例方法，则方法组必须是由一个简单名称，通过变量或值的成员访问产生的，\r\n               或成员访问的接收器无法将其分类为类型或价值，直到过载分辨率后（请参阅第7.6.4.4.1节）。\r\n             \r\n","The character '<' cannot be used in an attribute value.":"字符'<'不能在属性值中使用。\r\n","Missing compiler required member '{0}.{1}'":"缺少编译器所需会员'{0}。{1}'\r\n","\r\n              Looks up a localized string similar to An expression of type '{0}' cannot be handled by a pattern of type '{1}'..\r\n            ":"\r\n              查找类似于“ {0}”类型的表达式的本地化字符串，无法通过类型'{1}'..的模式来处理。\r\n            \r\n","\r\n            Creates a new nested scope which is a child of ":"\r\n            创建一个新的嵌套范围\r\n","A language name cannot be specified for this option.":"不能为此选项指定语言名称。\r\n"," referenced by this module, and corresponding\r\n            retargeting map for symbols.\r\n            ":" 由此模块引用，对应\r\n            符号的重新定位地图。\r\n            \r\n","Partial declarations of '{0}' must have the same type parameter names in the same order":"“ {0}”的部分声明必须具有相同顺序的相同类型的参数名称\r\n","\r\n            C# language version 10.0\r\n            ":"\r\n            C＃语言版本10.0\r\n            \r\n","\r\n              Looks up a localized string similar to The result of the expression is always the same since a value of this type is never equal to 'null'.\r\n            ":"\r\n              查找类似于表达式结果的局部字符串始终相同，因为此类型的值永远不等于“ null”。\r\n            \r\n","Obsolete member overrides non-obsolete member":"过时的成员覆盖了非观察成员\r\n","\r\n            Check generic type constraints unless the type is used as part of a type or method\r\n            declaration. In those cases, constraints checking is handled by the caller.\r\n            ":"\r\n            检查通用类型约束，除非类型用作类型或方法的一部分\r\n            宣言。在这种情况下，呼叫者处理约束检查。\r\n            \r\n","'{0}': user-defined conversions to or from an interface are not allowed":"'{0}'：不允许往接口或从接口的用户定义转换\r\n","The syntax node that declares a delegate.":"宣布委托的语法节点。\r\n","\r\n            Returns true if the location is within the syntax tree and span.\r\n            ":"\r\n            如果位置在语法树和跨度内，则返回true。\r\n            \r\n","Creates a new WithExpressionSyntax instance.":"创建一个使用ExplactionSyntax实例的新的。\r\n","Called when the visitor visits a CrefParameterListSyntax node.":"当访客访问crefparameterListsyntax节点时，请致电。\r\n","implicitly typed local variable":"隐式键入本地变量\r\n","\r\n              Looks up a localized string similar to Constraint type '{0}' is not CLS-compliant.\r\n            ":"\r\n              查找类似于约束类型'{0}'的本地化字符串不符合CLS。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': an attribute argument cannot use type parameters.\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串：属性参数无法使用类型参数。\r\n            \r\n","\r\n            Returns true if and only if at least one type within the assembly contains\r\n            extension methods. Note, this method is expensive since it potentially\r\n            inspects all types within the assembly. The expectation is that this method is\r\n            only called at emit time, when all types have been or will be traversed anyway.\r\n            ":"\r\n            当且仅当装配中至少一种类型包含时，返回true\r\n            扩展方法。注意，此方法很昂贵，因为它可能有可能\r\n            检查组件中的所有类型。期望这种方法是\r\n            只有在发射时间被调用，无论如何，所有类型都将被击中。\r\n            \r\n","\r\n              Looks up a localized string similar to Method name expected.\r\n            ":"\r\n              查找类似于预期方法名称的本地化字符串。\r\n            \r\n","The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}":"对于集合初始化器元素而言，最佳的超载添加方法'{0}'已过时。 {1}\r\n","It is not legal to use nullable type '{0}?' in a pattern; use the underlying type '{0}' instead.":"使用无效类型'{0}是不合法的？'以模式；代替使用基础类型'{0}'。\r\n"," test.\r\n            ":" 测试。\r\n            \r\n","\r\n              Looks up a localized string similar to Friend access was granted by '{0}', but the public key of the output assembly does not match that specified by the attribute in the granting assembly..\r\n            ":"\r\n              查找类似于朋友访问的本地化字符串由“ {0}”授予，但是输出组件的公共密钥与授予程序集中的属性指定的公共密钥不匹配。\r\n            \r\n"," expression of a switch case), and the branches to a given label if the guard\r\n            is true (or there is no guard).\r\n            ":" 开关案例的表达），如果警卫\r\n            是真的（或没有警卫）。\r\n            \r\n","Not a C# symbol.":"不是C＃符号。\r\n","Can't reference compilation of type '{0}' from {1} compilation.":"无法从{1}汇编中引用类型'{0}'的汇编。\r\n","\r\n              Looks up a localized string similar to Invalid token '{0}' in class, struct, or interface member declaration.\r\n            ":"\r\n              在类，struct或Interface成员声明中查找类似于无效令牌'{0}'的本地化字符串。\r\n            \r\n","\r\n            Return true if the class type has a public parameterless constructor.\r\n            ":"\r\n            如果类类型具有公共参数构造函数，则返回true。\r\n            \r\n","Class which represents the syntax node for implicit stackalloc array creation expression.":"代表隐式stackalloc数组创建表达式的语法节点的类。\r\n","\r\n            A type class providing primitive operations needed to support a value set for a floating-point type.\r\n            ":"\r\n            一个类型类提供了支持浮点类型的价值设置所需的原始操作。\r\n            \r\n","\r\n            The spec describes an algorithm for finding the following types:\r\n              1) Collection type\r\n              2) Enumerator type\r\n              3) Element type\r\n              \r\n            The implementation details are a bit difference.  If we're iterating over a string or an array, then we don't need to record anything\r\n            but the inferredType (in case the iteration variable is implicitly typed).  If we're iterating over anything else, then we want the \r\n            inferred type plus a ForEachEnumeratorInfo.Builder with:\r\n              1) Collection type\r\n              2) Element type\r\n              3) GetEnumerator method of the collection type (return type will be the enumerator type from the spec)\r\n              4) Current property of the enumerator type\r\n              5) MoveNext method of the enumerator type\r\n              \r\n            The caller will have to do some extra conversion checks before creating a ForEachEnumeratorInfo for the BoundForEachStatement.\r\n            ":"\r\n            该规范描述了用于查找以下类型的算法：\r\n              1）收集类型\r\n              2）枚​​举类型\r\n              3）元素类型\r\n              \r\n            实现细节有点差异。如果我们在字符串或数组中迭代，那么我们就不需要记录任何内容\r\n            但是推论型（如果迭代变量被隐式键入）。如果我们要迭代其他任何东西，那么我们想要\r\n            推断类型加上foreachEnumeratorInfo.builder with：\r\n              1）收集类型\r\n              2）元素类型\r\n              3）集合类型的getEnumerator方法（返回类型将是规格的枚举类型）\r\n              4）枚举类型的当前属性\r\n              5）枚举类型的MoveNEXT方法\r\n              \r\n            呼叫者将必须进行一些额外的转换检查，然后为BONDEREACHSTATETEMT创建ForeachEnumeratorInfo。\r\n            \r\n"," The syntax for the user-defined asynchronous main method. ":"用户定义的异步主方法的语法。\r\n","\r\n              Looks up a localized string similar to Duplicate '{0}' attribute.\r\n            ":"\r\n              查找类似于重复'{0}'属性的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Multiple analyzer config files cannot be in the same directory ('{0}')..\r\n            ":"\r\n              查找类似于多个分析仪配置文件的本地化字符串不能在同一目录中（'{0}'）。\r\n            \r\n","\r\n            Binds the expression in the context of the specified location and gets type information.\r\n            This method is used to get type information about an expression that did not actually\r\n            appear in the source code.\r\n            ":"\r\n            在指定位置的上下文中绑定表达式并获取类型信息。\r\n            此方法用于获取有关表达式的类型信息\r\n            出现在源代码中。\r\n            \r\n","Type conflicts with imported type":"类型与导入类型的冲突\r\n","\r\n              Looks up a localized string similar to '{0}': user-defined conversions to or from the dynamic type are not allowed.\r\n            ":"\r\n              查找类似于“ {0}'的本地化字符串：不允许使用动态类型的用户定义转换。\r\n            \r\n","Array elements cannot be of type '{0}'":"数组元素不能为'{0}'类型\r\n","\r\n            private fields declared in this assembly but never read\r\n            ":"\r\n            在这个大会上宣布的私人字段，但从未阅读\r\n            \r\n","\r\n              Looks up a localized string similar to Control cannot leave the body of an anonymous method or lambda expression.\r\n            ":"\r\n              查找类似于控件的本地化字符串不能离开匿名方法或lambda表达式的主体。\r\n            \r\n","\r\n            Start parsing a new lexeme.\r\n            ":"\r\n            开始解析新的Lexeme。\r\n            \r\n","End tag '{0}' does not match the start tag '{1}'.":"结束标签'{0}'与开始标签'{1}'不匹配。\r\n",", but with special behavior around tuples.\r\n            In particular, if substitution makes type tuple compatible, transform it into a tuple type.\r\n            ":"，但在元组周围具有特殊的行为。\r\n            特别是，如果替换使元组兼容，请将其转换为元组类型。\r\n            \r\n","\r\n             Given a compilation and a destination directory, determine three names:\r\n               1) The name with which the assembly should be output.\r\n               2) The path of the assembly/module file.\r\n               3) The path of the pdb file.\r\n            \r\n             When csc produces an executable, but the name of the resulting assembly\r\n             is not specified using the \"/out\" switch, the name is taken from the name\r\n             of the file (note: file, not class) containing the assembly entrypoint\r\n             (as determined by binding and the \"/main\" switch).\r\n            \r\n             For example, if the command is \"csc /target:exe a.cs b.cs\" and b.cs contains the\r\n             entrypoint, then csc will produce \"b.exe\" and \"b.pdb\" in the output directory,\r\n             with assembly name \"b\" and module name \"b.exe\" embedded in the file.\r\n             ":"\r\n             给定汇编和目标目录，确定三个名称：\r\n               1）应该输出组件的名称。\r\n               2）汇编/模块文件的路径。\r\n               3）PDB文件的路径。\r\n            \r\n             当CSC产生可执行文件时，但是由此产生的组件的名称\r\n             未使用“/out”开关指定，名称是从名称中获取的\r\n             文件（注意：文件，不是类）包含汇编入门点\r\n             （如绑定和“/main”开关确定）。\r\n            \r\n             例如，如果命令是“ CSC /TARGET：EXE A.CS B.CS”，并且B.CS包含\r\n             入门点，然后CSC将在输出目录中产生“ b.exe”和“ b.pdb”，\r\n             带有嵌入在文件中的汇编名称“ B”和模块名称“ B.EXE”。\r\n             \r\n","\r\n            Because the instruction cannot have any values on the stack before CLR execution.\r\n            Limit it to assignments and conditional expressions for now.\r\n            https://github.com/dotnet/roslyn/issues/22046\r\n            ":"\r\n            因为在CLR执行之前，指令在堆栈上不能具有任何值。\r\n            暂时将其限制为作业和条件表达式。\r\n            https://github.com/dotnet/roslyn/issues/22046\r\n            \r\n","\r\n            The following are rvalues: values, variables, null literals, properties\r\n            and indexers with getters, events. \r\n            \r\n            The following are not rvalues:\r\n            namespaces, types, method groups, anonymous functions.\r\n            ":"\r\n            以下是RVALUE：值，变量，无效文字，属性\r\n            以及带有Getters，Events的索引器。\r\n            \r\n            以下不是RVALUE：\r\n            名称空间，类型，方法组，匿名函数。\r\n            \r\n","\r\n            Pre C# 7.2 back-compat overload, which simply calls the replacement property ":"\r\n            Pre C＃7.2后串联超负荷，仅调用替换属性\r\n","Type argument cannot be null":"类型参数不能为null\r\n","\r\n              Looks up a localized string similar to The parameter of a unary operator must be the containing type.\r\n            ":"查找类似于单位操作员参数的本地化字符串必须是包含类型。\r\n            \r\n","\r\n            Creates a token with kind NumericLiteralToken from a decimal value.\r\n            ":"从小数值创建具有固有数字的令牌。\r\n            \r\n","Gets the close brace token.":"获取靠近的支架令牌。\r\n","\r\n            Generates the `ValueTask<bool> MoveNextAsync()` method.\r\n            ":"\r\n            生成`valueTask <bool> moveNextAsync（）`方法。\r\n            \r\n","Called when the visitor visits a EqualsValueClauseSyntax node.":"当访问者访问equalsValueClausesyntax节点时调用。\r\n","The unary operator expression representing the increment/decrement.":"一元操作员表达式表示增量/减少。\r\n","\r\n            Returns true if the Unicode character can be a part of a C# identifier.\r\n            ":"\r\n            如果Unicode字符可以成为C＃标识符的一部分，则返回true。\r\n            \r\n","\r\n            Gets the first directive of the tree rooted by this node.\r\n            ":"\r\n            获取由该节点扎根的树的第一个指令。\r\n            \r\n","\r\n            Can add some diagnostics into ":"\r\n            可以将一些诊断添加到\r\n","\r\n              Looks up a localized string similar to Unboxing a possibly null value..\r\n            ":"\r\n              查找类似于拆箱的本地化字符串。\r\n            \r\n","Target symbol on which this attribute is applied.":"应用此属性的目标符号。\r\n","\r\n              Looks up a localized string similar to '{0}': cannot override; '{1}' is not an event.\r\n            ":"\r\n              查找类似于'{0}'：不能覆盖的本地化字符串； '{1}'不是事件。\r\n            \r\n","\r\n            These diagnostics are for members that almost, but not actually, implicitly implement an interface member.\r\n            ":"\r\n            这些诊断是针对几乎但实际上并非隐含地实现接口成员的成员。\r\n            \r\n","Class which represents the syntax node for generic name.":"代表通用名称的语法节点的类。\r\n","\r\n            Apply type substitution to a generic method to create a method symbol with the given type parameters supplied.\r\n            ":"\r\n            将类型替换应用于通用方法，以创建使用给定类型参数的方法符号。\r\n            \r\n","\r\n              Looks up a localized string similar to An expression tree lambda may not contain a method group.\r\n            ":"\r\n              查找类似于表达树lambda的本地化字符串可能不包含方法组。\r\n            \r\n","ExpressionSyntax node representing the argument.":"表示参数的eNSTRANIONSYNTAX节点。\r\n","Called when the visitor visits a IfDirectiveTriviaSyntax node.":"当访问者访问一个IFDirectivtRiviaSyntax节点时，请致电。\r\n","Ref readonly":"ref Readonly\r\n","Extension method '{0}' defined on value type '{1}' cannot be used to create delegates":"在值类型'{1}'上定义的扩展方法'{0}'不能用于创建委托\r\n","\r\n            All imports (using directives and extern aliases) in syntax trees in this compilation.\r\n            NOTE: We need to de-dup since the Imports objects that populate the list may be GC'd\r\n            and re-created.\r\n            Values are the sets of dependencies for corresponding directives.\r\n            ":"\r\n            本汇编中语法树中的所有导入（使用指令和外部别名）。\r\n            注意：我们需要删除DUP，因为填充列表的导入对象可能是GC的\r\n            并重新创建。\r\n            值是相应指令的依赖关系集。\r\n            \r\n","Control cannot leave the body of an anonymous method or lambda expression":"控制不能离开匿名方法或lambda表达式的身体\r\n","\r\n            Bind the pattern switch labels.\r\n            ":"\r\n            绑定图案开关标签。\r\n            \r\n","\r\n              Looks up a localized string similar to User-defined operators cannot return void.\r\n            ":"\r\n              查找类似于用户定义的运算符的本地化字符串无法返回void。\r\n            \r\n","\r\n              Looks up a localized string similar to Parameter {0} is declared as type '{1}{2}' but should be '{3}{4}'.\r\n            ":"\r\n              查找类似于参数{0}的本地化字符串被声明为类型'{1} {2}'，但应为'{3} {4}'。\r\n            \r\n","\r\n              Looks up a localized string similar to Interfaces cannot contain instance fields.\r\n            ":"\r\n              查找类似于接口的本地化字符串不能包含实例字段。\r\n            \r\n","\r\n              Looks up a localized string similar to Missing compiler required member '{0}.{1}'.\r\n            ":"查找类似于缺少编译器所需成员'{0}的局部字符串。{1}'。\r\n            \r\n","Creates a new InitializerExpressionSyntax instance.":"创建一个新的initizerexpressionsyntax实例。\r\n",">>=":">> =\r\n","\r\n              Looks up a localized string similar to label.\r\n            ":"\r\n              查找类似于标签的本地化字符串。\r\n            \r\n","Async method lacks 'await' operators and will run synchronously":"异步方法缺少“等待”运算符，并且会同步运行\r\n","\r\n            Write document entries for all debug documents that do not yet have an entry.\r\n            ":"\r\n            为所有尚未输入的调试文档编写文档条目。\r\n            \r\n","True, if at least one documentation comment was processed; false, otherwise.":"是的，如果处理至少一个文档评论；错误，否则。\r\n","\r\n              Looks up a localized string similar to '{0}' does not contain a constructor that takes {1} arguments.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串不包含{1}参数的构造函数。\r\n            \r\n","Referenced assembly '{0}' targets a different processor.":"引用的汇编'{0}'针对不同的处理器。\r\n","\r\n            A value of type nuint may, in a 64-bit runtime, take on values greater than ":"\r\n            NUINT类型的值可能在64位运行时，其值大于\r\n","\r\n            Remaps a local, parameter, localfunction, or lambda symbol, if that symbol or its containing\r\n            symbols were reinferred. This should only be called when nullable semantic analysis is enabled.\r\n            ":"\r\n            如果该符号或其包含\r\n            符号被重载。只有在启用了无效的语义分析时，才能调用。\r\n            \r\n","The type of the corresponding parameter.":"相应参数的类型。\r\n","\r\n              Looks up a localized string similar to Interfaces cannot contain constructors.\r\n            ":"查找类似于接口的本地化字符串不能包含构造函数。\r\n            \r\n","\r\n            Creates a function pointer method symbol from individual parts. This method should only be used when diagnostics are not needed.\r\n            ":"\r\n            从各个部分创建功能指针方法符号。仅在不需要诊断时才能使用此方法。\r\n            \r\n","\r\n            Walk down tuple literals and replace all the side-effecting elements that need saving with temps.\r\n            Expressions that are not tuple literals need saving, and tuple literals that are involved in a simple comparison rather than a tuple comparison.\r\n            ":"\r\n            向下走元组文字，并替换所有需要节省温度的副作用元素。\r\n            不是元组文字的表达式需要节省，而与简单比较而不是元组比较有关的元组文字。\r\n            \r\n","Method group if the invocation represents a potentially overloaded member.":"方法组如果调用表示潜在的过载成员。\r\n","\r\n              Looks up a localized string similar to Error signing output with public key from container '{0}' -- {1}.\r\n            ":"\r\n              从容器'{0}' -  {1}中查找类似于带有公共密钥的错误签名输出的本地化字符串。\r\n            \r\n","\r\n            At least one type argument was inferred from a function type.\r\n            ":"\r\n            从函数类型推断出至少一种类型的参数。\r\n            \r\n","\r\n             Returns what symbol(s), if any, the given expression syntax bound to in the program.\r\n            \r\n             An AliasSymbol will never be returned by this method. What the alias refers to will be\r\n             returned instead. To get information about aliases, call GetAliasInfo.\r\n            \r\n             If binding the type name C in the expression \"new C(...)\" the actual constructor bound to\r\n             will be returned (or all constructor if overload resolution failed). This occurs as long as C\r\n             unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple\r\n             types, or C binds to a static class, then type(s) are returned.\r\n             ":"\r\n             返回程序中绑定到的给定表达式语法（如果有的话）。\r\n            \r\n             这种方法将永远不会返回别名鲍尔。别名是什么\r\n             而是返回。要获取有关别名的信息，请致电Getaliasinfo。\r\n            \r\n             如果在“新c（...）”表达式中绑定类型名称c\r\n             将返回（如果过载分辨率失败，则将返回所有构造函数）。这是在C\r\n             明确地与具有构造函数的单一类型结合。如果c模糊地与多个结合\r\n             类型或C结合到静态类，然后返回类型。\r\n             \r\n","Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.":"提供了代表参数列表语法节点的类的基类。这是一个抽象类。\r\n","\r\n            Captures the fact that consumers of the node already checked the state of the WasCompilerGenerated bit.\r\n            Allows to assert on attempts to set WasCompilerGenerated bit after that.\r\n            ":"捕获了节点的消费者已经检查了均氧化碳酸盐的状态的事实。\r\n            允许在此之后的尝试设置含量耐耐加工的位。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot assign {0} to an implicitly-typed variable.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法分配{0}到隐式类型的变量。\r\n            \r\n","Command-line syntax error: Missing Guid for option '{1}'":"命令行语法错误：丢失选项的GUID'{1}'\r\n","\r\n            Checks for a Dispose method on ":"\r\n            检查是否处置方法\r\n","\r\n             PROPERTIES:\r\n             NOTE: we're not checking whether this property has at least the accessors\r\n             declared in the interface.  Dev10 considers it a match either way and,\r\n             reports failure to implement accessors separately.\r\n            \r\n             If the implementing type (i.e. the type with the interface in its interface\r\n             list) is in source, then we can ignore custom modifiers in/on the property\r\n             type because they will be copied into the bridge property that explicitly\r\n             implements the interface property (or they would be, if we created such\r\n             a bridge property).  Bridge *methods* (not properties) are inserted in \r\n             SourceMemberContainerTypeSymbol.SynthesizeInterfaceMemberImplementation.\r\n            \r\n             CONSIDER: The spec for interface mapping (13.4.4) could be interpreted to mean that this\r\n             property is not an implementation unless it has an accessor for each accessor of the\r\n             interface property.  For now, we prefer to represent that case as having an implemented\r\n             property and an unimplemented accessor because it makes finding accessor implementations\r\n             much easier.  If we decide that we want the API to report the property as unimplemented,\r\n             then it might be appropriate to keep current result internally and just check the accessors\r\n             before returning the value from the public API (similar to the way MethodSymbol.OverriddenMethod\r\n             filters MethodSymbol.OverriddenOrHiddenMembers.\r\n             ":"\r\n             特性：\r\n             注意：我们没有检查此属性至少是否具有登录器\r\n             在接口中声明。 dev10无论哪种方式都认为它是匹配的，\r\n             报告未能单独实施访问者。\r\n            \r\n             如果实现类型（即带有接口的类型\r\n             列表）在源中，然后我们可以忽略属性中/在属性中的自定义修饰符\r\n             类型是因为它们将被复制到明确的桥梁属性中\r\n             实现接口属性（如果我们创建了这样的话，它们将是\r\n             桥梁财产）。桥 *方法 *（非属性）插入\r\n             Sourcemembercontainertypesymbol.SynthesizeInterfaceMembermementation。\r\n            \r\n             考虑：接口映射的规格（13.4.4）可以解释为表示这\r\n             属性不是实现的\r\n             接口属性。目前，我们更喜欢表示该案件已实施\r\n             属性和未完成的登录器，因为它使查找登录器实现\r\n             容易得多。如果我们决定希望API将属性报告为未完成的属性，请\r\n             然后，在内部保持最新结果并只检查登录器可能是合适的\r\n             在从公共API返回值之前（类似于Methodsymbol.overridendmethod的方式\r\n             滤波器方法符号。\r\n             \r\n","\r\n            Returns false because module can't be overridden.\r\n            ":"\r\n            返回false，因为模块不能被覆盖。\r\n            \r\n","\r\n            A map of NoPia local types immediately contained in this assembly.\r\n            Maps type name (non-qualified) to the row id. Note, for VB we should use\r\n            full name.\r\n            ":"\r\n            该组件中立即包含的NOPIA本地类型地图。\r\n            地图类型名称（不合格）到行ID。注意，对于VB，我们应该使用\r\n            全名。\r\n            \r\n","\r\n              Looks up a localized string similar to Duplicate user-defined conversion in type '{0}'.\r\n            ":"\r\n              在类型“ {0}”中查找类似于重复的用户定义转换的本地化字符串。\r\n            \r\n","\r\n            This field keeps track of the ":"\r\n            该领域跟踪\r\n","A MemberRef handle that can be used to obtain the name and signature of the method":"可以用来获取该方法的名称和签名的成员Ref手柄\r\n","expression-bodied indexer":"表达体索引器\r\n","\r\n              Looks up a localized string similar to Invalid module name: {0}.\r\n            ":"\r\n              查找类似于无效模块名称的本地化字符串：{0}。\r\n            \r\n","Operator '{0}' cannot be applied to operand '{1}'":"运算符'{0}'不能应用于操作数'{1}'\r\n","\r\n            Get the element type of this iterator.\r\n            ":"\r\n            获取此迭代器的元素类型。\r\n            \r\n","\r\n            A binding for an attribute.  Represents the result of binding an attribute constructor and\r\n            the positional and named arguments.\r\n            ":"\r\n            属性的绑定。代表绑定属性构造函数和\r\n            位置和命名参数。\r\n            \r\n",", this allows the Lazy implementation\r\n            to get the children of this node on demand.\r\n            ":"，这允许懒惰的实现\r\n            为了让这个节点的孩子按需。\r\n            \r\n","\r\n              Looks up a localized string similar to Alias '{0}' conflicts with {1} definition.\r\n            ":"\r\n              查找与{1}定义相似的'{0}'冲突的本地化字符串。\r\n            \r\n","Field-targeted attributes on auto-properties are not supported in language version {0}. Please use language version {1} or greater.":"在语言版本{0}中不支持自动生产的字段定位属性。请使用语言版本{1}或更大。\r\n","\r\n            Returns true if nullable analysis is enabled in the text span represented by the syntax node.\r\n            ":"\r\n            如果在语法节点表示的文本跨度中启用了无效的分析，则返回true。\r\n            \r\n"," to the replacement text.\r\n            ":" 到替换文本。\r\n            \r\n","\r\n            This is an adjusted version of ":"\r\n            这是调整后的版本\r\n","Anonymous methods, lambda expressions, query expressions, and local functions inside structs cannot access instance members of 'this'. Consider copying 'this' to a local variable outside the anonymous method, lambda expression, query expression, or local f ...":"匿名方法，lambda表达式，查询表达式和结构内部的本地函数无法访问“ this”的实例成员。考虑将“此”复制到匿名方法之外的局部变量，lambda表达式，查询表达式或本地f ...\r\n","The syntax node that declares a type.":"声明类型的语法节点。\r\n","\r\n              Looks up a localized string similar to Method has the wrong signature to be an entry point.\r\n            ":"\r\n              查找类似于方法的本地化字符串的错误签名是入口点。\r\n            \r\n","\r\n            We're binding an attribute and this is the member to/in which the attribute was applied.\r\n            ":"\r\n            我们正在绑定一个属性，这是应用属性的成员。\r\n            \r\n","\r\n            Returns a set of top-level forwarded types\r\n            ":"\r\n            返回一组顶级转发类型\r\n            \r\n","\r\n            Parse a MemberDeclarationSyntax. This includes all of the kinds of members that could occur in a type declaration.\r\n            If nothing resembling a valid member declaration is found in the input, returns null.\r\n            ":"\r\n            解析会员删除元素。这包括所有类型声明中可能发生的成员。\r\n            如果在输入中没有发现任何类似有效的成员声明，​​请返回null。\r\n            \r\n","\r\n            Creates a binder for a container with imports (usings and extern aliases) that can be\r\n            retrieved from ":"\r\n            为带有进口的容器创建活页夹，可以是\r\n            从...获得\r\n","Called when the visitor visits a ArrayRankSpecifierSyntax node.":"当访问者访问arrayrankspecifiersyntax节点时，请致电。\r\n","\r\n            Returns true if the character should be replaced and sets\r\n            ":"\r\n            如果要更换字符并设置角色，则返回true\r\n            \r\n","extensible fixed statement":"可扩展的固定语句\r\n","\r\n              Looks up a localized string similar to '{0}': type used in an async using statement must be implicitly convertible to 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method. Did you mean 'using' rather than 'await using'?.\r\n            ":"\r\n              查找类似于“ {0}'：使用语句中使用的类型类型的本地化字符串，必须隐式转换为'system.iasyncdisposable'或实现合适的'disposeasync'方法。您的意思是“使用”而不是“等待使用”？\r\n            \r\n","The line number specified for #line directive is missing or invalid":"为#line指令指定的行号丢失或无效\r\n","Generalized async return types":"概括的异步返回类型\r\n","\r\n              Looks up a localized string similar to Embedded interop struct '{0}' can contain only public instance fields..\r\n            ":"\r\n              查找类似于嵌入式Interop struct'{0}'的本地化字符串可以包含公共实例字段。\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability of reference types in type of parameter doesn't match implemented member..\r\n            ":"\r\n              查找类似于参数类型中参考类型的无效性类似的本地化字符串，不匹配实现的成员。\r\n            \r\n","\r\n            this is a basic do-nothing implementation of a syntax reference\r\n            ":"\r\n            这是语法参考的基本操作实现\r\n            \r\n","Class which represents the syntax node for tuple expression.":"代表元组表达式语法节点的类。\r\n","\r\n            Lexer entry point for LexMode.XmlProcessingInstructionText\r\n            ":"\r\n            lexmode.xmlPropocessingInstructiontext的Lexer入口点\r\n            \r\n","The attributes on the token, minus any ExtensionAttributes.":"令牌上的属性，减去任何扩展构成。\r\n","\r\n            [NullableContext(0)]\r\n            ":"\r\n            [nullableContext（0）]\r\n            \r\n","\r\n            A single test to be performed, described by a ":"\r\n            一个要执行的单个测试，由A描述\r\n","A public, protected, or protected internal variable must be of a type that is compliant with the Common Language Specification (CLS).":"公众，受保护或受保护的内部变量必须是符合常见语言规范（CLS）的类型。\r\n","The desired special member":"所需的特别成员\r\n","\r\n             - if it implicitly converts to bool, we'll just do the conversion\r\n             - otherwise, we'll do ":"\r\n              - 如果它隐含地转换为布尔，我们将进行转换\r\n              - 否则，我们会做\r\n"," that\r\n            (typically) wraps the subexpression.\r\n            ":" 那\r\n            （通常）包裹子表达。\r\n            \r\n","The expression for which lookup is being performed":"正在执行查找的表达\r\n","\r\n              Looks up a localized string similar to Invalid '{0}' value: '{1}' for C# {2}. Please use language version '{3}' or greater..\r\n            ":"\r\n              查找类似于无效'{0}'值的本地化字符串：'{1}'对于C＃{2}。请使用语言版本'{3}'或更大。\r\n            \r\n","\r\n            Returns a value indicating whether this compilation has a member that needs IsUnmanagedAttribute to be generated during emit phase.\r\n            The value is set during binding the symbols that need that attribute, and is frozen on first trial to get it.\r\n            Freezing is needed to make sure that nothing tries to modify the value after the value is read.\r\n            ":"\r\n            返回一个值，指示该汇编是否具有需要在EMIT阶段生成的iSunmanagedAttibute的成员。\r\n            该值是在绑定需要属性的符号期间设置的，并在第一次试验中冻结以获取它。\r\n            需要冻结以确保在读取值后没有试图修改值。\r\n            \r\n","A list of xml syntax nodes that represents the content of the value element.":"表示值元素内容的XML语法节点列表。\r\n","\r\n              Looks up a localized string similar to The label '{0}' shadows another label by the same name in a contained scope.\r\n            ":"\r\n              查找类似于标签'{0}'在包含范围中的同名标签的局部字符串。\r\n            \r\n"," with\r\n             ":" 和\r\n             \r\n","e.g. '\\uDC00' for &#x10000; (ch == '\\uD800').":"例如＆＃x10000的'\\ udc00'; （ch =='\\ ud800'）。\r\n","Failed lookup result.":"查找结果失败。\r\n","\r\n              Looks up a localized string similar to Do not use '{0}'. This is reserved for compiler usage..\r\n            ":"\r\n              查找类似于不使用'{0}'的本地化字符串。这是用于编译器使用的。\r\n            \r\n","\r\n              Looks up a localized string similar to Unmanaged type '{0}' not valid for fields..\r\n            ":"\r\n              查找类似于非托管类型的本地化字符串'{0}'对字段无效。\r\n            \r\n","A function that computes the translation of the node.  It receives lists of added statements and added symbols":"计算节点翻译的函数。它收到添加语句和添加符号的列表\r\n","\r\n              Looks up a localized string similar to Invalid signature public key specified in AssemblySignatureKeyAttribute..\r\n            ":"\r\n              查找类似于InvelySignature Keytribute中指定的无效签名公共密钥的本地化字符串。\r\n            \r\n","\r\n            Might be a generic (qualified) type name or a method name.\r\n            ":"\r\n            可能是通用（合格的）类型名称或方法名称。\r\n            \r\n","\r\n              Looks up a localized string similar to There is no argument given that corresponds to the required formal parameter '{0}' of '{1}'.\r\n            ":"\r\n              查找类似于类似的本地化字符串，没有任何参数对应于“ {1}”所需的形式参数'{0}'。\r\n            \r\n","Called when the visitor visits a PropertyDeclarationSyntax node.":"当访问者访问属性数据ntrationsyntax节点时，请致电。\r\n","s and compiler options\r\n            like /nowarn, /warnaserror etc.\r\n            ":"S和编译器选项\r\n            喜欢 /nowarn， /warnaserror等\r\n            \r\n","\r\n            Perform lookup (optionally, in a specified container).  If nothing is found and the member name matches the containing type\r\n            name, then use the instance constructors of the type instead.  The resulting symbols are sorted since tie-breaking is based\r\n            on order and we want cref binding to be repeatable.\r\n            ":"\r\n            执行查找（可选地，在指定的容器中）。如果什么也没有找到，并且成员名称与包含类型匹配\r\n            名称，然后使用类型的实例构造函数。由于抢七的符号是基于的，因此将结果符号排序\r\n            按顺序，我们希望CREF绑定可重复。\r\n            \r\n","\r\n            Perform a single pass of flow analysis.  Note that after this pass,\r\n            this.backwardBranchChanged indicates if a further pass is required.\r\n            ":"\r\n            进行单流分析。请注意，通过此通行证，\r\n            此。后链接指示是否需要进一步通过。\r\n            \r\n","A static readonly field cannot be returned by writable reference":"静态可读字段不能通过可写的参考返回\r\n",",\r\n            where we must consider user defined implicit conversions from the type of the switch expression to\r\n            any of the possible switch governing types.\r\n            ":"，，，，\r\n            我们必须考虑用户定义的隐式转换从开关表达式的类型到\r\n            任何可能的开关管理类型。\r\n            \r\n",". \r\n            Returns the type that it actually locks onto (it's possible that it had already locked onto ErrorType).\r\n            ":"。\r\n            返回其实际锁定到的类型（可能已经锁定在错误类型上）。\r\n            \r\n","Auto-implemented property '{0}' cannot be marked 'readonly' because it has a 'set' accessor.":"自动实施属性'{0}'无法标记为“ readonly”，因为它具有“集合”访问者。\r\n","Creates a new UsingStatementSyntax instance.":"创建一个新的使用StattatementSyntax实例。\r\n","\r\n              Looks up a localized string similar to Unused extern alias.\r\n            ":"\r\n              查找类似于未使用的外部别名的局部字符串。\r\n            \r\n","\r\n            Returns the default value constant of the parameter, \r\n            or null if the parameter doesn't have a default value or \r\n            the parameter type is a struct and the default value of the parameter\r\n            is the default value of the struct type or of type parameter type which is \r\n            not known to be a referenced type.\r\n            ":"\r\n            返回参数的默认值常数，\r\n            或null如果参数没有默认值或\r\n            参数类型是参数的struct和默认值\r\n            是结构类型的默认值或类型参数类型的默认值\r\n            不知道是引用类型。\r\n            \r\n","\r\n            Set if the group has a receiver but none was not specified in syntax.\r\n            ":"\r\n            设置如果组有接收器，但没有在语法中指定。\r\n            \r\n","Unsafe code may not appear in iterators":"不安全的代码可能不会出现在迭代器中\r\n","\r\n            The effective base class of the type parameter (spec 10.1.5). If the deduced\r\n            base type is a reference type, the effective base type will be the same as\r\n            the deduced base type. Otherwise if the deduced base type is a value type,\r\n            the effective base type will be the most derived reference type from which\r\n            deduced base type is derived.\r\n            ":"\r\n            类型参数的有效基类（规格10.1.5）。如果推论\r\n            基本类型是参考类型，有效的基本类型将与\r\n            推导的基本类型。否则，如果推论的基本类型是值类型，\r\n            有效的基本类型将是最派生的参考类型\r\n            推导了推导的基本类型。\r\n            \r\n","\r\n            The implementation of Next depends critically on the internal representation of an IEEE floating-point\r\n            number.  Every bit sequence between the representation of 0 and MaxValue represents a distinct\r\n            value, and the integer representations are ordered by value the same as the floating-point numbers they represent.\r\n            ":"\r\n            接下来的实施取决于IEEE浮点的内部表示\r\n            数字。 0和maxValue表示之间的每个位序列都代表一个独特的\r\n            值，整数表示按与它们代表的浮点数相同的值排序。\r\n            \r\n","\r\n              Looks up a localized string similar to Type '{0}' from assembly '{1}' cannot be used across assembly boundaries because it has a generic type parameter that is an embedded interop type..\r\n            ":"\r\n              在汇编边界上查找类似于“汇编” {1}'类型的本地化字符串，因为它具有嵌入式Interop类型。\r\n            \r\n"," token is also the end of the line.  This will\r\n            be true for ":" 令牌也是线路的尽头。这将\r\n            正确\r\n","Set to true if this visited a ":"如果这访问了\r\n","An expression tree may not contain an unsafe pointer operation":"表达树可能不包含不安全的指针操作\r\n","comparisonResult.true":"比较result.true\r\n","\r\n              Looks up a localized string similar to interpolated strings.\r\n            ":"\r\n              查找类似于插值字符串的局部字符串。\r\n            \r\n","\r\n            Some nodes have special binders for their contents (like Blocks)\r\n            ":"\r\n            有些节点具有特殊的粘合剂（例如块）\r\n            \r\n","\r\n            Given a syntax node of a tuple expression, get the tuple type symbol.\r\n            ":"\r\n            给定元组表达式的语法节点，获取元组类型符号。\r\n            \r\n","\r\n              Looks up a localized string similar to Interfaces cannot contain instance constructors.\r\n            ":"\r\n              查找类似于接口的本地化字符串不能包含实例构造函数。\r\n            \r\n","Cannot create short filename '{0}' when a long filename with the same short filename already exists":"当已经存在相同短文件名的长文件名时，无法创建简短的文件名'{0}'\r\n","\r\n            Produced list of \"ephemeral\" locals.\r\n            Essentially, these locals do not need to leave the evaluation stack.\r\n            As such they do not require an allocation of a local slot and \r\n            their load/store operations are implemented trivially.\r\n            ":"\r\n            生产的“短暂”当地人列表。\r\n            本质上，这些当地人不需要离开评估堆栈。\r\n            因此，它们不需要分配本地插槽，并且\r\n            他们的负载/商店操作是微不足道的。\r\n            \r\n","A description of the assemblies referenced by this module.":"该模块引用的组件的描述。\r\n","\r\n              Looks up a localized string similar to End-of-file found, '*/' expected.\r\n            ":"\r\n              查找类似于发现“*/'预期的文件终止”的局部字符串。\r\n            \r\n","\r\n            Does this dag temp represent the original input of the pattern-matching operation?\r\n            ":"\r\n            此DAG温度是否代表模式匹配操作的原始输入？\r\n            \r\n",".\r\n            E.g. if the current compilation references a metadata file that has changed since the creation of the compilation\r\n            the new compilation is going to use the updated version, while the current compilation will be using the previous (it doesn't change).\r\n            ":"。\r\n            例如。如果当前汇编引用自汇编创建以来已更改的元数据文件\r\n            新的汇编将使用更新版本，而当前汇编将使用以前的版本（不更改）。\r\n            \r\n","\r\n            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte signed integer value.\r\n            ":"\r\n            从文本和相应的8字节签名的整数值中创建一个具有属性数字的令牌。\r\n            \r\n","\r\n            Parses any block or expression bodies that are present. Also parses\r\n            the trailing semicolon if one is present.\r\n            ":"\r\n            解析存在的任何块或表达体。也解析\r\n            如果有的话，尾随的分号。\r\n            \r\n","\r\n            Validates whether the invocation is valid per no-mixing rules.\r\n            Returns `false` when it is not valid and produces diagnostics (possibly more than one recursively) that helps to figure the reason.\r\n            ":"\r\n            验证调用是否有效每个禁止混合规则。\r\n            返回`false`当它是无效的，并且会产生诊断（可能递归多个），这有助于弄清原因。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' does not implement '{1}'.\r\n            ":"查找类似于“ {0}'的本地化字符串”不实现'{1}'。\r\n            \r\n","Thrown value may be null.":"投掷价值可能为零。\r\n","\r\n              Looks up a localized string similar to An expression of type '{0}' cannot be handled by a pattern of type '{1}' in C# {2}. Please use language version {3} or greater..\r\n            ":"\r\n              查找类似于类型的“ {0}”表达式的本地化字符串，无法通过c＃{2}中的类型'{1}'的模式来处理。请使用语言版本{3}或更大。\r\n            \r\n","This warning occurs when you try to call a method, property, or indexer on a member of a class that derives from MarshalByRefObject, and the member is a value type. Objects that inherit from MarshalByRefObject are typically intended to be marshaled by refe ...":"当您尝试在派生的类成员上调用方法，属性或索引器时，就会发生此警告，而该类的成员属于元帅，而成员是值类型。从元帅继承的对象通常打算由Refe提交...\r\n","\r\n            The candidate member was rejected because an argument was specified that did not have a corresponding\r\n            parameter.\r\n            ":"\r\n            候选人成员被拒绝，因为指定了没有相应的论点\r\n            范围。\r\n            \r\n","\r\n            The CLR will only look for an implementation of an interface method in a type that\r\n              1) declares that it implements that interface; or\r\n              2) is a base class of a type that declares that it implements the interface but not\r\n                   a subtype of a class that declares that it implements the interface.\r\n                   \r\n            For example,\r\n            \r\n              interface I\r\n              class A\r\n              class B : A, I\r\n              class C : B\r\n              class D : C, I\r\n            \r\n            Suppose the runtime is looking for D's implementation of a member of I.  It will look in \r\n            D because of (1), will not look in C, will look in B because of (1), and will look in A\r\n            because of (2).\r\n            \r\n            The key point is that it does not look in C, which C# *does*.\r\n            ":"\r\n            CLR只会在类型中寻找接口方法的实现\r\n              1）声明它实现了该接口；或者\r\n              2）是一种声明其实现接口但未实现的类型的基类\r\n                   宣布其实现接口的类的子类型。\r\n                   \r\n            例如，\r\n            \r\n              接口i\r\n              A类\r\n              B级：A，我\r\n              C级：B\r\n              D级：C，我\r\n            \r\n            假设运行时正在寻找I的成员的D\r\n            d由于（1），不会在C中看，因为（1）会在B中看，并且会在A中看\r\n            因为（2）。\r\n            \r\n            关键点是它不在c中，c＃ *do do *。\r\n            \r\n","A namespace cannot directly contain members such as fields, methods or statements":"名称空间不能直接包含诸如字段，方法或语句之类的成员\r\n","Gets the open brace token.":"获取开放的支撑令牌。\r\n","\r\n              Looks up a localized string similar to Duplicate constraint '{0}' for type parameter '{1}'.\r\n            ":"\r\n              查找类似于重复约束'{0}'的本地化字符串，以键入type参数'{1}'。\r\n            \r\n","The argument syntax node.":"参数语法节点。\r\n","\r\n            Helper method that replaces less-than and greater-than characters with brackets. \r\n            ":"\r\n            辅助方法可以用括号替代比人字符少。\r\n            \r\n","\r\n            Symbol for a local whose type can be inferred by binding its initializer.\r\n            ":"\r\n            可以通过绑定其初始化器来推断其类型的本地符号。\r\n            \r\n","\r\n            Some variables that should be considered initially assigned.  Used for region analysis.\r\n            ":"\r\n            一些最初分配的变量。用于区域分析。\r\n            \r\n","\r\n            Expression is the LHS of a compound assignment\r\n            operation (such as +=).\r\n            ":"\r\n            表达是复合分配的LHS\r\n            操作（例如 +=）。\r\n            \r\n","\r\n            Returns the method used to create the delegate for a method group conversion if ":"\r\n            返回用于创建用于方法组转换的委托的方法\r\n","Cannot assign to '{0}' because it is a '{1}'":"无法分配给'{0}'，因为它是'{1}'\r\n","\r\n              Looks up a localized string similar to '{0}' is not a recognized attribute location. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored..\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串不是公认的属性位置。此声明的有效属性位置为“ {1}”。该块中的所有属性将被忽略。\r\n            \r\n","\r\n              Looks up a localized string similar to The type '{0}' is defined in an assembly that is not referenced. You must add a reference to assembly '{1}'..\r\n            ":"查找类似于“ {0}”类型的本地化字符串是在未引用的汇编中定义的。您必须将引用添加到汇编'{1}'..\r\n            \r\n","\r\n            A group is a common instance referenced by all BoundConversion instances\r\n            generated from a single Conversion. The group is used by NullableWalker to\r\n            determine which BoundConversion nodes should be considered as a unit.\r\n            ":"\r\n            组是所有界限实例引用的常见实例\r\n            由单个转换产生。该组由NullableWalker使用\r\n            确定应将哪些绑定节点视为单位。\r\n            \r\n","\r\n              Looks up a localized string similar to The type of the argument to the DefaultParameterValue attribute must match the parameter type.\r\n            ":"\r\n              查找与DefaultParameterValue属性的参数类型相似的本地化字符串必须与参数类型匹配。\r\n            \r\n","\r\n              Looks up a localized string similar to Member overrides obsolete member.\r\n            ":"\r\n              查找类似于成员覆盖成员的局部字符串。\r\n            \r\n"," isn't applied on the containing module or it doesn't apply on this symbol.\r\n            ":" 不应用于包含的模块，也不应用于此符号上。\r\n            \r\n","\r\n            BlockSyntax node representing the body of the anonymous function.\r\n            Only one of Block or ExpressionBody will be non-null.\r\n            ":"\r\n            blocksyntax节点代表匿名函数的主体。\r\n            只有一个块或表达机构将是非零的。\r\n            \r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 4.  Please use language version {1} or greater..\r\n            ":"\r\n              查找类似于功能'{0}'的本地化字符串。\r\n            \r\n","\r\n            Returns true if the conversion is a stackalloc conversion.\r\n            ":"\r\n            如果转换是stackalloc转换，则返回true。\r\n            \r\n","\r\n            The index of this member in the containing symbol. This is an optional\r\n            property, implemented by anonymous type properties only, for comparing\r\n            symbols in flow analysis.\r\n            ":"\r\n            该成员在包含符号中的索引。这是一个可选的\r\n            仅由匿名类型属性实现的属性，用于比较\r\n            流量分析中的符号。\r\n            \r\n","\r\n            A pending branch.  There are created for a return, break, continue, goto statement,\r\n            yield return, yield break, await expression, and if PreciseAbstractFlowPass.trackExceptions\r\n            is true for other\r\n            constructs that can cause an exception to be raised such as a throw statement or method\r\n            invocation.\r\n            The idea is that we don't know if the branch will eventually reach its destination\r\n            because of an intervening finally block that cannot complete normally.  So we store them\r\n            up and handle them as we complete processing each construct.  At the end of a block, if\r\n            there are any pending branches to a label in that block we process the branch.  Otherwise\r\n            we relay it up to the enclosing construct as a pending branch of the enclosing\r\n            construct.\r\n            ":"\r\n            一个待处理的分支。创建用于返回，中断，继续，goto语句，\r\n            收益率回报，收益率中断，等待表达，以及如果PreciseabstractFlowPass.TracKexceptions\r\n            对其他人是正确的\r\n            可能导致例外的构造，例如投掷声明或方法\r\n            调用。\r\n            这个想法是，我们不知道该分支最终是否将最终到达目的地\r\n            由于中间最终无法正常完成。所以我们存储了它们\r\n            当我们完成每个构造时，向上处理并处理它们。在一个块的末端，如果\r\n            在该块中，有任何已待处理的分支，我们处理分支。否则\r\n            我们将其传达到封闭构造作为封闭的待处理分支\r\n            构造。\r\n            \r\n","Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly, except for either a 'class', or a 'struct' constraint.":"覆盖和显式接口实现方法的约束是从基本方法继承的，因此除了“类”或“ struct”约束之外，不能直接指定它们。\r\n","The interface method that is going to be implemented by using synthesized MethodImpl entry.":"将使用合成的MethodImpl条目实现的接口方法。\r\n","\r\n            When pattern-matching is enabled, we use a completely different binder and binding\r\n            strategy for switch statements. Once we have confirmed that it is totally upward\r\n            compatible with the existing syntax and semantics, we will merge them completely.\r\n            However, until we have edit-and-continue working, we continue using the old binder\r\n            when we can.\r\n            ":"\r\n            启用图案匹配时，我们使用完全不同的粘合剂和绑定\r\n            开关语句的策略。一旦我们确认它完全向上\r\n            与现有的语法和语义兼容，我们将完全合并它们。\r\n            但是，直到我们进行编辑和连续性工作，我们将继续使用旧的粘合剂\r\n            我们可以。\r\n            \r\n","\r\n            The candidate member was rejected because an inferred type argument is inaccessible.\r\n            ":"\r\n            候选人成员被拒绝，因为推断的类型参数无法访问。\r\n            \r\n"," if syntax binds to a type in the current context, otherwise\r\n            syntax binds to the corresponding keyword in the current context.\r\n            ":" 如果语法在当前上下文中与类型结合，则\r\n            语法在当前上下文中与相应的关键字结合。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' in explicit interface declaration is not a member of interface.\r\n            ":"\r\n              在显式接口声明中查找类似于“ {0}”的本地化字符串不是接口的成员。\r\n            \r\n","'extern alias' is not valid in this context":"在这种情况下，“外部别名”无效\r\n","\r\n              Looks up a localized string similar to Type or member is obsolete.\r\n            ":"\r\n              查找类似于类型或成员的本地化字符串已过时。\r\n            \r\n","\r\n             Should we warn for assigning this state into this type?\r\n            \r\n             This should often be checked together with ":"\r\n             我们应该警告将这种状态分配给这种类型吗？\r\n            \r\n             这通常应该一起检查\r\n"," depending on whether the\r\n            types are ":" 取决于是否\r\n            类型是\r\n","\r\n            The list of custom modifiers, if any, associated with the parameter type.\r\n            ":"\r\n            与参数类型关联的自定义修饰符列表。\r\n            \r\n","\r\n              Looks up a localized string similar to Predefined type '{0}' is not defined or imported.\r\n            ":"\r\n              查找类似于预定义类型“ {0}”的本地化字符串未定义或导入。\r\n            \r\n","Inconsistent syntax tree features":"不一致的语法树特征\r\n",") or nested (like ":"）或嵌套（就像\r\n","True to get a special binder for cref parameter and return types.":"真实地获得CREF参数和返回类型的特殊活页夹。\r\n","Creates a new WhenClauseSyntax instance.":"创建一个新的clausesyntax实例。\r\n","Invalid variance modifier. Only interface and delegate type parameters can be specified as variant.":"无效的方差修饰符。只能将接口和委托类型参数指定为变体。\r\n","A bound expression for the constructor initializer call.":"构造函数初始化调用的绑定表达式。\r\n"," must have been created from CSharp code.\r\n            ":" 必须是由CSHARP代码创建的。\r\n            \r\n","The list of statements to visit":"访问的陈述列表\r\n","The first statement to be included in the analysis.":"分析中包含的第一个陈述。\r\n","\r\n            If the method was written as an iterator method (i.e. with yield statements in its body) returns the\r\n            element type of the iterator.  Otherwise returns null.\r\n            ":"\r\n            如果该方法是作为迭代方法写的（即带有屈服声明的方法），则返回\r\n            迭代器的元素类型。否则返回null。\r\n            \r\n","\r\n            Walk up from an XML syntax node (attribute or tag) to the enclosing documentation comment trivia.\r\n            ":"\r\n            从XML语法节点（属性或标签）走到封闭文档注释琐事。\r\n            \r\n","The label '{0}' shadows another label by the same name in a contained scope":"标签'{0}'在包含的范围中以同一名称为同一名称的另一个标签\r\n","\r\n            Lookup declaration for predefined CorLib type in this Assembly.\r\n            ":"\r\n            该组件中预定义的Corlib类型的查找声明。\r\n            \r\n","Where to place any diagnostics":"在哪里放置任何诊断\r\n","Creates a new FunctionPointerParameterListSyntax instance.":"创建一个新的forcormPoInterParameterListsyntax实例。\r\n","\r\n            The list of trivia that appears after this node in the source code.\r\n            ":"\r\n            该节点在源代码中出现的琐事列表。\r\n            \r\n","Field cannot have void type":"字段不能具有无效类型\r\n","If a method group conversion, the desired return type of the delegate.\r\n            May be null during inference if the return type of the delegate needs to be computed.":"如果方法组转换，则委托的所需返回类型。\r\n            如果需要计算委托的返回类型，则可能是无效的。\r\n","\r\n            The int key corresponds to ":"\r\n            Int键对应于 \r\n","\r\n              Looks up a localized string similar to '{1}' does not define type parameter '{0}'.\r\n            ":"\r\n              查找类似于'{1}'的本地化字符串未定义类型参数'{0}'。\r\n            \r\n","SyntaxToken representing the operator of the assignment expression.":"Syntaxtoken代表分配表达式的操作员。\r\n","\r\n              Looks up a localized string similar to AppConfigPath must be absolute..\r\n            ":"\r\n              查找类似于AppConfigPath的本地化字符串必须是绝对的。\r\n            \r\n","\r\n              Looks up a localized string similar to CLSCompliant attribute has no meaning when applied to parameters.\r\n            ":"\r\n              查找类似于CLSCompliant属性的本地化字符串，当应用于参数时没有含义。\r\n            \r\n","Cannot continue since the edit includes a reference to an embedded type: '{0}'.":"由于编辑包括对嵌入式类型的引用：'{0}'。\r\n","\r\n            Analyzes method body for labels.\r\n            ":"\r\n            分析标签的方法主体。\r\n            \r\n","(D1 d1, ...) = /* expression */":"（D1 D1，...）= / *表达 * /\r\n","Method must have a return type":"方法必须具有返回类型\r\n","Creates a new DelegateDeclarationSyntax instance.":"创建一个新的委托书yntax实例。\r\n","\r\n            Returns true if the conversion is an implicit method group conversion.\r\n            ":"\r\n            如果转换是隐式方法组转换，则返回true。\r\n            \r\n","\r\n            This instance is used to search for members that have the same name, parameters, (return) type, and constraints (if any)\r\n            according to the C# definition. Custom modifiers are ignored.\r\n            ":"\r\n            此实例用于搜索具有相同名称，参数，（返回）类型和约束（如果有）的成员\r\n            根据C＃定义。自定义修饰符被忽略。\r\n            \r\n","\r\n            It is rare but possible for a source expression to be convertible to a destination type\r\n            by both an implicit user-defined conversion and a built-in explicit conversion.\r\n            In that circumstance, this method classifies the conversion as the implicit conversion.\r\n            ":"\r\n            很少有源表达式可转换为目的地类型\r\n            通过隐式用户定义的转换和内置的显式转换。\r\n            在这种情况下，此方法将转换分类为隐式转换。\r\n            \r\n","\r\n            This publicly exposes the attributes of the internal backing field.\r\n            ":"\r\n            这公开公开了内部背衬字段的属性。\r\n            \r\n","The enclosing class":"封闭类\r\n","Calculate the start offset and length of range object using a collection length.":"使用集合长度计算范围对象的起始偏移和长度。\r\n","\r\n            Holds the variables on the LHS of a deconstruction as a tree of bound expressions.\r\n            ":"\r\n            将变量保存在解构的LHS上，作为绑定表达式的树。\r\n            \r\n","Called when the visitor visits a AssignmentExpressionSyntax node.":"当访问者访问sizhtment expressionsyntax节点时调用。\r\n","\r\n            An array of cached Cor types defined in this assembly.\r\n            Lazily filled by GetSpecialType method.\r\n            ":"\r\n            该组件中定义的一组缓存的COR类型。\r\n            用getspecialtype方法懒洋洋地填充。\r\n            \r\n","Sub-expression cannot be used in an argument to nameof.":"子表达不能在参数中使用以命名。\r\n","\r\n            Translate an is-pattern expression into a sequence of tests separated by the control-flow-and operator.\r\n            ":"\r\n            将IS-Pattern表达式转换为由控制流和操作员分离的一系列测试序列。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串没有预定义的大小，因此只能在不安全的上下文中使用sizeof。\r\n            \r\n","Creates a new PredefinedTypeSyntax instance.":"创建一个新的PredeDinedTypesyntax实例。\r\n","\r\n              Looks up a localized string similar to Cannot return by reference a member of result of '{0}' because the argument passed to parameter '{1}' cannot be returned by reference.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法通过引用“ {0}”的结果返回，因为传递给参数'{1}'的参数无法通过参考返回。\r\n            \r\n","\r\n            Serialize the syntax node into a byte stream.\r\n            ":"\r\n            将语法节点序列化为字节流。\r\n            \r\n","\r\n            Get a SemanticModel object that is associated with an attribute that did not appear in\r\n            this source code. This can be used to get detailed semantic information about sub-parts\r\n            of an attribute that did not appear in source code. \r\n            ":"\r\n            获取与未出现在\r\n            此源代码。这可以用来获取有关子部分的详细语义信息\r\n            未出现在源代码中的属性。\r\n            \r\n"," part of the decision tree is used.\r\n            ":" 使用决策树的一部分。\r\n            \r\n","\r\n            Adjust the ":"\r\n            调整\r\n","The translated statement, as returned from F":"翻译的语句，从f返回\r\n","\r\n            Extra restrictions apply when searching for a well-known type.  In particular, the type must be public.\r\n            ":"\r\n            搜索众所周知的类型时，适用额外的限制。特别是，该类型必须是公开的。\r\n            \r\n","\r\n              Looks up a localized string similar to #error: '{0}'.\r\n            ":"\r\n              查找类似于#Error的本地化字符串：'{0}'。\r\n            \r\n","The hintName '{0}' of the added source file must be unique within a generator.":"添加源文件的hintname'{0}'必须在生成器中是唯一的。\r\n","'{0}': accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor":"'{0}'：仅当属性或索引器具有GET和SET访问者时，才能使用登录机上的可访问性修饰符\r\n","\r\n            Checks to see whether an expression is a \"moveable\" variable according to the spec. Moveable\r\n            variables have underlying memory which may be moved by the runtime. The spec defines anything\r\n            not fixed as moveable and specifies the expressions which are fixed.\r\n            ":"\r\n            检查表达式是否是根据规格的“可移动”变量。活动\r\n            变量具有基础内存，可以通过运行时移动。规格定义了任何内容\r\n            不固定为可移动，并指定固定的表达式。\r\n            \r\n","\r\n            When binding \"C\" new C(...), return the type C and do not return information about\r\n            which constructor was bound to. Bind \"new C(...)\" to get information about which constructor\r\n            was chosen.\r\n            ":"\r\n            绑定“ C”新C（...）时，返回C型，请勿返回有关的信息\r\n            哪个构造函数绑定到。绑定“新C（...）”以获取有关哪个构造函数的信息\r\n            被选中。\r\n            \r\n","Creates a new QueryExpressionSyntax instance.":"创建一个新的QueryExpressionsyntax实例。\r\n","The resolved symbol if successful or null on failure.":"解决的符号是成功的或失败时无效的。\r\n","\r\n            Schedules the state machine to proceed to the next action when the specified awaiter completes. This method can be called from partially trusted code.\r\n            ":"\r\n            计划机器在指定的等待者完成后继续进行下一个操作。该方法可以从部分信任的代码中调用。\r\n            \r\n","\r\n            Returns 'NotApplicable' because label can't be used outside the member body.\r\n            ":"\r\n            返回“非适当”，因为不能在会员体外使用标签。\r\n            \r\n","Called when the visitor visits a CheckedExpressionSyntax node.":"当访问者访问checkEdeDexpressyntax节点时，请致电。\r\n","SyntaxToken representing the asterisk.":"Syntaxtoken代表星号。\r\n","static classes":"静态课程\r\n","The set of locals declared in the original version of this statement":"此语句的原始版本中声明的当地人集\r\n","\r\n            Frees an optional temp.\r\n            ":"\r\n            释放一个可选的温度。\r\n            \r\n","Partial declarations of '{0}' have inconsistent constraints for type parameter '{1}'":"“ {0}”的部分声明对类型参数'{1}'的约束不一致\r\n","Called when the visitor visits a XmlCDataSectionSyntax node.":"当访问者访问XMLCDATASECTIONSYNTAX节点时调用。\r\n","The method symbol that was looked up, or null":"查找的方法符号或无效\r\n","The location at which to report overload resolution result diagnostics.":"报告超载分辨率结果诊断的位置。\r\n","\r\n              Looks up a localized string similar to Attribute constructor parameter '{0}' has type '{1}', which is not a valid attribute parameter type.\r\n            ":"\r\n              查找类似于属性constructor参数'{0}'的本地化字符串type'{1}'，这不是有效的属性参数类型。\r\n            \r\n",".\r\n            \r\n            Then we make a frame, or compiler-generated class, represented by an instance of\r\n            ":"。\r\n            \r\n            然后，我们制作一个框架或编译器生成的类，以实例为代表\r\n            \r\n","\r\n              Looks up a localized string similar to The 'notnull' constraint must come before any other constraints.\r\n            ":"\r\n              查找类似于“ notnull”约束的本地化字符串必须在任何其他约束之前进行。\r\n            \r\n","\r\n            True if, for example, this expression statement represents the last expression statement\r\n            of the interactive top-level code.\r\n            ":"\r\n            例如，如果例如，此表达式语句代表最后一个表达式语句\r\n            交互式顶级代码。\r\n            \r\n","\r\n              Looks up a localized string similar to Accessing a member on a field of a marshal-by-reference class may cause a runtime exception.\r\n            ":"\r\n              查找类似于访问成员在逐个参考类的字段上的成员类似的本地化字符串可能会导致运行时异常。\r\n            \r\n","End tag was not expected at this location.":"在这个位置不会预期结束标签。\r\n","\r\n            Return the Invoke method symbol if the type is a delegate\r\n            type and the Invoke method is available, otherwise null.\r\n            ":"\r\n            如果类型是委托，请返回Invoke方法符号\r\n            类型和调用方法可用，否则为空。\r\n            \r\n"," converts a value from one type to another (which\r\n            is performed only after testing that the value is of that type).\r\n            ":" 将一个值从一种类型转换为另一种类型（\r\n            仅在测试该值是该类型的值之后才能执行。\r\n            \r\n"," (Deconstructable1.Deconstruct), no ":"（deconstructable1.deconstruct），否\r\n","\r\n              Looks up a localized string similar to Cannot convert null literal to non-nullable reference type..\r\n            ":"\r\n              查找类似于不能将null字面的字符串转换为不可删除的参考类型的本地化字符串。\r\n            \r\n","\r\n            This instance is used when trying to determine if one member explicitly implements another,\r\n            according the C# definition.\r\n            The member signatures are compared without regard to name (including the interface part, if any)\r\n            and the return types must match.\r\n            ":"\r\n            试图确定一个成员是否明确实现另一个成员时使用此实例，\r\n            根据C＃定义。\r\n            比较成员签名而无需考虑名称（包括接口部分，如果有）\r\n            返回类型必须匹配。\r\n            \r\n","\r\n            A collection of type parameter constraint kinds, populated when\r\n            constraint kinds for the first type parameter are requested.\r\n            ":"\r\n            类型参数约束类型的集合，当\r\n            请求第一个类型参数的约束种类。\r\n            \r\n","A list of syntax nodes that represents the content of the permission element.":"表示权限元素内容的语法节点列表。\r\n","\r\n              Looks up a localized string similar to Field is never used.\r\n            ":"\r\n              查找与字段类似的本地化字符串。\r\n            \r\n","\r\n            Attributes filtered out from m_lazyCustomAttributes, ParamArray, etc.\r\n            ":"\r\n            从m_lazycustomattributes，paramarray等过滤掉属性。\r\n            \r\n","Called when the visitor visits a ElseClauseSyntax node.":"当访问者访问elseclausesyntax节点时打电话。\r\n","Creates a new LetClauseSyntax instance.":"创建一个新的letclausesyntax实例。\r\n","\r\n              Looks up a localized string similar to Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed..\r\n            ":"\r\n              查找类似于“ system.runtime.compilerservices.nulleableattribute”的显式应用的本地化字符串。\r\n            \r\n","Called when the visitor visits a CatchDeclarationSyntax node.":"当访问者访问catchdeclarationsyntax节点时，请致电。\r\n","The tuple element name is ignored because a different name or no name is specified on the other side of the tuple == or != operator.":"元组元素名称被忽略，因为在元组的另一侧指定了不同的名称或未指定名称。\r\n","GetTuple() == (1, 2)":"getTuple（）==（1，2）\r\n","Operation caused a stack overflow.":"操作导致堆栈溢出。\r\n","\r\n            Verify if the given type can be used to back a tuple type \r\n            and return cardinality of that tuple type in ":"\r\n            验证给定类型是否可以用于备份元组类型\r\n            并返回该元组类型的基数\r\n","\r\n            The method whose body is being analyzed, or the field whose initializer is being analyzed.\r\n            May be a top-level member or a lambda or local function. It is used for\r\n            references to method parameters. Thus, '_symbol' should not be used directly, but\r\n            'MethodParameters', 'MethodThisParameter' and 'AnalyzeOutParameters(...)' should be used\r\n            instead. _symbol is null during speculative binding.\r\n            ":"\r\n            正在分析其身体的方法或正在分析初始化器的领域。\r\n            可以是顶级成员，或Lambda或本地功能。它用于\r\n            参考参数。因此，“ _symbol”不应直接使用，而应\r\n            应使用“方法参数”，“方法thisparameter”和“ AnalyzeOutParameters（...）”\r\n            反而。 _symbol在投机结合期间为无效。\r\n            \r\n","\r\n            Does a data flow analysis for state attached to local variables and fields of struct locals.\r\n            ":"\r\n            是否对附加到局部变量的状态和结构本地的字段进行数据流分析。\r\n            \r\n","\r\n            Creates a new syntax token with all whitespace and end of line trivia replaced with\r\n            regularly formatted trivia.\r\n            ":"\r\n            用所有空格和线路的结尾替换为新的语法令牌\r\n            定期格式化的琐事。\r\n            \r\n","Called when the visitor visits a InterfaceDeclarationSyntax node.":"当访问者访问Interfacedeclarationsyntax节点时，请致电。\r\n","Creates a new RefExpressionSyntax instance.":"创建一个新的Refexpressionsyntax实例。\r\n","Unmanaged constructed types":"不受管理的构造类型\r\n","\r\n            Construct context\r\n            ":"\r\n            构造上下文\r\n            \r\n","\r\n            Unique identifier in the chain of nested Variables instances. The value starts at 0\r\n            for the outermost method and increases at each nested function.\r\n            ":"\r\n            嵌套变量实例链中的唯一标识符。值从0开始\r\n            对于最外面的方法，并在每个嵌套函数上增加。\r\n            \r\n","\r\n              Looks up a localized string similar to The CallerMemberNameAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments.\r\n            ":"\r\n              查找类似于CallermemberneatTribute的本地化字符串将没有效果，因为它适用于不允许可选参数的上下文中使用的成员。\r\n            \r\n","Neither 'is' nor 'as' is valid on pointer types":"对指针类型既没有“也不是”为'\r\n","\r\n              Looks up a localized string similar to Partial declarations of '{0}' have conflicting accessibility modifiers.\r\n            ":"\r\n              查找类似于“ {0}”的部分声明类似的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Preprocessor directives must appear as the first non-whitespace character on a line.\r\n            ":"\r\n              查找类似于预处理指令类似的本地化字符串必须以行上的第一个非Whitespace字符出现。\r\n            \r\n","Use of possibly unassigned auto-implemented property '{0}'":"使用可能未分配的自动进化属性'{0}'\r\n","\r\n            Diagnostics that occur within cref attributes need to be\r\n            wrapped with ErrorCode.WRN_ErrorOverride.\r\n            ":"\r\n            CREF属性中发生的诊断需要为\r\n            用errorcode.wrn_erroroverride包装。\r\n            \r\n","\r\n            Represents a synthesized state machine field.\r\n            ":"\r\n            代表合成的状态机字段。\r\n            \r\n","\r\n            This is for when we are taking the address of a field.\r\n            Distinguish from ":"\r\n            这是为了当我们接受一个领域的地址时。\r\n            与众不同\r\n","Attribute '{0}' is only valid on classes derived from System.Attribute":"属性'{0}'仅在从system.attribute派生的类中有效\r\n","\r\n            Type variables are never considered reference types by the verifier.\r\n            ":"\r\n            类型变量永远不会被验证者视为参考类型。\r\n            \r\n"," if\r\n            there are no attributes.\r\n            ":" 如果\r\n            没有属性。\r\n            \r\n","\r\n              Looks up a localized string similar to Unexpected character '{0}'.\r\n            ":"\r\n              查找类似于意外字符'{0}'的本地化字符串。\r\n            \r\n","\r\n            Returns true if the named type is an implementation template for an anonymous type\r\n            ":"\r\n            如果命名类型是匿名类型的实现模板，则返回true\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' is not a valid named attribute argument because it is not a valid attribute parameter type.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串不是一个有效的命名属性参数，因为它不是有效的属性参数类型。\r\n            \r\n","The syntax node that declares an anonymous object.":"声明匿名对象的语法节点。\r\n","Tuple element name '{0}' is only allowed at position {1}.":"元组元素名称'{0}'仅在位置{1}处允许。\r\n","The two statements are not contained within the same statement list.":"这两个语句不包含在同一语句列表中。\r\n","\r\n              Looks up a localized string similar to This warning occurs when you try to call a method, property, or indexer on a member of a class that derives from MarshalByRefObject, and the member is a value type. Objects that inherit from MarshalByRefObject are typically intended to be marshaled by reference across an application domain. If any code ever attempts to directly access the value-type member of such an object across an application domain, a runtime exception will occur. To resolve the warning, first copy the member into a local variable and c [rest of string was truncated]\";.\r\n            ":"\r\n              查找类似于此警告的本地化字符串，当您尝试在派生的类成员上调用方法，属性或索引器时，就会发生这种局部字符串，而该类的成员是从元帅中派生的，并且成员是值类型。通常旨在通过在应用程序域上引用参考，从而通过参考来封为。如果任何代码曾经尝试直接跨应用程序域访问该对象的值成员，则将发生运行时异常。为了解决警告，请首先将成员复制到局部变量中，并将其c [截断其余的字符串]”；\r\n            \r\n","To use '@$' instead of '$@' for an interpolated verbatim string, please use language version '{0}' or greater.":"要使用'@$'代替'$@'进行插值的逐字字符串，请使用语言版本'{0}或更大。\r\n","\r\n            If this method overrides another method (because it both had the override modifier\r\n            and there correctly was a method to override), returns the overridden method.\r\n            Note that if an overriding method D.M overrides C.M, which in turn overrides\r\n            virtual method A.M, the \"overridden method\" of D.M is C.M, not the original virtual\r\n            method A.M. Note also that constructed generic methods are not considered to\r\n            override anything.\r\n            ":"\r\n            如果此方法覆盖了另一种方法（因为它都具有覆盖修饰符\r\n            并且正确地是一种覆盖方法），返回覆盖方法。\r\n            请注意，如果覆盖方法D.M覆盖C.M，则又覆盖了\r\n            虚拟方法A.M，D.M的“覆盖方法”是C.M，而不是原始虚拟\r\n            方法A.M.还请注意，构造的通用方法不被视为\r\n            覆盖任何东西。\r\n            \r\n","The body of an async-iterator method must contain a 'yield' statement.":"异步 - 介质方法的主体必须包含“产量”陈述。\r\n","\r\n            No valid type for operator.\r\n            ":"\r\n            没有有效类型的操作员。\r\n            \r\n","\r\n            Returns true if the method body is an expression, as expressed\r\n            by the ":"\r\n            如果方法主体为表达式，则返回true，如表达\r\n            由\r\n","Creates a new RefTypeExpressionSyntax instance.":"创建一个新的ReftyPeeXpressionsyntax实例。\r\n","This is used by the ExpressionEvaluator.":"这是由表达式使用者使用的。\r\n","Type expected":"预期的类型\r\n","\r\n            This override changes two things:\r\n                1) Return type arguments instead of type parameters.\r\n                2) Handle non-PE types.\r\n            ":"\r\n            这覆盖了两件事：\r\n                1）返回类型参数而不是类型参数。\r\n                2）处理非PE类型。\r\n            \r\n","The name '{0}' does not exist in the current context (are you missing a reference to assembly '{1}'?)":"名称'{0}'在当前上下文中不存在（您是否缺少对汇编'{1}'？）的引用\r\n"," and the attribute\r\n            has some error (such as invalid names).\r\n            ":" 和属性\r\n            有一些错误（例如无效名称）。\r\n            \r\n","\r\n              Looks up a localized string similar to __arglist is not allowed in the parameter list of iterators.\r\n            ":"\r\n              在迭代器的参数列表中不允许查找类似于__arglist的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': user-defined conversions to or from a derived class are not allowed.\r\n            ":"\r\n              查找类似于“ {0}'的本地化字符串：不允许使用派生类或来自派生类的用户定义转换。\r\n            \r\n","%=":"％=\r\n","\r\n              Looks up a localized string similar to '{0}' is obsolete: '{1}'.\r\n            ":"\r\n              查找类似于'{0}'的局部字符串是过时的：'{1}'。\r\n            \r\n","\r\n              Looks up a localized string similar to A namespace cannot directly contain members such as fields or methods.\r\n            ":"\r\n              查找类似于名称空间的本地化字符串不能直接包含诸如字段或方法之类的成员。\r\n            \r\n","\r\n              Looks up a localized string similar to Call to non-readonly member from a 'readonly' member results in an implicit copy..\r\n            ":"\r\n              查找类似于从“ ReadOnly”成员调用非读取成员的局部字符串，以隐式副本产生。\r\n            \r\n","\r\n              Looks up a localized string similar to Namespace '{1}' contains a definition conflicting with alias '{0}'.\r\n            ":"\r\n              查找类似于名称空间'{1}'的局部字符串包含与别名'{0}'相冲突的定义。\r\n            \r\n","\r\n              Looks up a localized string similar to Use of possibly unassigned auto-implemented property '{0}'.\r\n            ":"\r\n              查找类似于使用可能未分配的自动插入属性'{0}'的本地化字符串。\r\n            \r\n","\r\n            Creates a SemanticModel that creates and owns the ExecutableCodeBinder for the method of which it is a model.\r\n            ":"\r\n            创建一个semanticmodel，该语义模型为其成为模型的方法创建并拥有executableCodeBinder。\r\n            \r\n","\r\n            tests that a value is not null; ":"\r\n            测试值不是零的；\r\n","Creates a new ElementAccessExpressionSyntax instance.":"创建一个新的元素accessexpressionsyntax实例。\r\n","\r\n            Capture the set of compilation options to allow a compilation \r\n            to be reconstructed from the pdb\r\n            ":"\r\n            捕获一组汇编选项以允许编译\r\n            从PDB重建\r\n            \r\n","\r\n            Global namespace usings.\r\n            ":"\r\n            全球名称空间使用。\r\n            \r\n","\r\n            Gets the attribute target kind corresponding to the symbol kind\r\n            If attributes cannot be applied to this symbol kind, returns\r\n            an invalid AttributeTargets value of 0\r\n            ":"\r\n            获取与符号类型相对应的属性目标类\r\n            如果属性不能应用于此符号类型，请返回\r\n            无效的属性属性值为0\r\n            \r\n","Error opening response file '{0}'":"错误打开响应文件'{0}'\r\n","\r\n              Looks up a localized string similar to Compilation (C#): .\r\n            ":"\r\n              查找类似于汇编（C＃）的本地化字符串：。\r\n            \r\n","\r\n            Finally state of the next Finally frame if such created.\r\n            Finally state is a negative decreasing number starting with -3. (-2 is used for something else).\r\n            Root frame has finally state -1.\r\n            \r\n            The Finally state is the state that we are in when \"between states\".\r\n            Regular states are positive and are the only states that can be resumed to.\r\n            The purpose of distinct finally states is to have enough information about \r\n            which finally handlers must run when we need to finalize iterator after a fault. \r\n            ":"\r\n            最后，如果创建了下一个最后的状态。\r\n            最终，状态是从-3开始的负数下降数。 （-2用于其他东西）。\r\n            根架最终有-1。\r\n            \r\n            最终的状态是我们在“之间”之间处于的状态。\r\n            常规状态是积极的，是唯一可以恢复的状态。\r\n            最终指出的目的是拥有足够的信息\r\n            最终，当我们需要在故障后确定迭代器时必须运行。\r\n            \r\n","\r\n              Looks up a localized string similar to You cannot redefine the global extern alias.\r\n            ":"\r\n              查找类似于您的本地化字符串无法重新定义全局外部别名。\r\n            \r\n","\r\n            Read-only outside SyntaxParser (not enforced for perf reasons).\r\n            Reference type so that the factory stays up-to-date.\r\n            ":"\r\n            仅在syntaxparser外部读取（由于完美原因而不是执行）。\r\n            参考类型，使工厂保持最新状态。\r\n            \r\n","\r\n              Looks up a localized string similar to Module name '{0}' stored in '{1}' must match its filename..\r\n            ":"\r\n              查找类似于“ {1}”中存储的模块名称'{0}'的本地化字符串必须匹配其文件名。\r\n            \r\n","The '#' token.":"“＃”令牌。\r\n","Methods with variable arguments are not CLS-compliant":"具有可变参数的方法不符合CLS\r\n","\r\n            Helper method to generate a lowered conversion from the given rewrittenOperand to the given rewrittenType with the given conversion kind.\r\n            ":"\r\n            使用给定的转换类型的助手方法从给定的重新写入到给定的重写类型的降低转换。\r\n            \r\n","\r\n              Looks up a localized string similar to Operator '{0}' is ambiguous on operands of type '{1}' and '{2}'.\r\n            ":"\r\n              在类型'{1}'和'{2}'的操作数上查找类似于操作员'{0}'类似的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Identifier is not CLS-compliant.\r\n            ":"\r\n              查找类似于标识符的本地化字符串不合同。\r\n            \r\n","A node of interest (typically, the default node for a non-exhaustive switch).":"感兴趣的节点（通常是非避免开关的默认节点）。\r\n","\r\n            A node representing a dispatch based on a relational test of the input value by some constant.\r\n            Nodes of this kind are required to be height-balanced when constructed, so that when the full\r\n            decision tree is produced it generates a balanced tree of comparisons.  The shape of the tree\r\n            keeps tests for lower values on the left and tests for higher values on the right:\r\n            For ":"\r\n            一个基于输入值的关系测试来表示调度的节点以某个常数为单位。\r\n            构造时，此类节点必须保持高度平衡，以便当完整时\r\n            产生了决策树，它会生成平衡的比较树。树的形状\r\n            对左侧的较低值进行测试，并在右侧测试更高的值：\r\n            为了\r\n","Creates a new QueryContinuationSyntax instance.":"创建一个新的QueryContinuationSyntax实例。\r\n","\r\n            Returns true if the initializer is a field initializer which should be optimized out\r\n            ":"\r\n            如果初始化器是字段初始化器，则返回true，应进行优化\r\n            \r\n","\r\n            This method validates attribute usage for each bound attribute and calls ":"\r\n            此方法验证了每个界属性的属性用法并调用\r\n","\r\n            Labels reachable from within this frame without invoking its finally. \r\n            null if there are no such labels.\r\n            ":"\r\n            可从此框架内到达的标签，而无需最终调用。\r\n            如果没有此类标签，则为空。\r\n            \r\n","\r\n            A temporary variable that is holding the computed input at this branch.\r\n            ":"\r\n            一个临时变量，该变量在该分支上保留了计算的输入。\r\n            \r\n","\r\n             The rewriter for removing lambda expressions from method bodies and introducing closure classes\r\n             as containers for captured variables along the lines of the example in section 6.5.3 of the\r\n             C# language specification.\r\n             \r\n             The entry point is the public method ":"\r\n             从方法主体中删除lambda表达式并引入关闭类的重写者\r\n             作为沿该示例的捕获变量的容器，在第6.5.3节中\r\n             C＃语言规范。\r\n             \r\n             入口点是公共方法\r\n","\r\n            Implements visitor pattern. \r\n            ":"\r\n            实施访客模式。\r\n            \r\n","Inference of tuple element names was added in C# 7.1":"C＃7.1中添加了元组元素名称的推断\r\n","Namespace conflicts with imported type":"名称空间与导入类型冲突\r\n"," as its parent.\r\n            ":" 作为父母。\r\n            \r\n","\r\n            Gets the locations where this symbol was originally defined, either in source or\r\n            metadata. Some symbols (for example, partial classes) may be defined in more than one\r\n            location.\r\n            ":"\r\n            获取最初定义此符号的位置，无论是在源或\r\n            元数据。某些符号（例如，部分类）可以在多个以上定义\r\n            地点。\r\n            \r\n","\r\n            Conversion applied to the result of the user-defined conversion.\r\n            ":"\r\n            转换应用于用户定义的转换结果。\r\n            \r\n","\r\n            Produces a syntax tree by parsing the source text lazily. The syntax tree is realized when\r\n            ":"\r\n            通过懒洋洋地解析源文本来产生语法树。语法树在\r\n            \r\n","Class which represents the syntax node for implicit object creation expression.":"代表隐式对象创建表达式的语法节点的类。\r\n","\r\n              Looks up a localized string similar to The specified version string does not conform to the required format - major.minor.build.revision.\r\n            ":"\r\n              查找类似于指定版本字符串的本地化字符串不符合所需的格式-Major.minor.build.revision。\r\n            \r\n","\r\n            Returns the syntax node that declares the variable.\r\n            ":"\r\n            返回声明变量的语法节点。\r\n            \r\n","\r\n            Parse a sequence of C# language tokens.\r\n            ":"\r\n            解析一系列C＃语言令牌。\r\n            \r\n","Creates a new TypeArgumentListSyntax instance.":"创建一个新的TypeArgumentListsyntax实例。\r\n","\r\n            Return true if the method parameters match the parameters of the\r\n            event accessor, including the value parameter.\r\n            ":"\r\n            如果方法参数匹配该参数，则返回true\r\n            事件访问者，包括值参数。\r\n            \r\n","partial types":"部分类型\r\n","\r\n              Looks up a localized string similar to Parentheses are required around the switch governing expression..\r\n            ":"\r\n              查找类似于括号的局部字符串，需要在Switch Governing表达式周围。\r\n            \r\n","Member definition, statement, or end-of-file expected":"会员定义，声明或文件终止预期\r\n","A query body must end with a select clause or a group clause":"查询主体必须以选择子句或组子句结尾\r\n","\r\n            In the debugger, one can take the address of a managed object.\r\n            ":"\r\n            在调试器中，可以采用托管对象的地址。\r\n            \r\n","\r\n            Lowers a lock statement to a try-finally block that calls Monitor.Enter and Monitor.Exit\r\n            before and after the body, respectively.\r\n            ":"\r\n            将lock语句降低到调用Monitor的try-finally块。入并进行监控。出口；出口\r\n            体之前和之后分别。\r\n            \r\n","\r\n            The compiler-generated implementation type for each fixed-size buffer.\r\n            ":"\r\n            每个固定尺寸缓冲区的编译器生成的实现类型。\r\n            \r\n","\r\n            Print compiler logo\r\n            ":"\r\n            打印编译器徽标\r\n            \r\n","\r\n            This method does the following set of operations in the specified order:\r\n            (1) GetAttributesToBind: Merge attributes from the given attributesSyntaxLists and filter out attributes by attribute target.\r\n            (2) BindAttributeTypes: Bind all the attribute types to enable early decode of certain well-known attributes by type.\r\n            (3) EarlyDecodeWellKnownAttributes: Perform early decoding of certain well-known attributes that could be queried by the binder in subsequent steps.\r\n                (NOTE: This step has the side effect of updating the symbol state based on the data extracted from well known attributes).\r\n            (4) GetAttributes: Bind the attributes (attribute arguments and constructor) using bound attribute types.\r\n            (5) DecodeWellKnownAttributes: Decode and validate bound well known attributes.\r\n                (NOTE: This step has the side effect of updating the symbol state based on the data extracted from well known attributes).\r\n            (6) StoreBoundAttributesAndDoPostValidation:\r\n                (a) Store the bound attributes in lazyCustomAttributes in a thread safe manner.\r\n                (b) Perform some additional post attribute validations, such as\r\n                    1) Duplicate attributes, attribute usage target validation, etc.\r\n                    2) Post validation for attributes dependent on other attributes\r\n                    These validations cannot be performed prior to step 6(a) as we might need to\r\n                    perform a GetAttributes() call on a symbol which can introduce a cycle in attribute binding.\r\n                    We avoid this cycle by performing such validations in PostDecodeWellKnownAttributes after lazyCustomAttributes have been set.\r\n                NOTE: PostDecodeWellKnownAttributes SHOULD NOT change the symbol state.\r\n            ":"\r\n            该方法按指定顺序进行以下操作集：\r\n            （1）getAttributestobind：从给定的属性列表列表中合并属性，并通过属性目标过滤属性。\r\n            （2）BindAttributeTypes：绑定所有属性类型，以逐步启用某些知名属性的早期解码。\r\n            （3）早期decodewell已知属性：对某些已知属性进行早期解码，这些属性可以在随后的步骤中被粘合剂查询。\r\n                （注意：此步骤具有根据从知名属性提取的数据更新符号状态的副作用。\r\n            （4）getAttributes：使用绑定属性类型绑定属性（属性参数和构造函数）。\r\n            （5）解码器已知问题：解码和验证绑定的众所周知的属性。\r\n                （注意：此步骤具有根据从知名属性提取的数据更新符号状态的副作用。\r\n            （6）StoreBoundAttributesAndDopostValidation：\r\n                （a）以线程安全的方式将绑定属性存储在懒惰的属性中。\r\n                （b）执行一些其他帖子属性验证，例如\r\n                    1）重复属性，属性用法目标验证等。\r\n                    2）依赖于其他属性的属性的发布验证\r\n                    这些验证不能在步骤6（a）之前执行，因为我们可能需要\r\n                    执行getAttributes（）调用符号，该符号可以在属性绑定中引入周期。\r\n                    我们通过在设置了懒惰的托属术后，在decodewellnownnowntertributes中执行此类验证来避免此周期。\r\n                注意：postdecodeWellKonnoateTributes不应更改符号状态。\r\n            \r\n","\r\n            If (we believe) we know which symbol the user intended, then we should retain that information\r\n            in the corresponding error symbol - it can be useful for deciding how to handle the error.\r\n            For example, we might want to know whether (we believe) the error type was supposed to be an\r\n            interface, so that we can put it in a derived type's interface list, rather than in the base\r\n            type slot.\r\n            \r\n            Sometimes we will return the original definition of the intended symbol.  For example, if we see \r\n            ":"\r\n            如果（我们相信）我们知道用户预期的符号，那么我们应该保留该信息\r\n            在相应的错误符号中 - 它对于确定如何处理错误可能很有用。\r\n            例如，我们可能想知道（我们相信）错误类型是否应该是\r\n            接口，以便我们可以将其放在派生类型的接口列表中，而不是在基础上\r\n            类型插槽。\r\n            \r\n            有时我们会返回预期符号的原始定义。例如，如果我们看到\r\n            \r\n","'{0}' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.":"'{0}'不是此声明的有效属性位置。此声明的有效属性位置为“ {1}”。该块中的所有属性将被忽略。\r\n","Creates a new ImplicitArrayCreationExpressionSyntax instance.":"创建一个新的intimitarrayCreationexpressyntax实例。\r\n","Do not directly call your base type Finalize method. It is called automatically from your destructor.":"不要直接调用您的基本类型最终确定方法。它是从您的灾难中自动称为。\r\n","\r\n              Looks up a localized string similar to Using '{0}' as a ref or out value or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class.\r\n            ":"\r\n              查找类似于使用“ {0}”作为ref或out值的本地化字符串或拿走其地址可能会导致运行时异常，因为它是逐个参考类的字段。\r\n            \r\n","\r\n            Represents MDARRAY - multi-dimensional array (possibly of rank 1)\r\n            ":"\r\n            代表mdarray-多维数组（可能是等级1）\r\n            \r\n","\r\n              Looks up a localized string similar to The entry point of the program is global script code; ignoring entry point.\r\n            ":"\r\n              查找类似于程序的输入点的本地化字符串是全局脚本代码。忽略入口点。\r\n            \r\n","\r\n            Bound type if syntax binds to a type in the current context and\r\n            null if syntax binds to \"var\" keyword in the current context.\r\n            ":"\r\n            如果语法在当前上下文中与类型结合，则绑定类型\r\n            null如果语法在当前上下文中与“ var”关键字结合。\r\n            \r\n","\r\n            Variable slots are allocated to local variables sequentially and never reused.  This is\r\n            the index of the next slot number to use.\r\n            ":"\r\n            可变插槽依次分配给局部变量，并且永远不会重复使用。这是\r\n            要使用的下一个插槽号的索引。\r\n            \r\n","\r\n            Gets a SyntaxToken that represents the open braces preceding the switch sections.\r\n            ":"\r\n            获取一个代表开关部分前面的开放括号的语法。\r\n            \r\n","Cannot link resource files when building a module":"构建模块时无法链接资源文件\r\n","\r\n            Returns false because label can't be overridden.\r\n            ":"\r\n            返回false，因为标签不能被覆盖。\r\n            \r\n","Creates a new ConstantPatternSyntax instance.":"创建一个新的ConstantPatternsyntax实例。\r\n"," implementation that represents the inferred signature of a\r\n            lambda expression or method group. This is implemented as a ":" 代表推断的签名的实施\r\n            lambda表达或方法组。这是作为一个\r\n","The formatting options to apply.  If null is passed, ":"要应用的格式选项。如果通过了无效，\r\n","Reference to an implicitly-typed out variable '{0}' is not permitted in the same argument list.":"在同一参数列表中不允许引用隐式输出变量'{0}'。\r\n","s. Usually, this class should be \r\n            the root of the chain in order to ensure sound debugging experience for the instrumented code.\r\n            In other words, sequence points are typically applied after all other changes.\r\n            ":"s。通常，这堂课应该是\r\n            链条的根源是为了确保仪器代码的声音调试体验。\r\n            换句话说，通常在所有其他更改之后都应用序列点。\r\n            \r\n","\r\n            Pre C# 7.2 back-compat overload, which simply calls the replacement method ":"\r\n            PRE C＃7.2背部组件过载，仅调用替换方法\r\n","TypedConstantKind for the attribute parameter type.":"属性参数类型的TypedConstantkind。\r\n","\r\n            Represents an anonymous type 'GetHashCode' method.\r\n            ":"\r\n            代表匿名类型的“ GethashCode”方法。\r\n            \r\n","\r\n            Accumulate diagnostics related to the variance safety of an interface property.\r\n            ":"\r\n            积累与接口属性的方差安全性有关的诊断。\r\n            \r\n","Cannot embed interop types from assembly '{0}' because it is missing either the '{1}' attribute or the '{2}' attribute.":"无法从汇编'{0}'嵌入Interop类型，因为它缺少'{1}'属性或'{2}'属性。\r\n","\r\n            Certain (struct) types are known by the compiler to be immutable.  In these cases calling a method on\r\n            the type is known (by flow analysis) not to write the receiver.\r\n            ":"\r\n            编译器已知某些（结构）类型是不变的。在这些情况下，调用方法\r\n            该类型已知（通过流量分析）不编写接收器。\r\n            \r\n",">, and deserialized to a byte array.\r\n            ":">，并应将字节阵列序列化。\r\n            \r\n","\r\n            Given that the test ":"\r\n            鉴于测试\r\n","\r\n              Looks up a localized string similar to Invalid file section alignment '{0}'.\r\n            ":"\r\n              查找类似于无效的文件部分对齐'{0}'的本地化字符串。\r\n            \r\n","Type '{0}' in interface list is not an interface":"在接口列表中键入'{0}'不是接口\r\n","Unrecognized #pragma directive":"无法识别的#pragma指令\r\n","\r\n            This pass detects and reports diagnostics that do not affect lambda convertibility.\r\n            This part of the partial class focuses on expression and operator warnings.\r\n            ":"\r\n            此通行证检测和报告不影响Lambda可转换性的诊断。\r\n            部分类别的这一部分着重于表达和操作员警告。\r\n            \r\n","True if the compound assignment is a dynamic operation.":"如果复合分配是动态操作，则为正确。\r\n","\r\n            This method finds an attribute by metadata name and signature. The algorithm for signature matching is similar to the one\r\n            in Module.GetTargetAttributeSignatureIndex. Note, the signature matching is limited to primitive types\r\n            and System.Type.  It will not match an arbitrary signature but it is sufficient to match the signatures of the current set of\r\n            well known attributes.\r\n            ":"\r\n            此方法通过元数据名称和签名找到一个属性。签名匹配的算法类似于\r\n            在模块中。注意，签名匹配仅限于原始类型\r\n            和system.type。它将不匹配任意签名，但足以匹配当前集合的签名\r\n            众所周知的属性。\r\n            \r\n","\r\n            Optimized locations of lambdas. \r\n            \r\n            Lambda does not need to be placed in a frame that corresponds to its lexical scope if lambda does not reference any local state in that scope.\r\n            It is advantageous to place lambdas higher in the scope tree, ideally in the innermost scope of all scopes that contain variables captured by a given lambda.\r\n            Doing so reduces indirections needed when captured locals are accessed. For example locals from the innermost scope can be accessed with no indirection at all.\r\n            \r\n            NOTE: This information is computed in addition to the regular analysis of the tree and only needed for rewriting.\r\n            If someone only needs diagnostics or information about captures, this information is not necessary.\r\n            ":"\r\n            优化的Lambdas位置。\r\n            \r\n            如果Lambda不参考该范围中的任何局部状态，则不需要将Lambda放在与其词汇范围相对应的框架中。\r\n            将lambdas放在范围树中是有利的，理想情况下，在所有范围的最内部范围内包含由给定lambda捕获的变量的范围。\r\n            当访问当地人时，这样做会减少所需的间接。例如，可以完全没有间接访问最内向范围的当地人。\r\n            \r\n            注意：除了对树的常规分析外，还需要计算此信息，并且仅需要重写。\r\n            如果某人只需要诊断或有关捕获的信息，则无需此信息。\r\n            \r\n","\r\n            Thrown by the bound node factory when there is a failure to synthesize code.\r\n            An appropriate diagnostic is included that should be reported.  Currently\r\n            the only diagnostic handled through this mechanism is a missing special/well-known\r\n            member.\r\n            ":"当没有综合代码的情况下，被绑定的节点工厂抛出。\r\n            包括适当的诊断，应报告。目前\r\n            通过这种机制处理的唯一诊断是缺失的特殊/知名度\r\n            成员。\r\n            \r\n","\r\n            Base class for all parameters that are emitted.\r\n            ":"\r\n            所有发射参数的基类。\r\n            \r\n","User-defined operators cannot return void":"用户定义的操作员无法返回空隙\r\n","\r\n            Indicates whether this variable is nested inside another tracked variable.\r\n            For instance, if a field `x` of a struct is a tracked variable, the symbol is not sufficient\r\n            to uniquely determine which field is being tracked. The containing slot(s) would\r\n            identify which tracked variable the field `x` is part of.\r\n            ":"\r\n            指示此变量是否嵌套在另一个跟踪变量中。\r\n            例如，如果结构的字段`x`是一个跟踪变量，则该符号不够\r\n            独特地确定正在跟踪哪个字段。包含的插槽将\r\n            确定哪个跟踪变量字段`x`是的一部分。\r\n            \r\n","\r\n            Gets flattened type arguments of the underlying type\r\n            which correspond to the types of the tuple elements left-to-right\r\n            ":"\r\n            得到基础类型的扁平类型参数\r\n            对应于从左到右的元组元素的类型\r\n            \r\n","\r\n            When indexer overload resolution fails, we have two options:\r\n              1) Create a BoundBadExpression with the candidates as child nodes;\r\n              2) Create a BoundIndexerAccess with the error flag set.\r\n              \r\n            Option 2 is preferable, because it retains information about the arguments\r\n            (names, ref kind, etc), and results in better output from flow analysis.\r\n            However, we can't create a BoundIndexerAccess with a null indexer symbol,\r\n            so we create an ErrorPropertySymbol to fill the gap.\r\n            ":"\r\n            当索引器过载分辨率失败时，我们有两个选择：\r\n              1）与候选人作为子节点创建一个界限；\r\n              2）使用错误标志集创建一个boundindexeraccess。\r\n              \r\n            选项2是可取的，因为它保留有关参数的信息\r\n            （名称，ref类等），并从流量分析中获得更好的输出。\r\n            但是，我们不能使用带有空索引器符号的boundindexeraccess，\r\n            因此，我们创建一个错误的Propopertysymbol来填补空白。\r\n            \r\n","\r\n              Looks up a localized string similar to Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead..\r\n            ":"\r\n              查找类似于不使用'system.runtime.compilerservices.fixedbuffer'属性的本地化字符串。改用“固定”字段修饰符。\r\n            \r\n","The expression within the associated SyntaxTree to analyze.":"相关语法中的表达式要分析。\r\n","A string representation of an object of primitive type (or null if the type is not supported).":"原始类型对象的字符串表示（如果不支持该类型，则为null）。\r\n","\r\n            Does this value set contain no values?\r\n            ":"\r\n            此值集是否包含不包含值？\r\n            \r\n","Debug entry point must be a definition of a method declared in the current compilation.":"调试入口点必须是当前汇编中声明的方法的定义。\r\n","Both partial method declarations must be unsafe or neither may be unsafe":"两种部分方法声明都必须不安全，或者都不是不安全的\r\n","Non-null binder for the scope around the member.":"成员周围的范围的非无效粘合剂。\r\n","\r\n              Looks up a localized string similar to Cannot use local variable '{0}' before it is declared. The declaration of the local variable hides the field '{1}'..\r\n            ":"\r\n              在声明之前，查找类似于局部变量'{0}'的本地化字符串。本地变量的声明隐藏了字段'{1}'..\r\n            \r\n","CLSCompliant attribute has no meaning when applied to return types":"当应用于返回类型时，clscompliant属性没有意义\r\n",", in which case it is deemed to have\r\n            succeeded after being evaluated.\r\n            ":"，在这种情况下，它被认为有\r\n            经过评估后成功。\r\n            \r\n","The expression to return type of.":"返回类型的表达式。\r\n","Cannot pass argument with dynamic type to params parameter '{0}' of local function '{1}'.":"无法将动态类型传递给参数参数'{0}'的本地函数'{1}'。\r\n","\r\n              Looks up a localized string similar to Option '{0}' must be an absolute path..\r\n            ":"\r\n              查找类似于选项'{0}'的本地化字符串必须是绝对路径。\r\n            \r\n","\r\n            Is the type \"withinType\" nested within the original type \"originalContainingType\".\r\n            ":"\r\n            是嵌套在原始类型“原始范围”中的类型“ with Intype”。\r\n            \r\n","\r\n            Imports from all previous submissions.\r\n            ":"\r\n            从所有以前的提交中进口。\r\n            \r\n","\r\n             An async-iterator state machine has a flag indicating \"dispose mode\".\r\n             We enter dispose mode by calling DisposeAsync() when the state machine is paused on a `yield return`.\r\n             DisposeAsync() will resume execution of the state machine from that state (using existing dispatch mechanism\r\n             to restore execution from a given state, without executing other code to get there).\r\n            \r\n             From there, we don't want normal code flow:\r\n             - from `yield return` within a try, we'll jump to its `finally` if it has one (or method exit)\r\n             - after finishing a `finally` within a `finally`, we'll continue\r\n             - after finishing a `finally` within a `try`, jump to the its `finally` if it has one (or method exit)\r\n            \r\n             Some `finally` clauses may have already been rewritten and extracted to a plain block (":"\r\n             异步 - 列表状态机具有指示“处置模式”的标志。\r\n             当状态机在“收益率返回”上暂停时，我们通过调用disposeasync（）进入处置模式。\r\n             disposeasync（）将恢复该状态的状态计算机执行（使用现有的调度机制\r\n             从给定状态恢复执行，而无需执行其他代码到达那里）。\r\n            \r\n             从那里，我们不需要普通代码流：\r\n              - 从尝试中的“收益率返回”，如果它具有一个（或方法退出），我们将跳到它的``最终''\r\n              - 在最后一个``最后''结束后，我们将继续\r\n              - 在``尝试''中完成了``最终''之后，如果它具有一个（或方法退出）\r\n            \r\n             一些最终的条款可能已经重写并提取到一个普通的块（\r\n",", or \r\n            ":"， 或者\r\n            \r\n","\r\n            If the operand is definitely assigned, we may want to perform a read (in addition to\r\n            a write) so that the operand can show up as ReadInside/DataFlowsIn.\r\n            ":"\r\n            如果操作数肯定是分配的，我们可能需要执行读取（除了\r\n            一个写入），以便操作数可以显示为ReadInside/dataflowsin。\r\n            \r\n","\r\n            This portion of the binder converts a ":"\r\n            粘合剂的这一部分转换\r\n",".\r\n            \r\n             Nontrivial implementation is required for DataFlowsOutWalker or any flow analysis pass\r\n             that \"tracks unassignments\" like the nullable walker. The result should be a state, for\r\n             each variable, that is the strongest result possible (i.e. definitely assigned for the\r\n             data flow passes, or not null for the nullable analysis).\r\n             operation.\r\n             ":"。\r\n            \r\n             DataFlowsOutWalker或任何流程分析通行证需要非平凡的实现\r\n             像无效的步行者一样，“跟踪非分配”。结果应该是一个状态，因为\r\n             每个变量，这是最强大的结果（即绝对分配给\r\n             数据流通过或不为无效分析）。\r\n             手术。\r\n             \r\n","\r\n            Return the nearest type parameter with the given name in\r\n            this type or any enclosing type.\r\n            ":"\r\n            返回带有给定名称的最近类型参数\r\n            此类型或任何封闭类型。\r\n            \r\n",", or -1 if not initialized.\r\n            ":"，或-1如果不初始化。\r\n            \r\n","\r\n            Represents an anonymous type template's property symbol.\r\n            ":"\r\n            代表匿名类型模板的属性符号。\r\n            \r\n","Where diagnostics will be reported.":"将在哪里报告诊断。\r\n","Given operation block does not belong to the current analysis context.":"给定的操作块不属于当前分析上下文。\r\n","\r\n            This is the absolute \"bottom\" state of the data flow lattice. C# does not specify a\r\n            difference between unreachable states, so there can only be one. This is the state used\r\n            for unreachable code, like statements after a \"return\" or \"throw\" statement.\r\n            ":"\r\n            这是数据流晶格的绝对“底部”状态。 C＃不指定\r\n            无法达到的状态之间的区别，因此只能有一个。这是使用的状态\r\n            对于无法实现的代码，例如“返回”或“投掷”语句之后的语句。\r\n            \r\n","\r\n            NOTE:   We have no GetDeclaredSymbol overloads for following subtypes of MemberDeclarationSyntax:\r\n            NOTE:   (1) GlobalStatementSyntax as they don't declare any symbols.\r\n            NOTE:   (2) IncompleteMemberSyntax as there are no symbols for incomplete members.\r\n            NOTE:   (3) BaseFieldDeclarationSyntax or its subtypes as these declarations can contain multiple variable declarators.\r\n            NOTE:       GetDeclaredSymbol should be called on the variable declarators directly.\r\n            ":"\r\n            注意：我们没有getDeclaredSymbol的超载，用于遵循会员declarationsyntax的子类型：\r\n            注意：（1）GlobalStatementSyntax，因为它们没有声明任何符号。\r\n            注意：（2）由于不完整的成员没有符号。\r\n            注意：（3）basefielddeclarationsyntax或其子类型，因为这些声明可以包含多个变量声明器。\r\n            注意：应直接在变量声明器上调用GetDeclaredSymbol。\r\n            \r\n","\r\n              Looks up a localized string similar to Partial declarations of '{0}' have inconsistent constraints for type parameter '{1}'.\r\n            ":"\r\n              查找类似于“ {0}”的部分声明类似的本地化字符串，对于类型参数'{1}'的约束不一致。\r\n            \r\n","\r\n            Rewrites a BoundBinaryOperator composed of interpolated strings (either converted or unconverted) iteratively, without\r\n            recursion on the left side of the tree. Nodes of the tree are rewritten in a depth-first post-order fashion, meaning\r\n            left, then right, then parent.\r\n            ":"\r\n            重写一个由插值字符串（转换或不转化）组成的边界操作器，而无需迭代\r\n            树的左侧递归。树的节点以深度优先的后订单方式重写，含义\r\n            左，然后向右，然后是父母。\r\n            \r\n","\r\n              Looks up a localized string similar to Type '{0}' exported from module '{1}' conflicts with type declared in primary module of this assembly..\r\n            ":"\r\n              查找类似于从模块'{1}'导出的类型“ {0}”类型的本地化字符串与此汇编主模块中声明的类型冲突。\r\n            \r\n","A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a System.Runtime.CompilerServices.RuntimeWrappedException.":"先前的捕获子句已经捕获所有异常。所有不删除的抛出都将包裹在system.runtime.compilerservices.runtimewrappedexception中。\r\n","A single-line comment may not be used in an interpolated string.":"单行注释不得在插值字符串中使用。\r\n","'{0}': cannot change access modifiers when overriding '{1}' inherited member '{2}'":"'{0}'：当覆盖'{1}'继承成员'{2}'时，无法更改访问修饰符\r\n","\r\n            Like SubstTypes, but for NamedTypeSymbols.\r\n            ":"\r\n            像替代类型一样，但用于命名typeymbols。\r\n            \r\n","Creates a new BadDirectiveTriviaSyntax instance.":"创建一个新的BadDirectiviviaSyntax实例。\r\n","A list of trivia immediately preceding the token.":"在令牌之前的琐事列表。\r\n","\r\n            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;\r\n            int lastElement = someArray[^1]; // lastElement = 5\r\n            ":"\r\n            int [] someArray = new int [5] {1，2，3，4，5};\r\n            int lastElement = someArray [^1]; // lastElement = 5\r\n            \r\n","When boundRHS is a tuple literal, fix it up by inferring its types.":"当Bougnrhs是元组时，请通过推断其类型来修复它。\r\n",".\r\n            Try keeping structure of both functions similar to simplify this task. The split was made to \r\n            reduce the stack usage during recursive parsing.\r\n            ":"。\r\n            尝试保持两个功能的结构，类似于简化此任务。分裂是\r\n            减少递归解析过程中的堆栈使用情况。\r\n            \r\n","\r\n            Visit all the functions and return true when the ":"\r\n            访问所有功能，并在\r\n","The best overloaded Add method for the collection initializer element is obsolete":"收集初始元素元素的最佳超载添加方法是过时的\r\n","\r\n              Looks up a localized string similar to Tuple types used as operands of an == or != operator must have matching cardinalities. But this operator has tuple types of cardinality {0} on the left and {1} on the right..\r\n            ":"\r\n              查找类似于用作AN ==或！=操作员的操作数的元组类型类型的本地化字符串，必须具有匹配的基础性。但是该操作员在左侧具有元组类型的心脏{0}，右侧有{1}。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot convert method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?.\r\n            ":"\r\n              查找类似于无法将方法组'{0}'转换为非贵族类型'{1}'的本地化字符串。您是否打算调用该方法？\r\n            \r\n","Creates a new PostfixUnaryExpressionSyntax instance.":"创建一个新的fostixunary expressionsyntax实例。\r\n","Used to retrieve binder.":"用于检索粘合剂。\r\n","\r\n              Looks up a localized string similar to Keyword 'void' cannot be used in this context.\r\n            ":"\r\n              在此上下文中查找类似于关键字“ void”的本地化字符串。\r\n            \r\n","\r\n            Visit an expression. If an explicit target type is provided, the expression is converted\r\n            to that type. This method should be called whenever an expression may contain\r\n            an implicit conversion, even if that conversion was omitted from the bound tree,\r\n            so the conversion can be re-classified with nullability.\r\n            ":"\r\n            参观表情。如果提供了明确的目标类型，则将转换该表达式\r\n            到那个类型。每当表达式包含时，都应调用此方法\r\n            即使从绑定的树省略了这种转换，也是隐性的转换，\r\n            因此，可以通过无效性重新分类转换。\r\n            \r\n","'{0}' has no base class and cannot call a base constructor":"'{0}'没有基类，无法调用基本构造函数\r\n","\r\n            Given a catch declaration, get the symbol for the exception variable\r\n            ":"\r\n            给定捕获声明，获取异常变量的符号\r\n            \r\n","An object, string, or class type expected":"预期的对象，字符串或类类型\r\n","\r\n            Represents an anonymous type 'template' which is a generic type to be used for all \r\n            anonymous type having the same structure, i.e. the same number of fields and field names.\r\n            ":"\r\n            代表匿名类型的“模板”，这是用于所有的通用类型\r\n            具有相同结构的匿名类型，即相同数量的字段和字段名称。\r\n            \r\n","\r\n            Maybe null (type may be not nullable).\r\n            ":"\r\n            也许null（类型可能不可为空）。\r\n            \r\n","The as operator must be used with a reference type or nullable type ('{0}' is a non-nullable value type)":"AS运算符必须与参考类型或无效类型一起使用（'{0}'是不可删除的值类型）\r\n","\r\n              Looks up a localized string similar to Implicitly-typed variables must be initialized.\r\n            ":"\r\n              必须初始化类似于隐型变量的本地化字符串。\r\n            \r\n","The type on which we are looking for a declared implementation of the interface member.":"我们正在寻找已声明的接口成员实现的类型。\r\n","Base class '{0}' must come before any interfaces":"基类'{0}'必须在任何接口之前出现\r\n","\r\n              Looks up a localized string similar to XML comment has syntactically incorrect cref attribute '{0}'.\r\n            ":"\r\n              查找类似于XML注释的本地化字符串在句法上不正确cref属性'{0}'。\r\n            \r\n","\r\n              Looks up a localized string similar to The property or indexer '{0}' cannot be used in this context because it lacks the get accessor.\r\n            ":"\r\n              在此上下文中查找类似于属性或索引器'{0}'的本地化字符串，因为它缺少GET登录器。\r\n            \r\n","\r\n            Given an extern alias declaration get the corresponding symbol for the alias that was introduced.\r\n            ":"\r\n            鉴于外部别名声明获得了引入的别名的相应符号。\r\n            \r\n","Class which represents the syntax node for postfix unary expression.":"代表后缀一般表达式的语法节点的类。\r\n","\r\n            Gets symbol information about a syntax node. This is overridden by various specializations of SemanticModel.\r\n            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named\r\n            argument nodes have been handled.\r\n            ":"\r\n            获取有关语法节点的符号信息。 Semanticmodel的各种专业都覆盖了这一点。\r\n            它可以假设checksyntaxnode和cangetSemanticinfo已经被调用，以及\r\n            论证节点已被处理。\r\n            \r\n","\r\n             a (":"\r\n             一个 （\r\n","\r\n            Return the intersection of this value set with another. Both must have been created with the same ":"\r\n            返回此值集的交叉点与另一个值。两者都必须以相同的方式创建\r\n","\r\n              Looks up a localized string similar to Cannot link resource files when building a module.\r\n            ":"\r\n              查找类似于构建模块时无法链接资源文件的本地化字符串。\r\n            \r\n","\r\n            Gets a SyntaxToken that represents the close parenthesis following the switch governing expression.\r\n            ":"\r\n            获取一个SyntaxToken，该SyntaxToken表示switch管理表达式后面的近括号。\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability of reference types in type of parameter '{0}' doesn't match implemented member '{1}'..\r\n            ":"\r\n              在参数类型'{0}'类型中查找类似于参考类型的无效性类似的本地化字符串，不匹配实现的成员'{1}'..\r\n            \r\n","\r\n            Count the number of custom modifiers in/on the type\r\n            and parameters (for indexers) of the specified property.\r\n            ":"\r\n            计算该类型/类型中的自定义修饰符的数量\r\n            指定属性的参数（对于索引器）。\r\n            \r\n","\r\n            Creates an empty list of tokens.\r\n            ":"\r\n            创建一个空的令牌列表。\r\n            \r\n","builder to fill in CollectionType.":"建造者填充收藏品。\r\n","\r\n            True if the type has declarative security information (HasSecurity flags).\r\n            ":"\r\n            如果类型具有声明性安全信息（Hassecurity标志），则为正确。\r\n            \r\n","Method '{0}' cannot implement interface accessor '{1}' for type '{2}'. Use an explicit interface implementation.":"方法'{0}'无法实现类型'{2}'的Interface consector'{1}'。使用显式接口实现。\r\n","The pathmap option was incorrectly formatted.":"路径示意图的格式不正确。\r\n","byref locals and returns":"Byref当地人和返回\r\n","The property parameter doesn't have a name in metadata,\r\n            so this is the handle of a corresponding accessor parameter, if there is one,\r\n            or of the ParamInfo passed in, otherwise).":"属性参数在元数据中没有名称，\r\n            因此，这是相应的访问者参数的句柄，如果有一个，则\r\n            或paraninfo传递的内容，否则）。\r\n"," is case sensitive.\r\n            ":" 是案例敏感的。\r\n            \r\n","Type defines operator == or operator != but does not override Object.GetHashCode()":"键入定义操作员==或operator！=但不覆盖object.gethashcode（）\r\n","New features for partial methods":"部分方法的新功能\r\n","\r\n             Returns whether this method is using CLI VARARG calling convention. This is used for C-style variable\r\n             argument lists. This is used extremely rarely in C# code and is represented using the undocumented \"__arglist\" keyword.\r\n            \r\n             Note that methods with \"params\" on the last parameter are indicated with the \"IsParams\" property on ParameterSymbol, and\r\n             are not represented with this property.\r\n             ":"\r\n             返回此方法是否使用CLI VARARG调用约定。这用于C风格变量\r\n             参数列表。这很少在C＃代码中使用，并且使用无证件的“ __arglist”关键字表示。\r\n            \r\n             请注意，最后一个参数上带有“参数”的方法用parametersymbol上的“ isparams”属性表示，并且\r\n             没有代表此属性。\r\n             \r\n","Invalid option '{0}' for /langversion. Use '/langversion:?' to list supported values.":"无效选项'{0}'for /langversion。使用'/langversion：？'列出支持的值。\r\n"," modifier. Does not return true for\r\n            members declared as abstract or override.\r\n            ":" 修饰符。不返回true\r\n            成员宣布为抽象或覆盖。\r\n            \r\n","\r\n            Bind the given expression speculatively at the given position, and return back\r\n            the resulting bound node. May return null in some error cases.\r\n            ":"在给定位置绑定给定表达式，然后返回\r\n            结果结合节点。在某些错误情况下可能会返回null。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot assign {0} to a range variable.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法分配{0}到范围变量。\r\n            \r\n","\r\n            Implicit and explicit numeric conversions are described in sections 6.1.2 and 6.2.1 of the C# language specification.\r\n            ":"\r\n            隐式和显式数字转换在C＃语言规范的第6.1.2和6.2.1节中进行了描述。\r\n            \r\n","\r\n            Returns true if the conversion is an implicit null literal conversion.\r\n            ":"\r\n            如果转换是隐式零字面的转换，则返回true。\r\n            \r\n","Member '{0}' cannot be used in this attribute.":"成员'{0}'在此属性中不能使用。\r\n","\r\n            The candidate member was rejected because a required parameter had no corresponding argument.\r\n            ":"\r\n            候选人成员被拒绝，因为所需的参数没有相应的参数。\r\n            \r\n","\r\n            Search through the members of a given type symbol to find the method that matches a particular\r\n            signature.\r\n            ":"\r\n            浏览给定类型符号的成员以查找与特定的方法匹配的方法\r\n            签名。\r\n            \r\n",".\r\n            If a type parameter does not have constraints, the corresponding entry in the array is null.\r\n            ":"。\r\n            如果类型参数没有约束，则数组中的相应条目为空。\r\n            \r\n","\r\n            Represents an anonymous type 'Equals' method.\r\n            ":"\r\n            代表匿名类型的“等式”方法。\r\n            \r\n"," (as we'd do for ":" （就像我们要做的那样\r\n","SyntaxToken representing the this keyword.":"Syntaxtoken表示此关键字。\r\n","Reference to '{0}' netmodule missing.":"引用“ {0}” NetModule缺少。\r\n","Cannot initialize a by-value variable with a reference":"无法用参考初始化副价值变量\r\n","\r\n            Visit all closures in all nested scopes and run the ":"\r\n            访问所有嵌套范围的所有封闭，并运行\r\n","\r\n            Given a syntax node of a tuple argument, get the tuple element symbol.\r\n            ":"\r\n            给定元组参数的语法节点，获取元组元素符号。\r\n            \r\n","Indicates whether the index is from the start or the end.":"指示该索引是从开始还是结束的。\r\n","SyntaxToken representing the calling convention identifier.":"Syntaxtkoken代表呼叫公约标识符。\r\n","The rewritten tree should include assignments of the original locals to the lifted proxies":"重写的树应包括原始当地人的作业到提起的代理\r\n","Invalid file section alignment '{0}'":"无效的文件部分对齐'{0}'\r\n","Nullability of reference types in return type doesn't match overridden member.":"返回类型中参考类型的无效性不匹配覆盖成员。\r\n","\r\n            Instrument the expression of a switch arm of a switch expression.\r\n            ":"\r\n            仪器开关表达式的开关臂的表达。\r\n            \r\n","A variable was declared with the same name as a variable in a base type. However, the new keyword was not used. This warning informs you that you should use new; the variable is declared as if new had been used in the declaration.":"声明一个变量，名称与基本类型中的变量相同。但是，未使用新关键字。此警告告诉您，您应该使用新的；该变量被声明，好像是在声明中使用的。\r\n"," contain an override of ":" 包含一个替代\r\n","\r\n              Looks up a localized string similar to Newline in constant.\r\n            ":"\r\n              查找与常数类似于newline的本地化字符串。\r\n            \r\n"," loop and a bug could prevent the loop from making progress,\r\n            this method can prevent the parsing from hanging.\r\n            Use as:\r\n                int tokenProgress = -1;\r\n                while (IsMakingProgress(ref tokenProgress))\r\n            It should be used as a guardrail, not as a crutch, so it asserts if no progress was made.\r\n            ":" 循环和错误可以防止循环取得进展，\r\n            这种方法可以防止解析悬挂。\r\n            用于：\r\n                int tokenProgress = -1;\r\n                而（ismakingprogress（ref tokenprogress））\r\n            它应该用作护栏，而不是拐杖，因此它断言是否没有取得进展。\r\n            \r\n","\r\n            Represents a namespace of a RetargetingModuleSymbol. Essentially this is a wrapper around \r\n            another NamespaceSymbol that is responsible for retargeting symbols from one assembly to another. \r\n            It can retarget symbols for multiple assemblies at the same time.\r\n            ":"\r\n            代表retargetingModulesymbol的名称空间。本质上，这是周围的包装纸\r\n            另一个命名paceSymbol是负责从一个组件重新定位符号到另一个组件的。\r\n            它可以同时重新定位多个组件。\r\n            \r\n","Creates a new TypeParameterSyntax instance.":"创建一个新的Typeparametersyntax实例。\r\n","\r\n            The compilation in which the analysis is taking place.  This is needed to determine which\r\n            conditional methods will be compiled and which will be omitted.\r\n            ":"\r\n            进行分析的汇编。这需要确定哪个\r\n            有条件的方法将被编译并省略。\r\n            \r\n"," needs to be called to compute this.\r\n            ":" 需要调用来计算这个。\r\n            \r\n"," instances or two ":" 一两个实例\r\n","\r\n              Looks up a localized string similar to Object can be disposed more than once.\r\n            ":"\r\n              查找类似于对象的局部字符串可以多次处置。\r\n            \r\n","/sourcelink switch is only supported when emitting PDB.":"/仅在发出PDB时支持Sourcelink开关。\r\n","\r\n              Looks up a localized string similar to Invalid parameter type 'void'.\r\n            ":"\r\n              查找类似于无效参数类型“ void”的本地化字符串。\r\n            \r\n","\r\n            Information decoded early from well-known custom attributes applied on a type.\r\n            ":"\r\n            信息从应用于类型的众所周知的自定义属性提早解码。\r\n            \r\n","\r\n            Creates a separated list of nodes from a sequence of nodes, synthesizing comma separators in between.\r\n            ":"\r\n            从一系列节点中创建一个分离的节点列表，并在之间合成逗号分离器。\r\n            \r\n","\r\n            Lookup a member name in a submission chain.\r\n            ":"\r\n            在提交链中查找成员名称。\r\n            \r\n","\r\n              Looks up a localized string similar to null propagating operator.\r\n            ":"\r\n              查找类似于Null Expaging Operator的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to The 'l' suffix is easily confused with the digit '1'.\r\n            ":"\r\n              查找类似于“ L”后缀的局部字符串很容易与Digit“ 1”相混淆。\r\n            \r\n","\r\n              Looks up a localized string similar to A static readonly field cannot be assigned to (except in a static constructor or a variable initializer).\r\n            ":"\r\n              查找类似于静态可读字段的本地化字符串，无法分配给（除了静态构造函数或可变初始化器中除外）。\r\n            \r\n","Tuple must contain at least two elements.":"元组必须至少包含两个元素。\r\n","\r\n            Must be called only after ":"\r\n            必须只在\r\n","Array type.":"数组类型。\r\n","\r\n            This instance is used to determine if a partial method implementation matches the definition,\r\n            including differences ignored by the runtime.\r\n            ":"\r\n            此实例用于确定部分方法实现是否匹配定义，\r\n            包括运行时忽略的差异。\r\n            \r\n","\r\n            Gets a SyntaxToken that represents the close parenthesis after the if statement's condition expression.\r\n            ":"\r\n            获取一个语法，该语法代表IF语句条件表达式之后的亲密括号。\r\n            \r\n","Creates a new TypeConstraintSyntax instance.":"创建一个新的Typectraintsyntax实例。\r\n","'{0}': explicit interface declaration can only be declared in a class, record, struct or interface":"'{0}'：显式接口声明只能在类，记录，结构或接口中声明\r\n","Shouldn't be null if ":"如果不应该为无效\r\n","\r\n            Generate a thread-safe accessor for a regular field-like event.\r\n            \r\n            DelegateType tmp0 = _event; //backing field\r\n            DelegateType tmp1;\r\n            DelegateType tmp2;\r\n            do {\r\n                tmp1 = tmp0;\r\n                tmp2 = (DelegateType)Delegate.Combine(tmp1, value); //Remove for -=\r\n                tmp0 = Interlocked.CompareExchange<DelegateType>(ref _event, tmp2, tmp1);\r\n            } while ((object)tmp0 != (object)tmp1);\r\n            \r\n            Note, if System.Threading.Interlocked.CompareExchange<T> is not available,\r\n            we emit the following code and mark the method Synchronized (unless it is a struct).\r\n            \r\n            _event = (DelegateType)Delegate.Combine(_event, value); //Remove for -=\r\n            \r\n            ":"\r\n            为常规现场事件生成线程安全登录器。\r\n            \r\n            授权型TMP0 = _EVENT; //支持字段\r\n            授权型TMP1;\r\n            授权型TMP2;\r\n            做 {\r\n                TMP1 = TMP0;\r\n                tmp2 =（delegateType）delegate.combine（tmp1，value）; //删除 -  =\r\n                tmp0 = Interlocked.compareexchange <delegatetype>（ref _Event，tmp2，tmp1）;\r\n            } while（（对象）tmp0！=（object）tmp1）;\r\n            \r\n            注意，如果system.threading.interlocked.compareexchange <t>不可用，\r\n            我们发射以下代码并标记该方法同步（除非是结构）。\r\n            \r\n            _event =（delegateType）delegate.combine（_Event，value）; //删除 -  =\r\n            \r\n            \r\n","\r\n              Looks up a localized string similar to The type '{0}' is defined in a module that has not been added. You must add the module '{1}'..\r\n            ":"\r\n              在尚未添加的模块中定义了类似于“ {0}”类型的本地化字符串。您必须添加模块'{1}'..\r\n            \r\n","\r\n            Rewriter for the BoundBinaryOperator parts fo the binary operator. Passed the callback parameter, the original binary operator, and\r\n            the rewritten left and right components.\r\n            ":"\r\n            二进制运算符的BoundBinaryOperator零件的重写器。通过回调参数，原始二进制操作员，\r\n            重写的左右组件。\r\n            \r\n","\r\n            Represents a custom modifier (modopt/modreq).\r\n            ":"\r\n            代表自定义修饰符（MODOPT/MODREQ）。\r\n            \r\n","\r\n              Looks up a localized string similar to Auto-implemented property '{0}' cannot be marked 'readonly' because it has a 'set' accessor..\r\n            ":"\r\n              查找类似于自动实现属性'{0}'的本地化字符串，因为它具有“ set'''''''{0}\r\n            \r\n","Nullability of reference types in value doesn't match target type.":"值中参考类型的无效性不匹配目标类型。\r\n","\r\n            Represents a compiler generated field or captured variable.\r\n            ":"\r\n            代表编译器生成的字段或捕获变量。\r\n            \r\n","\r\n              Looks up a localized string similar to Argument type is not CLS-compliant.\r\n            ":"\r\n              查找类似于参数类型的本地化字符串不符合CLS。\r\n            \r\n","\r\n            Gets a list of all the diagnostics associated with the token and any related trivia.\r\n            ":"\r\n            获取与令牌和任何相关琐事相关的所有诊断列表。\r\n            \r\n"," instead!\r\n            If used, a unit-test with a missing member is absolutely a must have.\r\n            ":" 反而！\r\n            如果使用，则必须拥有带有失踪成员的单位测试。\r\n            \r\n","\r\n            Scans all of the whitespace (not new-lines) into a trivia node until it runs out.\r\n            ":"\r\n            将所有空格（不是新线）扫描到琐事节点中，直到它用完为止。\r\n            \r\n","\r\n            A sum of widths of spans of all preceding initializers \r\n            (instance and static initializers are summed separately, and trivias are not counted).\r\n            ":"\r\n            所有先前初始化器的跨度的宽度之和\r\n            （实例和静态初始化器分别汇总，琐事不计算）。\r\n            \r\n","SyntaxToken representing the operator of the range expression.":"表示范围表达式的运算符的SyntaxToken。\r\n","\r\n              Looks up a localized string similar to The 'goto case' value is not implicitly convertible to the switch type.\r\n            ":"\r\n              查找类似于“ goto case”值的本地化字符串，并不是隐式转换为交换机类型。\r\n            \r\n","\r\n            Environments created in this scope to hold ":"\r\n            在此范围内创建的环境以保持\r\n","\r\n            Visit all nested functions in all nested scopes and run the ":"\r\n            访问所有嵌套范围中的所有嵌套功能，并运行\r\n","\r\n             Lower a foreach loop that will enumerate a collection using an enumerator.\r\n            \r\n             E e = ((C)(x)).GetEnumerator()\r\n             try {\r\n                 while (e.MoveNext()) {\r\n                     V v = (V)(T)e.Current;  -OR-  (D1 d1, ...) = (V)(T)e.Current;\r\n                     // body\r\n                 }\r\n             }\r\n             finally {\r\n                 // clean up e\r\n             }\r\n             ":"\r\n             降低一个foreach循环，该循环将使用枚举器枚举集合。\r\n            \r\n             e e =（（c）（x））。getEnumerator（）\r\n             尝试 {\r\n                 while（e.movenext（））{\r\n                     v v =（v）（t）e.current; -or-（d1 d1，...）=（v）（t）e.current;\r\n                     // 身体\r\n                 }\r\n             }\r\n             最后 {\r\n                 //清理e\r\n             }\r\n             \r\n","Nullability of reference types in type of parameter doesn't match overridden member.":"参数类型中参考类型的无效性不匹配被覆盖的成员。\r\n","Feature '{0}' is not part of the standardized ISO C# language specification, and may not be accepted by other compilers":"功能'{0}'不是标准化的ISO C＃语言规范的一部分，也可能不被其他编译器接受\r\n","Field is never assigned to, and will always have its default value":"字段永远不会分配给，并且将始终具有其默认值\r\n","'{0}': user-defined conversions to or from a derived type are not allowed":"'{0}'：不允许使用派生类型或从派生类型的用户定义的转换\r\n","Populated with *warnings* if there are near misses.":"如果有附近的错过，则填充 *警告 *。\r\n","\r\n              Looks up a localized string similar to Reference to type '{0}' claims it is defined in this assembly, but it is not defined in source or any added modules.\r\n            ":"\r\n              查找类似于类型“ {0}”声明的引用的本地化字符串，它是在此汇编中定义的，但并未在源或任何添加的模块中定义。\r\n            \r\n","\r\n            A collection of the local variables that are read inside the region.\r\n            ":"\r\n            该区域内读取的本地变量的集合。\r\n            \r\n","\r\n            Returns custom modifiers for the type arguments that have been substituted for the type parameters. \r\n            ":"\r\n            返回已替换为类型参数的类型参数的自定义修饰符。\r\n            \r\n","\r\n              Looks up a localized string similar to The compiler emits this warning when it overrides an error with a warning. For information about the problem, search for the error code mentioned..\r\n            ":"\r\n              查找类似于编译器的本地化字符串在用警告覆盖错误时发出此警告。有关问题的信息，请搜索提到的错误代码。\r\n            \r\n","\r\n            By default we defer to this.Type.IsPointerOrFunctionPointer() \r\n            However in some cases this may cause circular dependency via binding a\r\n            pointer that points to the type that contains the current field.\r\n            Fortunately in those cases we do not need to force binding of the field's type \r\n            and can just check the declaration syntax if the field type is not yet known.\r\n            ":"\r\n            默认情况下，我们将其推迟到this.type.ispointerorfunctionpointer（）\r\n            但是在某些情况下，这可能会通过结合A导致循环依赖性\r\n            指向包含当前字段的类型的指针。\r\n            幸运的是，在这种情况下，我们不需要强迫该领域类型的绑定\r\n            如果尚不知道字段类型，则可以检查声明语法。\r\n            \r\n","\r\n            Binds an expression-bodied member with expression e as either { return e;} or { e; }.\r\n            ":"\r\n            将表达式构件绑定为表达式E，为{return e;}或{e; }。\r\n            \r\n","Provides the base class from which the classes that represent lambda expressions are derived.":"提供代表Lambda表达式的类的基类。\r\n","\r\n              Looks up a localized string similar to Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' forwarded to assembly '{3}'..\r\n            ":"\r\n              查找类似于'{0}'转发到assembly' {1}'类型'{1}'的本地化字符串与type'{2}'转发到汇编'{3}'..\r\n            \r\n","\r\n            A pool of fields used to hoist locals. They appear in this set when not in scope,\r\n            so that members of this set may be allocated to locals when the locals come into scope.\r\n            ":"\r\n            一个用于吊起当地人的田野。当他们不在范围中时，它们出现在该集合中\r\n            因此，当当地人进入范围时，该集合的成员可以分配给当地人。\r\n            \r\n","\r\n            Accumulate diagnostics related to the variance safety of an interface method type parameters.\r\n            ":"\r\n            积累与接口方法类型参数的方差安全有关的诊断。\r\n            \r\n","\r\n            The options the compilation was created with. \r\n            ":"\r\n            编译创建的选项。\r\n            \r\n","\r\n            The conversion for a terminal position in the deconstruction tree.\r\n            ":"\r\n            解构树中终端位置的转换。\r\n            \r\n","\r\n              Looks up a localized string similar to delegate generic type constraints.\r\n            ":"\r\n              查找类似于委托通用类型约束的本地化字符串。\r\n            \r\n"," means the context is 'enable', ":" 意味着上下文是“启用”，\r\n","\r\n            checks if receiver is effectively ldarg.0\r\n            ":"\r\n            检查接收器是否有效ldarg.0\r\n            \r\n","\r\n            Helper methods for generic type parameter constraints. There are two sets of methods: one\r\n            set for resolving constraint \"bounds\" (that is, determining the effective base type, interface set,\r\n            etc.), and another set for checking for constraint violations in type and method references.\r\n            \r\n            Bounds are resolved by calling one of the ResolveBounds overloads. Typically bounds are\r\n            resolved by each TypeParameterSymbol at, or before, one of the corresponding properties\r\n            (BaseType, Interfaces, etc.) is accessed. Resolving bounds may result in errors (cycles,\r\n            inconsistent constraints, etc.) and it is the responsibility of the caller to report any such\r\n            errors as declaration errors or use-site errors (depending on whether the type parameter\r\n            was from source or metadata) and to ensure bounds are resolved for source type parameters\r\n            even if the corresponding properties are never accessed directly.\r\n            \r\n            Constraints are checked by calling one of the CheckConstraints or CheckAllConstraints\r\n            overloads for any generic type or method reference from source. In some circumstances,\r\n            references are checked at the time the generic type or generic method is bound and constructed\r\n            by the Binder. In those case, it is sufficient to call one of the CheckConstraints overloads\r\n            since compound types (such as A<T>.B<U> or A<B<T>>) are checked\r\n            incrementally as each part is bound. In other cases however, constraint checking needs to be\r\n            delayed to prevent cycles where checking constraints requires binding the syntax that is currently\r\n            being bound (such as the constraint in class C<T> where T : C<T>). In those cases,\r\n            the caller must lazily check constraints, and since the types may be compound types, it is\r\n            necessary to call CheckAllConstraints.\r\n            ":"\r\n            通用类型参数约束的辅助方法。有两组方法：一组\r\n            设置用于解决约束“界限”（即确定有效的基本类型，接口集，\r\n            等），另一组用于检查类型和方法参考中的约束违规行为。\r\n            \r\n            通过调用ResolveBoundS过载之一来解决界限。通常是界限\r\n            由每个类型甲板符号在或之前的每个类型甲板上解析\r\n            （底型，接口等）被访问。解决边界可能会导致错误（周期，\r\n            不一致的约束等），呼叫者有责任报告任何此类\r\n            错误作为声明错误或用途错误错误（取决于类型参数\r\n            是来自源或元数据），以确保解决界面类型参数的界限\r\n            即使从未直接访问相应的属性。\r\n            \r\n            通过调用CheckConstraints或CheckAllConstraints来检查约束\r\n            来自源的任何通用类型或方法参考的过载。在某些情况下，\r\n            在绑定并构造通用类型或通用方法时检查参考文献\r\n            由活页夹。在这种情况下，足以调用其中一个checkconstraints过载\r\n            由于检查化合物类型（例如<t> .b <u>或A <b <t >>）\r\n            逐步绑定每个零件。但是，在其他情况下，约束检查必须是\r\n            延迟以防止在检查约束需要绑定当前的语法的情况下进行周期\r\n            被绑定（例如c <t>类中的约束，其中t：c <t>）。在这些情况下，\r\n            呼叫者必须懒惰地检查约束，并且由于类型可能是复合类型，因此\r\n            需要调用CheckAllConstraints。\r\n            \r\n","An expression tree lambda may not contain a dictionary initializer.":"表达树lambda可能不包含字典初始化器。\r\n","\r\n            Rewrite the subexpressions in a conditional expression to convert the whole thing to the destination type.\r\n            ":"\r\n            在条件表达式中重写子表达，以将整个事物转换为目标类型。\r\n            \r\n","\r\n              Looks up a localized string similar to An error occurred while writing the output file: {0}.\r\n            ":"\r\n              在编写输出文件时查找类似于错误的本地化字符串：{0}。\r\n            \r\n","\r\n            Parses any kind of local declaration statement: local variable or local function.\r\n            ":"\r\n            解析任何类型的本地声明语句：本地变量或本地函数。\r\n            \r\n","\r\n            Creates a token corresponding to syntax kind. This method can be used for token syntax kinds whose text can\r\n            be inferred by the kind alone.\r\n            ":"\r\n            创建与语法类型相对应的令牌。此方法可用于代币语法类型的文本可以\r\n            仅由那种推断。\r\n            \r\n","\r\n            Used to parse the block-body for a method or accessor.  For blocks that appear *inside*\r\n            method bodies, call ":"\r\n            用于解析方法或登录器的块体。对于出现 *内部 *的块\r\n            方法主体，打电话\r\n","An expression tree may not contain '{0}'":"表达树可能不包含'{0}'\r\n","Location to report errors on.":"报告错误的位置。\r\n","\r\n            Gets the default value for the ":"\r\n            获取默认值\r\n","Creates a new InterpolatedStringExpressionSyntax instance.":"创建一个新的InterpolatedStringExpressionsyntax实例。\r\n"," and \r\n            if visiting specific symbol method VisitXXX is not overridden\r\n            ":" 和\r\n            如果访问特定的符号方法visitxxx不被覆盖\r\n            \r\n","Called when the visitor visits a ExternAliasDirectiveSyntax node.":"当访问者访问externaliasDirectiveSyntax节点时调用。\r\n","True if skipped tokens should be included, false by default.":"如果应该包括跳过的令牌，则默认情况下是错误的。\r\n","\r\n            Get the name of the property, indexer, or event so that it can be looked up in the containing type.\r\n            ":"\r\n            获取属性，索引器或事件的名称，以便可以在包含类型中查找。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' is a new virtual member in sealed class '{1}'.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串是密封类'{1}'中的新虚拟成员。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot convert {0} to type '{1}' because the parameter types do not match the delegate parameter types.\r\n            ":"\r\n              查找类似于不能将{0}转换为'{1}'的本地化字符串，因为参数类型与委托参数类型不匹配。\r\n            \r\n","The containing type of the constructors.":"包含构造函数的类型。\r\n","\r\n              Looks up a localized string similar to Cannot await in the filter expression of a catch clause.\r\n            ":"\r\n              在捕获子句的过滤器表达式中查找类似于等待的本地化字符串。\r\n            \r\n","\r\n            Might not be a method symbol.\r\n            ":"\r\n            可能不是方法符号。\r\n            \r\n","\r\n            The dynamic operation factories below return this struct so that the caller\r\n            have the option of separating the call-site initialization from its invocation.\r\n            \r\n            Most callers just call ":"\r\n            下面的动态操作工厂返回此结构，以便呼叫者\r\n            可以选择将呼叫点初始化与调用。\r\n            \r\n            大多数呼叫者只是打电话\r\n","\r\n              Looks up a localized string similar to Semicolon after method or accessor block is not valid.\r\n            ":"\r\n              在方法或登录器块之后，查找类似于分号的本地化字符串是无效的。\r\n            \r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 2. Please use language version {1} or greater..\r\n            ":"\r\n              查找类似于功能'{0}'的本地化字符串。\r\n            \r\n","Creates a new AttributeArgumentSyntax instance.":"创建一个新的attributeargumentsyntax实例。\r\n","\r\n              Looks up a localized string similar to A value of type '{0}' cannot be used as default parameter for nullable parameter '{1}' because '{0}' is not a simple type.\r\n            ":"\r\n              查找类似于类型的'{0}'值的本地化字符串不能用作nullable参数'{1}'的默认参数，因为'{0}'不是一个简单的类型。\r\n            \r\n","\r\n              Looks up a localized string similar to #load is only allowed in scripts.\r\n            ":"\r\n              在脚本中仅允许查找类似于#load的本地化字符串。\r\n            \r\n","\r\n            ExpressionSyntax node representing the body of the lambda.\r\n            Only one of Block or ExpressionBody will be non-null.\r\n            ":"\r\n            表示lambda主体的表达式节点。\r\n            只有一个块或表达机构将是非零的。\r\n            \r\n","\r\n            Returns information about interface method implementations that will be accompanied with \r\n            MethodImpl entries in metadata, information about which isn't already exposed through\r\n            ":"\r\n            返回有关接口方法实现的信息\r\n            Methodimpl条目中的元数据，有关这些条目尚未通过\r\n            \r\n","Item{i+1}":"项目{i+1}\r\n","\r\n              Looks up a localized string similar to Out variable and pattern variable declarations are not allowed within constructor initializers, field initializers, or property initializers..\r\n            ":"\r\n              查找类似于OUT变量的本地化字符串，并且在构造函数初始化器，字段初始化器或属性初始化器中不允许使用模式变量声明。\r\n            \r\n","\r\n            Definitely a type name: either a predefined type (int, string, etc.) or an array\r\n            type (ending with a [] brackets), or a pointer type (ending with *s), or a function\r\n            pointer type (ending with > in valid cases, or a *, ), or calling convention\r\n            identifier, in invalid cases).\r\n            ":"\r\n            绝对是类型名称：预定义的类型（INT，String等）或数组\r\n            类型（以[]括号结尾）或指针类型（以 *s结尾）或函数\r\n            指针类型（以>在有效情况下或A *，）或调用约定的情况下结束\r\n            标识符，在无效的情况下）。\r\n            \r\n","The original tree.":"原始树。\r\n","The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application's .config file, and you must provide the correct strong name of an assembly.":"这两个组件在发行版和/或版本编号上有所不同。为了使统一发生，您必须在应用程序的.config文件中指定指令，并且必须提供适当的汇编名称。\r\n","\r\n              Looks up a localized string similar to Cannot implicitly convert type '{0}' to '{1}'. An explicit conversion exists (are you missing a cast?).\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法隐式将类型'{0}'转换为'{1}'。存在明确的转换（您是否缺少演员？）。\r\n            \r\n","Reference to type '{0}' claims it is defined in this assembly, but it is not defined in source or any added modules":"引用类型'{0}'声明是在此组件中定义的，但未在源或任何添加的模块中定义\r\n","\r\n            Determines if the given raw kind value belongs to the C# ":"\r\n            确定给定的原始物质值是否属于C＃\r\n","\r\n            A collection of local variables that are written inside the region.\r\n            ":"\r\n            该区域内写的本地变量的集合。\r\n            \r\n"," \r\n            If true then the trees are equivalent if the contained nodes and tokens declaring\r\n            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\r\n            or initializer expressions, otherwise all nodes and tokens must be equivalent. \r\n            ":" \r\n            如果为true，则树是等效的，如果包含的节点和代币声明\r\n            元数据可见的符号信息是等效的，忽略了方法内部节点的任何差异\r\n            或初始器表达式，否则所有节点和令牌都必须等效。\r\n            \r\n","\r\n            Represents a source parameter cloned from another ":"\r\n            表示从另一个克隆的源参数\r\n","\r\n            An enumerator over ExtensionMethodScopes.\r\n            ":"\r\n            在ExtensionMethodScopes上的枚举者。\r\n            \r\n"," because we want to link this functionality into\r\n            the Formatter project and we don't want it to be public there.\r\n            ":" 因为我们想将此功能链接到\r\n            格式化项目，我们不希望它在那里公开。\r\n            \r\n","XML comment has cref attribute '{0}' that could not be resolved":"XML评论具有无法解决的Cref属性'{0}'\r\n","\r\n              Looks up a localized string similar to The type arguments for method '{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly..\r\n            ":"\r\n              查找类似于方法'{0}'的类型参数的本地化字符串，无法从用法中推断出来。尝试明确指定类型参数。\r\n            \r\n","This warning is caused when a catch() block has no specified exception type after a catch (System.Exception e) block. The warning advises that the catch() block will not catch any exceptions.\r\n            \r\n            A catch() block after a catch (System.Exception e) block can ca ...":"当catch（）块没有指定的异常类型（system.Exception e）块后，引起此警告。警告建议catch（）块不会捕获任何例外。\r\n            \r\n            捕获后的捕获（system.Exception e）块可以ca ...\r\n"," false might return a symbol. That symbol, if any,\r\n            is guaranteed to be from an interface.\r\n            This parameter is used to optimize caching in ":" fals可以返回符号。那个符号（如果有的话）\r\n            保证来自接口。\r\n            此参数用于优化缓存\r\n","\r\n              Looks up a localized string similar to Invalid number.\r\n            ":"查找类似于无效号码的本地化字符串。\r\n            \r\n","Populated with a list of assignment expressions that initialize the temporary locals.":"填充了初始化临时当地人的作业表达式列表。\r\n","\r\n            Returns and consumes the current token if it has the requested ":"\r\n            返回并消耗当前令牌（如果已要求）\r\n","\r\n            Returns false if source type can be nullable at the same time when destination type can be not nullable, \r\n            including the case of type parameters that by themselves can represent nullable and not nullable reference types.\r\n            When either type has no nullability information (oblivious), this method returns true.\r\n            ":"\r\n            如果源类型可以在目的地类型不可nullable的同时返回false，则返回false\r\n            包括类型参数本身可以代表无效且不可为无效的参考类型的情况。\r\n            当任何一种类型都没有无效信息（遗忘）时，此方法将返回true。\r\n            \r\n","An expression of type '{0}' cannot be handled by a pattern of type '{1}'. Please use language version '{2}' or greater to match an open type with a constant pattern.":"类型'{0}'的表达式无法通过类型'{1}'的模式来处理。请使用语言版本“ {2}”或更大的方法与恒定图案的打开类型匹配。\r\n","\r\n              Looks up a localized string similar to The type '{0}' already contains a definition for '{1}'.\r\n            ":"\r\n              查找类似于“ {0}”类型的本地化字符串已经包含了“ {1}”的定义。\r\n            \r\n","\r\n              Looks up a localized string similar to foreach statement cannot operate on enumerators of type '{0}' in async or iterator methods because '{0}' is a ref struct..\r\n            ":"\r\n              查找类似于foreach语句的本地化字符串无法在Async或Iterator方法的类型“ {0}”的枚举器上操作，因为'{0}'是ref struce ..\r\n            \r\n","Extension GetEnumerator support for foreach loops":"扩展getEnumerator支持foreach循环\r\n","\r\n            For each dag temp of a type for which we track such things (the integral types, floating-point types, and bool),\r\n            the possible values it can take on when control reaches this state.\r\n            If this dictionary is mutated after ":"\r\n            对于每个类型的DAG温度\r\n            当控件达到此状态时，它可能需要的值。\r\n            如果此词典在\r\n","\r\n            The Closure type represents a lambda or local function and stores\r\n            information related to that closure. After initially building the\r\n            ":"\r\n            闭合类型代表lambda或本地功能，并存储\r\n            与该关闭有关的信息。最初建立\r\n            \r\n","\r\n            Used to copy variable slots and types from the NullableWalker for the containing method\r\n            or lambda to the NullableWalker created for a nested lambda or local function.\r\n            ":"\r\n            用于从Nullable Walker复制可变插槽和类型的包含方法\r\n            或lambda到为嵌套lambda或本地函数创建的nullablewalker。\r\n            \r\n","\r\n            Derive error info from a type symbol.\r\n            ":"\r\n            从类型符号中得出错误信息。\r\n            \r\n","\r\n            Search through the members of the ":"\r\n            浏览成员\r\n","\r\n              Looks up a localized string similar to Transparent identifier member access failed for field '{0}' of '{1}'.  Does the data being queried implement the query pattern?.\r\n            ":"\r\n              查找类似于透明标识符成员访问的本地化字符串失败了'{1}'的字段'{0}'。被查询的数据是否实现了查询模式？\r\n            \r\n","This was factored out for clarity, not because it's reusable.":"这是为了清楚起见的考虑，不是因为它可以重复使用。\r\n","expression body property accessor":"表达主体物业登录器\r\n","\r\n            It is invalid for a type to directly (vs through a base class) implement two interfaces that\r\n            unify (i.e. are the same for some substitution of type parameters).\r\n            ":"\r\n            直接（通过基类VS）实现两个接口，这是无效的\r\n            unify（即对于某些类型参数的替换是相同的）。\r\n            \r\n","\r\n              Looks up a localized string similar to A null literal introduces a null value when '{0}' is a non-nullable reference type..\r\n            ":"\r\n              在“ {0}”是不可删除的参考类型时，查找类似于null文字类似的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Implicitly-typed variables cannot have multiple declarators.\r\n            ":"\r\n              查找类似于隐型变量类似的本地化字符串，不能具有多个声明器。\r\n            \r\n","'{0}' cannot declare a body because it is marked abstract":"'{0}'无法声明身体，因为它是标记为抽象的\r\n","stackalloc may not be used in a catch or finally block":"stackalloc不得在渔获量中使用或最终阻止\r\n","\r\n            Expression can be the LHS of a simple assignment operation.\r\n            Example: \r\n              property with a setter\r\n            ":"\r\n            表达可以是简单分配操作的LHS。\r\n            例子：\r\n              带有设置器的属性\r\n            \r\n","\r\n            A binder that brings both extern and using aliases into the scope and deals with looking up names in them.\r\n            ":"\r\n            将外部和使用别名带入范围并处理其中的名称的活页夹。\r\n            \r\n","\r\n            The unqualified part of a CrefSyntax.\r\n            For example, \"ToString()\" in \"object.ToString()\".\r\n            NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax\r\n            will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol\r\n            might be a non-type member.\r\n            ":"\r\n            Crefsyntax的不合格部分。\r\n            例如，“ tostring（）”中的“ tostring（）”。\r\n            注意：typecrefsyntax，合格crefsyntax和成员crefsyntax重叠。 typecrefsyntax中的语法\r\n            始终将被绑定为类型，因此使用合格的crefsyntax或成员crefsyntax是更安全的\r\n            可能是非型成员。\r\n            \r\n","\r\n            Locals are given slots when their declarations are encountered.  We only need give slots\r\n            to local variables, out parameters, and the \"this\" variable of a struct constructs.\r\n            Other variables are not given slots, and are therefore not tracked by the analysis.  This\r\n            returns -1 for a variable that is not tracked, for fields of structs that have the same\r\n            assigned status as the container, and for structs that (recursively) contain no data members.\r\n            We do not need to track references to\r\n            variables that occur before the variable is declared, as those are reported in an\r\n            earlier phase as \"use before declaration\". That allows us to avoid giving slots to local\r\n            variables before processing their declarations.\r\n            ":"\r\n            当遇到声明时，当地人将获得插槽。我们只需要给插槽\r\n            对于局部变量，输出参数以及构造构造的“此”变量。\r\n            其他变量未给出插槽，因此不会通过分析跟踪。这个\r\n            对于没有跟踪的变量的返回-1，对于具有相同的结构字段\r\n            分配的状态为容器，以及（递归）不包含数据成员的结构。\r\n            我们不需要跟踪参考\r\n            声明变量之前发生的变量，因为这些变量在\r\n            较早的阶段为“在声明之前使用”。这使我们能够避免给本地插槽\r\n            在处理声明之前，变量。\r\n            \r\n","\r\n            Represents a reference to a generic type instantiation.\r\n            Subclasses represent nested and namespace types.\r\n            ":"\r\n            代表对通用类型实例化的引用。\r\n            子类代表嵌套和名称空间类型。\r\n            \r\n","Empty character literal":"空的角色字面意思\r\n","\r\n            Because the instruction cannot have any values on the stack before CLR execution\r\n            we limited it to assignments and conditional expressions in C# 7.\r\n            See https://github.com/dotnet/roslyn/issues/22046.\r\n            In C# 8 we relaxed\r\n            that by rewriting the code to move it to the statement level where the stack is empty.\r\n            ":"\r\n            因为在CLR执行之前，指令在堆栈上不能有任何值\r\n            我们将其限于C＃7中的作业和条件表达式。\r\n            请参阅https://github.com/dotnet/roslyn/issues/22046。\r\n            在C＃8中，我们放松了\r\n            通过重写代码将其移至堆栈为空的语句级别。\r\n            \r\n","\r\n            Compute the value of the binary relational operator on the given operands.\r\n            ":"\r\n            计算给定操作数上二进制关系运算符的价值。\r\n            \r\n","\r\n            Returns true if the type is constructed from a generic type named \"System.Linq.Expressions.Expression\"\r\n            with one type parameter.\r\n            ":"\r\n            如果类型是从名为“ System.linq.expressions.expression”的通用类型构造的，则返回true。\r\n            使用一种类型参数。\r\n            \r\n"," used for the xml cref attribute syntax.":" 用于XML CREF属性语法。\r\n","\r\n              Looks up a localized string similar to implicitly typed local variable.\r\n            ":"\r\n              查找类似于隐式键入本地变量的本地化字符串。\r\n            \r\n","Nullability of reference types in return type doesn't match partial method declaration.":"返回类型中参考类型的无效性不匹配部分方法声明。\r\n","\r\n            Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label.\r\n            ":"\r\n            获取一个表示代表CASE标签的恒定表达式的表达式字母。\r\n            \r\n","\r\n              Looks up a localized string similar to Overloaded method '{0}' differing only in ref or out, or in array rank, is not CLS-compliant.\r\n            ":"查找类似于过载的方法'{0}'的本地化字符串，仅在ref，out或array等级中不同，不符合CLS符合CLS。\r\n            \r\n","Cannot use fixed local '{0}' inside an anonymous method, lambda expression, or query expression":"无法在匿名方法，lambda表达式或查询表达式中使用固定的本地'{0}'\r\n","SyntaxToken representing the colon.":"Syntaxtkoken代表结肠。\r\n","No source files specified":"没有指定的源文件\r\n","Unreachable code detected":"检测到无法到达的代码\r\n","The given expression is always of the provided ('{0}') type":"给定的表达式始终是提供的（'{0}'）类型\r\n","\r\n            Produce the next (i.e. lowest) CompletionPart (bit) that is not set.\r\n            ":"\r\n            生产未设置的下一个（即最低）完成派特（位）。\r\n            \r\n","Creates a new ParenthesizedPatternSyntax instance.":"创建一个新的括号内patternsyntax实例。\r\n","The text of the identifier name without escapes or leading '@' character.":"标识符名称的文本无逃脱或领导“@”字符。\r\n",", but has a ":"，但有一个\r\n","The out parameter '{0}' must be assigned to before control leaves the current method":"OUT参数'{0}'必须分配给控件离开当前方法之前\r\n","\r\n            If a well-known member of a generic type instantiation is needed use this method to get the corresponding generic definition and \r\n            ":"\r\n            如果需要使用此方法来获取相应的通用定义和\r\n            \r\n","\r\n            True if current identifier token is not really some contextual keyword\r\n            ":"\r\n            正确，如果当前标识符令牌并不是真正的上下文关键字\r\n            \r\n","\r\n            If this field represents a tuple element with index X\r\n             2X      if this field represents Default-named element\r\n             2X + 1  if this field represents Friendly-named element\r\n            ":"\r\n            如果此字段代表带有索引x的元组元素\r\n             2x如果此字段表示默认为命名元素\r\n             2x + 1如果该字段表示为友好的元素\r\n            \r\n","Invalid filename specified for preprocessor directive. Filename is too long or not a valid filename.":"针对预处理器指令指定的文件名无效。文件名太长或没有有效的文件名。\r\n","An object used to await this yield.":"一个用于等待此产量的对象。\r\n","Called when the visitor visits a BaseExpressionSyntax node.":"当访问者访问basexpressyntax节点时，请致电。\r\n","\r\n            Return true iff an await with this subexpression would be legal where the expression appears.\r\n            ":"\r\n            如果等待此子表达方式，则返回True如果在表达式出现的情况下是合法的。\r\n            \r\n","query expression":"查询表达式\r\n","Comparing with null of type '{0}' always produces 'false'":"与'{0}'类型的null始终产生'false'进行比较\r\n","A '{0}' character may only be escaped by doubling '{0}{0}' in an interpolated string.":"A'{0}'字符只能通过在插值字符串中加倍'{0} {0}'来逃脱。\r\n","A class with the ComImport attribute cannot have a user-defined constructor":"具有Comimport属性的类不能具有用户定义的构造函数\r\n","\r\n            The map that captures information about what assembly should be retargeted \r\n            to what assembly. Key is the ":"\r\n            捕获有关应该重新定位哪个组件的信息的地图\r\n            到什么组装。关键是\r\n","The old token.":"旧令牌。\r\n","\r\n              Looks up a localized string similar to 'await' requires that the return type '{0}' of '{1}.GetAwaiter()' have suitable IsCompleted, OnCompleted, and GetResult members, and implement INotifyCompletion or ICriticalNotifyCompletion.\r\n            ":"\r\n              查找类似于“等待”的本地化字符串，要求“ {1} .getawaiter（）'的返回类型'{0}'具有适当的结论，oncompleted和getResult成员，并实现InotifyCompletion或IcricationCompletion或IcricitifyCompletion。\r\n            \r\n","\r\n            Write header, descend into members, and write footer.\r\n            ":"\r\n            写标题，下降到成员，然后写页脚。\r\n            \r\n","\r\n              Looks up a localized string similar to Named argument '{0}' is used out-of-position but is followed by an unnamed argument.\r\n            ":"\r\n              查找类似于命名参数'{0}'的本地化字符串，使用了位置外，但随后是未命名的参数。\r\n            \r\n","\r\n              Looks up a localized string similar to Assignment in conditional expression is always constant; did you mean to use == instead of = ?.\r\n            ":"\r\n              在条件表达式中查找类似于分配的本地化字符串始终是恒定的。您的意思是使用==而不是=？。\r\n            \r\n",". This method is shared among all\r\n            typeclasses for value sets.\r\n            ":"。此方法共享\r\n            值集的类型。\r\n            \r\n","Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.":"由于不等待此呼叫，因此在呼叫完成之前，当前方法的执行继续。考虑将“等待”操作员应用于呼叫的结果。\r\n","\r\n            Set current result according to another.\r\n            ":"\r\n            根据另一个设置当前结果。\r\n            \r\n","\r\n            This is a map from TypeRef row id to the target ":"\r\n            这是从Typeref行ID到目标的地图\r\n","\r\n            This is a port of TypeManager::ImportDynamicTransformType from the native compiler.\r\n            Comments from the C# design document for Dynamic:\r\n            SPEC:   To represent the dynamic type in metadata, any indexer, field or return value typed as dynamic or known to be a constructed type\r\n            SPEC:   containing dynamic will have each occurrence of dynamic erased to object and will be annotated with a [DynamicAttribute].\r\n            SPEC:   If the relevant type is a constructed type, the attribute's constructor is passed a bool array.\r\n            SPEC:   This array represents a preorder traversal of each \"node\" in the constructed type's \"tree of types\",\r\n            SPEC:   with true set for each \"node\" that is dynamic, and false set for all other types.\r\n            SPEC:   When dynamic occurs as part of the base type of a type, the applicable [DynamicAttribute] is applied to the type itself.\r\n            ":"\r\n            这是来自本机编译器的typemanager :: importdynamictransformtype的端口。\r\n            C＃设计文档的评论：动态：\r\n            规格：代表元数据中的动态类型，任何索引器，字段或返回值键入动态或已知为构造类型\r\n            规格：包含动态的每一次动态都会删除到对象，并用[DynamiCattribute]注释。\r\n            规格：如果相关类型是构造类型，则属性的构造函数将传递为bool数组。\r\n            规格：此数组代表构造类型的“类型树”中每个“节点”的预订遍历，\r\n            规格：对于每个“动态”的“节点”，以及所有其他类型的false设置。\r\n            规格：当动态作为类型的基本类型的一部分发生时，将适用的[DynamiCattribute]应用于类型本身。\r\n            \r\n","\r\n            Returns the constraint types for the given type parameter.\r\n            ":"\r\n            返回给定类型参数的约束类型。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': cannot override because '{1}' is not a property.\r\n            ":"\r\n              查找类似于'{0}'：不能覆盖的本地化字符串，因为'{1}'不是属性。\r\n            \r\n"," cannot change between reads. But in ":" 无法改变读数。但在\r\n","Called when the visitor visits a PostfixUnaryExpressionSyntax node.":"当访问者访问后fixunary expressyntax节点时，请致电。\r\n","Class which represents the syntax node for array creation expression.":"代表数组创建表达式语法节点的类。\r\n","\r\n            For each distinct label, the set of states that need to be dispatched to that label.\r\n            Note that there is a dispatch occurring at every try-finally statement, so this\r\n            variable takes on a new set of values inside each try block.\r\n            ":"\r\n            对于每个不同的标签，需要派往该标签的一组状态。\r\n            请注意，每个试用语句都会发生一个调度，因此\r\n            变量在每个尝试块内部采用新的值集。\r\n            \r\n","\r\n            Gets the effective language version, which the compiler uses to select the\r\n            language rules to apply to the program.\r\n            ":"\r\n            获取有效的语言版本，编译器使用该版本选择\r\n            语言规则适用于程序。\r\n            \r\n","\r\n              Looks up a localized string similar to SyntaxTree resulted from a #load directive and cannot be removed or replaced directly..\r\n            ":"\r\n              查找类似于语法的本地化字符串，该字符串是由#load指令产生的，无法直接删除或替换。\r\n            \r\n","\r\n            Global namespace.\r\n            ":"\r\n            全局名称空间。\r\n            \r\n","Call to non-readonly member '{0}' from a 'readonly' member results in an implicit copy of '{1}'.":"从'ReadOnly'成员中调用非读取成员'{0}'会导致“ {1}”的隐式副本。\r\n","\r\n            Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or\r\n            associated with the token and its related trivia.\r\n            ":"\r\n            在将指定节点作为root或\r\n            与令牌及其相关的琐事相关。\r\n            \r\n","\r\n            Force the inference of the LValueResultType from ResultType.\r\n            ":"\r\n            迫使lvalueresultType从结果typepe推断。\r\n            \r\n"," that owns this node.\r\n            If this node was created with an explicit non-null ":" 拥有此节点。\r\n            如果该节点是用明确的非零子创建的\r\n","              | no  | no  |   match   |\r\n            \r\n             ":"              |否|否|匹配|\r\n            \r\n             \r\n","\r\n            Null if we're not inside a nested function, otherwise the nearest nested function.\r\n            ":"\r\n            null如果我们不在嵌套功能中，则否则最近的嵌套功能。\r\n            \r\n","Called when the visitor visits a RefExpressionSyntax node.":"当访问者访问refexpressyntax节点时，请致电。\r\n","\r\n              Looks up a localized string similar to The field '{0}' is never used.\r\n            ":"\r\n              从未使用过类似于“ {0}”字段的本地化字符串。\r\n            \r\n","Algorithm '{0}' is not supported":"不支持算法'{0}'\r\n","\r\n              Looks up a localized string similar to The constraints for type parameter '{0}' of method '{1}' must match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead..\r\n            ":"\r\n              查找类似于类型参数的约束的本地化字符串，方法'{1}'必须匹配类型参数'{2}'接口方法'{3}'的约束。考虑使用显式接口实现。\r\n            \r\n","The entry point of the program is global code; ignoring '{0}' entry point.":"程序的切入点是全局代码；忽略'{0}'入口点。\r\n","True if the conversion should be determined as for a cast expression.":"正确，如果应确定转换为铸件表达式。\r\n","\r\n              Looks up a localized string similar to Expected contextual keyword 'equals'.\r\n            ":"\r\n              查找类似于预期上下文关键字“ equals”的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to 'await' requires that the type '{0}' have a suitable 'GetAwaiter' method. Are you missing a using directive for 'System'?.\r\n            ":"\r\n              查找类似于“等待”的本地化字符串，要求类型'{0}'具有合适的“ getawaiter”方法。您是否缺少使用“系统”的指令？\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot return the range variable '{0}' by reference.\r\n            ":"\r\n              查找类似于类似的本地化字符串无法通过引用返回范围变量'{0}'。\r\n            \r\n","\r\n            Whenever parsing in a ":"\r\n            每当解析\r\n","\r\n            Returns underlying internal symbol object, if any.\r\n            ":"\r\n            返回基础内部符号对象（如果有）。\r\n            \r\n","\r\n            Creates a token with kind CharacterLiteralToken from a character value.\r\n            ":"\r\n            从字符值创建具有善良的字符的令牌。\r\n            \r\n","Cannot convert null to '{0}' because it is a non-nullable value type":"无法将null转换为'{0}'，因为它是不可删除的值类型\r\n","Called when the visitor visits a RangeExpressionSyntax node.":"当访问者访问范围explactionsyntax节点时调用。\r\n","\r\n              Looks up a localized string similar to Duplicate null suppression operator ('!').\r\n            ":"\r\n              查找类似于重复的NULL抑制操作员（'！'）的本地化字符串。\r\n            \r\n","\r\n            The set of abstract members in declared in this type or declared in a base type and not overridden.\r\n            ":"\r\n            以这种类型声明或以基本类型声明而不是被覆盖的抽象成员集。\r\n            \r\n","e.g. '<' for &lt;.":"例如'<'for＆lt;。\r\n","\r\n              Looks up a localized string similar to Feature '{0}' is not available in C# 7. Please use language version {1} or greater..\r\n            ":"\r\n              查找类似于功能'{0}'的本地化字符串。\r\n            \r\n","The operand of an increment or decrement operator must be a variable, property or indexer":"增量或减少操作员的操作数必须是变量，属性或索引器\r\n","The raw text of the identifier name, including any escapes or leading '@'\r\n            character.":"标识符名称的原始文本，包括任何逃逸或领先的“@”\r\n            特点。\r\n","\r\n            The current iterator finally frame in the tree of finally frames.\r\n            By default there is a root finally frame.\r\n            Root frame does not have a handler, but may contain nested frames.\r\n            ":"\r\n            当前的迭代器最终在最终框架的树上框架。\r\n            默认情况下，有一个根框架。\r\n            根架没有处理程序，但可能包含嵌套框架。\r\n            \r\n","\r\n            Build and add synthesized return type attributes for this method symbol.\r\n            ":"\r\n            为此方法符号构建并添加合成的返回类型属性。\r\n            \r\n"," that represents the current AttributeData.":"这代表当前的属性。\r\n","'{0}': type used in a using statement must be implicitly convertible to 'System.IDisposable'.":"'{0}'：在使用语句中使用的类型必须隐式转换为“ system.idisposable”。\r\n","\r\n              Looks up a localized string similar to Keyword 'this' is not valid in a static property, static method, or static field initializer.\r\n            ":"\r\n              在静态属性，静态方法或静态字段初始化器中查找类似于关键字的本地化字符串。\r\n            \r\n","\r\n            Structure containing all semantic information about a for each statement.\r\n            ":"\r\n            结构包含有关每个语句的所有语义信息。\r\n            \r\n","Type parameters are not allowed on a method group as an argument to 'nameof'.":"类型参数在方法组上不允许作为“名称”的参数。\r\n","\r\n              Looks up a localized string similar to Partial declarations of '{0}' must be all classes, all structs, or all interfaces.\r\n            ":"查找类似于“ {0}”部分声明类似的本地化字符串，必须是所有类，所有结构或所有接口。\r\n            \r\n",".\r\n            All NaN values are treated as equivalent.\r\n            ":"。\r\n            所有NAN值均被视为等效。\r\n            \r\n"," for this node.\r\n            ":" 对于此节点。\r\n            \r\n","Call System.IDisposable.Dispose() on allocated instance of {0} before all references to it are out of scope.":"在{0}的分配实例上呼叫system.idisposable.dispose（），然后在所有引用均超出范围之前。\r\n","Missing closing quotation mark for string literal.":"缺少字符串文字的关闭引号。\r\n","The search must respect accessibility from this type.":"搜索必须尊重这种类型的可访问性。\r\n","Roslyn compiler server reports different protocol version than build task.":"Roslyn编译器服务器报告的协议版本与构建任务不同。\r\n","Invalid type specified as an argument for TypeForwardedTo attribute":"无效类型指定为typeforwardto属性的参数\r\n","The tuple element name '{0}' is ignored because a different name or no name is specified by the target type '{1}'.":"元组元素名称'{0}'被忽略，因为目标类型'{1}'指定了不同的名称或未指定名称。\r\n","\r\n              Looks up a localized string similar to Control cannot fall out of switch from final case label ('{0}').\r\n            ":"\r\n              查找类似于控件的本地化字符串不能从最终情况下标签（'{0}'）中脱离切换。\r\n            \r\n","'{0}' does not implement inherited abstract member '{1}'":"'{0}'不会实现继承的抽象成员'{1}'\r\n","Cannot assign to {0} '{1}' because it is a readonly variable":"无法分配给{0}'{1}'，因为它是一个可读变量\r\n","\r\n              Looks up a localized string similar to '{0}' cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type '{1}'.\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串不能将其标记为CLS兼容，因为它是非CLS兼容类型'{1}'的成员。\r\n            \r\n","Instance of type '{0}' cannot be used inside a nested function, query expression, iterator block or async method":"类型'{0}'的实例不能在嵌套函数，查询表达式，迭代块或异步方法中使用\r\n","\r\n            Note: do not use a static/singleton instance of this type, as it holds state.\r\n            ":"\r\n            注意：不要使用此类型的静态/单例实例，因为它保持状态。\r\n            \r\n"," of the source assembly is used.":" 使用源组件。\r\n","Will be populated with pattern diagnostics.":"将带有模式诊断。\r\n","\r\n            Write an array of bytes. The array data is provided as a\r\n            ":"\r\n            写一个字节。数组数据作为一个\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot ref-assign '{1}' to '{0}' because '{1}' has a narrower escape scope than '{0}'..\r\n            ":"\r\n              查找类似于'{0}'的局部字符串，因为'{1}'具有较窄的逃生范围，而不是'{0}'..\r\n            \r\n","Type does not implement the collection pattern; member has the wrong signature":"类型不会实现集合模式；成员的签名错误\r\n","\r\n              Looks up a localized string similar to Using directive appeared previously in this namespace.\r\n            ":"\r\n              查找类似于使用指令的本地化字符串，以前出现在此名称空间中。\r\n            \r\n","\r\n            Given a member, look for other members contained in the same type with signatures that will\r\n            not be distinguishable by the runtime.\r\n            ":"\r\n            给出了一个成员，查找与签名相同类型中包含的其他成员\r\n            无法通过运行时区分。\r\n            \r\n","\r\n            This class implements the region control flow analysis operations. Region control flow\r\n            analysis provides information about statements which enter and leave a region. The analysis\r\n            is done lazily. When created, it performs no analysis, but simply caches the arguments.\r\n            Then, the first time one of the analysis results is used it computes that one result and\r\n            caches it. Each result is computed using a custom algorithm.\r\n            ":"\r\n            该类实现区域控制流分析操作。区域控制流\r\n            分析提供了有关输入和离开区域的陈述的信息。分析\r\n            懒洋洋地完成。创建时，它不会执行任何分析，而只是缓存了参数。\r\n            然后，第一次使用分析结果，它计算出一个结果和\r\n            缓存。使用自定义算法计算每个结果。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot infer the type of implicitly-typed deconstruction variable '{0}'..\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法推断隐型解构变量的类型'{0}'..\r\n            \r\n","\r\n            Generates the syntax representation of a xml text node (e.g. for xml documentation comments).\r\n            ":"\r\n            生成XML文本节点的语法表示（例如，用于XML文档注释）。\r\n            \r\n","\r\n            Binds the expression for an is-type right-hand-side, in case it does not bind as a type.\r\n            ":"如果IS型右侧的表达式结合，以防它不作为类型结合。\r\n            \r\n","Called when the visitor visits a ConstructorInitializerSyntax node.":"当访问者访问constructorizersyntax节点时调用。\r\n","A lambda expression with a statement body cannot be converted to an expression tree":"带有语句主体的lambda表达式无法转换为表达树\r\n","\r\n              Looks up a localized string similar to Nullability of reference types in type of parameter '{0}' doesn't match partial method declaration..\r\n            ":"\r\n              在参数类型'{0}'类型中查找类似于参考类型的无效性类似的本地化字符串不匹配部分方法声明。\r\n            \r\n","\r\n              Looks up a localized string similar to implicitly typed array.\r\n            ":"\r\n              查找类似于隐式键入数组的本地化字符串。\r\n            \r\n",", indicates that the \"non-safety\" diagnostic ":"，表示“非安全”诊断\r\n","\r\n            Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.\r\n            ":"\r\n            获取一个elseclaisesyntax，该ancax表示如果存在此类语句，则在条件为false时要执行的语句。\r\n            \r\n","\r\n            Reports specified use-site diagnostic to given diagnostic bag. \r\n            ":"\r\n            报告指定的用途诊断以给定诊断袋。\r\n            \r\n","\r\n            In a file that has been included in the compilation via #load.\r\n            ":"\r\n            在通过#load中包含在汇编中的文件中。\r\n            \r\n","\r\n            An array of cached Cor types defined in this assembly.\r\n            Lazily filled by GetDeclaredSpecialType method.\r\n            ":"\r\n            该组件中定义的一组缓存的COR类型。\r\n            用getDeclaredSpecialType方法懒洋洋地填充。\r\n            \r\n","\r\n            These names are the simple identifiers for the type, and do not include namespaces,\r\n            outer type names, or type parameters.\r\n            \r\n            This functionality can be used for features that want to quickly know if a name could be\r\n            a type for performance reasons.  For example, classification does not want to incur an\r\n            expensive binding call cost if it knows that there is no type with the name that they\r\n            are looking at.\r\n            ":"\r\n            这些名称是类型的简单标识符，不包括名称空间，\r\n            外部类型名称或类型参数。\r\n            \r\n            此功能可以用于想要快速知道名称是否可以是的功能\r\n            出于性能原因。例如，分类不想产生\r\n            昂贵的绑定呼叫费用如果知道他们的名字没有类型\r\n            正在看。\r\n            \r\n","\r\n            Report warning passing argument where nested nullability does not match\r\n            parameter (e.g.: calling `void F(object[] o)` with `F(new[] { maybeNull })`).\r\n            ":"\r\n            报告警告通过嵌套无匹配的嵌套不匹配的传递论点\r\n            参数（例如：使用`f（new [] {Maybenull}）`调用`void f（object [] o）`）。\r\n            \r\n","\r\n            This is a cache similar to the one used by MetaImport::GetTypeByName\r\n            in native compiler. The difference is that native compiler pre-populates \r\n            the cache when it loads types. Here we are populating the cache only\r\n            with things we looked for, so that next time we are looking for the same \r\n            thing, the lookup is fast. This cache also takes care of TypeForwarders. \r\n            Gives about 8% win on subsequent lookups in some scenarios.     \r\n            ":"\r\n            这是一个类似于metaimport :: getTypebyname的缓存\r\n            在本地编译器中。区别在于，天然编译器预处理\r\n            加载类型时的缓存。在这里，我们仅填充缓存\r\n            我们寻找的东西，所以下次我们正在寻找相同的东西\r\n            事情，查找很快。此缓存还照顾了typeforwarders。\r\n            在某些情况下，在随后的查找中获得约8％的胜利。\r\n            \r\n","SeparatedSyntaxList of AnonymousObjectMemberDeclaratorSyntax representing the list of object member initializers.":"AnonymobjectMemberDeclaratorsyntax的分离列表列表表示对象成员初始化器的列表。\r\n","\r\n            An elastic trivia with kind EndOfLineTrivia containing both the carriage return and line feed characters.\r\n            Elastic trivia are used to denote trivia that was not produced by parsing source text, and are usually not\r\n            preserved during formatting.\r\n            ":"\r\n            带有载体的弹性琐事，既包含托架返回和线饲料字符。\r\n            弹性琐事用于表示不是通过解析源文本产生的琐事，通常不是\r\n            在格式期间保存。\r\n            \r\n","The side of the test handling lower values. The true side for < and <=, the false side for > and >=.":"测试处理较低值的侧面。 <and <=，> and> =的false侧的真实侧面。\r\n"," being true means ":" 是真的\r\n","\r\n            Null or default literal conversions are described in section 6.1.5 of the C# language specification.\r\n            ":"\r\n            null或默认文字转换在C＃语言规范的第6.1.5节中描述。\r\n            \r\n","\r\n            Gets the set of interfaces that this type directly implements. This set does not include\r\n            interfaces that are base interfaces of directly implemented interfaces.\r\n            ":"\r\n            获取此类型直接实现的一组接口。此组不包括\r\n            接口是直接实现的接口的基本接口。\r\n            \r\n","\r\n            Run the nullable walker during the flow analysis passes. True if the project-level nullable\r\n            context option is set, or if any file enables nullable or just the nullable warnings.\r\n            ":"\r\n            在流程分析过程中运行无效的步行者。如果项目级别无效，则为true\r\n            设置了上下文选项，或者如果任何文件启用了无效的或仅可用的警告。\r\n            \r\n","\r\n              Looks up a localized string similar to indexing movable fixed buffers.\r\n            ":"\r\n              查找类似于索引可移动固定缓冲区的本地化字符串。\r\n            \r\n","\r\n            Writes the full text of this node to the specified TextWriter.\r\n            ":"\r\n            将此节点的全文写入指定的文本作者。\r\n            \r\n","Called when the visitor visits a FixedStatementSyntax node.":"当访问者访问fixatstatementsyntax节点时，请致电。\r\n","\r\n            A distinct scope that may expose extension methods. For a particular Binder,  there\r\n            are two possible scopes: one for the namespace, and another for any using statements\r\n            in the namespace. The namespace scope is searched before the using scope.\r\n            ":"\r\n            可能暴露扩展方法的独特范围。对于特定的粘合剂，\r\n            是两个可能的范围：一个用于命名空间，另一个用于任何使用语句\r\n            在名称空间中。在使用范围之前搜索名称空间范围。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot declare namespace in script code.\r\n            ":"\r\n              在脚本代码中查找类似于无法声明名称空间的本地化字符串。\r\n            \r\n","Cannot assign to '{0}' because it is read-only":"不能分配给'{0}'，因为它是只读的\r\n","Possible null reference argument.":"可能的null参考参数。\r\n","Bag to which to add diagnostics.":"添加诊断的包。\r\n",".\r\n            When it returns true, it stops at operator keyword (":"。\r\n            当它返回true时，它将停止在操作员关键字（\r\n","\r\n            Initially, this is the method's return value label (":"\r\n            最初，这是该方法的返回值标签（\r\n","\r\n            NOTE: The spec fails to impose the restriction that the event receiver must be classified\r\n            as a variable (unlike for properties - 7.17.1).  This seems like a bug, but we have\r\n            production code that won't build with the restriction in place (see DevDiv #15674).\r\n            ":"\r\n            注意：规格未能强加必须对事件接收器进行分类的限制\r\n            作为变量（与属性不同-7.17.1）。这似乎是一个错误，但我们有\r\n            生产代码不会在适当的限制下构建（请参阅Devdiv＃15674）。\r\n            \r\n","\r\n             (2) The current method being processed (this changes within a lambda's body), in ":"\r\n             （2）当前正在处理的方法（这在兰伯达的身体内发生了变化），\r\n","The argument to evaluate early.":"提早评估的论点。\r\n","Rewritten attribute constructor arguments":"重写属性构造函数参数\r\n"," if we are in an explicitly checked context (within checked block or expression).\r\n            ":" 如果我们处于明确检查的上下文（在检查块或表达式中）。\r\n            \r\n","SyntaxToken representing the MakeRefKeyword.":"Syntaxtoken代表makereFkeyWord。\r\n","\r\n            Returns a flag indicating whether this symbol is ComImport.\r\n            ":"返回一个标志，指示此符号是否为comimport。\r\n            \r\n","\r\n              Looks up a localized string similar to No value for RuntimeMetadataVersion found. No assembly containing System.Object was found nor was a value for RuntimeMetadataVersion specified through options..\r\n            ":"\r\n              查找与找到的RuntimeMetAdaTaversion相似的本地化字符串。未找到包含系统的组件。被发现也不是通过选项指定的runtimemetadataversion的价值。\r\n            \r\n","Imported type '{0}' is invalid. It contains a circular base type dependency.":"导入类型的'{0}'无效。它包含圆形基本类型的依赖性。\r\n","\r\n            Is the node the name of a named argument of an invocation, object creation expression, \r\n            constructor initializer, or element access, but not an attribute.\r\n            ":"\r\n            是节点的名称的名称，是调用，对象创建表达式的名称，\r\n            构造函数初始化器或元素访问，而不是属性。\r\n            \r\n","\r\n              Looks up a localized string similar to Keyword 'this' is not available in the current context.\r\n            ":"\r\n              在当前上下文中查找类似于关键字的本地化字符串。\r\n            \r\n","\r\n            The syntax trees (parsed from source code) that this compilation was created with.\r\n            ":"\r\n            使用此汇编创建的语法树（根据源代码解析）。\r\n            \r\n","\r\n            This binder is for binding the argument to typeof.  It traverses\r\n            the syntax marking each open type (\"unbound generic type\" in the\r\n            C# spec) as either allowed or not allowed, so that BindType can \r\n            appropriately return either the corresponding type symbol or an \r\n            error type.  It also indicates whether the argument as a whole \r\n            should be considered open so that the flag can be set \r\n            appropriately in BoundTypeOfOperator.\r\n            ":"\r\n            该活页夹是为了将论点与typeof结合。它穿越\r\n            语法标记每个开放类型（在\r\n            c＃spec）是允许或不允许的，以便bindtype可以\r\n            适当返回相应的类型符号或\r\n            错误类型。它还表明了论点是否整体\r\n            应视为打开，以便设置标志\r\n            适当地在边界型操作机中。\r\n            \r\n","Ambiguity between '{0}' and '{1}'":"'{0}'和'{1}'之间的歧义\r\n","\r\n              Looks up a localized string similar to An event in an interface cannot have add or remove accessors.\r\n            ":"\r\n              查找类似于接口中事件的本地化字符串，无法具有添加或删除访问者。\r\n            \r\n","Syntax node is not within syntax tree":"语法节点不在语法树中\r\n","\r\n              Looks up a localized string similar to Call System.IDisposable.Dispose() on allocated instance of {0} before all references to it are out of scope..\r\n            ":"\r\n              在{0}的分配实例上查找类似于call system.idisposable.dispose（）的本地化字符串，然后所有引用的所有引用都超出了范围。\r\n            \r\n","\r\n              Looks up a localized string similar to Object '{0}' can be disposed more than once..\r\n            ":"\r\n              查找类似于对象'{0}'的本地化字符串可以多次处置。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot take the address of the given expression.\r\n            ":"\r\n              查找类似于给定表达式的地址的本地化字符串。\r\n            \r\n","\r\n            An array of assemblies referenced by this assembly, which are linked (/l-ed) by \r\n            each compilation that is using this AssemblySymbol as a reference. \r\n            If this AssemblySymbol is linked too, it will be in this array too.\r\n            The array and its content is provided by ReferenceManager and must not be modified.\r\n            ":"\r\n            该组件引用的一系列组件，由（/l-ed）链接\r\n            每次使用此组合符号作为参考的汇编。\r\n            如果此汇编符号也链接在一起，则它也将在此数组中。\r\n            数组及其内容由ReferenceManager提供，不得修改。\r\n            \r\n","Indexing an array with a negative index (array indices always start at zero)":"索引带有负索引的数组（数组索引始终以零启动）\r\n","The raw text within the new line.":"新行中的原始文本。\r\n","The class type constraint '{0}' must come before any other constraints":"类类型约束'{0}'必须在任何其他约束之前\r\n","\r\n            CustomAttributeHandle if any are found. Nil token otherwise.\r\n        ":"\r\n            customAttributeHandle（如果找到）。否则零令牌。\r\n        \r\n","A SemanticModel object that can be used to inquire about the semantic\r\n            information associated with syntax nodes within ":"可以用来查询语义的语义模型对象\r\n            与语法节点相关的信息\r\n","SyntaxToken representing the TypeOfKeyword.":"表示typeofkeyword的义务。\r\n","\r\n            An expression accessing the length of the indexing target. This should\r\n            be a non-side-effecting operation.\r\n            ":"\r\n            访问索引目标长度的表达式。这应该\r\n            成为非侧面效应的操作。\r\n            \r\n","\r\n            Returns the unqualified (right-most) part of a qualified or alias-qualified name, or the name itself if already unqualified. \r\n            ":"\r\n            返回合格或别名资格的名称的未合格（正确）一部分，或者如果已经不合格的名称本身。\r\n            \r\n","'{0}' does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute":"'{0}'不需要CLSCompliant属性，因为汇编没有CLSCompliant属性\r\n","Overloaded method '{0}' differing only in ref or out, or in array rank, is not CLS-compliant":"超载方法'{0}'仅在ref或out或array等级中不同，不符合cls cls cls\r\n","ExpressionSyntax node representing the expression on the right of the range operator.":"ExpressionSyntax节点表示范围运算符右侧的表达式。\r\n","\r\n            Uses object identity when comparing two references. \r\n            ":"\r\n            比较两个引用时使用对象身份。\r\n            \r\n","Referenced assembly has different culture setting":"参考组装有不同的文化环境\r\n","Both partial method declarations must be readonly or neither may be readonly":"两种部分方法声明都必须阅读或不可阅读\r\n","The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.":"无效的参考类型的注释仅应在“ #nullable”注释上下文中的代码中使用。\r\n","\r\n            Make a local variable symbol for an element of a deconstruction,\r\n            which can be inferred (if necessary) by binding the enclosing statement.\r\n            ":"\r\n            为解构的元素制作局部变量符号，\r\n            可以通过约束封闭语句来推断（如有必要）。\r\n            \r\n","An auto-implemented property must be fully assigned before control is returned to the caller.":"在将控件返回到呼叫者之前，必须完全分配自动实施的属性。\r\n","\r\n            Produce a random value set for testing purposes.\r\n            ":"\r\n            产生一个随机值集用于测试目的。\r\n            \r\n","\r\n            An elastic trivia with kind EndOfLineTrivia containing a single line feed character. Elastic trivia are used\r\n            to denote trivia that was not produced by parsing source text, and are usually not preserved during\r\n            formatting.\r\n            ":"\r\n            具有单线饲料特征的弹性琐事具有类似的内膜。使用弹性琐事\r\n            表示未通过解析源文本产生的琐事，通常在\r\n            格式化。\r\n            \r\n","Anonymous type field type with annotations":"带注释的匿名类型字段类型\r\n","Possible unintended reference comparison; to get a value comparison, cast the right hand side to type '{0}'":"可能的意外参考比较；要获得值比较，请将右侧施放到键入'{0}'\r\n","tuples":"元组\r\n","The Conditional attribute is not valid on '{0}' because it is an override method":"条件属性在“ {0}”上无效，因为它是覆盖方法\r\n",".\r\n            \r\n             To keep the stack frame size on recursive paths small the non-recursive parts are factored into local\r\n             functions. This means we pay their stack penalty only when they are used. They are themselves big\r\n             enough they should be disqualified from inlining. In the future when attributes are allowed on\r\n             local functions we should explicitly mark them as ":"。\r\n            \r\n             为了将堆栈框架的尺寸保持在递归路径上的小小\r\n             功能。这意味着我们只有在使用时才支付堆栈罚款。他们自己很大\r\n             足以使他们不合格。将来允许属性\r\n             本地功能我们应该明确将它们标记为\r\n","\r\n            Most of the above optimizations are not applicable in expression trees as the operator\r\n            must stay a binary operator. We cannot do much beyond constant folding which is done in binder.\r\n            ":"\r\n            以上大多数优化不适用于表达树作为操作员\r\n            必须留住二进制操作员。我们不能做出超越固定折叠的恒定折叠。\r\n            \r\n","string M()":"字符串M（）\r\n","The arguments of the invocation (or the delegate type, if a method group conversion)":"调用的参数（或委托类型，如果方法组转换）\r\n","The string to search":"搜索的字符串\r\n","\r\n            Collects XML doc comment exterior trivia, and therefore is a no op unless we are in the Start or Exterior of an XML doc comment.\r\n            ":"\r\n            收集XML Doc评论外部琐事，因此除非我们处于XML Doc评论的开始或外部，否则是不op。\r\n            \r\n"," to succeed":" 成功\r\n","No overload for '{0}' matches delegate '{1}'":"对于'{0}'匹配委托'{1}'没有超载\r\n","Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Consider explicitly specifying the type of the range variable '{2}'.":"找不到源类型的查询模式的实现。{0}'。 '{1}'找不到。考虑明确指定范围变量的类型'{2}'。\r\n","\r\n            Checks if 'symbol' is accessible from within type 'within', with\r\n            a qualifier of type \"throughTypeOpt\". Sets \"failedThroughTypeCheck\" to true\r\n            if it failed the \"through type\" check.\r\n            ":"\r\n            检查是否可以从类型“内部”中访问“符号”，\r\n            类型为“ Printypeopt”的预选赛。设置“失败的typecheck”\r\n            如果失败了“通过类型”检查。\r\n            \r\n","\r\n            If the new source text is a minor change from the current source text an incremental parse will occur\r\n            reusing most of the current syntax tree internal data.  Otherwise, a full parse will occur using the new\r\n            source text.\r\n            ":"\r\n            如果新源文本是当前源文本的较小更改，则会发生增量解析\r\n            重用大多数当前语法树内部数据。否则，将使用新的\r\n            源文本。\r\n            \r\n","Cannot convert null literal to non-nullable reference type.":"无法将null文字转换为不可删除的参考类型。\r\n","Cannot return by reference a member of parameter '{0}' because it is not a ref or out parameter":"无法通过参考返回参数'{0}'的成员，因为它不是ref或out参数\r\n","\r\n              Looks up a localized string similar to Metadata references are not supported..\r\n            ":"\r\n              查找类似于元数据参考的本地化字符串。\r\n            \r\n","\r\n            Displays the version number in the format expected on the command-line (/langver flag).\r\n            For instance, \"6\", \"7.0\", \"7.1\", \"latest\".\r\n            ":"\r\n            在命令行（/langver标志）上以预期的格式显示版本号。\r\n            例如，“ 6”，“ 7.0”，“ 7.1”，“最新”。\r\n            \r\n","Gets the close paren token.":"获取近距离的帕伦令牌。\r\n","\r\n              Looks up a localized string similar to The return type for ++ or -- operator must match the parameter type or be derived from the parameter type.\r\n            ":"\r\n              查找类似于++或 - 运算符的返回类型的本地化字符串，必须匹配参数类型或从参数类型派生。\r\n            \r\n","\r\n            A pointer to a function in fixed or managed memory.\r\n            ":"\r\n            指向固定或托管内存中功能的指针。\r\n            \r\n","Anonymous type field name, not nothing and not empty":"匿名类型字段名称，不是一无所有，不是空的\r\n","\r\n            Creates a speculative SemanticModel for a TypeSyntax node at a position within an existing MemberSemanticModel.\r\n            ":"\r\n            为在现有成员emanticmodel中的位置上的型典型字母节点创建一个投机性词素模型。\r\n            \r\n","\r\n              Looks up a localized string similar to The best overload for '{0}' does not have a parameter named '{1}'.\r\n            ":"查找类似于“ {0}”的最佳过载的本地化字符串，没有名为'{1}'的参数。\r\n            \r\n","A syntax node that represents a parsed expression. This syntax\r\n            node need not and typically does not appear in the source code referred to by the\r\n            SemanticModel instance.":"表示解析表达式的语法节点。这个语法\r\n            节点无需，通常不会出现在该源代码中\r\n            Semanticmodel实例。\r\n","\r\n            Separate from ":"\r\n            从.....分离\r\n","Source location.":"来源位置。\r\n","\r\n              Looks up a localized string similar to module as an attribute target specifier.\r\n            ":"\r\n              查找类似于模块的本地化字符串作为属性目标规范。\r\n            \r\n","\r\n            CompareExchange doesn't support bool, so use an int.  First bit is true/false, second bit \r\n            is read/unread (debug-only).\r\n            ":"\r\n            compareexchange不支持布尔，因此请使用int。第一个位是真/错误，第二位\r\n            被读取/未读（仅调试）。\r\n            \r\n","If a constant label is found that matches the constant input, assigned that label":"如果找到与常数输入匹配的常数标签，则分配该标签\r\n","\r\n            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees\r\n            added later. \r\n            ":"\r\n            在没有指定的语法树的情况下创建新的汇编。保存元数据信息可与树一起使用\r\n            稍后添加。\r\n            \r\n","Invalid parameter type 'void'":"无效的参数类型“ void”\r\n","Async Main":"异步主\r\n","Base type is not CLS-compliant":"基本类型不符合CLS\r\n","\r\n            Performs name lookup for simple generic or non-generic name\r\n            within an optional qualifier namespace or type symbol.\r\n            If LookupOption.AttributeTypeOnly is set, then it performs\r\n            attribute type lookup which involves attribute name lookup\r\n            with and without \"Attribute\" suffix.\r\n            ":"\r\n            执行简单通用或非传播名称的名称查找\r\n            在可选的预选赛名称空间或键入符号中。\r\n            如果设置了lookupoption.attributetypeonly，则可以执行\r\n            属性类型查找，涉及属性名称查找\r\n            有和没有“属性”后缀。\r\n            \r\n","\r\n            Accumulates conjuncts (conditions that must all be true) for the translation. When a conjunct is added,\r\n            elements of the _sideEffectBuilder, if any, should be added as part of a sequence expression for\r\n            the conjunct being added.\r\n            ":"\r\n            累积翻译的连词（必须全部为真的条件）。当添加一个连词时，\r\n            _sideeffectBuilder的元素（如果有）应作为序列表达式的一部分添加\r\n            添加了结合。\r\n            \r\n","True if a reference to \"this\" is available.":"如果可以参考“此”，则为true。\r\n","\r\n            An immutable copy of ":"\r\n            不变的副本\r\n","An expression tree may not contain a named argument specification":"表达树可能不包含命名参数规范\r\n","\r\n            The type passed to the runtime binder as context.\r\n            ":"\r\n            该类型将运行时活页夹作为上下文传递。\r\n            \r\n","\r\n            Source: Was the member name qualified with a type name?\r\n            Metadata: Is the member an explicit implementation?\r\n            ":"\r\n            资料来源：成员名称是否有类型名称的资格？\r\n            元数据：成员是明确的实施吗？\r\n            \r\n","Cannot define/undefine preprocessor symbols after first token in file":"在文件中首次令牌后无法定义/不确定预处理器符号\r\n","\r\n              Looks up a localized string similar to Properties which return by reference must have a get accessor.\r\n            ":"\r\n              查找类似于属性的本地化字符串，该属性必须具有引用返回的属性。\r\n            \r\n","\r\n            Returns true if the method is a constructor and has a this() constructor initializer.\r\n            ":"\r\n            如果该方法是构造函数，并且具有this（）构造函数初始化程序，则返回true。\r\n            \r\n","Creates a new YieldStatementSyntax instance.":"创建一个新的fordstatementsyntax实例。\r\n","Member '{0}' was not found on type '{1}' from assembly '{2}'.":"从汇编'{2}'在类型'{1}'上找不到成员'{0}'。\r\n","\r\n            Returns true if the conversion is an implicit reference conversion or explicit reference conversion.\r\n            ":"\r\n            如果转换是隐式参考转换或明确的参考转换，则返回true。\r\n            \r\n","\r\n            Set to true after an analysis scan if the analysis was incomplete due to state changing\r\n            after it was used by another analysis component.  In this case the caller scans again (until\r\n            this is false). Since the analysis proceeds by monotonically changing the state computed\r\n            at each label, this must terminate.\r\n            ":"\r\n            分析扫描后设置为TRUE，如果由于状态变化不完整，分析是否不完整\r\n            在另一个分析组件使用之后。在这种情况下，呼叫者再次扫描（直到\r\n            这是错误的）。由于分析是通过单调更改计算状态进行的\r\n            在每个标签上，必须终止。\r\n            \r\n","s and the provided options or default.\r\n            ":"S和提供的选项或默认值。\r\n            \r\n","\r\n            Returns true when field is a backing field for a captured frame pointer (typically \"this\").\r\n            ":"\r\n            当字段是捕获的帧指针（通常为“ this”）时，返回true。\r\n            \r\n","\r\n            True if the method itself is excluded from code coverage instrumentation.\r\n            True for source methods marked with ":"\r\n            如果将方法本身从代码覆盖仪器中排除在外，则为正确。\r\n            对于标记的源方法是正确的\r\n","\r\n              Looks up a localized string similar to An expression tree lambda may not contain a null propagating operator..\r\n            ":"\r\n              查找类似于表达树lambda的局部字符串可能不包含零散的繁殖操作员。\r\n            \r\n","\r\n            Represents an if statement syntax.\r\n            ":"\r\n            表示if语句语法。\r\n            \r\n","\r\n              Looks up a localized string similar to An expression tree lambda may not contain a COM call with ref omitted on arguments.\r\n            ":"\r\n              查找类似于表达树lambda的本地化字符串可能不包含在参数上省略的com调用。\r\n            \r\n","\r\n            Returns the byte value from the (single byte) NullableAttribute or nearest\r\n            NullableContextAttribute. Returns 0 if neither attribute is specified.\r\n            ":"\r\n            从（单字节）nulebabeAttribute或最近返回字节值\r\n            nullableContextAttribute。返回0，如果指定属性。\r\n            \r\n","\r\n            Creates the syntax representation of a param element within xml documentation comments (e.g. for\r\n            documentation of method parameters).\r\n            ":"\r\n            创建XML文档注释中参数元素的语法表示（例如\r\n            方法参数的文档）。\r\n            \r\n","Called when the visitor visits a XmlTextAttributeSyntax node.":"访问者访问XMLTEXTATTRIBUTESYNTAX节点时调用。\r\n","\r\n            Bound type if syntax binds to a type in the current context and\r\n            null if syntax binds to a contextual constraint keyword.\r\n            ":"\r\n            如果语法在当前上下文中与类型结合，则绑定类型\r\n            null如果语法绑定到上下文约束关键字。\r\n            \r\n","Wrong number of indices inside []; expected {0}":"[]内部的索引数错误;预期{0}\r\n","\r\n              Looks up a localized string similar to Possible null reference assignment to iteration variable.\r\n            ":"\r\n              查找类似于迭代变量的可能的null参考分配的本地化字符串。\r\n            \r\n"," in context of the current type.\r\n            The method is using cache to optimize subsequent calls for the same ":" 在当前类型的上下文中。\r\n            该方法是使用缓存来优化随后的调用相同的调用\r\n","NameSyntax node representing the name on the left side of the dot token of the qualified name.":"nameyntax节点表示合格名称的点令牌左侧的名称。\r\n","Must be non-null and contain a non-null GetEnumeratorMethod.":"必须是非零子，并且包含非肺化getEnumeratormethod。\r\n","; Override this method with specific\r\n            implementation; Calling default ":";用特定的\r\n            执行;调用默认值\r\n","\r\n            Returns a value that tells how many local scopes are visible, including the current.\r\n            I.E. outside of any method will be 0\r\n                 immediately inside a method - 1\r\n            ":"\r\n            返回一个值，该值告诉包括当前包括当前的局部范围有多少本地范围。\r\n            IE。任何方法都将是0\r\n                 立即在方法内 -  1\r\n            \r\n","\r\n            by computing a description of the initial state in a ":"\r\n            通过计算对初始状态的描述\r\n","\r\n            Given a compilation and a destination directory, determine three names:\r\n              1) The name with which the assembly should be output.\r\n              2) The path of the assembly/module file.\r\n              3) The path of the pdb file.\r\n            \r\n            When csc produces an executable, but the name of the resulting assembly\r\n            is not specified using the \"/out\" switch, the name is taken from the name\r\n            of the file (note: file, not class) containing the assembly entrypoint\r\n            (as determined by binding and the \"/main\" switch).\r\n            \r\n            For example, if the command is \"csc /target:exe a.cs b.cs\" and b.cs contains the\r\n            entrypoint, then csc will produce \"b.exe\" and \"b.pdb\" in the output directory,\r\n            with assembly name \"b\" and module name \"b.exe\" embedded in the file.\r\n            ":"\r\n            给定汇编和目标目录，确定三个名称：\r\n              1）应该输出组件的名称。\r\n              2）汇编/模块文件的路径。\r\n              3）PDB文件的路径。\r\n            \r\n            当CSC产生可执行文件时，但是由此产生的组件的名称\r\n            未使用“/out”开关指定，名称是从名称中获取的\r\n            文件（注意：文件，不是类）包含汇编入门点\r\n            （如绑定和“/main”开关确定）。\r\n            \r\n            例如，如果命令是“ CSC /TARGET：EXE A.CS B.CS”，并且B.CS包含\r\n            入门点，然后CSC将在输出目录中产生“ b.exe”和“ b.pdb”，\r\n            带有嵌入在文件中的汇编名称“ B”和模块名称“ B.EXE”。\r\n            \r\n","\r\n            Returns true if the conversion is an implicit constant expression conversion.\r\n            ":"\r\n            如果转换是隐式常数转换，则返回true。\r\n            \r\n","Called when the visitor visits a FunctionPointerParameterListSyntax node.":"当访问者访问fintunPoInterParameterListsyntax节点时调用。\r\n",".\r\n             \r\n             Then we make a frame, or compiler-generated class, represented by an instance of\r\n             ":"。\r\n             \r\n             然后，我们制作一个框架或编译器生成的类，以实例为代表\r\n             \r\n","     vs. ":"     VS.\r\n","\r\n              Looks up a localized string similar to Invalid operand for pattern match; value required, but found '{0}'..\r\n            ":"\r\n              查找类似于无效操作数以进行模式匹配的本地化字符串；需要的值，但发现“ {0}” ..\r\n            \r\n","\r\n            Produce the zero value for the type.\r\n            ":"\r\n            产生类型的零值。\r\n            \r\n","Inconsistent accessibility: event type '{1}' is less accessible than event '{0}'":"不一致的可访问性：事件类型'{1}'比事件'{0}'易于访问\r\n","\r\n            Mark this field as the backing field of a field-like event.\r\n            The caller will also ensure that it is excluded from the member list of\r\n            the containing type (as it would be in source).\r\n            ":"将此字段标记为类似现场事件的背景字段。\r\n            呼叫者还将确保将其排除在成员列表之外\r\n            包含类型（如在源中）。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': event must be of a delegate type.\r\n            ":"\r\n              查找类似于'{0}'：事件必须是委托类型的本地化字符串。\r\n            \r\n","\r\n            should be used instead.\r\n            ":"\r\n            应该使用。\r\n            \r\n","Diagnostic bag.":"诊断袋。\r\n","foreach statement cannot operate on enumerators of type '{0}' in async or iterator methods because '{0}' is a ref struct.":"foreach语句无法在异步或迭代方法中的类型'{0}'的枚举者上操作，因为'{0}'是REF结构。\r\n","Namespace '{1}' contains a definition conflicting with alias '{0}'":"名称空间'{1}'包含一个与别名'{0}'相冲突的定义\r\n","The field has multiple distinct constant values.":"该字段具有多个不同的常数值。\r\n","A static local function cannot contain a reference to '{0}'.":"静态本地函数不能包含对“ {0}”的引用。\r\n","\r\n            Gets the binder that encloses the position.\r\n            ":"\r\n            获取包含位置的活页夹。\r\n            \r\n","\r\n            Bind the (implicit or explicit) constructor initializer of a constructor symbol (in source).\r\n            ":"\r\n            绑定构造函数符号的（源）的（隐式或显式）构造函数。\r\n            \r\n","a commandlinearguments object representing the parsed command line.":"代表解析命令行的命令线核对对象。\r\n","\r\n              Looks up a localized string similar to An analyzer instance cannot be created.\r\n            ":"\r\n              查找类似于分析仪实例的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'.\r\n            ":"\r\n              查找类似于操作员'{0}'的本地化字符串，不能应用于类型'{1}'和'{2}'的操作数。\r\n            \r\n"," that provides the primitives for that type.\r\n            ":" 这为该类型提供了原始内容。\r\n            \r\n","The return type for ++ or -- operator must match the parameter type or be derived from the parameter type":"++或 - 运算符的返回类型必须匹配参数类型或从参数类型派生\r\n","Out variables":"输出变量\r\n","Ambiguous reference in cref attribute: '{0}'. Assuming '{1}', but could have also matched other overloads including '{2}'.":"Cref属性中的模棱两可的引用：'{0}'。假设'{1}'，但也可以匹配其他过载，包括'{2}'。\r\n","\r\n            NOTE: Keep this method in sync with AnalyzeImplicitUserDefinedConversionForSwitchGoverningType.\r\n            ":"\r\n            注意：将此方法与AnalysemeplicerDuserDefinedConversionForsWitchGoverningType保持同步。\r\n            \r\n","\r\n            Gets the XML that would be written to the documentation comment file for this assembly.\r\n            ":"\r\n            获取将写入此组件的文档注释文件的XML。\r\n            \r\n","CallerMemberNameAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'":"无法应用CallerMemberNameatTribute，因为从类型'{0}'type'{1}'类型中没有标准转换\r\n"," which has ":" 其中有\r\n","\r\n            So that the binding info can return an appropriate SemanticInfo.Converted type for the collection\r\n            expression of a foreach node, it is wrapped in a BoundConversion to the collection type in the\r\n            initial bound tree.  However, we may be able to optimize away (or entirely disregard) the conversion\r\n            so we pull out the bound node for the underlying expression.\r\n            ":"\r\n            这样绑定信息就可以返回一个适当的语义信息。集合的转换类型\r\n            foreach节点的表达式，它被包装在BoundConversion中，以\r\n            初始绑定树。  但是，我们可能能够优化（或完全忽略）转换\r\n            所以我们拉出底层表达式的绑定节点。\r\n            \r\n","\r\n            Parse a type.  May include an alias, a predefined type, and/or a qualified name.\r\n            ":"\r\n            解析类型。可以包括一个别名，预定义的类型和/或合格的名称。\r\n            \r\n","\r\n              Looks up a localized string similar to Position must be within span of the syntax tree..\r\n            ":"\r\n              查找类似于位置的局部字符串必须在语法树的跨度内。\r\n            \r\n","\r\n              Looks up a localized string similar to Argument of type '{0}' is not applicable for the DefaultParameterValue attribute.\r\n            ":"\r\n              查找类似于“ {0}”类型参数的本地化字符串不适用于DefaultParameTervalue属性。\r\n            \r\n","\r\n            Returns true if the conversion is an implicit numeric conversion or explicit numeric conversion. \r\n            ":"\r\n            如果转换是隐式数字转换或显式数字转换，则返回true。\r\n            \r\n","Creates a new XmlElementEndTagSyntax instance.":"创建一个新的XmlelementEndTagSyntax实例。\r\n","\r\n              Looks up a localized string similar to Type of '{0}' is not CLS-compliant.\r\n            ":"\r\n              查找类似于“ {0}”类型的本地化字符串不符合CLS。\r\n            \r\n"," modifier or\r\n            implicitly static.\r\n            ":" 修饰符或\r\n            隐式静态。\r\n            \r\n","\r\n            Add sequence point |here|:\r\n            \r\n            foreach (|Type var| in expr) { }\r\n            ":"\r\n            添加序列点/这里|:\r\n            \r\n            foreach(|类型var/in expr){}\r\n            \r\n","A params parameter must be the last parameter in a formal parameter list":"一个参数必须是正式参数列表中的最后一个参数\r\n","\r\n              Looks up a localized string similar to Not a recognized attribute location.\r\n            ":"\r\n              查找类似于未识别属性位置的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Local name is too long for PDB.\r\n            ":"\r\n              查找与本地名称相似的本地化字符串对于PDB来说太长了。\r\n            \r\n","contravariant":"违反\r\n","\r\n              Looks up a localized string similar to Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' exported from module '{3}'..\r\n            ":"\r\n              查找类似于'{0}'转发到assembly' {1}'类型的局部字符串与从模块'{3}'导出的类型'{2}'相冲突\r\n            \r\n","\r\n            Return statements and the result types from analyzing the returned expressions. Used when inferring lambda return type in MethodTypeInferrer.\r\n            ":"\r\n            返回语句和分析返回表达式的结果类型。在推断lambda返回类型中时使用。\r\n            \r\n","\r\n              Looks up a localized string similar to Fields of static readonly field '{0}' cannot be returned by writable reference.\r\n            ":"\r\n              查找类似于静态读取字段'{0}'字段类似的本地化字符串，无法通过写入引用返回。\r\n            \r\n","\r\n            Creates the syntax representation of an xml text attribute.\r\n            ":"\r\n            创建XML文本属性的语法表示。\r\n            \r\n","\r\n            While resolving the name, consider only types following CLS-compliant generic type names and arity encoding (ECMA-335, section 10.7.2).\r\n            I.e. arity is inferred from the name and matching type must have the same emitted name and arity.\r\n            ":"\r\n            在解决该名称时，仅考虑按照CLS兼容的通用类型名称和ARITY编码（ECMA-335，第10.7.2节）的类型。\r\n            IE。从名称中推断出Arity，并且匹配类型必须具有相同的发射名称和Arity。\r\n            \r\n","\r\n            C# language version 3.0.\r\n            ":"\r\n            C＃语言版本3.0。\r\n            \r\n","Called when the visitor visits a FunctionPointerUnmanagedCallingConventionSyntax node.":"当访问者访问fintunPoInterunManagedCallingConventionsyntax节点时，请致电。\r\n","\r\n            Return a clone of the current node with the HasErrors flag set.\r\n            ":"\r\n            用HaserRors标志集返回当前节点的克隆。\r\n            \r\n","\r\n              Looks up a localized string similar to Reference to '{0}' netmodule missing..\r\n            ":"\r\n              查找类似于“ {0}” NetModule缺失的引用的本地化字符串。\r\n            \r\n","\r\n            The module containing the namespace.\r\n            ":"\r\n            包含名称空间的模块。\r\n            \r\n","\r\n              Looks up a localized string similar to Nullability of reference types in return type doesn't match implemented member..\r\n            ":"\r\n              查找类似于返回类型中参考类型的无效类型的本地化字符串与实现的成员不匹配。\r\n            \r\n","\r\n              Looks up a localized string similar to CallerFilePathAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'.\r\n            ":"\r\n              查找类似于CallerFilePathAttribute的本地化字符串，因为从类型'{0}'type'{1}'类型中没有标准转换。\r\n            \r\n","\r\n            Gets a constant expression for a goto case statement.\r\n            ":"\r\n            获取goto案例语句的恒定表达式。\r\n            \r\n","Generic parameter is definition when expected to be reference {0}":"通用参数是定义，当期望为参考{0}\r\n","\r\n            In script C#, some field initializers are assignments to fields and others are global\r\n            statements.  There are no restrictions on accessing instance members.\r\n            ":"\r\n            在脚本C＃中，一些字段初始化器是对字段的作业，而其他字段则是全局\r\n            语句。访问实例成员没有限制。\r\n            \r\n","\r\n            A collection of type parameter constraint types, populated when\r\n            constraint types for the first type parameter is requested.\r\n            Initialized in two steps. Hold a copy if accessing during initialization.\r\n            ":"类型参数约束类型的集合，当\r\n            请求第一个类型参数的约束类型。\r\n            以两个步骤初始化。如果在初始化期间访问，请持有副本。\r\n            \r\n"," Anonymous type descriptor ":" 匿名类型描述符\r\n","\r\n            Take forwarded types into account.\r\n            ":"\r\n            考虑转发类型。\r\n            \r\n","\r\n            Get the symbol that logically contains this symbol. \r\n            ":"\r\n            获取逻辑上包含此符号的符号。\r\n            \r\n","Creates a new StructDeclarationSyntax instance.":"创建一个新的structDeclarationsyntax实例。\r\n","Null if there is no matching declaration.":"null如果没有匹配声明。\r\n","\r\n              Looks up a localized string similar to Delegate '{0}' does not take {1} arguments.\r\n            ":"\r\n              查找类似于委托'{0}'的本地化字符串不需要{1}参数。\r\n            \r\n","\r\n            This is a comparer that ignores differences in dynamic-ness and tuple names.\r\n            But it has a special case for top-level object vs. dynamic for purpose of method type inference.\r\n            ":"\r\n            这是一个忽略动态性和元组名称的差异的比较。\r\n            但是，对于方法类型推理的目的，它具有顶级对象与动态的特殊情况。\r\n            \r\n","ExpressionSyntax node representing the condition of the conditional expression.":"表示条件表达式条件的表达式元素节点。\r\n","\r\n              Looks up a localized string similar to Cannot assign {0} to anonymous type property.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法分配{0}到匿名类型属性。\r\n            \r\n","\r\n            Lower the given decision tree into the given statement builder.\r\n            ":"\r\n            将给定的决策树降低到给定的语句构建器中。\r\n            \r\n","Call System.IDisposable.Dispose() on allocated instance before all references to it are out of scope":"在分配的实例上call system.idisposable.dispose（）在所有引用不超出范围之前\r\n","A member '{0}' marked as override cannot be marked as new or virtual":"标记为替代的成员'{0}'不能标记为新的或虚拟的\r\n","Partial declarations of '{0}' must be all classes, all record classes, all structs, all record structs, or all interfaces":"“ {0}”的部分声明必须是所有类，所有记录类，所有结构，所有记录结构或所有接口\r\n","\r\n            You may assume that this would share code and logic with PEMethodSymbol.OverridesRuntimeFinalizer, \r\n            but FUNCBRECCS::bindDestructor has its own loop that performs these checks (differently).\r\n            ":"\r\n            您可以假设这将与pemethodsymbol.overridesruntimefinalizer共享代码和逻辑，\r\n            但是funcbreccs :: binddestructor具有自己的循环，可以执行这些检查（以不同的方式）。\r\n            \r\n",".\r\n            The expressions returned from a lambda are not converted though, so we'll have to classify fresh conversions.\r\n            Note: even if some conversions fail, we'll proceed to infer top-level nullability. That is reasonable in common cases.\r\n            ":"。\r\n            但是，从lambda返回的表达式并未转换，因此我们必须对新的转换进行分类。\r\n            注意：即使某些转换失败，我们也会继续推断顶级无效性。在常见情况下这是合理的。\r\n            \r\n","Populated with invocation errors, and warnings of near misses":"填充了调用错误，并警告近距离错过\r\n","\r\n            Packages up the various parts returned when resolving a method group. \r\n            ":"\r\n            解决方法组时返回的各个部分。\r\n            \r\n","items: must be non-empty":"项目：必须是非空的\r\n","\r\n            Look up the given metadata type, if it is forwarded.\r\n            ":"\r\n            如果转发，请查找给定的元数据类型。\r\n            \r\n","Called when the visitor visits a ClassOrStructConstraintSyntax node.":"当访问者访问classorscontconstyntax节点时，请致电。\r\n","The name '{0}' is not in scope on the right side of 'equals'.  Consider swapping the expressions on either side of 'equals'.":"名称“ {0}”不在'equals'的右侧范围。考虑将表达式交换在“平等”的两侧。\r\n","\r\n            Represents an anonymous type template's type parameter.\r\n            ":"\r\n            表示匿名类型模板的类型参数。\r\n            \r\n","The operation in question is undefined on void pointers":"有问题的操作在无效指针上不确定\r\n","\r\n            User variable declared by a declaration expression in some unsupported context.\r\n            This occurs as a result of error recovery in incorrect code.\r\n            ":"\r\n            用户变量在某些不支持的上下文中通过声明表达式声明。\r\n            这是由于不正确代码中的错误恢复而发生的。\r\n            \r\n","\r\n            Spec 7.7.7.1:\r\n            An Awaiter A has an accessible instance method GetResult with no parameters and no type parameters.\r\n            ":"\r\n            规格7.7.7.1：\r\n            等待者A具有无参数且没有类型参数的可访问实例方法GetResult。\r\n            \r\n","\r\n            Create a NamespaceExtent that represents a given ModuleSymbol.\r\n            ":"\r\n            创建一个代表给定模块符号的命名续文。\r\n            \r\n","\r\n            Given a character, advance the input if either the character or the\r\n            corresponding XML entity appears next in the text window.\r\n            ":"\r\n            给定角色，提出输入，如果字符或角色\r\n            相应的XML实体将出现在文本窗口中。\r\n            \r\n","\r\n             Takes the expression for the current value of the iteration variable and either\r\n             (1) assigns it into a local, or\r\n             (2) deconstructs it into multiple locals (if there is a deconstruct step).\r\n            \r\n             Produces `V v = /* expression */` or `(D1 d1, ...) = /* expression */`.\r\n             ":"\r\n             以迭代变量的当前值的表达\r\n             （1）将其分配给本地或\r\n             （2）将其解构为多个当地人（如果有一个解构步骤）。\r\n            \r\n             产生`v v = / *表达式 * /`or`（d1 d1，...）= / * expression * /`。\r\n             \r\n","\r\n            The Deconstruct method (if any) for this non-terminal position in the deconstruction tree.\r\n            ":"\r\n            该非末端位置在解构树中的解构方法（如果有）。\r\n            \r\n","\r\n              Looks up a localized string similar to The event '{0}' can only appear on the left hand side of += or -=.\r\n            ":"\r\n              查找类似于事件'{0}'的本地化字符串只能出现在 +=或 -  =的左侧。\r\n            \r\n"," comparison and the other for ":" 比较，另一个\r\n","Current array dimension being processed.":"当前数组维度正在处理。\r\n","\r\n            Ignore duplicate types from the cor library.\r\n            ":"\r\n            忽略COR库中的重复类型。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' in explicit interface declaration is not an interface.\r\n            ":"\r\n              在显式接口声明中查找类似于“ {0}”的本地化字符串不是接口。\r\n            \r\n","\r\n              Looks up a localized string similar to tree not part of compilation.\r\n            ":"\r\n              查找类似于树而不是编译的一部分的本地化字符串。\r\n            \r\n","\r\n            Find the well-known ValueTuple type of a given arity.\r\n            For example, for arity=2:\r\n            returns WellKnownType.System_ValueTuple_T2\r\n            ":"\r\n            找到给定的著名估值类型。\r\n            例如，对于Arity = 2：\r\n            返回众所周知的type.system_valuetuple_t2\r\n            \r\n","Expression on which to perform lookup":"表达进行查找的表达\r\n","\r\n            Clones all labels used in a finally block.\r\n            This allows creating an emittable clone of finally.\r\n            It is safe to do because no branches can go in or out of the finally handler.\r\n            ":"\r\n            克隆最终块中使用的所有标签。\r\n            这允许创建最终的克隆。\r\n            这是安全的，因为没有分支可以进出最后的处理程序。\r\n            \r\n","Creates a new FixedStatementSyntax instance.":"创建一个新的fixedstatementsyntax实例。\r\n","A helper class that uses a decision tree to produce subsumption diagnostics.":"使用决策树生成归因诊断的助手类。\r\n","Conditional ref operator":"有条件的参考操作员\r\n","The stream cannot be read from.":"该流无法从中读取。\r\n"," accessible from within ":" 可以从内部访问\r\n","Called when the visitor visits a TypeConstraintSyntax node.":"当访问者访问typectraintsyntax节点时，请致电。\r\n","True if a diagnostic was reported":"如果报告了诊断，则为真实\r\n","SourceText cannot be embedded. Provide encoding or canBeEmbedded=true at construction.":"SourceText不能嵌入。在施工时提供编码或canbeembedded = true。\r\n","\r\n            Creates a new syntax tree from a syntax node.\r\n            ":"\r\n            从语法节点创建一个新的语法树。\r\n            \r\n","Creates a new AttributeSyntax instance.":"创建一个新的属性yntax实例。\r\n","The callback args.":"回调args。\r\n","\r\n            It is rare but possible for a source type to be convertible to a destination type\r\n            by both an implicit user-defined conversion and a built-in explicit conversion.\r\n            In that circumstance, this method classifies the conversion as the built-in conversion.\r\n            ":"\r\n            很少见，但可能使源类型可转换为目的地类型\r\n            通过隐式用户定义的转换和内置的显式转换。\r\n            在这种情况下，此方法将转换归类为内置转换。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid filename specified for preprocessor directive.\r\n            ":"\r\n              查找类似于预处理指令指定的无效文件名的本地化字符串。\r\n            \r\n","\r\n            Flow analysis annotations on the method itself (ie. DoesNotReturn)\r\n            ":"\r\n            该方法本身的流量分析注释（即do.notorturn）\r\n            \r\n","\r\n            Does the assembly has internal accessibility to \"toAssembly\"?\r\n            ":"\r\n            大会是否具有内部可访问性？\r\n            \r\n","\r\n            Rewrite the replacement expression for the hoisted local so all synthesized field are accessed as members\r\n            of the appropriate frame.\r\n            ":"\r\n            重写吊装本地的替换表达式，因此所有合成字段均被访问为成员\r\n            适当的框架。\r\n            \r\n","Converting null literal or possible null value to non-nullable type.":"将零字面或可能的空值转换为不可删除类型。\r\n","Argument {0}: cannot convert from '{1}' to '{2}'":"参数{0}：不能从'{1}'转换为'{2}'\r\n","\r\n                IList<string> SemanticModel.LookupNames(CSharpSyntaxNode location, NamespaceOrTypeSymbol container = null, LookupOptions options = LookupOptions.Default, List<string> result = null);\r\n                IList<Symbol> SemanticModel.LookupSymbols(CSharpSyntaxNode location, NamespaceOrTypeSymbol container = null, string name = null, int? arity = null, LookupOptions options = LookupOptions.Default, List<Symbol> results = null);\r\n            ":"\r\n                iList <string> semanticmodel.lookupnames（csharpsyntaxnode位置，namespaceortypesymbol container = null，lookupoptions options = lookupoptions.default.default，list <string> result = result = null）;\r\n                iList <符号> semanticmodel.lookupsymbols（csharpsyntaxnode位置，namespaceortypesymbol容器= null，string null，string name = null，int？arity = null，lookupottions options = lookupoptions.defupoptions.default.default，list <符号<符号>结果= null = null）;\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid type for parameter in XML comment cref attribute.\r\n            ":"\r\n              在XML注释CREF属性中查找类似于参数的无效类型的本地化字符串。\r\n            \r\n","Skipping some types in analyzer assembly {0} due to a ReflectionTypeLoadException : {1}.":"由于ReflectionTypeloadexception：{1}，跳过某些类型的分析仪组件{0}。\r\n","This combination of arguments to '{0}' is disallowed because it may expose variables referenced by parameter '{1}' outside of their declaration scope":"这种参数与'{0}'的组合是不允许的\r\n","Invalid unicode character.":"无效的Unicode字符。\r\n","\r\n              Looks up a localized string similar to An expression tree may not contain a multidimensional array initializer.\r\n            ":"\r\n              查找类似于表达树的本地化字符串可能不包含多维阵列初始化器。\r\n            \r\n"," is null, then\r\n            the \"empty\" value should be inferred.\r\n            ":" 是无效的\r\n            应推断“空”值。\r\n            \r\n","\r\n            Look for a type forwarder for the given type in any referenced assemblies, checking any using namespaces in\r\n            the current imports.\r\n            ":"\r\n            在任何引用的组件中寻找给定类型的类型转发器\r\n            当前导入。\r\n            \r\n","\r\n            Allows asking semantic questions about a tree of syntax nodes that did not appear in the original source code.\r\n            Typically, an instance is obtained by a call to SemanticModel.TryGetSpeculativeSemanticModel. \r\n            ":"\r\n            允许询问有关原始源代码中未出现的语法节点树的语义问题。\r\n            通常，通过呼叫semanticmodel.trygetspeculativesemanticmodel获得了一个实例。\r\n            \r\n","\r\n            A Binder converts names in to symbols and syntax nodes into bound trees. It is context\r\n            dependent, relative to a location in source code.\r\n            ":"\r\n            活页夹将名称中的名称转换为符号和语法节点，转换为绑定的树。这是上下文\r\n            依赖，相对于源代码中的位置。\r\n            \r\n","default operator":"默认操作员\r\n","\r\n              Looks up a localized string similar to There is no defined ordering between fields in multiple declarations of partial struct '{0}'. To specify an ordering, all instance fields must be in the same declaration..\r\n            ":"\r\n              查找类似于类似的本地化字符串，在部分结构“ {0}”的多个声明中，字段之间没有定义的排序。要指定订购，所有实例字段必须在同一声明中。\r\n            \r\n","An obsolete parameter. It is unused.":"过时的参数。它没有使用。\r\n","\r\n            Ignore accessibility when resolving well-known type\r\n            members, in particular for generic type arguments\r\n            (e.g.: binding to internal types in the EE).\r\n            ":"\r\n            解决知名类型时忽略可访问性\r\n            成员，尤其是通用类型参数\r\n            （例如：与EE中的内部类型结合）。\r\n            \r\n","Creates a new IfDirectiveTriviaSyntax instance.":"创建一个新的iFirectivtriviaSyntax实例。\r\n","\r\n              Looks up a localized string similar to Tuple element name '{0}' is disallowed at any position..\r\n            ":"\r\n              在任何位置都不允许查找类似于元组元素名称'{0}'的本地化字符串。\r\n            \r\n","\r\n            Compares two anonymous type descriptors, takes into account fields names and types, not locations.\r\n            ":"\r\n            比较两个匿名类型的描述符，以考虑字段名称和类型，而不是位置。\r\n            \r\n","\r\n              Looks up a localized string similar to The CallerLineNumberAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments.\r\n            ":"查找类似于CallerlineNumberAttribute的本地化字符串将无效，因为它适用于不允许可选参数的上下文中使用的成员。\r\n            \r\n","Both partial method declarations must be extension methods or neither may be an extension method":"两种部分方法声明必须是扩展方法，或者不可能是扩展方法\r\n","\r\n              Looks up a localized string similar to Cannot return or a member of parameter '{0}' by reference because it is not a ref or out parameter.\r\n            ":"\r\n              查找类似于无法返回的本地化字符串或通过引用的参数'{0}'的成员，因为它不是ref或out参数。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not return by {3}.\r\n            ":"\r\n              查找类似于“ {0}'的本地化字符串”不实现接口成员'{1}'。 '{2}'无法实现'{1}'，因为它不会通过{3}返回。\r\n            \r\n","SyntaxToken representing the keyword for the kind of the identifier name.":"Syntaxtoken表示标识符名称的关键字。\r\n","\r\n            True if there was an error among the reported diagnostics\r\n            ":"\r\n            如果报告的诊断有错误，则为true\r\n            \r\n","\r\n            An analysis that computes the set of variables that may be used\r\n            before being assigned anywhere within a method.\r\n            ":"\r\n            计算可能使用的变量集的分析\r\n            在方法中的任何地方分配之前。\r\n            \r\n","\r\n            The candidate member was rejected because type inference failed.\r\n            ":"\r\n            候选人成员被拒绝，因为类型推理失败。\r\n            \r\n","\r\n              Looks up a localized string similar to Expression cannot be used in this context because it may indirectly expose variables outside of their declaration scope.\r\n            ":"\r\n              在此上下文中查找类似于表达式的本地化字符串，因为它可能间接地在其声明范围之外露出变量。\r\n            \r\n","Creates a new LineDirectiveTriviaSyntax instance.":"创建一个新的LinedirectiviviaSyntax实例。\r\n","\r\n            Spec section 2.4.2 says that identifiers are compared without regard\r\n            to leading \"@\" characters or unicode formatting characters.  As in dev10,\r\n            this is actually accomplished by dropping such characters during parsing.\r\n            Unfortunately, metadata names can still contain these characters and will\r\n            not be referenceable from source if they do (lookup will fail since the\r\n            characters will have been dropped from the search string).\r\n            See DevDiv #14432 for more.\r\n            ":"\r\n            规格第2.4.2节说，比较了标识符，而无需考虑\r\n            领导“@”字符或Unicode格式化字符。就像在dev10中一样\r\n            这实际上是通过在解析过程中删除此类角色来实现的。\r\n            不幸的是，元数据名称仍然可以包含这些字符，并且将\r\n            如果它们这样做，则无法从源中引用（查找会失败，因为\r\n            字符将从搜索字符串中删除）。\r\n            有关更多信息，请参见Devdiv＃14432。\r\n            \r\n","\r\n            Async-iterator methods use a GetAsyncEnumerator method just like the GetEnumerator of iterator methods.\r\n            But they need to do a bit more work (to reset the dispose mode).\r\n            ":"\r\n            异步 - 列表方法使用getAsyncencenumerator方法，就像迭代器方法的getEnumerator一样。\r\n            但是他们需要做更多的工作（重置处置模式）。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot apply attribute class '{0}' because it is abstract.\r\n            ":"\r\n              查找类似于应用属性类'{0}'的本地化字符串，因为它是抽象的。\r\n            \r\n","\r\n            Use the the parameter types and nullability from _methodSignatureOpt for initial\r\n            parameter state. If false, the signature of _member is used instead.\r\n            ":"\r\n            使用参数类型和_methodsignaturept的无效性作为初始\r\n            参数状态。如果为false，则使用_ ember的签名。\r\n            \r\n"," in script code.\r\n            ":" 在脚本代码中。\r\n            \r\n","Class which represents the syntax node for parenthesized expression.":"代表括号表达式的语法节点的类。\r\n","\r\n              Looks up a localized string similar to System.Void cannot be used from C# -- use typeof(void) to get the void type object.\r\n            ":"\r\n              查找与System类似的本地化字符串。无法从C＃使用void-使用typeof（void）获取void type对象。\r\n            \r\n","Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.":"不允许明确应用“ system.runtime.compilerservices.nulleableattribute”。\r\n","\r\n              Looks up a localized string similar to Cannot emit debug information for a source text without encoding..\r\n            ":"\r\n              在不编码的情况下查找类似于源文本的本地化字符串无法发出调试信息。\r\n            \r\n","Member '{0}' must have a non-null value when exiting.":"退出时，成员'{0}'必须具有非零值。\r\n","Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' exported from module '{3}'.":"类型'{0}'转发到汇编'{1}'与类型'{2}'冲突从模块'{3}'导出。\r\n","Comparison made to same variable":"与同一变量进行比较\r\n","Type is not CLS-compliant because base interface is not CLS-compliant":"类型不符合CLS，因为基本界面不符合CLS\r\n","\r\n            Expression is an out parameter.\r\n            ":"\r\n            表达是一个外参数。\r\n            \r\n","stdin argument '-' is specified, but input has not been redirected from the standard input stream.":"指定了stdin参数' - '，但尚未从标准输入流进行重定向。\r\n","\r\n              Looks up a localized string similar to The given expression never matches the provided pattern..\r\n            ":"\r\n              查找类似于给定表达式的局部字符串永远不匹配所提供的模式。\r\n            \r\n","\r\n            Creates a separated list from a ":"\r\n            从一个分离的列表中创建\r\n","Dictionary<,>":"字典<，>\r\n","\r\n            It's important that this is a set and that enumeration order is deterministic. We loop\r\n            over this list to generate proxies and if we loop out of order this will cause\r\n            non-deterministic compilation, and if we generate duplicate proxies we'll generate\r\n            wasteful code in the best case and incorrect code in the worst.\r\n            ":"\r\n            重要的是，这是一套，枚举顺序是确定性的。我们循环\r\n            在此列表上以生成代理，如果我们循环失败，这将导致\r\n            非确定性汇编，如果我们生成重复的代理，我们将生成\r\n            在最佳情况下，浪费代码和最坏的代码不正确。\r\n            \r\n","Cannot do member lookup in '{0}' because it is a type parameter":"无法在'{0}'中进行成员查找，因为它是类型参数\r\n","Base parameter syntax.":"基本参数语法。\r\n"," Compilation to use ":" 使用的汇编\r\n","\r\n            Returns binder that binds usings and aliases \r\n            ":"\r\n            返回绑定使用和别名的活页夹\r\n            \r\n","\r\n              Looks up a localized string similar to Because this call is not awaited, execution of the current method continues before the call is completed.\r\n            ":"\r\n              查找类似于此呼叫的本地化字符串，在呼叫完成之前继续执行当前方法。\r\n            \r\n","\r\n              Looks up a localized string similar to Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available..\r\n            ":"\r\n              查找类似于破坏者和对象的局部字符串。无法直接调用finalize。考虑致电idisposable.dispose如果可用。\r\n            \r\n","\r\n            Creates a verbatim token with kind IdentifierToken containing the specified text.\r\n            ":"\r\n            使用包含指定文本的词性标识来创建一个逐字图令牌。\r\n            \r\n","\r\n            A map of namespaces immediately contained within this namespace \r\n            mapped by their name (case-sensitively).\r\n            ":"\r\n            立即在此名称空间中包含的名称空间的地图\r\n            用他们的名字映射（案例敏感）。\r\n            \r\n","Cannot convert {0} to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type":"无法将{0}转换为预期的委托类型\r\n","\r\n            Special HasHome for fields. \r\n            Fields have readable homes when they are not constants.\r\n            Fields have writeable homes unless they are readonly and used outside of the constructor.\r\n            ":"\r\n            特殊的田野藏品。\r\n            当田地不是常数时，它们具有可读的房屋。\r\n            田地具有可写的房屋，除非它们被阅读并在构造函数之外使用。\r\n            \r\n","Forwarded type '{0}' conflicts with type declared in primary module of this assembly.":"转发类型'{0}'与此组件的主模块中声明的类型发生冲突。\r\n","\r\n            Should be accessed through ":"\r\n            应该通过\r\n","Cannot assign {0} to an implicitly-typed variable":"无法将{0}分配给隐式型变量\r\n","Item1":"项目1\r\n"," (if any).\r\n            ":" （如果有）。\r\n            \r\n","The value being assigned.":"分配的值。\r\n"," is in a type that derives from the type containing\r\n            ":" 是从包含的类型中衍生的类型\r\n            \r\n","\r\n            Returns a temp which is initialized with lowered-expression.HasValue\r\n            ":"\r\n            返回以降低表达初始化的温度。\r\n            \r\n","\r\n            Get a SemanticModel object that is associated with a constructor initializer that did not appear in\r\n            this source code. This can be used to get detailed semantic information about sub-parts\r\n            of a constructor initializer that did not appear in source code. \r\n            \r\n            NOTE: This will only work in locations where there is already a constructor initializer.\r\n            ":"\r\n            获取与未出现在\r\n            此源代码。这可以用来获取有关子部分的详细语义信息\r\n            未出现在源代码中的构造函数初始化器\r\n            \r\n            注意：这只能在已经有构造函数初始化器的位置工作。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}' is of type '{1}'. A default parameter value of a reference type other than string can only be initialized with null.\r\n            ":"\r\n              查找类似于'{1}'的本地化字符串。字符串以外的参考类型的默认参数值只能用NULL初始化。\r\n            \r\n","The original token that is to be replaced.":"要替换的原始令牌。\r\n","\r\n              Looks up a localized string similar to Cannot create short filename '{0}' when a long filename with the same short filename already exists.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法创建简短的文件名'{0}'当已存在相同短文件名的长文件名时。\r\n            \r\n","\r\n            True if this field has a pointer type.\r\n            ":"\r\n            如果此字段具有指针类型，则为true。\r\n            \r\n"," for the original node.\r\n            The APIs are expected to return new state of the rewritten node, after they apply appropriate\r\n            modifications, if any.\r\n            \r\n            The base class provides default implementation for all APIs, which simply returns the rewritten node. \r\n            ":"对于原始节点。\r\n            API在应用适当的情况下，预计将返回重写节点的新状态\r\n            修改（如果有）。\r\n            \r\n            基类提供了所有API的默认实现，该实现只需返回重写节点即可。\r\n            \r\n","\r\n            Creates a trivia with kind EndOfLineTrivia containing the specified text. Elastic trivia are used to\r\n            denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.\r\n            ":"\r\n            用包含指定文本的善良内传式创建一个琐事。弹性琐事习惯\r\n            表示未通过解析源文本产生的琐事，通常在格式期间没有保留。\r\n            \r\n","A bag where any diagnostics should be output":"应输出任何诊断的袋子\r\n"," to perform substitution\r\n            on types with TypeKind ErrorType.  The general pattern is to use the type map\r\n            to perform substitution on the wrapped type, if any, and then construct a new\r\n            error type symbol from the result (if there was a change).\r\n            ":" 执行替代\r\n            在具有Typekind错误类型的类型上。一般模式是使用类型地图\r\n            在包装类型上执行替换（如果有），然后构建一个新的\r\n            结果符号来自结果（如果有更改）。\r\n            \r\n","Creates a new ArrayTypeSyntax instance.":"创建一个新的arrayTypesyntax实例。\r\n","\r\n              Looks up a localized string similar to '{0}': type must be '{2}' to match overridden member '{1}'.\r\n            ":"\r\n              查找类似于'{0}'：类型必须为'{2}'的本地化字符串才能匹配覆盖成员'{1}'。\r\n            \r\n","SetResult":"setResult\r\n","This language feature ('{0}') is not yet implemented.":"此语言功能（'{0}'）尚未实现。\r\n","'{0}': cannot override because '{1}' does not have an overridable get accessor":"'{0}'：不能覆盖，因为'{1}'没有润饰的登录器\r\n","\r\n             A tree of binary operators for tuple comparisons.\r\n            \r\n             For `(a, (b, c)) == (d, (e, f))` we'll hold a Multiple with two elements.\r\n             The first element is a Single (describing the binary operator and conversions that are involved in `a == d`).\r\n             The second element is a Multiple containing two Singles (one for the `b == e` comparison and the other for `c == f`).\r\n             ":"\r\n             二进制操作员的树，用于元组比较。\r\n            \r\n             对于`（a，（b，c））==（d，（e，f））`我们将持有一个具有两个元素的倍数。\r\n             第一个元素是单个元素（描述了`a == d`）。\r\n             第二个元素是包含两个单曲的多个元素（一个用于`b == e`比较，另一个用于`c == f`）。\r\n             \r\n","\r\n            Returns a serializable object that is used for displaying this expression in a diagnostic message.\r\n            ":"\r\n            返回一个可序列化对象，用于在诊断消息中显示此表达式。\r\n            \r\n","\r\n            Combines paths with the same semantics as ":"\r\n            将路径与与相同语义的路径结合在一起\r\n","\r\n            Return true iff the method contains user code.\r\n            ":"\r\n            返回True Iff该方法包含用户代码。\r\n            \r\n","Type parameter constraint clause.":"类型参数约束子句。\r\n","\r\n              Looks up a localized string similar to This async method lacks 'await' operators and will run synchronously. Consider using the 'await' operator to await non-blocking API calls, or 'await Task.Run(...)' to do CPU-bound work on a background thread..\r\n            ":"\r\n              查找类似于此异步方法的本地化字符串缺乏“等待”操作员，并且会同步运行。考虑使用“等待”运算符等待非阻止API调用，或“等待任务。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot open '{0}' for writing -- '{1}'.\r\n            ":"查找类似于无法打开“ {0}”的本地化字符串进行写作 - '{1}'。\r\n            \r\n","\r\n              Looks up a localized string similar to #r is only allowed in scripts.\r\n            ":"\r\n              在脚本中仅允许查找类似于#R的本地化字符串。\r\n            \r\n","\r\n            Produce a random value set with the given expected size for testing.\r\n            ":"\r\n            产生一个随机值设置，带有给定的预期大小进行测试。\r\n            \r\n","\r\n            Generate a list containing the given field and all dependencies\r\n            of that field that require evaluation. The list is ordered by\r\n            dependencies, with fields with no dependencies first. Cycles are\r\n            broken at the first field lexically in the cycle. If multiple threads\r\n            call this method with the same field, the order of the fields\r\n            returned should be the same, although some fields may be missing\r\n            from the lists in some threads as other threads evaluate fields.\r\n            ":"\r\n            生成包含给定字段和所有依赖项的列表\r\n            需要评估的领域。该列表由\r\n            依赖项，首先没有依赖项的字段。周期是\r\n            在周期中的第一个字段在第一个字段中折断。如果多个线程\r\n            用同一字段调用此方法，字段的顺序\r\n            返回应该相同，尽管可能缺少某些字段\r\n            从某些线程中的列表中，其他线程评估字段。\r\n            \r\n","\r\n            Implements visitor pattern.\r\n            ":"\r\n            实施访客模式。\r\n            \r\n","The xml text value.":"XML文本值。\r\n","\r\n              Looks up a localized string similar to The Conditional attribute is not valid on '{0}' because it is a constructor, destructor, operator, or explicit interface implementation.\r\n            ":"\r\n              在“ {0}”上查找类似于条件属性的本地化字符串在“ {0}”上无效，因为它是构造函数，驱动器，操作员或显式接口实现。\r\n            \r\n","Syntax tree should be created from a submission.":"语法树应从提交中创建。\r\n","The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion or type parameter conversion from '{3}' to '{1}'.":"类型'{3}'在通用类型或方法'{0}'中不能用作类型参数'{2}'。从“ {3}”到'{1}'没有拳击转换或类型参数转换。\r\n","\r\n            C# language version 1\r\n            ":"\r\n            C＃语言版本1\r\n            \r\n","Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.":"退出构造函数时，不可用的字段必须包含非零值。考虑宣布为无效。\r\n","Cannot pass the range variable '{0}' as an out or ref parameter":"无法将范围变量'{0}'作为out或ref参数\r\n","End-of-file found, '*/' expected":"发现末期的'*/'预期\r\n","Synthesized parameters to add to destination method.":"合成的参数要添加到目标方法。\r\n","this.x++":"this.x ++\r\n","Class '{0}' cannot have multiple base classes: '{1}' and '{2}'":"类'{0}'不能具有多个基类：'{1}'和'{2}'\r\n","\r\n            Wrap a given expression e into a block as either { e; } or { return e; } \r\n            Shared between lambda and expression-bodied method binding.\r\n            ":"\r\n            将给定的表达式e包裹在一个块中{e; }或{返回e; }\r\n            在lambda和表达体现的方法结合之间共享。\r\n            \r\n","Called when the visitor visits a InterpolationSyntax node.":"当访问者访问interpolationsyntax节点时调用。\r\n","\r\n            Get the static container for closures or create one if one doesn't already exist.\r\n            ":"\r\n            获取静态容器以进行关闭，或者如果不存在，则创建一个容器。\r\n            \r\n","\r\n            Returns the RefKind if the expression represents a symbol\r\n            that has a RefKind. This method is ILLEGAL to call for\r\n            other expressions.\r\n            ":"如果表达式表示符号\r\n            有一个摘要。这种方法是非法的\r\n            其他表达方式。\r\n            \r\n","\r\n            Parse the custom cref syntax for a named member (method, property, etc),\r\n            an indexer, an overloadable operator, or a user-defined conversion.\r\n            ":"\r\n            解析命名成员（方法，属性等）的自定义CREF语法，\r\n            索引器，可超载运算符或用户定义的转换。\r\n            \r\n","An expression tree lambda may not contain a null propagating operator.":"表达树lambda可能不包含零繁殖操作员。\r\n","\r\n            Mapping from variable to slot.\r\n            ":"\r\n            从变量到插槽的映射。\r\n            \r\n","ExpressionSyntax node representing the expression enclosed within the parenthesis.":"表示括号内包含的表达式的表达式元素节点。\r\n","XML comment is not placed on a valid language element":"XML评论未在有效的语言元素上发表\r\n","\r\n            but does not throw on null paths or paths with invalid characters.\r\n            ":"\r\n            但是不会在无效字符上抛弃无效的路径或路径。\r\n            \r\n","Fixed size buffers must have a length greater than zero":"固定尺寸缓冲区的长度必须大于零\r\n","SyntaxToken representing the open brace.":"Syntaxtoken代表开放式支撑。\r\n","The type or namespace name '{0}' could not be found (are you missing a using directive or an assembly reference?)":"找不到类型或名称空间名称'{0}'（您是否缺少使用指令或汇编引用？）\r\n","\r\n              Looks up a localized string similar to The params parameter must be a single dimensional array.\r\n            ":"\r\n              查找类似于参数的本地化字符串必须是单个维数组。\r\n            \r\n","\r\n            These parameters can potentially be targetted by an attribute specified in source code. \r\n            As an optimization we distinguish simple parameters (no attributes, no modifiers, etc.) and complex parameters.\r\n            ":"\r\n            这些参数可能会被源代码中指定的属性靶向。\r\n            作为优化，我们区分简单参数（无属性，无修饰符等）和复杂参数。\r\n            \r\n","Called when the visitor visits a StackAllocArrayCreationExpressionSyntax node.":"当访问者访问stackallocarroyCreationexpressionsyntax节点时，请致电。\r\n","\r\n            Return to the caller the set of pending return statements.\r\n            ":"\r\n            返回呼叫者待处理的返回语句集。\r\n            \r\n","\r\n            Returns true if this symbol represents a constructor of a script class.\r\n            ":"\r\n            如果此符号代表脚本类的构造函数，则返回true。\r\n            \r\n","\r\n            Returns what kind of extent: Module, Assembly, or Compilation.\r\n            ":"\r\n            返回多大程度：模块，组装或编译。\r\n            \r\n","Partial methods with only a defining declaration or removed conditional methods cannot be used in expression trees":"只有定义声明或删除条件方法的部分方法不能用于表达式树中\r\n","\r\n            Translate the pattern of an is-pattern expression.\r\n            ":"\r\n            翻译IS-Pattern表达式的模式。\r\n            \r\n"," because the language defines no\r\n            relational operators for it; such a set can be formed only by including explicitly mentioned\r\n            members (or the inverse, excluding them, by complementing the set).\r\n            ":"因为语言定义不\r\n            关系运营商；这样的集合只能通过包括明确提及的\r\n            成员（或通过补充该集合的逆向，不包括它们）。\r\n            \r\n","True if the expression contains errors.":"如果表达式包含错误，则为正确。\r\n","\r\n            Represents a field in a RetargetingModuleSymbol. Essentially this is a wrapper around \r\n            another FieldSymbol that is responsible for retargeting symbols from one assembly to another. \r\n            It can retarget symbols for multiple assemblies at the same time.\r\n            ":"\r\n            代表retargetingModulesymbol中的字段。本质上，这是周围的包装纸\r\n            另一个负责从一个组件重新定位符号到另一个组件的fieldSymbol。\r\n            它可以同时重新定位多个组件。\r\n            \r\n"," from specified metadata. \r\n            ":" 来自指定的元数据。\r\n            \r\n","Cannot access protected member '{0}' via a qualifier of type '{1}'; the qualifier must be of type '{2}' (or derived from it)":"无法通过类型'{1}'的预选赛访问受保护的成员'{0}';预选赛必须为“ {2}”类型（或从中派生）\r\n","\r\n              Looks up a localized string similar to Array type specifier, [], must appear before parameter name.\r\n            ":"\r\n              查找类似于数组类型指示符[]的本地化字符串必须出现在参数名称之前。\r\n            \r\n","The bound node for the expansion of the range variable":"扩展范围变量的结合节点\r\n","Invalid expression term '{0}'":"无效的表达术语'{0}'\r\n","A tuple of the forwarded to assemblies.":"转发到集会的元组。\r\n","\r\n            Creates a token with kind IdentifierToken containing the specified text.\r\n            ":"\r\n            创建一个包含指定文本的属性标识的令牌。\r\n            \r\n","Gets the type keyword token (\"class\", \"struct\", \"interface\", \"record\").":"获取类型关键字令牌（“类”，“ struct”，“ interface”，“ record”）。\r\n","\r\n            There are two types of errors we can encounter when trying to scan out an interpolated string (and its\r\n            interpolations).  The first are true syntax errors where we do not know what it is going on and have no\r\n            good strategy to get back on track.  This happens when we see things in the interpolation we truly do\r\n            not know what to do with, or when we find we've gotten into an unbalanced state with the bracket pairs\r\n            we're consuming.  In this case, we will often choose to bail out rather than go on and potentially make\r\n            things worse.\r\n            ":"\r\n            试图扫描插值字符串时，我们可以遇到两种类型的错误（及其\r\n            插值）。第一个是真实的语法错误，我们不知道发生了什么并且没有\r\n            重回正轨的好策略。当我们在插值中看到事情时，就会发生这种情况\r\n            不知道该怎么办，或者当我们发现我们已经与括号对陷入不平衡状态\r\n            我们正在消费。在这种情况下，我们通常会选择救助而不是继续前进\r\n            情况更糟。\r\n            \r\n","True if the graph was acyclic.":"如果图为无环，则为正确。\r\n","\r\n            In cases a type could not be found because of ambiguity, we return two of the candidates that caused the ambiguity.\r\n            ":"\r\n            在由于歧义而找不到类型的情况下，我们返回引起歧义的两名候选人。\r\n            \r\n","'{0}': type used in a using statement must be implicitly convertible to 'System.IDisposable'. Did you mean 'await using' rather than 'using'?":"'{0}'：在使用语句中使用的类型必须隐式转换为“ system.idisposable”。您的意思是“等待使用”而不是“使用”？\r\n"," corresponding to the given reference or null if there is none.":" 如果没有，则对应给定的参考或null。\r\n","\r\n              Looks up a localized string similar to Expected 'disable' or 'restore' after #pragma warning.\r\n            ":"\r\n              在#pragma警告后查找类似于预期的“禁用”或“还原”的本地化字符串。\r\n            \r\n","\r\n            Creates an empty separated list.\r\n            ":"\r\n            创建一个空的分开列表。\r\n            \r\n","Called when the visitor visits a SkippedTokensTriviaSyntax node.":"当访客访问跳过的tokenstriviasyntax节点时打电话。\r\n","\r\n              Looks up a localized string similar to Length of String constant exceeds current memory limit.  Try splitting the string into multiple constants..\r\n            ":"\r\n              查找类似于字符串常数长度的本地化字符串超过当前内存限制。尝试将字符串分为多个常数。\r\n            \r\n","\r\n            WARN WARN WARN: If you access this via the semantic model, things will break (since the initializer may not have been bound).\r\n            \r\n            Whether or not this local is pinned (i.e. the type will be emitted with the \"pinned\" modifier).\r\n            ":"\r\n            警告警告：如果您通过语义模型访问此内容，情况将会破裂（因为初始化器可能没有绑定）。\r\n            \r\n            是否固定该局部性（即，将使用“固定”修饰符发射类型）。\r\n            \r\n","\r\n            Returns all members of the specific kind, starting at the optional offset.\r\n            Members of the same kind are assumed to be contiguous.\r\n            ":"\r\n            从可选偏移开始返回特定类型的所有成员。\r\n            假定同类成员是连续的。\r\n            \r\n"," per the given options. For example, the\r\n            severity may be escalated, or the ":" 根据给定的选项。例如，\r\n            严重程度可能会升级，或者\r\n","\r\n            Returns false because local variable can't be defined externally.\r\n            ":"\r\n            返回false，因为无法外部定义局部变量。\r\n            \r\n","\r\n            Gets type information about a constructor initializer.\r\n            ":"\r\n            获取有关构造函数初始化器的类型信息。\r\n            \r\n"," that should be used when parsing generated files.":" 解析生成的文件时应使用。\r\n","\r\n            For scenarios such as overriding with differing ref kinds (such as out vs in or ref)\r\n            we need to compare function pointer parameters assuming that Ref matches RefReadonly/In\r\n            and Out. This is done because you cannot overload on ref vs out vs in in regular method\r\n            signatures, and we are disallowing similar overloads in source with function pointers.\r\n            ":"\r\n            对于诸如不同涉及的裁判类型（例如Out vs in cor in cor in of或ref）之类的场景\r\n            我们需要比较函数指针参数，假设参考匹配refreadonly/in\r\n            和出去。之所以这样做，是因为您不能在常规方法中超负荷vs vs vs vs vs vs\r\n            签名，我们正在使用功能指针中的源中类似的过载。\r\n            \r\n","\r\n            Returns an array of assembly identities for assemblies referenced by this module.\r\n            Items at the same position from GetReferencedAssemblies and from GetReferencedAssemblySymbols \r\n            should correspond to each other.\r\n            \r\n            The array and its content is provided by ReferenceManager and must not be modified.\r\n            ":"\r\n            返回该模块引用的汇编数组。\r\n            从GetReferendedAssemblies和GetReferendedAssemblysymbols处于同一位置的项目\r\n            应彼此对应。\r\n            \r\n            数组及其内容由ReferenceManager提供，不得修改。\r\n            \r\n","Creates a new SubpatternSyntax instance.":"创建一个新的subpatternsnyntax实例。\r\n","\r\n            Learn from any constant null patterns appearing in the pattern.\r\n            ":"\r\n            从模式中出现的任何常量null模式中学习。\r\n            \r\n","\r\n            Get a SemanticModel object that is associated with a cref syntax node that did not appear in\r\n            this source code. This can be used to get detailed semantic information about sub-parts\r\n            of a cref syntax that did not appear in source code.\r\n            ":"\r\n            获取与未出现在\r\n            此源代码。这可以用来获取有关子部分的详细语义信息\r\n            未出现在源代码中的CREF语法。\r\n            \r\n","Called when the visitor visits a PragmaWarningDirectiveTriviaSyntax node.":"当访客访问pragmawarningDirectivetriviasyntax节点时，请致电。\r\n","Creates a new DeclarationPatternSyntax instance.":"创建一个新的声明patternsyntax实例。\r\n","\r\n            For the type ":"\r\n            对于类型\r\n","\r\n            Called at the point in a loop where the backwards branch would go to.\r\n            ":"\r\n            在向后分支将进入的循环中的点。\r\n            \r\n","Gets the members declaration list.":"获取会员声明列表。\r\n","Include tag is invalid":"包括标签是无效的\r\n","\r\n            Exists to copy constraints from the corresponding type parameter of an overridden method.\r\n            ":"\r\n            存在从覆盖方法的相应类型参数中复制约束。\r\n            \r\n","the rewritten block for the method (with a return statement possibly inserted)":"该方法的重写块（可能插入返回语句）\r\n","SyntaxTree resulted from a #load directive and cannot be removed or replaced directly.":"语法是由#load指令产生的，无法直接删除或直接替换。\r\n","\r\n              Looks up a localized string similar to Cannot return an expression of type 'void'.\r\n            ":"\r\n              查找类似于类似的本地化字符串无法返回“ void”类型的表达式。\r\n            \r\n","\r\n            Unlike in VB, we are not allowing retargeting symbols.  This method is used as an approximation\r\n            for ":"\r\n            与VB不同，我们不允许重新定位符号。该方法用作近似\r\n            为了\r\n","\r\n              Looks up a localized string similar to It is not legal to use nullable reference type '{0}?' in an as expression; use the underlying type '{0}' instead..\r\n            ":"\r\n              查找与其类似的本地化字符串，不合法地使用无效的参考类型“ {0}？”在AS表达中；代替使用基础类型'{0}'。\r\n            \r\n","\r\n            Returns true if this symbol can be referenced by its name in code. Examples of symbols\r\n            that cannot be referenced by name are:\r\n               constructors, destructors, operators, explicit interface implementations,\r\n               accessor methods for properties and events, array types.\r\n            ":"\r\n            如果可以在代码中引用此符号的名称，则返回true。符号的示例\r\n            不能用名称引用的是：\r\n               构造函数，破坏者，操作员，显式接口实现，\r\n               属性和事件的访问方法，数组类型。\r\n            \r\n","Stackalloc in nested expressions":"嵌套表达中的stackalloc\r\n","Creates a new PointerTypeSyntax instance.":"创建一个新的pointertypesyntax实例。\r\n","\r\n            Returns first or a modified version of first with merged dynamic flags from both types.\r\n            ":"\r\n            首先返回或修改版本的第一个版本，两种类型的合并动态标志。\r\n            \r\n","\r\n            Bind and return a single type parameter constraint clause.\r\n            ":"\r\n            绑定并返回单个类型的参数约束子句。\r\n            \r\n","foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation":"foreach语句无法在类型'{0}'的变量上操作，因为它实现了'{1}'的多个实例化;尝试铸造特定的接口实例化\r\n","Mix declarations and variables in deconstruction":"在解构中混合声明和变量\r\n","\r\n              Looks up a localized string similar to '{0}' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter..\r\n            ":"\r\n              查找类似于“ {0}”的本地化字符串不是有效的约束。用作约束的类型必须是接口，非密封类或类型参数。\r\n            \r\n","Called when the visitor visits a RefTypeSyntax node.":"当访问者访问reftypesyntax节点时，请致电。\r\n","\r\n            Note that NamedTypeSymbol, if available, is the type that is associated with the binder \r\n            that found the 'symbol', not the inner-most type that contains the access to the\r\n            'symbol'.\r\n            ":"\r\n            请注意，命名为typesymbol（如果有）是与粘合剂关联的类型\r\n            找到“符号”，而不是包含对访问权限的内部类型\r\n            '象征'。\r\n            \r\n","For type '{0}' to be used as an AsyncMethodBuilder for type '{1}', its Task property should return type '{1}' instead of type '{2}'.":"对于类型的'{0}'用作类型'{1}'的AsyncMethodBuilder，其任务属性应返回类型'{1}'而不是类型'{2}'。\r\n",",\r\n            meaning that some trailing dimensions don't have the lower bound specified.\r\n            The most common case is all dimensions are zero bound - a default array is returned in this case.\r\n            ":"，，，，\r\n            这意味着某些尾随尺寸没有指定的下限。\r\n            最常见的情况是所有尺寸均为零键 - 在这种情况下，返回默认数组。\r\n            \r\n","Top-level statements":"顶级语句\r\n","\r\n            Returns true for synthesized symbols which generate synthesized body in lowered form\r\n            ":"\r\n            返回的综合符号返回，这些符号以降低形式产生合成的身体\r\n            \r\n","SyntaxToken representing the omitted array size expression.":"Syntaxtoken表示省略的数组大小表达式。\r\n","\r\n              Looks up a localized string similar to The name '_' refers to the constant, not the discard pattern. Use 'var _' to discard the value, or '@_' to refer to a constant by that name..\r\n            ":"\r\n              查找类似于名称“ _”的本地化字符串是指常数，而不是丢弃模式。使用'var _'丢弃值，或者“ @_”来指代常数。\r\n            \r\n","\r\n              Looks up a localized string similar to Static member '{0}' cannot be marked 'readonly'..\r\n            ":"\r\n              查找类似于静态成员'{0}'的本地化字符串，无法标记为'ReadOnly'..\r\n            \r\n","\r\n            The syntax node(s) that declared the symbol. If the symbol was declared in metadata or\r\n            was implicitly declared, returns an empty read-only array.\r\n            ":"\r\n            声明为符号的语法节点。如果该符号在元数据或\r\n            被隐式声明，返回一个空的只读数组。\r\n            \r\n","A syntax node that represents a parsed attribute. This syntax node\r\n            need not and typically does not appear in the source code referred to SemanticModel instance.":"表示解析属性的语法节点。此语法节点\r\n            不需要，通常不会出现在引用SemanticModel实例的源代码中。\r\n","\r\n            We have a decision dag whose input is a tuple literal, and the decision dag does not need the tuple itself.\r\n            We rewrite the decision dag into one which doesn't touch the tuple, but instead works directly with the\r\n            values that have been stored in temps. This permits the caller to avoid creation of the tuple object\r\n            itself. We also emit assignments of the tuple values into their corresponding temps.\r\n            ":"\r\n            我们有一个决策DAG，其输入是元组的字面意思，而决策DAG不需要元组本身。\r\n            我们将决定DAG重写为不触及元组的决策，而是直接与\r\n            存储在温度中的值。这允许呼叫者避免创建元组对象\r\n            本身。我们还将元组值的分配发射到其相应的温度中。\r\n            \r\n","\r\n               Looks up a localized string similar to \r\n                                          Visual C# Compiler Options\r\n            \r\n                                    - OUTPUT FILES -\r\n             /out:<file>                   Specify output file name (default: base name of \r\n                                           file with main class or first file)\r\n             /target:exe                   Build a console executable (default) (Short \r\n                                           form: /t:exe)\r\n             /target:winexe                Build a Windows executable (Short form: \r\n                                           /t:winexe)\r\n             /target:library     [rest of string was truncated]\";.\r\n             ":"\r\n               查找类似于\r\n                                          视觉C＃编译器选项\r\n            \r\n                                     - 输出文件 - \r\n             /out：<file>指定输出文件名（默认值：\r\n                                           带有主类或第一个文件的文件）\r\n             /target：EXE构建控制台可执行文件（默认）（简短）\r\n                                           表格： /t：exe）\r\n             /target：Winexe构建Windows可执行文件（简短表格：\r\n                                           /t：winexe）\r\n             /target：库[弦的其余部分被截断];。\r\n             \r\n"," parameter contains value corresponding to the \r\n            left node, or zero, which will trigger inference. Upon return, it will \r\n            be adjusted to correspond future result node.\r\n            ":" 参数包含与 \r\n            左节点，或零，这将触发推理。 回来后，它会 \r\n            被调整以对应于将来的结果节点。\r\n            \r\n","\r\n            Backing field for the map from a local NoPia type to corresponding canonical type.\r\n            ":"\r\n            地图从本地NOPIA类型到相应的规范类型的备份字段。\r\n            \r\n","\r\n              Looks up a localized string similar to Use of unassigned local variable '{0}'.\r\n            ":"\r\n              查找类似于使用未分配的本地变量'{0}'的本地化字符串。\r\n            \r\n","\r\n             Takes the expression for the current value of the iteration variable and either\r\n             (1) assigns it into a local, or\r\n             (2) deconstructs it into multiple locals (if there is a deconstruct step).\r\n            \r\n             Produces ":"\r\n             以迭代变量的当前值的表达\r\n             （1）将其分配给本地或\r\n             （2）将其解构为多个当地人（如果有一个解构步骤）。\r\n            \r\n             生产\r\n","\r\n            Lower \"using [await] (expression) statement\" to a try-finally block.\r\n            ":"\r\n            降低“使用[等待]（表达式）语句”的较低限制。\r\n            \r\n","\r\n              Looks up a localized string similar to Each linked resource and module must have a unique filename. Filename '{0}' is specified more than once in this assembly.\r\n            ":"\r\n              查找类似于每个链接资源的本地化字符串，模块必须具有唯一的文件名。在此汇编中，多次指定了一个不止一次的文件名'{0}'。\r\n            \r\n","\r\n            Internal for test purposes only\r\n            ":"\r\n            内部仅出于测试目的\r\n            \r\n","\r\n            Given an initializer expression infer the name of anonymous property.\r\n            Returns default(SyntaxToken) if unsuccessful\r\n            ":"\r\n            给定一个初始器表达式推断匿名属性的名称。\r\n            如果不成功\r\n            \r\n","\r\n            Determines whether an expression is a known string concat operator (with or without a subsequent ?? \"\"), and extracts\r\n            its args if so.\r\n            ":"\r\n            确定表达式是否是已知的字符串cont仪（有或不带有后续的？”），然后提取提取\r\n            如果是这样，它是arg。\r\n            \r\n","Invalid hash algorithm name: '{0}'":"无效哈希算法名称：'{0}'\r\n","\r\n            Returns the constraint clause for the given type parameter.\r\n            ":"\r\n            返回给定类型参数的约束子句。\r\n            \r\n","\r\n            In the expanded form of a compound assignment (or increment/decrement), the LHS appears multiple times.\r\n            If we aren't careful, this can result in repeated side-effects.  This creates (ordered) temps for all of the\r\n            subexpressions that could result in side-effects and returns a side-effect-free expression that can be used\r\n            in place of the LHS in the expanded form.\r\n            ":"\r\n            在复合分配的扩展形式（或增量/减少）中，LHS出现多次。\r\n            如果我们不小心，这可能会导致重复的副作用。这会为所有这些创建（有序）温度\r\n            可能导致副作用并返回可以使用的无副作用表达式的子表达\r\n            以扩展形式代替LHS。\r\n            \r\n","\r\n            NOTE: Even there is a single viable symbol, it may be an error type symbol.\r\n            ":"\r\n            注意：即使有一个可行的符号，也可能是错误类型符号。\r\n            \r\n","\r\n              Looks up a localized string similar to Anonymous methods, lambda expressions, and query expressions inside structs cannot access instance members of 'this'. Consider copying 'this' to a local variable outside the anonymous method, lambda expression or query expression and using the local instead..\r\n            ":"\r\n              查找类似于匿名方法，lambda表达式和结构内部的查询表达式类似的本地化字符串，无法访问“ this”的实例成员。考虑将“此”复制到匿名方法之外的局部变量，lambda表达式或查询表达式之外，然后使用本地变量。\r\n            \r\n","\r\n            To create literal expression for IOperation, set localRewriter to null.\r\n            ":"\r\n            要创建ioperation的文字表达式，请将localrewriter设置为null。\r\n            \r\n","Parameter {0} is declared as type '{1}{2}' but should be '{3}{4}'":"参数{0}被声明为类型'{1} {2}'，但应为'{3} {4}'\r\n","\r\n              Looks up a localized string similar to The body of '{0}' cannot be an iterator block because '{1}' is not an iterator interface type.\r\n            ":"\r\n              查找类似于“ {0}”主体的本地化字符串不能是迭代器块，因为'{1}'不是迭代器接口类型。\r\n            \r\n","Type defines operator == or operator != but does not override Object.Equals(object o)":"类型定义操作员==或操作员！=但不覆盖对象。Equals.equals（Object O）\r\n","Argument of type '{0}' cannot be used for parameter '{2}' of type '{1}' in '{3}' due to differences in the nullability of reference types.":"由于参考类型的删除性差异，因此不能将类型'{0}'的类型用于'{3}'in'{3}'的type'{1}'的参数使用。\r\n","\r\n            The type of the expression represented by the syntax node. For expressions that do not\r\n            have a type, null is returned. If the type could not be determined due to an error, than\r\n            an object derived from ErrorTypeSymbol is returned.\r\n            ":"\r\n            语法节点表示的表达式类型。对于不表达的表达\r\n            有类型，返回null。如果由于错误而无法确定类型，则\r\n            返回源自errortypesymbol的对象。\r\n            \r\n","Indicates whether to bind the expression as a full expression,\r\n            or as a type or namespace.":"指示是否将表达式绑定为完整表达式，\r\n            或类型或名称空间。\r\n","The number of threads currently waiting in ":"当前等待的线程数\r\n","\r\n              Looks up a localized string similar to An expression tree may not contain a switch expression..\r\n            ":"\r\n              查找类似于表达树的本地化字符串可能不包含开关表达式。\r\n            \r\n","Nullability of reference types in return type doesn't match implemented member (possibly because of nullability attributes).":"返回类型中参考类型的无效性不匹配实现的成员（可能是由于无效属性）。\r\n","\r\n            Returns a value indicating whether this compilation has a member that needs IsReadOnlyAttribute to be generated during emit phase.\r\n            The value is set during binding the symbols that need that attribute, and is frozen on first trial to get it.\r\n            Freezing is needed to make sure that nothing tries to modify the value after the value is read.\r\n            ":"\r\n            返回一个值，指示该汇编是否具有需要在EMIT阶段生成的成员。\r\n            该值是在绑定需要属性的符号期间设置的，并在第一次试验中冻结以获取它。\r\n            需要冻结以确保在读取值后没有试图修改值。\r\n            \r\n"," and we have an IFoo with a different arity or accessibility \r\n            (e.g. ":" 而且我们有一个不同的Arity或可访问性\r\n            （例如。\r\n","\r\n            Should the format of error messages include the line and column of\r\n            the end of the offending text.\r\n            ":"\r\n            错误消息的格式是否应包括\r\n            有问题的文字的结尾。\r\n            \r\n","\r\n            Remove \"*/\" and any following text, if it is present.\r\n            ":"\r\n            如果存在，请删除“*/”和以下任何文本。\r\n            \r\n","\r\n            Method to early decode certain well-known attributes which can be queried by the binder.\r\n            This method is called during attribute binding after we have bound the attribute types for all attributes,\r\n            but haven't yet bound the attribute arguments/attribute constructor.\r\n            Early decoding certain well-known attributes enables the binder to use this decoded information on this symbol\r\n            when binding the attribute arguments/attribute constructor without causing attribute binding cycle.\r\n            ":"早期解码某些已知属性的方法可以由粘合剂查询。\r\n            在我们绑定所有属性的属性类型之后，在属性绑定期间调用此方法\r\n            但是尚未绑定属性参数/属性构造函数。\r\n            早期解码某些众所周知的属性使粘合剂能够在此符号上使用此解码信息\r\n            当绑定属性参数/属性构造函数时，而不会引起属性结合周期。\r\n            \r\n","\r\n            Must remain in sync with ":"\r\n            必须保持与\r\n","\r\n              Looks up a localized string similar to A declaration of a by-reference variable must have an initializer.\r\n            ":"\r\n              查找类似于副参考变量声明的本地化字符串必须具有初始化器。\r\n            \r\n","iterators":"迭代器\r\n","\r\n            Assumes continue, break, etc have already been rewritten to gotos.\r\n            ":"\r\n            假设继续，中断等已重写为GoTOS。\r\n            \r\n","\r\n            Labels reachable from within this frame without invoking its finally. \r\n            null if there are none such labels.\r\n            ":"\r\n            可从此框架内到达的标签，而无需最终调用。\r\n            null如果没有这样的标签。\r\n            \r\n","\r\n              Looks up a localized string similar to The 'new()' constraint cannot be used with the 'struct' constraint.\r\n            ":"\r\n              查找类似于“ new（）”约束的本地化字符串不能与“ struct”约束一起使用。\r\n            \r\n","Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'":"不一致的可访问性：基类'{1}'比class'{0}'易于访问\r\n","\r\n            The candidate member was rejected because its calling convention did not match the function pointer\r\n            calling convention.\r\n            ":"\r\n            候选人成员被拒绝，因为其调用约定与功能指针不符\r\n            召集惯例。\r\n            \r\n"," is applied.\r\n            If so, it transforms the given ":" 被申请;被应用。\r\n            如果是这样，它会改变给定的\r\n","\r\n            Build and add synthesized attributes for this symbol.\r\n            ":"\r\n            为此符号构建并添加综合属性。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot deconstruct dynamic objects..\r\n            ":"\r\n              查找类似于无法解构动态对象的本地化字符串。\r\n            \r\n","Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'":"操作员'{0}'不能应用于类型'{1}'和'{2}'的操作数\r\n","\r\n            If the operator represents lifted equality, then constant value true if both arguments have constant\r\n            value null, constant value false if exactly one argument has constant value null, and null otherwise.\r\n            If the operator represents lifted inequality, then constant value false if both arguments have constant\r\n            value null, constant value true if exactly one argument has constant value null, and null otherwise.\r\n            ":"\r\n            如果运算符表示相等，则如果两个参数都具有常量，则常量值true\r\n            值null，如果只有一个参数具有常量值null，则为常量值false，否则为null。\r\n            如果运算符表示不等式，则如果两个参数都具有常量，则常量值为false\r\n            值null，如果只有一个参数具有常量值null，则常量值true，否则为null。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot return a parameter by reference '{0}' because it is not a ref or out parameter.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法通过引用'{0}'返回参数，因为它不是ref或out参数。\r\n            \r\n","\r\n            Some kinds of methods are never considered hidden by methods, properties, or types\r\n            (constructors, destructors, operators, conversions, and accessors).\r\n            ":"\r\n            某些方法从不被方法，属性或类型隐藏\r\n            （构造函数，破坏者，操作员，转换和登录器）。\r\n            \r\n","The version of Windows PDB writer is older than required: '{0}'":"Windows PDB Writer的版本比所需的年龄要古老：'{0}'\r\n","A list of display parts.":"显示部分列表。\r\n","\r\n              Looks up a localized string similar to Cannot forward type '{0}' because it is a nested type of '{1}'.\r\n            ":"\r\n              查找类似于无法转发类型'{0}'的本地化字符串，因为它是'{1}'的嵌套类型。\r\n            \r\n","Set of unique attribute types applied to the symbol":"应用于符号的唯一属性类型集\r\n","\r\n            Translate a numeric value of type ":"\r\n            翻译类型的数值\r\n","directory does not exist":"目录不存在\r\n","\r\n               Looks up a localized string similar to This warning is caused when a catch() block has no specified exception type after a catch (System.Exception e) block. The warning advises that the catch() block will not catch any exceptions.\r\n            \r\n            A catch() block after a catch (System.Exception e) block can catch non-CLS exceptions if the RuntimeCompatibilityAttribute is set to false in the AssemblyInfo.cs file: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. If this attribute is not set explicitly to false, all thrown non-CLS excep [rest of string was truncated]\";.\r\n             ":"\r\n               查找类似于此警告的本地化字符串是在catch（）块没有指定的异常类型（system.exception e）块后引起的。警告建议catch（）块不会捕获任何例外。\r\n            \r\n            如果runtimeCompatibilityAttribute设置为false在assemblyInfo.cs文件中，请捕获（system.Exception e）块后的catch（System.Exception e）块后可以捕获非CLS异常。如果此属性未明确设置为false，则所有抛出的非CLS EXCEP [cluncep of String tencep];。\r\n             \r\n","\r\n            Gets a list of method or indexed property symbols for a syntax node. This is overridden by various specializations of SemanticModel.\r\n            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named\r\n            argument nodes have been handled.\r\n            ":"\r\n            获取语​​法节点的方法或索引属性符号的列表。 Semanticmodel的各种专业都覆盖了这一点。\r\n            它可以假设checksyntaxnode和cangetSemanticinfo已经被调用，以及\r\n            论证节点已被处理。\r\n            \r\n","Nullability of reference types in type of parameter '{0}' doesn't match overridden member.":"参数类型中的参考类型的无效性'{0}'不匹配被覆盖的成员。\r\n","Operator '{0}' cannot be applied to operand of type '{1}'":"运算符'{0}'不能应用于类型'{1}'的操作数\r\n",", cannot be another ":"，不能是另一个\r\n","s that jump from a point \r\n            after the beginning of a ":"从某个点跳\r\n            在开始之后\r\n",",\r\n            and all preprocessor directives.\r\n            ":"，，，，\r\n            以及所有预处理器指令。\r\n            \r\n","The text of the parenthesized parameter list.":"括号参数列表的文本。\r\n"," for top-level imports.\r\n            ":" 对于顶级进口。\r\n            \r\n","\r\n              Looks up a localized string similar to One of the parameters of a binary operator must be the containing type.\r\n            ":"\r\n              查找类似于二进制运算符的参数之一的本地化字符串必须是包含类型。\r\n            \r\n","\r\n            Merge another result with this one, with the symbols combined if both\r\n            this and other are viable. Otherwise the highest priority result wins (this if equal \r\n            priority and non-viable.)\r\n            ":"\r\n            合并另一个结果，如果两者都将符号结合在一起\r\n            这个和其他是可行的。否则最高优先级结果将获胜（如果等于\r\n            优先且不可行。）\r\n            \r\n","Creates a new ForStatementSyntax instance.":"创建一个新的forstatementsyntax实例。\r\n","Accessible, non-hidden indexers.":"可访问的，非隐藏的索引器。\r\n","\r\n            Return true if the type contains any tuples.\r\n            ":"\r\n            如果类型包含任何元组，则返回true。\r\n            \r\n","\r\n              Looks up a localized string similar to Async methods cannot have unsafe parameters or return types.\r\n            ":"\r\n              查找类似于异步方法的本地化字符串不能具有不安全的参数或返回类型。\r\n            \r\n","\r\n            True if this module has any unified references.\r\n            ":"\r\n            如果该模块具有任何统一的参考，则为thus。\r\n            \r\n","tree must have a root node with SyntaxKind.CompilationUnit":"树必须具有syntaxkind.compilationunit的根节点\r\n","Object can be disposed more than once":"物体可以不止一次处置\r\n","\r\n              Looks up a localized string similar to Filter expression is a constant 'false', consider removing the catch clause.\r\n            ":"\r\n              查找类似于过滤器表达式的本地化字符串是常数“ false”，请考虑删除捕获子句。\r\n            \r\n","\r\n              Looks up a localized string similar to It is not legal to use nullable reference type '{0}?' in an is-type expression; use the underlying type '{0}' instead..\r\n            ":"\r\n              查找与其类似的本地化字符串，不合法地使用无效的参考类型“ {0}？”在IS型表达中；代替使用基础类型'{0}'。\r\n            \r\n","\r\n            A mapping from local variables to the index of their slot in a flow analysis local state.\r\n            ":"\r\n            从局部变量到其插槽索引的映射在局部状态。\r\n            \r\n","Pattern-matching":"模式匹配\r\n","Missing partial modifier on declaration of type '{0}'; another partial declaration of this type exists":"在声明“ {0}”的声明时缺少部分修饰符;存在此类类型的另一部分声明\r\n","\r\n            Binds a lambda with expression e as either { return e;} or { e; }.\r\n            ":"\r\n            将lambda绑定为{return e;}或{e;; }。\r\n            \r\n","\r\n            all three declarations for class C are equivalent and result in the same symbol table object\r\n            for C. However, these using alias symbols do appear in the results of certain SemanticModel\r\n            APIs. Specifically, for the base clause of the first of C's class declarations, the\r\n            following APIs may produce a result that contains an AliasSymbol:\r\n            ":"C类的所有三个声明都是等效的，并导致相同的符号表对象\r\n            但是，对于C.但是，这些使用别名符号确实出现在某些semanticmodel的结果中\r\n            蜜蜂。具体而言，对于C班级声明的第一个基础条款，\r\n            遵循API可能会产生包含异氧合的结果：\r\n            \r\n","\r\n            Does the member group ":"\r\n            会员组吗\r\n","An integer to use as the starting position of the first token.":"用于用作第一个令牌的起始位置的整数。\r\n","Returns the new rewritten token with replaced characters.":"返回使用更换字符的新重写令牌。\r\n","'{0}': ref structs cannot implement interfaces":"'{0}'：ref structs无法实现接口\r\n","\r\n            The effective interface set (spec 10.1.5).\r\n            ":"\r\n            有效接口集（规格10.1.5）。\r\n            \r\n","\r\n            The candidate member was rejected because it is not supported by the language or cannot be used \r\n            given the current set of assembly references.\r\n            ":"\r\n            候选人成员被拒绝，因为该语言不支持或不能使用\r\n            给定当前的组装参考集。\r\n            \r\n","\r\n            Create a NamespaceExtent that represents a given Compilation.\r\n            ":"\r\n            创建一个代表给定汇编的命名续文。\r\n            \r\n","'{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' requires a receiver of type '{3}'":"'{0}'不包含'{1}'的定义，最佳扩展方法Overload'{2}'需要一个类型'{3}'的接收器\r\n","\r\n              Looks up a localized string similar to Method '{0}' specifies a 'struct' constraint for type parameter '{1}', but corresponding type parameter '{2}' of overridden or explicitly implemented method '{3}' is not a non-nullable value type..\r\n            ":"\r\n              查找类似于方法'{0}'的本地化字符串指定'struct'''type参数'{1}'，但是相应的类型参数'{2}'的被覆盖或明确实现的方法'{3}'是一种不可取消的值类型。\r\n            \r\n","\r\n            Returns true if:\r\n            - Either type has no nullability information (oblivious).\r\n            - Both types cannot have different nullability at the same time,\r\n              including the case of type parameters that by themselves can represent nullable and not nullable reference types.\r\n            ":"\r\n            如果：\r\n             - 任何一种类型都没有无效信息（遗忘）。\r\n             - 两种类型都不能同时具有不同的无效性，\r\n              包括类型参数本身可以代表无效且不可为无效的参考类型的情况。\r\n            \r\n","Cannot infer the type of implicitly-typed discard.":"无法推断隐式丢弃的类型。\r\n","\r\n            Translate the decision dag for node, given that it will be followed by the translation for nextNode.\r\n            ":"考虑到NextNode的转换，将其转换为节点的决策DAG。\r\n            \r\n","\r\n            Returns true if the specified ":"\r\n            如果指定\r\n","Only CLS-compliant members can be abstract":"只有符合CLS的成员才能抽象\r\n"," \r\n            Add a 'wrapper' synthesized method and map it to the original one so it can be reused. \r\n            ":" \r\n            添加一个“包装器”合成方法并将其映射到原始方法，以便可以重复使用。\r\n            \r\n","\r\n            Check the expression is of the required lvalue and rvalue specified by valueKind.\r\n            The method returns the original expression if the expression is of the required\r\n            type. Otherwise, an appropriate error is added to the diagnostics bag and the\r\n            method returns a BoundBadExpression node. The method returns the original\r\n            expression without generating any error if the expression has errors.\r\n            ":"\r\n            检查该表达式是所需的lvalue和rvalue valuekind指定的表达式。\r\n            该方法如果所需的表达式返回原始表达式\r\n            类型。否则，将适当的错误添加到诊断袋中\r\n            方法返回boundbadexpression节点。该方法返回原始\r\n            如果表达式有错误，则表达式无产生任何错误。\r\n            \r\n","'{0}' is already listed in interface list":"'{0}'已经在接口列表中列出\r\n","\r\n              Looks up a localized string similar to The specified version string does not conform to the required format - major.minor.build.revision (without wildcards).\r\n            ":"\r\n              查找类似于指定版本字符串的本地化字符串不符合所需的格式-Major.minor.build.revision（无通用）。\r\n            \r\n","+=":"+=\r\n","The start index":"开始索引\r\n"," Properties defined in the type ":" 类型中定义的属性\r\n","List of the parameter types and return type of the function pointer.":"参数类型的列表和返回功能指针的类型。\r\n","\r\n            The index of a CallerArgumentExpression. The value -2 means uninitialized, -1 means\r\n            not found. Otherwise, the index of the CallerArgumentExpression.\r\n            ":"\r\n            CallerArgumentExpression的索引。值-2表示非直接化，-1表示\r\n            未找到。否则，CallerArgumentExpression的索引。\r\n            \r\n","\r\n             During early attribute decoding, we consider a safe subset of all members that will not\r\n             cause cyclic dependencies.  Get all such members for this symbol.\r\n            \r\n             In particular, this method will return nested types and fields (other than auto-property\r\n             backing fields).\r\n             ":"\r\n             在早期属性解码期间，我们考虑所有成员的安全子集\r\n             导致循环依赖性。为此符号获取所有此类成员。\r\n            \r\n             特别是，此方法将返回嵌套类型和字段（自动范围除外\r\n             支持字段）。\r\n             \r\n","\r\n            We can usually lock on the syntax reference of this method, but it turns\r\n            out that some synthesized methods (e.g. field-like event accessors) also\r\n            need to do method checks.  This property allows such methods to supply\r\n            their own lock objects, so that we don't have to add a new field to every\r\n            SourceMethodSymbol.\r\n            ":"\r\n            我们通常可以锁定此方法的语法引用，但它转弯\r\n            除了一些合成的方法（例如类似现场的事件访问者）\r\n            需要进行方法检查。此属性允许此类方法提供\r\n            他们自己的锁定对象，因此我们不必为每个目标添加一个新字段\r\n            Sourcemethodsymbol。\r\n            \r\n","Unable to include XML fragment":"无法包括XML片段\r\n","An expression tree lambda may not contain a method group":"表达树lambda可能不包含方法组\r\n","The type caught or thrown must be derived from System.Exception":"捕获或投掷的类型必须从系统中得出。\r\n","\r\n            This is used while computing the values of constant fields.  Since they can depend on each\r\n            other, we need to keep track of which ones we are currently computing in order to avoid (and\r\n            report) cycles.\r\n            ":"\r\n            计算常数字段的值时使用的。因为它们可以依靠每个\r\n            其他，我们需要跟踪目前正在计算的哪些以避免（和\r\n            报告）周期。\r\n            \r\n","\r\n            Might be a tuple type.\r\n            ":"\r\n            可能是元组类型。\r\n            \r\n","\r\n            The starting point for deciding which case matches.\r\n            ":"决定哪种情况匹配的起点。\r\n            \r\n","\r\n            Returns true if this symbol requires an instance reference as the implicit receiver. This is false if the symbol is static, or a ":"\r\n            如果此符号需要实例参考作为隐式接收器，则返回true。如果符号是静态的，则是错误的\r\n","\r\n              Looks up a localized string similar to expression-bodied property.\r\n            ":"\r\n              查找类似于表达体属性的局部字符串。\r\n            \r\n","Custom modifiers for the element type of this array type.":"该数组类型的元素类型的自定义修饰符。\r\n","Method arity":"方法\r\n","\r\n            Retargeting map from underlying module to the retargeting module.\r\n            ":"\r\n            从基础模块重新定位地图到重新定位模块。\r\n            \r\n","'in' expected":"“预期”\r\n","<path list>":"<路径列表>\r\n","\r\n              Looks up a localized string similar to Partial declarations of '{0}' must have the same type parameter names in the same order.\r\n            ":"\r\n              查找类似于“ {0}”部分声明类似的本地化字符串，必须以相同的顺序具有相同的类型参数名称。\r\n            \r\n","\r\n              Looks up a localized string similar to The extern alias '{0}' was not specified in a /reference option.\r\n            ":"\r\n              在A /参考选项中未指定类似于Extern别名'{0}'的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to The tuple element name '{0}' is ignored because a different name or no name is specified on the other side of the tuple == or != operator..\r\n            ":"\r\n              查找类似于元组元素名称'{0}'的本地化字符串被忽略，因为在元组的另一侧没有指定其他名称或未指定名称。\r\n            \r\n","\r\n             are mutually recursive. The non-recursive parts of this method tend to reserve significantly large\r\n             stack frames due to their use of large struct like ":"\r\n             是相互递归的。该方法的非恢复部分倾向于保留很大的\r\n             由于使用大型结构，例如\r\n","BracketedArgumentListSyntax node representing the list of arguments of the implicit element access expression.":"表示隐式元素访问表达式的参数列表。\r\n","Creates a new CastExpressionSyntax instance.":"创建一个新的castexpressionsyntax实例。\r\n","\r\n              Looks up a localized string similar to Elements defined in a namespace cannot be explicitly declared as private, protected, protected internal, or private protected.\r\n            ":"\r\n              查找类似于名称空间中定义的元素的本地化字符串，不能明确声明为私人，受保护，受保护的内部或受保护。\r\n            \r\n"," applied on this symbol, or null if there are none.\r\n            ":" 应用于此符号，如果没有，则应用于null。\r\n            \r\n","Constructor constraint syntax.":"构造函数约束语法。\r\n","Called when the visitor visits a MakeRefExpressionSyntax node.":"当访问者访问makerefexpressyntax节点时，请致电。\r\n","The text of the tag or attribute.":"标签或属性的文字。\r\n","\r\n              Looks up a localized string similar to An expression tree may not contain a named argument specification.\r\n            ":"\r\n              查找类似于表达树的本地化字符串可能不包含命名参数规范。\r\n            \r\n","\r\n            Returns true if the overload required a function type conversion to infer\r\n            generic method type arguments or to convert to parameter types.\r\n            ":"\r\n            如果超载需要转换函数类型来推断，则返回true\r\n            通用方法类型参数或转换为参数类型。\r\n            \r\n","\r\n             We will follow Dev10 in diverging from the C# 4 spec by ignoring string's \r\n             implementation of IEnumerable and just indexing into its characters.\r\n             \r\n             NOTE: We're assuming that sequence points have already been generated.\r\n             Otherwise, lowering to for-loops would generated spurious ones.\r\n             ":"我们将通过忽略字符串的字符来遵循dev10与C＃4规格的分歧\r\n             实施IEnumerable，只是将其索引到其角色。\r\n             \r\n             注意：我们假设已经生成了序列点。\r\n             否则，降低到横环会产生伪造的。\r\n             \r\n","\r\n              Looks up a localized string similar to Filter expression is a constant, consider removing the filter.\r\n            ":"\r\n              查找类似于过滤器表达式的局部字符串是常数，请考虑删除过滤器。\r\n            \r\n"," \r\n            Features: async, caller info attributes.\r\n            ":" \r\n            功能：异步，呼叫者信息属性。\r\n            \r\n","\r\n            Applies action to all the nested elements of this tuple.\r\n            ":"将动作应用于该元组的所有嵌套元素。\r\n            \r\n","\r\n              Looks up a localized string similar to Argument {0}: cannot convert from '{1}' to '{2}'.\r\n            ":"\r\n              查找类似于参数{0}的本地化字符串：无法从'{1}'转换为'{2}'。\r\n            \r\n","\r\n            Gets the \"MoveNext\" method.\r\n            ":"\r\n            获取“ movenext”方法。\r\n            \r\n","\r\n            NOTE: We're assuming that sequence points have already been generated.\r\n            Otherwise, lowering to for-loops would generated spurious ones.\r\n            ":"\r\n            注意：我们假设已经生成了序列点。\r\n            否则，降低到横环会产生伪造的。\r\n            \r\n"," should both be null, or \r\n            neither should be null. If an error would be reported (whether or not diagnostics is null), true is returned.\r\n            ":" 都应该是无效的，或\r\n            都不应该是无效的。如果将报告错误（无论诊断是否为null），则返回TRUE。\r\n            \r\n","\r\n            Gets a SyntaxToken that represents the semi-colon at the end of the statement.\r\n            ":"\r\n            获取一个语法，该语法代表声明结尾处的半彩色。\r\n            \r\n","\r\n            Lookup declaration for predefined CorLib type in this Assembly. Only should be\r\n            called if it is know that this is the Cor Library (mscorlib).\r\n            ":"\r\n            该组件中预定义的Corlib类型的查找声明。只应该是\r\n            如果知道这是COR库（MSCORLIB）。\r\n            \r\n","\r\n            This should probably be an extra constructor parameter, but we don't need more constructor overloads.\r\n            ":"\r\n            这可能应该是一个额外的构造函数参数，但是我们不需要更多的构造函数过载。\r\n            \r\n","\r\n              Looks up a localized string similar to Async methods cannot have ref or out parameters.\r\n            ":"\r\n              查找类似于异步方法的本地化字符串不能具有参数或输出参数。\r\n            \r\n","\r\n            The clause can be implemented via ":"\r\n            该子句可以通过\r\n","\r\n            Creates an xml documentation comment that abstracts xml syntax creation.\r\n            ":"\r\n            创建一个XML文档注释，该注释抽象XML语法创建。\r\n            \r\n","\r\n            Creates a token corresponding to syntax kind. This method gives control over token Text and ValueText.\r\n            \r\n            For example, consider the text '<see cref=\"operator &#43;\"/>'.  To create a token for the value of\r\n            the operator symbol (&#43;), one would call \r\n            Token(default(SyntaxTriviaList), SyntaxKind.PlusToken, \"&#43;\", \"+\", default(SyntaxTriviaList)).\r\n            ":"\r\n            创建与语法类型相对应的令牌。此方法可以控制令牌文本和valueText。\r\n            \r\n            例如，考虑文本'<请参阅cref =“ operator＆＃43;”/>'。创建一个代币的价值\r\n            操作员符号（＆＃43;），一个人会打电话\r\n            token（默认（语法），syntaxkind.plustoken，“＆＃43;”，“+”，默认（语法主义者））。\r\n            \r\n","\r\n            Binder for symbol being analyzed.\r\n            ":"\r\n            分析符号的活页夹。\r\n            \r\n","\r\n            A NamespaceExtent represents whether a namespace contains types and sub-namespaces from a\r\n            particular module, assembly, or merged across all modules (source and metadata) in a\r\n            particular compilation.\r\n            ":"\r\n            namespaceextent表示名称空间是否包含来自一个类型和子名称空间\r\n            在所有模块中的特定模块，组装或合并\r\n            特定的汇编。\r\n            \r\n","\r\n              Looks up a localized string similar to Async lambda expressions cannot be converted to expression trees.\r\n            ":"\r\n              查找类似于异步lambda表达式的局部字符串不能转换为表达树。\r\n            \r\n"," method,\r\n            or provided on the command line.\r\n            ":" 方法，\r\n            或在命令行上提供。\r\n            \r\n","\r\n            Report a diagnostic by default.\r\n            Either there is no corresponding #pragma, or the action is \"restore\".\r\n            ":"\r\n            默认情况下报告诊断。\r\n            要么没有相应的#pragma，要么该动作是“还原”。\r\n            \r\n","The symbols used in a cref. If this is not default, then the return is null.":"CREF中使用的符号。如果不是默认，则返回为null。\r\n","\r\n            Creates a trivia with kind WhitespaceTrivia containing the specified text.\r\n            ":"\r\n            用包含指定文本的善良的whitespacrivia创建琐事。\r\n            \r\n","Syntax node to be speculated cannot belong to a syntax tree from the current compilation.":"要推测的语法节点不能属于当前汇编的语法树。\r\n","\r\n              Looks up a localized string similar to Method must have a return type.\r\n            ":"\r\n              查找类似于方法的本地化字符串必须具有返回类型。\r\n            \r\n","\r\n            Specialized PENamedTypeSymbol for types with no type parameters in\r\n            metadata (no type parameters on this type and all containing types).\r\n            ":"\r\n            专用Penamedtypesymbol，用于无类型参数的类型\r\n            元数据（此类型上没有类型的参数，所有包含类型的参数）。\r\n            \r\n","The typeof operator cannot be used on a nullable reference type":"运算符的类型不能在无效的参考类型上使用\r\n","No enclosing loop out of which to break or continue":"没有封闭循环从中折断或继续\r\n","Creates a new NamespaceDeclarationSyntax instance.":"创建一个新的namespacedeclarationsyntax实例。\r\n","\r\n            A decision tree node that branches based on (1) whether the input value is null, (2) the runtime\r\n            type of the input expression, and finally (3) a default decision tree if nothing in the previous\r\n            cases handles the input.\r\n            ":"\r\n            基于（1）分支的决策树节点是否为null，（2）运行时\r\n            输入表达式的类型，最后（3）默认决策树，如果以前的任何内容\r\n            案例处理输入。\r\n            \r\n","\r\n            This instance is used to determine if a partial method implementation matches the definition.\r\n            It is the same as ":"\r\n            此实例用于确定部分方法实现是否匹配定义。\r\n            与\r\n","\r\n              Looks up a localized string similar to An expression is too long or complex to compile.\r\n            ":"\r\n              查找类似于表达式的局部字符串太长或复杂而无法编译。\r\n            \r\n","\r\n              Looks up a localized string similar to Invalid object creation.\r\n            ":"\r\n              查找类似于无效对象创建的本地化字符串。\r\n            \r\n","\r\n            The contents of this method, particularly ":"\r\n            该方法的内容，特别是\r\n","\r\n            A wrapper method that is created for non-virtually calling a base-class \r\n            virtual method from other classes (like those created for lambdas...).\r\n            ":"\r\n            用于非虚拟调用基类的包装方法\r\n            来自其他类的虚拟方法（例如为lambdas创建的方法...）。\r\n            \r\n","\r\n            If one of the (unconverted) operands has constant value null and the other has\r\n            a null constant value other than null, then they are definitely not equal\r\n            and we can give a constant value for either == or !=.  This is a spec violation\r\n            that we retain from Dev10.\r\n            ":"\r\n            如果其中一个（未转换）操作数具有常量值null，而另一个具有\r\n            除null以外的null常量值，那么它们肯定不相等\r\n            我们可以给出一个常数值==或！=.  这是规范违规\r\n            我们从Dev10保留。\r\n            \r\n","\r\n            Not all built-in explicit conversions are standard explicit conversions.\r\n            ":"\r\n            并非所有内置的显式转换都是标准的显式转换。\r\n            \r\n","\r\n            Generates bound block representing method's body for methods in lowered form and adds it to\r\n            a collection of method bodies of the current module. This method is supposed to only be\r\n            called for method symbols which return SynthesizesLoweredBoundBody == true.\r\n            ":"\r\n            生成代表方法的实体的绑定块，以降低形式的方法，并将其添加到\r\n            当前模块的方法主体的集合。此方法应该只是\r\n            要求返回合成loderedBoundBody == true的方法符号。\r\n            \r\n","A static local function cannot contain a reference to 'this' or 'base'.":"静态本地函数不能包含对“此或“基础”的引用。\r\n","\r\n            The candidate member was rejected because a constraint on the type of a parameter was not satisfied.\r\n            ":"\r\n            候选人成员被拒绝，因为不满足参数类型的限制。\r\n            \r\n","Overloaded method differing only by unnamed array types is not CLS-compliant":"超载方法仅由未命名的数组类型不同，不符合CLS\r\n","\r\n            Returns a value indicating whether this compilation has a member that needs IsIsByRefLikeAttribute to be generated during emit phase.\r\n            The value is set during binding the symbols that need that attribute, and is frozen on first trial to get it.\r\n            Freezing is needed to make sure that nothing tries to modify the value after the value is read.\r\n            ":"\r\n            返回一个值，指示该汇编是否具有需要在EMIT阶段生成的IsisbyReflikeAttribute的成员。\r\n            该值是在绑定需要属性的符号期间设置的，并在第一次试验中冻结以获取它。\r\n            需要冻结以确保在读取值后没有试图修改值。\r\n            \r\n","\r\n            Set to false if syntax binds to a type in the current context and true if\r\n            syntax is \"var\" and it binds to \"var\" keyword in the current context.\r\n            ":"\r\n            设置为false如果语法在当前上下文中绑定到类型，则设置为true\r\n            语法为“ var”，并且在当前上下文中绑定到“ var”关键字。\r\n            \r\n","\r\n            Returns true if body contains yield returns within try blocks.\r\n            ":"\r\n            如果身体在尝试块中包含收益率回报，则返回true。\r\n            \r\n","\r\n            The member containing the binding context.  Note that for the purposes of the compiler,\r\n            a lambda expression is considered a \"member\" of its enclosing method, field, or lambda.\r\n            ":"\r\n            包含绑定上下文的成员。请注意，出于编译器的目的\r\n            lambda表达式被认为是其封闭方法，字段或lambda的“成员”。\r\n            \r\n","\r\n              Looks up a localized string similar to Attribute '{0}' is not valid on event accessors. It is only valid on '{1}' declarations..\r\n            ":"\r\n              查找类似于属性'{0}'的本地化字符串在事件访问中无效。它仅在“ {1}”声明上有效。\r\n            \r\n","\r\n            Behavior of this key should be kept aligned with ":"\r\n            该键的行为应保持一致\r\n","Called when the visitor visits a WhileStatementSyntax node.":"当访问者访问a时，请调用。\r\n","Called when the visitor visits a EnumDeclarationSyntax node.":"当访问者访问枚举元素节点时打电话。\r\n","\r\n            There is no forbidden zone for a foreach loop, because the iteration\r\n            variable is not in scope in the collection expression.\r\n            ":"\r\n            没有禁止的区域可供foreach循环，因为迭代\r\n            在集合表达式中，变量不在范围内。\r\n            \r\n","Identifier is not CLS-compliant":"标识符不符合CLS\r\n","'{0}': a type cannot be both static and sealed":"'{0}'：一种类型不能既静态又密封\r\n","&":"和\r\n","An analyzer instance cannot be created":"无法创建分析仪实例\r\n","\r\n              Looks up a localized string similar to An expression cannot be used in this context because it may not be returned by reference.\r\n            ":"\r\n              在此上下文中查找类似于表达式的本地化字符串，因为可能不会通过参考返回。\r\n            \r\n","The accessibility modifier of the '{0}' accessor must be more restrictive than the property or indexer '{1}'":"“ {0}”访问者的可访问性修饰符必须比属性或索引器'{1}'更具限制性\r\n"," is not changed if this function returns false. \r\n            ":" 如果此功能返回false，则不会更改。\r\n            \r\n"," is not run. This is problematic because\r\n            ":" 不运行。这是有问题的，因为\r\n            \r\n","Identifier '{0}' is not CLS-compliant":"标识符'{0}'不符合CLS\r\n","\r\n            Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.\r\n            ":"\r\n            返回程序中绑定到的给定构造函数初始化器语法（如果有）。\r\n            \r\n"," Key pf the anonymous type descriptor ":" 键PF匿名类型描述符\r\n","Tuple element name '{0}' is disallowed at any position.":"元组元素名称'{0}'在任何位置都禁止。\r\n","\r\n            Returns false because local variable can't be declared as static in C#.\r\n            ":"\r\n            返回false，因为在C＃中不能将局部变量声明为静态。\r\n            \r\n","Compiler version: '{0}'. Language version: {1}.":"编译器版本：'{0}'。语言版本：{1}。\r\n","\r\n            Performs interface mapping (spec 13.4.4).\r\n            ":"\r\n            执行接口映射（规范 13.4.4）。\r\n            \r\n","\r\n            C# only considers culture when comparing weak identities.\r\n            It ignores versions of weak identities and reports an error if there are two weak assembly \r\n            references passed to a compilation that have the same simple name.\r\n            ":"\r\n            C＃仅在比较弱身份时考虑文化。\r\n            它忽略了弱身份的版本，如果有两个弱组装，则报告错误\r\n            引用传递给具有相同名称的汇编。\r\n            \r\n","Agnostic assembly cannot have a processor specific module '{0}'.":"不可知论组件不能具有处理器特定模块'{0}'。\r\n","Called when the visitor visits a ParameterSyntax node.":"当访问者访问参数字母节点时调用。\r\n","'{0}' is of type '{1}'. A default parameter value of a reference type other than string can only be initialized with null":"'{0}'是类型'{1}'的'。字符串以外的参考类型的默认参数值只能使用NULL初始化\r\n","Creates a new ArrayCreationExpressionSyntax instance.":"创建一个新的arrayCreationexpressyntax实例。\r\n","\r\n              Looks up a localized string similar to Pointers and fixed size buffers may only be used in an unsafe context.\r\n            ":"\r\n              查找类似于指针的局部字符串，固定尺寸缓冲区只能在不安全的上下文中使用。\r\n            \r\n","\r\n            Returns the definition part of a partial method implementation, \r\n            or null if this is not a partial method or it is the implementation part.\r\n            ":"\r\n            返回部分方法实现的定义部分，\r\n            或null如果这不是部分方法，也不是实现部分。\r\n            \r\n","\r\n            There are three ways to initialize a fixed statement local:\r\n              1) with an address;\r\n              2) with an array (or fixed-size buffer); or\r\n              3) with a string.\r\n            \r\n            In the first two cases, the resulting local will be emitted with a \"pinned\" modifier.\r\n            In the third case, it is not the fixed statement local but a synthesized temp that is pinned.  \r\n            Unfortunately, we can't distinguish these cases when the local is declared; we only know\r\n            once we have bound the initializer.\r\n            ":"\r\n            有三种方法可以初始化固定语句本地：\r\n              1）有一个地址；\r\n              2）带有数组（或固定大小的缓冲区）；或者\r\n              3）用字符串。\r\n            \r\n            在前两种情况下，将带有“固定”修饰符发射所得的本地。\r\n            在第三种情况下，固定的不是固定语句本地的固定语句，而是合成的温度。\r\n            不幸的是，当宣布本地时，我们无法区分这些案件。我们只知道\r\n            一旦我们绑定了初始化器。\r\n            \r\n","Indicates whether the current Index object is equal to another Index object.":"指示当前索引对象是否等于另一个索引对象。\r\n","\r\n            Extract type under assumption that there should be no custom modifiers.\r\n            The method asserts otherwise.\r\n            ":"\r\n            假设不应该有自定义修饰符的提取类型。\r\n            该方法否则断言。\r\n            \r\n","\r\n            Explicit conversions are described in section 6.2 of the C# language specification.\r\n            ":"\r\n            C＃语言规范的第6.2节中描述了明确的转换。\r\n            \r\n","\r\n            Gets a SyntaxToken that represents a case or default keywords that belongs to a switch label.\r\n            ":"\r\n            获取一个代表属于交换标签的情况或默认关键字的语法。\r\n            \r\n","\r\n            The type containing the binding context\r\n            ":"\r\n            包含绑定上下文的类型\r\n            \r\n","\r\n            Create a cache for computing whether or not a struct type is \"empty\".\r\n            ":"\r\n            创建用于计算结构类型是否为“空”的缓存。\r\n            \r\n","The array builder to append statements to":"阵列构建器将语句附加到\r\n",".\r\n            \r\n            The assembly references listed in the metadata AssemblyRef table are matched to the resolved references \r\n            stored on this ":"。\r\n            \r\n            元数据汇编表中列出的汇编参考表与已解决的参考\r\n            存储在此上\r\n","\r\n            True if internals are exposed at all.\r\n            ":"\r\n            如果完全暴露在内，则是的。\r\n            \r\n","Transparent identifier member access failed for field '{0}' of '{1}'.  Does the data being queried implement the query pattern?":"'{1}'的字段'{0}''{0}'的透明标识符成员访问失败。被查询的数据是否实现了查询模式？\r\n","How C# should interpret the text of this token.":"C＃应该如何解释该令牌的文本。\r\n","\r\n            This visitor walks over a type expression looking for open types.\r\n            Open types are allowed if an only if:\r\n              1) There is no constructed generic type elsewhere in the visited syntax; and\r\n              2) The open type is not used as a type argument or array/pointer/nullable\r\n                   element type.\r\n            ":"\r\n            该访问者浏览类型的表达式寻找开放类型。\r\n            仅当以下情况下才允许开放类型\r\n              1）在访问的语法中其他地方没有构造的通用类型；和\r\n              2）开放式类型不用作类型参数或数组/指针/无效\r\n                   元素类型。\r\n            \r\n","\r\n              Looks up a localized string similar to Member definition, statement, or end-of-file expected.\r\n            ":"查找类似于成员定义，语句或文件终止期望的本地化字符串。\r\n            \r\n","A nullable type parameter must be known to be a value type or non-nullable reference type unless language version '{0}' or greater is used. Consider changing the language version or adding a 'class', 'struct', or type constraint.":"除非使用语言版本'{0}'或更大的方式，否则必须知道无效的类型参数是值类型或不可删除的参考类型。考虑更改语言版本或添加“类”，“ struct”或键入约束。\r\n","\r\n              Looks up a localized string similar to The range variable '{0}' conflicts with a previous declaration of '{0}'.\r\n            ":"\r\n              查找类似于范围变量'{0}'冲突的本地化字符串与先前的声明“ {0}”冲突。\r\n            \r\n","\r\n            This portion of the binder reports errors arising from resolving queries.\r\n            ":"\r\n            粘合剂的这一部分报告了解决查询引起的错误。\r\n            \r\n"," that represents\r\n            a namespace that couldn't be found.\r\n            ":" 代表\r\n            一个找不到的名称空间。\r\n            \r\n",".\r\n            Otherwise, returns a newly created ":"。\r\n            否则，返回新创建的\r\n","The range variable '{0}' conflicts with a previous declaration of '{0}'":"范围变量'{0}'与先前的声明'{0}'冲突\r\n","\r\n            Gets the symbol for the pre-defined type from core library associated with this assembly.\r\n            ":"\r\n            从与此组件关联的核心库中获取预定义类型的符号。\r\n            \r\n","\r\n            This class represents an event declared in source with explicit accessors\r\n            (i.e. not a field-like event).\r\n            ":"\r\n            该类代表带有显式登录机的源声明的事件\r\n            （即不是像现场的事件）。\r\n            \r\n","GetTuple()":"getTuple（）\r\n","\r\n            If this is a field of a tuple type, return corresponding underlying field from the\r\n            tuple underlying type. Otherwise, null. In case of a malformed underlying type\r\n            the corresponding underlying field might be missing, return null in this case too.\r\n            ":"如果这是元组类型的字段，请从\r\n            元组基础类型。否则，null。如果有畸形的基础类型\r\n            可能缺少相应的基础字段，在这种情况下也返回null。\r\n            \r\n","The type name '{0}' could not be found. This type has been forwarded to assembly '{1}'. Consider adding a reference to that assembly.":"找不到类型名称'{0}'。这种类型已转发到汇编'{1}'。考虑添加对该组件的引用。\r\n","The 'this' object cannot be used before all of its fields have been assigned":"在分配所有字段之前，不能使用“此”对象\r\n","\r\n            Convenience method for checking the mode.\r\n            ":"\r\n            检查模式的便利方法。\r\n            \r\n","\r\n            Some error messages are particularly confusing if multiple placeholders are substituted\r\n            with the same string.  For example, \"cannot convert from 'Foo' to 'Foo'\".  Usually, this\r\n            occurs because there are two types in different contexts with the same qualified name.\r\n            The solution is to provide additional qualification on each symbol - either a source\r\n            location, an assembly path, or an assembly identity.\r\n            ":"\r\n            如果多个占位符被替换，一些错误消息特别令人困惑\r\n            使用相同的字符串。例如，“不能从'foo'转换为'foo'”。通常，这个\r\n            之所以发生，是因为不同的上下文中有两种类型，具有相同的合格名称。\r\n            解决方案是在每个符号上提供额外的资格 - 要么是源\r\n            位置，装配路径或装配身份。\r\n            \r\n","/platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe":"/平台：Anycpu32bitPrefred只能与 /t：exe， /t：winexe和 /t：appContainerexe\r\n","\r\n            Returns true if the given argument is the beginning of a list of param array arguments (could be empty), otherwise returns false.\r\n            When returns true, numberOfParamArrayArguments is set to the number of param array arguments.\r\n            ":"\r\n            如果给定参数是参数参数列表的开头（可以是空），则返回true，否则返回false。\r\n            当返回true时，将numberOfParamArrayArayArguments设置为param数组参数的数量。\r\n            \r\n","Context in which type is not variance safe (e.g. method).":"哪种类型不是方差安全的上下文（例如方法）。\r\n","\r\n              Looks up a localized string similar to __arglist is not valid in this context.\r\n            ":"\r\n              在此上下文中查找类似于__arglist的本地化字符串是无效的。\r\n            \r\n","Type has no accessible constructors which use only CLS-compliant types":"类型没有仅使用符合CLS类型的可访问构造函数\r\n","Null for the initial call, non-null if we are in the process of evaluating a constant.":"对于初始呼叫，如果我们正在评估常数的过程中，则无效。\r\n","\r\n            In case duplicate types are found, ignore the one from corlib. This is useful for any kind of compilation at runtime\r\n            (EE/scripting/Powershell) using a type that is being migrated to corlib.\r\n            ":"\r\n            如果发现重复类型，请忽略Corlib的一种。这对于运行时的任何类型的汇编都是有用的\r\n            （EE/脚本/PowerShell）使用正在迁移到Corlib的类型。\r\n            \r\n","\r\n            Return a collection of bound constraint clauses indexed by type parameter\r\n            ordinal. All constraint clauses are bound, even if there are multiple constraints\r\n            for the same type parameter, or constraints for unrecognized type parameters.\r\n            Extra constraints are not included in the returned collection however.\r\n            ":"\r\n            返回按类型参数索引的界限子句的集合\r\n            序数。即使有多个约束\r\n            对于相同的类型参数，或未识别类型参数的约束。\r\n            但是，返回的集合中未包含额外的约束。\r\n            \r\n","The enumerator name '{0}' is reserved and cannot be used":"保留枚举名称'{0}'，无法使用\r\n","\r\n              Looks up a localized string similar to readonly structs.\r\n            ":"\r\n              查找类似于Readonly结构的本地化字符串。\r\n            \r\n","\r\n            Perform a lookup for the specified method on the specified expression by attempting to invoke it\r\n            ":"\r\n            通过尝试调用指定表达式的指定方法查找\r\n            \r\n","\r\n            This method implements the algorithm in spec section 7.6.5.1.\r\n            \r\n            For method group conversions, there are situations in which the conversion is\r\n            considered to exist (\"Otherwise the algorithm produces a single best method M having\r\n            the same number of parameters as D and the conversion is considered to exist\"), but\r\n            application of the conversion fails.  These are the \"final validation\" steps of\r\n            overload resolution.\r\n            ":"\r\n            此方法在规范第7.6.5.1节中实现了算法。\r\n            \r\n            对于方法组转换，在某些情况下转换为\r\n            被认为存在（否则该算法会产生一个最佳方法m\r\n            与d相同的参数数量，并且被认为存在转换”），但\r\n            转换的应用失败。这些是“最终验证”步骤\r\n            超负荷分辨率。\r\n            \r\n"," is in the right place in the syntax tree.\r\n            ":" 位于语法树中的正确位置。\r\n            \r\n"," is a collection of partially matched\r\n            cases represented\r\n            by ":" 是部分匹配的集合\r\n            案件代表\r\n            经过\r\n","Creates a new MemberBindingExpressionSyntax instance.":"创建一个新的MemberBindingExpressionsyntax实例。\r\n","\r\n            Bind the (implicit or explicit) constructor initializer of a constructor symbol.\r\n            ":"\r\n            绑定构造函数符号的（隐式或显式）构造函数初始化器。\r\n            \r\n",", then members are listed by inclusion.  Otherwise all members\r\n            are assumed to be contained in the set unless excluded.\r\n            ":"，然后通过包容列出会员。否则所有成员\r\n            除非排除，否则假定该集合中包含。\r\n            \r\n","\r\n            Visit the expression, but do so in a way that ensures that its type is precise.  That means that any\r\n            sometimes-unnecessary conversions (such as an implicit reference conversion) are retained.\r\n            ":"访问表达，但要以确保其类型为精确的方式进行。这意味着任何\r\n            有时保留了有时不必要的转换（例如隐式参考转换）。\r\n            \r\n"," where for at least one A_i one\r\n            of the following holds:\r\n                a) X_i is covariant or invariant and A_i is output-unsafe [input-unsafe]\r\n                b) X_i is contravariant or invariant and A_i is input-unsafe [output-unsafe] (note: spec has \"input-safe\", but it's a typo)\r\n            ":" 至少有一个A_I一个\r\n            以下内容：\r\n                a）x_i是协变量或不变的，a_i是输出 -  unsafe [input-unsafe]\r\n                b）x_i是逆向或不变的，a_i是输入 -  unsafe [output-unsafe]（注意：SPEC具有“输入安全”，但它是错别字）\r\n            \r\n","Receiver for the method call.":"方法调用的接收器。\r\n","Creates a new CatchFilterClauseSyntax instance.":"创建一个新的catchfilterclausesyntax实例。\r\n","File name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long":"文件名'{0}'是空的，包含无效字符，具有无绝对路径的驱动器规范，或者太长\r\n"," when\r\n            it's encountered.\r\n            ":" 什么时候\r\n            它遇到了。\r\n            \r\n"," on\r\n            the thread that actually completes the loading of attributes. Failure to do so will potentially\r\n            result in a deadlock.\r\n            ":" 上\r\n            实际完成属性加载的线程。不这样做会有可能\r\n            导致僵局。\r\n            \r\n","\r\n            Indicates whether this accessor is readonly due to reasons scoped to itself and its containing property.\r\n            ":"\r\n            指示该登录器是否已被阅读，因为范围内的原因及其包含的属性。\r\n            \r\n","The interface member being implemented.":"接口成员正在实现。\r\n","\r\n            A formatter for values of type ":"\r\n            类型值的格式\r\n"," which represent nullable type parameters\r\n            of the ":" 代表无效类型参数\r\n            的\r\n","Cannot specify the DefaultMember attribute on a type containing an indexer":"无法在包含索引器的类型上指定defaultmember属性\r\n","'{0}': cannot implement a dynamic interface '{1}'":"'{0}'：无法实现动态接口'{1}'\r\n","\r\n              Looks up a localized string similar to The variable '{0}' is declared but never used.\r\n            ":"\r\n              查找类似于变量'{0}'的本地化字符串，但从未使用过。\r\n            \r\n","virtual":"虚拟的\r\n","\r\n            (b ? x : y) becomes\r\n                push b\r\n                if pop then goto CONSEQUENCE\r\n                push y\r\n                goto DONE\r\n              CONSEQUENCE:\r\n                push x\r\n              DONE:\r\n            ":"\r\n            （b？x：y）变成\r\n                推b\r\n                如果流行随后得到结果\r\n                推y\r\n                完成了\r\n              结果：\r\n                推x\r\n              完毕：\r\n            \r\n","Gets the \"async\" token.":"获取“异步”令牌。\r\n","\r\n            Gets a SyntaxToken that represents the open parenthesis before the if statement's condition expression.\r\n            ":"\r\n            获取一个语法，该语法表示在IF语句的条件表达式之前表示开放的括号。\r\n            \r\n","Gets the optional construct targeted by the attribute.":"获取由属性靶向的可选构造。\r\n","Range variable '{0}' cannot be assigned to -- it is read only":"范围变量'{0}'不能分配给 - 仅读取\r\n","'{0}' does not implement instance interface member '{1}'. '{2}' cannot implement the interface member because it is static.":"'{0}'不实现实例接口成员'{1}'。 '{2}'无法实现接口成员，因为它是静态的。\r\n","\r\n            This method does not filter diagnostics based on ":"\r\n            此方法不会根据\r\n","Field or auto-implemented property cannot be of type '{0}' unless it is an instance member of a ref struct.":"除非它是REF结构的实例成员，否则字段或自动实施属性不能为'{0}'类型。\r\n","\r\n              Looks up a localized string similar to A goto cannot jump to a location after a using declaration..\r\n            ":"\r\n              查找类似于goto的局部字符串，在使用声明后无法跳到位置。\r\n            \r\n","\r\n            Calculates a syntax offset for a local (user-defined or long-lived synthesized) declared at ":"\r\n            计算在本地（用户定义或长寿命合成）声明的语法偏移量\r\n","\r\n              Looks up a localized string similar to Base type is not CLS-compliant.\r\n            ":"查找类似于基本类型的本地化字符串不合同。\r\n            \r\n","\r\n              Looks up a localized string similar to Provided source code kind is unsupported or invalid: '{0}'.\r\n            ":"\r\n              查找类似于提供的源代码类似的本地化字符串是不支持的或无效的：'{0}'。\r\n            \r\n","An expression tree may not contain a tuple conversion.":"表达树可能不包含元组转换。\r\n","Non-ASCII quotations marks may not be used around string literals.":"非ASCII引号标记不可能围绕字符串文字使用。\r\n","Cannot use #load after first token in file":"在文件中首次令牌后无法使用#load\r\n","The first parameter of an extension method cannot be of type '{0}'":"扩展方法的第一个参数不能是类型'{0}'\r\n","Named argument '{0}' specifies a parameter for which a positional argument has already been given":"命名参数'{0}'指定了已经给出的位置参数的参数\r\n","\r\n            NOTE: every struct has a public parameterless constructor either used-defined or default one\r\n            ":"\r\n            注意：每个结构都有一个公共参数构造函数，要么使用定义或默认一个\r\n            \r\n","Comparison to integral constant is useless; the constant is outside the range of the type":"与整体常数进行比较是没有用的；常数超出了类型的范围\r\n","SyntaxToken representing close bracket.":"Syntaxtoken代表近亲括号。\r\n","Creates a new EndRegionDirectiveTriviaSyntax instance.":"创建一个新的EndRegionDirectivtRiviaSyntax实例。\r\n","\r\n             Get all instance fields of a struct. They are not necessarily returned in order.\r\n             ":"\r\n             获取结构的所有实例字段。它们不一定按顺序返回。\r\n             \r\n","Parameter '{0}' must have a non-null value when exiting with '{1}'.":"使用'{1}'退出时，参数'{0}'必须具有非null值。\r\n"," produces its output in two forms.  First, it returns a new bound statement\r\n            for the caller to use for the body of the original method.  Second, it returns a collection of\r\n            (":" 以两种形式产生其输出。首先，它返回一个新的绑定语句\r\n            使呼叫者用于原始方法的主体。其次，它返回了\r\n            （（\r\n","\r\n            Note that the access check is done using the original definitions.  This is because we want to avoid\r\n            reductions in accessibility that result from type argument substitution (e.g. if an inaccessible type\r\n            has been passed as a type argument).\r\n            See DevDiv #11967 for an example.\r\n            ":"\r\n            请注意，使用原始定义完成了访问检查。这是因为我们要避免\r\n            降低了由类型参数替代产生的可访问性（例如，如果不访问类型\r\n            已作为类型参数通过）。\r\n            有关一个示例，请参见Devdiv＃11967。\r\n            \r\n","An expression tree may not contain a base access":"表达树可能不包含基本访问\r\n"," is provided, attributes will not be returned if it\r\n            is certain there are none that could match the request.  This prevents going back to \r\n            source unnecessarily.\r\n            ":" 提供了，如果属性将不会返回\r\n            确定没有人可以匹配该请求。这可以防止回到\r\n            不必要的来源。\r\n            \r\n","\r\n            Checks if this symbol is a definition and its containing module is a SourceModuleSymbol.\r\n            ":"\r\n            检查此符号是否为定义，其包含的模块是SourceModulesymbol。\r\n            \r\n","\r\n              Looks up a localized string similar to Skip loading types in analyzer assembly that fail due to a ReflectionTypeLoadException.\r\n            ":"\r\n              在分析仪组件中查找类似于跳过加载类型的局部字符串，该字符串由于ReflectionTypeloadexception而失败。\r\n            \r\n","\r\n            The assemblies to which the given type is forwarded.\r\n            ":"\r\n            转发给定类型的组件。\r\n            \r\n","\r\n            Traverses the symbol table processing XML documentation comments and optionally writing them to\r\n            a provided stream.\r\n            ":"\r\n            遍历符号表处理XML文档注释，并可选地将其写入\r\n            提供的流。\r\n            \r\n","\r\n              Looks up a localized string similar to Iterators cannot have unsafe parameters or yield types.\r\n            ":"\r\n              查找类似于迭代器的本地化字符串不能具有不安全的参数或产量类型。\r\n            \r\n","\r\n              Looks up a localized string similar to Expression will always cause a System.NullReferenceException because the default value of '{0}' is null.\r\n            ":"\r\n              查找类似于表达式的本地化字符串将始终导致系统。NullReferenceException，因为“ {0}”的默认值为null。\r\n            \r\n","You cannot redefine the global extern alias":"您不能重新定义全球外部别名\r\n","\r\n            A set of tests to be performed.  This is a discriminated union; see the options (nested types) for more details.\r\n            ":"\r\n            一组要执行的测试。这是一个歧视的联盟；有关更多详细信息，请参见选项（嵌套类型）。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot deconstruct a tuple of '{0}' elements into '{1}' variables..\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法将'{0}'元素的元组解构为'{1}'变量..\r\n            \r\n","\r\n            Binds a member access expression\r\n            ":"\r\n            绑定成员访问表达式\r\n            \r\n","\r\n            Returns an array of assembly identities for assemblies referenced by this module.\r\n            Items at the same position from GetReferencedAssemblies and from GetReferencedAssemblySymbols \r\n            should correspond to each other.\r\n            ":"\r\n            返回该模块引用的汇编数组。\r\n            从GetReferendedAssemblies和GetReferendedAssemblysymbols处于同一位置的项目\r\n            应彼此对应。\r\n            \r\n","\r\n            If this symbol represents a partial method definition or implementation part, its other part (if any).\r\n            This should be set, if at all, before this symbol appears among the members of its owner.  \r\n            The implementation part is not listed among the \"members\" of the enclosing type.\r\n            ":"\r\n            如果此符号代表部分方法定义或实现部分，则其另一部分（如果有）。\r\n            如果有的话，应该设置此符号在其所有者的成员中出现之前。\r\n            实现部分未在封闭类型的“成员”中列出。\r\n            \r\n","\r\n            This property exists purely for performance reasons.\r\n            ":"\r\n            该属性纯粹是出于绩效原因而存在。\r\n            \r\n","Attributes on lambda expressions require a parenthesized parameter list.":"lambda表达式上的属性需要括号的参数列表。\r\n","Invalid extern alias for '/reference'; '{0}' is not a valid identifier":"“/参考”的无效外部别名； '{0}'不是有效的标识符\r\n","\r\n              Looks up a localized string similar to '{0}' should not have a params parameter since '{1}' does not.\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串不应具有参数，因为'{1}'没有。\r\n            \r\n","\r\n            This binder produces BoundForEachStatements.  The lowering described in the spec is performed in ControlFlowRewriter.\r\n            ":"\r\n            该活页夹会产生边界宣传。规格中描述的降低是在ControlFlowRwriter中执行的。\r\n            \r\n","\r\n            Used to decide if we need to emit 'call' or 'callvirt' for structure method.\r\n            It basically checks if the method overrides any other and method's defining type\r\n            is not a 'special' or 'special-by-ref' type. \r\n            ":"\r\n            用于确定我们是否需要发出“呼叫”或“呼叫”来进行结构方法。\r\n            它基本上检查该方法是否覆盖了任何其他方法，并且方法的定义类型\r\n            不是“特殊”或“特殊划分”类型。\r\n            \r\n","\r\n              Looks up a localized string similar to type variance.\r\n            ":"\r\n              查找类似于类型方差的本地化字符串。\r\n            \r\n","The RequiredAttribute attribute is not permitted on C# types":"C＃类型不允许使用所需的属性属性\r\n"," Free resources allocated for this method collection ":" 为此方法收集分配的免费资源\r\n","The current method calls an async method that returns a Task or a Task<TResult> and doesn't apply the await operator to the result. The call to the async method starts an asynchronous task. However, because no await operator is applied, the program continu ...":"当前方法调用一个异步方法，该方法返回任务或任务<tresult>，并且不将等待运算符应用于结果。对异步方法的调用开始了异步任务。但是，由于没有应用等待运营商，该程序会继续...\r\n","\r\n            Prefers symbols from source module, then from added modules, then from referenced assemblies.\r\n            Returns true if values were swapped.\r\n            ":"\r\n            首选来自源模块的符号，然后从添加的模块，然后是引用的组件。\r\n            如果交换值，则返回true。\r\n            \r\n"," is an unbound lambda.\r\n            If ":" 是一个无界的lambda。\r\n            如果\r\n","Members of readonly field '{0}' cannot be used as a ref or out value (except in a constructor)":"ReadOnly字段'{0}'的成员不能用作REF或OUT值（在构造函数中除外）\r\n","\r\n            Parse a list of trivia using the parsing rules for trailing trivia.\r\n            ":"\r\n            使用解析规则来解析琐事清单。\r\n            \r\n","Cannot compile net modules when using /refout or /refonly.":"使用 /refut或 /重新拨号时无法编译净模块。\r\n","\r\n              Looks up a localized string similar to Member overrides base member with multiple override candidates at run-time.\r\n            ":"\r\n              查找类似于成员覆盖基本成员的本地化字符串，在运行时有多个覆盖候选者。\r\n            \r\n","Invalid search path '{0}' specified in '{1}' -- '{2}'":"无效的搜索路径'{0}'在'{1}' - '{2}'中指定\r\n","A single trivia.":"一个琐事。\r\n","Creates a new FunctionPointerTypeSyntax instance.":"创建一个新的forcormPoInterTypesyntax实例。\r\n","^":"^\r\n"," to determine if the parameter will be considered optional by\r\n            overload resolution.\r\n            \r\n            The default value can be obtained with ":" 确定参数是否将被视为可选的\r\n            超负荷分辨率。\r\n            \r\n            可以通过\r\n","\r\n            Is a top-level type with accessibility \"declaredAccessibility\" inside assembly \"assembly\"\r\n            accessible from \"within\", which must be a named type of an assembly.\r\n            ":"\r\n            是顶级类型，具有可访问性的“声明性”内部装配“汇编”\r\n            可以从“内部”访问，这必须是命名类型的组件类型。\r\n            \r\n","\r\n            Rewrites Try/Catch part of the Try/Catch/Finally\r\n            ":"\r\n            重写尝试/捕获一部分try/catch/终于\r\n            \r\n","Creates a new ObjectCreationExpressionSyntax instance.":"创建一个新的ObjectCreationexpressynntax实例。\r\n","\r\n            Gets the return type of the method\r\n            ":"获取该方法的返回类型\r\n            \r\n","true if the character is a hexadecimal digit 0-9, A-F, a-f.":"如果角色是十六进制的数字0-9，A-F，A-F。\r\n","\r\n              Looks up a localized string similar to Cannot restore warning because it was disabled globally.\r\n            ":"\r\n              查找类似于无法恢复警告的本地化字符串，因为它在全球范围内被禁用。\r\n            \r\n","\r\n            This represents a partially lowered local function reference (e.g.,\r\n            a local function call or delegate conversion) with relevant proxies\r\n            attached. It will later be rewritten by the\r\n            ":"\r\n            这代表了部分降低的本地函数参考（例如，\r\n            与相关代理的本地函数调用或委托转换）\r\n            随附的。稍后将由\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot convert async {0} to delegate type '{1}'. An async {0} may return void, Task or Task<T>, none of which are convertible to '{1}'..\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法将异步{0}转换为委托类型'{1}'。异步{0}可以返回void，task或task <t>，它们都不可转换为'{1}'..\r\n            \r\n","\r\n            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte floating point value.\r\n            ":"\r\n            从文本和相应的4字节浮点值中创建一个具有相同数字的令牌。\r\n            \r\n","\r\n            Given a namespace symbol, returns the corresponding assembly specific namespace symbol\r\n            ":"\r\n            给定的名称空间符号，返回相应的汇编特定的名称空间符号\r\n            \r\n","The DllImport attribute must be specified on a method marked 'static' and 'extern'":"必须在标记为“静态”和“ extern”的方法上指定dllimport属性\r\n","->":" - >\r\n","\r\n            Turn a (parsed) interpolated string nonterminal into an interpolated string token.\r\n            ":"\r\n            将（解析的）插值字符串非末端变成插值字符串令牌。\r\n            \r\n","\r\n            Is the switch statement one that could be interpreted as a C# 6 or earlier switch statement?\r\n            ":"\r\n            开关语句是否可以解释为C＃6或更早的Switch语句？\r\n            \r\n","Creates a new TupleExpressionSyntax instance.":"创建一个新的tuplexpressionsyntax实例。\r\n","\r\n              Looks up a localized string similar to Error opening response file '{0}'.\r\n            ":"\r\n              查找类似于错误打开响应文件'{0}'的本地化字符串。\r\n            \r\n"," already has errors and meets the above type requirements, then it is returned unchanged.\r\n            Otherwise, if ":" 已经有错误并满足上述类型要求，然后将其返回。\r\n            否则，如果\r\n","Called when the visitor visits a ConstructorConstraintSyntax node.":"当访问者访问constructorConstraintsyntax节点时，请致电。\r\n","\r\n            Creates a function pointer from individual parts. This method should only be used when diagnostics are not needed. This is\r\n            intended for use in test code.\r\n            ":"\r\n            从各个部分创建功能指针。仅在不需要诊断时才能使用此方法。这是\r\n            旨在用于测试代码。\r\n            \r\n","Class which represents a placeholder in an array size list.":"在数组尺寸列表中代表占位符的类。\r\n","Creates a new ParameterSyntax instance.":"创建一个新的parametersyntax实例。\r\n","\r\n              Looks up a localized string similar to Local name '{0}' is too long for PDB.  Consider shortening or compiling without /debug..\r\n            ":"\r\n              查找类似于本地名称'{0}'的本地化字符串对于PDB来说太长了。考虑缩短或编译没有 /调试。\r\n            \r\n","\r\n            A symbol requires a documentation comment if it was explicitly declared and\r\n            will be visible outside the current assembly (ignoring InternalsVisibleTo).\r\n            Exception: accessors do not require doc comments.\r\n            ":"\r\n            如果符号明确声明，则需要评论。\r\n            将在当前组件外（忽略InternalSvisibleto）之外可见。\r\n            例外：登录器不需要文档评论。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot return '{0}' by reference because it was initialized to a value that cannot be returned by reference.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法通过引用返回'{0}'，因为它被初始化为无法通过引用返回的值。\r\n            \r\n","\r\n            Indices of attributes that will not be emitted for one of two reasons:\r\n            - They are duplicates of another attribute (i.e. attributes that bind to the same constructor and have identical arguments)\r\n            - They are InternalsVisibleToAttributes with invalid assembly identities\r\n            ":"\r\n            由于两个原因之一，不会发出的属性索引：\r\n             - 它们是另一个属性的重复（即绑定到同一构造函数并具有相同参数的属性）\r\n             - 它们是具有无效装配身份的内部visibletoatibutes\r\n            \r\n","Called when the visitor visits a CastExpressionSyntax node.":"当访问者访问castexpressyntax节点时，请致电。\r\n","Inconsistent lambda parameter usage; parameter types must be all explicit or all implicit":"lambda参数使用不一致；参数类型必须均为明确或全隐含\r\n","\r\n              Looks up a localized string similar to Cannot await 'void'.\r\n            ":"\r\n              查找类似于无法等待“无效”的局部字符串。\r\n            \r\n","\r\n            Contains a list of the labels visited so far for each scope. \r\n            The outer ArrayBuilder is a stack representing the chain of scopes from the root scope to the current scope,\r\n            and for each item on the stack, the ArrayBuilder is the list of the labels visited so far for the scope.\r\n            \r\n            Used by ":"\r\n            包含迄今为止每个范围访问的标签列表。\r\n            外部阵列布置器是一个堆栈，代表从根部范围到当前范围的范围链链，\r\n            对于堆栈上的每个项目，ArrayBuilder是迄今为止访问范围的标签列表。\r\n            \r\n            使用\r\n","\r\n            Indicates whether the method is declared readonly, i.e.\r\n            whether the 'this' receiver parameter is 'ref readonly'.\r\n            See also ":"\r\n            指示该方法是否被宣布为ROADONLY，即\r\n            “此“接收器”参数是否为“ ref Readonly”。\r\n            也可以看看\r\n","Unable to resolve file path '{0}' specified for the named argument '{1}' for PermissionSet attribute":"无法解析为permissionset属性指定的命名参数'{1}'指定的文件路径'{0}'\r\n","\r\n            Apply the conversion to the type of the operand and return the resulting type.\r\n            If the operand does not have an explicit type, the operand expression is used.\r\n            ":"\r\n            将转换应用于操作数的类型，然后返回结果类型。\r\n            如果操作数没有显式类型，则使用操作数表达式。\r\n            \r\n","\r\n             A plain TupleElementFieldSymbol (as opposed to a TupleVirtualElementFieldSymbol) represents\r\n             an element field of a tuple type (such as (int, byte).Item1) that is backed by a real field\r\n             with the same name within the tuple underlying type.\r\n            \r\n             Note that original tuple fields (like 'System.ValueTuple`2.Item1') do not get wrapped.\r\n             ":"\r\n             普通的TupleelementFieldSymbol（与Tuplevirtualelementsymbol）代表\r\n             元素字段的元素字段（例如（int，byte）.Item1）由真实字段支持\r\n             带有元组的基础类型中的同名。\r\n            \r\n             请注意，原始的元组字段（例如'System.Valuetuple`2.Item1'）不会被包装。\r\n             \r\n","\r\n            We imitate the native compiler's policy of not warning about unused fields\r\n            when the enclosing type is used by an extern method for a ref argument.\r\n            Here we keep track of those types.\r\n            ":"\r\n            我们模仿本地编译器不警告未使用字段的政策\r\n            当封闭类型由外部方法使用用于参数时。\r\n            在这里，我们跟踪这些类型。\r\n            \r\n","\r\n            The overload resolution portion of FindForEachPatternMethod.\r\n            If no arguments are passed in, then an empty argument list will be used.\r\n            ":"\r\n            FindForeachPatternMethod的过载分辨率部分。\r\n            如果没有参数，则将使用一个空参数列表。\r\n            \r\n","\r\n              Looks up a localized string similar to The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion from '{3}' to '{1}'..\r\n            ":"\r\n              在通用类型或方法'{0}'中查找类似于类型的'{3}'类型的本地化字符串。从“ {3}”到'{1}'..没有拳击转换。\r\n            \r\n","\r\n              Looks up a localized string similar to The type '{2}' cannot be used as type parameter '{1}' in the generic type or method '{0}'. Nullability of type argument '{2}' doesn't match 'class' constraint..\r\n            ":"\r\n              在通用类型或方法'{0}'中查找类似于类型的'{2}'类型的本地化字符串。类型参数的无效性'{2}'不匹配'class'约束。\r\n            \r\n","'id#' syntax is no longer supported. Use '$id' instead.":"不再支持'id＃'语法。改用“ $ id”。\r\n","A throw statement with no arguments is not allowed outside of a catch clause":"不允许在渔获条款之外没有任何论点的投掷声明\r\n","Static field or property '{0}' cannot be assigned in an object initializer":"静态字段或属性'{0}'不能在对象初始化器中分配\r\n","\r\n            Reports top-level nullability problem in assignment.\r\n            Any conversion of the value should have been applied.\r\n            ":"\r\n            报告分配中的顶级无效问题。\r\n            该值的任何转换都应应用。\r\n            \r\n","The identifier name.":"标识符名称。\r\n","),\r\n            that symbol will be returned (i.e. the returned value will be reference-equal to one\r\n            reachable from the root of the symbol table). Symbols representing entities without names\r\n            (e.g. array-of-int) may or may not exhibit reference equality. However, some named symbols\r\n            (such as local variables) are not reachable from the root. These symbols are visible as\r\n            answers to semantic questions. When the same SemanticModel object is used, the answers\r\n            exhibit reference-equality.  \r\n            ":"），\r\n            该符号将被返回（即返回的值将是一个相等的\r\n            可以从符号表的根部到达）。代表没有名称的实体的符号\r\n            （例如，Int阵列）可能会或可能不会表现出参考平等。但是，一些命名符号\r\n            （例如局部变量）无法从根部到达。这些符号可见\r\n            语义问题的答案。当使用相同的senanticmodel对象时，答案\r\n            展示参考等效。\r\n            \r\n","\r\n            Method signature used for return type or parameter types. Distinct from _member\r\n            signature when _member is a lambda and type is inferred from MethodTypeInferrer.\r\n            ":"\r\n            用于返回类型或参数类型的方法签名。与_MEMBER不同\r\n            当_member是lambda时，签名是从MethodTypeinferrer推断出的。\r\n            \r\n","Creates a new SwitchStatementSyntax instance.":"创建一个新的SwitchStatementSyntax实例。\r\n","\r\n              Looks up a localized string similar to CLSCompliant attribute has no meaning when applied to return types.\r\n            ":"\r\n              查找类似于CLSCompliant属性的本地化字符串，当应用于返回类型时没有任何含义。\r\n            \r\n","XML comment has a param tag for '{0}', but there is no parameter by that name":"XML评论具有“ {0}”的param标签，但是没有该名称的参数\r\n","\r\n              Looks up a localized string similar to The first parameter of an 'in' extension method '{0}' must be a value type..\r\n            ":"查找类似于“扩展方法” {0}'的第一个参数类似的本地化字符串。\r\n            \r\n","\r\n            Returns true and a string from the first GuidAttribute on the assembly, \r\n            the string might be null or an invalid guid representation. False, \r\n            if there is no GuidAttribute with string argument.\r\n            ":"\r\n            返回true和一个从组件上的第一个指南中的字符串，\r\n            字符串可能为null或无效的GUID表示。错误的，\r\n            如果没有字符串参数的指南。\r\n            \r\n","\r\n            Lookup extension methods by name and arity in the given binder and\r\n            check viability in this binder. The lookup is performed on a single\r\n            binder because extension method search stops at the first applicable\r\n            method group from the nearest enclosing namespace.\r\n            ":"\r\n            在给定的粘合剂中使用名称和arity的查找扩展方法，\r\n            检查此活页夹中的生存能力。查找是在单个上执行的\r\n            活页夹，因为扩展方法搜索停止在第一个适用\r\n            方法组来自最近的封闭名称空间。\r\n            \r\n","Members of readonly field '{0}' cannot be modified (except in a constructor or a variable initializer)":"无法修改ReadOnly字段'{0}'的成员（在构造函数或变量初始器中除外）\r\n"," symbol\r\n            is actually among the symbols cached by this type symbol in a way that ensures\r\n            that any consumer of standard APIs to get to type's members is going to get the same \r\n            symbol (same instance) for the member rather than an equivalent, but different instance.\r\n            ":" 象征\r\n            实际上是通过这种类型符号缓存的符号之一，以确保\r\n            任何标准API的消费者都可以键入成员\r\n            符号（同一实例），而不是等效但不同的实例。\r\n            \r\n","\r\n            For performance reason, we don't validate the input length parameter against negative values.\r\n            It is expected Range will be used with collections which always have non negative length/count.\r\n            We validate the range is inside the length scope though.\r\n            ":"\r\n            出于性能原因，我们没有针对负值验证输入长度参数。\r\n            预计范围将与始终具有非负长度/计数的集合一起使用。\r\n            我们验证范围在长度范围内。\r\n            \r\n","\r\n              Looks up a localized string similar to Ambiguity between '{0}' and '{1}'.\r\n            ":"查找类似于“ {0}'和'{1}'之间的歧义的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to A default expression introduces a null value when '{0}' is a non-nullable reference type..\r\n            ":"\r\n              查找类似于默认表达式的本地化字符串，当'{0}'是不可删除的参考类型时引入null值。\r\n            \r\n","\r\n            Gets the last non-zero-width token of the tree rooted by this node.\r\n            ":"\r\n            获取由该节点扎根的树的最后一个非零宽度令牌。\r\n            \r\n","\r\n            Make the tests and variable bindings for the given pattern with the given input.  The pattern's\r\n            \"output\" value is placed in ":"\r\n            用给定输入对给定模式进行测试和可变绑定。图案的\r\n            “输出”值放入\r\n","Creates a new PropertyPatternClauseSyntax instance.":"创建一个新的propertypaternclausesyntax实例。\r\n","Creates a new ReturnStatementSyntax instance.":"创建一个新的returnstatementsyntax实例。\r\n","\r\n              Looks up a localized string similar to SyntaxTree '{0}' resulted from a #load directive and cannot be removed or replaced directly..\r\n            ":"\r\n              查找类似于语法'{0}'的本地化字符串，该字符串是由#load指令产生的，无法直接删除或直接替换。\r\n            \r\n","\r\n              Looks up a localized string similar to Error reading Win32 manifest file '{0}' -- '{1}'.\r\n            ":"\r\n              查找类似于错误读取Win32清单文件'{0}' - '{1}'的本地化字符串。\r\n            \r\n","\r\n            Mark a variable as assigned (or unassigned).\r\n            ":"\r\n            标记一个分配（或未分配）的变量。\r\n            \r\n","                vs. ":"                VS.\r\n"," for nullable expressions that are neither always null or\r\n            never null, and functionally equivalent parts for other cases.\r\n            ":" 对于既不始终为null也不是无效的表达式\r\n            永远不要零，并且在功能上等效零件。\r\n            \r\n","\r\n              Looks up a localized string similar to Local function is declared but never used.\r\n            ":"\r\n              查找与本地功能类似的本地化字符串，但从未使用过。\r\n            \r\n","'{1}' does not define type parameter '{0}'":"'{1}'不定义类型参数'{0}'\r\n","Field is assigned but its value is never used":"分配了字段，但其价值从未使用\r\n","Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available.":"破坏者和对象。无法直接调用。考虑呼叫idisposable.dispose（如果有）。\r\n","\r\n            Check that the given variable is definitely assigned when replaying local function\r\n            reads. If not, produce an error.\r\n            ":"\r\n            在重播本地功能时，检查给定变量是否肯定是分配的\r\n            阅读。如果没有，请产生错误。\r\n            \r\n","\r\n              Looks up a localized string similar to Async methods cannot have ref, in or out parameters.\r\n            ":"\r\n              查找类似于异步方法的本地化字符串，不可能具有参数或输出参数。\r\n            \r\n","\r\n            This method is called during attribute binding after EarlyDecodeWellKnownAttributeTypes has been executed.\r\n            Symbols should default initialize the data for early decoded well-known attributes here.\r\n            ":"\r\n            在执行早期decodewellnoningattributetypes之后，在属性绑定期间调用此方法。\r\n            符号应默认在此处初始解码众所周知的属性初始化数据。\r\n            \r\n","Compiler name":"编译器名称\r\n","\r\n              Looks up a localized string similar to Cannot use a collection of dynamic type in an asynchronous foreach.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法在异步方面使用动态类型的集合。\r\n            \r\n","Cannot initialize an implicitly-typed variable with an array initializer":"无法使用数组初始化器初始化隐式型变量\r\n","\r\n              Looks up a localized string similar to Cannot use '{0}' as a ref or out value because it is read-only.\r\n            ":"\r\n              查找类似于不能使用'{0}'的局部字符串作为ref或外出值，因为它是只读的。\r\n            \r\n","\r\n            Returns true if this symbol was declared to override a base class member and was also\r\n            sealed from further overriding; i.e., declared with the \"sealed\" modifier.  Also set for\r\n            types that do not allow a derived class (declared with \"sealed\" or \"static\" or \"struct\"\r\n            or \"enum\" or \"delegate\").\r\n            ":"\r\n            如果该符号被宣布覆盖小型班级成员，则返回为true\r\n            从进一步的覆盖中密封；即，用“密封”修饰符声明。也设定\r\n            不允许派生类的类型（用“密封”或“静态”或“结构”声明\r\n            或“枚举”或“委托”）。\r\n            \r\n","\r\n              Looks up a localized string similar to ) expected.\r\n            ":"\r\n              查找类似于预期的局部字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to Unrecognized escape sequence.\r\n            ":"\r\n              查找类似于未识别的逃生序列的局部字符串。\r\n            \r\n","\r\n            Used by Add*LookupSymbolsInfo* to determine whether the symbol is of interest.\r\n            Distinguish from ":"\r\n            Add*LookupSymbolsInfo*用于确定符号是否感兴趣。\r\n            区别于 \r\n",", which performs an analogous task for Add*LookupSymbolsInfo*.\r\n            ":"，它为Add*LookupSymbolsInfo*执行类似的任务。\r\n            \r\n","\r\n            The candidate member was rejected because an argument could not be converted to the appropriate parameter\r\n            type.\r\n            ":"\r\n            候选人成员被拒绝，因为不能将一个参数转换为适当的参数\r\n            类型。\r\n            \r\n","This method is a port of TypeManager::ImportDynamicTransformType from the native compiler.":"此方法是来自本机编译器的TypeManager :: importdynamictransformtype的端口。\r\n","Assembly and module attributes must precede all other elements defined in a file except using clauses and extern alias declarations":"汇编和模块属性必须先于文件中定义的所有其他元素，除非使用条款和外部别名声明\r\n","A syntax node that represents a parsed expression body. This node should not be\r\n            present in the syntax tree associated with this object.":"代表解析表达主体的语法节点。这个节点不应该是\r\n            存在与此对象关联的语法树中。\r\n","Called when the visitor visits a ConstantPatternSyntax node.":"当访问者访问常数patternsyntax节点时，请致电。\r\n","Gets the struct keyword token.":"获取struct关键字令牌。\r\n","Provides the base class from which the classes that represent anonymous function expressions are derived.":"提供了代表匿名函数表达式的类的基类。\r\n","TypeSyntax node representing the type the expression is being casted to.":"表示表达式所施放的类型的型尺寸节点。\r\n","Called when the visitor visits a FunctionPointerUnmanagedCallingConventionListSyntax node.":"当访问者访问fintunPoInterunManagedCallingConconcentlistsyntax节点时，请致电。\r\n","\r\n            Gets the diagnostics produced during the parsing stage of a compilation. There are no diagnostics for declarations or accessor or\r\n            method bodies, for example.\r\n            ":"\r\n            获取在汇编的解析阶段产生的诊断。没有诊断声明或访问者或\r\n            例如，方法主体。\r\n            \r\n","\r\n            This binder owns and lazily creates the map of SyntaxNodes to Binders associated with\r\n            the syntax with which it is created. This binder is not created in reaction to any\r\n            specific syntax node type. It is inserted into the binder chain\r\n            between the binder which it is constructed with and those that it constructs via\r\n            the LocalBinderFactory. \r\n            ":"\r\n            该粘合剂拥有并懒惰地创建了与与Binders相关的Binders的语法图。\r\n            它创建的语法。此粘合剂并非对任何\r\n            特定的语法节点类型。它被插入粘合剂链\r\n            在与之构造的粘合剂之间以及通过\r\n            LocalBinderFactory。\r\n            \r\n","\r\n              Looks up a localized string similar to Must call SetMethodTestData(ConcurrentDictionary) before calling SetMethodTestData(MethodSymbol, ILBuilder).\r\n            ":"\r\n              在调用setMethodtestdata（MethodSymbol，iLbuilder）之前，请查找类似于setMethodtestdata（consurrentDictionary）必须调用的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to The label '{0}' is a duplicate.\r\n            ":"\r\n              查找类似于标签'{0}'的本地化字符串是重复的。\r\n            \r\n","\r\n            If implementation of an interface method ":"\r\n            如果实现接口方法\r\n","Expression-bodied methods and properties":"表达体现的方法和属性\r\n","The length of the collection that the range will be used with. length has to be a positive value.":"范围将使用的集合的长度。长度必须是一个正值。\r\n","\r\n            Used to detect whether we are in a cref parameter type.\r\n            ":"\r\n            用于检测我们是否处于CREF参数类型中。\r\n            \r\n","\r\n              Looks up a localized string similar to default interface implementation.\r\n            ":"\r\n              查找类似于默认接口实现的本地化字符串。\r\n            \r\n","\r\n            Slight rewrite to make it more idiomatic for C#:\r\n                a) X_i is covariant and A_i is input-unsafe\r\n                b) X_i is contravariant and A_i is output-unsafe\r\n                c) X_i is invariant and A_i is input-unsafe or output-unsafe\r\n            ":"\r\n            轻微的重写使其对C＃更惯用：\r\n                a）x_i是协变量的，a_i是输入 - 不安全\r\n                b）x_i是违反的，a_i是输出 - 不安全\r\n                c）x_i是不变的，a_i是输入-UNSAFE或UNPOUST-UNSAFE\r\n            \r\n","Node being assigned to.":"分配给的节点。\r\n","Records":"记录\r\n","The character(s) '{0}' cannot be used at this location.":"角色（s）'{0}'不能在此位置使用。\r\n","Allocated instance is not disposed along all exception paths":"分配的实例并未沿所有异常路径处置\r\n"," Properties defined in the template ":" 模板中定义的属性\r\n","The compilation references multiple assemblies whose versions only differ in auto-generated build and/or revision numbers.":"汇编引用了多个组件，其版本仅在自动生成的构建和/或修订号上有所不同。\r\n","\r\n            Lower \"using (ResourceType resource = expression) statement\" to a try-finally block.\r\n            ":"\r\n            较低的“使用（ResourceType Resource =表达式）语句”到一个尝试块。\r\n            \r\n","\r\n              Looks up a localized string similar to '{0}': cannot override inherited member '{1}' because it is not marked virtual, abstract, or override.\r\n            ":"\r\n              查找类似于'{0}'：无法覆盖的局部字符串，因为它没有标记为虚拟，抽象或覆盖。\r\n            \r\n","\r\n            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means pointing at beyond last element.\r\n            ":"\r\n            如果从末端构造的索引，索引值1表示指向最后一个元素，索引值0表示指向最后一个元素。\r\n            \r\n","Deconstructable1.Deconstruct(out int y1, out Deconstructable2 y2)":"解构1.deconstruct（out int y1，out deconstructable2 y2）\r\n","Called when the visitor visits a QualifiedCrefSyntax node.":"当访问者访问合格的crefsyntax节点时，请致电。\r\n","\r\n            If this method has MethodKind of MethodKind.PropertyGet or MethodKind.PropertySet,\r\n            returns the property that this method is the getter or setter for.\r\n            If this method has MethodKind of MethodKind.EventAdd or MethodKind.EventRemove,\r\n            returns the event that this method is the adder or remover for.\r\n            Note, the set of possible associated symbols might be expanded in the future to \r\n            reflect changes in the languages.\r\n            ":"\r\n            如果此方法具有MethodKind.propertyget或MethodKind.propertyset的MethodKind，则\r\n            返回此方法是Getter或setter的属性。\r\n            如果此方法具有MethodKind.eventadd或MethodKind.eventremove的MethodKind，则\r\n            返回此方法是加法器或去除剂的事件。\r\n            注意，将来可能会扩展一组可能的相关符号\r\n            反映语言的变化。\r\n            \r\n"," type with dynamic type.\r\n            ":" 具有动态类型的类型。\r\n            \r\n","\r\n            Gets the BaseType of this type. If the base type could not be determined, then \r\n            an instance of ErrorType is returned. If this kind of type does not have a base type\r\n            (for example, interfaces), null is returned. Also the special class System.Object\r\n            always has a BaseType of null.\r\n            ":"\r\n            获取这种类型的底套。如果无法确定基本类型，则\r\n            返回错误类型的实例。如果这种类型没有基本类型\r\n            （例如，接口），返回空。还有特殊类系统。\r\n            始终具有零的底型。\r\n            \r\n","Structs without explicit constructors cannot contain members with initializers.":"没有明确构造函数的结构不能包含具有初始化器的成员。\r\n","The variable '{0}' is declared but never used":"变量'{0}'被声明但从未使用\r\n",".\r\n            \r\n             To keep the stack frame size on recursive paths small the non-recursive parts are factored into local \r\n             functions. This means we pay their stack penalty only when they are used. They are themselves big \r\n             enough they should be disqualified from inlining. In the future when attributes are allowed on \r\n             local functions we should explicitly mark them as ":"。\r\n            \r\n             为了将堆栈框架的尺寸保持在递归路径上的小小\r\n             功能。这意味着我们只有在使用时才支付堆栈罚款。他们自己很大\r\n             足以使他们不合格。将来允许属性\r\n             本地功能我们应该明确将它们标记为\r\n","This warning can be generated when two interface methods are differentiated only by whether a particular parameter is marked with ref or with out. It is best to change your code to avoid this warning because it is not obvious or guaranteed which method is  ...":"只有通过用REF标记还是用OUT来区分两个接口方法时，才能生成此警告。最好更改您的代码以避免此警告，因为它不明显或保证哪种方法是...\r\n","\r\n            What we need to do is find a *repeatable* arbitrary way to choose between\r\n            two errors; we can for example simply take the one that is lower in alphabetical\r\n            order when converted to a string.  As an optimization, we compare error codes\r\n            first and skip string comparison if they differ.\r\n            ":"\r\n            我们需要做的是找到一种 *可重复的 *任意方法来选择\r\n            两个错误；例如，我们可以简单地将字母顺序较低的一个以较低\r\n            转换为字符串时订购。作为优化，我们比较错误代码\r\n            首先，跳过字符串比较是否有所不同。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot use ref, out, or in parameter '{0}' inside an anonymous method, lambda expression, query expression, or local function.\r\n            ":"\r\n              在匿名方法，lambda表达式，查询表达式或局部函数中查找类似于无法使用REF，OUT或参数'{0}'中的本地化字符串。\r\n            \r\n","\r\n              Looks up a localized string similar to The 'unmanaged' constraint must come before any other constraints.\r\n            ":"\r\n              查找类似于“未管理”约束的本地化字符串必须在任何其他约束之前进行。\r\n            \r\n","\r\n              Looks up a localized string similar to You can only take the address of an unfixed expression inside of a fixed statement initializer.\r\n            ":"\r\n              查找类似于您的本地化字符串，只能在固定语句初始化器内的未固定表达式的地址。\r\n            \r\n","'{0}' cannot be both abstract and sealed":"'{0}'不能既抽象又密封\r\n","Called when the visitor visits a TypeParameterConstraintClauseSyntax node.":"当访问者访问typeparameterconstclausesyntax节点时，请致电。\r\n","\r\n              Looks up a localized string similar to '{0}' does not contain a definition for '{1}' and no accessible extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive or an assembly reference?).\r\n            ":"\r\n              查找类似于'{0}'的本地化字符串不包含'{1}''的定义，并且没有可访问的扩展方法'{1}'接受类型'{0}'的第一个参数（您是您是否（您是您）缺少使用指令或汇编引用？）。\r\n            \r\n","A BoundExpression representing the call.":"表示调用的BoundExpression。\r\n","\r\n            Gets the root namespace that contains all namespaces and types defined in source code or in \r\n            referenced metadata, merged into a single namespace hierarchy.\r\n            ":"\r\n            获取包含所有名称空间和源代码中定义的类型的根名称空间\r\n            引用元数据，合并为单个名称空间层次结构。\r\n            \r\n","Preprocessor directive expected":"预期预期预期\r\n","Returns true if Boolean is present and healthy.":"如果布尔人在场且健康，返回是正确的。\r\n","Destructor declaration syntax.":"驱动器声明语法。\r\n","\r\n             Both `oldChanges` and `newChanges` must contain non-overlapping spans in ascending order.\r\n             ":"\r\n             “ Oldchanges”和`newchanges''都必须按上升顺序包含非重叠的跨度。\r\n             \r\n","\r\n            If there are no constraints, returns an empty immutable array. Otherwise, returns an immutable\r\n            array of clauses, indexed by the constrained type parameter in ":"\r\n            如果没有约束，则返回一个空的不变阵列。否则，返回不变的\r\n            条款数组，由约束类型参数索引\r\n","\r\n            Visit the given type and, in the case of compound types, visit all \"sub type\"\r\n            (such as A in A[], or { A<T>, T, U } in A<T>.B<U>) invoking 'predicate'\r\n            with the type and 'arg' at each sub type. If the predicate returns true for any type,\r\n            traversal stops and that type is returned from this method. Otherwise if traversal\r\n            completes without the predicate returning true for any type, this method returns null.\r\n            ":"访问给定的类型，对于复合类型，请访问所有“子类型”\r\n            （例如A []或{a <t>，t，u}中的a <t> .b <u>）调用“谓词”\r\n            在每个子类型上使用类型和“ arg”。如果任何类型的谓词返回true，\r\n            遍历停止，该类型是从此方法返回的。否则，如果遍历\r\n            该方法在没有谓词返回的情况下完成，此方法返回null。\r\n            \r\n","\r\n              Looks up a localized string similar to Cannot create an instance of the variable type '{0}' because it does not have the new() constraint.\r\n            ":"\r\n              查找类似于类似的本地化字符串无法创建变量类型'{0}'的实例，因为它没有新（）约束。\r\n            \r\n","\r\n            Meet two nullable annotations for computing the nullable annotation of a type parameter from upper bounds.\r\n            This uses the contravariant merging rules. (NotAnnotated wins over Oblivious which wins over Annotated)\r\n            ":"\r\n            满足两个无效的注释，以计算上限的类型参数的无效注释。\r\n            这使用违反合并规则。 （毫无意义地赢得了胜利的胜利）\r\n            \r\n","\r\n              Looks up a localized string similar to The property or indexer '{0}' cannot be used in this context because the get accessor is inaccessible.\r\n            ":"\r\n              在此上下文中查找类似于属性或索引器'{0}'的本地化字符串，因为GET登录器无法访问。\r\n            \r\n","The CallerMemberNameAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments":"应用于参数'{0}'的callermemberneattribute将无效，因为它适用于不允许可选参数的上下文中使用的成员\r\n",", either through caching the result or by using\r\n            ":"，通过缓存结果或使用\r\n            \r\n","\r\n              Looks up a localized string similar to Array creation must have array size or array initializer.\r\n            ":"\r\n              查找类似于数组创建的本地化字符串必须具有数组大小或数组初始化器。\r\n            \r\n","'{0}': a field cannot be both volatile and readonly":"'{0}'：一个字段不能既波动又可读\r\n","\r\n            Given a using declaration get the corresponding symbol for the using alias that was introduced.  \r\n            ":"\r\n            给定使用声明获取引入的使用别名的相应符号。\r\n            \r\n","\r\n            Maybe null (type is nullable).\r\n            ":"\r\n            也许null（类型是无效的）。\r\n            \r\n","\r\n            We should be intentional about behavior of derived classes regarding guarding against stack overflow.\r\n            ":"\r\n            我们应该有意地考虑派生类的行为，以防止堆栈溢出。\r\n            \r\n","\r\n            Gets a SyntaxToken that represents a case or default keyword that belongs to a switch label.\r\n            ":"\r\n            获取一个代表属于交换标签的情况或默认关键字的语法。\r\n            \r\n","'{0}': abstract event cannot have initializer":"'{0}'：抽象事件不能具有初始化器\r\n","\r\n            Holds onto data related to reference binding.\r\n            The manager is shared among multiple compilations that we expect to have the same result of reference binding.\r\n            In most cases this can be determined without performing the binding. If the compilation however contains a circular \r\n            metadata reference (a metadata reference that refers back to the compilation) we need to avoid sharing of the binding results.\r\n            We do so by creating a new reference manager for such compilation. \r\n            ":"\r\n            保留与参考绑定有关的数据。\r\n            经理在多个汇编中共享，我们期望具有参考绑定的结果相同。\r\n            在大多数情况下，这可以在不执行结合的情况下确定。但是，如果汇编包含一个圆形\r\n            元数据参考（元数据引用回编译），我们需要避免共享结合结果。\r\n            我们通过为这种编译创建新的参考经理来做到这一点。\r\n            \r\n","\r\n             Variables local to current frame do not need temps when re-read multiple times\r\n             as long as there is no code that may write to locals in between accesses and they\r\n             are not captured.\r\n             \r\n             Example:\r\n                    l += goo(ref l);\r\n             \r\n             even though l is a local, we must access it via a temp since \"goo(ref l)\" may change it\r\n             on between accesses.\r\n            \r\n             Note: In ":"\r\n             当重新阅读多次阅读时，本地到当前帧本地帧不需要温度\r\n             只要没有代码可以在访问之间写给当地人，他们\r\n             没有被捕获。\r\n             \r\n             例子：\r\n                    l +=粘胶（ref l）;\r\n             \r\n             即使L是本地人，我们也必须通过温度访问它，因为“ Goo（Ref L）可能会改变它\r\n             在两次访问之间。\r\n            \r\n             注意：in\r\n","\r\n            If the record type is derived from a base record type Base, the record type includes\r\n            a synthesized override of the strongly-typed Equals(Base other). The synthesized\r\n            override is sealed. It is an error if the override is declared explicitly.\r\n            The synthesized override returns Equals((object?)other).\r\n            ":"\r\n            如果记录类型是从基本记录类型基础派生的，则记录类型包括\r\n            强大的替代（基础）合成的替代。合成的\r\n            覆盖被密封。如果明确声明覆盖物，则是错误。\r\n            合成的替代返回等于（（对象？）其他）。\r\n            \r\n","?\r\n            'true' if the matched type catches all of them, 'false' if it catches none of them, and\r\n            'null' if it might catch some of them.\r\n            ":"？\r\n            如果匹配的类型抓住了所有这些，则“ true”，“ false”，如果它没有抓住它们，并且\r\n            “ null”如果可能会抓住其中的一些。\r\n            \r\n","Creates a new FunctionPointerUnmanagedCallingConventionListSyntax instance.":"创建一个新的forcormpoInterunManagedCallingConconcentlistSyntax实例。\r\n","Alias '{0}' not found":"别名'{0}'找不到\r\n","The type implementing the interface property (usually \"this\").":"实现接口属性的类型（通常是“this”）。\r\n","\r\n              Looks up a localized string similar to Expected catch or finally.\r\n            ":"\r\n              查找类似于预期捕获或最后的局部字符串。\r\n            \r\n","\r\n            Will have all other members with the same signature (including custom modifiers) as \r\n            representativeMember added.\r\n            ":"\r\n            所有其他成员都具有相同的签名（包括自定义修饰符）\r\n            添加了代表编号。\r\n            \r\n","\r\n            Returns true if the parameter explicitly specifies a default value to be passed\r\n            when no value is provided as an argument to a call. \r\n            ":"\r\n            如果参数明确指定要传递的默认值，则返回true\r\n            当不提供值作为呼叫的参数时。\r\n            \r\n","Lambda improvements":"Lambda的改进\r\n","Target kind (by-ref or not).":"目标种类（或不通过）。\r\n","This method is used to determine the method kind of\r\n            a PEMethodSymbol, so we may need to avoid using MethodKind until we move on to a different\r\n            MethodSymbol.":"此方法用于确定方法\r\n            pemethodsymbol，因此我们可能需要避免使用MethodKind，直到我们继续前进\r\n            方法符号。\r\n","\r\n              Looks up a localized string similar to Cannot specify a default value for a parameter array.\r\n            ":"\r\n              查找类似于类似的本地化字符串，无法指定参数数组的默认值。\r\n            \r\n","There is an error in a referenced assembly '{0}'.":"引用汇编'{0}'中存在错误。\r\n","\r\n            Map from switch section's syntax to the lowered code for the section. The code for a section\r\n            includes the code to assign to the pattern variables and evaluate the when clause. Since a\r\n            when clause can yield a false value, it can jump back to a label in the lowered decision dag.\r\n            ":"\r\n            从开关部分的语法映射到该部分的降低代码。部分的代码\r\n            包括将代码分配给模式变量并评估何时子句。自从\r\n            当子句产生一个错误的值时，它可以跳回降低的决策DAG中的标签。\r\n            \r\n","\r\n            Binder that should be used to bind initializer, if different from the ":"如果不同的粘合剂应用于绑定初始化器\r\n","\r\n            Gets the syntax list of custom attributes applied on the event symbol.\r\n            ":"\r\n            获取在事件符号上应用的自定义属性的语法列表。\r\n            \r\n","\r\n              Looks up a localized string similar to A previous catch clause already catches all exceptions.\r\n            ":"\r\n              查找类似于以前的捕获子句的本地化字符串已经捕获所有异常。\r\n            \r\n","\r\n            Collection of names of members declared within this type. May return duplicates.\r\n            ":"\r\n            在此类型中声明的成员名称的集合。可以返回重复项。\r\n            \r\n","\r\n              Looks up a localized string similar to Identifier differing only in case is not CLS-compliant.\r\n            ":"\r\n              查找类似于仅在CLS兼容的情况下不同的标识符类似的局部字符串。\r\n            \r\n","An anonymous method expression cannot be converted to an expression tree":"匿名方法表达式无法转换为表达树\r\n","The attribute {0} has an invalid value of {1}.":"属性{0}的值无效为{1}。\r\n","\r\n            Cached \"this\" local, used to store the captured \"this\", which is safe to cache locally since \"this\" \r\n            is semantically immutable.\r\n            It would be hard for such caching to happen at JIT level (since JIT does not know that it never changes).\r\n            NOTE: this field is null when we are not caching \"this\" which happens when\r\n                  - not optimizing\r\n                  - method is not capturing \"this\" at all\r\n                  - containing type is a struct \r\n                  (we could cache \"this\" as a ref local for struct containers, \r\n                  but such caching would not save as much indirection and could actually \r\n                  be done at JIT level, possibly more efficiently)\r\n            ":"\r\n            缓存的“这个”本地，用于存储捕获的“此”，这是可以在本地缓存的，因为“此”\r\n            在语义上是不变的。\r\n            这种缓存在JIT级别上很难发生（因为JIT不知道它永远不会改变）。\r\n            注意：当我们不缓存“此”时，此字段是无效的\r\n                   - 不优化\r\n                   - 方法根本没有捕获“这个”\r\n                   - 包含类型是结构\r\n                  （我们可以作为结构容器的REF局部缓存“此”，\r\n                  但是这种缓存不会节省太多的间接，实际上可以\r\n                  在JIT级别完成，可能更有效）\r\n            \r\n","The namespace of the potentially forwarded type. If none is provided, will\r\n            try Usings of the current import for eligible namespaces and return the namespace of the found forwarder, \r\n            if any.":"潜在转发类型的名称空间。如果没有提供\r\n            尝试使用合格名称空间的当前导入的使用，然后返回找到的转发器的名称空间，\r\n            如果有的话。\r\n","\r\n              Looks up a localized string similar to Called GetDeclarationName for a declaration node that can possibly contain multiple variable declarators..\r\n            ":"\r\n              查找类似于可能包含多个变量声明器的声明节点的局部字符串。\r\n            \r\n","\r\n            The decision tree is a transient data structure used during initial binding to compute which\r\n            cases in a switch are subsumed by previous cases, and in lowering to help produce the lowered\r\n            form.\r\n            ":"\r\n            决策树是初始绑定期间使用的瞬态数据结构，以计算哪个\r\n            开关中的案例被以前的案例所包含，并降低以帮助产生降低的\r\n            形式。\r\n            \r\n","Containing symbol type arguments.":"包含符号类型参数。\r\n","Alignment value {0} has a magnitude greater than {1} and may result in a large formatted string.":"对齐值{0}的幅度大于{1}，可能会导致一个格式化的字符串。\r\n"}